<a name="top"></a>

[–ù–∞ –≥–ª–∞–≤–Ω—É—é](../README.md)

[–ü–µ—Ä–µ–π—Ç–∏ –∫ –≤–æ–ø—Ä–æ—Å–∞–º](#questions)

| ‚Ññ. | –í–æ–ø—Ä–æ—Å |
| --- | --------- |
|   | JavaScript Grundlagen |
|1 | [Klassifizierung von Datentypen, Typumwandlung](#1) |
|2 | [Unterschied zwischen null und undefined](#2) |
|3 | [Variablen let, const, var. Strikter Modus](#3) |
|4 | [Interaktion mit dem Benutzer: alert(), prompt(), confirm()](#4) |
|5 | [Interpolation (ES6)](#5) |
|6 | [Operatoren in JavaScript](#6) |
|7 | [Bedingungen](#7) |
|8 | [Schleifen, verschachtelte Schleifen, Labels](#8) |
|9 | [Hoisting (Hochheben von Variablen und Funktionen)](#9) |
|10 | [Ausf√ºhrungskontext, Lexikalische Umgebung](#10) |
|11 | [Tempor√§re Totzone (Temporal Dead Zone)](#11) |
|12 | [typeof ‚Äì wie erkennt man den Typ eines Werts?](#12) |
|13 | [Warum haben primitive Datentypen Methoden? Was ist Autoboxing?](#13) |
|14 | [Garbage Collector in JavaScript](#14) |
|15 | [](#15) |
|16 | [](#16) |
|17 | [](#17) |
|18 | [](#18) |
|19 | [](#19) |
|20 | [](#20) |
|   | Funktionen und ihre Besonderheiten |
|21 | [Funktionen, Pfeilfunktionen, IIFE](#21) |
|22 | [Methoden zur Kontextbindung (call, apply, bind)](#22) |
|23 | [Closures (Abschl√ºsse)](#23) |
|24 | [Callback-Funktionen](#24) |
|25 | [Konstruktor-Funktionen](#25) |
|26 | [Aufrufkontext (this)](#26) |
|27 | [Getter und Setter (Objekteigenschaften)](#27) |
|28 | [Generatorfunktionen](#28) |
|29 | [Rekursion](#29) |
|30 | [](#30) |
|   | Arbeiten mit Objekten |
|31 | [Objekte, Destrukturierung von Objekten (ES6)](#31) |
|32 | [Methoden Object, Object.prototype](#32) |
|33 | [M√∂glichkeiten zur Objekterstellung](#33) |
|34 | [Kopieren von Objekten](#34) |
|35 | [Property Descriptors (Eigenschaftsbeschreibungen)](#35) |
|36 | [Private und gesch√ºtzte Eigenschaften von Objekten](#36) |
|37 | [Prototypen, Prototypen-Kette](#37) |
|38 | [Object.create()](#38) |
|39 | [Unterschied zwischen klassischer und prototypischer Vererbung](#39) |
|40 | [](#40) |
|   | Arrays und Sammlungen |
|41 | [Arrays und Pseudo-Arrays, Array-Destrukturierung](#41) |
|42 | [Methoden Array, Array.prototype](#42) |
|43 | [Kopieren von Arrays](#43) |
|44 | [Map, Set, WeakSet, WeakMap](#44) |
|45 | [Live Collections (lebendige Sammlungen)](#45) |
|46 | [](#46) |
|47 | [](#47) |
|48 | [](#48) |
|49 | [](#49) |
|50 | [](#50) |
|   | Moderne JavaScript-Funktionen |
|51 | [Spread-Operator (ES6-ES9)](#51) |
|52 | [Rest-Operator und Standardparameter (ES6)](#52) |
|53 | [Symbol](#53) |
|54 | [BigInt](#54) |
|55 | [Module import/export (ES6) & CommonJS](#55) |
|56 | [](#56) |
|57 | [](#57) |
|58 | [](#58) |
|59 | [](#59) |
|60 | [](#60) |
|   | Ereignisse und DOM-Manipulation |
|61 | [Ereignisse und ihre Handler](#61) |
|62 | [Ereignis-Bubbling (event bubbling)](#62) |
|63 | [Ereignis-Delegation](#63) |
|64 | [Unterschied zwischen load und DOMContentLoaded](#64) |
|65 | [Elemente von der Seite abrufen](#65) |
|66 | [Methoden zum Abrufen von DOM-Elementen in JavaScript](#66) |
|67 | [Navigation durch DOM-Elemente](#67) |
|68 | [classList, className und Ereignisdelegation](#68) |
|69 | [Manipulation von Seitenelementen](#69) |
|70 | [Dokument- und Fensterparameter sowie deren Nutzung](#70) |
|71 | [Web Animations API](#71) |
|72 | [requestAnimationFrame](#72) |
|73 | [](#73) |
|74 | [](#74) |
|75 | [](#75) |
|   | Asynchronit√§t und Serverkommunikation |
|76 | [setTimeout und setInterval, Besonderheiten](#76) |
|77 | [AJAX und XMLHttpRequest](#77) |
|78 | [Promise (ES6)](#78) |
|79 | [Fetch API](#79) |
|80 | [Async/Await (ES8)](#80) |
|81 | [try...catch, throw-Anweisung](#81) |
|82 | [Axios-Bibliothek](#82) |
|83 | [Event Loop, synchrone und asynchrone Operationen](#83) |
|84 | [M√∂glichkeiten zum Senden von Serveranfragen](#84) |
|85 | [Long Polling (Langes Abfragen)](#85) |
|86 | [Web Socket](#86) |
|87 | [Was sind Web Workers und wof√ºr braucht man sie?](#87) |
|88 | [](#88) |
|89 | [](#89) |
|90 | [](#90) |
|   | Fortgeschrittene Themen |
|91 | [Klassen (ES6)](#91) |
|92 | [Klassenvererbung, private und gesch√ºtzte Eigenschaften](#92) |
|93 | [Kapselung (Encapsulation)](#93) |
|94 | [Was ist funktionale Programmierung? Grundlagen (First-Class-Funktionen, Higher-Order-Funktionen, Pure Functions, Immutability, Lazy Evaluation usw.)](#94) |
|95 | [Regul√§re Ausdr√ºcke (RegExp)](#95) |
|96 | [JSON](#96) |
|97 | [](#97) |
|98 | [](#98) |
|99 | [](#99) |
|100 | [](#100) |
|   | Praktische Aufgaben |
|101 | [Erstellen von Tabs in einem Projekt](#101) |
|102 | [Countdown-Timer](#102) |
|103 | [Modales Fenster](#103) |
|104 | [Slider](#104) |
|105 | [Rechner](#105) |
|106 | [](#106) |
|107 | [](#107) |
|108 | [](#108) |
|109 | [](#109) |
|110 | [](#110) |



<a name="questions"></a>

## JavaScript Grundlagen

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**
  
1. ### <a name="1"></a> Klassifizierung von Datentypen, Typumwandlung

### **Datentypen in JavaScript**  

In JavaScript gibt es **primitive Datentypen** und **Referenztypen**.  

---

## **1. Primitive Datentypen (Werte werden direkt gespeichert)**  
Primitive Datentypen sind **immutable** (unver√§nderlich) und speichern Werte direkt im Speicher.

| Datentyp   | Beschreibung | Beispiel |
|------------|-------------|-----------|
| **`string`** | Zeichenkette | `"Hallo"`, `'Test'`, `` `Template` `` |
| **`number`** | Zahlen (Ganzzahlen, Dezimal, `NaN`, `Infinity`) | `42`, `3.14`, `NaN`, `Infinity` |
| **`bigint`** | Sehr gro√üe Ganzzahlen | `123456789012345678901234567890n` |
| **`boolean`** | Wahrheitswerte | `true`, `false` |
| **`undefined`** | Variable wurde deklariert, aber nicht zugewiesen | `let x; console.log(x); // undefined` |
| **`null`** | Bewusste "leere" Variable | `let y = null;` |
| **`symbol`** | Einzigartige, unver√§nderliche Identifikatoren | `let id = Symbol("id");` |

```js
let name = "Max"; // string
let alter = 25; // number
let isStudent = true; // boolean
let nichts = null; // null
let unbestimmt; // undefined
let gro√üeZahl = 123456789012345678901n; // bigint
let uniqueKey = Symbol("key"); // symbol
```

---

## **2. Referenztypen (Speichern Verweise auf Objekte im Speicher)**
Referenztypen speichern **Referenzen** auf Speicherorte, nicht die Werte direkt.

| Datentyp   | Beschreibung | Beispiel |
|------------|-------------|-----------|
| **`object`** | Sammlungen von Werten als Key-Value-Paare | `{name: "Max", alter: 25}` |
| **`array`** | Listen von Werten | `[1, 2, 3, "Test"]` |
| **`function`** | Funktionen sind Objekte | `function add(a, b) { return a + b; }` |
| **`date`** | Datum und Zeit | `new Date()` |
| **`RegExp`** | Regul√§re Ausdr√ºcke | `/abc/i` |

```js
let person = { name: "Max", alter: 25 }; // Objekt
let zahlen = [1, 2, 3, 4]; // Array
function sagHallo() { console.log("Hallo!"); } // Funktion
let heute = new Date(); // Datum
let regex = /abc/i; // Regul√§rer Ausdruck
```

---

## **3. Unterschiede zwischen Primitiven und Referenztypen**
| Eigenschaft | Primitive Typen | Referenztypen |
|------------|----------------|--------------|
| Speicherort | Direkt im Stack gespeichert | Verweis auf Speicheradresse im Heap |
| Vergleich | Vergleicht Werte (`===` und `==` gleich) | Vergleicht Speicherreferenzen (`{}` !== `{}`) |
| Ver√§nderbarkeit | **Immutable** (Wert kann nicht direkt ge√§ndert werden) | **Mutable** (Werte innerhalb des Objekts/Arrays k√∂nnen ge√§ndert werden) |

```js
let a = 5;
let b = a;
b = 10;
console.log(a); // 5 (unver√§ndert)

let obj1 = { name: "Max" };
let obj2 = obj1; // Referenz auf dasselbe Objekt
obj2.name = "Anna";
console.log(obj1.name); // "Anna" (beide verweisen auf dasselbe Objekt)
```

---

## **4. Sonderf√§lle**
### **Falsy und Truthy Werte**
#### **Falsy-Werte (`Boolean(wert) ‚Üí false`)**
Diese Werte werden als `false` interpretiert:
```js
false, 0, "", null, undefined, NaN
```

#### **Truthy-Werte (`Boolean(wert) ‚Üí true`)**
Alle anderen Werte sind `true`, z. B.:
```js
"0", "false", [], {}, function() {}, Infinity
```

```js
console.log(Boolean(0)); // false
console.log(Boolean("")); // false
console.log(Boolean([])); // true (leeres Array ist truthy)
console.log(Boolean({})); // true (leeres Objekt ist truthy)
```

---

## **5. Dynamische Typisierung in JavaScript**
JavaScript ist eine **dynamisch typisierte** Sprache, d. h., eine Variable kann den Typ zur Laufzeit √§ndern:
```js
let x = "Hallo"; // String
x = 42; // Jetzt eine Zahl
x = true; // Jetzt ein Boolean
console.log(x); // true
```

---

### **Zusammenfassung**
‚úÖ **Primitive Typen** speichern Werte direkt und sind immutable.  
‚úÖ **Referenztypen** speichern Verweise auf Objekte und sind ver√§nderbar.  
‚úÖ **Vergleich von Referenztypen** erfolgt √ºber Speicherreferenzen.  
‚úÖ **Falsy-Werte** sind `0, "", null, undefined, NaN`.  
‚úÖ **Dynamische Typisierung** erlaubt das √Ñndern von Typen zur Laufzeit.


### **Typumwandlung in JavaScript (Type Conversion)**

In JavaScript gibt es zwei Arten der Typumwandlung:
1. **Implizite Typumwandlung (Type Coercion)** ‚Üí Automatische Konvertierung durch JavaScript  
2. **Explizite Typumwandlung (Type Casting)** ‚Üí Manuelle Konvertierung durch den Entwickler

---

## **1. Implizite Typumwandlung (Automatische Umwandlung)**
JavaScript wandelt Werte automatisch um, wenn sie in bestimmten Operationen verwendet werden.

### **String-Konkatenation mit `+` (Zahl ‚Üí String)**
```js
console.log("10" + 5); // "105" (Zahl wird zu String)
console.log(5 + "10"); // "510"
console.log("Hello " + true); // "Hello true"
```

### **Arithmetische Operationen (`-`, `*`, `/`) (String ‚Üí Zahl)**
```js
console.log("10" - 5); // 5 ("10" wird zu 10)
console.log("6" * "2"); // 12
console.log("100" / "10"); // 10
console.log("5" - true); // 4 (true ‚Üí 1)
console.log("5" - false); // 5 (false ‚Üí 0)
```

### **Vergleiche mit `==` (Typumwandlung vor dem Vergleich)**
```js
console.log(0 == "0");  // true (String wird zu Zahl)
console.log(false == ""); // true ("" wird zu false)
console.log(null == undefined); // true
```
üëâ **Verwende `===`, um ohne Typumwandlung zu vergleichen!**
```js
console.log(0 === "0"); // false
console.log(false === ""); // false
```

---

## **2. Explizite Typumwandlung (Manuelle Umwandlung)**
Hier erfolgt die Umwandlung durch Methoden wie `Number()`, `String()`, `Boolean()`.

### **String ‚Üí Number**
```js
console.log(Number("42")); // 42
console.log(Number("3.14")); // 3.14
console.log(Number("10abc")); // NaN (Fehler, da "abc" keine Zahl ist)
console.log(parseInt("42px")); // 42 (ignoriert "px")
console.log(parseFloat("3.14abc")); // 3.14
```

### **Number ‚Üí String**
```js
console.log(String(100)); // "100"
console.log((42).toString()); // "42"
console.log((3.14).toFixed(1)); // "3.1" (Rundet und gibt String zur√ºck)
```

### **Beliebiger Wert ‚Üí Boolean**
```js
console.log(Boolean(1)); // true
console.log(Boolean(0)); // false
console.log(Boolean("Hello")); // true
console.log(Boolean("")); // false
console.log(Boolean(null)); // false
console.log(Boolean(undefined)); // false
console.log(Boolean([])); // true (leeres Array ist truthy!)
console.log(Boolean({})); // true (leeres Objekt ist truthy!)
```

---

## **Spezialf√§lle und Fallstricke**
### **1. `NaN` (Not-a-Number)**
```js
console.log(Number("abc")); // NaN
console.log(0 / 0); // NaN
console.log(NaN == NaN); // false (NaN ist nicht gleich NaN!)
```

### **2. `null` und `undefined` Verhalten**
```js
console.log(Number(null)); // 0
console.log(Number(undefined)); // NaN
console.log(Boolean(null)); // false
console.log(Boolean(undefined)); // false
```

---

## **Fazit**
- **Implizite Typumwandlung** passiert automatisch, kann aber zu unerwarteten Ergebnissen f√ºhren.
- **Explizite Typumwandlung** ist sicherer und kontrollierter.
- **Nutze `===` statt `==`**, um unerwartete Konvertierungen zu vermeiden.

---
üìñ Weitere Informationen findest du in der offiziellen [MDN Web Docs](https://developer.mozilla.org/de/docs/Web/JavaScript/Data_structures).

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

2. ### <a name="2"></a> Unterschied zwischen null und undefined

# Unterschied zwischen `null` und `undefined` in JavaScript

In JavaScript stehen `null` und `undefined` f√ºr das Fehlen eines Wertes, aber sie unterscheiden sich in ihrer Bedeutung und Verwendung.

## **`undefined`**
- Eine Variable wurde deklariert, aber nicht initialisiert.
- Ist der Standardwert f√ºr nicht zugewiesene Variablen.
- Wird zur√ºckgegeben, wenn eine Funktion kein explizites `return` hat.
- Wird zur√ºckgegeben, wenn auf eine nicht existierende Objekt-Eigenschaft oder ein nicht existierendes Array-Element zugegriffen wird.

### **Beispiele f√ºr `undefined`**
```js
let x;
console.log(x); // undefined
```

```js
function doSomething() {
  // Keine R√ºckgabe
}
console.log(doSomething()); // undefined
```

```js
let obj = {};
console.log(obj.nonExistentProperty); // undefined
```

## **`null`**
- `null` ist ein expliziter Wert, der anzeigt, dass eine Variable bewusst leer oder nicht gesetzt ist.
- Wird vom Entwickler zugewiesen, um eine Variable als ‚Äûohne Wert‚Äú zu markieren.

### **Beispiel f√ºr `null`**
```js
let y = null;
console.log(y); // null
```

## **Unterschiede zusammengefasst**
| Eigenschaft   | `undefined` | `null` |
|--------------|------------|--------|
| Standardwert | Ja (bei nicht zugewiesenen Variablen) | Nein (muss explizit gesetzt werden) |
| R√ºckgabewert | Funktionen ohne `return`, fehlende Objekteigenschaften | Muss manuell zugewiesen werden |
| Typ          | `undefined` | `object` (bekannter JavaScript-Bug) |

## **Wann `null` oder `undefined` verwenden?**
- **Verwende `null`**, wenn du eine Variable explizit auf ‚Äûkein Wert‚Äú setzen m√∂chtest.
- **Lass `undefined`** dem System √ºberlassen (z. B. nicht initialisierte Variablen, fehlende Eigenschaften).

---
üìñ Weitere Informationen findest du in der offiziellen [MDN Web Docs](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/null).

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

3. ### <a name="3"></a> Variablen let, const, var. Strikter Modus

# `let`, `const`, `var` und der strikte Modus in JavaScript

## **Unterschiede zwischen `let`, `const` und `var`**
JavaScript bietet drei M√∂glichkeiten, Variablen zu deklarieren: `let`, `const` und `var`. Hier sind ihre Unterschiede:

### **`let`** ‚Äì Blockscope und Neu-Zuweisung erlaubt
- Hat **Block-Scope** (g√ºltig innerhalb `{}`).
- Kann neu zugewiesen werden.
- **Hoisting:** Wird hochgehoben, aber nicht initialisiert.

**Beispiel:**
```js
let x = 5;
if (true) {
  let x = 10;
  console.log(x); // 10 (innerhalb des Blocks)
}
console.log(x); // 5 (au√üerhalb des Blocks)
```

### **`const`** ‚Äì Blockscope und unver√§nderlich
- Hat ebenfalls **Block-Scope**.
- Muss **direkt initialisiert** werden.
- Kann **nicht** neu zugewiesen werden.

**Beispiel:**
```js
const y = 7;
// y = 10; // ‚ùå Fehler: `const`-Variablen k√∂nnen nicht neu zugewiesen werden.
```

### **`var`** ‚Äì Funktionaler Scope und Hoisting
- Hat **funktionalen Scope** (sichtbar in der gesamten Funktion, in der sie deklariert wurde).
- Wird **gehoistet** und erh√§lt beim Hoisting den Wert `undefined`.
- Kann √ºberschrieben und neu deklariert werden.

**Beispiel:**
```js
var z = 3;
if (true) {
  var z = 6;
  console.log(z); // 6
}
console.log(z); // 6 (da `var` global oder funktionsweit g√ºltig ist)
```

üöÄ **Empfehlung:** Verwende **`let`** oder **`const`**, da sie sicherer sind. **`var`** sollte vermieden werden.

---

## **Strikter Modus (`"use strict"`)**
Der **strikte Modus** (`"use strict";`) aktiviert eine strengere Interpretation von JavaScript und hilft, Fehler fr√ºhzeitig zu erkennen.

### **Aktivierung des strikten Modus**
```js
"use strict";
function myFunction() {
  x = 10; // ‚ùå Fehler: `x` wurde nicht mit `let`, `const` oder `var` deklariert.
}
```

### **Wichtige √Ñnderungen durch `"use strict"`**
1. **Keine impliziten globalen Variablen**
   ```js
   "use strict";
   myVar = 10; // ‚ùå Fehler: Variable wurde nicht deklariert.
   ```

2. **Kein mehrfaches Deklarieren von Parametern**
   ```js
   "use strict";
   function sum(a, a) { // ‚ùå Fehler: Doppelte Parameter-Namen nicht erlaubt.
       return a + a;
   }
   ```

3. **Kein L√∂schen von Variablen und Funktionen**
   ```js
   "use strict";
   let myVar = 10;
   delete myVar; // ‚ùå Fehler: Variablen k√∂nnen nicht gel√∂scht werden.
   ```

4. **`this` ist `undefined` in einer Funktion**
   ```js
   "use strict";
   function show() {
       console.log(this); // `undefined` statt `window`
   }
   show();
   ```

### **Warum `"use strict"` verwenden?**
‚úÖ Verhindert h√§ufige Fehler.  
‚úÖ Erh√∂ht die Code-Sicherheit.  
‚úÖ Hilft, modernen JavaScript-Standards zu entsprechen.

üìñ Weitere Informationen findest du in der offiziellen [MDN Web Docs](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Strict_mode).

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

4. ### <a name="4"></a> Interaktion mit dem Benutzer: alert(), prompt(), confirm()

# Benutzerinteraktion in JavaScript: `alert()`, `prompt()`, `confirm()`

JavaScript bietet drei eingebaute Funktionen zur Benutzerinteraktion √ºber modale Dialoge im Browser: `alert()`, `prompt()` und `confirm()`. Diese blockieren die weitere Ausf√ºhrung des Skripts, bis der Benutzer eine Aktion ausf√ºhrt.

## **`alert()` ‚Äì Anzeige einer einfachen Nachricht**
Verwendet, um eine Nachricht in einem Dialogfeld mit einer **OK-Schaltfl√§che** anzuzeigen. 

**Beispiel:**
```js
alert("Hallo, Welt!"); // Zeigt eine Meldung an.
```

üìå **Eigenschaften:**
- Blockiert den Code, bis der Benutzer auf **OK** klickt.
- Hat **keine** R√ºckgabe (immer `undefined`).

---

## **`prompt()` ‚Äì Benutzereingabe anfordern**
Zeigt ein Dialogfeld mit einer Nachricht, einem **Eingabefeld** und den Schaltfl√§chen **OK / Abbrechen**.

**Beispiel:**
```js
let name = prompt("Wie hei√üt du?");
console.log("Hallo, " + name + "!");
```

üìå **Eigenschaften:**
- Gibt den **eingegebenen Text** als `string` zur√ºck.
- Gibt `null` zur√ºck, wenn der Benutzer **Abbrechen** klickt.
- Standardm√§√üig wird alles als `string` gespeichert (auch Zahlen!).

üëâ **Achtung:** Wenn eine Zahl ben√∂tigt wird, sollte `Number()` verwendet werden:
```js
let age = Number(prompt("Gib dein Alter ein:"));
console.log(age + 1); // Falls eine Zahl eingegeben wurde, wird sie korrekt erh√∂ht.
```

---

## **`confirm()` ‚Äì Benutzerentscheidung abfragen**
Zeigt ein Dialogfeld mit einer Nachricht und zwei Schaltfl√§chen: **OK / Abbrechen**.

**Beispiel:**
```js
let result = confirm("Bist du sicher?");
if (result) {
  console.log("Benutzer hat OK geklickt");
} else {
  console.log("Benutzer hat Abbrechen geklickt");
}
```

üìå **Eigenschaften:**
- Gibt `true` zur√ºck, wenn der Benutzer **OK** klickt.
- Gibt `false` zur√ºck, wenn der Benutzer **Abbrechen** klickt.

---

## **Einschr√§nkungen der Modalfenster**
‚ùå K√∂nnen nicht gestylt oder angepasst werden.  
‚ùå Unterbrechen den Codefluss (synchron).  
‚ùå K√∂nnen in modernen Web-Apps st√∂rend sein, daher sind **benutzerdefinierte Dialoge** (`<dialog>`-Element oder modale Fenster mit JavaScript/CSS) oft besser.

üìñ Weitere Informationen findest du in der offiziellen [MDN Web Docs](https://developer.mozilla.org/de/docs/Web/API/Window/alert).

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

5. ### <a name="5"></a> Interpolation (ES6)

### **Interpolation in JavaScript (ES6)**

Interpolation in JavaScript refers to embedding variables or expressions inside a string literal dynamically. This is done using **template literals**, introduced in **ES6**.

#### **Syntax of Template Literals**
Template literals are enclosed in **backticks** (`` ` ``) instead of quotes. The placeholders for variables or expressions are written inside **`${}`**.

```js
let variable = "Wert";
let expression = 2 + 2;

let interpolatedString = `Text: ${variable}, Ausdruck: ${expression}`;
console.log(interpolatedString); // "Text: Wert, Ausdruck: 4"
```

#### **Example: Dynamic String Construction**
```js
let name = "Alice";
let age = 25;

let message = `Hallo, mein Name ist ${name} und ich bin ${age} Jahre alt.`;
console.log(message);
// Ausgabe: "Hallo, mein Name ist Alice und ich bin 25 Jahre alt."
```

#### **Advantages of Template Literals**
‚úÖ **Better Readability**: No need to concatenate strings using `+`.  
‚úÖ **Expression Embedding**: Mathematical operations or function calls can be directly embedded.  
‚úÖ **Multiline Strings**: Supports **multiline strings** without `\n`.  

**Example with Multiline String:**
```js
let text = `Das ist eine mehrzeilige
Zeichenkette ohne Escape-Sequenzen.`;
console.log(text);
```

üìå **Use Case:** Template literals make it easier to build dynamic messages, queries, or HTML content.

Weitere Details findest du in den [MDN Web Docs](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Template_literals). üöÄ

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

6. ### <a name="6"></a> Operatoren in JavaScript

### **Operatoren in JavaScript**  

JavaScript bietet verschiedene Operatoren, die in mehrere Kategorien unterteilt werden k√∂nnen:  

---

## **1. Arithmetische Operatoren**
Diese Operatoren f√ºhren mathematische Berechnungen durch.  

| Operator | Beschreibung  | Beispiel | Ergebnis |
|----------|--------------|----------|----------|
| `+`      | Addition     | `5 + 2`  | `7` |
| `-`      | Subtraktion  | `5 - 2`  | `3` |
| `*`      | Multiplikation | `5 * 2` | `10` |
| `/`      | Division     | `5 / 2`  | `2.5` |
| `%`      | Modulo (Rest) | `5 % 2`  | `1` |
| `++`     | Inkrement    | `let a = 5; a++` | `6` |
| `--`     | Dekrement    | `let b = 2; b--` | `1` |

**Beispiel:**  
```js
let a = 5;
let b = 2;

console.log(a + b); // 7
console.log(a - b); // 3
console.log(a * b); // 10
console.log(a / b); // 2.5
console.log(a % b); // 1
```

---

## **2. Zuweisungsoperatoren**
Diese Operatoren weisen Werte zu und k√∂nnen eine Kombination aus Rechenoperationen und Zuweisung sein.

| Operator | Beschreibung | Beispiel | Ergebnis |
|----------|-------------|----------|----------|
| `=`      | Zuweisung    | `x = 10` | `x = 10` |
| `+=`     | Addition und Zuweisung | `x += 5` | `x = x + 5` |
| `-=`     | Subtraktion und Zuweisung | `x -= 3` | `x = x - 3` |
| `*=`     | Multiplikation und Zuweisung | `x *= 2` | `x = x * 2` |
| `/=`     | Division und Zuweisung | `x /= 4` | `x = x / 4` |

**Beispiel:**  
```js
let x = 10;
x += 5;  // x = 15
x -= 3;  // x = 12
x *= 2;  // x = 24
x /= 4;  // x = 6
console.log(x);
```

---

## **3. Vergleichsoperatoren**
Vergleichsoperatoren vergleichen zwei Werte und geben ein Boolean-Ergebnis (`true` oder `false`) zur√ºck.

| Operator | Bedeutung | Beispiel | Ergebnis |
|----------|------------|----------|----------|
| `==`     | Gleich (Wert) | `5 == "5"` | `true` |
| `===`    | Strikt gleich (Wert und Typ) | `5 === "5"` | `false` |
| `!=`     | Ungleich | `5 != 3` | `true` |
| `!==`    | Strikt ungleich | `5 !== "5"` | `true` |
| `>`      | Gr√∂√üer als | `5 > 3` | `true` |
| `<`      | Kleiner als | `5 < 3` | `false` |
| `>=`     | Gr√∂√üer oder gleich | `5 >= 5` | `true` |
| `<=`     | Kleiner oder gleich | `3 <= 5` | `true` |

**Beispiel:**  
```js
let a = 5;
let b = "5";

console.log(a == b);  // true
console.log(a === b); // false
console.log(a !== b); // true
console.log(a > 3);   // true
```

---

## **4. Logische Operatoren**
Werden f√ºr logische Ausdr√ºcke verwendet.

| Operator | Bedeutung | Beispiel | Ergebnis |
|----------|------------|----------|----------|
| `&&`     | Logisches UND | `true && false` | `false` |
| `||`     | Logisches ODER | `true || false` | `true` |
| `!`      | Logisches NICHT | `!true` | `false` |

**Beispiel:**  
```js
let x = 5;
let y = 10;

console.log(x > 0 && y > 0); // true
console.log(x > 0 || y < 0); // true
console.log(!(x > 0));       // false
```

---

## **5. Nullish Coalescing Operator (`??`)**
Gibt den **ersten definierten Wert** zur√ºck (wenn der linke Wert `null` oder `undefined` ist, wird der rechte verwendet).

**Beispiel:**  
```js
let username = null;
let defaultUsername = "Gast";

let finalUsername = username ?? defaultUsername;
console.log(finalUsername); // "Gast"

let count = 0;
let finalCount = count ?? 10;
console.log(finalCount); // 0 (weil `count` nicht `null` oder `undefined` ist)
```

---

## **6. Optionale Verkettung (`?.`)**
Erm√∂glicht den **sicheren Zugriff** auf Eigenschaften oder Methoden von `null` oder `undefined`, ohne einen Fehler auszul√∂sen.

**Beispiel:**  
```js
let user = {
  name: "John",
  address: {
    city: "Berlin"
  }
};

console.log(user?.name);         // "John"
console.log(user?.address?.city); // "Berlin"
console.log(user?.age);          // undefined (statt Fehler)
```

---

## **7. Bitweise Operatoren**
Arbeiten direkt auf den Bin√§rwerten von Zahlen.

| Operator | Beschreibung | Beispiel | Ergebnis |
|----------|-------------|----------|----------|
| `&`      | Bitweises UND | `5 & 3`  | `1` |
| `|`      | Bitweises ODER | `5 | 3`  | `7` |
| `^`      | Bitweises XOR | `5 ^ 3`  | `6` |
| `~`      | Bitweises NOT | `~5` | `-6` |
| `<<`     | Linksverschiebung | `5 << 1` | `10` |
| `>>`     | Rechtsverschiebung | `5 >> 1` | `2` |

**Beispiel:**  
```js
let a = 5;  // Bin√§r: 101
let b = 3;  // Bin√§r: 011

console.log(a & b); // 1 (001)
console.log(a | b); // 7 (111)
console.log(a ^ b); // 6 (110)
console.log(~a);    // -6
console.log(a << 1); // 10
console.log(b >> 1); // 1
```

---

## **8. Unterschied zwischen un√§rem und bin√§rem `+`**
- **Bin√§rer `+`**: F√ºhrt Addition oder String-Konkatenation durch.
- **Un√§rer `+`**: Wandelt einen Wert in eine Zahl um.

**Beispiel:**  
```js
let a = "10";
let b = 5;

console.log(a + b);  // "105" (String-Konkatenation)
console.log(+a + b); // 15 (Addition)

console.log(+"123"); // 123 (String ‚Üí Zahl)
console.log(+true);  // 1 (Boolean ‚Üí Zahl)
console.log(+"abc"); // NaN (ung√ºltige Umwandlung)
```

---

### **Zusammenfassung**
- Verwende `===` f√ºr verl√§ssliche Vergleiche.
- Nutze `??` f√ºr Standardwerte bei `null` oder `undefined`.
- Die **optionale Verkettung (`?.`)** ist hilfreich f√ºr den sicheren Zugriff auf Objekte.
- **Un√§rer `+`** kann n√ºtzlich sein, um Strings in Zahlen zu konvertieren.

üìñ Weitere Details findest du in den [MDN Web Docs](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Operators). üöÄ

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

7. ### <a name="7"></a> Bedingungen

### **Bedingungen in JavaScript**

In JavaScript gibt es verschiedene M√∂glichkeiten, Bedingungen zu pr√ºfen und Code auszuf√ºhren, wenn bestimmte Kriterien erf√ºllt sind.  

---

## **1. Truthy- und Falsy-Werte**
Bestimmte Werte werden als **falsch** (`false`) behandelt, wenn sie in einer Bedingung √ºberpr√ºft werden:
- `0`
- `""` (leerer String)
- `null`
- `undefined`
- `NaN`

Alle anderen Werte sind **wahr** (`true`), einschlie√ülich:
- `"0"` (String mit Null)
- `"false"` (String mit "false")
- `[]` (leeres Array)
- `{}` (leeres Objekt)
- `function() {}` (leere Funktion)

**Beispiel:**  
```js
if (0) {
  console.log("Dies wird nicht ausgef√ºhrt.");
} else {
  console.log("0 ist ein falsy Wert.");
}
```
---

## **2. `if`-`else`-Bedingungen**
Der `if`-Befehl pr√ºft eine Bedingung und f√ºhrt den zugeh√∂rigen Codeblock aus.

### **Syntax:**
```js
if (Bedingung) {
  // Code wird ausgef√ºhrt, wenn die Bedingung true ist
} else if (weitere Bedingung) {
  // Code f√ºr eine alternative Bedingung
} else {
  // Code f√ºr den Fall, dass keine Bedingung wahr ist
}
```

### **Beispiel:**
```js
let x = 5;

if (x > 0) {
  console.log("Die Zahl ist positiv.");
} else if (x < 0) {
  console.log("Die Zahl ist negativ.");
} else {
  console.log("Die Zahl ist null.");
}
```

---

## **3. Logische Operatoren in Bedingungen**
Logische Operatoren werden verwendet, um mehrere Bedingungen zu kombinieren.

| Operator | Bedeutung | Beispiel |
|----------|------------|-------------|
| `&&`     | UND       | `true && false // false` |
| `||`     | ODER      | `true || false // true` |
| `!`      | NICHT     | `!true // false` |

**Beispiel mit `&&` (UND):**  
```js
let age = 25;
let hasDriverLicense = true;

if (age >= 18 && hasDriverLicense) {
  console.log("Du kannst Auto fahren.");
} else {
  console.log("Du darfst nicht fahren.");
}
```

**Beispiel mit `||` (ODER):**  
```js
let isWeekend = false;
let isHoliday = true;

if (isWeekend || isHoliday) {
  console.log("Du hast frei!");
} else {
  console.log("Arbeitstag!");
}
```

---

## **4. Tern√§rer Operator (`? :`)**
Der **tern√§re Operator** ist eine Kurzform f√ºr `if`-`else`.

### **Syntax:**
```js
Bedingung ? Ausdruck_wenn_wahr : Ausdruck_wenn_falsch;
```

### **Beispiel:**
```js
let x = 10;
let isEven = x % 2 === 0 ? "Gerade Zahl" : "Ungerade Zahl";
console.log(isEven); // "Gerade Zahl"
```

---

## **5. `switch`-Bedingungen**
Der `switch`-Operator wird verwendet, wenn ein Wert mit mehreren M√∂glichkeiten verglichen werden soll.  
üîπ **Vergleich ist strikt (`===`)** ‚Äì Datentypen m√ºssen √ºbereinstimmen.  
üîπ **`break` nicht vergessen**, um zu verhindern, dass alle weiteren `case`-Bl√∂cke ausgef√ºhrt werden.  

### **Syntax:**
```js
switch (Ausdruck) {
  case Wert1:
    // Code wenn Ausdruck === Wert1
    break;
  case Wert2:
    // Code wenn Ausdruck === Wert2
    break;
  default:
    // Code wenn kein Fall zutrifft
}
```

### **Beispiel:**
```js
let day = 2;
let dayName;

switch (day) {
  case 1:
    dayName = "Montag";
    break;
  case 2:
    dayName = "Dienstag";
    break;
  case 3:
    dayName = "Mittwoch";
    break;
  case 4:
    dayName = "Donnerstag";
    break;
  case 5:
    dayName = "Freitag";
    break;
  default:
    dayName = "Wochenende";
}

console.log(dayName); // "Dienstag"
```

### **Mehrere `case`-Werte gruppieren:**
```js
let char = "a";

switch (char) {
  case "a":
  case "e":
  case "i":
  case "o":
  case "u":
    console.log("Vokal");
    break;
  default:
    console.log("Konsonant");
}
```

---

### **Wann `if-else` und wann `switch` verwenden?**
| Situation | Empfohlene Struktur |
|-----------|----------------------|
| Vergleich von Zahlen-/Booleschen Werten | `if-else` |
| Komplexe Bedingungen mit `&&` oder `||` | `if-else` |
| Vergleich einer Variable mit mehreren festen Werten | `switch` |

---

## **Zusammenfassung**
‚úÖ **Falsy-Werte**: `0, "", null, undefined, NaN`  
‚úÖ **`if-else`** f√ºr allgemeine Bedingungen  
‚úÖ **Logische Operatoren (`&&`, `||`, `!`)** f√ºr kombinierte Bedingungen  
‚úÖ **Tern√§rer Operator (`? :`)** f√ºr kurze Bedingungen  
‚úÖ **`switch`** f√ºr mehrere m√∂gliche Werte einer Variablen  

üìñ Weitere Infos: [MDN Web Docs](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Statements/if...else) üöÄ

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

8. ### <a name="8"></a> Schleifen, verschachtelte Schleifen, Labels

### **Schleifen in JavaScript: `for`, `while`, `do...while`**
Schleifen erm√∂glichen es, Codebl√∂cke mehrfach auszuf√ºhren, solange eine Bedingung erf√ºllt ist.

---

## **1. `for`-Schleife**
Die `for`-Schleife ist ideal, wenn die Anzahl der Durchl√§ufe bekannt ist.

### **Syntax:**
```js
for (Start; Bedingung; Inkrement) {
  // Code, der in jeder Iteration ausgef√ºhrt wird
}
```

### **Beispiel:**
```js
for (let i = 0; i < 5; i++) {
  console.log(i);
}
// Ausgabe: 0, 1, 2, 3, 4
```

---

## **2. `while`-Schleife**
Die `while`-Schleife wird ausgef√ºhrt, solange die Bedingung `true` ist.

### **Beispiel:**
```js
let i = 0;
while (i < 5) {
  console.log(i);
  i++;
}
```

Falls die Bedingung von Anfang an `false` ist, wird die Schleife **keinmal** ausgef√ºhrt.

---

## **3. `do...while`-Schleife**
Diese Schleife wird **mindestens einmal** ausgef√ºhrt, da die Bedingung erst nach dem ersten Durchlauf gepr√ºft wird.

### **Beispiel:**
```js
let i = 0;
do {
  console.log(i);
  i++;
} while (i < 5);
```

---

## **4. Verschachtelte Schleifen (Nested Loops)**
Eine Schleife kann innerhalb einer anderen ausgef√ºhrt werden.

### **Beispiel:**
```js
for (let i = 0; i < 3; i++) {
  for (let j = 0; j < 3; j++) {
    console.log(`i: ${i}, j: ${j}`);
  }
}
```
üëâ Dies wird f√ºr `i = 0` dreimal ausgef√ºhrt (`j = 0, 1, 2`), dann f√ºr `i = 1` usw.

---

## **5. `break` und `continue`**
- **`break`** ‚Üí Bricht die Schleife ab.
- **`continue`** ‚Üí √úberspringt den aktuellen Durchlauf und f√§hrt mit der n√§chsten Iteration fort.

### **Beispiel f√ºr `break`:**
```js
for (let i = 0; i < 5; i++) {
  if (i === 3) {
    break; // Schleife wird bei i = 3 abgebrochen
  }
  console.log(i);
}
// Ausgabe: 0, 1, 2
```

### **Beispiel f√ºr `continue`:**
```js
for (let i = 0; i < 5; i++) {
  if (i === 3) {
    continue; // i = 3 wird √ºbersprungen
  }
  console.log(i);
}
// Ausgabe: 0, 1, 2, 4
```

---

## **6. Labels in Schleifen**
Labels helfen, **verschachtelte Schleifen gezielt zu unterbrechen**.

### **Beispiel:**
```js
outerLoop: for (let i = 0; i < 3; i++) {
  for (let j = 0; j < 3; j++) {
    if (i === 1 && j === 1) {
      break outerLoop; // Beendet die √§u√üere Schleife komplett
    }
    console.log(`i: ${i}, j: ${j}`);
  }
}
```
üëâ Hier w√ºrde der `break` normalerweise nur die innere Schleife abbrechen. Durch das **Label `outerLoop`** wird jedoch die √§u√üere Schleife gestoppt.

---

### **Zusammenfassung**
‚úÖ **`for`** ‚Üí Wenn die Anzahl der Durchl√§ufe bekannt ist.  
‚úÖ **`while`** ‚Üí Solange eine Bedingung wahr ist.  
‚úÖ **`do...while`** ‚Üí Wird **mindestens einmal** ausgef√ºhrt.  
‚úÖ **Verschachtelte Schleifen** f√ºr komplexe Strukturen.  
‚úÖ **`break` & `continue`** zur Steuerung des Ablaufs.  
‚úÖ **Labels** erm√∂glichen gezieltes Unterbrechen von verschachtelten Schleifen.

üìñ Mehr Infos: [MDN Web Docs](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Statements/for) üöÄ

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

9. ### <a name="9"></a> Hoisting (Hochheben von Variablen und Funktionen)

### **Hoisting in JavaScript (Hochheben von Variablen und Funktionen)**

**Hoisting** ist ein Mechanismus in JavaScript, bei dem **Deklarationen von Variablen und Funktionen** vor der Codeausf√ºhrung an den Anfang ihres G√ºltigkeitsbereichs (Scope) **verschoben** werden.

---

## **1. Hoisting von Variablen**
### **1.1 `var` (Hoisting mit `undefined`)**
- Deklaration wird **hochgehoben**, aber die Initialisierung bleibt an der urspr√ºnglichen Stelle.
- Zugriff vor der Initialisierung gibt `undefined` zur√ºck.

```js
console.log(x); // undefined
var x = 10;
console.log(x); // 10
```
üîπ **Warum?** JavaScript behandelt es so:
```js
var x;
console.log(x); // undefined
x = 10;
console.log(x);
```

---

### **1.2 `let` und `const` (Hoisting mit TDZ)**
- `let` und `const` werden ebenfalls hochgehoben, aber sie bleiben in der **Temporal Dead Zone (TDZ)**.
- Zugriff vor der Deklaration f√ºhrt zu **ReferenceError**.

```js
console.log(y); // ‚ùå ReferenceError
let y = 20;
console.log(y); // ‚úÖ 20

console.log(z); // ‚ùå ReferenceError
const z = 30;
console.log(z); // ‚úÖ 30
```
üîπ **Warum?** JavaScript behandelt es so:
```js
// Variablen existieren in der TDZ (keine Nutzung m√∂glich)
let y;
const z;
console.log(y, z); // ReferenceError
y = 20;
z = 30;
```
üìå **Empfehlung:** Nutze `let` oder `const` statt `var`, um unerwartetes Verhalten zu vermeiden.

---

## **2. Hoisting von Funktionen**
### **2.1 `function` (Function Declaration)**
- **Wird vollst√§ndig hochgehoben**, d.h. Funktionen k√∂nnen **vor ihrer Definition** aufgerufen werden.

```js
myFunction(); // ‚úÖ "Hello, world!"

function myFunction() {
  console.log("Hello, world!");
}
```
üîπ **JavaScript behandelt es so:**
```js
function myFunction() {
  console.log("Hello, world!");
}
myFunction();
```

---

### **2.2 `function` als `const` oder `let` (Function Expression)**
- Wenn eine Funktion als **Variable (`let` oder `const`) gespeichert wird**, gilt **TDZ**.
- Zugriff vor der Definition f√ºhrt zu **ReferenceError**.

```js
myFunc(); // ‚ùå ReferenceError
const myFunc = function () {
  console.log("Hello!");
};
```
üìå **Warum?** `const myFunc` wird hochgehoben, aber bleibt in der **Temporal Dead Zone**.

---

## **3. Hoisting: Zusammenfassung**
| Typ | Wird hochgehoben? | Zugriff vor Deklaration? |
|------|----------------|----------------|
| `var` | ‚úÖ Ja | `undefined` |
| `let` | ‚úÖ Ja (aber in TDZ) | ‚ùå ReferenceError |
| `const` | ‚úÖ Ja (aber in TDZ) | ‚ùå ReferenceError |
| Function Declaration | ‚úÖ Ja | ‚úÖ Funktion kann vorher aufgerufen werden |
| Function Expression (`let/const`) | ‚úÖ Ja (aber in TDZ) | ‚ùå ReferenceError |

---

üìñ **Empfohlene Praxis**:
‚úÖ **Immer `let` oder `const` verwenden**  
‚úÖ **Variablen immer am Anfang des Scopes deklarieren**  
‚úÖ **Funktionen bevorzugt mit `function myFunc()` deklarieren, wenn sie vor Nutzung verf√ºgbar sein sollen**  

üîó **Mehr Infos**: [MDN Web Docs](https://developer.mozilla.org/de/docs/Glossary/Hoisting) üöÄ

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

10. ### <a name="10"></a> Ausf√ºhrungskontext, Lexikalische Umgebung

### **Ausf√ºhrungskontext und Lexikalische Umgebung in JavaScript**  

JavaScript verwaltet die Ausf√ºhrung von Code mithilfe von **Ausf√ºhrungskontexten (Execution Contexts)** und **lexikalischen Umgebungen (Lexical Environments)**. Diese Mechanismen bestimmen, welche Variablen und Funktionen an einer bestimmten Stelle im Code zug√§nglich sind.

---

## **1. Ausf√ºhrungskontext (Execution Context)**  
Ein **Ausf√ºhrungskontext** ist die Umgebung, in der JavaScript-Code ausgef√ºhrt wird. Er enth√§lt:
- **Variablen** und **Funktionen**, die im aktuellen Kontext definiert sind.
- Eine **Referenz zur √§u√üeren Umgebung** f√ºr den Zugriff auf √§u√üere Variablen.

### **Arten von Ausf√ºhrungskontexten**  
1. **Globaler Kontext**:  
   - Wird automatisch beim Start des Skripts erstellt.
   - Enth√§lt globale Variablen und Funktionen.
   - Im Browser ist das `window`-Objekt der globale Kontext.

2. **Funktionskontext**:  
   - Wird f√ºr jede aufgerufene Funktion erstellt.
   - Jede Funktion hat ihren eigenen lokalen Kontext.

3. **Eval-Kontext** *(selten verwendet)*:  
   - Entsteht beim Ausf√ºhren von Code mit `eval()`.

---

## **2. Lexikalische Umgebung (Lexical Environment)**  
Eine **lexikalische Umgebung** speichert **Variablen und Funktionen** im aktuellen Scope und enth√§lt eine **Referenz zum √§u√üeren Scope**.

### **Bestandteile der lexikalischen Umgebung**
1. **Environment Record** (Speicher f√ºr Variablen und Funktionen).
2. **Outer Environment Reference** (Referenz zur √§u√üeren Umgebung).

üîπ **Lexikalische Umgebung wird beim Parsen (Code-Analyse) erstellt**, bevor der Code ausgef√ºhrt wird.

---

## **3. Beispiel f√ºr Ausf√ºhrungskontext & Lexikalische Umgebung**
```js
function outer() {
  const x = 10; // x geh√∂rt zur Lexical Environment von outer()

  function inner() {
    const y = 20; // y geh√∂rt zur Lexical Environment von inner()
    console.log(x + y); // Zugriff auf x durch "Outer Environment Reference"
  }

  inner();
}

outer();
```

### **Ablauf des Codes**
1. **Global Execution Context wird erstellt** (`outer` wird definiert).
2. `outer()` wird aufgerufen:
   - Neuer **Funktionskontext f√ºr `outer()`** wird erstellt.
   - `x = 10` wird gespeichert.
3. `inner()` wird aufgerufen:
   - Neuer **Funktionskontext f√ºr `inner()`** wird erstellt.
   - `y = 20` wird gespeichert.
   - Zugriff auf `x` durch **Outer Environment Reference**.
4. Nach der Ausf√ºhrung werden die **inneren Kontexte gel√∂scht**, der **globale Kontext bleibt**.

---

## **4. Call Stack (Ausf√ºhrungsstapel)**
JavaScript verwaltet mehrere Ausf√ºhrungskontexte mit einem **Stack (Stapelprinzip: LIFO - Last In, First Out)**.

**Beispiel Call Stack f√ºr obigen Code:**
1. **Global Execution Context (wird zuerst geladen)**  
2. `outer()` wird aufgerufen ‚Üí Neuer **Funktionskontext f√ºr `outer()`**  
3. `inner()` wird aufgerufen ‚Üí Neuer **Funktionskontext f√ºr `inner()`**  
4. `inner()` beendet ‚Üí **Wird aus dem Stack entfernt**  
5. `outer()` beendet ‚Üí **Wird aus dem Stack entfernt**  
6. Globaler Kontext bleibt.

---

## **5. Temporal Dead Zone (TDZ) und Scope Chain**
- **Variablen mit `let` oder `const` befinden sich vor ihrer Initialisierung in der Temporal Dead Zone (TDZ)**.
- **Scope Chain:** Falls eine Variable nicht im aktuellen Scope gefunden wird, sucht JavaScript in den √§u√üeren Scopes weiter.

**Beispiel f√ºr TDZ:**
```js
console.log(a); // ‚ùå ReferenceError (TDZ)
let a = 5;
```

**Beispiel f√ºr Scope Chain:**
```js
const globalVar = "Ich bin global";

function outerFunction() {
  const outerVar = "Ich bin in outer";

  function innerFunction() {
    console.log(globalVar); // Zugriff auf globale Variable
    console.log(outerVar);  // Zugriff auf √§u√üere Funktion
  }

  innerFunction();
}

outerFunction();
```

üîπ **Hier greift `innerFunction` auf `outerVar` zu, weil es im √§u√üeren Scope existiert.**  

---

### **Zusammenfassung**
‚úÖ **Execution Context (Ausf√ºhrungskontext)** verwaltet Codeausf√ºhrung.  
‚úÖ **Lexikalische Umgebung (Lexical Environment)** speichert Variablen und Funktionen.  
‚úÖ **Call Stack (Ausf√ºhrungsstapel)** verwaltet, welche Funktion gerade l√§uft.  
‚úÖ **Scope Chain** bestimmt, wo JavaScript nach Variablen sucht.  
‚úÖ **TDZ (Temporal Dead Zone)** tritt bei `let` und `const` auf.

üìñ Weitere Infos: [MDN Web Docs](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/LexicalEnvironment) üöÄ

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

11. ### <a name="11"></a> Tempor√§re Totzone (Temporal Dead Zone)

### **Tempor√§re Totzone (Temporal Dead Zone, TDZ) in JavaScript**  

Die **Tempor√§re Totzone (TDZ)** ist eine Phase, in der eine Variable existiert, aber **noch nicht zug√§nglich** ist.  

---

## **1. Wann tritt die TDZ auf?**  
### **‚ö†Ô∏è Die TDZ tritt bei `let` und `const` auf, aber nicht bei `var`.**  
```js
console.log(x); // ‚ùå ReferenceError: x is not defined
let x = 10;
```
Hier existiert `x` technisch bereits im **Scope**, ist aber noch **nicht nutzbar**, bis die Deklaration tats√§chlich erreicht wird.

---

## **2. Beispiele f√ºr TDZ**
### **2.1 TDZ in `let` und `const`**
```js
{
  console.log(a); // ‚ùå ReferenceError: a is not defined
  let a = 5;
  console.log(a); // ‚úÖ 5 (ab hier nutzbar)
}
```
**Erkl√§rung:**  
- `a` existiert im Scope des `{}`-Blocks.
- Aber **vor der Deklaration (`let a = 5`) befindet sich `a` in der TDZ**.

---

### **2.2 TDZ in `if`, `for` oder anderen Bl√∂cken**
```js
if (true) {
  console.log(b); // ‚ùå ReferenceError
  let b = 20;
}
```
**Warum?**  
- `b` wird erst **nach der Deklaration (`let b = 20;`) verwendbar**.

---

### **2.3 TDZ bei Funktionsparametern**
**‚ö†Ô∏è Parameter k√∂nnen auch in der TDZ sein, wenn sie sich auf sp√§tere Parameter beziehen.**  
```js
function myFunction(x = y, y = 2) {
  console.log(x); // ‚ùå ReferenceError: y is not defined
  console.log(y); // ‚úÖ 2
}
myFunction();
```
**Warum?**  
- `x = y` wird ausgef√ºhrt, **bevor** `y` einen Wert erh√§lt ‚Üí **TDZ f√ºr `y`**.

---

## **3. Unterschiede zwischen `var`, `let` und `const`**
| Deklaration | Wird hochgehoben? | Zugriff vor Initialisierung? | Wert in TDZ? |
|------------|----------------|----------------|-------------|
| `var`      | ‚úÖ Ja           | ‚úÖ `undefined` | ‚ùå Keine TDZ |
| `let`      | ‚úÖ Ja           | ‚ùå ReferenceError | ‚úÖ TDZ vorhanden |
| `const`    | ‚úÖ Ja           | ‚ùå ReferenceError | ‚úÖ TDZ vorhanden |

---

## **4. Wie vermeide ich TDZ-Fehler?**
‚úÖ **Immer `let` oder `const` direkt am Anfang eines Scopes deklarieren.**  
‚úÖ **Keinen Code schreiben, der auf eine Variable zugreift, bevor sie definiert ist.**  

**üîπ Falsch:**
```js
console.log(x); // ‚ùå ReferenceError
let x = 5;
```

**‚úÖ Richtig:**
```js
let x = 5;
console.log(x); // ‚úÖ 5
```

üìñ Weitere Infos: [MDN Web Docs](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Statements/let#temporal_dead_zone_tdz) üöÄ

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

12. ### <a name="12"></a> typeof ‚Äì wie erkennt man den Typ eines Werts?

### **`typeof` ‚Äì Den Typ eines Werts in JavaScript erkennen**  

Der `typeof`-Operator wird in JavaScript verwendet, um den **Datentyp** einer Variablen oder eines Werts als **String** zur√ºckzugeben.

---

## **1. Syntax**  
```js
typeof Wert;
typeof (Wert);
```

üìå **Hinweis:** Klammern sind optional, k√∂nnen aber zur besseren Lesbarkeit genutzt werden.

---

## **2. R√ºckgabewerte von `typeof`**  
| Datentyp | `typeof` R√ºckgabe |
|----------|------------------|
| `undefined` | `"undefined"` |
| `null` | `"object"` ‚ùå (JavaScript-Bug) |
| `boolean` | `"boolean"` |
| `number` | `"number"` |
| `bigint` | `"bigint"` (ab ES11) |
| `string` | `"string"` |
| `symbol` | `"symbol"` |
| `function` | `"function"` |
| `object` | `"object"` (Objekte, Arrays) |

---

## **3. Beispiele**
```js
console.log(typeof 42);         // "number"
console.log(typeof "Hello");    // "string"
console.log(typeof true);       // "boolean"
console.log(typeof undefined);  // "undefined"
console.log(typeof null);       // "object" ‚ùå (Bug in JavaScript)
console.log(typeof {});         // "object"
console.log(typeof []);         // "object" (Arrays sind Objekte!)
console.log(typeof function(){}); // "function"
console.log(typeof Symbol("id")); // "symbol"
console.log(typeof BigInt(9007199254740991)); // "bigint"
```

---

## **4. Besonderheiten und Fallstricke**
### ‚ùå **`typeof null` gibt `"object"` zur√ºck**
```js
console.log(typeof null); // "object"
```
üìå **Grund:** Dies ist ein **historischer Bug** in JavaScript. `null` ist **kein** Objekt, sondern ein eigener Datentyp.

**Richtige Pr√ºfung auf `null`:**
```js
let value = null;
console.log(value === null); // ‚úÖ true
```

---

### ‚ùå **Arrays geben `"object"` zur√ºck**
```js
console.log(typeof [1, 2, 3]); // "object"
```
üìå **Arrays sind eine spezielle Art von Objekten.**  
**Richtige Pr√ºfung:**  
```js
console.log(Array.isArray([1, 2, 3])); // ‚úÖ true
```

---

### **`typeof` bei `functions`**
```js
console.log(typeof function() {}); // "function"
```
üìå **Obwohl Funktionen Objekte sind, gibt `typeof` "function" zur√ºck.**  

---

## **5. Praktische Anwendungsf√§lle**
### ‚úÖ **Datentyp pr√ºfen, bevor Operationen ausgef√ºhrt werden**
```js
function add(a, b) {
  if (typeof a !== "number" || typeof b !== "number") {
    return "Fehler: Beide Werte m√ºssen Zahlen sein!";
  }
  return a + b;
}

console.log(add(5, "10")); // "Fehler: Beide Werte m√ºssen Zahlen sein!"
```

### ‚úÖ **Pr√ºfung auf `null`**
```js
let obj = null;

if (obj === null) {
  console.log("obj ist null");
}
```

### ‚úÖ **Unterschied zwischen `object` und `array` pr√ºfen**
```js
let data = [1, 2, 3];

if (Array.isArray(data)) {
  console.log("data ist ein Array!");
} else {
  console.log("data ist ein Objekt!");
}
```

---

### **6. Zusammenfassung**
‚úÖ `typeof` gibt den Datentyp eines Werts als **String** zur√ºck.  
‚úÖ **Achtung bei `typeof null` ‚Üí gibt `"object"` zur√ºck (Bug).**  
‚úÖ **Arrays** sind `typeof "object"` ‚Üí `Array.isArray()` zur Pr√ºfung verwenden.  
‚úÖ **Funktionen** sind `typeof "function"` (aber intern Objekte).  

üìñ Weitere Infos: [MDN Web Docs](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Operators/typeof) üöÄ

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

13. ### <a name="13"></a> Warum haben primitive Datentypen Methoden? Was ist Autoboxing?

### **Warum haben primitive Datentypen Methoden? Was ist Autoboxing?**  

In JavaScript sind **primitive Datentypen** (`string`, `number`, `boolean`, `symbol`, `bigint`, `null`, `undefined`) **keine Objekte** und haben normalerweise keine Methoden. Dennoch k√∂nnen wir Methoden wie `.toUpperCase()` f√ºr Strings oder `.toFixed()` f√ºr Zahlen aufrufen.  

üìå **Grund:** **JavaScript nutzt "Autoboxing"**, um primitive Werte in **Objekt-Wrapper** umzuwandeln, wenn Methoden aufgerufen werden.

---

## **1. Was ist Autoboxing?**
üìå **Autoboxing** bedeutet, dass ein primitiver Wert **automatisch in ein entsprechendes Objekt umgewandelt** wird, wenn eine Methode oder Eigenschaft aufgerufen wird.  

| Primitiver Typ | Entsprechendes Wrapper-Objekt |
|---------------|------------------------------|
| `string`      | `String` |
| `number`      | `Number` |
| `boolean`     | `Boolean` |

Nach der **Nutzung des Objekts wird es sofort wieder verworfen**, und die Variable bleibt ein primitiver Wert.

---

## **2. Beispiel f√ºr Autoboxing**
```js
const str = "hello";
console.log(str.toUpperCase()); // "HELLO"
```
üëâ **Was passiert intern?**
1. JavaScript erstellt **tempor√§r** ein `String`-Objekt:  
   ```js
   new String("hello");
   ```
2. F√ºhrt `.toUpperCase()` darauf aus.  
3. Gibt `"HELLO"` zur√ºck und verwirft das Objekt.

---

## **3. Beispiel mit `Number`**
```js
const num = 42;
console.log(num.toFixed(2)); // "42.00"
```
üëâ **Intern passiert Folgendes:**
1. `num` ist ein primitiver `number`-Wert.
2. JavaScript wandelt `num` tempor√§r in ein `Number`-Objekt um.
3. F√ºhrt `.toFixed(2)` aus.
4. Gibt das Ergebnis zur√ºck und verwirft das `Number`-Objekt.

---

## **4. Was passiert, wenn wir ein echtes Wrapper-Objekt nutzen?**
```js
const strObj = new String("hello");
console.log(typeof strObj); // "object"
console.log(strObj === "hello"); // false (Objekt ‚â† primitiver Wert)
```
üìå **Achtung:** Ein `new String("hello")` ist **kein** primitiver `string`, sondern ein Objekt!  
Deshalb sollte man `new String()`, `new Number()` oder `new Boolean()` **nicht verwenden**.

---

## **5. Warum sind primitive Werte unver√§nderlich?**
```js
const str = "hello";
str[0] = "H"; // ‚ùå Keine √Ñnderung m√∂glich
console.log(str); // "hello" bleibt unver√§ndert
```
üìå **Warum?** Weil **primitive Werte keine ver√§nderbaren Objekte sind**. Methoden wie `.toUpperCase()` oder `.slice()` **geben eine neue Zeichenkette zur√ºck, anstatt die urspr√ºngliche zu √§ndern**.

---

### **Zusammenfassung**
‚úÖ **Autoboxing** erm√∂glicht Methodenaufrufe auf primitiven Werten.  
‚úÖ **Primitive Werte bleiben unver√§ndert** ‚Äì Methoden erzeugen neue Werte.  
‚úÖ **Nach der Methode wird das tempor√§re Objekt sofort verworfen.**  
‚úÖ **Vermeide `new String()`, `new Number()` und `new Boolean()`** ‚Äì sie erzeugen unn√∂tige Objekte.

üìñ Mehr Infos: [MDN Web Docs](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/String) üöÄ

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

14. ### <a name="14"></a> Garbage Collector in JavaScript

### **Garbage Collector in JavaScript**  

JavaScript hat einen **automatischen Garbage Collector**, der **nicht mehr verwendete Objekte aus dem Speicher entfernt**. Dies verhindert manuelles Speichermanagement wie in C oder C++.  

---

## **1. Wie funktioniert der Garbage Collector?**  
Der **Garbage Collector** entfernt Objekte aus dem Speicher, die **nicht mehr erreichbar** sind.  
Ein Objekt gilt als **"nicht mehr erreichbar"**, wenn **keine Referenz mehr darauf existiert**.

üîπ **Beispiel f√ºr ein erreichbares Objekt:**  
```js
let obj = { name: "Max" }; // "obj" h√§lt eine Referenz auf das Objekt
```
üëâ **Dieses Objekt wird NICHT gel√∂scht**, weil `obj` darauf verweist.

üîπ **Objekt wird unerreichbar und gel√∂scht:**  
```js
let obj = { name: "Max" };
obj = null; // Keine Referenz mehr ‚Üí Speicher wird freigegeben
```
üëâ **Nach `obj = null;` gibt es keine Referenz mehr ‚Üí Objekt wird gel√∂scht.**

---

## **2. Hauptstrategie des Garbage Collectors: Mark-and-Sweep (Markierung & L√∂schung)**  
Der **h√§ufigste Algorithmus** in modernen JavaScript-Engines ist **"Mark-and-Sweep"**:
1. **Mark (Markieren)**: Der Garbage Collector markiert **alle erreichbaren Objekte**.
2. **Sweep (L√∂schen)**: Alle **nicht markierten (unerreichbaren) Objekte werden gel√∂scht**.

üìå **Beispiel f√ºr Mark-and-Sweep:**
```js
function createObject() {
  let obj = { value: 42 }; // Erreichbar innerhalb der Funktion
}
createObject(); 
// Nach dem Funktionsaufruf ist "obj" nicht mehr erreichbar ‚Üí Es wird gel√∂scht.
```

---

## **3. Memory Leaks (Speicherlecks) vermeiden**
Obwohl der Garbage Collector automatisch arbeitet, k√∂nnen **Speicherlecks** auftreten.

### **Typische Ursachen f√ºr Memory Leaks**  
1. **Unn√∂tige globale Variablen**  
   ```js
   var globalVar = {}; // Bleibt f√ºr die gesamte Laufzeit erhalten
   ```
   **L√∂sung:** **Vermeide `var`, nutze `let` oder `const`.**  
   
2. **Vergessene Timer (`setInterval`)**
   ```js
   let interval = setInterval(() => console.log("l√§uft"), 1000);
   // clearInterval(interval); // Muss gestoppt werden, sonst bleibt es im Speicher!
   ```

3. **DOM-Referenzen behalten**  
   ```js
   let button = document.getElementById("btn");
   button.addEventListener("click", () => console.log("geklickt"));
   // Falls "button" entfernt wird, bleibt die Referenz bestehen und blockiert Speicher.
   ```

   **L√∂sung:** `removeEventListener()` nutzen:  
   ```js
   button.removeEventListener("click", handler);
   ```

---

## **4. Zusammenfassung**
‚úÖ **Garbage Collector entfernt ungenutzte Objekte automatisch**.  
‚úÖ **"Mark-and-Sweep" ist der wichtigste Algorithmus**.  
‚úÖ **Speicherlecks vermeiden:** `setInterval` stoppen, Event-Listener entfernen, keine unn√∂tigen globalen Variablen.  

üìñ **Mehr Infos:** [MDN Web Docs](https://developer.mozilla.org/de/docs/Web/JavaScript/Memory_Management) üöÄ

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

15. ### <a name="15"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

16. ### <a name="16"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

17. ### <a name="17"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

18. ### <a name="18"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

19. ### <a name="19"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

20. ### <a name="20"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

21. ### <a name="21"></a> Funktionen, Pfeilfunktionen, IIFE

### **Funktionen, Pfeilfunktionen und IIFE in JavaScript**

JavaScript bietet verschiedene Arten von Funktionen, die sich in **Syntax, `this`-Bindung und Anwendungsf√§llen** unterscheiden.

---

## **1. Klassische Funktionsdeklaration**
Die **Funktionsdeklaration** ist die traditionelle Methode zur Definition von Funktionen.

```javascript
function addiere(a, b) {
  return a + b;
}

console.log(addiere(3, 5)); // 8
```
‚úÖ **Eigenschaften**:
- Kann **vor der Definition** aufgerufen werden (Hoisting).
- Hat eine eigene `this`-Bindung.

---

## **2. Funktionsausdruck**
Ein **Funktionsausdruck** speichert eine Funktion in einer Variable.

```javascript
const subtrahiere = function (a, b) {
  return a - b;
};

console.log(subtrahiere(10, 4)); // 6
```
‚úÖ **Eigenschaften**:
- Muss **nach der Definition** aufgerufen werden.
- Ist n√ºtzlich f√ºr **anonyme Funktionen**.

---

## **3. Pfeilfunktionen (`=>`)**
Pfeilfunktionen bieten eine **k√ºrzere Syntax** und √ºbernehmen `this` aus dem umgebenden Kontext.

```javascript
const multipliziere = (a, b) => a * b;

console.log(multipliziere(3, 4)); // 12
```

üìå **Besonderheiten von Pfeilfunktionen**:
- **Kein eigenes `this`** (√ºbernimmt `this` vom √§u√üeren Kontext).
- **Kein `arguments`-Objekt**.
- K√ºrzere Syntax, **besonders f√ºr Callbacks**.

### **Beispiel: `this` in Pfeilfunktionen**
```javascript
const person = {
  name: "Max",
  sagHallo: function() {
    setTimeout(() => {
      console.log(`Hallo, ich bin ${this.name}`);
    }, 1000);
  }
};

person.sagHallo(); // Hallo, ich bin Max (weil `this` von `person` kommt)
```
- **Normale Funktionen** w√ºrden `this` verlieren (`undefined` oder `window`).
- **Pfeilfunktionen** behalten `this` vom √§u√üeren Scope.

---

## **4. Immediately Invoked Function Expression (IIFE)**
Ein **IIFE** (Sofort ausgef√ºhrter Funktionsausdruck) wird **direkt nach der Definition** ausgef√ºhrt.

```javascript
(function() {
  console.log("Ich bin ein IIFE!");
})(); // Ich bin ein IIFE!
```
Oder mit **Pfeilfunktion**:

```javascript
(() => {
  console.log("IIFE mit Pfeilfunktion!");
})(); // IIFE mit Pfeilfunktion!
```

üìå **Anwendungsf√§lle f√ºr IIFE**:
- Um **Variablen vor dem globalen Scope zu sch√ºtzen**.
- Einmalige Initialisierungen oder Konfigurationen.

---

## **Zusammenfassung**
- **Funktionsdeklarationen** (`function name()`) sind **hoistbar** und haben ein eigenes `this`.
- **Funktionsausdr√ºcke** (`const name = function() {}`) m√ºssen zuerst definiert werden.
- **Pfeilfunktionen** (`const name = () => {}`) haben **kein eigenes `this`** und sind ideal f√ºr Callbacks.
- **IIFE (`(function() {})()`)** werden sofort ausgef√ºhrt und kapseln Variablen.

üîó [MDN-Dokumentation zu Funktionen](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Functions)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

22. ### <a name="22"></a> Methoden zur Kontextbindung (call, apply, bind)

### **Methoden zur Kontextbindung (`call`, `apply`, `bind`) in JavaScript**

In JavaScript kann das `this`-Binding einer Funktion dynamisch ver√§ndert werden. Daf√ºr gibt es drei Methoden:  
- `call()`
- `apply()`
- `bind()`

Diese Methoden werden verwendet, um **Funktionen mit einem bestimmten `this`-Wert auszuf√ºhren**.

---

## **1. `call()` ‚Äì Funktion mit explizitem `this`-Wert aufrufen**
Die Methode `call()` ruft eine Funktion mit einem bestimmten `this`-Wert und einzelnen Argumenten auf.

```javascript
function begruessen(land, sprache) {
  console.log(`Hallo, ich bin ${this.name} aus ${land}, und ich spreche ${sprache}.`);
}

const person = { name: "Max" };

begruessen.call(person, "Deutschland", "Deutsch");
// Hallo, ich bin Max aus Deutschland, und ich spreche Deutsch.
```
‚úÖ **Eigenschaften**:
- `this` wird auf `person` gesetzt.
- Die Argumente werden **einzeln √ºbergeben**.

---

## **2. `apply()` ‚Äì √Ñhnlich wie `call()`, aber mit Array als Argumente**
Die Methode `apply()` funktioniert wie `call()`, aber Argumente werden als **Array** √ºbergeben.

```javascript
begruessen.apply(person, ["Frankreich", "Franz√∂sisch"]);
// Hallo, ich bin Max aus Frankreich, und ich spreche Franz√∂sisch.
```
‚úÖ **Unterschied zu `call()`**:
- Argumente werden **als Array** (`[]`) √ºbergeben, nicht einzeln.

---

## **3. `bind()` ‚Äì Neue Funktion mit festem `this` erstellen**
Die Methode `bind()` gibt eine **neue Funktion** zur√ºck, in der `this` dauerhaft an ein Objekt gebunden ist.

```javascript
const begruessungMax = begruessen.bind(person);
begruessungMax("Spanien", "Spanisch");
// Hallo, ich bin Max aus Spanien, und ich spreche Spanisch.
```
‚úÖ **Eigenschaften**:
- `this` bleibt dauerhaft auf `person` gebunden.
- Gibt eine **neue Funktion** zur√ºck, die sp√§ter aufgerufen werden kann.

---

## **4. `bind()` f√ºr Methoden in Objekten**
Ein h√§ufiges Problem: **`this`-Verlust in Event-Handlern**.

```javascript
const user = {
  name: "Lisa",
  sagHallo() {
    console.log(`Hallo, ich bin ${this.name}`);
  }
};

const hallo = user.sagHallo;
hallo(); // Fehler: `this` ist `undefined` oder `window`
```
‚úÖ **L√∂sung: `bind()` verwenden**:
```javascript
const halloGebunden = user.sagHallo.bind(user);
halloGebunden(); // Hallo, ich bin Lisa
```
- `bind()` sorgt daf√ºr, dass `this` auf `user` bleibt.

---

## **5. `bind()` in Event-Handlern**
Beim Event-Handling in DOM-Elementen verliert `this` oft die Verbindung zum Objekt.

```javascript
const button = document.querySelector("button");

const handler = {
  text: "Geklickt!",
  clickHandler() {
    console.log(this.text);
  }
};

// Funktion ohne Bindung (Fehlverhalten)
button.addEventListener("click", handler.clickHandler); // `this` ist nicht `handler`

// L√∂sung: `bind()`
button.addEventListener("click", handler.clickHandler.bind(handler));
```

---

### **Zusammenfassung**
- **`call(obj, arg1, arg2, ...)`** ‚Üí F√ºhrt die Funktion sofort mit `this = obj` aus (Argumente einzeln).
- **`apply(obj, [arg1, arg2, ...])`** ‚Üí Wie `call()`, aber Argumente als Array.
- **`bind(obj)`** ‚Üí Erstellt eine neue Funktion mit festem `this`, die sp√§ter aufgerufen wird.

üîó [MDN-Dokumentation zu `call`, `apply` und `bind`](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Function/bind)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

23. ### <a name="23"></a> Closures (Abschl√ºsse)

### **Closures (Abschl√ºsse) in JavaScript**  

Ein **Closure** entsteht, wenn eine **innere Funktion** auf die **Variablen einer √§u√üeren Funktion** zugreift, auch nach dem Abschluss der √§u√üeren Funktion. Dadurch bleibt der Zugriff auf **private Daten** erhalten.

---

## **1. Einfaches Beispiel f√ºr ein Closure**  
```javascript
function begruessung(name) {
  return function() {
    console.log(`Hallo, ${name}!`);
  };
}

const sagHallo = begruessung("Max");
sagHallo(); // Hallo, Max!
```
‚úÖ **Erkl√§rung**:  
- `begruessung("Max")` gibt eine **innere Funktion** zur√ºck.  
- Diese Funktion merkt sich `name`, selbst nachdem `begruessung` beendet wurde.

---

## **2. Datenkapselung mit Closures**  
Closures k√∂nnen **private Variablen** simulieren:

```javascript
function zaehler() {
  let count = 0; // Private Variable

  return {
    hoch: function() { count++; console.log(count); },
    runter: function() { count--; console.log(count); },
    wert: function() { return count; }
  };
}

const meinZaehler = zaehler();
meinZaehler.hoch(); // 1
meinZaehler.hoch(); // 2
meinZaehler.runter(); // 1
console.log(meinZaehler.wert()); // 1
```
‚úÖ **Vorteile**:
- `count` ist **nicht direkt zug√§nglich** (private Variable).
- Zugriff nur √ºber die bereitgestellten Methoden.

---

## **3. Closures in `setTimeout` und Event-Handlern**  
```javascript
function verz√∂gerteNachricht(nachricht, delay) {
  setTimeout(function() {
    console.log(nachricht);
  }, delay);
}

verz√∂gerteNachricht("Hallo nach 2 Sekunden!", 2000);
```
- Die innere Funktion speichert `nachricht` und `delay`, bis `setTimeout` sie ausf√ºhrt.

---

## **4. Closure in einer Schleife (Problem & L√∂sung)**  
‚ùå **Problem mit `var` (kein Block-Scope)**  
```javascript
for (var i = 1; i <= 3; i++) {
  setTimeout(function() {
    console.log(i);
  }, i * 1000);
}
// Ausgabe nach 3 Sekunden: 4, 4, 4 (falsche Werte!)
```
‚úÖ **L√∂sung mit `let` (Block-Scope)**  
```javascript
for (let i = 1; i <= 3; i++) {
  setTimeout(function() {
    console.log(i);
  }, i * 1000);
}
// Ausgabe: 1, 2, 3 (korrekt)
```
‚úÖ **Alternative L√∂sung mit Closure (`var`)**  
```javascript
for (var i = 1; i <= 3; i++) {
  (function(j) {
    setTimeout(function() {
      console.log(j);
    }, j * 1000);
  })(i);
}
```
- Hier wird `i` als Parameter (`j`) an eine sofort ausgef√ºhrte Funktion (`IIFE`) √ºbergeben.

---

### **Zusammenfassung**  
- **Closures** erm√∂glichen Zugriff auf Variablen einer √§u√üeren Funktion, auch nach deren Ausf√ºhrung.  
- **N√ºtzlich f√ºr**:
  - **Datenkapselung** (private Variablen).
  - **Callbacks und Event-Handler**.
  - **Speicherung von Werten √ºber Zeit** (z. B. `setTimeout`).  
- **Probleme mit `var`** ‚Üí Verwende `let` oder eine IIFE-L√∂sung.

üîó [MDN-Dokumentation zu Closures](https://developer.mozilla.org/de/docs/Web/JavaScript/Closures)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

24. ### <a name="24"></a> Callback-Funktionen in JavaScript

### **Callback-Funktionen in JavaScript**  

Eine **Callback-Funktion** ist eine Funktion, die als Argument an eine andere Funktion √ºbergeben wird und **zu einem sp√§teren Zeitpunkt** aufgerufen wird. Callbacks sind essenziell f√ºr **asynchrone Operationen** (z. B. `setTimeout`, Event-Handling, HTTP-Anfragen).

---

## **1. Einfaches Beispiel f√ºr Callbacks**  
```javascript
function begruessen(name, callback) {
  console.log(`Hallo, ${name}!`);
  callback();
}

function verabschieden() {
  console.log("Tsch√ºss!");
}

begruessen("Max", verabschieden);
// Hallo, Max!
// Tsch√ºss!
```
‚úÖ **Erkl√§rung**:
- `verabschieden` wird als **Callback** an `begruessen` √ºbergeben.
- Nach der Begr√º√üung wird `callback()` ausgef√ºhrt.

---

## **2. Callbacks mit `setTimeout` (asynchrones Verhalten)**  
```javascript
function ladeDaten(callback) {
  console.log("Daten werden geladen...");
  setTimeout(() => {
    console.log("Daten erfolgreich geladen.");
    callback();
  }, 2000);
}

function verarbeiteDaten() {
  console.log("Daten werden verarbeitet...");
}

ladeDaten(verarbeiteDaten);
/*
Daten werden geladen...
(Daten werden nach 2 Sekunden geladen)
Daten erfolgreich geladen.
Daten werden verarbeitet...
*/
```
‚úÖ **Erkl√§rung**:
- `ladeDaten()` simuliert eine **asynchrone Operation**.
- Nach 2 Sekunden wird `callback()` (`verarbeiteDaten()`) ausgef√ºhrt.

---

## **3. Callbacks in Arrays (z. B. `forEach`, `map`, `filter`)**
```javascript
const zahlen = [1, 2, 3, 4, 5];

zahlen.forEach((zahl) => {
  console.log(zahl * 2);
});
/*
2
4
6
8
10
*/
```
- `forEach()` nimmt eine **Callback-Funktion** als Argument.
- Die Callback-Funktion wird f√ºr jedes Element des Arrays ausgef√ºhrt.

---

## **4. Callback Hell (verschachtelte Callbacks)**
**Problem**: Wenn Callbacks tief verschachtelt werden, entsteht **"Callback Hell"** (schwer lesbarer Code).

```javascript
function schritt1(callback) {
  setTimeout(() => {
    console.log("Schritt 1 erledigt");
    callback();
  }, 1000);
}

function schritt2(callback) {
  setTimeout(() => {
    console.log("Schritt 2 erledigt");
    callback();
  }, 1000);
}

function schritt3(callback) {
  setTimeout(() => {
    console.log("Schritt 3 erledigt");
    callback();
  }, 1000);
}

schritt1(() => {
  schritt2(() => {
    schritt3(() => {
      console.log("Alle Schritte erledigt!");
    });
  });
});
```
‚ùå **Problem:** Der Code ist schwer zu lesen und zu warten.

‚úÖ **L√∂sung:** Verwende **Promises** oder **async/await** statt Callbacks.

---

### **Zusammenfassung**  
- **Callback-Funktionen** werden als Argumente an andere Funktionen √ºbergeben und sp√§ter ausgef√ºhrt.  
- N√ºtzlich f√ºr **asynchrone Operationen** (z. B. `setTimeout`, HTTP-Anfragen, Events).  
- **Array-Methoden** wie `forEach`, `map`, `filter` verwenden Callbacks.  
- **Callback Hell** (tiefe Verschachtelung) ‚Üí Ersetze Callbacks durch **Promises** oder **async/await**.

üîó [MDN-Dokumentation zu Callbacks](https://developer.mozilla.org/de/docs/Glossary/Callback-Funktion)  

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

25. ### <a name="25"></a> Konstruktor-Funktionen

In JavaScript sind **Konstruktor-Funktionen** spezielle Funktionen, die zur Erstellung von Objekten verwendet werden. Sie werden mit dem Schl√ºsselwort `new` aufgerufen und erm√∂glichen die Wiederverwendung von Objektstrukturen.

### **Syntax einer Konstruktor-Funktion**
```javascript
function Person(name, alter) {
  this.name = name; // Eigenschaft "name"
  this.alter = alter; // Eigenschaft "alter"

  this.greet = function() {
    console.log(`Hallo, mein Name ist ${this.name} und ich bin ${this.alter} Jahre alt.`);
  };
}

const person1 = new Person("Max", 30);
const person2 = new Person("Anna", 25);

person1.greet(); // Hallo, mein Name ist Max und ich bin 30 Jahre alt.
person2.greet(); // Hallo, mein Name ist Anna und ich bin 25 Jahre alt.
```
- Das Schl√ºsselwort `this` referenziert das erstellte Objekt.
- `new Person("Max", 30)` erzeugt ein neues Objekt mit den Eigenschaften `name` und `alter`.

### **Prototyp-Methode statt Direktdefinition**
Jede Instanz einer Konstruktor-Funktion erh√§lt eine eigene Kopie der Methoden. Eine effizientere L√∂sung ist die Verwendung des **Prototyps**, da Methoden dann von allen Instanzen geteilt werden:

```javascript
function Person(name, alter) {
  this.name = name;
  this.alter = alter;
}

// Methode im Prototyp definieren (spart Speicherplatz)
Person.prototype.greet = function() {
  console.log(`Hallo, mein Name ist ${this.name} und ich bin ${this.alter} Jahre alt.`);
};

const person3 = new Person("Lena", 28);
person3.greet(); // Hallo, mein Name ist Lena und ich bin 28 Jahre alt.
```

### **Zusammenfassung**
- Konstruktor-Funktionen werden mit `new` aufgerufen.
- `this` verweist auf die erstellte Instanz.
- Methoden sollten √ºber `prototype` hinzugef√ºgt werden, um Speicher zu sparen.

üîó [MDN-Dokumentation zu Konstruktor-Funktionen](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Operators/new)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

26. ### <a name="26"></a> Aufrufkontext (this)

Der **Aufrufkontext (`this`)** in JavaScript bestimmt, auf welches Objekt sich `this` innerhalb einer Funktion oder Methode bezieht. Der Wert von `this` h√§ngt davon ab, wie die Funktion aufgerufen wird.

### **1. Globaler Kontext (`this` in der obersten Ebene)**
Im globalen Kontext verweist `this`:
- Im **Browser** auf das `window`-Objekt.
- In **Node.js** auf `global`.

```javascript
console.log(this); // Im Browser: window, in Node.js: global
```

### **2. `this` in einer Funktion**
Ohne `use strict` verweist `this` in einer normalen Funktion auf das globale Objekt. Mit `"use strict"` ist `this` `undefined`.

```javascript
function test() {
  console.log(this);
}

test(); // Browser: window, Node.js: global (ohne strict)
```

Mit **strict mode**:

```javascript
"use strict";
function testStrict() {
  console.log(this);
}

testStrict(); // undefined
```

### **3. `this` in Objekten (Methoden)**
Wird eine Funktion als Methode eines Objekts aufgerufen, verweist `this` auf das Objekt selbst.

```javascript
const person = {
  name: "Max",
  greet: function() {
    console.log(`Hallo, ich bin ${this.name}`);
  }
};

person.greet(); // Hallo, ich bin Max
```

### **4. `this` in Konstruktor-Funktionen**
Bei Konstruktor-Funktionen verweist `this` auf die neu erstellte Instanz.

```javascript
function Person(name) {
  this.name = name;
}

const max = new Person("Max");
console.log(max.name); // Max
```

### **5. `this` in Arrow-Funktionen**
Arrow-Funktionen √ºbernehmen `this` aus dem umgebenden Lexikalischen Kontext (kein eigenes `this`!).

```javascript
const person = {
  name: "Anna",
  greet: function() {
    const arrowFunction = () => console.log(this.name);
    arrowFunction(); // this bleibt auf `person` bezogen
  }
};

person.greet(); // Anna
```

### **6. Explizite Steuerung von `this` (`call`, `apply`, `bind`)**
Man kann `this` manuell setzen mit `call()`, `apply()` oder `bind()`.

```javascript
function greet() {
  console.log(`Hallo, ich bin ${this.name}`);
}

const user = { name: "Lisa" };

greet.call(user);  // Hallo, ich bin Lisa
greet.apply(user); // Hallo, ich bin Lisa

const boundGreet = greet.bind(user);
boundGreet(); // Hallo, ich bin Lisa
```

### **Zusammenfassung**
- `this` h√§ngt vom **Aufrufkontext** ab.
- In einer **Funktion** (strict mode) ist `this` `undefined`, sonst `window/global`.
- In **Methoden** zeigt `this` auf das aufrufende Objekt.
- In **Konstruktoren** verweist `this` auf die erstellte Instanz.
- **Arrow-Funktionen** haben kein eigenes `this`, sondern √ºbernehmen es aus der Umgebung.
- **`call`, `apply`, `bind`** erlauben das manuelle Setzen von `this`.

üîó [MDN-Dokumentation zu `this`](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Operators/this)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

27. ### <a name="27"></a> Getter und Setter (Objekteigenschaften)

In JavaScript erm√∂glichen **Getter** und **Setter** den kontrollierten Zugriff auf Objekteigenschaften. Sie werden mit `get` und `set` innerhalb eines Objekts oder einer Klasse definiert.

---

### **1. Getter (`get`)**
Getter sind Methoden, die eine Eigenschaft abrufen, aber wie normale Eigenschaften verwendet werden.

```javascript
const person = {
  vorname: "Max",
  nachname: "Mustermann",
  
  get vollerName() {
    return `${this.vorname} ${this.nachname}`;
  }
};

console.log(person.vollerName); // Max Mustermann
```
- `vollerName` wird als Eigenschaft aufgerufen (`person.vollerName`), aber intern als Methode definiert.

---

### **2. Setter (`set`)**
Setter erm√∂glichen das Festlegen von Eigenschaftswerten und k√∂nnen Validierung oder Formatierung enthalten.

```javascript
const user = {
  _alter: 0, // Private Variable (Konvention: Unterstrich)

  get alter() {
    return this._alter;
  },

  set alter(value) {
    if (value < 0) {
      console.log("Alter kann nicht negativ sein!");
    } else {
      this._alter = value;
    }
  }
};

user.alter = 25;
console.log(user.alter); // 25

user.alter = -5; // Alter kann nicht negativ sein!
```
- Der `set`-Methodenaufruf `user.alter = -5` verhindert ung√ºltige Werte.

---

### **3. Getter und Setter in Klassen**
In Klassen k√∂nnen Getter und Setter auf Instanzvariablen zugreifen.

```javascript
class Auto {
  constructor(marke, baujahr) {
    this.marke = marke;
    this._baujahr = baujahr; // Private Variable
  }

  get baujahr() {
    return this._baujahr;
  }

  set baujahr(value) {
    if (value < 1886) {
      console.log("Ung√ºltiges Baujahr!");
    } else {
      this._baujahr = value;
    }
  }
}

const meinAuto = new Auto("Tesla", 2022);
console.log(meinAuto.baujahr); // 2022

meinAuto.baujahr = 1800; // Ung√ºltiges Baujahr!
```

---

### **Zusammenfassung**
- **Getter (`get`)**: Erlauben den kontrollierten Zugriff auf Eigenschaften.
- **Setter (`set`)**: Erm√∂glichen das Setzen und Validieren von Werten.
- Werden oft f√ºr **Datenkapselung** verwendet.
- K√∂nnen in **Objekten** und **Klassen** definiert werden.

üîó [MDN-Dokumentation zu Getter und Setter](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Functions/get)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

28. ### <a name="28"></a> Generatorfunktionen in JavaScript

### **Generatorfunktionen in JavaScript**
Generatorfunktionen (`function*`) erm√∂glichen das **pausieren und fortsetzen** der Codeausf√ºhrung mit `yield`. Sie sind besonders n√ºtzlich f√ºr iterative Prozesse und Lazy Evaluation.

---

### **1. Syntax einer Generatorfunktion**
```javascript
function* meineGeneratorFunktion() {
  yield 1;
  yield 2;
  yield 3;
}

const generator = meineGeneratorFunktion();

console.log(generator.next()); // { value: 1, done: false }
console.log(generator.next()); // { value: 2, done: false }
console.log(generator.next()); // { value: 3, done: false }
console.log(generator.next()); // { value: undefined, done: true }
```
- Das `yield`-Schl√ºsselwort pausiert die Funktion und gibt einen Wert zur√ºck.
- `next()` setzt die Funktion an der letzten `yield`-Stelle fort.

---

### **2. Generator in einer Schleife**
Man kann Generatoren mit `for...of` durchlaufen:

```javascript
function* zahlenGenerator() {
  yield 10;
  yield 20;
  yield 30;
}

for (const zahl of zahlenGenerator()) {
  console.log(zahl);
}
// 10
// 20
// 30
```

---

### **3. Unendliche Generatoren**
Generatoren k√∂nnen **endlos laufen**, ohne den Speicher zu √ºberlasten:

```javascript
function* unendlicherZ√§hler() {
  let i = 1;
  while (true) {
    yield i++;
  }
}

const counter = unendlicherZ√§hler();
console.log(counter.next().value); // 1
console.log(counter.next().value); // 2
console.log(counter.next().value); // 3
```

---

### **4. `yield` mit Parametern**
Man kann `next(value)` verwenden, um Werte an den Generator zur√ºckzugeben:

```javascript
function* bidirektionalerGenerator() {
  const wert1 = yield "Erster Wert?";
  const wert2 = yield `Zweiter Wert ist ${wert1}`;
  return `Dritter Wert ist ${wert2}`;
}

const gen = bidirektionalerGenerator();
console.log(gen.next().value);      // "Erster Wert?"
console.log(gen.next(42).value);    // "Zweiter Wert ist 42"
console.log(gen.next(100).value);   // "Dritter Wert ist 100"
```

---

### **5. `yield*` f√ºr geschachtelte Generatoren**
Mit `yield*` kann man einen anderen Generator aufrufen:

```javascript
function* unterGenerator() {
  yield "A";
  yield "B";
}

function* hauptGenerator() {
  yield* unterGenerator();
  yield "C";
}

for (const wert of hauptGenerator()) {
  console.log(wert);
}
// A
// B
// C
```

---

### **Zusammenfassung**
- Generatorfunktionen (`function*`) erlauben das **pausieren und fortsetzen** der Codeausf√ºhrung.
- `yield` gibt einen Wert zur√ºck, `next()` setzt die Funktion fort.
- Generatoren eignen sich f√ºr **Lazy Evaluation, unendliche Sequenzen** und **asynchrone Verarbeitung**.
- `yield*` erm√∂glicht das Delegieren an andere Generatoren.

üîó [MDN-Dokumentation zu Generatorfunktionen](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Statements/function*)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

29. ### <a name="29"></a> Rekursion in JavaScript

### **Rekursion in JavaScript**
Rekursion bedeutet, dass eine Funktion sich **selbst aufruft**, bis eine **Abbruchbedingung** erreicht ist. Sie wird oft f√ºr Probleme mit **nat√ºrlicher Teilung** verwendet, z. B. Baumstrukturen oder mathematische Berechnungen.

---

### **1. Einfaches Beispiel: Countdown**
```javascript
function countdown(n) {
  if (n <= 0) {
    console.log("Fertig!");
    return;
  }
  console.log(n);
  countdown(n - 1); // Rekursiver Aufruf
}

countdown(5);
/*
5
4
3
2
1
Fertig!
*/
```
- Die Funktion ruft sich mit `n - 1` selbst auf.
- Sobald `n <= 0`, stoppt die Rekursion (**Abbruchbedingung**).

---

### **2. Fakult√§t berechnen (n!)**
Die **Fakult√§t** eines Zahl `n` ist `n * (n-1) * (n-2) * ... * 1`.

```javascript
function fakultaet(n) {
  if (n === 0) return 1; // Abbruchbedingung
  return n * fakultaet(n - 1); // Rekursiver Aufruf
}

console.log(fakultaet(5)); // 120 (5*4*3*2*1)
```
- Ohne Abbruchbedingung w√ºrde die Funktion **unendlich laufen**.

---

### **3. Fibonacci-Folge**
Die **Fibonacci-Zahlen** sind definiert als:
- `fib(0) = 0`, `fib(1) = 1`
- `fib(n) = fib(n-1) + fib(n-2)`

```javascript
function fibonacci(n) {
  if (n <= 1) return n; // Basisf√§lle
  return fibonacci(n - 1) + fibonacci(n - 2);
}

console.log(fibonacci(6)); // 8 (0,1,1,2,3,5,8)
```
‚ùå **Problem:** Rekursion kann ineffizient sein, da viele Werte mehrfach berechnet werden.

‚úÖ **L√∂sung:** **Memoization** zur Optimierung:

```javascript
function fibonacciMemo(n, memo = {}) {
  if (n in memo) return memo[n];
  if (n <= 1) return n;
  
  memo[n] = fibonacciMemo(n - 1, memo) + fibonacciMemo(n - 2, memo);
  return memo[n];
}

console.log(fibonacciMemo(50)); // Sehr schnelle Berechnung
```

---

### **4. Rekursion f√ºr verschachtelte Strukturen (Baum-Durchlauf)**
Rekursion ist ideal f√ºr **hierarchische Daten**, wie verschachtelte Objekte oder B√§ume.

```javascript
const baum = {
  wert: 1,
  kinder: [
    { wert: 2, kinder: [{ wert: 4 }, { wert: 5 }] },
    { wert: 3, kinder: [{ wert: 6 }] }
  ]
};

function durchlaufeBaum(knoten) {
  console.log(knoten.wert);
  if (knoten.kinder) {
    knoten.kinder.forEach(durchlaufeBaum);
  }
}

durchlaufeBaum(baum);
/*
1
2
4
5
3
6
*/
```
- Die Funktion ruft sich **f√ºr jedes Kind** des Knotens auf.

---

### **5. Tail Call Optimization (TCO)**
Moderne JavaScript-Engines optimieren **Tail-Recursive-Funktionen** (wenn der letzte Ausdruck ein rekursiver Aufruf ist), um **Stack-√úberl√§ufe zu vermeiden**.

```javascript
function summe(n, akk = 0) {
  if (n === 0) return akk;
  return summe(n - 1, akk + n); // Tail Call (optimierbar)
}

console.log(summe(10000)); // Kein Stack Overflow in TCO-f√§higen Umgebungen
```

---

### **Zusammenfassung**
- **Rekursion** bedeutet, dass eine Funktion sich **selbst aufruft**.
- **Wichtig:** Immer eine **Abbruchbedingung** (`if`) definieren, um Endlosschleifen zu vermeiden.
- **Memoization** kann ineffiziente Rekursion optimieren.
- **Ideal f√ºr:** Mathematische Probleme, hierarchische Strukturen (B√§ume), Algorithmen wie Tiefensuche.
- **Tail Call Optimization (TCO)** reduziert Speicherverbrauch, aber nicht in allen JavaScript-Engines unterst√ºtzt.

üîó [MDN-Dokumentation zu Rekursion](https://developer.mozilla.org/de/docs/Glossary/Rekursion)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

30. ### <a name="30"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

31. ### <a name="31"></a> Objekte, Destrukturierung von Objekten (ES6)

### **Objekte & Destrukturierung von Objekten (ES6) in JavaScript**  

---

## **1. Objekte in JavaScript**  
Ein **Objekt** ist eine Sammlung von **Schl√ºssel-Wert-Paaren**.

```javascript
const person = {
  name: "Max",
  alter: 30,
  beruf: "Entwickler"
};

console.log(person.name);  // Max
console.log(person["alter"]); // 30
```
‚úÖ **Eigenschaften von Objekten**:  
- Werte k√∂nnen **beliebige Datentypen** sein (Strings, Arrays, andere Objekte).
- Zugriff √ºber **Punkt-Notation (`.`)** oder **Array-Notation (`[]`)**.

---

## **2. ES6-Destrukturierung von Objekten**  
Mit **Destrukturierung** kann man **Eigenschaften direkt extrahieren**.

```javascript
const person = { name: "Anna", alter: 25, beruf: "Designer" };

const { name, alter } = person;

console.log(name); // Anna
console.log(alter); // 25
```
‚úÖ **Vorteile**:  
- Spart **Schreibarbeit** (`person.name` ‚Üí `name`).
- Einfachere **Funktionseingaben**.

---

## **3. Destrukturierung mit Standardwerten**
Falls eine Eigenschaft **nicht existiert**, kann ein **Standardwert** gesetzt werden.

```javascript
const user = { name: "Lisa" };

const { name, alter = 18 } = user;

console.log(alter); // 18 (Standardwert)
```

---

## **4. Umbenennung von Variablen bei der Destrukturierung**
Man kann Eigenschaftsnamen **umbenennen**.

```javascript
const auto = { marke: "Tesla", baujahr: 2023 };

const { marke: hersteller, baujahr } = auto;

console.log(hersteller); // Tesla
```

---

## **5. Destrukturierung in Funktionen**  
```javascript
function zeigeInfo({ name, alter }) {
  console.log(`${name} ist ${alter} Jahre alt.`);
}

const person = { name: "Tom", alter: 40 };
zeigeInfo(person); // Tom ist 40 Jahre alt.
```
‚úÖ **Vorteile**:  
- Die Funktion erh√§lt direkt die **relevanten Werte**.

---

## **6. Verschachtelte Objekte destrukturieren**
```javascript
const student = {
  name: "Sophia",
  adresse: {
    stadt: "Berlin",
    land: "Deutschland"
  }
};

const { adresse: { stadt, land } } = student;

console.log(stadt); // Berlin
console.log(land); // Deutschland
```
‚úÖ **Hierbei wird `adresse` nicht als Variable erstellt!**  
Falls n√∂tig, kann man `adresse` zus√§tzlich speichern:
```javascript
const { adresse, adresse: { stadt } } = student;
console.log(adresse); // { stadt: "Berlin", land: "Deutschland" }
```

---

### **Zusammenfassung**
- **Objekte** sind Sammlungen von Schl√ºssel-Wert-Paaren.
- **Destrukturierung** vereinfacht den Zugriff auf Eigenschaften.
- **Standardwerte** k√∂nnen gesetzt werden.
- **Eigenschaftsnamen k√∂nnen umbenannt werden**.
- **Verschachtelte Objekte** lassen sich destrukturieren.
- **N√ºtzlich in Funktionen**, um nur relevante Daten zu extrahieren.

üîó [MDN-Dokumentation zur Destrukturierung](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Operators/Destrukturierende_Zuweisung)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

32. ### <a name="32"></a> Methoden Object, Object.prototype

### **Methoden von `Object` & `Object.prototype` in JavaScript**

In JavaScript gibt es zwei Kategorien von Methoden f√ºr Objekte:

1. **`Object`-Methoden** ‚Üí Statische Methoden von `Object`
2. **`Object.prototype`-Methoden** ‚Üí Methoden, die jedes Objekt erbt

---

## **1. `Object`-Methoden (statische Methoden)**
Diese Methoden werden direkt auf `Object` aufgerufen.

### **1.1 `Object.keys(obj)` ‚Äì Alle Schl√ºssel eines Objekts**
```javascript
const person = { name: "Anna", alter: 28, beruf: "Designer" };

console.log(Object.keys(person)); // ["name", "alter", "beruf"]
```

### **1.2 `Object.values(obj)` ‚Äì Alle Werte eines Objekts**
```javascript
console.log(Object.values(person)); // ["Anna", 28, "Designer"]
```

### **1.3 `Object.entries(obj)` ‚Äì Schl√ºssel-Wert-Paare als Array**
```javascript
console.log(Object.entries(person));
// [["name", "Anna"], ["alter", 28], ["beruf", "Designer"]]
```

### **1.4 `Object.assign(target, source)` ‚Äì Objekte zusammenf√ºhren**
```javascript
const obj1 = { a: 1 };
const obj2 = { b: 2 };
const merged = Object.assign({}, obj1, obj2);

console.log(merged); // { a: 1, b: 2 }
```

### **1.5 `Object.freeze(obj)` ‚Äì Objekt unver√§nderlich machen**
```javascript
const buch = { titel: "JavaScript", preis: 30 };
Object.freeze(buch);

buch.preis = 40; // Fehler (im strikten Modus)
console.log(buch.preis); // 30 (unver√§ndert)
```

### **1.6 `Object.seal(obj)` ‚Äì Keine neuen Eigenschaften, aber √Ñnderung erlaubt**
```javascript
const auto = { marke: "Tesla", farbe: "Rot" };
Object.seal(auto);

auto.farbe = "Blau"; // OK
auto.modell = "Model S"; // ‚ùå Fehler (Eigenschaft kann nicht hinzugef√ºgt werden)
console.log(auto); // { marke: "Tesla", farbe: "Blau" }
```

### **1.7 `Object.create(proto)` ‚Äì Neues Objekt mit bestimmtem Prototyp**
```javascript
const tier = { typ: "S√§ugetier" };
const hund = Object.create(tier);

console.log(hund.typ); // "S√§ugetier" (geerbt von `tier`)
```

---

## **2. `Object.prototype`-Methoden**
Diese Methoden sind f√ºr **alle Objekte verf√ºgbar**, weil sie von `Object.prototype` erben.

### **2.1 `obj.hasOwnProperty(prop)` ‚Äì Pr√ºft, ob eine Eigenschaft direkt existiert**
```javascript
const person = { name: "Max" };

console.log(person.hasOwnProperty("name")); // true
console.log(person.hasOwnProperty("alter")); // false
```
üîπ **Warum wichtig?**  
Verhindert, dass geerbte Eigenschaften (`prototype`) f√§lschlicherweise als eigene Eigenschaften interpretiert werden.

---

### **2.2 `obj.toString()` ‚Äì Objekt in String umwandeln**
```javascript
const zahl = 123;
console.log(zahl.toString()); // "123"

const array = [1, 2, 3];
console.log(array.toString()); // "1,2,3"
```

---

### **2.3 `obj.valueOf()` ‚Äì Gibt den Prim√§rwert eines Objekts zur√ºck**
```javascript
const num = new Number(42);
console.log(num.valueOf()); // 42
```

---

### **2.4 `obj.isPrototypeOf(obj2)` ‚Äì Pr√ºft, ob ein Objekt Prototyp eines anderen ist**
```javascript
function Tier() {}
const hund = new Tier();

console.log(Tier.prototype.isPrototypeOf(hund)); // true
```

---

### **Zusammenfassung**
- **`Object.keys()`**, **`Object.values()`**, **`Object.entries()`** ‚Üí Arbeiten mit Eigenschaften.
- **`Object.assign()`**, **`Object.create()`**, **`Object.freeze()`**, **`Object.seal()`** ‚Üí Objektverwaltung.
- **`hasOwnProperty()`** ‚Üí Pr√ºft, ob eine Eigenschaft direkt im Objekt existiert.
- **`toString()`**, **`valueOf()`** ‚Üí Umwandlung von Objekten in Strings oder primitive Werte.

üîó [MDN-Dokumentation zu `Object`](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Object)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

33. ### <a name="33"></a> M√∂glichkeiten zur Objekterstellung

### **M√∂glichkeiten zur Objekterstellung in JavaScript**  

In JavaScript gibt es mehrere M√∂glichkeiten, ein Objekt zu erstellen. Jede Methode hat ihre eigenen **Anwendungsf√§lle und Vorteile**.

---

## **1. Objekt-Literal (`{}`)**
Die einfachste Methode, um ein Objekt zu erstellen.

```javascript
const person = {
  name: "Max",
  alter: 30,
  beruf: "Entwickler"
};

console.log(person.name); // Max
```
‚úÖ **Vorteile**:  
- Schnell und einfach f√ºr kleine Objekte  
- Kein `new` oder Prototyp erforderlich  

---

## **2. `Object.create(prototype)`**
Erstellt ein neues Objekt mit einem bestimmten **Prototyp**.

```javascript
const tier = {
  typ: "S√§ugetier"
};

const hund = Object.create(tier);
hund.name = "Bello";

console.log(hund.typ); // "S√§ugetier" (geerbt von `tier`)
console.log(hund.hasOwnProperty("typ")); // false (kommt aus dem Prototyp)
```
‚úÖ **Vorteile**:  
- Erlaubt direkte Kontrolle √ºber den **Prototyp**  
- Gut f√ºr **Prototypen-Vererbung**  

---

## **3. `new Object()` (Konstruktor von `Object`)**
Alternative zu `{}`.

```javascript
const person = new Object();
person.name = "Anna";
person.alter = 25;

console.log(person.name); // Anna
```
‚ùå **Weniger gebr√§uchlich**, da `{}` k√ºrzer und verst√§ndlicher ist.

---

## **4. Konstruktorfunktion**
Verwendet eine Funktion, um **mehrere Objekte mit √§hnlicher Struktur** zu erstellen.

```javascript
function Person(name, alter) {
  this.name = name;
  this.alter = alter;
}

const person1 = new Person("Lisa", 28);
const person2 = new Person("Tom", 35);

console.log(person1.name); // Lisa
console.log(person2.alter); // 35
```
‚úÖ **Vorteile**:  
- Erm√∂glicht das Erstellen **mehrerer Instanzen**  
- `this` verweist auf das erstellte Objekt  
‚ùå **Nachteile**:  
- Methoden werden bei jeder Instanz neu erstellt (besser `prototype` verwenden).  

---

## **5. Konstruktorfunktion mit `prototype` (Speichereffizienter)**
```javascript
function Auto(marke) {
  this.marke = marke;
}

Auto.prototype.fahren = function() {
  console.log(`${this.marke} f√§hrt.`);
};

const meinAuto = new Auto("Tesla");
meinAuto.fahren(); // Tesla f√§hrt.
```
‚úÖ **Speichert Methoden im Prototyp, nicht bei jeder Instanz**.

---

## **6. ES6 Klassen (`class`)**
Klassen sind eine modernere Alternative zu Konstruktorfunktionen.

```javascript
class Fahrzeug {
  constructor(marke) {
    this.marke = marke;
  }

  fahren() {
    console.log(`${this.marke} f√§hrt.`);
  }
}

const auto = new Fahrzeug("BMW");
auto.fahren(); // BMW f√§hrt.
```
‚úÖ **Vorteile**:  
- Klarere Syntax  
- Bessere Lesbarkeit f√ºr objektorientierte Programmierung  

---

## **7. Fabrikfunktion (Factory Function)**
Eine **Funktion, die Objekte zur√ºckgibt**, ohne `new`.

```javascript
function erstellePerson(name, alter) {
  return {
    name,
    alter,
    sagHallo() {
      console.log(`Hallo, ich bin ${this.name}.`);
    }
  };
}

const person = erstellePerson("Markus", 40);
person.sagHallo(); // Hallo, ich bin Markus.
```
‚úÖ **Vorteile**:  
- Kein `new` erforderlich  
- Gut f√ºr **geschlossene (private) Variablen**  

---

## **8. JSON (`JSON.parse()` & `JSON.stringify()`)**
### **Objekt aus JSON-String erstellen**
```javascript
const jsonString = '{"name": "Elena", "alter": 22}';
const person = JSON.parse(jsonString);

console.log(person.name); // Elena
```

### **Objekt in JSON umwandeln**
```javascript
const jsonDaten = JSON.stringify(person);
console.log(jsonDaten); // {"name":"Elena","alter":22}
```
‚úÖ **Wichtig f√ºr:**  
- **Daten√ºbertragung (APIs)**  
- **Speicherung in `localStorage`**  

---

### **Zusammenfassung**
| Methode | Vorteile | Nachteile |
|---------|---------|-----------|
| **`{}` (Objekt-Literal)** | Einfach, direkt | Nicht f√ºr viele Instanzen |
| **`Object.create(proto)`** | Direktes Prototyp-Handling | Komplexe Vererbung |
| **`new Object()`** | Alternative zu `{}` | L√§nger als `{}` |
| **Konstruktorfunktion (`new`)** | Strukturierte Erstellung | Methoden ineffizient ohne `prototype` |
| **Konstruktorfunktion mit `prototype`** | Speicheroptimiert | Weniger intuitiv als `class` |
| **`class` (ES6)** | Klarer, modernes OOP | Komplexer als einfache Objekte |
| **Fabrikfunktion (`Factory Function`)** | Kein `new`, einfach zu lesen | Kein direkter Prototypzugriff |
| **JSON (`JSON.parse()`)** | API-kompatibel | Kein Verhalten (Methoden) |

üîó [MDN-Dokumentation zu Objekten](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Object)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

34. ### <a name="34"></a> Kopieren von Objekten

### **Kopieren von Objekten in JavaScript**  

Beim Kopieren von Objekten in JavaScript gibt es zwei Arten:  

1. **Shallow Copy (flache Kopie)** ‚Äì Kopiert nur die erste Ebene der Eigenschaften (tiefer liegende Objekte bleiben referenziert).  
2. **Deep Copy (tiefe Kopie)** ‚Äì Erstellt eine vollst√§ndige Kopie, auch von verschachtelten Objekten.  

---

## **1. Shallow Copy (Flache Kopie)**  

Flache Kopien duplizieren nur die **oberste Ebene** des Objekts. Falls das Objekt **verschachtelte Objekte** enth√§lt, bleiben diese referenziert (√Ñnderungen im Original wirken sich auf die Kopie aus).  

### **1.1 `Object.assign(target, source)`**
```javascript
const original = { a: 1, b: { c: 2 } };
const kopie = Object.assign({}, original);

kopie.a = 42;
kopie.b.c = 99; // Achtung: Referenzierte Objekte werden nicht kopiert!

console.log(original.b.c); // 99 (auch ge√§ndert!)
```

‚úÖ **Schnelle flache Kopie**  
‚ùå **Nicht f√ºr verschachtelte Objekte geeignet**

---

### **1.2 Spread-Operator (`{ ...obj }`)**
```javascript
const original = { a: 1, b: { c: 2 } };
const kopie = { ...original };

kopie.a = 42;
kopie.b.c = 99; // Wieder nur eine Referenz!

console.log(original.b.c); // 99 (Original ebenfalls ver√§ndert!)
```
‚úÖ **Einfacher als `Object.assign()`**  
‚ùå **Nur erste Ebene wird kopiert**

---

## **2. Deep Copy (Tiefe Kopie)**  

### **2.1 `JSON.parse(JSON.stringify(obj))` (einfache L√∂sung)**
```javascript
const original = { a: 1, b: { c: 2 } };
const kopie = JSON.parse(JSON.stringify(original));

kopie.b.c = 99;

console.log(original.b.c); // 2 (Original bleibt unver√§ndert)
```
‚úÖ **Einfache Methode f√ºr tiefe Kopien**  
‚ùå **Verliert Funktionen, `undefined`, Symbole**  

---

### **2.2 Rekursive Funktion f√ºr tiefe Kopie**
```javascript
function deepCopy(obj) {
  if (obj === null || typeof obj !== "object") return obj;

  const kopie = Array.isArray(obj) ? [] : {};

  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      kopie[key] = deepCopy(obj[key]);
    }
  }
  return kopie;
}

const original = { a: 1, b: { c: 2 } };
const kopie = deepCopy(original);

kopie.b.c = 99;

console.log(original.b.c); // 2 (Original bleibt unver√§ndert)
```
‚úÖ **Kopiert auch Funktionen, Arrays, `undefined`**  
‚ùå **Aufwendiger als `JSON.parse()`**

---

### **2.3 `structuredClone(obj)` (Moderne L√∂sung)**
```javascript
const original = { a: 1, b: { c: 2 }, d: new Date() };
const kopie = structuredClone(original);

kopie.b.c = 99;

console.log(original.b.c); // 2 (Original bleibt unver√§ndert)
console.log(kopie.d instanceof Date); // true (Kopiert auch `Date`!)
```
‚úÖ **Unterst√ºtzt `Date`, Arrays, `Map`, `Set`**  
‚úÖ **Schnell & sicher**  
‚ùå **Nicht in √§lteren Browsern verf√ºgbar**  

---

### **Zusammenfassung**
| Methode | Typ | Vorteile | Nachteile |
|---------|-----|----------|------------|
| **`Object.assign({}, obj)`** | Flach | Schnell & einfach | Tiefe Objekte bleiben referenziert |
| **`{ ...obj }` (Spread)** | Flach | K√ºrzere Syntax | Keine tiefe Kopie |
| **`JSON.parse(JSON.stringify(obj))`** | Tief | Einfach & schnell | Verliert Methoden & `undefined` |
| **Rekursive Funktion** | Tief | Behandelt alle Datentypen | Komplexer |
| **`structuredClone(obj)`** | Tief | Beste moderne L√∂sung | Nicht √ºberall unterst√ºtzt |

üîó [MDN-Dokumentation zu `structuredClone()`](https://developer.mozilla.org/de/docs/Web/API/structuredClone)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

35. ### <a name="35"></a> Property Descriptors (Eigenschaftsbeschreibungen)

### **Property Descriptors (Eigenschaftsbeschreibungen) in JavaScript**  

Jede Eigenschaft eines Objekts hat **Eigenschaftsbeschreibungen** (**Property Descriptors**), die bestimmen, wie die Eigenschaft funktioniert. Diese k√∂nnen mit `Object.getOwnPropertyDescriptor()` und `Object.defineProperty()` verwaltet werden.

---

## **1. Property Descriptor auslesen**
Mit `Object.getOwnPropertyDescriptor(obj, prop)` kann man die Eigenschaften einer Eigenschaft abrufen.

```javascript
const person = { name: "Max" };

console.log(Object.getOwnPropertyDescriptor(person, "name"));
/*
{
  value: 'Max',
  writable: true,
  enumerable: true,
  configurable: true
}
*/
```

‚úÖ **Standardwerte f√ºr eine Eigenschaft**:  
- `writable: true` ‚Üí Wert kann ge√§ndert werden  
- `enumerable: true` ‚Üí Eigenschaft wird in Schleifen (`for...in`, `Object.keys()`) angezeigt  
- `configurable: true` ‚Üí Eigenschaft kann gel√∂scht oder ver√§ndert werden  

---

## **2. Eigenschaften mit `Object.defineProperty()` setzen**  
Mit `Object.defineProperty(obj, prop, descriptor)` kann man Eigenschaften **kontrollierter definieren**.

### **2.1 `writable: false` ‚Äì Schreibschutz aktivieren**
```javascript
const auto = {};
Object.defineProperty(auto, "marke", {
  value: "Tesla",
  writable: false
});

auto.marke = "BMW"; // ‚ùå Keine √Ñnderung m√∂glich!
console.log(auto.marke); // "Tesla"
```

---

### **2.2 `enumerable: false` ‚Äì Eigenschaft verstecken**
```javascript
const benutzer = { name: "Anna", passwort: "geheim" };

Object.defineProperty(benutzer, "passwort", {
  enumerable: false
});

console.log(Object.keys(benutzer)); // ["name"] (passwort wird nicht angezeigt)
```
‚úÖ **Gut f√ºr sensible Daten!**

---

### **2.3 `configurable: false` ‚Äì Eigenschaft gegen √Ñnderungen sperren**
```javascript
const buch = { titel: "JavaScript Guide" };

Object.defineProperty(buch, "titel", {
  configurable: false
});

// L√∂schen schl√§gt fehl:
delete buch.titel; 
console.log(buch.titel); // "JavaScript Guide"

// `configurable: false` verhindert Neudefinition:
Object.defineProperty(buch, "titel", { writable: true }); // ‚ùå Fehler!
```
‚úÖ **Sch√ºtzt eine Eigenschaft vor Modifikationen oder L√∂schung**

---

## **3. Getter & Setter mit `defineProperty()`**
Man kann auch Getter und Setter definieren.

```javascript
const konto = {
  _saldo: 1000
};

Object.defineProperty(konto, "saldo", {
  get() {
    return `${this._saldo} EUR`;
  },
  set(value) {
    if (value < 0) {
      console.log("Saldo kann nicht negativ sein!");
    } else {
      this._saldo = value;
    }
  }
});

console.log(konto.saldo); // "1000 EUR"
konto.saldo = 500; 
console.log(konto.saldo); // "500 EUR"
konto.saldo = -200; // ‚ùå "Saldo kann nicht negativ sein!"
```
‚úÖ **Steuert den Zugriff auf eine Eigenschaft durch Regeln**

---

### **Zusammenfassung**
| Eigenschaft | Bedeutung |
|------------|-----------|
| `value` | Der Wert der Eigenschaft |
| `writable` | Kann der Wert ge√§ndert werden? (`true` / `false`) |
| `enumerable` | Wird die Eigenschaft in `Object.keys()` und Schleifen (`for...in`) angezeigt? |
| `configurable` | Kann die Eigenschaft gel√∂scht oder ver√§ndert werden? |
| `get()` | Gibt einen Wert zur√ºck (Getter) |
| `set(value)` | Setzt einen Wert mit Logik (Setter) |

üîó [MDN-Dokumentation zu Property Descriptors](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

36. ### <a name="36"></a> Private und gesch√ºtzte Eigenschaften von Objekten

### **Private und gesch√ºtzte Eigenschaften von Objekten in JavaScript**  

JavaScript bietet verschiedene M√∂glichkeiten, **private** oder **gesch√ºtzte Eigenschaften** zu definieren, um Daten **vor direktem Zugriff zu sch√ºtzen**.

---

## **1. Konvention: `_` f√ºr "gesch√ºtzte" Eigenschaften**  
Es gibt **keine echte Privateigenschaft** in normalen Objekten, aber Konventionen helfen:

```javascript
class Nutzer {
  constructor(name) {
    this.name = name;
    this._passwort = "geheim"; // Gesch√ºtzt (Konvention: `_`)
  }

  zeigePasswort() {
    return this._passwort;
  }
}

const user = new Nutzer("Anna");
console.log(user._passwort); // ‚ùå Sollte nicht direkt genutzt werden
console.log(user.zeigePasswort()); // ‚úÖ "geheim"
```
‚úÖ **N√ºtzlich, aber nicht wirklich privat!**  
‚ùå **Jeder kann `_passwort` trotzdem lesen und √§ndern!**

---

## **2. Private Eigenschaften mit `#` (ES2020+)**
Seit ES2020 k√∂nnen **private Eigenschaften** mit `#` definiert werden. Sie sind **au√üerhalb der Klasse nicht zug√§nglich**.

```javascript
class Konto {
  #saldo = 1000; // Private Variable mit `#`

  getSaldo() {
    return this.#saldo;
  }

  einzahlen(betrag) {
    if (betrag > 0) this.#saldo += betrag;
  }
}

const meinKonto = new Konto();
console.log(meinKonto.getSaldo()); // ‚úÖ 1000
meinKonto.einzahlen(500);
console.log(meinKonto.getSaldo()); // ‚úÖ 1500

console.log(meinKonto.#saldo); // ‚ùå Fehler: Private Eigenschaft nicht zug√§nglich!
```
‚úÖ **Echte Privateigenschaften** (nicht von au√üen sichtbar)  
‚ùå **Nicht kompatibel mit √§lteren JavaScript-Versionen**

---

## **3. Private Eigenschaften mit Closures (√§ltere Alternative)**
Vor ES2020 wurden Closures genutzt, um Eigenschaften **privat zu halten**:

```javascript
function erstelleKonto() {
  let saldo = 1000; // Private Variable

  return {
    getSaldo: () => saldo,
    einzahlen: (betrag) => { if (betrag > 0) saldo += betrag; }
  };
}

const konto = erstelleKonto();
console.log(konto.getSaldo()); // ‚úÖ 1000
konto.einzahlen(500);
console.log(konto.getSaldo()); // ‚úÖ 1500

console.log(konto.saldo); // ‚ùå `saldo` ist nicht zug√§nglich!
```
‚úÖ **Private Daten sind gesch√ºtzt**  
‚ùå **Nicht so intuitiv wie `class` mit `#`**

---

## **4. `WeakMap` f√ºr private Eigenschaften**
Eine andere Technik ist die Nutzung von `WeakMap`, um private Eigenschaften au√üerhalb des Objekts zu speichern.

```javascript
const privateDaten = new WeakMap();

class Benutzer {
  constructor(name) {
    privateDaten.set(this, { passwort: "geheim" });
    this.name = name;
  }

  getPasswort() {
    return privateDaten.get(this).passwort;
  }
}

const benutzer = new Benutzer("Tom");
console.log(benutzer.getPasswort()); // ‚úÖ "geheim"

console.log(benutzer.passwort); // ‚ùå `undefined`
```
‚úÖ **Sicherer als `_`-Konvention, aber komplexer**  
‚úÖ **Privat, da `WeakMap`-Werte nicht direkt zug√§nglich sind**  
‚ùå **Mehr Overhead als `#`-Privateigenschaften**

---

### **Zusammenfassung**
| Methode | Privat? | Einfachheit | Kompatibilit√§t |
|---------|---------|------------|---------------|
| `_gesch√ºtzt` (Konvention) | ‚ùå Nein | ‚úÖ Einfach | ‚úÖ √úberall |
| `#privat` (ES2020+) | ‚úÖ Ja | ‚úÖ Einfach | ‚ùå Nicht in √§lteren Browsern |
| **Closure (Funktion + `let`)** | ‚úÖ Ja | ‚ùå Umst√§ndlich | ‚úÖ √úberall |
| `WeakMap` | ‚úÖ Ja | ‚ùå Komplexer | ‚úÖ √úberall |

üîó [MDN-Dokumentation zu privaten Feldern (`#`)](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Classes/Private_class_fields)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

37. ### <a name="37"></a> Prototypen, Prototypen-Kette

### **Prototypen und Prototypen-Kette in JavaScript**  

In JavaScript basiert die **Objektvererbung** auf **Prototypen**. Jedes Objekt hat eine **interne Verbindung zu einem Prototypen**, von dem es Eigenschaften und Methoden erben kann.

---

## **1. Prototyp eines Objekts**
Jedes JavaScript-Objekt hat eine versteckte Verbindung (`[[Prototype]]`) zu einem Prototyp-Objekt, das mit `Object.getPrototypeOf(obj)` oder `__proto__` sichtbar gemacht werden kann.

```javascript
const person = { name: "Max" };

console.log(Object.getPrototypeOf(person)); 
console.log(person.__proto__ === Object.prototype); // true
```
‚úÖ **`Object.prototype` ist der Standard-Prototyp f√ºr Objekte.**  
‚úÖ **`Object.getPrototypeOf(obj)` ist sicherer als `obj.__proto__`**  

---

## **2. Prototypen-Kette (Prototype Chain)**
Wenn eine Eigenschaft nicht im Objekt selbst gefunden wird, sucht JavaScript sie **im Prototypen**.

```javascript
const tier = {
  atmen() {
    console.log("Das Tier atmet.");
  }
};

const hund = Object.create(tier); // `hund` erbt von `tier`
hund.bellen = function() {
  console.log("Wuff!");
};

hund.bellen(); // "Wuff!"
hund.atmen(); // "Das Tier atmet." (geerbt von `tier`)
console.log(Object.getPrototypeOf(hund) === tier); // true
```
‚úÖ **Eigenschaften werden √ºber die Prototypen-Kette vererbt.**  
‚úÖ **Wenn eine Eigenschaft fehlt, wird im n√§chsten Prototyp gesucht.**  

---

## **3. Eigene Prototypen mit Konstruktorfunktionen**
Jede Funktion hat eine `prototype`-Eigenschaft, die f√ºr die Vererbung genutzt wird.

```javascript
function Person(name) {
  this.name = name;
}

Person.prototype.greet = function() {
  console.log(`Hallo, ich bin ${this.name}.`);
};

const max = new Person("Max");
max.greet(); // "Hallo, ich bin Max."
console.log(max.__proto__ === Person.prototype); // true
```
‚úÖ **Methoden werden nur einmal im Prototyp gespeichert, nicht in jeder Instanz.**  
‚ùå **Ohne `new` wird `this` nicht richtig gesetzt.**  

---

## **4. Prototyp-Kette mit Klassen (`class`)**
ES6 **Klassen (`class`)** sind eine modernere Syntax f√ºr Prototypen.

```javascript
class Tier {
  atmen() {
    console.log("Das Tier atmet.");
  }
}

class Hund extends Tier {
  bellen() {
    console.log("Wuff!");
  }
}

const bello = new Hund();
bello.bellen(); // "Wuff!"
bello.atmen(); // "Das Tier atmet." (geerbt von `Tier`)
```
‚úÖ **Klarere Syntax f√ºr Vererbung.**  
‚úÖ **Nutzen intern Prototypen (`extends`).**  

---

## **5. `Object.create(prototype)` f√ºr Prototypen**
```javascript
const katze = Object.create(tier);
katze.miauen = function() {
  console.log("Miau!");
};

katze.atmen(); // "Das Tier atmet." (geerbt)
```
‚úÖ **Flexibel, kein `new` n√∂tig.**  
‚ùå **Kein `instanceof`-Support.**  

---

### **Zusammenfassung**
| Methode | Beschreibung | Vorteile | Nachteile |
|---------|-------------|----------|-----------|
| `Object.create(proto)` | Erstellt ein Objekt mit bestimmtem Prototyp | Einfach, flexibel | Kein `instanceof` |
| **Konstruktorfunktion + `prototype`** | Klassische Methode zur Vererbung | Speicheroptimiert | Braucht `new` |
| **ES6 `class` + `extends`** | Modernere Syntax f√ºr Vererbung | Lesbar, `super()`-Support | Nur syntaktischer Zucker |
| **Prototyp-Kette** | Automatische Suche in `[[Prototype]]` | Erm√∂glicht Vererbung | Kann un√ºbersichtlich werden |

üîó [MDN-Dokumentation zu Prototypen](https://developer.mozilla.org/de/docs/Learn/JavaScript/Objects/Prototypes)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

38. ### <a name="38"></a> Object.create()

### **`Object.create()` in JavaScript**  

Die Methode `Object.create(proto)` erstellt ein neues Objekt mit einem bestimmten **Prototypen**. Dadurch kann man einfach Objekte **vererben**, ohne Konstruktorfunktionen oder Klassen zu verwenden.

---

## **1. Einfaches Beispiel: Objekt mit Prototyp**
```javascript
const tier = {
  atmen() {
    console.log("Das Tier atmet.");
  }
};

const hund = Object.create(tier);
hund.bellen = function() {
  console.log("Wuff!");
};

hund.atmen(); // "Das Tier atmet." (geerbt von `tier`)
hund.bellen(); // "Wuff!"
console.log(Object.getPrototypeOf(hund) === tier); // true
```
‚úÖ **`hund` erbt die Methode `atmen()` von `tier`.**  
‚úÖ **Prototype Chain wird genutzt.**  

---

## **2. `Object.create(proto, properties)` mit Eigenschaften**
Man kann Eigenschaften direkt definieren.

```javascript
const person = {
  beschreibung() {
    return `${this.name} ist ${this.alter} Jahre alt.`;
  }
};

const max = Object.create(person, {
  name: { value: "Max", writable: true, enumerable: true },
  alter: { value: 30, writable: true, enumerable: true }
});

console.log(max.beschreibung()); // "Max ist 30 Jahre alt."
console.log(Object.keys(max)); // ["name", "alter"] (enumerable: true)
```
‚úÖ **Man kann `writable`, `enumerable`, `configurable` setzen.**  

---

## **3. `Object.create(null)` ‚Äì Objekt ohne Prototyp**
Erstellt ein **komplett leeres Objekt** (kein `Object.prototype`).

```javascript
const obj = Object.create(null);
obj.name = "Test";

console.log(obj.name); // "Test"
console.log(obj.toString); // ‚ùå `undefined` (kein `Object.prototype`)
```
‚úÖ **Gut f√ºr "reine" Key-Value-Maps (z. B. f√ºr Dictionary-Speicherung).**  
‚ùå **Keine Standardmethoden (`toString`, `hasOwnProperty`).**  

---

## **4. Vererbung mit `Object.create()`**
```javascript
const fahrzeug = {
  start() {
    console.log(`${this.marke} startet.`);
  }
};

const auto = Object.create(fahrzeug);
auto.marke = "Tesla";

auto.start(); // "Tesla startet."
```
‚úÖ **Einfachere Alternative zu `class` oder Konstruktorfunktionen.**  

---

### **Zusammenfassung**
| Methode | Beschreibung | Vorteile | Nachteile |
|---------|-------------|----------|-----------|
| `Object.create(proto)` | Erstellt Objekt mit Prototyp `proto` | Speicheroptimiert, flexibel | Kein direkter `instanceof`-Support |
| `Object.create(proto, props)` | Erstellt Objekt + Eigenschaftsdefinition | Kontrolle √ºber Eigenschaften | Komplexer |
| `Object.create(null)` | Objekt ohne Prototyp (`Object.prototype` fehlt) | Kein Overhead | Keine Standardmethoden |

üîó [MDN-Dokumentation zu `Object.create()`](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Object/create)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

39. ### <a name="39"></a> Unterschied zwischen klassischer und prototypischer Vererbung

### **Unterschied zwischen klassischer und prototypischer Vererbung in JavaScript**  

JavaScript nutzt **prototypische Vererbung**, w√§hrend viele andere Sprachen wie Java oder C++ **klassische Vererbung** (klassenbasiert) verwenden. Ab **ES6** gibt es jedoch die `class`-Syntax, die auf Prototypen basiert, aber klassisches Verhalten nachahmt.

---

## **1. Klassische Vererbung (Klassenbasiert ‚Äì ES6 `class`)**
In klassischer Vererbung erstellt man **eine Klasse**, die als Blaupause f√ºr Objekte dient. Subklassen k√∂nnen von einer Superklasse erben.

```javascript
class Tier {
  constructor(name) {
    this.name = name;
  }

  laufen() {
    console.log(`${this.name} l√§uft.`);
  }
}

class Hund extends Tier {
  bellen() {
    console.log(`${this.name} bellt: Wuff!`);
  }
}

const rex = new Hund("Rex");
rex.laufen(); // "Rex l√§uft."
rex.bellen(); // "Rex bellt: Wuff!"
```
‚úÖ **Vorteile:**  
- Klare Struktur, leicht verst√§ndlich  
- `super()` erm√∂glicht Zugriff auf die Superklasse  
- Bessere Lesbarkeit f√ºr Entwickler mit OOP-Erfahrung  

‚ùå **Nachteile:**  
- Statischer als Prototypen  
- Weniger flexibel f√ºr dynamische Objekte  

---

## **2. Prototypische Vererbung (`Object.create()` oder `prototype`)**
Hier gibt es **keine Klassen**. Objekte erben direkt von anderen Objekten √ºber die **Prototype Chain**.

```javascript
const tier = {
  laufen() {
    console.log("Das Tier l√§uft.");
  }
};

const hund = Object.create(tier);
hund.bellen = function() {
  console.log("Wuff!");
};

hund.laufen(); // "Das Tier l√§uft." (geerbt von `tier`)
hund.bellen(); // "Wuff!"
```
‚úÖ **Vorteile:**  
- Mehr **Flexibilit√§t** (dynamische Objekte, keine feste Klassendefinition)  
- **Direkte Vererbung von Objekten**  
- Speicherfreundlich (Methoden im Prototyp gespeichert)  

‚ùå **Nachteile:**  
- Weniger intuitiv f√ºr Entwickler mit OOP-Hintergrund  
- Keine direkte `instanceof`-√úberpr√ºfung  

---

## **3. Vergleich: Klassisch vs. Prototypisch**

| Merkmal | Klassische Vererbung (`class`) | Prototypische Vererbung (`Object.create()` / `prototype`) |
|---------|---------------------------------|---------------------------------|
| **Basis** | Klassen mit Konstruktoren | Objekte erben direkt von anderen Objekten |
| **Syntax** | `class` und `extends` | `Object.create()` oder `prototype` |
| **Methodenspeicher** | Im `prototype` der Klasse | Direkt im Prototyp-Objekt |
| **Flexibilit√§t** | Statisch, festgelegte Struktur | Dynamisch, Objekte k√∂nnen ge√§ndert werden |
| **Performance** | Optimiert f√ºr OOP | Speicherfreundlich, da Prototypen gemeinsam genutzt werden |

---

### **Zusammenfassung**
- **`class` (ES6)** ‚Üí Klassische Syntax, aber basiert intern auf **Prototypen**.
- **`Object.create(proto)` oder `prototype`** ‚Üí Direktes Erben von Objekten, flexibler.
- **Prototypische Vererbung ist dynamischer**, klassisches OOP ist strukturierter.

üîó [MDN-Dokumentation zu Vererbung](https://developer.mozilla.org/de/docs/Learn/JavaScript/Objects/Inheritance)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

40. ### <a name="40"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

41. ### <a name="41"></a> Arrays und Pseudo-Arrays, Array-Destrukturierung

### **Arrays und Pseudo-Arrays, Array-Destrukturierung in JavaScript**  

---

## **1. Arrays in JavaScript**
Ein **Array** ist eine geordnete Liste von Werten, die mit Index (`0`-basiert) zug√§nglich sind.

```javascript
const zahlen = [10, 20, 30];
console.log(zahlen[0]); // 10
console.log(zahlen.length); // 3
```
‚úÖ **Arrays sind dynamisch und k√∂nnen verschiedene Datentypen speichern.**  

---

## **2. Pseudo-Arrays (Array-√§hnliche Objekte)**
Pseudo-Arrays haben **L√§ngen- und Indexeigenschaften**, aber **nicht alle Array-Methoden**.

### **2.1 `arguments`-Objekt (funktionales Pseudo-Array)**
```javascript
function summe() {
  console.log(arguments); // Pseudo-Array
  return Array.from(arguments).reduce((acc, val) => acc + val, 0);
}

console.log(summe(1, 2, 3)); // 6
```
‚úÖ `Array.from(arguments)` konvertiert ein Pseudo-Array in ein echtes Array.  

---

### **2.2 `NodeList` und `HTMLCollection` (DOM-Pseudo-Arrays)**
```javascript
const alleDivs = document.querySelectorAll("div");
console.log(alleDivs instanceof NodeList); // true

const echteArray = Array.from(alleDivs);
console.log(echteArray.map(div => div.innerText)); // Array-Methoden nutzbar
```
‚úÖ **`NodeList` ist kein echtes Array ‚Üí `Array.from()` oder Spread-Operator nutzen.**  

---

## **3. Array-Destrukturierung (ES6)**  
Mit **Destrukturierung** k√∂nnen Werte direkt aus einem Array extrahiert werden.

### **3.1 Grundlegende Destrukturierung**
```javascript
const zahlen = [10, 20, 30];
const [erstes, zweites] = zahlen;

console.log(erstes); // 10
console.log(zweites); // 20
```
‚úÖ **Verk√ºrzt den Code bei Wertzuweisungen.**  

---

### **3.2 √úberspringen von Werten**
```javascript
const zahlen = [10, 20, 30, 40];
const [, , drittes] = zahlen;

console.log(drittes); // 30
```
‚úÖ **L√§sst bestimmte Elemente aus.**  

---

### **3.3 Destrukturierung mit Rest-Operator (`...`)**
```javascript
const [erstes, ...rest] = [1, 2, 3, 4, 5];

console.log(erstes); // 1
console.log(rest); // [2, 3, 4, 5]
```
‚úÖ **Ideal f√ºr Variablen mit dynamischer L√§nge.**  

---

### **3.4 Werte tauschen mit Destrukturierung**
```javascript
let a = 5, b = 10;
[a, b] = [b, a];

console.log(a, b); // 10, 5
```
‚úÖ **Kein tempor√§rer Zwischenspeicher n√∂tig.**  

---

### **3.5 Destrukturierung in Funktionsparametern**
```javascript
function zeigePerson([name, alter]) {
  console.log(`${name} ist ${alter} Jahre alt.`);
}

const daten = ["Lisa", 30];
zeigePerson(daten); // Lisa ist 30 Jahre alt.
```
‚úÖ **Perfekt f√ºr Funktionen mit Array-Parametern.**  

---

### **Zusammenfassung**
| Thema | Beschreibung |
|-------|-------------|
| **Array** | Geordnete Liste von Werten (`[1, 2, 3]`) |
| **Pseudo-Arrays** | `arguments`, `NodeList` ‚Äì Kein echtes Array |
| **Destrukturierung** | Extrahiert Werte aus Arrays |
| **Rest-Operator (`...`)** | Speichert den Rest der Werte |
| **Tauschen mit Destrukturierung** | `[a, b] = [b, a]` |

üîó [MDN-Dokumentation zur Array-Destrukturierung](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Operators/Destrukturierende_Zuweisung#arrays)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

42. ### <a name="42"></a> Methoden Array, Array.prototype

### **Methoden f√ºr Arrays und `Array.prototype` in JavaScript**  

JavaScript-Arrays besitzen viele Methoden, die das Arbeiten mit Daten erleichtern. Sie sind in zwei Kategorien unterteilt:

1. **Statische Methoden** (`Array.method()`)
2. **Instanzmethoden** (`Array.prototype.method()` ‚Äì f√ºr einzelne Arrays)

---

## **1. Statische Methoden (`Array.method()`)**
Diese Methoden werden direkt auf `Array` angewendet.

### **1.1 `Array.from(iterable)` ‚Äì Pseudo-Array zu echtem Array konvertieren**
```javascript
const pseudoArray = document.querySelectorAll("div"); // NodeList (kein echtes Array)
const echtesArray = Array.from(pseudoArray);

console.log(echtesArray instanceof Array); // true
```
‚úÖ **Konvertiert `NodeList`, `arguments`, `Set` in Arrays**  

---

### **1.2 `Array.isArray(value)` ‚Äì Pr√ºft, ob ein Wert ein echtes Array ist**
```javascript
console.log(Array.isArray([1, 2, 3])); // true
console.log(Array.isArray({ 0: "a", length: 1 })); // false
```
‚úÖ **Sicherer als `instanceof Array`, weil auch f√ºr `iframes` funktioniert.**  

---

### **1.3 `Array.of(...values)` ‚Äì Erstellt ein Array aus Argumenten**
```javascript
console.log(Array.of(1, 2, 3)); // [1, 2, 3]
console.log(Array(3)); // [empty √ó 3] (Sonderverhalten!)
```
‚úÖ **Verhindert `Array(3)`-Problem (leeres Array mit L√§nge 3).**  

---

## **2. Instanzmethoden (`Array.prototype.method()`)**
Diese Methoden werden auf einzelne Arrays angewendet.

---

### **2.1 Mutierende Methoden (ver√§ndern das Array)**
#### **`push()` ‚Äì Element(e) ans Ende hinzuf√ºgen**
```javascript
const zahlen = [1, 2];
zahlen.push(3, 4);
console.log(zahlen); // [1, 2, 3, 4]
```

#### **`pop()` ‚Äì Letztes Element entfernen**
```javascript
const namen = ["Max", "Anna"];
namen.pop();
console.log(namen); // ["Max"]
```

#### **`shift()` ‚Äì Erstes Element entfernen**
```javascript
const queue = ["Erster", "Zweiter"];
queue.shift();
console.log(queue); // ["Zweiter"]
```

#### **`unshift()` ‚Äì Element(e) am Anfang hinzuf√ºgen**
```javascript
const liste = ["B"];
liste.unshift("A");
console.log(liste); // ["A", "B"]
```

#### **`splice(start, deleteCount, ...items)` ‚Äì Elemente entfernen/hinzuf√ºgen**
```javascript
const farben = ["Rot", "Gr√ºn", "Blau"];
farben.splice(1, 1, "Gelb"); // 1 Element ab Index 1 ersetzen
console.log(farben); // ["Rot", "Gelb", "Blau"]
```
‚úÖ **Vielseitig: Entfernen, Einf√ºgen und Ersetzen von Elementen.**  

---

### **2.2 Nicht-mutierende Methoden (erstellt neue Arrays)**
#### **`slice(start, end)` ‚Äì Teilausschnitt eines Arrays**
```javascript
const zahlen = [1, 2, 3, 4];
console.log(zahlen.slice(1, 3)); // [2, 3] (Index 1 bis 2)
```

#### **`concat(arr)` ‚Äì Arrays verbinden**
```javascript
const a = [1, 2], b = [3, 4];
console.log(a.concat(b)); // [1, 2, 3, 4]
```

#### **`join(separator)` ‚Äì Array zu String**
```javascript
const worte = ["Hallo", "Welt"];
console.log(worte.join(" ")); // "Hallo Welt"
```

---

### **2.3 Iterationsmethoden**
#### **`forEach(callback)` ‚Äì Jedes Element durchlaufen**
```javascript
const zahlen = [1, 2, 3];
zahlen.forEach((zahl) => console.log(zahl * 2));
// 2
// 4
// 6
```
‚úÖ **Ersetzt `for`-Schleife f√ºr Arrays.**  

---

### **2.4 Methoden f√ºr neue Arrays**
#### **`map(callback)` ‚Äì Jedes Element transformieren**
```javascript
const zahlen = [1, 2, 3];
const verdoppelt = zahlen.map((zahl) => zahl * 2);
console.log(verdoppelt); // [2, 4, 6]
```
‚úÖ **√Ñndert Werte ohne Original-Array zu modifizieren.**  

---

#### **`filter(callback)` ‚Äì Elemente basierend auf Bedingung filtern**
```javascript
const zahlen = [10, 20, 30, 40];
const gefiltert = zahlen.filter((zahl) => zahl > 20);
console.log(gefiltert); // [30, 40]
```
‚úÖ **Perfekt f√ºr Datenverarbeitung.**  

---

#### **`reduce(callback, startwert)` ‚Äì Werte reduzieren (z. B. Summe)**
```javascript
const zahlen = [1, 2, 3, 4];
const summe = zahlen.reduce((acc, zahl) => acc + zahl, 0);
console.log(summe); // 10
```
‚úÖ **Wird oft f√ºr Summen, Durchschnittswerte und Objektverarbeitung genutzt.**  

---

### **2.5 Suchen und Pr√ºfen**
#### **`find(callback)` ‚Äì Erstes passendes Element**
```javascript
const leute = [{ name: "Max", alter: 30 }, { name: "Anna", alter: 25 }];
const ergebnis = leute.find(person => person.alter > 28);
console.log(ergebnis); // { name: "Max", alter: 30 }
```

#### **`findIndex(callback)` ‚Äì Index des ersten passenden Elements**
```javascript
const zahlen = [10, 20, 30];
console.log(zahlen.findIndex(n => n === 20)); // 1
```

#### **`some(callback)` ‚Äì Pr√ºft, ob mind. ein Element passt**
```javascript
const zahlen = [3, 7, 11];
console.log(zahlen.some(n => n > 5)); // true
```

#### **`every(callback)` ‚Äì Pr√ºft, ob ALLE Elemente passen**
```javascript
console.log(zahlen.every(n => n > 2)); // true
console.log(zahlen.every(n => n > 5)); // false
```

---

### **2.6 Sortieren**
#### **`sort([compareFunction])` ‚Äì Sortiert das Array**
```javascript
const zahlen = [10, 2, 30, 4];
zahlen.sort((a, b) => a - b);
console.log(zahlen); // [2, 4, 10, 30]
```
‚ùå **Standard `sort()` sortiert alphabetisch ‚Äì Immer `compareFunction` nutzen!**  

---

### **Zusammenfassung**
| Methode | Typ | Funktion |
|---------|-----|----------|
| `push()`, `pop()`, `shift()`, `unshift()` | Mutierend | Elemente hinzuf√ºgen/entfernen |
| `slice()`, `concat()`, `join()` | Nicht-mutierend | Neues Array/Strings erstellen |
| `map()`, `filter()`, `reduce()` | Iterativ | Transformation & Aggregation |
| `find()`, `some()`, `every()` | Suchmethoden | Elemente finden & pr√ºfen |
| `sort()`, `reverse()` | Sortieren | Reihenfolge √§ndern |

üîó [MDN-Dokumentation zu Arrays](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Array)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

43. ### <a name="43"></a> Kopieren von Arrays

### **Kopieren von Arrays in JavaScript**  

Beim Kopieren von Arrays gibt es zwei Methoden:  

1. **Shallow Copy (flache Kopie)** ‚Äì Erstellt eine Kopie der obersten Ebene, verschachtelte Objekte/Arrays bleiben referenziert.  
2. **Deep Copy (tiefe Kopie)** ‚Äì Erstellt eine komplette Kopie inklusive aller verschachtelten Werte.

---

## **1. Flache Kopie (Shallow Copy)**
Eine **flache Kopie** dupliziert nur die oberste Ebene des Arrays. **Verschachtelte Objekte bleiben referenziert**.

### **1.1 Spread-Operator (`[...]`)**
```javascript
const original = [1, 2, [3, 4]];
const kopie = [...original];

kopie[0] = 99;
kopie[2][0] = 999; // ‚ö†Ô∏è √Ñnderung in verschachteltem Array!

console.log(original); // [1, 2, [999, 4]] (√Ñnderung √ºbernommen!)
console.log(kopie); // [99, 2, [999, 4]]
```
‚úÖ **K√ºrzeste Methode**  
‚ùå **Tief verschachtelte Werte bleiben referenziert!**  

---

### **1.2 `Array.slice()` ‚Äì Erstellt eine neue Kopie**
```javascript
const original = [1, 2, 3];
const kopie = original.slice();

kopie[0] = 99;

console.log(original); // [1, 2, 3] (unver√§ndert)
console.log(kopie); // [99, 2, 3]
```
‚úÖ **Gut f√ºr flache Arrays**  
‚ùå **Verschachtelte Werte bleiben referenziert**  

---

### **1.3 `Array.from()` ‚Äì Erstellt eine Kopie**
```javascript
const original = [1, 2, { a: 3 }];
const kopie = Array.from(original);

kopie[2].a = 99; // ‚ö†Ô∏è Referenzierte Objekte werden nicht kopiert!

console.log(original); // [1, 2, { a: 99 }]
console.log(kopie); // [1, 2, { a: 99 }]
```
‚úÖ **N√ºtzlich f√ºr `arguments` oder `NodeList`**  
‚ùå **Verschachtelte Objekte bleiben referenziert**  

---

## **2. Tiefe Kopie (Deep Copy)**
Eine **tiefe Kopie** dupliziert **das gesamte Array und alle verschachtelten Werte**, sodass keine Referenz bestehen bleibt.

### **2.1 `JSON.parse(JSON.stringify(array))` (Einfache L√∂sung)**
```javascript
const original = [1, 2, { a: 3 }];
const kopie = JSON.parse(JSON.stringify(original));

kopie[2].a = 99;

console.log(original); // [1, 2, { a: 3 }] (unver√§ndert)
console.log(kopie); // [1, 2, { a: 99 }]
```
‚úÖ **Einfache Methode f√ºr tiefe Kopien**  
‚ùå **Verliert Methoden, `undefined`, `Symbol`, `Date`**  

---

### **2.2 `structuredClone(array)` (Moderne L√∂sung)**
```javascript
const original = [1, 2, { a: 3 }, new Date()];
const kopie = structuredClone(original);

kopie[2].a = 99;

console.log(original); // [1, 2, { a: 3 }, Date]
console.log(kopie); // [1, 2, { a: 99 }, Date]
```
‚úÖ **Erh√§lt `Date`, `Map`, `Set`**  
‚ùå **Nicht in √§lteren Browsern unterst√ºtzt**  

---

### **2.3 Rekursive Deep Copy-Funktion**
Falls `structuredClone()` nicht verf√ºgbar ist, kann man eine **eigene Funktion** schreiben.

```javascript
function deepCopy(arr) {
  return arr.map(item => 
    Array.isArray(item) ? deepCopy(item) : 
    typeof item === "object" && item !== null ? {...item} : item
  );
}

const original = [1, 2, { a: 3 }, [4, 5]];
const kopie = deepCopy(original);

kopie[2].a = 99;
kopie[3][0] = 999;

console.log(original); // [1, 2, { a: 3 }, [4, 5]]
console.log(kopie); // [1, 2, { a: 99 }, [999, 5]]
```
‚úÖ **Flexible und funktionale L√∂sung**  
‚ùå **Verliert Methoden und komplexe Objekte (`Date`, `Map`, `Set`)**  

---

### **Zusammenfassung**
| Methode | Typ | Vorteile | Nachteile |
|---------|-----|----------|-----------|
| **`slice()` / `[...arr]`** | Flach | Schnell, einfach | Tiefe Werte bleiben referenziert |
| **`JSON.parse(JSON.stringify(arr))`** | Tief | Einfach, gut f√ºr Objekte | Verliert `undefined`, Methoden, `Date` |
| **`structuredClone(arr)`** | Tief | Beste moderne L√∂sung | Nicht in √§lteren Browsern |
| **Rekursive Funktion (`deepCopy()`)** | Tief | Anpassbar | Kein `Date`, `Map`, `Set` |

üîó [MDN-Dokumentation zu `structuredClone()`](https://developer.mozilla.org/de/docs/Web/API/structuredClone)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

44. ### <a name="44"></a> Map, Set, WeakSet, WeakMap

### **`Map`, `Set`, `WeakMap`, `WeakSet` in JavaScript**  

JavaScript bietet **`Map`** und **`Set`** als moderne Alternativen zu **Objekten (`{}`) und Arrays (`[]`)**, sowie **`WeakMap`** und **`WeakSet`** f√ºr schwache Referenzen.

---

## **1. `Map` ‚Äì Schl√ºssel-Wert-Speicher mit beliebigen Schl√ºsseltypen**  

Ein **`Map`** ist eine geordnete Sammlung von **Schl√ºssel-Wert-Paaren**, bei der **beliebige Werte** als Schl√ºssel verwendet werden k√∂nnen (z. B. Objekte oder Funktionen).  

### **1.1 Erstellen & Bef√ºllen einer Map**
```javascript
const benutzerMap = new Map();
benutzerMap.set("name", "Max");
benutzerMap.set(42, "Alter");
benutzerMap.set({ id: 1 }, "Objekt als Schl√ºssel");

console.log(benutzerMap.get("name")); // Max
console.log(benutzerMap.get(42)); // Alter
```
‚úÖ **Beliebige Schl√ºssel m√∂glich (Objekte, Zahlen, Strings, Funktionen)**  
‚úÖ **Erh√§lt Reihenfolge der Eintr√§ge**  

---

### **1.2 Methoden von `Map`**
```javascript
console.log(benutzerMap.has(42)); // true
benutzerMap.delete(42);
console.log(benutzerMap.size); // 2
benutzerMap.clear(); // L√∂scht alle Eintr√§ge
```

---

### **1.3 `forEach()`, `keys()`, `values()`, `entries()`**
```javascript
const map = new Map([
  ["name", "Anna"],
  ["stadt", "Berlin"]
]);

// Iteration
map.forEach((wert, schl√ºssel) => console.log(`${schl√ºssel}: ${wert}`));

console.log([...map.keys()]); // ["name", "stadt"]
console.log([...map.values()]); // ["Anna", "Berlin"]
console.log([...map.entries()]); // [["name", "Anna"], ["stadt", "Berlin"]]
```

---

## **2. `Set` ‚Äì Sammlung eindeutiger Werte**  

Ein **`Set`** speichert **einzigartige Werte** (keine Duplikate).

### **2.1 Erstellen & Bef√ºllen eines Sets**
```javascript
const zahlenSet = new Set([1, 2, 3, 3, 4]);

console.log(zahlenSet.size); // 4 (kein doppeltes 3)
```

---

### **2.2 Methoden von `Set`**
```javascript
zahlenSet.add(5);
console.log(zahlenSet.has(3)); // true
zahlenSet.delete(2);
zahlenSet.clear(); // L√∂scht alle Eintr√§ge
```

---

### **2.3 `forEach()`, `keys()`, `values()`, `entries()`**
```javascript
const set = new Set(["Apfel", "Banane", "Kirsche"]);
set.forEach((wert) => console.log(wert));

console.log([...set.keys()]); // ["Apfel", "Banane", "Kirsche"]
console.log([...set.values()]); // ["Apfel", "Banane", "Kirsche"]
console.log([...set.entries()]); // [["Apfel", "Apfel"], ["Banane", "Banane"], ["Kirsche", "Kirsche"]]
```
‚úÖ **Perfekt f√ºr Listen ohne doppelte Werte**  

---

## **3. `WeakMap` ‚Äì Schl√ºssel-Objekte mit automatischem Speicherfreigeben**  

Ein **`WeakMap`** speichert nur **Objekte als Schl√ºssel** und erlaubt **automatische Speicherbereinigung (Garbage Collection)**, wenn das Objekt nicht mehr verwendet wird.

### **3.1 Erstellen & Verwenden einer `WeakMap`**
```javascript
const weakMap = new WeakMap();
let obj = { id: 1 };

weakMap.set(obj, "Daten f√ºr das Objekt");
console.log(weakMap.get(obj)); // "Daten f√ºr das Objekt"

obj = null; // Das Objekt wird entfernt -> automatisch aus WeakMap gel√∂scht
```
‚úÖ **Speichert nur Objekte als Schl√ºssel**  
‚úÖ **Automatische Speicherfreigabe bei `null`**  
‚ùå **Hat keine `size`, `keys()`, `values()` oder Iterationsmethoden**  

---

## **4. `WeakSet` ‚Äì Sammlung von Objekten mit automatischer Speicherfreigabe**  

Ein **`WeakSet`** speichert **nur Objekte** und entfernt sie automatisch, wenn sie nicht mehr referenziert werden.

### **4.1 Erstellen & Verwenden eines `WeakSet`**
```javascript
const weakSet = new WeakSet();
let obj1 = { name: "Max" };

weakSet.add(obj1);
console.log(weakSet.has(obj1)); // true

obj1 = null; // Objekt wird entfernt -> automatisch aus WeakSet gel√∂scht
```
‚úÖ **Perfekt f√ºr "Markierungen" an Objekten**  
‚ùå **Keine Iterationsmethoden (`forEach()`, `keys()`, etc.)**  

---

### **Zusammenfassung**
| Struktur | Schl√ºsseltyp | Werte d√ºrfen sein | Iterierbar? | Speicherbereinigung |
|----------|-------------|-------------------|-------------|---------------------|
| **Map** | Beliebig | Beliebig | ‚úÖ Ja | ‚ùå Nein |
| **Set** | Keine Schl√ºssel | Einzigartige Werte | ‚úÖ Ja | ‚ùå Nein |
| **WeakMap** | Nur Objekte | Beliebig | ‚ùå Nein | ‚úÖ Ja |
| **WeakSet** | Keine Schl√ºssel | Nur Objekte | ‚ùå Nein | ‚úÖ Ja |

üîó [MDN-Dokumentation zu `Map`](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Map)  
üîó [MDN-Dokumentation zu `Set`](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Set)  

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

45. ### <a name="45"></a> Live Collections (lebendige Sammlungen)

### **Live Collections (lebendige Sammlungen) in JavaScript**  

**Live Collections** sind **Datenstrukturen im DOM**, die sich **automatisch aktualisieren**, wenn sich das Dokument √§ndert.  

---

## **1. Arten von Live Collections**
- **`HTMLCollection`** ‚Üí Ergebnis von `getElementsByTagName()`, `getElementsByClassName()`
- **`NodeList` (manchmal live)** ‚Üí Ergebnis von `querySelectorAll()` (statisch) oder `childNodes` (live)

---

## **2. `HTMLCollection` ‚Äì Automatisch aktualisierbare Liste von Elementen**
Ein **`HTMLCollection`** wird live aktualisiert, wenn sich das DOM ver√§ndert.

```javascript
const divs = document.getElementsByTagName("div");
console.log(divs.length); // Anzahl der <div>-Elemente

const neuesDiv = document.createElement("div");
document.body.appendChild(neuesDiv); // Ein neues <div> wird hinzugef√ºgt

console.log(divs.length); // Live-Collection zeigt automatisch die neue Anzahl!
```
‚úÖ **Live (automatische Updates)**  
‚ùå **Hat keine Array-Methoden (`map()`, `filter()`, etc.)**  

---

## **3. `NodeList` ‚Äì Live vs. Statische Liste**
Nicht alle `NodeList`-Sammlungen sind live!  

### **3.1 Live `NodeList` (z. B. `childNodes`)**
```javascript
const nodes = document.body.childNodes;
console.log(nodes.length);

const neuerText = document.createTextNode("Hallo!");
document.body.appendChild(neuerText);

console.log(nodes.length); // Wird automatisch aktualisiert!
```
‚úÖ **Live-Updates bei √Ñnderungen**  
‚ùå **Enth√§lt auch `TextNodes` und `Comments`**  

---

### **3.2 Statische `NodeList` (`querySelectorAll()`)**
```javascript
const liste = document.querySelectorAll("li");
console.log(liste.length); // Anzahl der <li>-Elemente

const neuesLi = document.createElement("li");
document.querySelector("ul").appendChild(neuesLi);

console.log(liste.length); // ‚ùå Bleibt unver√§ndert (statisch)!
```
‚úÖ **Hat `forEach()` & andere Array-Methoden**  
‚ùå **Bleibt unver√§ndert, wenn DOM ge√§ndert wird**  

---

## **4. Live Collection in einer Schleife (Problem!)**
Ein **gro√ües Problem** mit Live Collections: √Ñnderungen w√§hrend einer Schleife f√ºhren zu unerwartetem Verhalten.

```javascript
const elemente = document.getElementsByTagName("p");

for (let i = 0; i < elemente.length; i++) {
  document.body.removeChild(elemente[i]); // ‚ö†Ô∏è Fehler: `elemente.length` √§ndert sich!
}
```
‚úÖ **L√∂sung:** R√ºckw√§rts iterieren oder `Array.from()` verwenden.

```javascript
const elemente = Array.from(document.getElementsByTagName("p"));

elemente.forEach(p => document.body.removeChild(p)); // Funktioniert sicher
```

---

### **Zusammenfassung**
| Sammlung | Live? | Methoden verf√ºgbar? | Typ |
|----------|------|----------------|------|
| **`HTMLCollection`** | ‚úÖ Ja | ‚ùå Keine Array-Methoden | Elemente |
| **`NodeList` (z. B. `childNodes`)** | ‚úÖ Ja | ‚ùå Nur `forEach()` | Knoten (Elemente, Text) |
| **`NodeList` (`querySelectorAll()`)** | ‚ùå Nein | ‚úÖ Array-Methoden | Elemente |

üîó [MDN-Dokumentation zu Live Collections](https://developer.mozilla.org/de/docs/Web/API/HTMLCollection)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

46. ### <a name="46"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

47. ### <a name="47"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

48. ### <a name="48"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

49. ### <a name="49"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

50. ### <a name="50"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

51. ### <a name="51"></a> Spread-Operator (ES6-ES9)

### **Spread-Operator (`...`) in JavaScript (ES6-ES9)**  

Der **Spread-Operator (`...`)** wird in JavaScript verwendet, um **Arrays, Objekte und Funktionsargumente zu "entpacken"**. Er wurde mit **ES6** eingef√ºhrt und in sp√§teren Versionen erweitert.

---

## **1. Spread-Operator mit Arrays**  

### **1.1 Array-Kopieren (`Shallow Copy`)**
```javascript
const zahlen = [1, 2, 3];
const kopie = [...zahlen];

kopie.push(4);
console.log(zahlen); // [1, 2, 3] (unver√§ndert)
console.log(kopie); // [1, 2, 3, 4]
```
‚úÖ **Erstellt eine flache Kopie des Arrays**  
‚ùå **Verschachtelte Arrays werden referenziert!**  

---

### **1.2 Arrays zusammenf√ºgen (Alternative zu `concat()`)**
```javascript
const a = [1, 2], b = [3, 4];
const zusammen = [...a, ...b];

console.log(zusammen); // [1, 2, 3, 4]
```

---

### **1.3 Elemente hinzuf√ºgen**
```javascript
const zahlen = [1, 2, 3];
const erweitert = [0, ...zahlen, 4];

console.log(erweitert); // [0, 1, 2, 3, 4]
```

---

## **2. Spread-Operator mit Objekten (`ES9`)**
Ab **ES9 (ES2018)** kann der Spread-Operator auch f√ºr **Objekte** verwendet werden.

### **2.1 Objekt-Kopieren**
```javascript
const person = { name: "Max", alter: 30 };
const kopie = { ...person };

kopie.alter = 31;
console.log(person.alter); // 30 (unver√§ndert)
console.log(kopie.alter); // 31
```
‚úÖ **Flache Kopie des Objekts**  

---

### **2.2 Objekte zusammenf√ºhren**
```javascript
const user = { name: "Anna", alter: 25 };
const zusatz = { beruf: "Designer" };

const merged = { ...user, ...zusatz };
console.log(merged); // { name: "Anna", alter: 25, beruf: "Designer" }
```
‚úÖ **Alternative zu `Object.assign()`**  

---

### **2.3 Standardwerte √ºberschreiben**
```javascript
const defaultSettings = { theme: "light", showSidebar: true };
const userSettings = { theme: "dark" };

const settings = { ...defaultSettings, ...userSettings };
console.log(settings); // { theme: "dark", showSidebar: true }
```
‚úÖ **Sp√§ter hinzugef√ºgte Werte √ºberschreiben fr√ºhere Werte**  

---

## **3. Spread-Operator in Funktionsaufrufen**
### **3.1 Argumente an Funktionen √ºbergeben**
```javascript
function summe(a, b, c) {
  return a + b + c;
}

const zahlen = [1, 2, 3];
console.log(summe(...zahlen)); // 6
```
‚úÖ **Alternative zu `apply()`**  
```javascript
console.log(Math.max(...[10, 20, 30])); // 30
```

---

## **4. Unterschied zwischen Spread (`...`) und Rest-Parameter (`...`)**
**Spread (`...`)** ‚Üí **Entpackt** Werte aus Arrays oder Objekten.  
**Rest (`...`)** ‚Üí **Sammelt** Werte in Arrays.

```javascript
function beispiel(a, ...rest) {
  console.log(a); // Erstes Argument
  console.log(rest); // Restliche Argumente als Array
}

beispiel(1, 2, 3, 4);
// 1
// [2, 3, 4]
```

---

### **Zusammenfassung**
| Feature | Spread (`...`) f√ºr Arrays | Spread (`...`) f√ºr Objekte |
|---------|------------------|------------------|
| **Kopieren** | `const arr2 = [...arr1]` | `const obj2 = { ...obj1 }` |
| **Zusammenf√ºgen** | `[...arr1, ...arr2]` | `{ ...obj1, ...obj2 }` |
| **Elemente einf√ºgen** | `[1, ...arr, 4]` | `{ key: "new", ...obj }` |
| **Funktion Argumente** | `sum(...arr)` | ‚ùå Nicht m√∂glich |

üîó [MDN-Dokumentation zum Spread-Operator](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Operators/Spread_syntax)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

52. ### <a name="52"></a> Rest-Operator und Standardparameter (ES6)

### **Rest-Operator (`...`) und Standardparameter (ES6) in JavaScript**  

Der **Rest-Operator (`...`)** sammelt mehrere Werte in **einem Array**.  
Standardparameter (`=`) setzen **Standardwerte f√ºr Funktionsargumente**.

---

## **1. Rest-Operator (`...`) ‚Äì Sammelt Werte in Arrays**  

### **1.1 Funktionsargumente sammeln**
```javascript
function summe(...zahlen) {
  return zahlen.reduce((acc, val) => acc + val, 0);
}

console.log(summe(1, 2, 3, 4)); // 10
```
‚úÖ **Unbegrenzte Argumente als Array empfangen**  
‚ùå **Muss am **Ende** der Parameterliste stehen!**  

---

### **1.2 Rest-Parameter mit festen Parametern**
```javascript
function ersteUndRest(erstes, ...rest) {
  console.log(erstes); // Erstes Argument
  console.log(rest); // Rest als Array
}

ersteUndRest("A", "B", "C", "D");
// "A"
// ["B", "C", "D"]
```

---

### **1.3 Rest-Operator in Array-Destrukturierung**
```javascript
const zahlen = [1, 2, 3, 4, 5];
const [erstes, zweites, ...rest] = zahlen;

console.log(erstes, zweites); // 1, 2
console.log(rest); // [3, 4, 5]
```
‚úÖ **Perfekt f√ºr Teillisten**  

---

### **1.4 Rest-Operator in Objekt-Destrukturierung**
```javascript
const person = { name: "Max", alter: 30, beruf: "Entwickler" };
const { name, ...rest } = person;

console.log(name); // "Max"
console.log(rest); // { alter: 30, beruf: "Entwickler" }
```
‚úÖ **N√ºtzlich f√ºr das Entfernen einzelner Eigenschaften**  

---

## **2. Standardparameter ‚Äì Vorgabewerte f√ºr Funktionsargumente**
Falls ein Parameter **nicht √ºbergeben wird**, erh√§lt er einen **Standardwert**.

```javascript
function begruessung(name = "Gast") {
  console.log(`Hallo, ${name}!`);
}

begruessung("Anna"); // "Hallo, Anna!"
begruessung(); // "Hallo, Gast!"
```
‚úÖ **Verhindert `undefined`-Werte in Funktionen**  

---

### **2.1 Standardwerte mit Berechnung**
```javascript
function mult(a, b = a) {
  return a * b;
}

console.log(mult(3)); // 9 (b = 3)
console.log(mult(3, 4)); // 12
```
‚úÖ **Ein Parameter kann als Standardwert f√ºr einen anderen genutzt werden**  

---

### **2.2 Kombination von Rest-Operator und Standardwerten**
```javascript
function summeMitStart(start = 0, ...zahlen) {
  return zahlen.reduce((acc, val) => acc + val, start);
}

console.log(summeMitStart(10, 1, 2, 3)); // 16 (10 + 1 + 2 + 3)
console.log(summeMitStart()); // 0
```

---

### **Zusammenfassung**
| Feature | Beschreibung | Beispiel |
|---------|-------------|----------|
| **Rest-Operator (`...`)** | Sammelt mehrere Werte als Array | `function test(...args) {}` |
| **Array-Destrukturierung** | Teilt Array-Werte in Variablen | `[a, ...rest] = [1, 2, 3]` |
| **Objekt-Destrukturierung** | Entfernt Eigenschaft aus Objekt | `{ key, ...rest } = obj` |
| **Standardparameter** | Setzt Standardwerte f√ºr Argumente | `function(a = 5) {}` |

üîó [MDN-Dokumentation zu Rest-Operator & Standardparametern](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Functions/Default_parameters)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

53. ### <a name="53"></a> Symbol

### **`Symbol` in JavaScript (ES6)**  

Ein **`Symbol`** ist ein einzigartiger, unver√§nderlicher Wert, der als **Schl√ºssel f√ºr Objekte** verwendet werden kann.  
Es wurde in **ES6 (ECMAScript 2015)** eingef√ºhrt und hilft, **Namenskonflikte zu vermeiden**.

---

## **1. Symbol erstellen**
```javascript
const id = Symbol();
console.log(typeof id); // "symbol"
```
‚úÖ **Jedes `Symbol()` ist einzigartig!**  

---

## **2. Symbol mit Beschreibung**
```javascript
const userID = Symbol("Benutzer-ID");
console.log(userID.toString()); // "Symbol(Benutzer-ID)"
```
‚úÖ **Die Beschreibung dient nur zu Debugging-Zwecken.**  

---

## **3. Symbol als Objekt-Schl√ºssel**
```javascript
const user = {
  name: "Max",
  [userID]: 12345 // Symbol als Schl√ºssel
};

console.log(user[userID]); // 12345
console.log(Object.keys(user)); // ["name"] (Symbol wird nicht angezeigt!)
console.log(Object.getOwnPropertySymbols(user)); // [Symbol(Benutzer-ID)]
```
‚úÖ **Verhindert unbeabsichtigten Zugriff auf Eigenschaften**  

‚ùå **Wird nicht in `Object.keys()` oder `for...in` angezeigt!**  

---

## **4. Globale Symbol-Registrierung mit `Symbol.for()`**
```javascript
const sym1 = Symbol.for("globalID");
const sym2 = Symbol.for("globalID");

console.log(sym1 === sym2); // true
```
‚úÖ **`Symbol.for("name")` erstellt ein globales Symbol oder gibt ein existierendes zur√ºck.**  

```javascript
console.log(Symbol.keyFor(sym1)); // "globalID"
```
‚úÖ **`Symbol.keyFor(symbol)` gibt den Symbol-Namen zur√ºck.**  

‚ùå **Unterschied zu `Symbol()` ‚Üí `Symbol.for()` erzeugt **KEIN** einzigartiges Symbol!**  

---

## **5. Eingebaute (`Well-Known`) Symbole**
JavaScript hat **vordefinierte Symbole**, die das Verhalten von Objekten √§ndern k√∂nnen.

| Symbol | Zweck |
|--------|--------|
| `Symbol.iterator` | Definiert eine Iteration f√ºr `for...of` |
| `Symbol.toPrimitive` | Steuert die Typumwandlung eines Objekts |
| `Symbol.toStringTag` | √Ñndert den `toString()`-Ausgabe |

### **Beispiel: `Symbol.iterator` f√ºr benutzerdefinierte Iterationen**
```javascript
const meineZahlen = {
  werte: [1, 2, 3],
  [Symbol.iterator]() {
    let index = 0;
    return {
      next: () => ({
        value: this.werte[index++],
        done: index > this.werte.length
      })
    };
  }
};

for (const zahl of meineZahlen) {
  console.log(zahl); // 1, 2, 3
}
```
‚úÖ **Erm√∂glicht benutzerdefinierte `for...of`-Schleifen!**  

---

### **Zusammenfassung**
| Feature | Beschreibung |
|---------|-------------|
| **`Symbol()`** | Erzeugt ein einzigartiges Symbol |
| **`Symbol("beschreibung")`** | Symbol mit Debug-Beschreibung |
| **`Symbol.for("key")`** | Erstellt oder ruft ein globales Symbol ab |
| **`Object.getOwnPropertySymbols(obj)`** | Zeigt alle Symbole eines Objekts |
| **Well-Known Symbols** | `Symbol.iterator`, `Symbol.toPrimitive`, `Symbol.toStringTag` |

üîó [MDN-Dokumentation zu `Symbol`](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Symbol)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

54. ### <a name="54"></a> BigInt

### **BigInt in JavaScript (ES11 / ES2020)**  

**BigInt** ist ein spezieller Zahlentyp f√ºr sehr gro√üe Ganzzahlen, die √ºber den sicheren Bereich von `Number` (`2^53 - 1`) hinausgehen.

---

## **1. Warum BigInt?**  

Die gr√∂√üte sichere Zahl in JavaScript ist:  
```javascript
console.log(Number.MAX_SAFE_INTEGER); // 9007199254740991
```
Wird eine gr√∂√üere Zahl verwendet, kann es zu **Pr√§zisionsfehlern** kommen:  
```javascript
console.log(9007199254740991 + 1); // 9007199254740992 ‚úÖ
console.log(9007199254740991 + 2); // 9007199254740992 ‚ùå (Fehler!)
```
**L√∂sung:** Verwende `BigInt` f√ºr gro√üe Zahlen.  

---

## **2. BigInt erstellen**
```javascript
const gro√üeZahl = 123456789012345678901234567890n;
console.log(gro√üeZahl); // 123456789012345678901234567890n
console.log(typeof gro√üeZahl); // "bigint"
```
‚úÖ **BigInt wird mit `n` am Ende geschrieben**  

```javascript
const andereZahl = BigInt(12345678901234567890);
console.log(andereZahl); // 12345678901234567890n
```
‚úÖ **`BigInt()`-Konstruktor funktioniert ebenfalls**  

---

## **3. Rechnen mit BigInt**
```javascript
const a = 10n;
const b = 20n;

console.log(a + b); // 30n
console.log(a * b); // 200n
console.log(a / 3n); // 3n (Abrundung!)
```
‚úÖ **Alle arithmetischen Operationen sind m√∂glich**  
‚ùå **Division rundet immer ab (kein Gleitkomma!)**  

---

## **4. BigInt und normale Zahlen (`Number`)**
```javascript
const big = 100n;
const num = 50;

console.log(big + BigInt(num)); // ‚úÖ 150n
console.log(Number(big) + num); // ‚úÖ 150
```
‚ùå **Mischen von `BigInt` und `Number` ist nicht erlaubt!**  
```javascript
console.log(big + num); // ‚ùå TypeError
```
‚úÖ **L√∂sung: `BigInt()` oder `Number()` verwenden**  

---

## **5. Vergleiche mit BigInt**
Vergleiche (`==` oder `===`) funktionieren wie gewohnt:  
```javascript
console.log(10n == 10); // ‚úÖ true (automatische Konvertierung)
console.log(10n === 10); // ‚ùå false (unterschiedlicher Typ)
console.log(10n > 5); // ‚úÖ true
```
‚úÖ **`==` vergleicht den Wert, `===` vergleicht auch den Typ**  

---

## **6. BigInt in `Math`-Methoden**
BigInt **funktioniert nicht** mit `Math`-Funktionen:  
```javascript
console.log(Math.sqrt(16n)); // ‚ùå TypeError
```
‚úÖ **L√∂sung:** `Number(bigInt)` nutzen  
```javascript
console.log(Math.sqrt(Number(16n))); // ‚úÖ 4
```

---

### **Zusammenfassung**
| Feature | Beschreibung |
|---------|-------------|
| **`BigInt(n)` oder `n`-Suffix** | Erstellt eine gro√üe Ganzzahl |
| **Arithmetik (`+`, `-`, `*`, `/`)** | Funktioniert, aber Division rundet ab |
| **Vergleich (`==`, `===`, `<`, `>`)** | Funktioniert, aber `===` vergleicht auch den Typ |
| **BigInt & Number mischen** | ‚ùå Nicht erlaubt (`TypeError`) |
| **Keine `Math`-Funktionen** | ‚ùå `Math.sqrt(16n)` funktioniert nicht |

üîó [MDN-Dokumentation zu BigInt](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/BigInt)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

55. ### <a name="55"></a> Module import/export (ES6) & CommonJS

### **JavaScript-Module: `import/export` (ES6) & CommonJS**  

JavaScript unterst√ºtzt **zwei Modulsysteme**:  
1. **ES6-Module** (`import/export`) ‚Üí **F√ºr Browser & moderne JavaScript-Engines**  
2. **CommonJS** (`require/module.exports`) ‚Üí **F√ºr Node.js**  

---

## **1. ES6-Module (`import/export`) ‚Äì Modern**
### **1.1 Standard-Export (`export default`)**
```javascript
// üìÅ math.js (Modul)
export default function add(a, b) {
  return a + b;
}
```

```javascript
// üìÅ main.js
import add from "./math.js";

console.log(add(2, 3)); // 5
```
‚úÖ **`export default` ‚Üí Import ohne `{}` m√∂glich**  

---

### **1.2 Benannte Exporte (`export`)**
```javascript
// üìÅ utils.js
export function greet(name) {
  return `Hallo, ${name}!`;
}

export const PI = 3.1415;
```

```javascript
// üìÅ main.js
import { greet, PI } from "./utils.js";

console.log(greet("Max")); // "Hallo, Max!"
console.log(PI); // 3.1415
```
‚úÖ **Mehrere benannte Exporte m√∂glich**  

```javascript
// Alternativer Import (Alias vergeben)
import { greet as hello } from "./utils.js";
console.log(hello("Anna")); // "Hallo, Anna!"
```

---

### **1.3 Alles importieren (`* as`)**
```javascript
import * as utils from "./utils.js";

console.log(utils.greet("Lisa")); // "Hallo, Lisa!"
console.log(utils.PI); // 3.1415
```
‚úÖ **Praktisch f√ºr Modul-B√ºndelung**  

---

### **1.4 Dynamischer Import (`import()`)**
```javascript
async function ladeModul() {
  const math = await import("./math.js");
  console.log(math.default(2, 3)); // 5
}
ladeModul();
```
‚úÖ **Erm√∂glicht asynchrones Laden von Modulen**  

---

## **2. CommonJS (`require/module.exports`) ‚Äì F√ºr Node.js**
Vor ES6 wurde **CommonJS** in **Node.js** verwendet.

### **2.1 Export (`module.exports`)**
```javascript
// üìÅ math.js
module.exports = function add(a, b) {
  return a + b;
};
```

### **2.2 Import (`require()`)**
```javascript
// üìÅ main.js
const add = require("./math");

console.log(add(2, 3)); // 5
```
‚úÖ **Funktioniert in √§lteren Node.js-Versionen**  
‚ùå **Nicht f√ºr Browser geeignet!**  

---

## **3. Unterschiede: ES6 vs. CommonJS**
| Feature | ES6-Module (`import/export`) | CommonJS (`require/module.exports`) |
|---------|------------------|-------------------|
| **Verwendet in** | Browser, Node.js | Nur Node.js |
| **Synchron / Asynchron** | Asynchron (lazily loaded) | Synchron (blockiert) |
| **Syntax** | `import/export` | `require/module.exports` |
| **Standard-Export** | `export default` | `module.exports =` |
| **Dynamischer Import** | `import()` | `require()` |

---

### **Zusammenfassung**
1. **ES6-Module** (`import/export`) ‚Üí Standard f√ºr moderne JavaScript-Projekte.  
2. **CommonJS** (`require/module.exports`) ‚Üí Wird in **√§lteren Node.js-Projekten** verwendet.  
3. **Dynamischer `import()`** erm√∂glicht **lazy loading** f√ºr bessere Performance.  

üîó [MDN-Dokumentation zu `import/export`](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Statements/import)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

56. ### <a name="56"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

57. ### <a name="57"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

58. ### <a name="58"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

59. ### <a name="59"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

60. ### <a name="60"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

61. ### <a name="61"></a> Ereignisse und ihre Handler

### **Ereignisse und ihre Handler in JavaScript**  

JavaScript-Ereignisse (`events`) erm√∂glichen **Interaktionen mit der Webseite**.  
Ein **Ereignis-Handler** (`event handler`) ist eine Funktion, die auf ein Ereignis reagiert.

---

## **1. Ereignisse mit `addEventListener()` (Empfohlene Methode)**  
```javascript
document.getElementById("btn").addEventListener("click", function() {
  console.log("Button wurde geklickt!");
});
```
‚úÖ **Mehrere Event-Listener m√∂glich**  
‚úÖ **Kann mit `removeEventListener()` entfernt werden**  

```javascript
function handler() {
  console.log("Event ausgel√∂st!");
}

document.getElementById("btn").addEventListener("click", handler);
document.getElementById("btn").removeEventListener("click", handler);
```
‚ùå **Funktion muss benannt sein, um sie zu entfernen**  

---

## **2. Direktes Event-Handling (veraltete Methode)**
```html
<button onclick="alert('Geklickt!')">Klick mich</button>
```
‚ùå **Nicht empfohlen, da HTML und JS vermischt werden**  

---

## **3. `onEvent`-Eigenschaft (nicht empfohlen)**
```javascript
document.getElementById("btn").onclick = function() {
  console.log("Button geklickt!");
};
```
‚ùå **√úberschreibt vorherige Event-Handler**  

---

## **4. Wichtige Event-Objekte**
Das **Event-Objekt (`event`)** enth√§lt Informationen √ºber das Ereignis.

### **4.1 `event.target` ‚Äì Element, das das Ereignis ausgel√∂st hat**
```javascript
document.getElementById("btn").addEventListener("click", function(event) {
  console.log(event.target); // Gibt das geklickte Element zur√ºck
});
```

### **4.2 `event.preventDefault()` ‚Äì Standardverhalten verhindern**
```javascript
document.querySelector("a").addEventListener("click", function(event) {
  event.preventDefault(); // Verhindert das Laden der Seite
  console.log("Link wurde geklickt!");
});
```

---

## **5. Event-Delegation (Optimierte Event-Behandlung)**
Anstatt jedem Element einen Event-Listener zuzuweisen, kann das **√ºbergeordnete Element** die Ereignisse abfangen.

```javascript
document.getElementById("liste").addEventListener("click", function(event) {
  if (event.target.tagName === "LI") {
    console.log(`Geklickt: ${event.target.innerText}`);
  }
});
```
‚úÖ **Weniger Event-Listener ‚Üí Bessere Performance**  

---

## **6. Bubbling & Capturing (Event Propagation)**
Ein Ereignis durchl√§uft **drei Phasen**:  
1. **Capturing Phase** (`window ‚Üí Eltern ‚Üí Kind`)  
2. **Target Phase** (Event erreicht das Ziel)  
3. **Bubbling Phase** (Event steigt von **Kind ‚Üí Eltern ‚Üí window** auf)

### **6.1 Bubbling (Standardverhalten)**
```javascript
document.getElementById("child").addEventListener("click", function() {
  console.log("Child geklickt!");
});

document.getElementById("parent").addEventListener("click", function() {
  console.log("Parent geklickt!");
});
```
Wenn `child` geklickt wird:  
```
Child geklickt!
Parent geklickt!  // (Weil das Event "hochblubbert")
```

### **6.2 Event nur auf Ziel stoppen**
```javascript
document.getElementById("child").addEventListener("click", function(event) {
  event.stopPropagation(); // Stoppt das Bubbling
  console.log("Nur Child wird ausgel√∂st!");
});
```

---

### **Zusammenfassung**
| Methode | Vorteil | Nachteil |
|---------|---------|---------|
| **`addEventListener()`** | Mehrere Listener, entfernbare Events | Funktion muss benannt sein zum Entfernen |
| **`onclick = function`** | Einfach | √úberschreibt fr√ºhere Handler |
| **Inline `onclick="..."`** | Schnell | Vermischt HTML & JavaScript |
| **Event-Delegation** | Spart Ressourcen | Muss `event.target` pr√ºfen |
| **`stopPropagation()`** | Verhindert Bubbling | Kann ungewollte Effekte haben |

üîó [MDN-Dokumentation zu `addEventListener()`](https://developer.mozilla.org/de/docs/Web/API/EventTarget/addEventListener)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

62. ### <a name="62"></a> Ereignis-Bubbling (event bubbling)

### **Ereignis-Bubbling (`event bubbling`) in JavaScript**  

**Ereignis-Bubbling** beschreibt, wie ein **Ereignis von einem untergeordneten (`child`) Element zu den √ºbergeordneten (`parent`) Elementen "hochblubbert"**.  

---

## **1. Standardverhalten: Bubbling**
Wenn ein `click`-Event auf einem `child`-Element ausgel√∂st wird, **wird das Ereignis automatisch an die Eltern weitergegeben**.  
Das bedeutet: **Erst das geklickte Element verarbeitet das Event, dann seine Eltern (bis zum `document`).**

```html
<div id="parent">
  <button id="child">Klick mich</button>
</div>
```

```javascript
document.getElementById("child").addEventListener("click", () => {
  console.log("Child geklickt!");
});

document.getElementById("parent").addEventListener("click", () => {
  console.log("Parent geklickt!");
});
```

**Klick auf den Button (`#child`) ‚Üí Ausgabe:**  
```
Child geklickt!
Parent geklickt!
```
‚úÖ **Das `click`-Ereignis "blubbert" vom `child` zum `parent`.**  

---

## **2. `stopPropagation()` ‚Äì Bubbling verhindern**
Falls das Ereignis **nicht an Eltern weitergegeben werden soll**, kann `event.stopPropagation()` verwendet werden.

```javascript
document.getElementById("child").addEventListener("click", (event) => {
  event.stopPropagation(); // Stoppt das Bubbling
  console.log("Nur Child wird ausgel√∂st!");
});
```
**Klick auf `#child` ‚Üí Ausgabe:**  
```
Nur Child wird ausgel√∂st!
```
‚úÖ **Das `click`-Event bleibt auf `child`, `parent` wird nicht aufgerufen.**  

---

## **3. `capture: true` ‚Äì Capturing-Phase aktivieren**
Standardm√§√üig wird ein Event zuerst auf dem `child` ausgef√ºhrt.  
Mit `{ capture: true }` kann das Ereignis zuerst im `parent` verarbeitet werden (Capturing statt Bubbling).

```javascript
document.getElementById("parent").addEventListener("click", () => {
  console.log("Parent geklickt (Capturing)!");
}, { capture: true });
```
**Klick auf `#child` ‚Üí Ausgabe:**  
```
Parent geklickt (Capturing)!
Child geklickt!
```
‚úÖ **Das Event wird zuerst im `parent` verarbeitet und dann im `child`.**  

---

## **4. `stopImmediatePropagation()` ‚Äì Alle weiteren Handler blockieren**
Falls ein Element mehrere Event-Listener hat, kann **`stopImmediatePropagation()`** verhindern, dass weitere Listener ausgef√ºhrt werden.

```javascript
document.getElementById("child").addEventListener("click", (event) => {
  event.stopImmediatePropagation();
  console.log("Erster Listener");
});

document.getElementById("child").addEventListener("click", () => {
  console.log("Zweiter Listener");
});
```
‚úÖ **Nur "Erster Listener" wird ausgef√ºhrt, der zweite wird blockiert.**  

---

### **Zusammenfassung**
| Methode | Wirkung |
|---------|---------|
| **Bubbling (Standard)** | Event wandert von `child` zu `parent`. |
| **`event.stopPropagation()`** | Verhindert Bubbling (nur `child` feuert). |
| **`{ capture: true }`** | Aktiviert **Capturing-Phase** (Eltern zuerst). |
| **`event.stopImmediatePropagation()`** | Blockiert ALLE Event-Handler auf dem Element. |

üîó [MDN-Dokumentation zu `event.stopPropagation()`](https://developer.mozilla.org/de/docs/Web/API/Event/stopPropagation)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

63. ### <a name="63"></a> Ereignis-Delegation

### **Ereignis-Delegation (`event delegation`) in JavaScript**  

**Ereignis-Delegation** bedeutet, dass **ein √ºbergeordnetes Element (`parent`) ein Ereignis f√ºr seine untergeordneten (`child`) Elemente verarbeitet**.  
Das nutzt **Ereignis-Bubbling**, um nicht f√ºr jedes Kind-Element einen eigenen Event-Listener zu setzen.

---

## **1. Warum Ereignis-Delegation?**
‚úÖ **Bessere Performance** (weniger Event-Listener)  
‚úÖ **Funktioniert auch f√ºr dynamisch erstellte Elemente**  
‚úÖ **Einfacher zu verwalten**  

---

## **2. Beispiel ohne Delegation (Ineffizient)**
```javascript
document.querySelectorAll("li").forEach(li => {
  li.addEventListener("click", () => {
    console.log("LI geklickt!");
  });
});
```
‚ùå **Jedes `li`-Element bekommt einen eigenen Event-Listener!**  
‚ùå **Neue `li`-Elemente funktionieren nicht automatisch**  

---

## **3. Ereignis-Delegation (Empfohlene Methode)**
```javascript
document.getElementById("liste").addEventListener("click", (event) => {
  if (event.target.tagName === "LI") {
    console.log(`Geklickt: ${event.target.innerText}`);
  }
});
```
‚úÖ **Nur ein Event-Listener f√ºr die gesamte Liste (`#liste`)**  
‚úÖ **Funktioniert auch f√ºr sp√§ter hinzugef√ºgte `li`-Elemente**  

---

## **4. Dynamische Elemente automatisch unterst√ºtzen**
```javascript
document.getElementById("liste").addEventListener("click", (event) => {
  if (event.target.matches("li")) {
    console.log(`Neu geklickt: ${event.target.innerText}`);
  }
});

document.getElementById("addItem").addEventListener("click", () => {
  const neuesLi = document.createElement("li");
  neuesLi.textContent = "Neues Item";
  document.getElementById("liste").appendChild(neuesLi);
});
```
‚úÖ **Neue Elemente (`<li>`) funktionieren ohne zus√§tzlichen Code!**  

---

## **5. `event.target` vs. `event.currentTarget`**
- **`event.target`** ‚Üí Das Element, das das Ereignis ausgel√∂st hat (`<li>`).  
- **`event.currentTarget`** ‚Üí Das Element, an dem der Event-Listener h√§ngt (`#liste`).

```javascript
document.getElementById("liste").addEventListener("click", (event) => {
  console.log("target:", event.target); // Das geklickte `li`
  console.log("currentTarget:", event.currentTarget); // `#liste`
});
```

---

## **6. `stopPropagation()` verhindern, wenn n√∂tig**
Falls ein `li` innerhalb eines anderen Elements liegt, kann `event.stopPropagation()` ungewollte Effekte verhindern:

```javascript
document.getElementById("liste").addEventListener("click", (event) => {
  if (event.target.matches("button")) {
    event.stopPropagation(); // Verhindert, dass `li`-Events ebenfalls feuern
  }
});
```

---

### **Zusammenfassung**
| Methode | Vorteil |
|---------|---------|
| **Direkter Event-Listener pro Element** | ‚ùå Ineffizient bei vielen Elementen |
| **Event-Delegation (`addEventListener()` am `parent`)** | ‚úÖ Weniger Event-Listener, bessere Performance |
| **`event.target`** | ‚úÖ Gibt das **eigentliche geklickte Element** zur√ºck |
| **`event.currentTarget`** | ‚úÖ Gibt das **Element mit dem Event-Listener** zur√ºck |
| **Dynamische Elemente** | ‚úÖ Funktionieren automatisch |

üîó [MDN-Dokumentation zu `event delegation`](https://developer.mozilla.org/de/docs/Learn/JavaScript/Building_blocks/Events#event_delegation)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

64. ### <a name="64"></a> Unterschied zwischen load und DOMContentLoaded

### **Unterschied zwischen `load` und `DOMContentLoaded` in JavaScript**  

Beide Ereignisse werden im **Window- oder Document-Objekt** ausgel√∂st, aber sie haben unterschiedliche Zeitpunkte und Zwecke.

---

## **1. `DOMContentLoaded` ‚Äì DOM ist geladen, aber Ressourcen noch nicht**
```javascript
document.addEventListener("DOMContentLoaded", () => {
  console.log("DOM ist vollst√§ndig geladen!");
});
```
‚úÖ **L√§uft, sobald das HTML-Dokument geparst wurde**  
‚úÖ **Bilder, Stylesheets & externe Ressourcen k√∂nnen noch laden**  
‚úÖ **Ideal f√ºr DOM-Manipulationen (z. B. `document.querySelector`)**  

---

## **2. `load` ‚Äì Alles ist vollst√§ndig geladen**
```javascript
window.addEventListener("load", () => {
  console.log("Seite und alle Ressourcen sind vollst√§ndig geladen!");
});
```
‚úÖ **L√§uft erst, wenn ALLE Ressourcen (CSS, Bilder, Skripte) geladen sind**  
‚úÖ **Gut f√ºr Skripte, die auf vollst√§ndige Inhalte (z. B. Bilder) angewiesen sind**  

---

## **3. Unterschied in der Praxis**
```javascript
document.addEventListener("DOMContentLoaded", () => {
  console.log("HTML ist fertig!");
});

window.addEventListener("load", () => {
  console.log("Alles (inkl. Bilder) ist geladen!");
});
```
**Wenn die Seite l√§dt:**  
```
HTML ist fertig!  // (DOMContentLoaded)
Alles (inkl. Bilder) ist geladen!  // (load)
```

---

## **4. Wann welches Event nutzen?**
| Event | Wann wird es ausgel√∂st? | Wann verwenden? |
|-------|-----------------|----------------|
| **`DOMContentLoaded`** | Sobald das HTML vollst√§ndig geladen und geparst ist | Wenn **DOM-Manipulationen** notwendig sind |
| **`load`** | Wenn **alle Ressourcen (CSS, Bilder, Skripte, Fonts)** geladen sind | Wenn Skripte auf **Bilder oder CSS-Abmessungen** angewiesen sind |

üîó [MDN-Dokumentation zu `DOMContentLoaded`](https://developer.mozilla.org/de/docs/Web/API/Document/DOMContentLoaded_event)  
üîó [MDN-Dokumentation zu `load`](https://developer.mozilla.org/de/docs/Web/API/Window/load_event)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

65. ### <a name="65"></a> Elemente von der Seite abrufen

### **Elemente von der Seite abrufen in JavaScript**  

JavaScript bietet mehrere Methoden, um **HTML-Elemente** aus dem DOM abzurufen.

---

## **1. `getElementById()` ‚Äì Einzelnes Element per `id` abrufen**
```javascript
const element = document.getElementById("meinElement");
console.log(element);
```
‚úÖ **Schnell und effizient**  
‚ùå **Nur f√ºr ein einzelnes Element mit `id`**  

---

## **2. `getElementsByClassName()` ‚Äì Elemente per `class` abrufen (Live Collection)**
```javascript
const elements = document.getElementsByClassName("meineKlasse");
console.log(elements[0]); // Erstes Element mit der Klasse
```
‚úÖ **Live Collection ‚Üí Aktualisiert sich bei DOM-√Ñnderungen**  
‚ùå **Keine Array-Methoden (`map()`, `filter()`)** ‚Üí `Array.from()` verwenden  

---

## **3. `getElementsByTagName()` ‚Äì Alle Elemente eines bestimmten Tags abrufen (Live Collection)**
```javascript
const alleDivs = document.getElementsByTagName("div");
console.log(alleDivs.length); // Anzahl der <div>-Elemente
```
‚úÖ **Schnell f√ºr bestimmte Tags (`div`, `p`, `a`)**  
‚ùå **Auch eine Live Collection (kein echtes Array)**  

---

## **4. `querySelector()` ‚Äì Erstes passendes Element per CSS-Selektor abrufen**
```javascript
const erstesDiv = document.querySelector("div");
console.log(erstesDiv);
```
‚úÖ **Sehr flexibel (CSS-Selektoren wie `#id`, `.class`, `[attr]`)**  
‚úÖ **Findet nur das erste passende Element**  

---

## **5. `querySelectorAll()` ‚Äì Alle passenden Elemente abrufen (Statische `NodeList`)**
```javascript
const alleButtons = document.querySelectorAll("button");
console.log(alleButtons);
```
‚úÖ **Erzeugt eine `NodeList` (√§hnlich einem Array, aber nicht live)**  
‚úÖ **Unterst√ºtzt `forEach()`, `map()`**  
‚ùå **√Ñndert sich nicht, wenn neue Elemente ins DOM kommen**  

---

## **6. `document.forms` ‚Äì Alle `<form>`-Elemente abrufen**
```javascript
console.log(document.forms);
console.log(document.forms[0].elements); // Alle Eingabefelder der ersten Form
```
‚úÖ **N√ºtzlich f√ºr Formulareingaben**  

---

## **7. `document.images`, `document.links` ‚Äì Spezielle Sammlungen**
```javascript
console.log(document.images); // Alle Bilder (`<img>`)
console.log(document.links); // Alle Links (`<a>`)
```
‚úÖ **Schneller Zugriff auf spezielle Elemente**  

---

## **Zusammenfassung**
| Methode | R√ºckgabe | Besonderheiten |
|---------|---------|---------------|
| **`getElementById("id")`** | Einzelnes Element (`Element`) | Schnell, aber nur f√ºr `id` |
| **`getElementsByClassName("class")`** | Live Collection (`HTMLCollection`) | Kein echtes Array, dynamisch |
| **`getElementsByTagName("tag")`** | Live Collection (`HTMLCollection`) | Enth√§lt alle Elemente des Typs |
| **`querySelector("css-selektor")`** | Erstes passendes Element (`Element`) | Flexibel mit CSS-Selektoren |
| **`querySelectorAll("css-selektor")`** | Statische `NodeList` | Unterst√ºtzt `forEach()`, `map()` |
| **`document.forms`** | `HTMLCollection` | Zugriff auf Formulare |
| **`document.images`, `document.links`** | `HTMLCollection` | Schneller Zugriff auf Bilder/Links |

üîó [MDN-Dokumentation zu `document.querySelector()`](https://developer.mozilla.org/de/docs/Web/API/Document/querySelector)  
üîó [MDN-Dokumentation zu `getElementById()`](https://developer.mozilla.org/de/docs/Web/API/Document/getElementById)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

66. ### <a name="66"></a> Methoden zum Abrufen von DOM-Elementen in JavaScript

### **Methoden zum Abrufen von DOM-Elementen in JavaScript**  

JavaScript bietet mehrere **DOM-Methoden**, um Elemente aus dem HTML-Dokument abzurufen.  
Hier sind die wichtigsten Methoden mit ihren Unterschieden.

---

## **1. `getElementById(id)` ‚Äì Einzelnes Element per `id`**
```javascript
const element = document.getElementById("meinElement");
console.log(element);
```
‚úÖ **Schnell und effizient**  
‚úÖ **Gibt ein einzelnes Element zur√ºck**  
‚ùå **Nur f√ºr `id`, keine `class` oder `tag`-Suche**  

---

## **2. `getElementsByClassName(className)` ‚Äì Alle Elemente mit einer `class` (Live Collection)**
```javascript
const elements = document.getElementsByClassName("meineKlasse");
console.log(elements[0]); // Erstes Element mit der Klasse
```
‚úÖ **Findet mehrere Elemente**  
‚úÖ **Schneller als `querySelectorAll()`**  
‚ùå **Live Collection (ver√§ndert sich bei DOM-Updates)**  
‚ùå **Kein echtes Array (`map()`, `filter()` fehlen)**  

üìå **L√∂sung: Umwandlung in ein echtes Array**
```javascript
const elementsArray = Array.from(document.getElementsByClassName("meineKlasse"));
```

---

## **3. `getElementsByTagName(tagName)` ‚Äì Alle Elemente eines bestimmten Tags (Live Collection)**
```javascript
const alleDivs = document.getElementsByTagName("div");
console.log(alleDivs.length); // Anzahl der <div>-Elemente
```
‚úÖ **Schnell f√ºr bestimmte Tags (`div`, `p`, `a`)**  
‚úÖ **Gibt eine Live Collection zur√ºck**  
‚ùå **Kein echtes Array**  

---

## **4. `querySelector(selector)` ‚Äì Erstes passendes Element per CSS-Selektor**
```javascript
const erstesDiv = document.querySelector("div");
console.log(erstesDiv);
```
‚úÖ **Sehr flexibel (CSS-Selektoren wie `#id`, `.class`, `[attr]`)**  
‚úÖ **Gibt nur das erste gefundene Element zur√ºck**  
‚ùå **Langsamer als `getElementById()`**  

---

## **5. `querySelectorAll(selector)` ‚Äì Alle passenden Elemente abrufen (`NodeList`)**
```javascript
const alleButtons = document.querySelectorAll("button");
console.log(alleButtons);
```
‚úÖ **Erzeugt eine `NodeList` (√§hnlich einem Array, aber nicht live)**  
‚úÖ **Unterst√ºtzt `forEach()`, `map()`**  
‚ùå **√Ñndert sich nicht automatisch bei DOM-Updates**  

üìå **L√∂sung: In ein echtes Array umwandeln**
```javascript
const echteArray = [...document.querySelectorAll("button")];
```

---

## **6. `document.forms`, `document.images`, `document.links` ‚Äì Spezielle Sammlungen**
```javascript
console.log(document.forms); // Alle Formulare
console.log(document.images); // Alle Bilder (`<img>`)
console.log(document.links); // Alle Links (`<a>`)
```
‚úÖ **Schneller Zugriff auf bestimmte Elemente**  

---

## **7. `document.body`, `document.head`, `document.documentElement`**
```javascript
console.log(document.body); // <body>...</body>
console.log(document.head); // <head>...</head>
console.log(document.documentElement); // <html>...</html>
```
‚úÖ **Direkter Zugriff auf die Hauptbereiche des Dokuments**  

---

## **Zusammenfassung**
| Methode | R√ºckgabe | Besonderheiten |
|---------|---------|---------------|
| **`getElementById("id")`** | Einzelnes Element (`Element`) | Schnell, nur f√ºr `id` |
| **`getElementsByClassName("class")`** | Live Collection (`HTMLCollection`) | Kein echtes Array |
| **`getElementsByTagName("tag")`** | Live Collection (`HTMLCollection`) | Enth√§lt alle Elemente des Typs |
| **`querySelector("css-selektor")`** | Erstes passendes Element (`Element`) | Flexibel mit CSS-Selektoren |
| **`querySelectorAll("css-selektor")`** | Statische `NodeList` | Unterst√ºtzt `forEach()`, `map()` |
| **`document.forms`** | `HTMLCollection` | Zugriff auf Formulare |
| **`document.images`, `document.links`** | `HTMLCollection` | Schneller Zugriff auf Bilder/Links |

üîó [MDN-Dokumentation zu `document.querySelector()`](https://developer.mozilla.org/de/docs/Web/API/Document/querySelector)  
üîó [MDN-Dokumentation zu `getElementById()`](https://developer.mozilla.org/de/docs/Web/API/Document/getElementById)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

67. ### <a name="67"></a> Navigation durch DOM-Elemente

### **Navigation durch DOM-Elemente in JavaScript**  

JavaScript bietet verschiedene Methoden, um durch das **Document Object Model (DOM)** zu navigieren.  

---

## **1. Eltern-Element abrufen (`parentNode` & `parentElement`)**  
```javascript
const kind = document.getElementById("child");
console.log(kind.parentNode); // Gibt das √ºbergeordnete Element zur√ºck
console.log(kind.parentElement); // Meist dasselbe wie `parentNode`
```
‚úÖ **`parentNode` enth√§lt auch `document`, `parentElement` nicht.**  

---

## **2. Kind-Elemente abrufen (`childNodes` & `children`)**  
```javascript
const eltern = document.getElementById("parent");

console.log(eltern.childNodes); // NodeList (inkl. Text & Kommentare)
console.log(eltern.children); // HTMLCollection (nur Elemente)
```
‚úÖ **`children` gibt nur echte HTML-Elemente zur√ºck.**  

---

## **3. Erstes & letztes Kind abrufen (`firstChild`, `firstElementChild`)**  
```javascript
console.log(eltern.firstChild); // Erstes Node (auch Text!)
console.log(eltern.firstElementChild); // Erstes echtes Element
console.log(eltern.lastElementChild); // Letztes echtes Element
```
‚úÖ **`firstChild` kann auch Textknoten sein!**  

---

## **4. Geschwister-Elemente abrufen (`nextSibling`, `previousSibling`)**  
```javascript
const aktuelles = document.getElementById("item");

console.log(aktuelles.nextSibling); // N√§chstes Node (inkl. Text)
console.log(aktuelles.nextElementSibling); // N√§chstes echtes Element
console.log(aktuelles.previousElementSibling); // Vorheriges echtes Element
```
‚úÖ **`nextElementSibling` & `previousElementSibling` ignorieren Textknoten.**  

---

## **5. Alle Nachfahren (`querySelectorAll()`)**  
```javascript
const nachfahren = document.getElementById("container").querySelectorAll("p");
console.log(nachfahren); // Alle <p>-Elemente innerhalb von #container
```
‚úÖ **Ideal f√ºr selektives Finden von Elementen.**  

---

## **6. Alle Vorfahren (`closest()`)**
```javascript
const item = document.getElementById("child");
console.log(item.closest(".container")); // N√§chstes √ºbergeordnetes `.container`
```
‚úÖ **Findet das n√§chste √ºbergeordnete Element mit bestimmtem Selektor.**  

---

### **Zusammenfassung**
| Methode | R√ºckgabe | Besonderheiten |
|---------|---------|---------------|
| **`parentNode` / `parentElement`** | √úbergeordnetes Element | `parentElement` gibt nur HTML-Elemente zur√ºck |
| **`childNodes`** | Alle Knoten (inkl. Text) | Enth√§lt auch Leerzeichen & Kommentare |
| **`children`** | Nur HTML-Elemente | Schneller als `childNodes` |
| **`firstChild` / `firstElementChild`** | Erstes Kind | `firstChild` kann auch ein Textknoten sein |
| **`nextSibling` / `nextElementSibling`** | N√§chstes Geschwister-Element | `nextElementSibling` ignoriert Textknoten |
| **`closest(selector)`** | N√§chstes √ºbergeordnetes Element | Findet den n√§chsten passenden Vorfahren |

üîó [MDN-Dokumentation zu `parentElement`](https://developer.mozilla.org/de/docs/Web/API/Node/parentElement)  
üîó [MDN-Dokumentation zu `closest()`](https://developer.mozilla.org/de/docs/Web/API/Element/closest)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

68. ### <a name="68"></a> classList, className und Ereignisdelegation

### **`classList`, `className` und Ereignisdelegation in JavaScript**  

Diese Konzepte helfen, **CSS-Klassen** zu verwalten und **Ereignisse effizient zu handhaben**.

---

## **1. `classList` ‚Äì Klassen effizient verwalten (Empfohlen)**
`classList` bietet Methoden, um Klassen hinzuzuf√ºgen, zu entfernen oder zu toggeln.

```javascript
const element = document.getElementById("meinElement");

// Klasse hinzuf√ºgen
element.classList.add("neue-klasse");

// Klasse entfernen
element.classList.remove("alte-klasse");

// Klasse umschalten (toggle)
element.classList.toggle("aktiv");

// Pr√ºfen, ob Klasse existiert
console.log(element.classList.contains("aktiv")); // true oder false
```
‚úÖ **Mehrere Klassen gleichzeitig verwalten**  
‚úÖ **`toggle()` erleichtert Umschalten**  

---

## **2. `className` ‚Äì Klassen als String verwalten (veraltet)**
```javascript
const element = document.getElementById("meinElement");

// Alle Klassen setzen (√ºberschreibt vorhandene Klassen!)
element.className = "klasse1 klasse2";
```
‚ùå **√úberschreibt alle vorhandenen Klassen!**  
‚úÖ **Praktisch, wenn alle Klassen auf einmal ge√§ndert werden m√ºssen.**  

üìå **L√∂sung zum Hinzuf√ºgen mit `className` (unsicher)**  
```javascript
element.className += " neue-klasse"; // ‚ùå Funktioniert, kann aber doppelte Klassen erzeugen
```
üìå **Besser mit `classList.add()`**  

---

## **3. Ereignisdelegation ‚Äì Events effizient verwalten**
**Ereignisdelegation** erm√∂glicht es, Ereignisse auf **√ºbergeordnete (`parent`) Elemente** zu setzen, statt auf jedes einzelne Kind-Element (`child`).

```html
<ul id="liste">
  <li>Klick mich 1</li>
  <li>Klick mich 2</li>
  <li>Klick mich 3</li>
</ul>
```

```javascript
document.getElementById("liste").addEventListener("click", (event) => {
  if (event.target.tagName === "LI") {
    event.target.classList.toggle("aktiv"); // Klasse umschalten
    console.log(`Geklickt: ${event.target.innerText}`);
  }
});
```
‚úÖ **Nur ein Event-Listener f√ºr die gesamte Liste**  
‚úÖ **Neue `li`-Elemente funktionieren automatisch**  

üìå **Vergleich ohne Delegation (schlecht)**  
```javascript
document.querySelectorAll("li").forEach((li) => {
  li.addEventListener("click", () => console.log("LI geklickt!"));
});
```
‚ùå **Setzt viele Event-Listener ‚Üí Langsamer, ineffizient**  

---

### **Zusammenfassung**
| Feature | Methode | Vorteile | Nachteile |
|---------|---------|----------|-----------|
| **Klassen verwalten** | `classList.add()`, `remove()`, `toggle()` | ‚úÖ Sicher & effizient | ‚ùå Nicht f√ºr kompletten Austausch geeignet |
| **Alle Klassen setzen** | `className = "..."` | ‚úÖ Einfach, wenn alle Klassen √ºberschrieben werden | ‚ùå √úberschreibt bestehende Klassen |
| **Ereignisdelegation** | `parent.addEventListener("click", callback)` | ‚úÖ Spart Ressourcen, funktioniert mit neuen Elementen | ‚ùå Muss `event.target` pr√ºfen |

üîó [MDN-Dokumentation zu `classList`](https://developer.mozilla.org/de/docs/Web/API/Element/classList)  
üîó [MDN-Dokumentation zu Ereignisdelegation](https://developer.mozilla.org/de/docs/Learn/JavaScript/Building_blocks/Events#event_delegation)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

69. ### <a name="69"></a> Manipulation von Seitenelementen

### **Manipulation von Seitenelementen in JavaScript**  

Mit JavaScript k√∂nnen HTML-Elemente dynamisch **ge√§ndert, hinzugef√ºgt oder entfernt** werden.

---

## **1. Inhalt √§ndern (`innerHTML`, `textContent`)**
### **1.1 `innerHTML` ‚Äì HTML-Inhalt setzen (nicht sicher!)**
```javascript
document.getElementById("element").innerHTML = "<strong>Neuer Text</strong>";
```
‚ùå **Gef√§hrlich: Kann Sicherheitsl√ºcken (XSS) verursachen**  

---

### **1.2 `textContent` ‚Äì Nur Text setzen (sicher!)**
```javascript
document.getElementById("element").textContent = "<strong>Nur Text</strong>";
```
‚úÖ **Sicherer als `innerHTML` (keine HTML-Ausf√ºhrung)**  

---

## **2. Attribute √§ndern (`setAttribute`, `getAttribute`, `removeAttribute`)**
```javascript
const link = document.getElementById("meinLink");

link.setAttribute("href", "https://example.com");
console.log(link.getAttribute("href")); // "https://example.com"
link.removeAttribute("target");
```
‚úÖ **Funktioniert f√ºr alle HTML-Attribute**  

---

## **3. CSS-Klassen verwalten (`classList`)**
```javascript
const box = document.getElementById("box");

box.classList.add("highlight");  // Klasse hinzuf√ºgen
box.classList.remove("hidden");  // Klasse entfernen
box.classList.toggle("aktiv");   // Umschalten
console.log(box.classList.contains("aktiv")); // true oder false
```
‚úÖ **Besser als `className` (vermeidet √úberschreibung)**  

---

## **4. CSS direkt √§ndern (`style`)**
```javascript
const element = document.getElementById("element");
element.style.color = "red";
element.style.fontSize = "20px";
```
‚úÖ **Direkte CSS-√Ñnderung m√∂glich**  
‚ùå **Nicht f√ºr komplexe Stylesheets geeignet**  

üìå **Besser: Klasse hinzuf√ºgen statt Inline-Styles**  
```javascript
element.classList.add("rote-schrift");
```

---

## **5. Elemente erstellen, hinzuf√ºgen & entfernen**
### **5.1 Neues Element erstellen (`createElement`)**
```javascript
const neuerAbsatz = document.createElement("p");
neuerAbsatz.textContent = "Ich bin neu!";
document.body.appendChild(neuerAbsatz);
```

---

### **5.2 Element an bestimmter Stelle einf√ºgen (`insertBefore`)**
```javascript
const liste = document.getElementById("liste");
const neuerEintrag = document.createElement("li");
neuerEintrag.textContent = "Neues Item";

liste.insertBefore(neuerEintrag, liste.children[1]); // Vor 2. Element einf√ºgen
```

---

### **5.3 Element entfernen (`remove`)**
```javascript
document.getElementById("zuEntfernen").remove();
```
üìå **√Ñltere Methode (`removeChild`)**
```javascript
const parent = document.getElementById("container");
const kind = document.getElementById("child");

parent.removeChild(kind);
```

---

### **6. Ereignisse hinzuf√ºgen (`addEventListener`)**
```javascript
document.getElementById("btn").addEventListener("click", () => {
  alert("Button wurde geklickt!");
});
```

---

### **Zusammenfassung**
| Aktion | Methode | Beschreibung |
|--------|---------|-------------|
| **Inhalt √§ndern** | `innerHTML`, `textContent` | `innerHTML` f√ºr HTML, `textContent` f√ºr sicheren Text |
| **Attribute √§ndern** | `setAttribute`, `getAttribute`, `removeAttribute` | Manipuliert HTML-Attribute |
| **CSS-Klassen** | `classList.add()`, `remove()`, `toggle()` | Klassen effizient verwalten |
| **CSS-Styles** | `element.style.property` | Direktes √Ñndern von Styles |
| **Elemente erstellen** | `createElement`, `appendChild`, `insertBefore` | F√ºgt neue Elemente hinzu |
| **Elemente entfernen** | `remove()`, `removeChild()` | Entfernt HTML-Elemente |
| **Ereignisse** | `addEventListener()` | Reagiert auf Benutzeraktionen |

üîó [MDN-Dokumentation zu `document.createElement()`](https://developer.mozilla.org/de/docs/Web/API/Document/createElement)  
üîó [MDN-Dokumentation zu `classList`](https://developer.mozilla.org/de/docs/Web/API/Element/classList)  

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

70. ### <a name="70"></a> Dokument- und Fensterparameter sowie deren Nutzung

### **Dokument- und Fensterparameter sowie deren Nutzung in JavaScript**  

JavaScript bietet verschiedene **Eigenschaften und Methoden**, um Informationen √ºber das **Dokument (HTML-Seite)** und das **Fenster (Browser-Viewport)** zu erhalten und zu manipulieren.

---

## **1. Fenster-Parameter (`window`-Objekt)**  
Das `window`-Objekt repr√§sentiert das **Browser-Fenster** und enth√§lt Methoden, um Gr√∂√üe, Position und Verhalten zu steuern.

### **1.1 Fenstergr√∂√üe (`innerWidth`, `innerHeight`)**
```javascript
console.log(window.innerWidth);  // Breite des sichtbaren Bereichs (Viewport)
console.log(window.innerHeight); // H√∂he des Viewports
```
‚úÖ **Gibt die Gr√∂√üe des nutzbaren Bereichs im Browser zur√ºck.**  

---

### **1.2 Scroll-Position (`scrollX`, `scrollY`)**
```javascript
console.log(window.scrollX); // Horizontale Scroll-Position
console.log(window.scrollY); // Vertikale Scroll-Position
```
‚úÖ **Hilfreich f√ºr Sticky-Navigationen oder Lazy Loading.**  

üìå **Scroll-Position √§ndern:**
```javascript
window.scrollTo(0, 100); // Scrollt zur Y-Position 100px
window.scrollBy(0, 50);  // Scrollt 50px nach unten
```

---

### **1.3 Bildschirmgr√∂√üe (`screen`-Objekt)**
```javascript
console.log(screen.width, screen.height); // Gesamtbildschirmgr√∂√üe
console.log(screen.availWidth, screen.availHeight); // Nutzbare Fl√§che
```
‚úÖ **Zeigt auch verf√ºgbare Fl√§che ohne Taskleiste.**  

---

### **1.4 Fenster √∂ffnen & schlie√üen (`open()`, `close()`)**
```javascript
const neuesFenster = window.open("https://example.com", "_blank", "width=600,height=400");
neuesFenster.close(); // Schlie√üt das Fenster
```
‚úÖ **Erm√∂glicht das √ñffnen neuer Tabs/Fenster.**  
‚ùå **Kann durch Pop-up-Blocker verhindert werden.**  

---

## **2. Dokument-Parameter (`document`-Objekt)**
Das `document`-Objekt repr√§sentiert die HTML-Seite.

---

### **2.1 Titel und URL abrufen**
```javascript
console.log(document.title);  // Gibt den Seitentitel zur√ºck
console.log(document.URL);    // Aktuelle URL der Seite
```

üìå **Titel setzen:**
```javascript
document.title = "Neuer Titel";
```

---

### **2.2 Dokumentgr√∂√üe (`document.documentElement.scrollHeight`)**
```javascript
console.log(document.documentElement.scrollHeight); // Gesamte Dokumenth√∂he
console.log(document.documentElement.scrollWidth);  // Gesamte Breite
```
‚úÖ **Wichtig f√ºr Infinite-Scrolling oder dynamisches Laden.**  

---

### **2.3 Dokument-Elemente abrufen**
```javascript
console.log(document.body); // Zugriff auf <body>
console.log(document.head); // Zugriff auf <head>
console.log(document.documentElement); // Zugriff auf <html>
```

---

## **3. Fenster-Ereignisse (`resize`, `scroll`, `load`)**
```javascript
window.addEventListener("resize", () => {
  console.log(`Neue Gr√∂√üe: ${window.innerWidth} x ${window.innerHeight}`);
});

window.addEventListener("scroll", () => {
  console.log(`Scroll-Position: ${window.scrollY}`);
});
```
‚úÖ **Ideal f√ºr responsives Verhalten & dynamisches Layout.**  

---

## **4. `navigator`-Objekt ‚Äì Browser-Informationen**
```javascript
console.log(navigator.userAgent); // Gibt Browser-Info zur√ºck
console.log(navigator.language);  // Sprache des Browsers
console.log(navigator.platform);  // Betriebssystem
```
‚úÖ **Wird f√ºr Ger√§te- & Browser-Erkennung genutzt.**  

---

### **Zusammenfassung**
| Feature | Methode/Eigenschaft | Beschreibung |
|---------|------------------|-------------|
| **Fenstergr√∂√üe** | `window.innerWidth`, `window.innerHeight` | Gibt die Viewport-Gr√∂√üe zur√ºck |
| **Scroll-Position** | `window.scrollX`, `window.scrollY` | Aktuelle Scroll-Position |
| **Dokumentgr√∂√üe** | `document.documentElement.scrollHeight` | Gesamte H√∂he des Dokuments |
| **URL & Titel** | `document.URL`, `document.title` | Zeigt und setzt Seitentitel & URL |
| **Bildschirmgr√∂√üe** | `screen.width`, `screen.height` | Bildschirmaufl√∂sung |
| **Browser-Info** | `navigator.userAgent`, `navigator.language` | Browser- und Ger√§teinformationen |
| **Fenster-Events** | `resize`, `scroll`, `load` | Reagiert auf Gr√∂√üen- und Scroll√§nderungen |

üîó [MDN-Dokumentation zu `window`](https://developer.mozilla.org/de/docs/Web/API/Window)  
üîó [MDN-Dokumentation zu `document`](https://developer.mozilla.org/de/docs/Web/API/Document)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

71. ### <a name="71"></a> Web Animations API

### **Web Animations API in JavaScript**  

Die **Web Animations API (WAAPI)** erm√∂glicht Animationen direkt mit **JavaScript**, ohne CSS `@keyframes` oder externe Bibliotheken wie jQuery oder GSAP.

---

## **1. Grundlegende Animation mit `element.animate()`**
```javascript
const box = document.getElementById("box");

box.animate(
  [
    { transform: "translateX(0px)" }, 
    { transform: "translateX(200px)" }
  ],
  {
    duration: 1000,  // Dauer in ms (1s)
    iterations: 1,   // Anzahl der Wiederholungen
    easing: "ease-in-out" // Animationstiming
  }
);
```
‚úÖ **Direkte Steuerung per JavaScript**  
‚úÖ **Kein zus√§tzliches CSS n√∂tig**  

---

## **2. Eigenschaften der Web Animations API**
Ein `animate()`-Aufruf ben√∂tigt **zwei Parameter**:  
1. **Keyframes** ‚Üí Eine Liste von Werten, die das Element durchl√§uft.  
2. **Timing-Optionen** ‚Üí Steuerung von Dauer, Wiederholungen & Verz√∂gerung.  

### **2.1 Keyframe-Optionen**
```javascript
const keyframes = [
  { opacity: 0, transform: "translateY(-50px)" },
  { opacity: 1, transform: "translateY(0px)" }
];
```

### **2.2 Timing-Optionen**
```javascript
const options = {
  duration: 1500,  // Animation dauert 1,5 Sekunden
  iterations: Infinity, // Endlos wiederholen
  easing: "ease-in-out", // Weiche Bewegung
  delay: 500, // Verz√∂gerung um 0,5s
  fill: "forwards" // Bleibt im Endzustand stehen
};
```

---

## **3. Animation speichern & steuern (`play()`, `pause()`, `reverse()`)**
```javascript
const animation = box.animate(keyframes, options);

// Steuerung der Animation
animation.pause();   // Stoppt die Animation
animation.play();    // Startet sie erneut
animation.reverse(); // L√§uft r√ºckw√§rts
animation.cancel();  // Setzt sie zur√ºck
```
‚úÖ **Manuelle Steuerung m√∂glich**  

---

## **4. Animation mit `finished`-Promise abfragen**
```javascript
animation.finished.then(() => {
  console.log("Animation ist fertig!");
});
```
‚úÖ **Perfekt f√ºr Callback-Funktionen**  

---

## **5. Animation mit `animate()` und `addEventListener`**
```javascript
document.getElementById("btn").addEventListener("click", () => {
  box.animate(
    [
      { transform: "scale(1)" },
      { transform: "scale(1.2)" },
      { transform: "scale(1)" }
    ],
    { duration: 500, iterations: 1 }
  );
});
```
‚úÖ **Event-Listener k√∂nnen Animationen starten**  

---

### **Zusammenfassung**
| Feature | Methode / Eigenschaft | Beschreibung |
|---------|-----------------|--------------|
| **Element animieren** | `element.animate(keyframes, options)` | Startet eine Animation |
| **Animation stoppen** | `animation.pause()` | Stoppt die Animation |
| **Animation fortsetzen** | `animation.play()` | Setzt sie fort |
| **Animation r√ºckg√§ngig** | `animation.reverse()` | Spielt sie r√ºckw√§rts ab |
| **Animation nach Fertigstellung** | `animation.finished.then(callback)` | F√ºhrt eine Aktion nach Beendigung aus |

üîó [MDN-Dokumentation zur Web Animations API](https://developer.mozilla.org/de/docs/Web/API/Web_Animations_API)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

72. ### <a name="72"></a> requestAnimationFrame

### **`requestAnimationFrame()` in JavaScript**  

Die Methode **`requestAnimationFrame()`** wird verwendet, um **leistungsoptimierte Animationen** zu erstellen. Sie sorgt f√ºr eine **fl√ºssige Darstellung**, indem sie Animationen an die Bildwiederholrate (meist **60 FPS**) des Bildschirms anpasst.

---

## **1. Grundlegendes Beispiel ‚Äì Ein Element bewegen**
```javascript
const box = document.getElementById("box");

let position = 0;
function animate() {
  position += 2;
  box.style.transform = `translateX(${position}px)`;

  if (position < 200) {
    requestAnimationFrame(animate); // N√§chsten Frame planen
  }
}

animate(); // Animation starten
```
‚úÖ **Effizienter als `setInterval()` oder `setTimeout()`**  
‚úÖ **Wird automatisch gestoppt, wenn der Tab inaktiv ist**  

---

## **2. Vergleich: `setInterval()` vs. `requestAnimationFrame()`**
### **Mit `setInterval()` (nicht empfohlen)**
```javascript
setInterval(() => {
  box.style.transform = `translateX(${position}px)`;
  position += 2;
}, 16); // ~60 FPS (1000ms / 60 = ~16ms)
```
‚ùå **Kann ruckeln, da das Timing nicht an die tats√§chliche Framerate angepasst wird.**  

### **Mit `requestAnimationFrame()` (empfohlen)**
```javascript
function animate() {
  position += 2;
  box.style.transform = `translateX(${position}px)`;
  requestAnimationFrame(animate);
}
animate();
```
‚úÖ **Wird synchron zur Bildschirmwiederholrate ausgef√ºhrt**  

---

## **3. Animation stoppen (`cancelAnimationFrame()`)**
```javascript
let animationId;
function move() {
  position += 2;
  box.style.transform = `translateX(${position}px)`;
  if (position < 200) {
    animationId = requestAnimationFrame(move);
  }
}

move(); // Startet die Animation

setTimeout(() => {
  cancelAnimationFrame(animationId); // Stoppt die Animation
}, 1000);
```
‚úÖ **Animation kann jederzeit gestoppt werden**  

---

## **4. FPS messen mit `performance.now()`**
```javascript
let lastTime = performance.now();

function trackFPS() {
  let now = performance.now();
  let fps = Math.round(1000 / (now - lastTime));
  console.log(`FPS: ${fps}`);
  lastTime = now;
  requestAnimationFrame(trackFPS);
}

trackFPS();
```
‚úÖ **Hilft, die Performance zu analysieren**  

---

### **Zusammenfassung**
| Feature | Methode | Beschreibung |
|---------|---------|--------------|
| **Animation starten** | `requestAnimationFrame(callback)` | Startet eine fl√ºssige Animation |
| **Animation stoppen** | `cancelAnimationFrame(id)` | Stoppt eine geplante Animation |
| **Effizienz** | Synchronisiert mit 60 FPS | Verhindert Ruckler und CPU-√úberlastung |
| **Alternative zu** | `setInterval()`, `setTimeout()` | Bessere Performance & Energieeffizienz |

üîó [MDN-Dokumentation zu `requestAnimationFrame()`](https://developer.mozilla.org/de/docs/Web/API/window/requestAnimationFrame)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

73. ### <a name="73"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

74. ### <a name="74"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

75. ### <a name="75"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

76. ### <a name="76"></a> setTimeout und setInterval, Besonderheiten

### **`setTimeout()` und `setInterval()` in JavaScript**  

Diese Methoden werden verwendet, um **zeitverz√∂gerte oder wiederholte Ausf√ºhrungen** von Funktionen zu steuern.  

---

## **1. `setTimeout(callback, delay)` ‚Äì Verz√∂gerte Ausf√ºhrung**
F√ºhrt eine Funktion **nach einer bestimmten Zeit (ms)** einmal aus.

```javascript
setTimeout(() => {
  console.log("Nach 2 Sekunden ausgef√ºhrt!");
}, 2000);
```
‚úÖ **Einmalige Verz√∂gerung**  
‚ùå **Funktioniert asynchron ‚Äì l√§uft unabh√§ngig vom Hauptcode**  

---

### **1.1 `setTimeout()` abbrechen mit `clearTimeout()`**
```javascript
const timeoutId = setTimeout(() => {
  console.log("Das wird nicht ausgef√ºhrt!");
}, 2000);

clearTimeout(timeoutId); // L√∂scht den Timeout
```
‚úÖ **N√ºtzlich, um Verz√∂gerungen zu stoppen (z. B. Ladeanimationen)**  

---

## **2. `setInterval(callback, delay)` ‚Äì Wiederholte Ausf√ºhrung**
F√ºhrt eine Funktion **immer wieder nach einer bestimmten Zeit aus**.

```javascript
const intervalId = setInterval(() => {
  console.log("Alle 2 Sekunden wiederholt!");
}, 2000);
```
‚úÖ **Perfekt f√ºr zyklische Updates (z. B. Uhren, Echtzeit-Daten)**  

---

### **2.1 `setInterval()` abbrechen mit `clearInterval()`**
```javascript
const intervalId = setInterval(() => {
  console.log("Wiederholung...");
}, 1000);

setTimeout(() => {
  clearInterval(intervalId); // Stoppt den `setInterval`
  console.log("Interval gestoppt!");
}, 5000);
```
‚úÖ **N√ºtzlich, um Loops zu stoppen (z. B. nach X Sekunden)**  

---

## **3. `setTimeout()` als `setInterval()`-Alternative**
Manchmal ist es besser, `setTimeout()` rekursiv zu verwenden, statt `setInterval()`.

```javascript
function wiederhole() {
  console.log("Wiederholung...");
  setTimeout(wiederhole, 1000); // Wartet 1 Sekunde und ruft sich erneut auf
}

wiederhole();
```
‚úÖ **Bessere Kontrolle als `setInterval()` (z. B. variabler Delay)**  

---

## **4. Besonderheiten & Probleme**
### **4.1 `setTimeout(0)` ‚Äì Wann wird es ausgef√ºhrt?**
```javascript
console.log("Start");

setTimeout(() => {
  console.log("Timeout mit 0 ms!");
}, 0);

console.log("Ende");
```
**Konsolenausgabe:**
```
Start
Ende
Timeout mit 0 ms!
```
üìå **Grund:** `setTimeout(0)` wird erst nach dem aktuellen Callstack ausgef√ºhrt!  

---

### **4.2 `setInterval()` kann ungenau sein**
```javascript
let count = 0;
const start = Date.now();

const interval = setInterval(() => {
  count++;
  console.log(`Laufzeit: ${Date.now() - start} ms`);
  if (count === 5) clearInterval(interval);
}, 1000);
```
‚ùå **`setInterval(1000)` l√§uft nicht exakt jede Sekunde, weil andere Code-Ausf√ºhrungen Verz√∂gerungen verursachen k√∂nnen.**  
‚úÖ **Besser:** `setTimeout()` rekursiv nutzen (siehe Punkt 3).  

---

### **Zusammenfassung**
| Methode | Beschreibung | Stoppen mit |
|---------|-------------|------------|
| **`setTimeout(callback, delay)`** | F√ºhrt `callback` **einmal** nach `delay` ms aus | `clearTimeout(id)` |
| **`setInterval(callback, delay)`** | F√ºhrt `callback` **wiederholt** alle `delay` ms aus | `clearInterval(id)` |
| **Alternative** | `setTimeout()` rekursiv als `setInterval()`-Ersatz nutzen | - |

üîó [MDN-Dokumentation zu `setTimeout()`](https://developer.mozilla.org/de/docs/Web/API/setTimeout)  
üîó [MDN-Dokumentation zu `setInterval()`](https://developer.mozilla.org/de/docs/Web/API/setInterval)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

77. ### <a name="77"></a> AJAX und XMLHttpRequest

### **AJAX und `XMLHttpRequest` in JavaScript**  

**AJAX (Asynchronous JavaScript and XML)** erm√∂glicht das **asynchrone Laden von Daten** in eine Webseite, ohne die Seite neu zu laden.  
Dazu wird h√§ufig das **`XMLHttpRequest`-Objekt (XHR)** oder die modernere **`fetch()`-API** verwendet.

---

## **1. Grundlagen: `XMLHttpRequest`**
```javascript
const xhr = new XMLHttpRequest();
xhr.open("GET", "https://jsonplaceholder.typicode.com/posts/1", true);
xhr.onreadystatechange = function () {
  if (xhr.readyState === 4 && xhr.status === 200) {
    console.log(JSON.parse(xhr.responseText)); // Antwort als JSON ausgeben
  }
};
xhr.send();
```
‚úÖ **`xhr.open(method, url, async)`** ‚Üí √ñffnet eine Verbindung  
‚úÖ **`xhr.send()`** ‚Üí Sendet die Anfrage  

---

## **2. `readyState` Werte (`onreadystatechange`)**
| `readyState` | Bedeutung |
|-------------|-----------|
| `0` | Anfrage nicht initialisiert (`UNSENT`) |
| `1` | Verbindung ge√∂ffnet (`OPENED`) |
| `2` | Anfrage gesendet (`HEADERS_RECEIVED`) |
| `3` | Antwort wird geladen (`LOADING`) |
| `4` | Antwort vollst√§ndig (`DONE`) |

---

## **3. HTTP-Methoden mit `XMLHttpRequest`**
### **3.1 `GET`-Anfrage**
```javascript
xhr.open("GET", "https://jsonplaceholder.typicode.com/users", true);
xhr.send();
```

### **3.2 `POST`-Anfrage (Daten senden)**
```javascript
const xhr = new XMLHttpRequest();
xhr.open("POST", "https://jsonplaceholder.typicode.com/posts", true);
xhr.setRequestHeader("Content-Type", "application/json;charset=UTF-8");

xhr.onreadystatechange = function () {
  if (xhr.readyState === 4 && xhr.status === 201) {
    console.log("Erfolgreich gesendet:", JSON.parse(xhr.responseText));
  }
};

const daten = JSON.stringify({ title: "Neuer Beitrag", body: "Inhalt", userId: 1 });
xhr.send(daten);
```
‚úÖ **`xhr.setRequestHeader()` setzt die ben√∂tigten Header f√ºr JSON-Daten**  

---

## **4. Fehlerbehandlung**
```javascript
xhr.onerror = function () {
  console.log("Fehler beim Laden der Daten!");
};
```
‚úÖ **Wichtig f√ºr Netzwerkfehler**  

---

## **5. `fetch()` als moderner Ersatz f√ºr `XMLHttpRequest`**
```javascript
fetch("https://jsonplaceholder.typicode.com/posts/1")
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error("Fehler:", error));
```
‚úÖ **K√ºrzere Syntax**  
‚úÖ **Verwendet Promises statt `onreadystatechange`**  

---

### **Zusammenfassung**
| Methode | Beschreibung |
|---------|-------------|
| **`XMLHttpRequest`** | √Ñltere AJAX-Technik, erfordert `onreadystatechange` |
| **`fetch()`** | Moderner, nutzt Promises, k√ºrzere Syntax |
| **`readyState`** | Zeigt Status der Anfrage (`0-4`) |
| **`xhr.setRequestHeader()`** | Setzt HTTP-Header f√ºr Anfragen |

üîó [MDN-Dokumentation zu `XMLHttpRequest`](https://developer.mozilla.org/de/docs/Web/API/XMLHttpRequest)  
üîó [MDN-Dokumentation zu `fetch()`](https://developer.mozilla.org/de/docs/Web/API/Fetch_API)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

78. ### <a name="78"></a> Promise (ES6)

### **Promise (ES6) in JavaScript**  

Ein **Promise** ist ein **Objekt**, das einen **asynchronen Prozess** repr√§sentiert. Es kann folgende Zust√§nde haben:  

- **`pending`** ‚Üí Der Promise wird ausgef√ºhrt (noch nicht abgeschlossen).  
- **`fulfilled`** ‚Üí Der Promise wurde erfolgreich abgeschlossen (`resolve`).  
- **`rejected`** ‚Üí Der Promise ist fehlgeschlagen (`reject`).  

---

## **1. Einfache `Promise`-Erstellung**
```javascript
const meinPromise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("Erfolg!"); // Promise erfolgreich
    // reject("Fehler!"); // Falls Fehler auftritt
  }, 2000);
});

meinPromise
  .then((ergebnis) => console.log(ergebnis)) // "Erfolg!"
  .catch((fehler) => console.error(fehler)) // Falls `reject` ausgef√ºhrt wurde
  .finally(() => console.log("Fertig!")); // Wird immer ausgef√ºhrt
```
‚úÖ **`resolve(value)`** ‚Üí Erfolg (geht in `.then()`)  
‚úÖ **`reject(error)`** ‚Üí Fehler (geht in `.catch()`)  
‚úÖ **`finally()`** ‚Üí Wird immer ausgef√ºhrt  

---

## **2. Verkettung von Promises (`then()`)**
```javascript
new Promise((resolve) => resolve(2))
  .then((wert) => wert * 2)
  .then((wert) => wert + 3)
  .then((wert) => console.log(wert)); // 7
```
‚úÖ **`then()` gibt automatisch einen neuen Promise zur√ºck**  

---

## **3. `Promise.all()` ‚Äì Mehrere Promises parallel ausf√ºhren**
```javascript
const p1 = new Promise((resolve) => setTimeout(() => resolve("A"), 1000));
const p2 = new Promise((resolve) => setTimeout(() => resolve("B"), 2000));

Promise.all([p1, p2]).then((ergebnisse) => console.log(ergebnisse)); // ["A", "B"] nach 2s
```
‚úÖ **Wird erst ausgef√ºhrt, wenn ALLE Promises erfolgreich sind**  
‚ùå **Falls ein Promise fehlschl√§gt, wird der gesamte `Promise.all()` abgebrochen**  

üìå **Fehlertolerante Alternative: `Promise.allSettled()`**
```javascript
Promise.allSettled([p1, Promise.reject("Fehler")])
  .then((ergebnisse) => console.log(ergebnisse));
```
‚úÖ **Jedes Promise gibt seinen Status zur√ºck (`fulfilled` oder `rejected`)**  

---

## **4. `Promise.race()` ‚Äì Erstes abgeschlossenes Promise gewinnt**
```javascript
Promise.race([
  new Promise((resolve) => setTimeout(() => resolve("Schnell"), 1000)),
  new Promise((resolve) => setTimeout(() => resolve("Langsam"), 3000))
]).then((ergebnis) => console.log(ergebnis)); // "Schnell" nach 1s
```
‚úÖ **N√ºtzlich f√ºr Timeout-Strategien**  

---

## **5. `Promise.any()` ‚Äì Erster `resolve()` gewinnt (ES2021)**
```javascript
Promise.any([
  Promise.reject("Fehler 1"),
  new Promise((resolve) => setTimeout(() => resolve("Erfolg"), 2000)),
  Promise.reject("Fehler 2")
]).then((ergebnis) => console.log(ergebnis)); // "Erfolg" nach 2s
```
‚úÖ **Ignoriert Fehler, solange mindestens ein Promise erfolgreich ist**  
‚ùå **Falls alle fehlschlagen ‚Üí `AggregateError`**  

---

## **6. `async/await` als Alternative zu Promises**
```javascript
async function ladeDaten() {
  try {
    let daten = await fetch("https://jsonplaceholder.typicode.com/posts/1");
    let json = await daten.json();
    console.log(json);
  } catch (fehler) {
    console.error("Fehler:", fehler);
  }
}

ladeDaten();
```
‚úÖ **Bessere Lesbarkeit als `.then()`-Ketten**  
‚úÖ **Kann mit `try/catch` Fehler abfangen**  

---

### **Zusammenfassung**
| Methode | Beschreibung |
|---------|-------------|
| **`then()`** | Wird bei `resolve()` ausgef√ºhrt |
| **`catch()`** | Wird bei `reject()` ausgef√ºhrt |
| **`finally()`** | Wird immer ausgef√ºhrt |
| **`Promise.all([])`** | Wartet auf alle Promises, bricht bei Fehler ab |
| **`Promise.allSettled([])`** | Wartet auf alle Promises, gibt Status zur√ºck |
| **`Promise.race([])`** | Nimmt das erste Promise, das fertig ist |
| **`Promise.any([])`** | Nimmt das erste erfolgreiche Promise |

üîó [MDN-Dokumentation zu Promises](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Promise)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

79. ### <a name="79"></a> Fetch API

### **Fetch API in JavaScript**  

Die **Fetch API** ist eine moderne M√∂glichkeit, um **asynchrone HTTP-Anfragen** zu senden. Sie bietet eine **promisbasierte API** und ist eine Alternative zu `XMLHttpRequest`.

---

## **1. Grundlegende Verwendung von `fetch()`**
```javascript
fetch("https://jsonplaceholder.typicode.com/posts/1")
  .then((response) => response.json()) // Antwort als JSON parsen
  .then((data) => console.log(data))    // Die Daten weiterverarbeiten
  .catch((error) => console.error("Fehler:", error)); // Fehlerbehandlung
```
‚úÖ **`fetch()` gibt ein Promise zur√ºck**, das mit der Antwort (Response) aufgel√∂st wird.  
‚úÖ **Antworten m√ºssen explizit in das gew√ºnschte Format (z. B. `json()`) umgewandelt werden.**

---

## **2. `fetch()` mit POST-Anfragen und Senden von Daten**
```javascript
fetch("https://jsonplaceholder.typicode.com/posts", {
  method: "POST",                       // HTTP-Methode
  headers: {                            // Header
    "Content-Type": "application/json"
  },
  body: JSON.stringify({                // Daten, die gesendet werden
    title: "Neuer Post",
    body: "Dies ist ein neuer Beitrag.",
    userId: 1
  })
})
  .then((response) => response.json())
  .then((data) => console.log(data))
  .catch((error) => console.error("Fehler:", error));
```
‚úÖ **`method`** gibt die HTTP-Methode an (`GET`, `POST`, etc.)  
‚úÖ **`headers`** definieren die Header der Anfrage  
‚úÖ **`body`** enth√§lt die gesendeten Daten (wird normalerweise als JSON-String √ºbertragen)

---

## **3. Behandlung der Antwort**
### **3.1 √úberpr√ºfen des Statuscodes**
```javascript
fetch("https://jsonplaceholder.typicode.com/posts/1")
  .then((response) => {
    if (!response.ok) { // Statuscode 200-299
      throw new Error("Fehler beim Abrufen der Daten");
    }
    return response.json();
  })
  .then((data) => console.log(data))
  .catch((error) => console.error("Fehler:", error));
```
‚úÖ **`response.ok`** √ºberpr√ºft, ob der Statuscode im Bereich 200-299 liegt.  
‚úÖ **Fehlerbehandlung** ist wichtig, um auf HTTP-Fehler zu reagieren.

---

### **3.2 Umwandeln der Antwort in andere Formate**
```javascript
fetch("https://jsonplaceholder.typicode.com/posts/1")
  .then((response) => response.text()) // Antwort als Text
  .then((text) => console.log(text))    // Textinhalt ausgeben

fetch("https://jsonplaceholder.typicode.com/posts/1")
  .then((response) => response.blob()) // Antwort als Blob (z. B. Bild)
  .then((blob) => console.log(blob))    // Blob weiterverarbeiten
```
‚úÖ **`text()`**, **`json()`**, **`blob()`** und andere Methoden wandeln die Antwort in unterschiedliche Formate um.

---

## **4. `async/await` mit Fetch API**
```javascript
async function fetchDaten() {
  try {
    const response = await fetch("https://jsonplaceholder.typicode.com/posts/1");
    if (!response.ok) {
      throw new Error("Fehler beim Abrufen der Daten");
    }
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error("Fehler:", error);
  }
}

fetchDaten();
```
‚úÖ **`async/await` macht den Code lesbarer und synchroner.**  
‚úÖ **Fehler k√∂nnen direkt mit `try/catch` abgefangen werden.**

---

## **5. CORS (Cross-Origin Resource Sharing)**
**CORS** steuert, ob eine Webanwendung **Anfragen von einer anderen Dom√§ne** ausf√ºhren kann. Wenn ein Fehler auftritt, sieht die Fehlermeldung z. B. so aus:
```
Access to fetch at 'https://example.com' from origin 'https://yourwebsite.com' has been blocked by CORS policy.
```
‚úÖ **CORS-Probleme k√∂nnen mit Serverkonfigurationen oder durch Hinzuf√ºgen von CORS-Headern auf dem Server behoben werden.**

---

## **6. Optionen wie `mode`, `credentials`, `cache`**
```javascript
fetch("https://jsonplaceholder.typicode.com/posts/1", {
  method: "GET",
  headers: {
    "Accept": "application/json"
  },
  mode: "cors",          // CORS-Modus (z. B. "cors", "no-cors", "same-origin")
  credentials: "same-origin",  // Senden von Cookies nur bei derselben Herkunft
  cache: "no-cache"      // Cache-Optionen (z. B. "no-cache", "reload", "force-cache")
})
  .then((response) => response.json())
  .then((data) => console.log(data));
```
‚úÖ **`mode`** regelt CORS-Handling.  
‚úÖ **`credentials`** steuert das Senden von Cookies und Authentifizierung.  
‚úÖ **`cache`** bietet Optionen zur Caching-Strategie.

---

### **Zusammenfassung**
| Methode | Beschreibung |
|---------|-------------|
| **`fetch(url, options)`** | Senden von HTTP-Anfragen (z. B. `GET`, `POST`) |
| **`response.json()`** | Antwort als JSON parsen |
| **`response.text()`** | Antwort als Text parsen |
| **`response.blob()`** | Antwort als Blob parsen (z. B. Bilder) |
| **`response.ok`** | √úberpr√ºft, ob die Antwort erfolgreich war (Status 200-299) |
| **`async/await`** | Verbessert die Lesbarkeit und Fehlerbehandlung von `fetch()` |

üîó [MDN-Dokumentation zu `fetch()`](https://developer.mozilla.org/de/docs/Web/API/Fetch_API)  
üîó [MDN-Dokumentation zu `Response`](https://developer.mozilla.org/de/docs/Web/API/Response)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

80. ### <a name="80"></a> Async/Await (ES8)

### **Async/Await (ES8) in JavaScript**  

**`async/await`** ist eine **modernere Alternative** zu Promises (`.then()`-Ketten) und macht asynchronen Code **lesbarer und synchroner**.

---

## **1. `async`-Funktion erstellen**
Eine **`async`-Funktion** gibt immer **ein Promise zur√ºck**.

```javascript
async function beispiel() {
  return "Hallo Welt!";
}

beispiel().then(console.log); // "Hallo Welt!"
```
‚úÖ **Automatische R√ºckgabe eines Promises**  
‚úÖ **Kein explizites `return new Promise()` n√∂tig**  

---

## **2. `await` ‚Äì Warte auf Promise-Ergebnisse**
```javascript
async function ladeDaten() {
  let response = await fetch("https://jsonplaceholder.typicode.com/posts/1");
  let daten = await response.json();
  console.log(daten);
}

ladeDaten();
```
‚úÖ **`await` wartet, bis das Promise aufgel√∂st wurde**  
‚úÖ **Kein `.then()` n√∂tig**  

---

## **3. Fehlerbehandlung mit `try/catch`**
```javascript
async function ladeDatenMitFehler() {
  try {
    let response = await fetch("https://jsonplaceholder.typicode.com/invalid-url");
    if (!response.ok) throw new Error("Fehlerhafte Anfrage!");
    
    let daten = await response.json();
    console.log(daten);
  } catch (error) {
    console.error("Fehler:", error);
  }
}

ladeDatenMitFehler();
```
‚úÖ **Besser als `.catch()` f√ºr Fehlerbehandlung**  

---

## **4. `async/await` mit mehreren Promises (`Promise.all`)**
```javascript
async function ladeMehrereDaten() {
  let [benutzer, beitraege] = await Promise.all([
    fetch("https://jsonplaceholder.typicode.com/users/1").then((res) => res.json()),
    fetch("https://jsonplaceholder.typicode.com/posts?userId=1").then((res) => res.json()),
  ]);

  console.log(benutzer, beitraege);
}

ladeMehrereDaten();
```
‚úÖ **Effizient ‚Äì Beide Anfragen laufen gleichzeitig!**  

---

## **5. `await` in Schleifen (nacheinander ausf√ºhren)**
```javascript
async function ladeNacheinander() {
  for (let id of [1, 2, 3]) {
    let res = await fetch(`https://jsonplaceholder.typicode.com/posts/${id}`);
    let daten = await res.json();
    console.log(daten.title);
  }
}

ladeNacheinander();
```
‚úÖ **F√ºhrt Anfragen in einer Schleife nacheinander aus**  
‚ùå **Langsamer als `Promise.all()` (kein paralleles Laden)**  

---

## **6. `await` in einer normalen Funktion (geht nicht)**
‚ùå **`await` kann nur in `async`-Funktionen verwendet werden!**
```javascript
// Ung√ºltig:
function test() {
  let data = await fetch("https://jsonplaceholder.typicode.com/posts/1"); // ‚ùå Fehler!
}
```
‚úÖ **L√∂sung:** Funktion in `async`-Funktion umwandeln  
```javascript
async function test() {
  let data = await fetch("https://jsonplaceholder.typicode.com/posts/1");
  console.log(await data.json());
}
```

---

### **Zusammenfassung**
| Feature | Beschreibung |
|---------|-------------|
| **`async function()`** | Erstellt eine asynchrone Funktion, gibt ein Promise zur√ºck |
| **`await`** | Wartet auf das Ergebnis eines Promises |
| **`try/catch`** | F√§ngt Fehler in `async`-Funktionen ab |
| **`Promise.all()`** | F√ºhrt mehrere Promises parallel aus |
| **`await` in Schleifen** | F√ºhrt Promises nacheinander aus |

üîó [MDN-Dokumentation zu `async/await`](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Statements/async_function)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

81. ### <a name="81"></a> try...catch, throw-Anweisung

### **`try...catch` und `throw` in JavaScript**  

Die **`try...catch`-Anweisung** dient zur **Fehlerbehandlung**, w√§hrend **`throw`** es erm√∂glicht, manuell Fehler auszul√∂sen.

---

## **1. Grundlegende Fehlerbehandlung mit `try...catch`**
```javascript
try {
  let x = y + 1; // Fehler: `y` ist nicht definiert
} catch (error) {
  console.log("Fehler:", error.message);
}
```
‚úÖ **`try`-Block f√ºhrt den Code aus**  
‚úÖ **`catch`-Block f√§ngt Fehler ab und verhindert Absturz**  

---

## **2. `catch` kann Fehlerdetails abrufen**
```javascript
try {
  let x = y + 1;
} catch (error) {
  console.log("Fehlertyp:", error.name); // ReferenceError
  console.log("Fehlermeldung:", error.message); // y is not defined
}
```
‚úÖ **`error.name` ‚Üí Fehlertyp (z. B. `ReferenceError`, `TypeError`)**  
‚úÖ **`error.message` ‚Üí Detaillierte Fehlermeldung**  

---

## **3. `throw` ‚Äì Eigene Fehler ausl√∂sen**
```javascript
function pr√ºfeAlter(alter) {
  if (alter < 18) {
    throw new Error("Du bist zu jung!");
  }
  return "Zugang erlaubt";
}

try {
  console.log(pr√ºfeAlter(16));
} catch (error) {
  console.error("Fehler:", error.message);
}
```
‚úÖ **`throw` kann benutzerdefinierte Fehler ausl√∂sen**  

üìå **Ohne `try...catch` w√ºrde das Skript abst√ºrzen!**  

---

## **4. `finally` ‚Äì Code immer ausf√ºhren**
```javascript
try {
  console.log("Code wird ausgef√ºhrt");
} catch (error) {
  console.log("Fehler passiert");
} finally {
  console.log("Wird immer ausgef√ºhrt!");
}
```
‚úÖ **`finally` wird immer ausgef√ºhrt ‚Äì auch bei Fehlern!**  

---

## **5. `try...catch` mit `async/await`**
```javascript
async function ladeDaten() {
  try {
    let response = await fetch("https://jsonplaceholder.typicode.com/invalid-url");
    if (!response.ok) throw new Error("Fehlerhafte Anfrage!");
    
    let daten = await response.json();
    console.log(daten);
  } catch (error) {
    console.error("Fehler:", error.message);
  }
}

ladeDaten();
```
‚úÖ **F√§ngt Fehler bei `fetch()` oder anderen Promises ab**  

---

### **Zusammenfassung**
| Anweisung | Beschreibung |
|-----------|-------------|
| **`try {}`** | F√ºhrt den Code aus |
| **`catch(error) {}`** | F√§ngt Fehler ab |
| **`error.name`** | Zeigt den Fehler-Typ (z. B. `TypeError`) |
| **`error.message`** | Gibt die Fehlermeldung aus |
| **`throw new Error("...")`** | L√∂st einen eigenen Fehler aus |
| **`finally {}`** | Wird immer ausgef√ºhrt, egal ob Fehler oder nicht |

üîó [MDN-Dokumentation zu `try...catch`](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Statements/try...catch)  
üîó [MDN-Dokumentation zu `throw`](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Statements/throw)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

82. ### <a name="82"></a> Axios-Bibliothek

### **Axios-Bibliothek in JavaScript**  

**Axios** ist eine beliebte **HTTP-Client-Bibliothek**, die einfacher und leistungsf√§higer als die native `fetch()`-API ist.  
Sie basiert auf **Promises** und unterst√ºtzt **automatische JSON-Verarbeitung, Fehlerbehandlung und Abbruch von Anfragen**.

üìå **Installation (f√ºr Node.js / Browser mit npm):**
```bash
npm install axios
```
üìå **CDN f√ºr den Browser:**
```html
<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
```

---

## **1. `GET`-Anfrage mit Axios**
```javascript
axios.get("https://jsonplaceholder.typicode.com/posts/1")
  .then((response) => console.log(response.data)) // JSON-Daten ausgeben
  .catch((error) => console.error("Fehler:", error));
```
‚úÖ **`axios.get(url)`** ‚Üí F√ºhrt eine `GET`-Anfrage aus  
‚úÖ **Antwort ist bereits in `response.data` (kein `response.json()` n√∂tig)**  

---

## **2. `POST`-Anfrage mit Axios**
```javascript
axios.post("https://jsonplaceholder.typicode.com/posts", {
  title: "Neuer Beitrag",
  body: "Inhalt des Beitrags",
  userId: 1
})
  .then((response) => console.log(response.data))
  .catch((error) => console.error("Fehler:", error));
```
‚úÖ **Automatische Umwandlung in JSON**  
‚úÖ **Kein `fetch() + JSON.stringify()` n√∂tig**  

---

## **3. `PUT` und `DELETE` mit Axios**
```javascript
// Eintrag aktualisieren (PUT)
axios.put("https://jsonplaceholder.typicode.com/posts/1", {
  title: "Aktualisierter Titel",
  body: "Neuer Inhalt"
});

// Eintrag l√∂schen (DELETE)
axios.delete("https://jsonplaceholder.typicode.com/posts/1")
  .then(() => console.log("Erfolgreich gel√∂scht!"));
```
‚úÖ **PUT: √úberschreibt die gesamte Ressource**  
‚úÖ **DELETE: Entfernt eine Ressource**  

---

## **4. `async/await` mit Axios**
```javascript
async function ladeDaten() {
  try {
    const response = await axios.get("https://jsonplaceholder.typicode.com/posts");
    console.log(response.data);
  } catch (error) {
    console.error("Fehler:", error);
  }
}

ladeDaten();
```
‚úÖ **Verbessert Lesbarkeit im Vergleich zu `.then()`**  

---

## **5. Mehrere Anfragen gleichzeitig (`axios.all()`)**
```javascript
axios.all([
  axios.get("https://jsonplaceholder.typicode.com/users/1"),
  axios.get("https://jsonplaceholder.typicode.com/posts?userId=1")
])
  .then(axios.spread((benutzer, beitraege) => {
    console.log("Benutzer:", benutzer.data);
    console.log("Beitr√§ge:", beitraege.data);
  }));
```
‚úÖ **F√ºhrt mehrere Anfragen parallel aus**  

---

## **6. Abbrechen von Anfragen mit `CancelToken`**
```javascript
const source = axios.CancelToken.source();

axios.get("https://jsonplaceholder.typicode.com/posts", { cancelToken: source.token })
  .catch((thrown) => {
    if (axios.isCancel(thrown)) {
      console.log("Anfrage abgebrochen:", thrown.message);
    }
  });

// Abbrechen der Anfrage
source.cancel("Anfrage wurde manuell abgebrochen.");
```
‚úÖ **Perfekt f√ºr das Abbrechen von Requests in SPA-Apps**  

---

## **7. Fehlerbehandlung mit `response.status`**
```javascript
axios.get("https://jsonplaceholder.typicode.com/invalid-url")
  .then((response) => console.log(response.data))
  .catch((error) => {
    if (error.response) {
      console.log("Fehlerstatus:", error.response.status); // z. B. 404
    } else {
      console.log("Netzwerkfehler:", error.message);
    }
  });
```
‚úÖ **Detaillierte Fehlerbehandlung basierend auf HTTP-Statuscodes**  

---

### **Zusammenfassung**
| Methode | Beschreibung |
|---------|-------------|
| **`axios.get(url)`** | F√ºhrt eine `GET`-Anfrage aus |
| **`axios.post(url, data)`** | Sendet eine `POST`-Anfrage |
| **`axios.put(url, data)`** | Aktualisiert eine Ressource (`PUT`) |
| **`axios.delete(url)`** | L√∂scht eine Ressource |
| **`axios.all([req1, req2])`** | F√ºhrt mehrere Anfragen parallel aus |
| **`axios.CancelToken`** | Erlaubt das Abbrechen von Anfragen |

üîó [Axios-Dokumentation](https://axios-http.com/docs/intro)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**   

83. ### <a name="83"></a> Event Loop, synchrone und asynchrone Operationen

### **Event Loop, synchrone und asynchrone Operationen in JavaScript**  

Der **Event Loop** ist der Mechanismus in JavaScript, der zwischen **synchronem und asynchronem Code** vermittelt und daf√ºr sorgt, dass asynchrone Operationen **nicht blockierend** ablaufen.

---

## **1. Synchrone vs. Asynchrone Operationen**
üìå **Synchrone Operationen** werden in der Reihenfolge ausgef√ºhrt, in der sie im Code stehen.  

```javascript
console.log("Erste Ausgabe");
console.log("Zweite Ausgabe");
```
**Konsolenausgabe:**  
```
Erste Ausgabe
Zweite Ausgabe
```
‚úÖ **Einfach, aber kann blockieren**  

üìå **Asynchrone Operationen** laufen im **Hintergrund** und werden erst sp√§ter ausgef√ºhrt.  

```javascript
console.log("Start");

setTimeout(() => {
  console.log("Asynchrone Ausgabe");
}, 2000);

console.log("Ende");
```
**Konsolenausgabe:**  
```
Start
Ende
Asynchrone Ausgabe (nach 2 Sekunden)
```
‚úÖ **Verhindert Blockieren des Hauptprogramms**  

---

## **2. Der Event Loop ‚Äì Wie funktioniert er?**
JavaScript l√§uft **single-threaded**, was bedeutet, dass es **nur eine Hauptausf√ºhrungsschleife** gibt.  

**Der Ablauf im Event Loop:**
1. **Call Stack (Aufrufstapel)** ‚Äì Hier werden **synchrone Operationen** direkt ausgef√ºhrt.  
2. **Web APIs (z. B. `setTimeout`)** ‚Äì Hier laufen **asynchrone Funktionen** im Hintergrund.  
3. **Callback Queue (Warteschlange)** ‚Äì Hier werden **fertige asynchrone Operationen** auf ihren Aufruf gewartet.  
4. **Event Loop** ‚Äì Pr√ºft, ob der Call Stack leer ist, und f√ºhrt dann Code aus der Callback Queue aus.  

---

## **3. Beispiel: Event Loop in Aktion**
```javascript
console.log("1");

setTimeout(() => console.log("2"), 0);

Promise.resolve().then(() => console.log("3"));

console.log("4");
```
**Konsolenausgabe:**
```
1
4
3
2
```
üìå **Warum?**
1. **`console.log("1")`** ‚Üí Wird direkt ausgef√ºhrt (Call Stack).  
2. **`setTimeout(..., 0)`** ‚Üí Kommt in die Web API, wird nach 0 ms in die Callback Queue geschoben.  
3. **`Promise.resolve().then(...)`** ‚Üí Kommt in die **Microtask Queue** (h√∂here Priorit√§t!).  
4. **`console.log("4")`** ‚Üí Wird direkt ausgef√ºhrt.  
5. **Event Loop** pr√ºft: **Microtasks (Promise)** werden VOR `setTimeout()`-Callbacks ausgef√ºhrt ‚Üí **`3` kommt vor `2`**.  

---

## **4. Unterschied: Callback Queue vs. Microtask Queue**
- **Callback Queue:** Enth√§lt **`setTimeout`**, **`setInterval`**, **`setImmediate`**-Callbacks.  
- **Microtask Queue:** Enth√§lt **`Promise.then()`**, **`MutationObserver`** (h√∂here Priorit√§t).  

**Reihenfolge:**  
1. **Call Stack wird geleert**  
2. **Alle Microtasks (`Promise.then()`) werden ausgef√ºhrt**  
3. **Erst dann kommen `setTimeout()` & `setInterval()` aus der Callback Queue**  

---

## **5. Praxis: Reihenfolge verstehen**
```javascript
setTimeout(() => console.log("Timeout"), 0);
Promise.resolve().then(() => console.log("Promise"));
console.log("Sofort");
```
**Konsolenausgabe:**
```
Sofort
Promise
Timeout
```
‚úÖ **Promiseketten (`.then()`) haben Vorrang vor `setTimeout()`**  

---

## **6. Blockierende Operationen vermeiden**
Wenn eine **langsame Schleife** den Call Stack blockiert, wird der Event Loop **angehalten**.

```javascript
console.log("Start");

for (let i = 0; i < 1e9; i++) {} // ‚ùå Blockiert die UI!

console.log("Ende");
```
‚ùå **Alles bleibt h√§ngen, da die Schleife nicht unterbrochen wird.**  

üìå **Besser: Asynchron mit `setTimeout()` ausf√ºhren**
```javascript
console.log("Start");

setTimeout(() => {
  for (let i = 0; i < 1e9; i++) {} // Wird verz√∂gert ausgef√ºhrt
  console.log("Lange Berechnung fertig");
}, 0);

console.log("Ende");
```
‚úÖ **Verhindert Blockieren der Hauptschleife**  

---

### **Zusammenfassung**
| Begriff | Beschreibung |
|---------|-------------|
| **Call Stack** | Stapel f√ºr synchronen Code |
| **Web APIs** | Verarbeitet asynchrone Operationen (`setTimeout`, `fetch`) |
| **Callback Queue** | Warteschlange f√ºr `setTimeout`, `setInterval` |
| **Microtask Queue** | Warteschlange f√ºr `Promise.then()`, hat h√∂here Priorit√§t |
| **Event Loop** | Steuert die Ausf√ºhrung von Code zwischen Stack, Queues & Web APIs |

üîó [MDN-Dokumentation zum Event Loop](https://developer.mozilla.org/de/docs/Web/JavaScript/EventLoop)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

84. ### <a name="84"></a> M√∂glichkeiten zum Senden von Serveranfragen

### **M√∂glichkeiten zum Senden von Serveranfragen in JavaScript**  

JavaScript bietet mehrere Methoden, um **HTTP-Anfragen** an einen Server zu senden.  
Hier sind die wichtigsten Techniken:

---

## **1. `fetch()` (Moderne L√∂sung, Promises)**
```javascript
fetch("https://jsonplaceholder.typicode.com/posts/1")
  .then((response) => response.json()) // Antwort als JSON parsen
  .then((data) => console.log(data))    // Daten ausgeben
  .catch((error) => console.error("Fehler:", error));
```
‚úÖ **Einfach & nativ in JS verf√ºgbar**  
‚úÖ **Unterst√ºtzt `async/await` f√ºr bessere Lesbarkeit**  
‚ùå **Kein automatischer Timeout oder Fehlerhandling f√ºr HTTP-Fehler**  

üìå **POST-Anfrage mit `fetch()`**
```javascript
fetch("https://jsonplaceholder.typicode.com/posts", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ title: "Neuer Beitrag", body: "Text", userId: 1 })
})
  .then((response) => response.json())
  .then((data) => console.log(data));
```

---

## **2. `XMLHttpRequest` (√Ñltere Methode)**
```javascript
const xhr = new XMLHttpRequest();
xhr.open("GET", "https://jsonplaceholder.typicode.com/posts/1", true);

xhr.onload = function () {
  if (xhr.status === 200) {
    console.log(JSON.parse(xhr.responseText));
  }
};

xhr.onerror = function () {
  console.error("Fehler bei der Anfrage");
};

xhr.send();
```
‚úÖ **Funktioniert in √§lteren Browsern**  
‚ùå **Komplexer als `fetch()` und nicht Promise-basiert**  

---

## **3. `Axios` (Beliebte externe Bibliothek)**
üìå **Installation (f√ºr Node.js & Browser mit npm)**
```bash
npm install axios
```
üìå **CDN f√ºr den Browser**
```html
<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
```
üìå **GET-Anfrage mit Axios**
```javascript
axios.get("https://jsonplaceholder.typicode.com/posts/1")
  .then((response) => console.log(response.data))
  .catch((error) => console.error("Fehler:", error));
```
üìå **POST-Anfrage mit Axios**
```javascript
axios.post("https://jsonplaceholder.typicode.com/posts", {
  title: "Neuer Post",
  body: "Inhalt",
  userId: 1
})
  .then((response) => console.log(response.data));
```
‚úÖ **Promise-basiert und einfach zu benutzen**  
‚úÖ **Automatische Fehlerbehandlung**  
‚úÖ **Unterst√ºtzt `async/await` & Abbruch von Anfragen**  

---

## **4. `WebSockets` (Echtzeit-Kommunikation)**
üìå **Verwendet f√ºr Live-Daten wie Chat, Spiele & Finanzm√§rkte**
```javascript
const socket = new WebSocket("wss://example.com/socket");

socket.onopen = () => {
  console.log("Verbindung ge√∂ffnet");
  socket.send("Hallo, Server!");
};

socket.onmessage = (event) => {
  console.log("Nachricht vom Server:", event.data);
};

socket.onerror = (error) => {
  console.error("WebSocket-Fehler:", error);
};

socket.onclose = () => {
  console.log("Verbindung geschlossen");
};
```
‚úÖ **Ideal f√ºr Echtzeitkommunikation**  
‚ùå **Server muss WebSockets unterst√ºtzen**  

---

## **5. `EventSource` (Server-Sent Events, SSE)**
üìå **F√ºr einseitige Updates (Server ‚Üí Client), z. B. News-Feeds**
```javascript
const eventSource = new EventSource("https://example.com/stream");

eventSource.onmessage = (event) => {
  console.log("Neue Nachricht:", event.data);
};

eventSource.onerror = () => {
  console.error("Verbindung unterbrochen");
};
```
‚úÖ **Weniger Overhead als WebSockets**  
‚ùå **Nur f√ºr Server ‚Üí Client-Nachrichten**  

---

### **Zusammenfassung**
| Methode | Beschreibung | Vorteile | Nachteile |
|---------|-------------|----------|-----------|
| **`fetch()`** | Moderne API f√ºr HTTP-Anfragen | Einfach, `async/await`, Promises | Kein Timeout, Fehlerbehandlung n√∂tig |
| **`XMLHttpRequest`** | √Ñltere Methode f√ºr AJAX | Funktioniert √ºberall | Komplexer, nicht Promise-basiert |
| **`Axios`** | Externe Bibliothek f√ºr HTTP | Einfach, `async/await`, Abbruch m√∂glich | Externer Import n√∂tig |
| **`WebSockets`** | Zwei-Wege-Kommunikation in Echtzeit | Live-Daten, geringe Latenz | Server-Unterst√ºtzung n√∂tig |
| **`EventSource`** | Einweg-Kommunikation Server ‚Üí Client | Einfach f√ºr Live-Updates | Kein Client ‚Üí Server-Kanal |

üîó [MDN-Dokumentation zu `fetch()`](https://developer.mozilla.org/de/docs/Web/API/Fetch_API)  
üîó [Axios-Dokumentation](https://axios-http.com/docs/intro)  
üîó [WebSockets-Dokumentation](https://developer.mozilla.org/de/docs/Web/API/WebSockets_API)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

85. ### <a name="85"></a> Long Polling (Langes Abfragen)

### **Long Polling (Langes Abfragen) in JavaScript**  

**Long Polling** ist eine Technik zur **Echtzeitkommunikation**, bei der der Client eine **lang laufende HTTP-Anfrage** an den Server sendet und auf eine Antwort wartet.  
Sobald neue Daten verf√ºgbar sind, antwortet der Server und der Client sendet eine neue Anfrage.  

üîπ **Wird verwendet, wenn WebSockets oder Server-Sent Events (SSE) nicht verf√ºgbar sind.**  

---

## **1. Funktionsweise von Long Polling**
1. Der **Client** sendet eine `GET`-Anfrage an den **Server**.  
2. Der **Server** h√§lt die Verbindung offen, bis neue Daten verf√ºgbar sind.  
3. Sobald neue Daten vorhanden sind, antwortet der **Server** und schlie√üt die Verbindung.  
4. Der **Client** sendet sofort eine neue Anfrage (wiederholte Anfragen erzeugen ein "Live-Update").  

---

## **2. Beispiel: Long Polling mit `fetch()`**
```javascript
function longPolling() {
  fetch("https://example.com/api/updates")
    .then(response => response.json())
    .then(data => {
      console.log("Neue Daten:", data);
      longPolling(); // Neue Anfrage nach Antwort starten
    })
    .catch(error => {
      console.error("Fehler:", error);
      setTimeout(longPolling, 5000); // Bei Fehler nach 5 Sekunden erneut versuchen
    });
}

longPolling(); // Startet den Long Polling-Prozess
```
‚úÖ **Server sendet Daten nur, wenn neue Informationen verf√ºgbar sind**  
‚úÖ **Direkt nach einer Antwort startet eine neue Anfrage**  

---

## **3. Beispiel: Long Polling mit `async/await`**
```javascript
async function longPolling() {
  try {
    const response = await fetch("https://example.com/api/updates");
    const data = await response.json();
    console.log("Neue Daten:", data);
  } catch (error) {
    console.error("Fehler:", error);
  } finally {
    longPolling(); // Wiederholen
  }
}

longPolling();
```
‚úÖ **`async/await` verbessert die Lesbarkeit**  
‚úÖ **Fehlertolerant durch `try/catch`**  

---

## **4. Beispiel: Long Polling mit `XMLHttpRequest` (√§ltere Methode)**
```javascript
function longPolling() {
  const xhr = new XMLHttpRequest();
  xhr.open("GET", "https://example.com/api/updates", true);

  xhr.onload = function () {
    if (xhr.status === 200) {
      console.log("Neue Daten:", JSON.parse(xhr.responseText));
    }
    longPolling(); // Erneute Anfrage nach Antwort
  };

  xhr.onerror = function () {
    console.error("Fehler bei der Anfrage");
    setTimeout(longPolling, 5000); // Nach 5 Sekunden erneut versuchen
  };

  xhr.send();
}

longPolling();
```
‚úÖ **Funktioniert auch in √§lteren Browsern**  
‚ùå **Komplexer als `fetch()` oder `async/await`**  

---

## **5. Vergleich: Long Polling vs. Alternativen**
| Technik | Beschreibung | Vorteile | Nachteile |
|---------|-------------|----------|-----------|
| **Long Polling** | Wiederholte `GET`-Anfragen f√ºr Echtzeit-Updates | Funktioniert √ºberall, kein WebSocket-Server n√∂tig | Hohe Serverlast |
| **WebSockets** | Permanente Zwei-Wege-Verbindung | Sehr schnell, geringe Serverlast | WebSocket-Server erforderlich |
| **Server-Sent Events (SSE)** | Nur Server ‚Üí Client-Nachrichten | Einfach zu implementieren | Nur Einweg-Kommunikation |
| **Short Polling** | Regelm√§√üige `GET`-Anfragen in Intervallen | Einfach umzusetzen | Verz√∂gerte Updates, h√∂here Last |

üîó [MDN-Dokumentation zu Long Polling](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/Polling)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

86. ### <a name="86"></a> Web Socket

### **WebSockets in JavaScript**  

**WebSockets** erm√∂glichen eine **bidirektionale (zweiwege) Echtzeit-Kommunikation** zwischen **Client** (Browser) und **Server** √ºber eine dauerhafte Verbindung.  
Im Gegensatz zu **HTTP**, das f√ºr **jeden Request eine neue Verbindung** √∂ffnet, bleibt die **WebSocket-Verbindung offen**, wodurch **schnellere und effizientere Kommunikation** m√∂glich ist.

---

## **1. WebSocket-Verbindung aufbauen**
```javascript
const socket = new WebSocket("wss://example.com/socket");

// Verbindung erfolgreich ge√∂ffnet
socket.onopen = () => {
  console.log("WebSocket-Verbindung hergestellt");
  socket.send("Hallo, Server!");
};

// Nachricht vom Server empfangen
socket.onmessage = (event) => {
  console.log("Nachricht vom Server:", event.data);
};

// Fehlerbehandlung
socket.onerror = (error) => {
  console.error("WebSocket-Fehler:", error);
};

// Verbindung geschlossen
socket.onclose = (event) => {
  console.log("WebSocket geschlossen:", event.reason);
};
```
‚úÖ **Sofortige Daten√ºbertragung nach Verbindungsaufbau**  
‚úÖ **Effizient f√ºr Chats, Echtzeitdaten (Finanzm√§rkte, Spiele, IoT, etc.)**  

---

## **2. Nachrichten an den Server senden**
```javascript
socket.send(JSON.stringify({ type: "message", text: "Hallo, Server!" }));
```
‚úÖ **Daten k√∂nnen als JSON-Objekte gesendet werden**  

---

## **3. Verbindung sicher schlie√üen**
```javascript
socket.close(1000, "Verbindung beendet");
```
üìå **WebSocket-Schlusscodes (Status-Codes):**
- `1000` ‚Üí **Normaler Verbindungsabbruch**
- `1001` ‚Üí **Client oder Server geht offline**
- `1006` ‚Üí **Verbindung wurde unerwartet getrennt**

---

## **4. WebSocket-Server mit Node.js (Beispiel)**
**üìå Server mit `ws`-Bibliothek erstellen**  
üìå **Installation:**
```bash
npm install ws
```

üìå **Node.js WebSocket-Server:**
```javascript
const WebSocket = require("ws");
const server = new WebSocket.Server({ port: 8080 });

server.on("connection", (ws) => {
  console.log("Neuer Client verbunden");

  ws.on("message", (message) => {
    console.log("Nachricht erhalten:", message);
    ws.send(`Server antwortet: ${message}`);
  });

  ws.on("close", () => {
    console.log("Client hat die Verbindung geschlossen");
  });
});
```
‚úÖ **Funktioniert mit jedem WebSocket-Client (Browser, Node.js, mobile Apps)**  

---

## **5. Vergleich: WebSockets vs. Alternativen**
| Technologie | Beschreibung | Vorteile | Nachteile |
|-------------|-------------|----------|-----------|
| **WebSockets** | Dauerhafte Echtzeit-Verbindung | Schnell, bidirektional, effizient | WebSocket-Server n√∂tig |
| **AJAX (Polling)** | Regelm√§√üige `GET`-Anfragen | Einfach zu implementieren | Hohe Serverlast, Verz√∂gerungen |
| **Long Polling** | Server h√§lt Verbindung offen | Bessere Echtzeit-Daten als AJAX | H√∂here Serverbelastung als WebSockets |
| **Server-Sent Events (SSE)** | Einweg-Stream Server ‚Üí Client | Einfach, weniger Overhead | Kein Client ‚Üí Server-Kanal |

---

### **Zusammenfassung**
- WebSockets bieten eine **bidirektionale** Echtzeitkommunikation.
- **Ideal f√ºr Chats, Live-Updates, Multiplayer-Spiele & Finanzm√§rkte**.
- **Alternative: SSE (nur Server ‚Üí Client) oder Long Polling (weniger effizient)**.

üîó [MDN-Dokumentation zu WebSockets](https://developer.mozilla.org/de/docs/Web/API/WebSockets_API)  
üîó [ws-Bibliothek f√ºr Node.js](https://github.com/websockets/ws)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

87. ### <a name="87"></a> Was sind Web Workers und wof√ºr braucht man sie?

### **Web Workers in JavaScript ‚Äì Hintergrundprozesse f√ºr bessere Performance**  

**Web Workers** sind **separate Threads**, die in JavaScript **unabh√§ngig vom Hauptthread** laufen.  
Sie erm√∂glichen die **Parallelverarbeitung**, ohne die Hauptseite zu blockieren.

---

## **1. Warum Web Workers?**  
üìå **JavaScript ist Single-Threaded** ‚Üí Langsame Operationen (z. B. schwere Berechnungen, API-Anfragen) k√∂nnen die **UI blockieren**.  
‚úÖ **Web Workers l√∂sen das Problem**, indem sie Rechenaufgaben in einem separaten Thread ausf√ºhren.  

**Beispiel: Ohne Web Workers (Blockierung der UI)**  
```javascript
console.log("Start");

// Blockierende Schleife (UI h√§ngt!)
for (let i = 0; i < 1e9; i++) {}

console.log("Ende");
```
‚ùå **Der Browser friert ein, weil JavaScript den Hauptthread blockiert.**  

---

## **2. Web Worker erstellen**
**üìå Web Workers werden in einer separaten Datei (`worker.js`) definiert.**  

üìå **Hauptthread (`main.js`):**
```javascript
const worker = new Worker("worker.js");

worker.onmessage = (event) => {
  console.log("Ergebnis vom Worker:", event.data);
};

worker.postMessage(10); // Sende Daten an den Worker
```
üìå **Worker-Thread (`worker.js`):**
```javascript
onmessage = function (event) {
  let zahl = event.data;
  let ergebnis = zahl * 2; // Beispiel: Berechnung
  postMessage(ergebnis); // Antwort zur√ºck an Hauptthread
};
```
‚úÖ **Hauptseite bleibt reaktionsf√§hig, w√§hrend der Worker arbeitet.**  

---

## **3. Daten zwischen Hauptthread & Worker senden**
### **3.1 Hauptthread ‚Üí Worker**
```javascript
worker.postMessage({ zahl: 5, text: "Hallo" });
```
‚úÖ **Daten als JSON-Objekt senden**  

### **3.2 Worker ‚Üí Hauptthread**
```javascript
postMessage("Fertig!");
```

---

## **4. Worker beenden**
```javascript
worker.terminate(); // Stoppt den Worker sofort
```
‚úÖ **Verhindert unn√∂tige CPU-Auslastung**  

---

## **5. Einschr√§nkungen von Web Workers**
- ‚ùå **Kein direkter Zugriff auf DOM (`document`, `window`, `alert()`)**  
- ‚ùå **M√ºssen in separaten Dateien (`worker.js`) gespeichert werden**  
- ‚úÖ **Kommunikation nur √ºber `postMessage()`**  

---

## **6. Beispiel: Aufwendige Berechnung mit Web Worker**
üìå **Hauptthread (`main.js`):**
```javascript
const worker = new Worker("worker.js");

worker.onmessage = (event) => {
  console.log("Faktorielle Berechnung:", event.data);
};

worker.postMessage(10);
```
üìå **Worker (`worker.js`):**
```javascript
onmessage = function (event) {
  let n = event.data;
  let ergebnis = 1;
  for (let i = 2; i <= n; i++) ergebnis *= i;
  postMessage(ergebnis);
};
```
‚úÖ **Hauptthread bleibt ungest√∂rt, w√§hrend der Worker rechnet.**  

---

## **7. `SharedWorker` (Ein Worker f√ºr mehrere Tabs)**
üìå **Standard-Workers k√∂nnen nur vom Ersteller genutzt werden. `SharedWorker` kann von mehreren Tabs einer Seite geteilt werden.**  

üìå **Shared Worker (sharedWorker.js):**
```javascript
onconnect = function (event) {
  const port = event.ports[0];

  port.onmessage = function (event) {
    port.postMessage("Empfangen: " + event.data);
  };
};
```
üìå **Hauptseite (`main.js`):**
```javascript
const sharedWorker = new SharedWorker("sharedWorker.js");

sharedWorker.port.onmessage = function (event) {
  console.log("Antwort vom Worker:", event.data);
};

sharedWorker.port.postMessage("Hallo Worker!");
```
‚úÖ **Mehrere Tabs k√∂nnen denselben Worker verwenden.**  

---

### **Zusammenfassung**
| Feature | Beschreibung |
|---------|-------------|
| **Web Worker** | F√ºhrt Berechnungen in einem separaten Thread aus |
| **postMessage()** | Kommunikation zwischen Worker & Hauptthread |
| **terminate()** | Beendet den Worker |
| **Kein Zugriff auf DOM** | `document`, `window`, `alert()` sind nicht verf√ºgbar |
| **Shared Worker** | Kann von mehreren Tabs genutzt werden |

üîó [MDN-Dokumentation zu Web Workers](https://developer.mozilla.org/de/docs/Web/API/Web_Workers_API)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

88. ### <a name="88"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

89. ### <a name="89"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

90. ### <a name="90"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

91. ### <a name="91"></a> Klassen (ES6)

### **Klassen (`class`) in JavaScript (ES6)**  

**Klassen** in JavaScript sind eine **ES6-Syntax** f√ºr die objektorientierte Programmierung (OOP). Sie sind eine **vereinfachte Schreibweise** f√ºr das Prototypensystem.

---

## **1. Grundlegende Klassendefinition**
```javascript
class Person {
  constructor(name, alter) {
    this.name = name;
    this.alter = alter;
  }

  // Methode
  vorstellen() {
    console.log(`Hallo, ich bin ${this.name} und ${this.alter} Jahre alt.`);
  }
}

// Instanz der Klasse erstellen
const max = new Person("Max", 30);
max.vorstellen();
```
‚úÖ **`constructor` wird beim Erstellen eines Objekts ausgef√ºhrt**  
‚úÖ **Methoden (`vorstellen()`) sind automatisch im `prototype` gespeichert**  

---

## **2. Klassenvererbung (`extends`, `super`)**
```javascript
class Mitarbeiter extends Person {
  constructor(name, alter, beruf) {
    super(name, alter); // Ruft den `constructor` der Elternklasse auf
    this.beruf = beruf;
  }

  vorstellen() {
    super.vorstellen(); // Ruft die Methode der Elternklasse auf
    console.log(`Ich arbeite als ${this.beruf}.`);
  }
}

const anna = new Mitarbeiter("Anna", 28, "Entwicklerin");
anna.vorstellen();
```
‚úÖ **`extends` ‚Üí Erbt von einer anderen Klasse**  
‚úÖ **`super()` ‚Üí Ruft den `constructor` der Elternklasse auf**  
‚úÖ **`super.method()` ‚Üí Ruft eine Methode der Elternklasse auf**  

---

## **3. Getter & Setter f√ºr Eigenschaften**
```javascript
class Auto {
  constructor(marke) {
    this._marke = marke; // Private Konvention (_)
  }

  get marke() {
    return this._marke.toUpperCase();
  }

  set marke(neueMarke) {
    this._marke = neueMarke;
  }
}

const meinAuto = new Auto("BMW");
console.log(meinAuto.marke); // "BMW"
meinAuto.marke = "Audi";
console.log(meinAuto.marke); // "AUDI"
```
‚úÖ **Getter (`get`) ‚Üí Erm√∂glicht eine abgeleitete Darstellung**  
‚úÖ **Setter (`set`) ‚Üí Erm√∂glicht Validierung oder Transformation von Daten**  

---

## **4. Statische Methoden & Eigenschaften**
```javascript
class Mathe {
  static addiere(a, b) {
    return a + b;
  }
}

console.log(Mathe.addiere(5, 3)); // 8
```
‚úÖ **`static` Methoden geh√∂ren zur Klasse, nicht zur Instanz**  

---

## **5. Private Eigenschaften & Methoden (`#`)**
üìå **Seit ES2020 k√∂nnen echte private Felder mit `#` definiert werden.**
```javascript
class Konto {
  #saldo = 0; // Privates Feld

  einzahlen(betrag) {
    this.#saldo += betrag;
  }

  get saldo() {
    return this.#saldo;
  }
}

const meinKonto = new Konto();
meinKonto.einzahlen(100);
console.log(meinKonto.saldo); // 100
// console.log(meinKonto.#saldo); // ‚ùå Fehler! Private Eigenschaft
```
‚úÖ **Private Felder sind wirklich nicht von au√üen zug√§nglich!**  
‚ùå **Nur in moderneren Browsern verf√ºgbar**  

---

## **6. Klassen als `Expressions`**
```javascript
const Auto = class {
  constructor(marke) {
    this.marke = marke;
  }
};

const bmw = new Auto("BMW");
console.log(bmw.marke); // "BMW"
```
‚úÖ **Funktioniert √§hnlich wie `function expressions` (`const foo = function() {}`)**  

---

## **7. `instanceof` ‚Äì Pr√ºfen, ob ein Objekt zu einer Klasse geh√∂rt**
```javascript
console.log(anna instanceof Person); // true
console.log(anna instanceof Mitarbeiter); // true
console.log(max instanceof Mitarbeiter); // false
```
‚úÖ **√úberpr√ºft die Zugeh√∂rigkeit eines Objekts zu einer Klasse**  

---

### **Zusammenfassung**
| Feature | Beschreibung |
|---------|-------------|
| **`class`** | Erstellt eine Klasse |
| **`constructor`** | Initialisiert Eigenschaften |
| **`extends`** | Vererbung von einer anderen Klasse |
| **`super()`** | Ruft Konstruktor/Methode der Elternklasse auf |
| **`get` / `set`** | Getter & Setter f√ºr Eigenschaften |
| **`static`** | Statische Methoden & Eigenschaften |
| **`#privat`** | Private Eigenschaften (ab ES2020) |

üîó [MDN-Dokumentation zu Klassen](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Classes)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

92. ### <a name="92"></a> Klassenvererbung, private und gesch√ºtzte Eigenschaften

### **Klassenvererbung, private und gesch√ºtzte Eigenschaften in JavaScript**  

In JavaScript erm√∂glicht **ES6-Klassenvererbung (`extends`)** das Wiederverwenden von Code durch **Vererbung**.  
Ab **ES2020** sind auch **private Eigenschaften (`#`)** verf√ºgbar.

---

## **1. Klassenvererbung (`extends`, `super`)**
Eine Klasse kann Eigenschaften und Methoden von einer anderen Klasse erben.

```javascript
class Person {
  constructor(name, alter) {
    this.name = name;
    this.alter = alter;
  }

  vorstellen() {
    console.log(`Hallo, ich bin ${this.name} und ${this.alter} Jahre alt.`);
  }
}

// Vererbung mit `extends`
class Mitarbeiter extends Person {
  constructor(name, alter, beruf) {
    super(name, alter); // Ruft den Konstruktor der Elternklasse auf
    this.beruf = beruf;
  }

  vorstellen() {
    super.vorstellen(); // Ruft die Methode der Elternklasse auf
    console.log(`Ich arbeite als ${this.beruf}.`);
  }
}

const anna = new Mitarbeiter("Anna", 28, "Entwicklerin");
anna.vorstellen();
```
‚úÖ **`extends`** ‚Üí Erbt von einer Elternklasse  
‚úÖ **`super()`** ‚Üí Ruft den Konstruktor der Elternklasse auf  
‚úÖ **`super.methode()`** ‚Üí Ruft eine Methode der Elternklasse auf  

---

## **2. Private Eigenschaften (`#`) ‚Äì ES2020**
üìå **Private Eigenschaften sind nur innerhalb der Klasse sichtbar.**  

```javascript
class Konto {
  #saldo = 0; // Private Eigenschaft mit `#`

  einzahlen(betrag) {
    if (betrag > 0) this.#saldo += betrag;
  }

  get saldo() {
    return this.#saldo;
  }
}

const meinKonto = new Konto();
meinKonto.einzahlen(100);
console.log(meinKonto.saldo); // 100
// console.log(meinKonto.#saldo); // ‚ùå Fehler! Nicht von au√üen zug√§nglich
```
‚úÖ **`#privat` ‚Üí Kann nicht au√üerhalb der Klasse ge√§ndert oder gelesen werden**  
‚ùå **Nicht in √§lteren Browsern unterst√ºtzt**  

---

## **3. Gesch√ºtzte Eigenschaften (Konvention `_`)**
üìå **JavaScript hat keine echte `protected`-Eigenschaft, aber `_` wird als Konvention genutzt.**  
```javascript
class Auto {
  constructor(marke) {
    this._marke = marke; // "Gesch√ºtzt" durch Konvention
  }
}

class Sportwagen extends Auto {
  zeigeMarke() {
    console.log(`Marke: ${this._marke}`); // Zugriff in der Unterklasse m√∂glich
  }
}

const porsche = new Sportwagen("Porsche");
porsche.zeigeMarke(); // "Marke: Porsche"
console.log(porsche._marke); // ‚ùå Konvention sagt: Nicht au√üerhalb der Klasse nutzen!
```
‚úÖ **Zugriff in der Unterklasse erlaubt**  
‚ùå **Keine echte Zugriffsbeschr√§nkung**  

---

## **4. Statische Methoden & Eigenschaften (`static`)**
üìå **Statische Methoden und Eigenschaften geh√∂ren zur Klasse, nicht zur Instanz.**  
```javascript
class Mathe {
  static addiere(a, b) {
    return a + b;
  }
}

console.log(Mathe.addiere(5, 3)); // 8
```
‚úÖ **Kann direkt √ºber `Klasse.method()` aufgerufen werden**  
‚ùå **Nicht von Instanzen zug√§nglich**  

---

## **5. `instanceof` ‚Äì Pr√ºfen, ob ein Objekt zu einer Klasse geh√∂rt**
```javascript
console.log(anna instanceof Person); // true
console.log(anna instanceof Mitarbeiter); // true
console.log(anna instanceof Array); // false
```
‚úÖ **√úberpr√ºft die Zugeh√∂rigkeit eines Objekts zu einer Klasse**  

---

### **Zusammenfassung**
| Feature | Beschreibung |
|---------|-------------|
| **`extends`** | Vererbung von einer anderen Klasse |
| **`super()`** | Ruft Konstruktor der Elternklasse auf |
| **`#privat`** | Echte private Eigenschaften (ab ES2020) |
| **`_gesch√ºtzt`** | Konvention f√ºr gesch√ºtzte Eigenschaften |
| **`static`** | Statische Methoden/Eigenschaften |
| **`instanceof`** | Pr√ºft, ob ein Objekt zu einer Klasse geh√∂rt |

üîó [MDN-Dokumentation zu Klassen](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Classes)  
üîó [MDN-Dokumentation zu privaten Eigenschaften](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Classes/Private_class_fields)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

93. ### <a name="93"></a> Kapselung (Encapsulation)

### **Kapselung (Encapsulation) in JavaScript**  

**Kapselung** bedeutet, dass **Daten innerhalb eines Objekts gesch√ºtzt** werden, sodass sie nicht direkt von au√üen ge√§ndert werden k√∂nnen.  
In JavaScript kann Kapselung mit **private Eigenschaften (`#`), Gettern/Settern und Closures** erreicht werden.

---

## **1. Kapselung mit privaten Eigenschaften (`#`) ‚Äì ES2020**
üìå **Private Eigenschaften sind nur innerhalb der Klasse sichtbar.**  

```javascript
class Konto {
  #saldo = 0; // Private Eigenschaft

  einzahlen(betrag) {
    if (betrag > 0) this.#saldo += betrag;
  }

  get saldo() {
    return this.#saldo;
  }
}

const meinKonto = new Konto();
meinKonto.einzahlen(100);
console.log(meinKonto.saldo); // ‚úÖ 100
// console.log(meinKonto.#saldo); // ‚ùå Fehler! Nicht von au√üen zug√§nglich
```
‚úÖ **Echte Privatsph√§re: `#saldo` ist von au√üen nicht erreichbar**  
‚ùå **Nicht in √§lteren Browsern verf√ºgbar**  

---

## **2. Kapselung mit Getter & Setter**
üìå **Getter & Setter erm√∂glichen kontrollierten Zugriff auf Eigenschaften.**  
```javascript
class Auto {
  constructor(marke) {
    this._marke = marke; // Gesch√ºtzt durch Konvention "_"
  }

  get marke() {
    return this._marke.toUpperCase();
  }

  set marke(neueMarke) {
    if (neueMarke.length > 0) this._marke = neueMarke;
  }
}

const bmw = new Auto("BMW");
console.log(bmw.marke); // ‚úÖ "BMW"
bmw.marke = "Audi";
console.log(bmw.marke); // ‚úÖ "AUDI"
```
‚úÖ **Getter erm√∂glicht formatierte Ausgabe**  
‚úÖ **Setter verhindert ung√ºltige Werte**  

---

## **3. Kapselung mit Closures (IIFE) ‚Äì Alternative ohne Klassen**
üìå **Privatsph√§re kann auch mit Closures erreicht werden.**  
```javascript
const konto = (function () {
  let saldo = 0; // Private Variable

  return {
    einzahlen(betrag) {
      if (betrag > 0) saldo += betrag;
    },
    getSaldo() {
      return saldo;
    }
  };
})();

konto.einzahlen(100);
console.log(konto.getSaldo()); // ‚úÖ 100
// console.log(konto.saldo); // ‚ùå Fehler! saldo ist nicht zug√§nglich
```
‚úÖ **Daten sind vollst√§ndig gekapselt**  
‚ùå **Kein Zugriff von Unterklassen m√∂glich**  

---

## **4. Gesch√ºtzte Eigenschaften (`_`) ‚Äì Konvention**
üìå **In JavaScript gibt es kein echtes `protected`, daher wird `_` als Konvention genutzt.**  
```javascript
class Fahrzeug {
  constructor(typ) {
    this._typ = typ; // "Gesch√ºtzt" durch Konvention
  }
}

class Auto extends Fahrzeug {
  zeigeTyp() {
    console.log(`Fahrzeugtyp: ${this._typ}`); // Zugriff in Unterklasse erlaubt
  }
}

const porsche = new Auto("Sportwagen");
porsche.zeigeTyp(); // ‚úÖ "Fahrzeugtyp: Sportwagen"
console.log(porsche._typ); // ‚ùå Konvention sagt: Nicht von au√üen nutzen!
```
‚úÖ **Kann in Unterklassen genutzt werden**  
‚ùå **Nicht wirklich gesch√ºtzt ‚Äì `porsche._typ` ist von au√üen zug√§nglich**  

---

### **Zusammenfassung**
| Methode | Beschreibung | Schutzstufe |
|---------|-------------|-------------|
| **`#privat`** | Echte private Eigenschaften (ab ES2020) | üîí Vollst√§ndig privat |
| **Getter/Setter** | Kontrollierter Zugriff auf Eigenschaften | üü° Halb-privat |
| **Closures (IIFE)** | Private Variablen ohne Klassen | üîí Vollst√§ndig privat |
| **`_gesch√ºtzt`** | Nur Konvention f√ºr "gesch√ºtzte" Felder | ‚ö†Ô∏è Kein echter Schutz |

üîó [MDN-Dokumentation zu privaten Eigenschaften](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Classes/Private_class_fields)  
üîó [MDN-Dokumentation zu Getter & Setter](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Functions/get)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

94. ### <a name="94"></a> Was ist funktionale Programmierung? Grundlagen (First-Class-Funktionen, Higher-Order-Funktionen, Pure Functions, Immutability, Lazy Evaluation usw.)

### **Funktionale Programmierung in JavaScript ‚Äì Grundlagen**  

**Funktionale Programmierung (FP)** ist ein **paradigmatischer Ansatz**, der Programme aus **reinen Funktionen** ohne ver√§nderbare Zust√§nde (`immutability`) und Nebenwirkungen (`side effects`) aufbaut.  

---

## **1. Grundlagen der funktionalen Programmierung**
üîπ **First-Class-Funktionen** ‚Äì Funktionen sind **Werte**, die gespeichert, √ºbergeben und zur√ºckgegeben werden k√∂nnen.  
üîπ **Higher-Order-Funktionen** ‚Äì Funktionen, die andere Funktionen als Parameter oder R√ºckgabewert haben.  
üîπ **Pure Functions** ‚Äì Funktionen, die nur vom Input abh√§ngen und **keine Nebenwirkungen** haben.  
üîπ **Immutability** ‚Äì Daten werden **nicht ver√§ndert**, sondern neue Kopien erstellt.  
üîπ **Lazy Evaluation** ‚Äì Berechnungen werden nur ausgef√ºhrt, wenn sie ben√∂tigt werden.  

---

## **2. First-Class-Funktionen**
üìå **In JavaScript sind Funktionen "first-class citizens" ‚Äì sie k√∂nnen wie Variablen behandelt werden.**  

```javascript
const begruessung = function(name) {
  return `Hallo, ${name}!`;
};

console.log(begruessung("Max")); // ‚úÖ "Hallo, Max!"
```
‚úÖ **Funktionen k√∂nnen in Variablen gespeichert und als Werte genutzt werden.**  

---

## **3. Higher-Order-Funktionen (HOF)**
üìå **Funktionen, die andere Funktionen als Argumente nehmen oder zur√ºckgeben.**  

```javascript
function ausf√ºhren(operation, a, b) {
  return operation(a, b);
}

const addiere = (x, y) => x + y;
const multiplizieren = (x, y) => x * y;

console.log(ausf√ºhren(addiere, 3, 4)); // ‚úÖ 7
console.log(ausf√ºhren(multiplizieren, 3, 4)); // ‚úÖ 12
```
‚úÖ **Macht den Code flexibler und wiederverwendbar.**  

---

## **4. Pure Functions (Reine Funktionen)**
üìå **Eine Funktion ist "rein", wenn sie:**
- Nur von **ihren Parametern** abh√§ngt.
- **Keine Seiteneffekte** (`side effects`) erzeugt.
- Immer **dieselbe Ausgabe** f√ºr denselben Input liefert.

‚ùå **Nicht rein (ver√§ndert externe Variable)**  
```javascript
let saldo = 100;
function abheben(betrag) {
  saldo -= betrag; // ‚ùå Nebenwirkung (Mutation)
  return saldo;
}
```
‚úÖ **Reine Funktion (Keine externe Ver√§nderung)**  
```javascript
function neuesSaldo(saldo, betrag) {
  return saldo - betrag;
}
console.log(neuesSaldo(100, 20)); // ‚úÖ 80
console.log(neuesSaldo(100, 20)); // ‚úÖ 80 (Immer gleiche Ausgabe)
```
‚úÖ **Erleichtert Debugging & macht Code vorhersehbar.**  

---

## **5. Immutability (Unver√§nderlichkeit)**
üìå **In funktionaler Programmierung werden Objekte nicht ver√§ndert, sondern neue Kopien erstellt.**  

‚ùå **Mutation (ver√§ndert das Original-Array)**  
```javascript
const zahlen = [1, 2, 3];
zahlen.push(4); // ‚ùå √Ñndert das Original-Array
console.log(zahlen); // [1, 2, 3, 4]
```
‚úÖ **Unver√§nderlichkeit durch `map()`**  
```javascript
const neueZahlen = [...zahlen, 4]; // ‚úÖ Erstellt neue Kopie
console.log(neueZahlen); // [1, 2, 3, 4]
```
‚úÖ **Daten bleiben unver√§ndert, sicher & vorhersehbar.**  

---

## **6. Lazy Evaluation (Faule Auswertung)**
üìå **Funktionen werden erst ausgef√ºhrt, wenn das Ergebnis wirklich ben√∂tigt wird.**  

```javascript
function generiereZahlen() {
  console.log("Berechnung l√§uft...");
  return [1, 2, 3, 4, 5];
}

const zahlen = generiereZahlen; // ‚úÖ Funktion gespeichert, aber nicht ausgef√ºhrt!
console.log(zahlen()); // "Berechnung l√§uft..." + [1, 2, 3, 4, 5]
```
‚úÖ **Vermeidet unn√∂tige Berechnungen.**  

---

## **7. Funktionale Array-Methoden (`map()`, `filter()`, `reduce()`)**
üìå **JavaScript bietet viele Funktionen, um Daten funktional zu transformieren.**  

### **7.1 `map()` ‚Äì Jedes Element transformieren**
```javascript
const zahlen = [1, 2, 3];
const verdoppelt = zahlen.map((x) => x * 2);
console.log(verdoppelt); // ‚úÖ [2, 4, 6]
```
‚úÖ **Erstellt eine neue Kopie der Daten.**  

---

### **7.2 `filter()` ‚Äì Elemente herausfiltern**
```javascript
const zahlen = [1, 2, 3, 4, 5];
const gerade = zahlen.filter((x) => x % 2 === 0);
console.log(gerade); // ‚úÖ [2, 4]
```
‚úÖ **Beh√§lt nur Elemente, die die Bedingung erf√ºllen.**  

---

### **7.3 `reduce()` ‚Äì Werte zusammenfassen**
```javascript
const zahlen = [1, 2, 3, 4];
const summe = zahlen.reduce((acc, x) => acc + x, 0);
console.log(summe); // ‚úÖ 10
```
‚úÖ **Funktionale Alternative zu Schleifen.**  

---

### **Zusammenfassung**
| Konzept | Beschreibung |
|---------|-------------|
| **First-Class-Funktionen** | Funktionen k√∂nnen als Werte behandelt werden |
| **Higher-Order-Funktionen** | Funktionen, die andere Funktionen als Argumente oder R√ºckgabewerte haben |
| **Pure Functions** | Funktionen ohne Seiteneffekte, die immer denselben Output f√ºr denselben Input liefern |
| **Immutability** | Daten werden nicht ver√§ndert, sondern neue Kopien erstellt |
| **Lazy Evaluation** | Berechnungen werden nur ausgef√ºhrt, wenn sie ben√∂tigt werden |
| **`map()`, `filter()`, `reduce()`** | Funktionale Methoden zur Transformation von Arrays |

üîó [MDN-Dokumentation zu funktionaler Programmierung](https://developer.mozilla.org/en-US/docs/Glossary/Functional_programming)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

95. ### <a name="95"></a> Regul√§re Ausdr√ºcke (RegExp)

### **Regul√§re Ausdr√ºcke (`RegExp`) in JavaScript**  

Regul√§re Ausdr√ºcke (**Regular Expressions, RegExp**) sind **Muster**, um **Texte zu durchsuchen, zu validieren oder zu ersetzen**.  

---

## **1. Regul√§ren Ausdruck erstellen**
### **1.1 Mit Schr√§gstrichen (`/regex/`)**
```javascript
const regex = /hallo/;
console.log(regex.test("hallo Welt")); // ‚úÖ true
console.log(regex.test("Hallo Welt")); // ‚ùå false (Gro√ü-/Kleinschreibung beachtet)
```
‚úÖ **Direkte Schreibweise**  

### **1.2 Mit `RegExp`-Konstruktor**
```javascript
const regex = new RegExp("hallo", "i"); // "i" ignoriert Gro√ü-/Kleinschreibung
console.log(regex.test("Hallo Welt")); // ‚úÖ true
```
‚úÖ **Dynamische Muster m√∂glich (`new RegExp(variable)`)**  

---

## **2. Flags (`/pattern/flags`)**
| Flag | Bedeutung |
|------|-----------|
| **`g`** | Global ‚Äì Alle Vorkommen suchen |
| **`i`** | Case-insensitive ‚Äì Gro√ü-/Kleinschreibung ignorieren |
| **`m`** | Multiline ‚Äì Mehrzeilenmodus |
| **`s`** | Dotall ‚Äì `.` erfasst auch Zeilenumbr√ºche |
| **`u`** | Unicode-Unterst√ºtzung |
| **`y`** | Sticky ‚Äì Sucht genau ab aktueller Position |

```javascript
const regex = /hallo/gi;
console.log("Hallo hallo hallo".match(regex)); // ‚úÖ ["Hallo", "hallo", "hallo"]
```

---

## **3. Zeichenklassen (`[...]`, `\d`, `\w`, `\s`)**
| Zeichen | Bedeutung | Beispiel |
|---------|-----------|----------|
| **`.`** | Jedes Zeichen au√üer Zeilenumbruch | `/h.llo/` ‚Üí `hallo`, `hxllo` |
| **`\d`** | Ziffer `[0-9]` | `/\d/` ‚Üí `5`, `9` |
| **`\w`** | Wortzeichen `[a-zA-Z0-9_]` | `/\w/` ‚Üí `a`, `9`, `_` |
| **`\s`** | Leerzeichen, Tab, Zeilenumbruch | `/\s/` ‚Üí `" "` |
| **`\b`** | Wortgrenze | `/\btest\b/` findet `test`, aber nicht `testing` |
| **`[xyz]`** | Eines dieser Zeichen | `/[aeiou]/` ‚Üí findet Vokale |

```javascript
console.log(/\d/.test("Haus 123")); // ‚úÖ true (Ziffer gefunden)
console.log(/\w+/.exec("Hallo Welt!")); // ‚úÖ ["Hallo"]
```

---

## **4. Quantoren (`+`, `*`, `?`, `{n,m}`)**
| Quantor | Bedeutung | Beispiel |
|---------|-----------|----------|
| **`+`** | Mindestens einmal | `/a+/` ‚Üí `aaa` in `"baa"` |
| **`*`** | Beliebig oft (auch 0-mal) | `/bo*l/` ‚Üí `bl`, `bol`, `bool` |
| **`?`** | Optional (0 oder 1-mal) | `/colou?r/` ‚Üí `color`, `colour` |
| **`{n}`** | Genau `n` Wiederholungen | `/\d{4}/` ‚Üí `2023` |
| **`{n,}`** | Mindestens `n`-mal | `/\d{2,}/` ‚Üí `12`, `123` |
| **`{n,m}`** | Zwischen `n` und `m`-mal | `/a{2,4}/` ‚Üí `aa`, `aaa`, `aaaa` |

```javascript
console.log(/a{2,}/.test("baaa")); // ‚úÖ true (mind. 2-mal `a`)
console.log(/bo*l/.test("bl")); // ‚úÖ true (kein `o` n√∂tig)
```

---

## **5. Gruppen (`()`, `|`, `?:`)**
| Zeichen | Bedeutung | Beispiel |
|---------|-----------|----------|
| **`(abc)`** | Gruppe | `/H(a|e)llo/` ‚Üí `Hallo`, `Hello` |
| **`(?:abc)`** | Nicht speichernde Gruppe | `/H(?:e|a)llo/` ‚Üí Kein Gruppenspeicher |
| **`|`** | ODER (Alternation) | `/rot|blau/` ‚Üí `rot`, `blau` |

```javascript
console.log(/(Hallo|Hi) Welt/.test("Hi Welt")); // ‚úÖ true
console.log(/(abc){2}/.test("abcabc")); // ‚úÖ true (2-mal `abc`)
```

---

## **6. Methoden mit `RegExp`**
| Methode | Beschreibung |
|---------|-------------|
| **`regex.test(str)`** | Gibt `true` zur√ºck, wenn √úbereinstimmung gefunden |
| **`regex.exec(str)`** | Gibt erstes Match als Array zur√ºck |
| **`str.match(regex)`** | Findet alle √úbereinstimmungen |
| **`str.replace(regex, ersatz)`** | Ersetzt √úbereinstimmungen |
| **`str.search(regex)`** | Gibt Index des ersten Treffers zur√ºck |

```javascript
const text = "Die Zahl 42 ist wichtig!";
console.log(/\d+/.test(text)); // ‚úÖ true
console.log(text.match(/\d+/)); // ‚úÖ ["42"]
console.log(text.replace(/\d+/, "100")); // ‚úÖ "Die Zahl 100 ist wichtig!"
```

---

## **7. Lookaheads & Lookbehinds**
| Lookaround | Beschreibung | Beispiel |
|------------|-------------|----------|
| **`(?=...)`** | Positiver Lookahead | `/\d(?=‚Ç¨)/` ‚Üí `5` in `5‚Ç¨` |
| **`(?!...)`** | Negativer Lookahead | `/\d(?!‚Ç¨)/` ‚Üí `5` in `5$` |
| **`(?<=...)`** | Positives Lookbehind | `/(?<=‚Ç¨)\d/` ‚Üí `5` in `‚Ç¨5` |
| **`(?<!...)`** | Negatives Lookbehind | `/(?<!‚Ç¨)\d/` ‚Üí `5` in `$5` |

```javascript
console.log(/(?<=‚Ç¨)\d+/.exec("‚Ç¨100")); // ‚úÖ ["100"]
console.log(/\d+(?=‚Ç¨)/.exec("50‚Ç¨")); // ‚úÖ ["50"]
```

---

### **Zusammenfassung**
| Konzept | Beispiel | Bedeutung |
|---------|---------|-----------|
| **Zeichenklassen** | `/\d/`, `/\w/` | `\d` = Zahl, `\w` = Wortzeichen |
| **Quantoren** | `/a+/`, `/b{2,4}/` | `+` mind. 1-mal, `{2,4}` 2-4-mal |
| **Gruppen** | `/(abc|def)/` | Sucht `abc` oder `def` |
| **Lookaheads** | `\d+(?=‚Ç¨)` | Zahl vor `‚Ç¨` |
| **Lookbehinds** | `(?<=‚Ç¨)\d+` | Zahl nach `‚Ç¨` |
| **Testen** | `/regex/.test("text")` | Gibt `true` oder `false` zur√ºck |

üîó [MDN-Dokumentation zu RegExp](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/RegExp)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

96. ### <a name="96"></a> JSON

### **JSON in JavaScript**  

**JSON (JavaScript Object Notation)** ist ein **leichtgewichtiges Datenformat**, das f√ºr **Daten√ºbertragung und Speicherung** genutzt wird.  
Es basiert auf **Schl√ºssel-Wert-Paaren** und ist in vielen Programmiersprachen verwendbar.

---

## **1. JSON-Struktur**
üìå **JSON ist √§hnlich zu JavaScript-Objekten, aber mit einigen Unterschieden:**
- **Schl√ºssel m√ºssen Strings sein** (`"key": "value"`)
- **Werte k√∂nnen sein:** `String`, `Number`, `Boolean`, `Array`, `Object`, `null`
- **Kein `undefined` oder Funktionen erlaubt**

```json
{
  "name": "Max",
  "alter": 30,
  "verheiratet": false,
  "kinder": ["Anna", "Tom"],
  "adresse": { "stadt": "Berlin", "plz": "10115" }
}
```

‚úÖ **JSON ist universell lesbar und speicherbar**  
‚ùå **Kommentare sind nicht erlaubt**  

---

## **2. JSON zu JavaScript-Objekt (`JSON.parse()`)**
üìå **Daten aus JSON in ein JavaScript-Objekt umwandeln.**  

```javascript
const jsonString = '{"name": "Max", "alter": 30}';
const person = JSON.parse(jsonString);
console.log(person.name); // ‚úÖ "Max"
```
‚úÖ **Wandelt JSON-Text in ein echtes JavaScript-Objekt um**  

---

## **3. JavaScript-Objekt zu JSON (`JSON.stringify()`)**
üìå **Ein JavaScript-Objekt in eine JSON-Zeichenkette umwandeln.**  

```javascript
const person = { name: "Max", alter: 30 };
const jsonString = JSON.stringify(person);
console.log(jsonString); // ‚úÖ '{"name":"Max","alter":30}'
```
‚úÖ **N√ºtzlich f√ºr API-Anfragen oder lokale Speicherung**  

---

## **4. Formatierte JSON-Ausgabe (`JSON.stringify(obj, null, 2)`)**
```javascript
const jsonString = JSON.stringify(person, null, 2);
console.log(jsonString);
```
**Ergebnis (lesbar formatiert):**
```json
{
  "name": "Max",
  "alter": 30
}
```
‚úÖ **Praktisch f√ºr Logging oder Debugging**  

---

## **5. JSON mit `fetch()` nutzen**
üìå **JSON-Daten von einer API abrufen und in ein JavaScript-Objekt umwandeln.**  

```javascript
fetch("https://jsonplaceholder.typicode.com/users/1")
  .then(response => response.json()) // ‚úÖ JSON-Text in Objekt umwandeln
  .then(data => console.log(data.name)) // ‚úÖ "Leanne Graham"
  .catch(error => console.error("Fehler:", error));
```
‚úÖ **JSON ist das Standardformat f√ºr API-Kommunikation**  

---

## **6. JSON-Validierung mit `try...catch`**
üìå **Falls JSON fehlerhaft ist, kann ein `try...catch`-Block Fehler abfangen.**  

```javascript
const jsonString = '{"name": "Max", "alter": }'; // ‚ùå Fehlerhafter JSON
try {
  const person = JSON.parse(jsonString);
  console.log(person);
} catch (error) {
  console.error("Ung√ºltiges JSON:", error.message);
}
```
‚úÖ **Verhindert Abst√ºrze durch fehlerhafte JSON-Daten**  

---

## **7. Unterschied: `JSON.parse()` vs. `eval()`**
```javascript
const jsonString = '{"name": "Max"}';

// Sicher:
const person = JSON.parse(jsonString);

// Unsicher:
const unsicher = eval("(" + jsonString + ")"); // ‚ùå Kann sch√§dlichen Code ausf√ºhren!
```
‚úÖ **`JSON.parse()` ist sicherer als `eval()`**  

---

### **Zusammenfassung**
| Methode | Beschreibung |
|---------|-------------|
| **`JSON.parse(jsonString)`** | Wandelt JSON-String in JavaScript-Objekt |
| **`JSON.stringify(obj)`** | Wandelt JavaScript-Objekt in JSON-String |
| **`JSON.stringify(obj, null, 2)`** | Formatiert JSON f√ºr bessere Lesbarkeit |
| **`fetch(url).then(res => res.json())`** | Holt JSON-Daten von einer API |
| **`try...catch` f√ºr `JSON.parse()`** | F√§ngt JSON-Fehler ab |

üîó [MDN-Dokumentation zu JSON](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/JSON)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

97. ### <a name="97"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

98. ### <a name="98"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

99. ### <a name="99"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

100. ### <a name="100"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

101. ### <a name="101"></a> Erstellen von Tabs in einem Projekt

### **Erstellen von Tabs in JavaScript**  

Tabs sind eine h√§ufige UI-Komponente, um Inhalte **in verschiedene Bereiche zu unterteilen**.  
Hier zeige ich eine **einfache, moderne** Methode, um Tabs mit **JavaScript, HTML und CSS** zu erstellen.

---

## **1. HTML-Grundstruktur**
```html
<div class="tabs">
  <button class="tab-button active" data-tab="1">Tab 1</button>
  <button class="tab-button" data-tab="2">Tab 2</button>
  <button class="tab-button" data-tab="3">Tab 3</button>
</div>

<div class="tab-content active" id="tab-1">
  <p>Inhalt f√ºr Tab 1</p>
</div>
<div class="tab-content" id="tab-2">
  <p>Inhalt f√ºr Tab 2</p>
</div>
<div class="tab-content" id="tab-3">
  <p>Inhalt f√ºr Tab 3</p>
</div>
```
‚úÖ **`data-tab="1"` f√ºr Zuordnung von Tabs zu Inhalten**  
‚úÖ **`active`-Klasse f√ºr das aktuell sichtbare Tab**  

---

## **2. CSS-Styling**
```css
.tabs {
  display: flex;
  gap: 10px;
}

.tab-button {
  padding: 10px;
  border: none;
  background: lightgray;
  cursor: pointer;
}

.tab-button.active {
  background: blue;
  color: white;
}

.tab-content {
  display: none;
  padding: 10px;
  border: 1px solid #ccc;
  margin-top: 10px;
}

.tab-content.active {
  display: block;
}
```
‚úÖ **Nur der aktive Tab ist sichtbar (`display: block`)**  
‚úÖ **Visuelle Hervorhebung des aktiven Buttons (`background: blue`)**  

---

## **3. JavaScript f√ºr die Tab-Funktionalit√§t**
```javascript
document.addEventListener("DOMContentLoaded", () => {
  const buttons = document.querySelectorAll(".tab-button");
  const contents = document.querySelectorAll(".tab-content");

  buttons.forEach((button) => {
    button.addEventListener("click", () => {
      // Entferne `active` von allen Buttons und Inhalten
      buttons.forEach((btn) => btn.classList.remove("active"));
      contents.forEach((content) => content.classList.remove("active"));

      // Aktiviere den geklickten Tab
      button.classList.add("active");
      document.getElementById(`tab-${button.dataset.tab}`).classList.add("active");
    });
  });
});
```
‚úÖ **Event-Listener f√ºr alle Buttons**  
‚úÖ **Wechselt die `active`-Klasse f√ºr den geklickten Tab**  
‚úÖ **Verwendet `dataset.tab`, um Inhalt zuzuordnen (`data-tab="1" ‚Üí id="tab-1"`)**  

---

### **Fazit**
‚úî **Einfach & modern mit JavaScript, HTML & CSS**  
‚úî **Ohne externe Bibliotheken**  
‚úî **Kann leicht erweitert oder gestylt werden**  

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

102. ### <a name="102"></a> Countdown-Timer

### **Countdown-Timer in JavaScript**  

Ein **Countdown-Timer** kann in vielen Anwendungen verwendet werden, z. B. f√ºr **Veranstaltungen, Werbeaktionen oder Online-Tests**.  
Hier zeige ich eine **dynamische L√∂sung mit JavaScript, HTML & CSS**.

---

## **1. HTML-Grundstruktur**
```html
<div class="timer">
  <h2>Countdown:</h2>
  <div id="countdown">
    <span id="days">00</span> Tage 
    <span id="hours">00</span> Stunden 
    <span id="minutes">00</span> Minuten 
    <span id="seconds">00</span> Sekunden
  </div>
</div>
```
‚úÖ **Zeigt Tage, Stunden, Minuten & Sekunden an**  

---

## **2. CSS-Styling (optional)**
```css
.timer {
  font-family: Arial, sans-serif;
  text-align: center;
  font-size: 24px;
  background: #222;
  color: white;
  padding: 20px;
  border-radius: 10px;
}

#countdown span {
  font-weight: bold;
  font-size: 30px;
  margin: 0 5px;
}
```
‚úÖ **Macht den Timer √ºbersichtlicher & modern**  

---

## **3. JavaScript f√ºr den Countdown-Timer**
```javascript
function startCountdown(endTime) {
  function updateTimer() {
    const now = new Date().getTime();
    const distance = endTime - now;

    if (distance <= 0) {
      clearInterval(timerInterval);
      document.getElementById("countdown").innerHTML = "Zeit abgelaufen!";
      return;
    }

    const days = Math.floor(distance / (1000 * 60 * 60 * 24));
    const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
    const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
    const seconds = Math.floor((distance % (1000 * 60)) / 1000);

    document.getElementById("days").textContent = days.toString().padStart(2, "0");
    document.getElementById("hours").textContent = hours.toString().padStart(2, "0");
    document.getElementById("minutes").textContent = minutes.toString().padStart(2, "0");
    document.getElementById("seconds").textContent = seconds.toString().padStart(2, "0");
  }

  updateTimer();
  const timerInterval = setInterval(updateTimer, 1000);
}

// Countdown auf ein zuk√ºnftiges Datum setzen (z. B. Neujahr)
const countdownDate = new Date("December 31, 2024 23:59:59").getTime();
startCountdown(countdownDate);
```

‚úÖ **Berechnet die verbleibende Zeit bis zum `countdownDate`**  
‚úÖ **Aktualisiert den Timer jede Sekunde (`setInterval`)**  
‚úÖ **Zeigt `"Zeit abgelaufen!"`, wenn die Zeit vorbei ist**  

---

### **Erweiterungen**
üîπ **Live-Anpassung des Enddatums?** ‚Äì √úber ein Eingabefeld setzen  
üîπ **Animationen hinzuf√ºgen?** ‚Äì `fade-in` Effekt f√ºr Sekunden  
üîπ **Ton abspielen?** ‚Äì Sound beim Ablauf des Countdowns  

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

103. ### <a name="103"></a> Modales Fenster

### **Modales Fenster (Modal) in JavaScript**  

Ein **modales Fenster** ist eine UI-Komponente, die sich √ºber den Inhalt legt und Benutzeraktionen erfordert (z. B. Best√§tigungen oder Formulareingaben).  
Hier erstellen wir ein **eigenes modales Fenster mit HTML, CSS & JavaScript**.

---

## **1. HTML-Struktur**
```html
<button id="openModal">√ñffne Modal</button>

<div id="modal" class="modal">
  <div class="modal-content">
    <span class="close">&times;</span>
    <h2>Modales Fenster</h2>
    <p>Dies ist ein Beispiel f√ºr ein modales Fenster.</p>
  </div>
</div>
```
‚úÖ **Das Modal ist anfangs unsichtbar und wird durch den Button ge√∂ffnet**  
‚úÖ **Das `span.close`-Element schlie√üt das Modal**  

---

## **2. CSS-Styling**
```css
/* Modal-Hintergrund */
.modal {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
  justify-content: center;
  align-items: center;
}

/* Modal-Inhalt */
.modal-content {
  background: white;
  padding: 20px;
  border-radius: 10px;
  width: 300px;
  text-align: center;
  position: relative;
}

/* Schlie√üen-Button */
.close {
  position: absolute;
  top: 10px;
  right: 15px;
  font-size: 24px;
  cursor: pointer;
}
```
‚úÖ **Das `modal` ist `display: none`, bis es aktiviert wird**  
‚úÖ **Der `close`-Button schlie√üt das Modal**  
‚úÖ **Hintergrund wird abgedunkelt (`rgba(0, 0, 0, 0.5)`)**  

---

## **3. JavaScript f√ºr Modal-Funktionalit√§t**
```javascript
document.addEventListener("DOMContentLoaded", () => {
  const modal = document.getElementById("modal");
  const openBtn = document.getElementById("openModal");
  const closeBtn = document.querySelector(".close");

  // √ñffne das Modal
  openBtn.addEventListener("click", () => {
    modal.style.display = "flex";
  });

  // Schlie√üe das Modal
  closeBtn.addEventListener("click", () => {
    modal.style.display = "none";
  });

  // Schlie√üen beim Klicken au√üerhalb des Modal-Inhalts
  window.addEventListener("click", (event) => {
    if (event.target === modal) {
      modal.style.display = "none";
    }
  });
});
```
‚úÖ **`click`-Event √∂ffnet & schlie√üt das Modal**  
‚úÖ **Modal wird geschlossen, wenn man auf den dunklen Hintergrund klickt**  
‚úÖ **`window.addEventListener("click", ...)` sorgt f√ºr benutzerfreundliches Schlie√üen**  

---

### **Erweiterungen**
üîπ **Animationen (`opacity`, `transform`) f√ºr sanfte √úberg√§nge hinzuf√ºgen**  
üîπ **Tastatursteuerung (`ESC`-Taste zum Schlie√üen)**  
üîπ **Mehrere Modals in einer Seite verwalten**  

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

104. ### <a name="104"></a> Slider

### **Bild-Slider (Karussell) in JavaScript**  

Ein **Slider** (Karussell) zeigt mehrere Bilder oder Inhalte **nacheinander**, oft mit Steuerungselementen (Pfeile, Punkte).  
Hier erstellen wir einen **einfachen und modernen Slider mit HTML, CSS & JavaScript**.

---

## **1. HTML-Struktur**
```html
<div class="slider">
  <div class="slider-container">
    <div class="slide active"><img src="image1.jpg" alt="Bild 1"></div>
    <div class="slide"><img src="image2.jpg" alt="Bild 2"></div>
    <div class="slide"><img src="image3.jpg" alt="Bild 3"></div>
  </div>

  <button id="prev" class="slider-btn">&#10094;</button>
  <button id="next" class="slider-btn">&#10095;</button>
</div>
```
‚úÖ **Bilder werden in `.slider-container` platziert**  
‚úÖ **Vorw√§rts-/R√ºckw√§rtsbuttons mit `id="prev"` & `id="next"`**  

---

## **2. CSS-Styling**
```css
.slider {
  position: relative;
  max-width: 600px;
  margin: auto;
  overflow: hidden;
}

.slider-container {
  display: flex;
  transition: transform 0.5s ease-in-out;
}

.slide {
  min-width: 100%;
  transition: opacity 0.5s;
}

img {
  width: 100%;
  display: block;
}

.slider-btn {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  background: rgba(0, 0, 0, 0.5);
  color: white;
  border: none;
  padding: 10px;
  cursor: pointer;
}

#prev { left: 10px; }
#next { right: 10px; }
```
‚úÖ **Slider bewegt sich mit `flexbox` & `transform: translateX()`**  
‚úÖ **Buttons √ºberlagern das Bild f√ºr Navigation**  

---

## **3. JavaScript f√ºr Slider-Funktionalit√§t**
```javascript
document.addEventListener("DOMContentLoaded", () => {
  const slides = document.querySelectorAll(".slide");
  let index = 0;

  function showSlide(i) {
    slides.forEach((slide, idx) => {
      slide.style.display = idx === i ? "block" : "none";
    });
  }

  document.getElementById("prev").addEventListener("click", () => {
    index = (index - 1 + slides.length) % slides.length;
    showSlide(index);
  });

  document.getElementById("next").addEventListener("click", () => {
    index = (index + 1) % slides.length;
    showSlide(index);
  });

  showSlide(index);
});
```
‚úÖ **Funktion `showSlide(i)` zeigt nur ein Bild gleichzeitig**  
‚úÖ **Navigation mit `prev` / `next`-Buttons**  
‚úÖ **Runde Logik: Letztes Bild ‚Üí Erstes Bild und umgekehrt**  

---

## **4. Automatischer Slider (`setInterval`)**
üìå **L√§sst den Slider alle 3 Sekunden automatisch wechseln**
```javascript
setInterval(() => {
  index = (index + 1) % slides.length;
  showSlide(index);
}, 3000);
```
‚úÖ **Verhindert, dass der Nutzer klicken muss**  

---

### **Erweiterungen**
üîπ **Mit `transform: translateX()` f√ºr fl√ºssige Animationen**  
üîπ **Pagination (Punkte unter den Bildern zum Wechseln)**  
üîπ **Swipe-Funktion f√ºr mobile Ger√§te (`touchstart`, `touchend`)**  

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

105. ### <a name="105"></a> Rechner

### **Einfacher Rechner in JavaScript**  

Hier erstellen wir einen **einfachen Taschenrechner** mit **HTML, CSS & JavaScript**, der die Grundrechenarten (`+`, `-`, `*`, `/`) unterst√ºtzt.

---

## **1. HTML-Struktur**
```html
<div class="calculator">
  <input type="text" id="display" disabled />
  <div class="buttons">
    <button class="btn" data-value="7">7</button>
    <button class="btn" data-value="8">8</button>
    <button class="btn" data-value="9">9</button>
    <button class="btn" data-value="/">√∑</button>

    <button class="btn" data-value="4">4</button>
    <button class="btn" data-value="5">5</button>
    <button class="btn" data-value="6">6</button>
    <button class="btn" data-value="*">√ó</button>

    <button class="btn" data-value="1">1</button>
    <button class="btn" data-value="2">2</button>
    <button class="btn" data-value="3">3</button>
    <button class="btn" data-value="-">‚àí</button>

    <button class="btn" data-value="0">0</button>
    <button class="btn" data-value=".">.</button>
    <button class="btn clear" data-value="C">C</button>
    <button class="btn" data-value="+">+</button>

    <button class="btn equal" data-value="=">=</button>
  </div>
</div>
```
‚úÖ **`<input>` als Display f√ºr die Berechnung**  
‚úÖ **Buttons f√ºr Zahlen & Operatoren mit `data-value`**  

---

## **2. CSS-Styling**
```css
.calculator {
  width: 250px;
  margin: 50px auto;
  padding: 10px;
  background: #222;
  color: white;
  border-radius: 10px;
  text-align: center;
}

#display {
  width: 100%;
  height: 50px;
  font-size: 24px;
  text-align: right;
  padding: 10px;
  border: none;
  background: #333;
  color: white;
}

.buttons {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 5px;
  margin-top: 10px;
}

.btn {
  padding: 15px;
  font-size: 20px;
  border: none;
  background: #444;
  color: white;
  cursor: pointer;
  border-radius: 5px;
}

.btn:hover {
  background: #666;
}

.equal {
  grid-column: span 4;
  background: #f39c12;
}

.clear {
  background: #e74c3c;
}
```
‚úÖ **Raster-Layout mit `grid-template-columns`**  
‚úÖ **Buttons mit `hover`-Effekt & Highlight-Farben f√ºr `=` & `C`**  

---

## **3. JavaScript f√ºr die Taschenrechner-Funktionalit√§t**
```javascript
document.addEventListener("DOMContentLoaded", () => {
  const display = document.getElementById("display");
  const buttons = document.querySelectorAll(".btn");

  buttons.forEach(button => {
    button.addEventListener("click", () => {
      const value = button.dataset.value;

      if (value === "=") {
        try {
          display.value = eval(display.value); // Berechnung
        } catch {
          display.value = "Fehler";
        }
      } else if (value === "C") {
        display.value = ""; // Reset
      } else {
        display.value += value; // Zahlen & Operatoren hinzuf√ºgen
      }
    });
  });
});
```
‚úÖ **`eval()` berechnet den Ausdruck (z. B. `3+5*2`)**  
‚úÖ **Fehlermeldung bei ung√ºltiger Eingabe (`try...catch`)**  
‚úÖ **`C` l√∂scht das Eingabefeld**  

---

## **4. Erweiterungen**
üîπ **Ersetze `eval()` mit `Function()` f√ºr mehr Sicherheit**  
üîπ **Unterst√ºtzung f√ºr `Backspace` (`‚Üê` l√∂schen letzte Zahl)**  
üîπ **Dunkler/heller Modus mit CSS-Variablen**  

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

106. ### <a name="106"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

107. ### <a name="107"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

108. ### <a name="108"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

109. ### <a name="109"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

110. ### <a name="110"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

111. ### <a name="111"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**   
