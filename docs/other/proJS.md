<a name="top"></a>

[ĞĞ° Ğ³Ğ»Ğ°Ğ²Ğ½ÑƒÑ](../README.md)

[ĞŸĞµÑ€ĞµĞ¹Ñ‚Ğ¸ Ğº Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑĞ°Ğ¼](#questions)

| â„–. | Ğ’Ğ¾Ğ¿Ñ€Ğ¾Ñ |
| --- | --------- |
|   | JavaScript Grundlagen |
|1 | [Klassifizierung von Datentypen, Typumwandlung](#1) |
|2 | [Unterschied zwischen null und undefined](#2) |
|3 | [Variablen let, const, var. Strikter Modus](#3) |
|4 | [Interaktion mit dem Benutzer: alert(), prompt(), confirm()](#4) |
|5 | [Interpolation (ES6)](#5) |
|6 | [Operatoren in JavaScript](#6) |
|7 | [Bedingungen](#7) |
|8 | [Schleifen, verschachtelte Schleifen, Labels](#8) |
|9 | [Hoisting (Hochheben von Variablen und Funktionen)](#9) |
|10 | [AusfÃ¼hrungskontext, Lexikalische Umgebung](#10) |
|11 | [TemporÃ¤re Totzone (Temporal Dead Zone)](#11) |
|12 | [typeof â€“ wie erkennt man den Typ eines Werts?](#12) |
|13 | [Warum haben primitive Datentypen Methoden? Was ist Autoboxing?](#13) |
|14 | [Garbage Collector in JavaScript](#14) |
|15 | [Unterschied zwischen == und ===](#15) |
|16 | [Primitive vs. Referenztypen](#16) |
|17 | [Symbol.iterator und Iterierbare Objekte](#17) |
|18 | [WeakRef und FinalizationRegistry](#18) |
|19 | [](#19) |
|20 | [](#20) |
|   | Funktionen und ihre Besonderheiten |
|21 | [Funktionen, Pfeilfunktionen, IIFE](#21) |
|22 | [Methoden zur Kontextbindung (call, apply, bind)](#22) |
|23 | [Closures (AbschlÃ¼sse)](#23) |
|24 | [Callback-Funktionen](#24) |
|25 | [Konstruktor-Funktionen](#25) |
|26 | [Aufrufkontext (this)](#26) |
|27 | [Getter und Setter (Objekteigenschaften)](#27) |
|28 | [Generatorfunktionen](#28) |
|29 | [Rekursion](#29) |
|30 | [Memoization](#30) |
|   | Arbeiten mit Objekten |
|31 | [Objekte, Destrukturierung von Objekten (ES6)](#31) |
|32 | [Methoden Object, Object.prototype](#32) |
|33 | [MÃ¶glichkeiten zur Objekterstellung](#33) |
|34 | [Kopieren von Objekten](#34) |
|35 | [Property Descriptors (Eigenschaftsbeschreibungen)](#35) |
|36 | [Private und geschÃ¼tzte Eigenschaften von Objekten](#36) |
|37 | [Prototypen, Prototypen-Kette](#37) |
|38 | [Object.create()](#38) |
|39 | [Unterschied zwischen klassischer und prototypischer Vererbung](#39) |
|40 | [](#40) |
|   | Arrays und Sammlungen |
|41 | [Arrays und Pseudo-Arrays, Array-Destrukturierung](#41) |
|42 | [Methoden Array, Array.prototype](#42) |
|43 | [Kopieren von Arrays](#43) |
|44 | [Map, Set, WeakSet, WeakMap](#44) |
|45 | [Live Collections (lebendige Sammlungen)](#45) |
|46 | [](#46) |
|47 | [](#47) |
|48 | [](#48) |
|49 | [](#49) |
|50 | [](#50) |
|   | Moderne JavaScript-Funktionen |
|51 | [Spread-Operator (ES6-ES9)](#51) |
|52 | [Rest-Operator und Standardparameter (ES6)](#52) |
|53 | [Symbol](#53) |
|54 | [BigInt](#54) |
|55 | [Module import/export (ES6) & CommonJS](#55) |
|56 | [Proxy und Reflect](#56) |
|57 | [](#57) |
|58 | [](#58) |
|59 | [](#59) |
|60 | [](#60) |
|   | Ereignisse und DOM-Manipulation |
|61 | [Ereignisse und ihre Handler](#61) |
|62 | [Ereignis-Bubbling (event bubbling)](#62) |
|63 | [Ereignis-Delegation](#63) |
|64 | [Unterschied zwischen load und DOMContentLoaded](#64) |
|65 | [Elemente von der Seite abrufen](#65) |
|66 | [Methoden zum Abrufen von DOM-Elementen in JavaScript](#66) |
|67 | [Navigation durch DOM-Elemente](#67) |
|68 | [classList, className und Ereignisdelegation](#68) |
|69 | [Manipulation von Seitenelementen](#69) |
|70 | [Dokument- und Fensterparameter sowie deren Nutzung](#70) |
|71 | [Web Animations API](#71) |
|72 | [requestAnimationFrame](#72) |
|73 | [Debouncing und Throttling](#73) |
|74 | [IntersectionObserver API](#74) |
|75 | [Unterschied zwischen innerHTML, textContent und innerText](#75) |
|   | AsynchronitÃ¤t und Serverkommunikation |
|76 | [setTimeout und setInterval, Besonderheiten](#76) |
|77 | [AJAX und XMLHttpRequest](#77) |
|78 | [Promise (ES6)](#78) |
|79 | [Fetch API](#79) |
|80 | [Async/Await (ES8)](#80) |
|81 | [try...catch, throw-Anweisung](#81) |
|82 | [Axios-Bibliothek](#82) |
|83 | [Event Loop, synchrone und asynchrone Operationen](#83) |
|84 | [MÃ¶glichkeiten zum Senden von Serveranfragen](#84) |
|85 | [Long Polling (Langes Abfragen)](#85) |
|86 | [Web Socket](#86) |
|87 | [Was sind Web Workers und wofÃ¼r braucht man sie?](#87) |
|88 | [Microtasks vs. Macrotasks](#88) |
|89 | [](#89) |
|90 | [](#90) |
|   | Fortgeschrittene Themen |
|91 | [Klassen (ES6)](#91) |
|92 | [Klassenvererbung, private und geschÃ¼tzte Eigenschaften](#92) |
|93 | [Kapselung (Encapsulation)](#93) |
|94 | [Was ist funktionale Programmierung? Grundlagen (First-Class-Funktionen, Higher-Order-Funktionen, Pure Functions, Immutability, Lazy Evaluation usw.)](#94) |
|95 | [RegulÃ¤re AusdrÃ¼cke (RegExp)](#95) |
|96 | [JSON](#96) |
|97 | [Design-Patterns in JavaScript (Singleton, Factory, Observer, etc.)](#97) |
|98 | [](#98) |
|99 | [](#99) |
|100 | [](#100) |
|   | Praktische Aufgaben |
|101 | [Erstellen von Tabs in einem Projekt](#101) |
|102 | [Countdown-Timer](#102) |
|103 | [Modales Fenster](#103) |
|104 | [Slider](#104) |
|105 | [Rechner](#105) |
|106 | [](#106) |
|107 | [](#107) |
|108 | [](#108) |
|109 | [](#109) |
|110 | [](#110) |



<a name="questions"></a>

## JavaScript Grundlagen

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**
  
1. ### <a name="1"></a> Klassifizierung von Datentypen, Typumwandlung

### **Datentypen in JavaScript**  

In JavaScript gibt es **primitive Datentypen** und **Referenztypen**.  

---

## **1. Primitive Datentypen (Werte werden direkt gespeichert)**  
Primitive Datentypen sind **immutable** (unverÃ¤nderlich) und speichern Werte direkt im Speicher.

| Datentyp   | Beschreibung | Beispiel |
|------------|-------------|-----------|
| **`string`** | Zeichenkette | `"Hallo"`, `'Test'`, `` `Template` `` |
| **`number`** | Zahlen (Ganzzahlen, Dezimal, `NaN`, `Infinity`) | `42`, `3.14`, `NaN`, `Infinity` |
| **`bigint`** | Sehr groÃŸe Ganzzahlen | `123456789012345678901234567890n` |
| **`boolean`** | Wahrheitswerte | `true`, `false` |
| **`undefined`** | Variable wurde deklariert, aber nicht zugewiesen | `let x; console.log(x); // undefined` |
| **`null`** | Bewusste "leere" Variable | `let y = null;` |
| **`symbol`** | Einzigartige, unverÃ¤nderliche Identifikatoren | `let id = Symbol("id");` |

```js
let name = "Max"; // string
let alter = 25; // number
let isStudent = true; // boolean
let nichts = null; // null
let unbestimmt; // undefined
let groÃŸeZahl = 123456789012345678901n; // bigint
let uniqueKey = Symbol("key"); // symbol
```

---

## **2. Referenztypen (Speichern Verweise auf Objekte im Speicher)**
Referenztypen speichern **Referenzen** auf Speicherorte, nicht die Werte direkt.

| Datentyp   | Beschreibung | Beispiel |
|------------|-------------|-----------|
| **`object`** | Sammlungen von Werten als Key-Value-Paare | `{name: "Max", alter: 25}` |
| **`array`** | Listen von Werten | `[1, 2, 3, "Test"]` |
| **`function`** | Funktionen sind Objekte | `function add(a, b) { return a + b; }` |
| **`date`** | Datum und Zeit | `new Date()` |
| **`RegExp`** | RegulÃ¤re AusdrÃ¼cke | `/abc/i` |

```js
let person = { name: "Max", alter: 25 }; // Objekt
let zahlen = [1, 2, 3, 4]; // Array
function sagHallo() { console.log("Hallo!"); } // Funktion
let heute = new Date(); // Datum
let regex = /abc/i; // RegulÃ¤rer Ausdruck
```

---

## **3. Unterschiede zwischen Primitiven und Referenztypen**
| Eigenschaft | Primitive Typen | Referenztypen |
|------------|----------------|--------------|
| Speicherort | Direkt im Stack gespeichert | Verweis auf Speicheradresse im Heap |
| Vergleich | Vergleicht Werte (`===` und `==` gleich) | Vergleicht Speicherreferenzen (`{}` !== `{}`) |
| VerÃ¤nderbarkeit | **Immutable** (Wert kann nicht direkt geÃ¤ndert werden) | **Mutable** (Werte innerhalb des Objekts/Arrays kÃ¶nnen geÃ¤ndert werden) |

```js
let a = 5;
let b = a;
b = 10;
console.log(a); // 5 (unverÃ¤ndert)

let obj1 = { name: "Max" };
let obj2 = obj1; // Referenz auf dasselbe Objekt
obj2.name = "Anna";
console.log(obj1.name); // "Anna" (beide verweisen auf dasselbe Objekt)
```

---

## **4. SonderfÃ¤lle**
### **Falsy und Truthy Werte**
#### **Falsy-Werte (`Boolean(wert) â†’ false`)**
Diese Werte werden als `false` interpretiert:
```js
false, 0, "", null, undefined, NaN
```

#### **Truthy-Werte (`Boolean(wert) â†’ true`)**
Alle anderen Werte sind `true`, z. B.:
```js
"0", "false", [], {}, function() {}, Infinity
```

```js
console.log(Boolean(0)); // false
console.log(Boolean("")); // false
console.log(Boolean([])); // true (leeres Array ist truthy)
console.log(Boolean({})); // true (leeres Objekt ist truthy)
```

---

## **5. Dynamische Typisierung in JavaScript**
JavaScript ist eine **dynamisch typisierte** Sprache, d. h., eine Variable kann den Typ zur Laufzeit Ã¤ndern:
```js
let x = "Hallo"; // String
x = 42; // Jetzt eine Zahl
x = true; // Jetzt ein Boolean
console.log(x); // true
```

---

### **Zusammenfassung**
âœ… **Primitive Typen** speichern Werte direkt und sind immutable.  
âœ… **Referenztypen** speichern Verweise auf Objekte und sind verÃ¤nderbar.  
âœ… **Vergleich von Referenztypen** erfolgt Ã¼ber Speicherreferenzen.  
âœ… **Falsy-Werte** sind `0, "", null, undefined, NaN`.  
âœ… **Dynamische Typisierung** erlaubt das Ã„ndern von Typen zur Laufzeit.


### **Typumwandlung in JavaScript (Type Conversion)**

In JavaScript gibt es zwei Arten der Typumwandlung:
1. **Implizite Typumwandlung (Type Coercion)** â†’ Automatische Konvertierung durch JavaScript  
2. **Explizite Typumwandlung (Type Casting)** â†’ Manuelle Konvertierung durch den Entwickler

---

## **1. Implizite Typumwandlung (Automatische Umwandlung)**
JavaScript wandelt Werte automatisch um, wenn sie in bestimmten Operationen verwendet werden.

### **String-Konkatenation mit `+` (Zahl â†’ String)**
```js
console.log("10" + 5); // "105" (Zahl wird zu String)
console.log(5 + "10"); // "510"
console.log("Hello " + true); // "Hello true"
```

### **Arithmetische Operationen (`-`, `*`, `/`) (String â†’ Zahl)**
```js
console.log("10" - 5); // 5 ("10" wird zu 10)
console.log("6" * "2"); // 12
console.log("100" / "10"); // 10
console.log("5" - true); // 4 (true â†’ 1)
console.log("5" - false); // 5 (false â†’ 0)
```

### **Vergleiche mit `==` (Typumwandlung vor dem Vergleich)**
```js
console.log(0 == "0");  // true (String wird zu Zahl)
console.log(false == ""); // true ("" wird zu false)
console.log(null == undefined); // true
```
ğŸ‘‰ **Verwende `===`, um ohne Typumwandlung zu vergleichen!**
```js
console.log(0 === "0"); // false
console.log(false === ""); // false
```

---

## **2. Explizite Typumwandlung (Manuelle Umwandlung)**
Hier erfolgt die Umwandlung durch Methoden wie `Number()`, `String()`, `Boolean()`.

### **String â†’ Number**
```js
console.log(Number("42")); // 42
console.log(Number("3.14")); // 3.14
console.log(Number("10abc")); // NaN (Fehler, da "abc" keine Zahl ist)
console.log(parseInt("42px")); // 42 (ignoriert "px")
console.log(parseFloat("3.14abc")); // 3.14
```

### **Number â†’ String**
```js
console.log(String(100)); // "100"
console.log((42).toString()); // "42"
console.log((3.14).toFixed(1)); // "3.1" (Rundet und gibt String zurÃ¼ck)
```

### **Beliebiger Wert â†’ Boolean**
```js
console.log(Boolean(1)); // true
console.log(Boolean(0)); // false
console.log(Boolean("Hello")); // true
console.log(Boolean("")); // false
console.log(Boolean(null)); // false
console.log(Boolean(undefined)); // false
console.log(Boolean([])); // true (leeres Array ist truthy!)
console.log(Boolean({})); // true (leeres Objekt ist truthy!)
```

---

## **SpezialfÃ¤lle und Fallstricke**
### **1. `NaN` (Not-a-Number)**
```js
console.log(Number("abc")); // NaN
console.log(0 / 0); // NaN
console.log(NaN == NaN); // false (NaN ist nicht gleich NaN!)
```

### **2. `null` und `undefined` Verhalten**
```js
console.log(Number(null)); // 0
console.log(Number(undefined)); // NaN
console.log(Boolean(null)); // false
console.log(Boolean(undefined)); // false
```

---

## **Fazit**
- **Implizite Typumwandlung** passiert automatisch, kann aber zu unerwarteten Ergebnissen fÃ¼hren.
- **Explizite Typumwandlung** ist sicherer und kontrollierter.
- **Nutze `===` statt `==`**, um unerwartete Konvertierungen zu vermeiden.

---
ğŸ“– Weitere Informationen findest du in der offiziellen [MDN Web Docs](https://developer.mozilla.org/de/docs/Web/JavaScript/Data_structures).

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

2. ### <a name="2"></a> Unterschied zwischen null und undefined

# Unterschied zwischen `null` und `undefined` in JavaScript

In JavaScript stehen `null` und `undefined` fÃ¼r das Fehlen eines Wertes, aber sie unterscheiden sich in ihrer Bedeutung und Verwendung.

## **`undefined`**
- Eine Variable wurde deklariert, aber nicht initialisiert.
- Ist der Standardwert fÃ¼r nicht zugewiesene Variablen.
- Wird zurÃ¼ckgegeben, wenn eine Funktion kein explizites `return` hat.
- Wird zurÃ¼ckgegeben, wenn auf eine nicht existierende Objekt-Eigenschaft oder ein nicht existierendes Array-Element zugegriffen wird.

### **Beispiele fÃ¼r `undefined`**
```js
let x;
console.log(x); // undefined
```

```js
function doSomething() {
  // Keine RÃ¼ckgabe
}
console.log(doSomething()); // undefined
```

```js
let obj = {};
console.log(obj.nonExistentProperty); // undefined
```

## **`null`**
- `null` ist ein expliziter Wert, der anzeigt, dass eine Variable bewusst leer oder nicht gesetzt ist.
- Wird vom Entwickler zugewiesen, um eine Variable als â€ohne Wertâ€œ zu markieren.

### **Beispiel fÃ¼r `null`**
```js
let y = null;
console.log(y); // null
```

## **Unterschiede zusammengefasst**
| Eigenschaft   | `undefined` | `null` |
|--------------|------------|--------|
| Standardwert | Ja (bei nicht zugewiesenen Variablen) | Nein (muss explizit gesetzt werden) |
| RÃ¼ckgabewert | Funktionen ohne `return`, fehlende Objekteigenschaften | Muss manuell zugewiesen werden |
| Typ          | `undefined` | `object` (bekannter JavaScript-Bug) |

## **Wann `null` oder `undefined` verwenden?**
- **Verwende `null`**, wenn du eine Variable explizit auf â€kein Wertâ€œ setzen mÃ¶chtest.
- **Lass `undefined`** dem System Ã¼berlassen (z. B. nicht initialisierte Variablen, fehlende Eigenschaften).

---
ğŸ“– Weitere Informationen findest du in der offiziellen [MDN Web Docs](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/null).

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

3. ### <a name="3"></a> Variablen let, const, var. Strikter Modus

# `let`, `const`, `var` und der strikte Modus in JavaScript

## **Unterschiede zwischen `let`, `const` und `var`**
JavaScript bietet drei MÃ¶glichkeiten, Variablen zu deklarieren: `let`, `const` und `var`. Hier sind ihre Unterschiede:

### **`let`** â€“ Blockscope und Neu-Zuweisung erlaubt
- Hat **Block-Scope** (gÃ¼ltig innerhalb `{}`).
- Kann neu zugewiesen werden.
- **Hoisting:** Wird hochgehoben, aber nicht initialisiert.

**Beispiel:**
```js
let x = 5;
if (true) {
  let x = 10;
  console.log(x); // 10 (innerhalb des Blocks)
}
console.log(x); // 5 (auÃŸerhalb des Blocks)
```

### **`const`** â€“ Blockscope und unverÃ¤nderlich
- Hat ebenfalls **Block-Scope**.
- Muss **direkt initialisiert** werden.
- Kann **nicht** neu zugewiesen werden.

**Beispiel:**
```js
const y = 7;
// y = 10; // âŒ Fehler: `const`-Variablen kÃ¶nnen nicht neu zugewiesen werden.
```

### **`var`** â€“ Funktionaler Scope und Hoisting
- Hat **funktionalen Scope** (sichtbar in der gesamten Funktion, in der sie deklariert wurde).
- Wird **gehoistet** und erhÃ¤lt beim Hoisting den Wert `undefined`.
- Kann Ã¼berschrieben und neu deklariert werden.

**Beispiel:**
```js
var z = 3;
if (true) {
  var z = 6;
  console.log(z); // 6
}
console.log(z); // 6 (da `var` global oder funktionsweit gÃ¼ltig ist)
```

ğŸš€ **Empfehlung:** Verwende **`let`** oder **`const`**, da sie sicherer sind. **`var`** sollte vermieden werden.

---

## **Strikter Modus (`"use strict"`)**
Der **strikte Modus** (`"use strict";`) aktiviert eine strengere Interpretation von JavaScript und hilft, Fehler frÃ¼hzeitig zu erkennen.

### **Aktivierung des strikten Modus**
```js
"use strict";
function myFunction() {
  x = 10; // âŒ Fehler: `x` wurde nicht mit `let`, `const` oder `var` deklariert.
}
```

### **Wichtige Ã„nderungen durch `"use strict"`**
1. **Keine impliziten globalen Variablen**
   ```js
   "use strict";
   myVar = 10; // âŒ Fehler: Variable wurde nicht deklariert.
   ```

2. **Kein mehrfaches Deklarieren von Parametern**
   ```js
   "use strict";
   function sum(a, a) { // âŒ Fehler: Doppelte Parameter-Namen nicht erlaubt.
       return a + a;
   }
   ```

3. **Kein LÃ¶schen von Variablen und Funktionen**
   ```js
   "use strict";
   let myVar = 10;
   delete myVar; // âŒ Fehler: Variablen kÃ¶nnen nicht gelÃ¶scht werden.
   ```

4. **`this` ist `undefined` in einer Funktion**
   ```js
   "use strict";
   function show() {
       console.log(this); // `undefined` statt `window`
   }
   show();
   ```

### **Warum `"use strict"` verwenden?**
âœ… Verhindert hÃ¤ufige Fehler.  
âœ… ErhÃ¶ht die Code-Sicherheit.  
âœ… Hilft, modernen JavaScript-Standards zu entsprechen.

ğŸ“– Weitere Informationen findest du in der offiziellen [MDN Web Docs](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Strict_mode).

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

4. ### <a name="4"></a> Interaktion mit dem Benutzer: alert(), prompt(), confirm()

# Benutzerinteraktion in JavaScript: `alert()`, `prompt()`, `confirm()`

JavaScript bietet drei eingebaute Funktionen zur Benutzerinteraktion Ã¼ber modale Dialoge im Browser: `alert()`, `prompt()` und `confirm()`. Diese blockieren die weitere AusfÃ¼hrung des Skripts, bis der Benutzer eine Aktion ausfÃ¼hrt.

## **`alert()` â€“ Anzeige einer einfachen Nachricht**
Verwendet, um eine Nachricht in einem Dialogfeld mit einer **OK-SchaltflÃ¤che** anzuzeigen. 

**Beispiel:**
```js
alert("Hallo, Welt!"); // Zeigt eine Meldung an.
```

ğŸ“Œ **Eigenschaften:**
- Blockiert den Code, bis der Benutzer auf **OK** klickt.
- Hat **keine** RÃ¼ckgabe (immer `undefined`).

---

## **`prompt()` â€“ Benutzereingabe anfordern**
Zeigt ein Dialogfeld mit einer Nachricht, einem **Eingabefeld** und den SchaltflÃ¤chen **OK / Abbrechen**.

**Beispiel:**
```js
let name = prompt("Wie heiÃŸt du?");
console.log("Hallo, " + name + "!");
```

ğŸ“Œ **Eigenschaften:**
- Gibt den **eingegebenen Text** als `string` zurÃ¼ck.
- Gibt `null` zurÃ¼ck, wenn der Benutzer **Abbrechen** klickt.
- StandardmÃ¤ÃŸig wird alles als `string` gespeichert (auch Zahlen!).

ğŸ‘‰ **Achtung:** Wenn eine Zahl benÃ¶tigt wird, sollte `Number()` verwendet werden:
```js
let age = Number(prompt("Gib dein Alter ein:"));
console.log(age + 1); // Falls eine Zahl eingegeben wurde, wird sie korrekt erhÃ¶ht.
```

---

## **`confirm()` â€“ Benutzerentscheidung abfragen**
Zeigt ein Dialogfeld mit einer Nachricht und zwei SchaltflÃ¤chen: **OK / Abbrechen**.

**Beispiel:**
```js
let result = confirm("Bist du sicher?");
if (result) {
  console.log("Benutzer hat OK geklickt");
} else {
  console.log("Benutzer hat Abbrechen geklickt");
}
```

ğŸ“Œ **Eigenschaften:**
- Gibt `true` zurÃ¼ck, wenn der Benutzer **OK** klickt.
- Gibt `false` zurÃ¼ck, wenn der Benutzer **Abbrechen** klickt.

---

## **EinschrÃ¤nkungen der Modalfenster**
âŒ KÃ¶nnen nicht gestylt oder angepasst werden.  
âŒ Unterbrechen den Codefluss (synchron).  
âŒ KÃ¶nnen in modernen Web-Apps stÃ¶rend sein, daher sind **benutzerdefinierte Dialoge** (`<dialog>`-Element oder modale Fenster mit JavaScript/CSS) oft besser.

ğŸ“– Weitere Informationen findest du in der offiziellen [MDN Web Docs](https://developer.mozilla.org/de/docs/Web/API/Window/alert).

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

5. ### <a name="5"></a> Interpolation (ES6)

### **Interpolation in JavaScript (ES6)**

Interpolation in JavaScript refers to embedding variables or expressions inside a string literal dynamically. This is done using **template literals**, introduced in **ES6**.

#### **Syntax of Template Literals**
Template literals are enclosed in **backticks** (`` ` ``) instead of quotes. The placeholders for variables or expressions are written inside **`${}`**.

```js
let variable = "Wert";
let expression = 2 + 2;

let interpolatedString = `Text: ${variable}, Ausdruck: ${expression}`;
console.log(interpolatedString); // "Text: Wert, Ausdruck: 4"
```

#### **Example: Dynamic String Construction**
```js
let name = "Alice";
let age = 25;

let message = `Hallo, mein Name ist ${name} und ich bin ${age} Jahre alt.`;
console.log(message);
// Ausgabe: "Hallo, mein Name ist Alice und ich bin 25 Jahre alt."
```

#### **Advantages of Template Literals**
âœ… **Better Readability**: No need to concatenate strings using `+`.  
âœ… **Expression Embedding**: Mathematical operations or function calls can be directly embedded.  
âœ… **Multiline Strings**: Supports **multiline strings** without `\n`.  

**Example with Multiline String:**
```js
let text = `Das ist eine mehrzeilige
Zeichenkette ohne Escape-Sequenzen.`;
console.log(text);
```

ğŸ“Œ **Use Case:** Template literals make it easier to build dynamic messages, queries, or HTML content.

Weitere Details findest du in den [MDN Web Docs](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Template_literals). ğŸš€

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

6. ### <a name="6"></a> Operatoren in JavaScript

### **Operatoren in JavaScript**  

JavaScript bietet verschiedene Operatoren, die in mehrere Kategorien unterteilt werden kÃ¶nnen:  

---

## **1. Arithmetische Operatoren**
Diese Operatoren fÃ¼hren mathematische Berechnungen durch.  

| Operator | Beschreibung  | Beispiel | Ergebnis |
|----------|--------------|----------|----------|
| `+`      | Addition     | `5 + 2`  | `7` |
| `-`      | Subtraktion  | `5 - 2`  | `3` |
| `*`      | Multiplikation | `5 * 2` | `10` |
| `/`      | Division     | `5 / 2`  | `2.5` |
| `%`      | Modulo (Rest) | `5 % 2`  | `1` |
| `++`     | Inkrement    | `let a = 5; a++` | `6` |
| `--`     | Dekrement    | `let b = 2; b--` | `1` |

**Beispiel:**  
```js
let a = 5;
let b = 2;

console.log(a + b); // 7
console.log(a - b); // 3
console.log(a * b); // 10
console.log(a / b); // 2.5
console.log(a % b); // 1
```

---

## **2. Zuweisungsoperatoren**
Diese Operatoren weisen Werte zu und kÃ¶nnen eine Kombination aus Rechenoperationen und Zuweisung sein.

| Operator | Beschreibung | Beispiel | Ergebnis |
|----------|-------------|----------|----------|
| `=`      | Zuweisung    | `x = 10` | `x = 10` |
| `+=`     | Addition und Zuweisung | `x += 5` | `x = x + 5` |
| `-=`     | Subtraktion und Zuweisung | `x -= 3` | `x = x - 3` |
| `*=`     | Multiplikation und Zuweisung | `x *= 2` | `x = x * 2` |
| `/=`     | Division und Zuweisung | `x /= 4` | `x = x / 4` |

**Beispiel:**  
```js
let x = 10;
x += 5;  // x = 15
x -= 3;  // x = 12
x *= 2;  // x = 24
x /= 4;  // x = 6
console.log(x);
```

---

## **3. Vergleichsoperatoren**
Vergleichsoperatoren vergleichen zwei Werte und geben ein Boolean-Ergebnis (`true` oder `false`) zurÃ¼ck.

| Operator | Bedeutung | Beispiel | Ergebnis |
|----------|------------|----------|----------|
| `==`     | Gleich (Wert) | `5 == "5"` | `true` |
| `===`    | Strikt gleich (Wert und Typ) | `5 === "5"` | `false` |
| `!=`     | Ungleich | `5 != 3` | `true` |
| `!==`    | Strikt ungleich | `5 !== "5"` | `true` |
| `>`      | GrÃ¶ÃŸer als | `5 > 3` | `true` |
| `<`      | Kleiner als | `5 < 3` | `false` |
| `>=`     | GrÃ¶ÃŸer oder gleich | `5 >= 5` | `true` |
| `<=`     | Kleiner oder gleich | `3 <= 5` | `true` |

**Beispiel:**  
```js
let a = 5;
let b = "5";

console.log(a == b);  // true
console.log(a === b); // false
console.log(a !== b); // true
console.log(a > 3);   // true
```

---

## **4. Logische Operatoren**
Werden fÃ¼r logische AusdrÃ¼cke verwendet.

| Operator | Bedeutung | Beispiel | Ergebnis |
|----------|------------|----------|----------|
| `&&`     | Logisches UND | `true && false` | `false` |
| `||`     | Logisches ODER | `true || false` | `true` |
| `!`      | Logisches NICHT | `!true` | `false` |

**Beispiel:**  
```js
let x = 5;
let y = 10;

console.log(x > 0 && y > 0); // true
console.log(x > 0 || y < 0); // true
console.log(!(x > 0));       // false
```

---

## **5. Nullish Coalescing Operator (`??`)**
Gibt den **ersten definierten Wert** zurÃ¼ck (wenn der linke Wert `null` oder `undefined` ist, wird der rechte verwendet).

**Beispiel:**  
```js
let username = null;
let defaultUsername = "Gast";

let finalUsername = username ?? defaultUsername;
console.log(finalUsername); // "Gast"

let count = 0;
let finalCount = count ?? 10;
console.log(finalCount); // 0 (weil `count` nicht `null` oder `undefined` ist)
```

---

## **6. Optionale Verkettung (`?.`)**
ErmÃ¶glicht den **sicheren Zugriff** auf Eigenschaften oder Methoden von `null` oder `undefined`, ohne einen Fehler auszulÃ¶sen.

**Beispiel:**  
```js
let user = {
  name: "John",
  address: {
    city: "Berlin"
  }
};

console.log(user?.name);         // "John"
console.log(user?.address?.city); // "Berlin"
console.log(user?.age);          // undefined (statt Fehler)
```

---

## **7. Bitweise Operatoren**
Arbeiten direkt auf den BinÃ¤rwerten von Zahlen.

| Operator | Beschreibung | Beispiel | Ergebnis |
|----------|-------------|----------|----------|
| `&`      | Bitweises UND | `5 & 3`  | `1` |
| `|`      | Bitweises ODER | `5 | 3`  | `7` |
| `^`      | Bitweises XOR | `5 ^ 3`  | `6` |
| `~`      | Bitweises NOT | `~5` | `-6` |
| `<<`     | Linksverschiebung | `5 << 1` | `10` |
| `>>`     | Rechtsverschiebung | `5 >> 1` | `2` |

**Beispiel:**  
```js
let a = 5;  // BinÃ¤r: 101
let b = 3;  // BinÃ¤r: 011

console.log(a & b); // 1 (001)
console.log(a | b); // 7 (111)
console.log(a ^ b); // 6 (110)
console.log(~a);    // -6
console.log(a << 1); // 10
console.log(b >> 1); // 1
```

---

## **8. Unterschied zwischen unÃ¤rem und binÃ¤rem `+`**
- **BinÃ¤rer `+`**: FÃ¼hrt Addition oder String-Konkatenation durch.
- **UnÃ¤rer `+`**: Wandelt einen Wert in eine Zahl um.

**Beispiel:**  
```js
let a = "10";
let b = 5;

console.log(a + b);  // "105" (String-Konkatenation)
console.log(+a + b); // 15 (Addition)

console.log(+"123"); // 123 (String â†’ Zahl)
console.log(+true);  // 1 (Boolean â†’ Zahl)
console.log(+"abc"); // NaN (ungÃ¼ltige Umwandlung)
```

---

### **Zusammenfassung**
- Verwende `===` fÃ¼r verlÃ¤ssliche Vergleiche.
- Nutze `??` fÃ¼r Standardwerte bei `null` oder `undefined`.
- Die **optionale Verkettung (`?.`)** ist hilfreich fÃ¼r den sicheren Zugriff auf Objekte.
- **UnÃ¤rer `+`** kann nÃ¼tzlich sein, um Strings in Zahlen zu konvertieren.

ğŸ“– Weitere Details findest du in den [MDN Web Docs](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Operators). ğŸš€

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

7. ### <a name="7"></a> Bedingungen

### **Bedingungen in JavaScript**

In JavaScript gibt es verschiedene MÃ¶glichkeiten, Bedingungen zu prÃ¼fen und Code auszufÃ¼hren, wenn bestimmte Kriterien erfÃ¼llt sind.  

---

## ** Falsy-Werte**
Bestimmte Werte werden als **falsch** (`false`) behandelt, wenn sie in einer Bedingung Ã¼berprÃ¼ft werden:
- `0`
- `""` (leerer String)
- `null`
- `undefined`
- `NaN`

### **Bedingungen in JavaScript (`if`, `else`, `switch`, ternÃ¤rer Operator)** âœ…  

ğŸ“Œ **Bedingungen steuern den Programmfluss, indem sie Entscheidungen treffen.**  
âœ… **Ziel:** **Code soll auf Basis von Bedingungen unterschiedliche Aktionen ausfÃ¼hren.**  

---

## **1. `if`, `else if`, `else` â€“ Standardbedingungen**
ğŸ“Œ **`if` prÃ¼ft eine Bedingung & fÃ¼hrt Code aus, wenn sie `true` ist.**  
ğŸ“Œ **`else if` & `else` ermÃ¶glichen mehrere Bedingungen.**  

ğŸ”¹ **Beispiel: Einfache `if`-Bedingung**
```javascript
const age = 18;

if (age >= 18) {
  console.log("Du darfst Auto fahren");
} else {
  console.log("Du bist zu jung zum Fahren");
}
```
âœ… **Nur eine der Bedingungen wird ausgefÃ¼hrt.**  

ğŸ”¹ **Beispiel: `if...else if...else` mit mehreren Bedingungen**
```javascript
const temperature = 30;

if (temperature > 30) {
  console.log("Es ist heiÃŸ");
} else if (temperature > 20) {
  console.log("Angenehme Temperatur");
} else {
  console.log("Es ist kalt");
}
```
âœ… **Der erste `true`-Zweig wird ausgefÃ¼hrt, danach stoppt die PrÃ¼fung.**  

---

## **2. `switch` â€“ Alternative zu mehreren `if`-Bedingungen**
ğŸ“Œ **Ideal fÃ¼r mehrere Werte eines einzelnen Ausdrucks.**  
ğŸ“Œ **Vermeidet viele `if...else if`-Verzweigungen.**  

ğŸ”¹ **Beispiel: `switch` fÃ¼r Wochentage**
```javascript
const day = "Montag";

switch (day) {
  case "Montag":
    console.log("Wochenstart!");
    break;
  case "Freitag":
    console.log("Bald Wochenende!");
    break;
  case "Samstag":
  case "Sonntag":
    console.log("Wochenende!");
    break;
  default:
    console.log("Normaler Tag");
}
```
âœ… **`break` verhindert, dass alle weiteren `case`-Zweige ausgefÃ¼hrt werden.**  

---

## **3. TernÃ¤rer Operator (`? :`) â€“ Kurzschreibweise fÃ¼r `if...else`**
ğŸ“Œ **Kurzversion von `if...else` fÃ¼r einfache Bedingungen.**  
ğŸ“Œ **Ideal fÃ¼r eine schnelle `true`/`false`-Entscheidung.**  

ğŸ”¹ **Beispiel: `if...else` vs. TernÃ¤rer Operator**
```javascript
const isMember = true;

// Standard `if...else`
let discount;
if (isMember) {
  discount = "10% Rabatt";
} else {
  discount = "Kein Rabatt";
}

// Kurzform mit `? :`
const discountTernary = isMember ? "10% Rabatt" : "Kein Rabatt";

console.log(discountTernary); // âœ… "10% Rabatt"
```
âœ… **Eleganter & kÃ¼rzer als `if...else`.**  

---

## **4. Logische Operatoren (`&&`, `||`, `!`) in Bedingungen**
ğŸ“Œ **ErmÃ¶glichen komplexere Bedingungen mit `AND`, `OR` & `NOT`.**  

| Operator | Bedeutung | Beispiel |
|----------|-----------|------------|
| `&&` | **AND** (beide mÃ¼ssen `true` sein) | `if (x > 10 && y < 20) {...}` |
| `||` | **OR** (mindestens eine Bedingung `true`) | `if (x > 10 || y < 20) {...}` |
| `!` | **NOT** (negiert `true` zu `false`) | `if (!isLoggedIn) {...}` |

ğŸ”¹ **Beispiel: Mehrere Bedingungen mit `&&` und `||`**
```javascript
const userLoggedIn = true;
const hasPremium = false;

if (userLoggedIn && hasPremium) {
  console.log("Premium-Inhalte anzeigen");
} else if (userLoggedIn || hasPremium) {
  console.log("Normale Inhalte anzeigen");
} else {
  console.log("Bitte einloggen");
}
```
âœ… **Logische Operatoren kombinieren Bedingungen flexibel.**  

---

## **5. `nullish coalescing` (`??`) & Optional Chaining (`?.`)**
ğŸ“Œ **Behandelt `null` oder `undefined` auf elegante Weise.**  

ğŸ”¹ **`??` (`nullish coalescing`) â†’ Fallback-Wert setzen, wenn `null` oder `undefined`**
```javascript
const username = null;
const displayName = username ?? "Gast"; // âœ… "Gast"
console.log(displayName);
```
âœ… **Ideal fÃ¼r Standardwerte!**  

ğŸ”¹ **`?.` (`Optional Chaining`) â†’ Verhindert Fehler bei `undefined`-Werten**
```javascript
const user = { profile: { name: "Max" } };
console.log(user.profile?.name); // âœ… "Max"
console.log(user.address?.street); // âœ… `undefined` (kein Fehler!)
```
âœ… **Verhindert `TypeError`, wenn `address` nicht existiert.**  

---

### **Zusammenfassung**
| Methode | Wann nutzen? | Beispiel |
|---------|-------------|----------|
| **`if...else`** | Einfache Bedingungen | `if (age >= 18) {...}` |
| **`switch`** | Mehrere mÃ¶gliche Werte | `switch (day) {...}` |
| **TernÃ¤rer Operator** | Kurzform fÃ¼r `if...else` | `const x = condition ? A : B;` |
| **`&&`, `||`, `!`** | Logische Bedingungen | `if (x > 10 && y < 20) {...}` |
| **`??` (`nullish coalescing`)** | Standardwert fÃ¼r `null` oder `undefined` | `const x = val ?? "Default";` |
| **`?.` (`Optional Chaining`)** | Verhindert `undefined`-Fehler | `object?.property?.value` |

âœ… **Bedingungen ermÃ¶glichen dynamischen & flexiblen Code!** ğŸš€  

ğŸ”— [MDN: JavaScript `if...else`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else)  
ğŸ”— [MDN: JavaScript `switch`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/switch)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

8. ### <a name="8"></a> Schleifen, verschachtelte Schleifen, Labels

### **Schleifen in JavaScript (`for`, `while`, `do...while`, verschachtelte Schleifen, Labels)** ğŸ”„  

ğŸ“Œ **Schleifen wiederholen Code-BlÃ¶cke, bis eine Bedingung nicht mehr erfÃ¼llt ist.**  
âœ… **Ziel:** **Effiziente Iteration Ã¼ber Arrays, Objekte & wiederholte Aktionen.**  

---

## **1. `for`-Schleife â€“ Standard fÃ¼r Iterationen**
ğŸ“Œ **Beste Wahl, wenn die Anzahl der Wiederholungen bekannt ist.**  

ğŸ”¹ **Syntax:**
```javascript
for (Initialisierung; Bedingung; Inkrement/Dekrement) {
  // Code wird wiederholt
}
```

ğŸ”¹ **Beispiel: Zahlen von 1 bis 5 ausgeben**
```javascript
for (let i = 1; i <= 5; i++) {
  console.log(i);
}
```
âœ… **LÃ¤uft von `1` bis `5`, dann stoppt sie.**  

---

## **2. `while`-Schleife â€“ LÃ¤uft, solange die Bedingung `true` ist**
ğŸ“Œ **NÃ¼tzlich, wenn die Anzahl der Wiederholungen unbekannt ist.**  

ğŸ”¹ **Beispiel: `while` mit zufÃ¤lliger Zahl**
```javascript
let number = 0;

while (number < 5) {
  number = Math.floor(Math.random() * 10);
  console.log("Zufallszahl:", number);
}
```
âœ… **Wird ausgefÃ¼hrt, bis `number >= 5`.**  

---

## **3. `do...while`-Schleife â€“ FÃ¼hrt Code **mindestens einmal** aus**
ğŸ“Œ **Gleiche Logik wie `while`, aber Code lÃ¤uft mindestens 1x.**  

ğŸ”¹ **Beispiel: `do...while` mit Nutzereingabe**
```javascript
let userInput;

do {
  userInput = prompt("Gib eine Zahl grÃ¶ÃŸer als 10 ein:");
} while (userInput <= 10);

console.log("Danke!");
```
âœ… **Fordert den Nutzer so lange auf, bis er `>10` eingibt.**  

---

## **4. `for...in`-Schleife â€“ Iteration Ã¼ber Objekte**
ğŸ“Œ **DurchlÃ¤uft die Eigenschaften eines Objekts.**  

ğŸ”¹ **Beispiel: Iteration Ã¼ber ein Objekt**
```javascript
const user = { name: "Max", age: 30, city: "Berlin" };

for (let key in user) {
  console.log(`${key}: ${user[key]}`);
}
```
âœ… **Gibt `name: Max`, `age: 30`, `city: Berlin` aus.**  

---

## **5. `for...of`-Schleife â€“ Iteration Ã¼ber Arrays & Iterables**
ğŸ“Œ **Einfachste Methode, um Arrays zu durchlaufen.**  

ğŸ”¹ **Beispiel: Durchlaufen eines Arrays**
```javascript
const colors = ["Rot", "GrÃ¼n", "Blau"];

for (let color of colors) {
  console.log(color);
}
```
âœ… **Leichter lesbar als `for` oder `forEach`.**  

---

## **6. Verschachtelte Schleifen â€“ Schleifen in Schleifen**
ğŸ“Œ **NÃ¼tzlich fÃ¼r Matrizen & kombinierte Datenstrukturen.**  

ğŸ”¹ **Beispiel: Multiplikationstabelle**
```javascript
for (let i = 1; i <= 3; i++) {
  for (let j = 1; j <= 3; j++) {
    console.log(`${i} x ${j} = ${i * j}`);
  }
}
```
âœ… **FÃ¼r `i = 1` wird `j` von `1` bis `3` iteriert.**  

---

## **7. `break` & `continue` â€“ Schleifen unterbrechen oder Ã¼berspringen**
ğŸ“Œ **`break` â†’ Bricht die Schleife ab**  
ğŸ“Œ **`continue` â†’ Ãœberspringt die aktuelle Iteration**  

ğŸ”¹ **Beispiel: `break` in einer `for`-Schleife**
```javascript
for (let i = 1; i <= 5; i++) {
  if (i === 3) break; // Stoppt bei 3
  console.log(i);
}
// Ausgabe: 1, 2
```

ğŸ”¹ **Beispiel: `continue` Ã¼berspringt eine Iteration**
```javascript
for (let i = 1; i <= 5; i++) {
  if (i === 3) continue; // Ãœberspringt 3
  console.log(i);
}
// Ausgabe: 1, 2, 4, 5
```
âœ… **Steuert den Ablauf innerhalb der Schleife gezielt.**  

---

## **8. Labels â€“ Schleifen gezielt abbrechen**
ğŸ“Œ **ErmÃ¶glicht das gezielte `break` fÃ¼r verschachtelte Schleifen.**  

ğŸ”¹ **Beispiel: `break` mit Label**
```javascript
outerLoop: for (let i = 1; i <= 3; i++) {
  for (let j = 1; j <= 3; j++) {
    if (i === 2 && j === 2) break outerLoop;
    console.log(`${i}, ${j}`);
  }
}
// Ausgabe: Bis `1,3` und `2,1`, dann Abbruch
```
âœ… **Beendet `outerLoop`, nicht nur die innere Schleife!**  

---

## **9. Vergleich der Schleifenarten**
| Schleife | Wann nutzen? | Beispiel |
|----------|-------------|----------|
| **`for`** | Feste Anzahl an Wiederholungen | `for (let i = 0; i < 5; i++)` |
| **`while`** | Unbekannte Anzahl, Bedingung vor Eintritt | `while (x < 10)` |
| **`do...while`** | Mindestens einmal ausfÃ¼hren | `do { x++ } while (x < 10)` |
| **`for...in`** | Iteration Ã¼ber Objekte | `for (let key in obj)` |
| **`for...of`** | Iteration Ã¼ber Arrays | `for (let item of arr)` |

âœ… **Die Wahl der richtigen Schleife verbessert Code-Lesbarkeit & Performance!** ğŸš€  

ğŸ”— [MDN: JavaScript-Loops](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Loops_and_iteration)  
ğŸ”— [MDN: break & continue](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/break)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

9. ### <a name="9"></a> Hoisting (Hochheben von Variablen und Funktionen)

### **Hoisting in JavaScript â€“ Variablen & Funktionen "hochheben"** ğŸš€  

ğŸ“Œ **Hoisting bedeutet, dass Variablen & Funktionen in den Speicher geladen werden, bevor der Code ausgefÃ¼hrt wird.**  
âœ… **Ziel:** **Verstehen, wie JavaScript Variablen & Funktionen verarbeitet, um Fehler zu vermeiden.**  

---

## **1. Was ist Hoisting?**
ğŸ“Œ **JavaScript verarbeitet den Code in zwei Schritten:**
1ï¸âƒ£ **Speicherphase (Hoisting):**  
   - Funktionen & Variablen werden **vor der Code-AusfÃ¼hrung** im Speicher abgelegt.  
   - **`var`-Variablen werden als `undefined` gespeichert.**  
   - **`let` & `const` werden zwar reserviert, aber nicht initialisiert (TDZ = Temporal Dead Zone).**  
2ï¸âƒ£ **AusfÃ¼hrungsphase:**  
   - Der eigentliche Code wird von oben nach unten ausgefÃ¼hrt.  

---

## **2. Hoisting mit `var` â€“ Wird als `undefined` angelegt**
ğŸ“Œ **`var`-Variablen werden vor ihrer Zuweisung deklariert, aber nicht initialisiert.**  

ğŸ”¹ **Beispiel: `var` wird hochgehoben, aber ist `undefined`**
```javascript
console.log(name); // âœ… `undefined`
var name = "Max";
console.log(name); // âœ… "Max"
```
â¡ **JavaScript "sieht" den Code intern so:**
```javascript
var name; // Hoisting (Speicherung als `undefined`)
console.log(name); // âœ… `undefined`
name = "Max"; // Zuweisung erfolgt erst hier
console.log(name); // âœ… "Max"
```
âœ… **Vermeide `var`, da es zu unerwarteten Ergebnissen fÃ¼hren kann!**  

---

## **3. Hoisting mit `let` & `const` â€“ Gibt einen Fehler (TDZ)**
ğŸ“Œ **`let` & `const` werden zwar hochgehoben, aber nicht initialisiert!**  

ğŸ”¹ **Beispiel: Zugriff vor der Deklaration fÃ¼hrt zu einem Fehler**
```javascript
console.log(age); // âŒ ReferenceError (TDZ!)
let age = 25;
```
â¡ **JavaScript "sieht" den Code intern so:**
```javascript
// `let` wird hochgehoben, aber nicht initialisiert (TDZ aktiv)
console.log(age); // âŒ ReferenceError (Zugriff in der TDZ)
let age = 25; // Erst hier ist die Variable nutzbar
```
âœ… **Nutze immer `let` oder `const`, um unklare Fehler zu vermeiden!**  

---

## **4. Hoisting mit Funktionen â€“ FunktionserklÃ¤rungen (`function`) werden vollstÃ¤ndig hochgehoben**
ğŸ“Œ **Funktionsdeklarationen werden komplett hochgehoben & kÃ¶nnen vor ihrer Definition genutzt werden.**  

ğŸ”¹ **Beispiel: Funktion vor ihrer Definition aufrufen**
```javascript
sayHello(); // âœ… "Hallo!"

function sayHello() {
  console.log("Hallo!");
}
```
â¡ **JavaScript "sieht" den Code intern so:**
```javascript
function sayHello() { // Hoisting
  console.log("Hallo!");
}

sayHello(); // âœ… Funktion kann hier bereits genutzt werden
```
âœ… **FunktionserklÃ¤rungen (`function`) werden **vollstÃ¤ndig** hochgehoben.**  

---

## **5. Hoisting mit FunktionsausdrÃ¼cken (`const function = () => {}`)**
ğŸ“Œ **Bei FunktionsausdrÃ¼cken (`const function = () => {}` oder `const function = function() {}`) gibt es ein Problem!**  

ğŸ”¹ **Beispiel: Zugriff auf Funktionsausdruck vor der Zuweisung**
```javascript
greet(); // âŒ ReferenceError: greet is not defined

const greet = function () {
  console.log("Hallo!");
};
```
â¡ **JavaScript "sieht" den Code intern so:**
```javascript
const greet; // âŒ Variable ist zwar hochgehoben, aber nicht initialisiert (TDZ)
greet(); // âŒ Fehler: Zugriff in der TDZ
greet = function () { console.log("Hallo!"); };
```
âœ… **LÃ¶sung: Funktionen als `function name() {}` definieren, wenn sie vorher aufgerufen werden mÃ¼ssen!**  

---

## **6. Zusammenfassung: Hoisting-Regeln**
| Element | Wird hochgehoben? | Initialisiert? | Zugriff vor der Deklaration? |
|---------|----------------|-----------------|-----------------------------|
| **`var`** | âœ… Ja | âŒ `undefined` | âš  `undefined` |
| **`let`** | âœ… Ja | âŒ Nein (TDZ!) | âŒ `ReferenceError` |
| **`const`** | âœ… Ja | âŒ Nein (TDZ!) | âŒ `ReferenceError` |
| **`function name() {}`** | âœ… Ja | âœ… Ja | âœ… Funktion kann genutzt werden |
| **`const function = () => {}`** | âœ… Ja | âŒ Nein (TDZ!) | âŒ `ReferenceError` |

âœ… **Empfohlene Best Practices:**
- **Nutze `let` & `const` statt `var`.**
- **Definiere FunktionsausdrÃ¼cke (`const fn = () => {}`) erst, bevor du sie nutzt.**
- **Verstehe die `Temporal Dead Zone` (TDZ) bei `let` & `const`.**  

ğŸ”— [MDN: Hoisting in JavaScript](https://developer.mozilla.org/en-US/docs/Glossary/Hoisting) ğŸš€

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

10. ### <a name="10"></a> AusfÃ¼hrungskontext, Lexikalische Umgebung

### **AusfÃ¼hrungskontext & Lexikalische Umgebung in JavaScript** ğŸš€  

ğŸ“Œ **JavaScript fÃ¼hrt Code innerhalb eines Kontexts aus & nutzt eine lexikalische Umgebung fÃ¼r Variablen & Funktionen.**  
âœ… **Ziel:** **Verstehen, wie JavaScript Code ausfÃ¼hrt & auf Variablen zugreift.**  

---

## **1. Was ist der AusfÃ¼hrungskontext (`Execution Context`)?**  
ğŸ“Œ **Ein AusfÃ¼hrungskontext bestimmt, welche Variablen & Funktionen in einem bestimmten Codeblock verfÃ¼gbar sind.**  

ğŸ”¹ **Es gibt 3 Hauptarten:**
| Art des Kontexts | Beschreibung | Beispiel |
|------------------|-------------|----------|
| **Global Execution Context (GEC)** | Standardkontext, in dem der Code lÃ¤uft | `window` (Browser), `global` (Node.js) |
| **Function Execution Context (FEC)** | Wird fÃ¼r jede FunktionsausfÃ¼hrung erstellt | `function myFunc() {...}` |
| **Eval Execution Context** | Selten genutzt, fÃ¼r `eval()`-Code | `eval("var a = 5");` |

âœ… **Jede Funktion erstellt ihren eigenen `Execution Context`.**  

---

## **2. Ablauf eines AusfÃ¼hrungskontexts**
ğŸ“Œ **Ein neuer Execution Context wird in 2 Phasen erstellt:**  

1ï¸âƒ£ **Erstellungsphase (`Creation Phase`)**  
   - Speicherzuweisung fÃ¼r Variablen, Funktionen & `this`.  
   - Variablen mit `var` bekommen `undefined`.  
   - `let` & `const` werden reserviert (TDZ = Temporal Dead Zone).  

2ï¸âƒ£ **AusfÃ¼hrungsphase (`Execution Phase`)**  
   - Code wird von oben nach unten ausgefÃ¼hrt.  
   - Werte werden den Variablen zugewiesen.  

ğŸ”¹ **Beispiel: Execution Context in Aktion**
```javascript
console.log(x); // âœ… `undefined` (Hoisting von `var`)
console.log(y); // âŒ ReferenceError (TDZ von `let`)

var x = 5;
let y = 10;
```
âœ… **`var` wird `undefined`, `let` bleibt in der TDZ & gibt einen Fehler.**  

---

## **3. Der Call Stack & Execution Context**
ğŸ“Œ **JavaScript verwaltet Execution Contexts mit einem Call Stack (LIFO - Last In, First Out).**  

ğŸ”¹ **Beispiel: Call Stack in Aktion**
```javascript
function first() {
  console.log("Funktion first");
  second();
}

function second() {
  console.log("Funktion second");
}

first();
console.log("Globaler Code");
```
ğŸ”¹ **Call Stack Ablauf:**
1ï¸âƒ£ **Global Execution Context (`GEC`) wird erstellt.**  
2ï¸âƒ£ **`first()` wird aufgerufen â†’ Neuer `Execution Context` kommt in den Stack.**  
3ï¸âƒ£ **`second()` wird von `first()` aufgerufen â†’ Neuer `Execution Context`.**  
4ï¸âƒ£ **Nach Beendigung wird `second()` entfernt, dann `first()`, dann `GEC`.**  

âœ… **Call Stack verarbeitet Funktionen von innen nach auÃŸen!**  

---

## **4. Was ist die lexikalische Umgebung (`Lexical Environment`)?**
ğŸ“Œ **Die lexikalische Umgebung bestimmt, welche Variablen & Funktionen verfÃ¼gbar sind.**  

ğŸ”¹ **Jeder `Execution Context` hat seine eigene lexikalische Umgebung, die enthÃ¤lt:**
1. **Eigene Variablen & Funktionen.**  
2. **Verweis auf den Ã¼bergeordneten (`outer`) Kontext (Scope Chain).**  

ğŸ”¹ **Beispiel: Verschachtelte Funktionen & lexikalische Umgebung**
```javascript
function outer() {
  let a = "Hallo";

  function inner() {
    console.log(a); // âœ… Greift auf `a` von `outer()` zu
  }

  inner();
}

outer();
```
âœ… **`inner()` kann `a` von `outer()` nutzen, weil es im lexikalischen Scope liegt.**  

---

## **5. Scope Chain â€“ Wie JavaScript Variablen sucht**
ğŸ“Œ **Scope Chain bedeutet, dass JavaScript Variablen von innen nach auÃŸen sucht.**  

ğŸ”¹ **Beispiel: Variable nicht im lokalen Scope**
```javascript
let x = "Global";

function first() {
  let y = "First Scope";

  function second() {
    console.log(x); // âœ… "Global" (sucht im Ã¤uÃŸeren Scope)
    console.log(y); // âœ… "First Scope"
  }

  second();
}

first();
```
âœ… **JavaScript sucht zuerst in `second()`, dann in `first()`, dann im globalen Scope.**  

---

## **6. Fazit: Execution Context vs. Lexical Environment**
| Konzept | Beschreibung | Beispiel |
|---------|-------------|----------|
| **Execution Context** | Wo & wie wird Code ausgefÃ¼hrt? | Global, Function, Eval |
| **Lexical Environment** | Wo werden Variablen gespeichert? | `function inner() { console.log(a); }` |
| **Call Stack** | Verwaltung von Execution Contexts | LIFO-Prinzip |
| **Scope Chain** | Wie Variablen gefunden werden | `console.log(x);` sucht in Ã¤uÃŸeren Scopes |

âœ… **Execution Context = Laufzeitumgebung**  
âœ… **Lexical Environment = Sichtbarkeitsbereich (Scope)**  

ğŸ”— [MDN: Execution Context](https://developer.mozilla.org/en-US/docs/Glossary/Execution_context)  
ğŸ”— [MDN: Scope & Lexical Environment](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures) ğŸš€

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

11. ### <a name="11"></a> TemporÃ¤re Totzone (Temporal Dead Zone)

### **TemporÃ¤re Totzone (Temporal Dead Zone, TDZ) in JavaScript** âš ï¸  

ğŸ“Œ **Die temporÃ¤re Totzone (`Temporal Dead Zone, TDZ`) ist der Zeitraum zwischen der Deklaration & Initialisierung einer `let` oder `const` Variablen, in dem ein Zugriff zu einem `ReferenceError` fÃ¼hrt.**  
âœ… **Ziel:** **Verstehen, warum `let` & `const` anders als `var` behandelt werden.**  

---

## **1. Was ist die TemporÃ¤re Totzone (TDZ)?**
ğŸ“Œ **Variablen mit `let` & `const` sind "gehoistet", aber nicht initialisiert.**  
- **Der Zugriff darauf, bevor sie initialisiert werden, fÃ¼hrt zu einem `ReferenceError`.**  
- **`var` hingegen wird als `undefined` initialisiert & gibt keinen Fehler.**  

ğŸ”¹ **Beispiel: Zugriff auf `let` in der TDZ**
```javascript
console.log(a); // âŒ ReferenceError: Cannot access 'a' before initialization
let a = 10;
console.log(a); // âœ… 10
```
âœ… **`a` existiert bereits im Scope, aber ist noch nicht nutzbar.**  

---

## **2. Warum tritt die TDZ auf?**
ğŸ“Œ **TDZ verhindert unerwartetes Verhalten durch vorzeitigen Zugriff auf Variablen.**  

ğŸ”¹ **Vergleich mit `var` (kein TDZ, aber `undefined`)**
```javascript
console.log(x); // âœ… undefined (kein Fehler, aber unerwartetes Verhalten)
var x = 5;
console.log(x); // âœ… 5
```
ğŸ”¹ **Gleiches Beispiel mit `let` (fÃ¼hrt zu `ReferenceError`)**
```javascript
console.log(y); // âŒ ReferenceError (TDZ)
let y = 5;
console.log(y); // âœ… 5
```
âœ… **TDZ macht Fehler frÃ¼h sichtbar & verhindert ungewollten `undefined`-Zugriff.**  

---

## **3. Wann beginnt & endet die TDZ?**
ğŸ“Œ **Die TDZ beginnt mit dem Eintritt in den Scope & endet mit der Initialisierung.**  

ğŸ”¹ **Beispiel: Block-Scoped TDZ in `if`-BlÃ¶cken**
```javascript
if (true) {
  console.log(z); // âŒ ReferenceError (TDZ aktiv)
  let z = 10; // TDZ endet hier
  console.log(z); // âœ… 10
}
```
âœ… **Die TDZ gilt fÃ¼r den gesamten Block, bevor die Variable deklariert wird.**  

---

## **4. TDZ in `const` (Noch strenger als `let`)**
ğŸ“Œ **`const`-Variablen befinden sich auch in der TDZ, aber zusÃ¤tzlich mÃ¼ssen sie sofort initialisiert werden.**  

ğŸ”¹ **Beispiel: `const` ohne Initialisierung**
```javascript
console.log(x); // âŒ ReferenceError (TDZ)
const x = 10;
```
ğŸ”¹ **Beispiel: `const` ohne Initialisierung fÃ¼hrt zu SyntaxError**
```javascript
const y; // âŒ SyntaxError: Missing initializer in const declaration
```
âœ… **`const` muss bei der Deklaration sofort einen Wert bekommen.**  

---

## **5. TDZ in Funktionsparametern**
ğŸ“Œ **`let` & `const` innerhalb einer Funktion befinden sich in der TDZ, bevor sie zugewiesen werden.**  

ğŸ”¹ **Beispiel: Funktionsparameter beeinflussen TDZ**
```javascript
function test(x = y, y = 10) { // âŒ ReferenceError (TDZ fÃ¼r `y`)
  console.log(x, y);
}

test();
```
âœ… **Funktion kann keinen Parameter nutzen, der erst danach deklariert wird.**  

---

## **6. Fazit â€“ TDZ & Hoisting-Vergleich**
| Feature | `var` | `let` | `const` |
|---------|-------|-------|---------|
| **Hoisting?** | âœ… Ja | âœ… Ja | âœ… Ja |
| **Initialisierung?** | `undefined` | âŒ Nein (TDZ) | âŒ Nein (TDZ) |
| **Zugriff vor Initialisierung?** | âœ… Ja (`undefined`) | âŒ `ReferenceError` | âŒ `ReferenceError` |
| **Muss sofort initialisiert werden?** | âŒ Nein | âŒ Nein | âœ… Ja |

âœ… **TDZ macht Code sicherer & vermeidet unerwartete `undefined`-Werte!** ğŸš€  

ğŸ”— [MDN: TDZ & Hoisting](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#temporal_dead_zone_tdz) ğŸš€

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

12. ### <a name="12"></a> typeof â€“ wie erkennt man den Typ eines Werts?

### **`typeof` â€“ Den Typ eines Werts in JavaScript erkennen**  

Der `typeof`-Operator wird in JavaScript verwendet, um den **Datentyp** einer Variablen oder eines Werts als **String** zurÃ¼ckzugeben.

---

## **1. Syntax**  
```js
typeof Wert;
typeof (Wert);
```

ğŸ“Œ **Hinweis:** Klammern sind optional, kÃ¶nnen aber zur besseren Lesbarkeit genutzt werden.

---

## **2. RÃ¼ckgabewerte von `typeof`**  
| Datentyp | `typeof` RÃ¼ckgabe |
|----------|------------------|
| `undefined` | `"undefined"` |
| `null` | `"object"` âŒ (JavaScript-Bug) |
| `boolean` | `"boolean"` |
| `number` | `"number"` |
| `bigint` | `"bigint"` (ab ES11) |
| `string` | `"string"` |
| `symbol` | `"symbol"` |
| `function` | `"function"` |
| `object` | `"object"` (Objekte, Arrays) |

---

## **3. Beispiele**
```js
console.log(typeof 42);         // "number"
console.log(typeof "Hello");    // "string"
console.log(typeof true);       // "boolean"
console.log(typeof undefined);  // "undefined"
console.log(typeof null);       // "object" âŒ (Bug in JavaScript)
console.log(typeof {});         // "object"
console.log(typeof []);         // "object" (Arrays sind Objekte!)
console.log(typeof function(){}); // "function"
console.log(typeof Symbol("id")); // "symbol"
console.log(typeof BigInt(9007199254740991)); // "bigint"
```

---

## **4. Besonderheiten und Fallstricke**
### âŒ **`typeof null` gibt `"object"` zurÃ¼ck**
```js
console.log(typeof null); // "object"
```
ğŸ“Œ **Grund:** Dies ist ein **historischer Bug** in JavaScript. `null` ist **kein** Objekt, sondern ein eigener Datentyp.

**Richtige PrÃ¼fung auf `null`:**
```js
let value = null;
console.log(value === null); // âœ… true
```

---

### âŒ **Arrays geben `"object"` zurÃ¼ck**
```js
console.log(typeof [1, 2, 3]); // "object"
```
ğŸ“Œ **Arrays sind eine spezielle Art von Objekten.**  
**Richtige PrÃ¼fung:**  
```js
console.log(Array.isArray([1, 2, 3])); // âœ… true
```

---

### **`typeof` bei `functions`**
```js
console.log(typeof function() {}); // "function"
```
ğŸ“Œ **Obwohl Funktionen Objekte sind, gibt `typeof` "function" zurÃ¼ck.**  

---

## **5. Praktische AnwendungsfÃ¤lle**
### âœ… **Datentyp prÃ¼fen, bevor Operationen ausgefÃ¼hrt werden**
```js
function add(a, b) {
  if (typeof a !== "number" || typeof b !== "number") {
    return "Fehler: Beide Werte mÃ¼ssen Zahlen sein!";
  }
  return a + b;
}

console.log(add(5, "10")); // "Fehler: Beide Werte mÃ¼ssen Zahlen sein!"
```

### âœ… **PrÃ¼fung auf `null`**
```js
let obj = null;

if (obj === null) {
  console.log("obj ist null");
}
```

### âœ… **Unterschied zwischen `object` und `array` prÃ¼fen**
```js
let data = [1, 2, 3];

if (Array.isArray(data)) {
  console.log("data ist ein Array!");
} else {
  console.log("data ist ein Objekt!");
}
```

---

### **6. Zusammenfassung**
âœ… `typeof` gibt den Datentyp eines Werts als **String** zurÃ¼ck.  
âœ… **Achtung bei `typeof null` â†’ gibt `"object"` zurÃ¼ck (Bug).**  
âœ… **Arrays** sind `typeof "object"` â†’ `Array.isArray()` zur PrÃ¼fung verwenden.  
âœ… **Funktionen** sind `typeof "function"` (aber intern Objekte).  

ğŸ“– Weitere Infos: [MDN Web Docs](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Operators/typeof) ğŸš€

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

13. ### <a name="13"></a> Warum haben primitive Datentypen Methoden? Was ist Autoboxing?

### **Warum haben primitive Datentypen Methoden? Was ist Autoboxing?**  

In JavaScript sind **primitive Datentypen** (`string`, `number`, `boolean`, `symbol`, `bigint`, `null`, `undefined`) **keine Objekte** und haben normalerweise keine Methoden. Dennoch kÃ¶nnen wir Methoden wie `.toUpperCase()` fÃ¼r Strings oder `.toFixed()` fÃ¼r Zahlen aufrufen.  

ğŸ“Œ **Grund:** **JavaScript nutzt "Autoboxing"**, um primitive Werte in **Objekt-Wrapper** umzuwandeln, wenn Methoden aufgerufen werden.

---

## **1. Was ist Autoboxing?**
ğŸ“Œ **Autoboxing** bedeutet, dass ein primitiver Wert **automatisch in ein entsprechendes Objekt umgewandelt** wird, wenn eine Methode oder Eigenschaft aufgerufen wird.  

| Primitiver Typ | Entsprechendes Wrapper-Objekt |
|---------------|------------------------------|
| `string`      | `String` |
| `number`      | `Number` |
| `boolean`     | `Boolean` |

Nach der **Nutzung des Objekts wird es sofort wieder verworfen**, und die Variable bleibt ein primitiver Wert.

---

## **2. Beispiel fÃ¼r Autoboxing**
```js
const str = "hello";
console.log(str.toUpperCase()); // "HELLO"
```
ğŸ‘‰ **Was passiert intern?**
1. JavaScript erstellt **temporÃ¤r** ein `String`-Objekt:  
   ```js
   new String("hello");
   ```
2. FÃ¼hrt `.toUpperCase()` darauf aus.  
3. Gibt `"HELLO"` zurÃ¼ck und verwirft das Objekt.

---

## **3. Beispiel mit `Number`**
```js
const num = 42;
console.log(num.toFixed(2)); // "42.00"
```
ğŸ‘‰ **Intern passiert Folgendes:**
1. `num` ist ein primitiver `number`-Wert.
2. JavaScript wandelt `num` temporÃ¤r in ein `Number`-Objekt um.
3. FÃ¼hrt `.toFixed(2)` aus.
4. Gibt das Ergebnis zurÃ¼ck und verwirft das `Number`-Objekt.

---

## **4. Was passiert, wenn wir ein echtes Wrapper-Objekt nutzen?**
```js
const strObj = new String("hello");
console.log(typeof strObj); // "object"
console.log(strObj === "hello"); // false (Objekt â‰  primitiver Wert)
```
ğŸ“Œ **Achtung:** Ein `new String("hello")` ist **kein** primitiver `string`, sondern ein Objekt!  
Deshalb sollte man `new String()`, `new Number()` oder `new Boolean()` **nicht verwenden**.

---

## **5. Warum sind primitive Werte unverÃ¤nderlich?**
```js
const str = "hello";
str[0] = "H"; // âŒ Keine Ã„nderung mÃ¶glich
console.log(str); // "hello" bleibt unverÃ¤ndert
```
ğŸ“Œ **Warum?** Weil **primitive Werte keine verÃ¤nderbaren Objekte sind**. Methoden wie `.toUpperCase()` oder `.slice()` **geben eine neue Zeichenkette zurÃ¼ck, anstatt die ursprÃ¼ngliche zu Ã¤ndern**.

---

### **Zusammenfassung**
âœ… **Autoboxing** ermÃ¶glicht Methodenaufrufe auf primitiven Werten.  
âœ… **Primitive Werte bleiben unverÃ¤ndert** â€“ Methoden erzeugen neue Werte.  
âœ… **Nach der Methode wird das temporÃ¤re Objekt sofort verworfen.**  
âœ… **Vermeide `new String()`, `new Number()` und `new Boolean()`** â€“ sie erzeugen unnÃ¶tige Objekte.

ğŸ“– Mehr Infos: [MDN Web Docs](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/String) ğŸš€

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

14. ### <a name="14"></a> Garbage Collector in JavaScript

### **Garbage Collector in JavaScript**  

JavaScript hat einen **automatischen Garbage Collector**, der **nicht mehr verwendete Objekte aus dem Speicher entfernt**. Dies verhindert manuelles Speichermanagement wie in C oder C++.  

---

## **1. Wie funktioniert der Garbage Collector?**  
Der **Garbage Collector** entfernt Objekte aus dem Speicher, die **nicht mehr erreichbar** sind.  
Ein Objekt gilt als **"nicht mehr erreichbar"**, wenn **keine Referenz mehr darauf existiert**.

ğŸ”¹ **Beispiel fÃ¼r ein erreichbares Objekt:**  
```js
let obj = { name: "Max" }; // "obj" hÃ¤lt eine Referenz auf das Objekt
```
ğŸ‘‰ **Dieses Objekt wird NICHT gelÃ¶scht**, weil `obj` darauf verweist.

ğŸ”¹ **Objekt wird unerreichbar und gelÃ¶scht:**  
```js
let obj = { name: "Max" };
obj = null; // Keine Referenz mehr â†’ Speicher wird freigegeben
```
ğŸ‘‰ **Nach `obj = null;` gibt es keine Referenz mehr â†’ Objekt wird gelÃ¶scht.**

---

## **2. Hauptstrategie des Garbage Collectors: Mark-and-Sweep (Markierung & LÃ¶schung)**  
Der **hÃ¤ufigste Algorithmus** in modernen JavaScript-Engines ist **"Mark-and-Sweep"**:
1. **Mark (Markieren)**: Der Garbage Collector markiert **alle erreichbaren Objekte**.
2. **Sweep (LÃ¶schen)**: Alle **nicht markierten (unerreichbaren) Objekte werden gelÃ¶scht**.

ğŸ“Œ **Beispiel fÃ¼r Mark-and-Sweep:**
```js
function createObject() {
  let obj = { value: 42 }; // Erreichbar innerhalb der Funktion
}
createObject(); 
// Nach dem Funktionsaufruf ist "obj" nicht mehr erreichbar â†’ Es wird gelÃ¶scht.
```

---

## **3. Memory Leaks (Speicherlecks) vermeiden**
Obwohl der Garbage Collector automatisch arbeitet, kÃ¶nnen **Speicherlecks** auftreten.

### **Typische Ursachen fÃ¼r Memory Leaks**  
1. **UnnÃ¶tige globale Variablen**  
   ```js
   var globalVar = {}; // Bleibt fÃ¼r die gesamte Laufzeit erhalten
   ```
   **LÃ¶sung:** **Vermeide `var`, nutze `let` oder `const`.**  
   
2. **Vergessene Timer (`setInterval`)**
   ```js
   let interval = setInterval(() => console.log("lÃ¤uft"), 1000);
   // clearInterval(interval); // Muss gestoppt werden, sonst bleibt es im Speicher!
   ```

3. **DOM-Referenzen behalten**  
   ```js
   let button = document.getElementById("btn");
   button.addEventListener("click", () => console.log("geklickt"));
   // Falls "button" entfernt wird, bleibt die Referenz bestehen und blockiert Speicher.
   ```

   **LÃ¶sung:** `removeEventListener()` nutzen:  
   ```js
   button.removeEventListener("click", handler);
   ```

---

## **4. Zusammenfassung**
âœ… **Garbage Collector entfernt ungenutzte Objekte automatisch**.  
âœ… **"Mark-and-Sweep" ist der wichtigste Algorithmus**.  
âœ… **Speicherlecks vermeiden:** `setInterval` stoppen, Event-Listener entfernen, keine unnÃ¶tigen globalen Variablen.  

ğŸ“– **Mehr Infos:** [MDN Web Docs](https://developer.mozilla.org/de/docs/Web/JavaScript/Memory_Management) ğŸš€

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

15. ### <a name="15"></a> Unterschied zwischen == und ===

### **Unterschied zwischen `==` und `===` in JavaScript**  

In JavaScript gibt es zwei Arten von Vergleichsoperatoren:  

| Operator | Bedeutung | TypprÃ¼fung |
|----------|------------|------------|
| **`==` (doppelt gleich)** | **Vergleicht Werte nach Typumwandlung** | âŒ Nein (fÃ¼hrt Typkonvertierung durch) |
| **`===` (dreifach gleich)** | **Vergleicht Werte & Datentypen** | âœ… Ja (kein Typwechsel) |

---

## **1. `==` (Lose Gleichheit â€“ Typumwandlung erlaubt)**
ğŸ“Œ **JavaScript konvertiert Werte automatisch, wenn sie nicht denselben Typ haben.**  
```javascript
console.log(5 == "5");  // âœ… true  (String wird in Zahl umgewandelt)
console.log(0 == false); // âœ… true  (false wird zu 0)
console.log(null == undefined); // âœ… true  (beide als "leer" betrachtet)
console.log("" == false); // âœ… true  ("" wird zu 0)
```
âœ… **Flexibel, aber kann zu unerwarteten Ergebnissen fÃ¼hren!**  

---

## **2. `===` (Strikte Gleichheit â€“ Typen mÃ¼ssen Ã¼bereinstimmen)**
ğŸ“Œ **Vergleicht sowohl Wert als auch Datentyp â€“ kein automatischer Typwechsel.**  
```javascript
console.log(5 === "5");  // âŒ false (Zahl vs. String)
console.log(0 === false); // âŒ false (Zahl vs. Boolean)
console.log(null === undefined); // âŒ false (unterschiedliche Typen)
console.log("" === false); // âŒ false (String vs. Boolean)
```
âœ… **Empfohlen fÃ¼r prÃ¤zisere Vergleiche!**  

---

## **3. Wann sollte `==` oder `===` verwendet werden?**
| Situation | Empfohlener Operator |
|-----------|----------------------|
| **Vergleich mit strikter TypprÃ¼fung** | `===` (empfohlen) |
| **PrÃ¼fen auf `null` oder `undefined`** | `==` (`null == undefined` ist `true`) |
| **Explizite Konvertierung vor dem Vergleich** | `Number(a) === Number(b)` |

**Beispiel: Korrekte Nutzung**
```javascript
const alter = "18";

if (Number(alter) === 18) { 
  console.log("VolljÃ¤hrig"); // âœ… Explizite Umwandlung
}
```
âœ… **Vermeidet unerwartete Typumwandlungen**  

---

### **Zusammenfassung**
| Operator | Typumwandlung | Beispiel (`5 == "5"`) | Empfehlung |
|----------|--------------|----------------|------------|
| `==` | Ja (lose Gleichheit) | âœ… `true` | âŒ Nicht empfohlen |
| `===` | Nein (strikte Gleichheit) | âŒ `false` | âœ… Empfohlen |

ğŸ”— [MDN-Dokumentation zu `==` & `===`](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Operators)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

16. ### <a name="16"></a> Primitive vs. Referenztypen

### **Primitive vs. Referenztypen in JavaScript**  

In JavaScript gibt es zwei Hauptkategorien von Datentypen:  
- **Primitive Typen** â†’ **Direkte Werte** (immutable/unverÃ¤nderlich, gespeichert im **Stack**)  
- **Referenztypen (Objekte)** â†’ **Referenzen auf Speicheradressen** (mutable/verÃ¤nderbar, gespeichert im **Heap**)  

---

## **1. Primitive Typen (immutable & im Stack gespeichert)**  

ğŸ“Œ **Folgende Typen gehÃ¶ren zu den primitiven Typen:**  
| Typ | Beispiel |
|------|------------|
| **`string`** | `"Hallo"` |
| **`number`** | `42`, `3.14`, `NaN` |
| **`boolean`** | `true`, `false` |
| **`null`** | `null` |
| **`undefined`** | `undefined` |
| **`bigint`** | `9007199254740991n` |
| **`symbol`** | `Symbol("unique")` |

âœ… **Direkte Wertzuweisung (Kopien sind unabhÃ¤ngig voneinander)**  
```javascript
let a = 10;
let b = a; // Kopie des Werts, nicht die gleiche Referenz

b = 20;
console.log(a); // âœ… 10 (unverÃ¤ndert)
console.log(b); // âœ… 20 (geÃ¤ndert)
```
âœ… **Primitiven Werte werden **direkt** im **Stack** gespeichert.**  

---

## **2. Referenztypen (mutable & im Heap gespeichert)**  

ğŸ“Œ **Folgende Typen gehÃ¶ren zu den Referenztypen:**  
| Typ | Beispiel |
|------|------------|
| **`Object`** | `{ name: "Max" }` |
| **`Array`** | `[1, 2, 3]` |
| **`Function`** | `function() {}` |

âŒ **Referenz wird kopiert, nicht der Wert!**  
```javascript
let obj1 = { zahl: 10 };
let obj2 = obj1; // Beide zeigen auf das gleiche Objekt

obj2.zahl = 20;
console.log(obj1.zahl); // âŒ 20 (weil `obj1` und `obj2` dieselbe Referenz haben)
```
âœ… **Objekte werden im **Heap** gespeichert, wÃ¤hrend die Variable nur eine **Referenz** im Stack enthÃ¤lt.**  

---

## **3. Unterschied zwischen Kopie (primitiv) & Referenz (Objekte)**
### **Kopie bei primitiven Werten (unabhÃ¤ngig)**
```javascript
let x = "Hallo";
let y = x;

y = "Welt";
console.log(x); // âœ… "Hallo" (unverÃ¤ndert)
console.log(y); // âœ… "Welt" (geÃ¤ndert)
```
âœ… **Bei primitiven Werten werden echte Kopien erstellt.**  

### **Referenz bei Objekten (gemeinsame Nutzung)**
```javascript
let person1 = { name: "Max" };
let person2 = person1;

person2.name = "Anna";
console.log(person1.name); // âŒ "Anna" (weil person1 und person2 dasselbe Objekt referenzieren)
```
âŒ **Ã„nderungen an `person2` beeinflussen auch `person1`.**  

---

## **4. Wie vermeidet man unerwÃ¼nschte Referenzen?**
ğŸ“Œ **1. Objekte klonen (`Object.assign()` oder `...` Spread)**  
```javascript
let person1 = { name: "Max" };
let person2 = { ...person1 }; // Neuer Speicherplatz

person2.name = "Anna";
console.log(person1.name); // âœ… "Max" (unverÃ¤ndert)
```
ğŸ“Œ **2. Tiefe Kopie mit `JSON.parse(JSON.stringify(obj))` (funktioniert nicht mit Funktionen/Symbolen!)**  
```javascript
let person1 = { name: "Max", details: { age: 30 } };
let person2 = JSON.parse(JSON.stringify(person1));

person2.details.age = 40;
console.log(person1.details.age); // âœ… 30 (unverÃ¤ndert)
```
ğŸ“Œ **3. Mit `structuredClone()` (moderne Alternative)**  
```javascript
let person1 = { name: "Max", details: { age: 30 } };
let person2 = structuredClone(person1);

person2.details.age = 40;
console.log(person1.details.age); // âœ… 30 (unverÃ¤ndert)
```

---

### **Zusammenfassung**
| Typ | Eigenschaften | Speicherort |
|------|--------------|-------------|
| **Primitive Typen** | Immutable (unverÃ¤nderlich), Kopien sind unabhÃ¤ngig | **Stack** |
| **Referenztypen** | Mutable (verÃ¤nderbar), Kopien sind **Referenzen** auf dasselbe Objekt | **Heap** |

ğŸ”— [MDN-Dokumentation zu Datenstrukturen](https://developer.mozilla.org/de/docs/Web/JavaScript/Data_structures)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

17. ### <a name="17"></a> Symbol.iterator und Iterierbare Objekte

### **`Symbol.iterator` und Iterierbare Objekte in JavaScript**  

In JavaScript sind **iterierbare Objekte** Objekte, die mit `for...of` oder anderen Iterationsmethoden durchlaufen werden kÃ¶nnen.  
Das geschieht Ã¼ber die **`Symbol.iterator`-Schnittstelle**, die definiert, wie sich ein Objekt iterieren lÃ¤sst.

---

## **1. Was ist `Symbol.iterator`?**
ğŸ“Œ **`Symbol.iterator` ist ein spezielles Symbol, das definiert, wie ein Objekt iteriert wird.**  
- Es muss eine **Methode** zurÃ¼ckgeben, die einen **Iterator** erzeugt (`next()`-Methode).  

âœ… **Beispiel: `Array` ist iterierbar**  
```javascript
const arr = [10, 20, 30];
const iterator = arr[Symbol.iterator]();

console.log(iterator.next()); // âœ… { value: 10, done: false }
console.log(iterator.next()); // âœ… { value: 20, done: false }
console.log(iterator.next()); // âœ… { value: 30, done: false }
console.log(iterator.next()); // âœ… { value: undefined, done: true }
```
âœ… **`done: false` â†’ Iteration lÃ¤uft noch**  
âœ… **`done: true` â†’ Keine Werte mehr verfÃ¼gbar**  

---

## **2. `for...of` fÃ¼r iterierbare Objekte**
ğŸ“Œ **`for...of` nutzt `Symbol.iterator`, um Elemente abzurufen.**
```javascript
const zahlen = [1, 2, 3];

for (let zahl of zahlen) {
  console.log(zahl); // âœ… 1, 2, 3
}
```
âœ… **Funktioniert mit allen eingebauten iterierbaren Objekten (`Array`, `Set`, `Map`)**  

---

## **3. Eigene Objekte iterierbar machen**
ğŸ“Œ **Ein benutzerdefiniertes Objekt iterierbar machen, indem `Symbol.iterator` definiert wird.**
```javascript
const benutzer = {
  namen: ["Max", "Anna", "Tom"],
  [Symbol.iterator]() {
    let index = 0;
    return {
      next: () => {
        if (index < this.namen.length) {
          return { value: this.namen[index++], done: false };
        }
        return { done: true };
      }
    };
  }
};

for (let name of benutzer) {
  console.log(name); // âœ… "Max", "Anna", "Tom"
}
```
âœ… **Das Objekt verhÃ¤lt sich jetzt wie ein Array mit `for...of`.**  

---

## **4. `Set` und `Map` sind iterierbar**
```javascript
const zahlenSet = new Set([1, 2, 3]);
for (let zahl of zahlenSet) {
  console.log(zahl); // âœ… 1, 2, 3
}

const map = new Map([
  ["a", 1],
  ["b", 2]
]);
for (let [key, value] of map) {
  console.log(`${key}: ${value}`); // âœ… "a: 1", "b: 2"
}
```
âœ… **`Set` und `Map` implementieren `Symbol.iterator`, daher direkt iterierbar.**  

---

## **5. Manuelles Nutzen von `Symbol.iterator`**
ğŸ“Œ **Ein Objekt kann direkt Ã¼ber den Iterator durchlaufen werden.**
```javascript
const iterator = benutzer[Symbol.iterator]();
console.log(iterator.next().value); // âœ… "Max"
console.log(iterator.next().value); // âœ… "Anna"
console.log(iterator.next().value); // âœ… "Tom"
console.log(iterator.next().done);  // âœ… true
```
âœ… **Direkter Zugriff auf Iterationswerte ohne `for...of`**  

---

### **Zusammenfassung**
| Feature | Beschreibung |
|---------|-------------|
| **`Symbol.iterator`** | Definiert, wie ein Objekt iteriert wird |
| **`next()`-Methode** | Gibt `{ value, done }` zurÃ¼ck |
| **`for...of`** | Nutzt `Symbol.iterator`, um Objekte zu durchlaufen |
| **Iterierbare Objekte** | `Array`, `Set`, `Map` sind von Haus aus iterierbar |
| **Eigene Iteratoren** | Durch Implementieren von `Symbol.iterator` |

ğŸ”— [MDN-Dokumentation zu `Symbol.iterator`](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

18. ### <a name="18"></a> WeakRef und FinalizationRegistry

### **`WeakRef` und `FinalizationRegistry` in JavaScript (ES2021)**  

Ab **ES2021** gibt es zwei neue Speicherverwaltungsfunktionen in JavaScript:  
- **`WeakRef`** (Schwache Referenzen) â†’ Erlaubt Referenzen auf Objekte, die vom Garbage Collector entfernt werden kÃ¶nnen.  
- **`FinalizationRegistry`** â†’ Benachrichtigt, wenn ein Objekt vom Speicher entfernt wurde.  

Diese sind nÃ¼tzlich fÃ¼r **optimierte Speicherverwaltung**, aber sollten **mit Vorsicht** verwendet werden!  

---

## **1. `WeakRef` â€“ Schwache Referenzen**
ğŸ“Œ **`WeakRef` speichert eine schwache Referenz auf ein Objekt.**  
- Das Objekt kann **vom Garbage Collector gelÃ¶scht werden**, wenn keine andere starke Referenz existiert.  

```javascript
let obj = { name: "Test" };
const weakRef = new WeakRef(obj);

console.log(weakRef.deref()); // âœ… { name: "Test" }

obj = null; // Objekt wird nun potenziell vom GC gelÃ¶scht

console.log(weakRef.deref()); // âŒ MÃ¶glicherweise `undefined` (wenn GC es entfernt hat)
```
âœ… **NÃ¼tzlich fÃ¼r Caching-Mechanismen**  
âŒ **Kein sicherer Zugriff (kann `undefined` zurÃ¼ckgeben)**  

---

## **2. `FinalizationRegistry` â€“ Speicherbereinigung verfolgen**
ğŸ“Œ **`FinalizationRegistry` erlaubt es, eine Callback-Funktion zu registrieren, die aufgerufen wird, wenn ein Objekt gelÃ¶scht wird.**  

```javascript
const registry = new FinalizationRegistry((heldValue) => {
  console.log(`Objekt mit Wert "${heldValue}" wurde gelÃ¶scht`);
});

let obj = { name: "Test" };
registry.register(obj, "Test-Objekt");

obj = null; // Nach dem LÃ¶schen kann der GC das Objekt entfernen
```
âœ… **Ideal fÃ¼r Debugging & Cleanup-Tasks**  
âŒ **Keine Garantie, wann der Garbage Collector es ausfÃ¼hrt!**  

---

## **3. Verwendung in Kombination**
ğŸ“Œ **Man kann `WeakRef` & `FinalizationRegistry` zusammen verwenden.**  

```javascript
const cache = new Map();
const registry = new FinalizationRegistry((key) => {
  cache.delete(key);
});

function addToCache(key, value) {
  const ref = new WeakRef(value);
  cache.set(key, ref);
  registry.register(value, key);
}

let obj = { data: "Wichtig" };
addToCache("objKey", obj);

console.log(cache.get("objKey").deref()); // âœ… { data: "Wichtig" }

obj = null; // Objekt wird gelÃ¶scht
setTimeout(() => console.log(cache.get("objKey")), 1000); // âŒ Wahrscheinlich `undefined`
```
âœ… **Effiziente Speicherverwaltung fÃ¼r Caching**  
âŒ **GC-Zeitpunkt nicht vorhersehbar!**  

---

## **4. Wann `WeakRef` & `FinalizationRegistry` verwenden?**
| Situation | **Empfohlen?** |
|-----------|--------------|
| **Cache fÃ¼r selten genutzte Objekte** | âœ… Ja |
| **Event-Listener oder Timer automatisch entfernen** | âœ… Ja |
| **Normale Objektreferenzen in Anwendungen** | âŒ Nein |
| **Datenbank-/Sitzungscache, der immer bestehen soll** | âŒ Nein |

---

### **Zusammenfassung**
| Feature | Beschreibung |
|---------|-------------|
| **`WeakRef(obj)`** | Erstellt eine schwache Referenz auf ein Objekt |
| **`.deref()`** | Holt das Objekt, falls noch vorhanden |
| **`FinalizationRegistry(callback)`** | Meldet, wenn ein Objekt vom GC gelÃ¶scht wird |
| **`.register(obj, value)`** | Registriert ein Objekt zur Ãœberwachung |

ğŸ”— [MDN-Dokumentation zu `WeakRef`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef)  
ğŸ”— [MDN-Dokumentation zu `FinalizationRegistry`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

19. ### <a name="19"></a> 


  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

20. ### <a name="20"></a> 


  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

21. ### <a name="21"></a> Funktionen, Pfeilfunktionen, IIFE, Unterschied zwischen Funktionsdeklaration und Funktionsausdruck

### **Funktionen, Pfeilfunktionen und IIFE in JavaScript**

JavaScript bietet verschiedene Arten von Funktionen, die sich in **Syntax, `this`-Bindung und AnwendungsfÃ¤llen** unterscheiden.

---

## **1. Klassische Funktionsdeklaration**
Die **Funktionsdeklaration** ist die traditionelle Methode zur Definition von Funktionen.

```javascript
function addiere(a, b) {
  return a + b;
}

console.log(addiere(3, 5)); // 8
```
âœ… **Eigenschaften**:
- Kann **vor der Definition** aufgerufen werden (Hoisting).
- Hat eine eigene `this`-Bindung.

---

## **2. Funktionsausdruck**
Ein **Funktionsausdruck** speichert eine Funktion in einer Variable.

```javascript
const subtrahiere = function (a, b) {
  return a - b;
};

console.log(subtrahiere(10, 4)); // 6
```
âœ… **Eigenschaften**:
- Muss **nach der Definition** aufgerufen werden.
- Ist nÃ¼tzlich fÃ¼r **anonyme Funktionen**.

---

## **3. Pfeilfunktionen (`=>`)**
Pfeilfunktionen bieten eine **kÃ¼rzere Syntax** und Ã¼bernehmen `this` aus dem umgebenden Kontext.

```javascript
const multipliziere = (a, b) => a * b;

console.log(multipliziere(3, 4)); // 12
```

ğŸ“Œ **Besonderheiten von Pfeilfunktionen**:
- **Kein eigenes `this`** (Ã¼bernimmt `this` vom Ã¤uÃŸeren Kontext).
- **Kein `arguments`-Objekt**.
- KÃ¼rzere Syntax, **besonders fÃ¼r Callbacks**.

### **Beispiel: `this` in Pfeilfunktionen**
```javascript
const person = {
  name: "Max",
  sagHallo: function() {
    setTimeout(() => {
      console.log(`Hallo, ich bin ${this.name}`);
    }, 1000);
  }
};

person.sagHallo(); // Hallo, ich bin Max (weil `this` von `person` kommt)
```
- **Normale Funktionen** wÃ¼rden `this` verlieren (`undefined` oder `window`).
- **Pfeilfunktionen** behalten `this` vom Ã¤uÃŸeren Scope.

---

## **4. Immediately Invoked Function Expression (IIFE)**
Ein **IIFE** (Sofort ausgefÃ¼hrter Funktionsausdruck) wird **direkt nach der Definition** ausgefÃ¼hrt.

```javascript
(function() {
  console.log("Ich bin ein IIFE!");
})(); // Ich bin ein IIFE!
```
Oder mit **Pfeilfunktion**:

```javascript
(() => {
  console.log("IIFE mit Pfeilfunktion!");
})(); // IIFE mit Pfeilfunktion!
```

ğŸ“Œ **AnwendungsfÃ¤lle fÃ¼r IIFE**:
- Um **Variablen vor dem globalen Scope zu schÃ¼tzen**.
- Einmalige Initialisierungen oder Konfigurationen.

---

## **Zusammenfassung**
- **Funktionsdeklarationen** (`function name()`) sind **hoistbar** und haben ein eigenes `this`.
- **FunktionsausdrÃ¼cke** (`const name = function() {}`) mÃ¼ssen zuerst definiert werden.
- **Pfeilfunktionen** (`const name = () => {}`) haben **kein eigenes `this`** und sind ideal fÃ¼r Callbacks.
- **IIFE (`(function() {})()`)** werden sofort ausgefÃ¼hrt und kapseln Variablen.

ğŸ”— [MDN-Dokumentation zu Funktionen](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Functions)

### **Unterschied zwischen Funktionsdeklaration und Funktionsausdruck in JavaScript**  

In JavaScript gibt es zwei MÃ¶glichkeiten, eine Funktion zu definieren:  
1. **Funktionsdeklaration (`function name() {}`)**  
2. **Funktionsausdruck (`const name = function() {}` oder `const name = () => {}`)**  

---

## **1. Funktionsdeklaration (`Function Declaration`)**
ğŸ“Œ **Definiert eine Funktion mit `function` und einem Namen.**  
ğŸ“Œ **Wird vor der AusfÃ¼hrung "gehoisted"** â€“ also nach oben verschoben.  

```javascript
console.log(begrÃ¼ÃŸen()); // âœ… "Hallo!"

function begrÃ¼ÃŸen() {
  return "Hallo!";
}
```
âœ… **Kann vor der Definition aufgerufen werden (Hoisting)**  
âœ… **Bietet eine klare Struktur**  
âŒ **Nicht flexibel fÃ¼r anonyme Funktionen**  

---

## **2. Funktionsausdruck (`Function Expression`)**
ğŸ“Œ **Funktion wird einer Variable zugewiesen.**  
ğŸ“Œ **Nicht "gehoisted"** â€“ kann nur nach der Definition verwendet werden.  

```javascript
console.log(begrÃ¼ÃŸen()); // âŒ Fehler: Cannot access 'begrÃ¼ÃŸen' before initialization

const begrÃ¼ÃŸen = function () {
  return "Hallo!";
};

console.log(begrÃ¼ÃŸen()); // âœ… "Hallo!"
```
âœ… **Funktion kann anonym sein (`const begr = function() {}`)**  
âœ… **Flexibler, kann leicht als Callback oder Argument genutzt werden**  
âŒ **Muss vor der Verwendung definiert werden**  

---

## **3. Unterschied bei Hoisting**
```javascript
// Funktionsdeklaration (hoisted)
test(); // âœ… Kein Fehler

function test() {
  console.log("Ich bin eine Deklaration!");
}

// Funktionsausdruck (nicht hoisted)
test2(); // âŒ Fehler: Cannot access 'test2' before initialization

const test2 = function () {
  console.log("Ich bin ein Funktionsausdruck!");
};
```
âœ… **Funktionsdeklarationen kÃ¶nnen vor ihrer Definition aufgerufen werden**  
âŒ **FunktionsausdrÃ¼cke nicht â€“ sie verhalten sich wie `let/const` Variablen**  

---

## **4. Arrow Functions als Funktionsausdruck**
ğŸ“Œ **Arrow Functions (`=>`) sind eine kompakte Form von FunktionsausdrÃ¼cken.**  

```javascript
const add = (a, b) => a + b;

console.log(add(2, 3)); // âœ… 5
```
âœ… **KÃ¼rzere Syntax**  
âœ… **Kein eigenes `this` (nÃ¼tzlich in Callbacks & Methoden)**  
âŒ **Kann nicht als Konstruktor (`new`) verwendet werden**  

---

### **Zusammenfassung**
| Typ | Hoisting? | Syntax | Verwendung |
|------|----------|--------|------------|
| **Funktionsdeklaration** | âœ… Ja | `function name() {}` | Standard, wenn keine flexible Zuweisung nÃ¶tig ist |
| **Funktionsausdruck** | âŒ Nein | `const name = function() {};` | NÃ¼tzlich fÃ¼r anonyme Funktionen, Callbacks |
| **Arrow Function** | âŒ Nein | `const name = () => {};` | KÃ¼rzere Schreibweise, kein `this` |

ğŸ”— [MDN-Dokumentation zu Funktionen](https://developer.mozilla.org/de/docs/Web/JavaScript/Guide/Functions)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

22. ### <a name="22"></a> Methoden zur Kontextbindung (call, apply, bind)

### **Methoden zur Kontextbindung (`call`, `apply`, `bind`) in JavaScript**

In JavaScript kann das `this`-Binding einer Funktion dynamisch verÃ¤ndert werden. DafÃ¼r gibt es drei Methoden:  
- `call()`
- `apply()`
- `bind()`

Diese Methoden werden verwendet, um **Funktionen mit einem bestimmten `this`-Wert auszufÃ¼hren**.

---

## **1. `call()` â€“ Funktion mit explizitem `this`-Wert aufrufen**
Die Methode `call()` ruft eine Funktion mit einem bestimmten `this`-Wert und einzelnen Argumenten auf.

```javascript
function begruessen(land, sprache) {
  console.log(`Hallo, ich bin ${this.name} aus ${land}, und ich spreche ${sprache}.`);
}

const person = { name: "Max" };

begruessen.call(person, "Deutschland", "Deutsch");
// Hallo, ich bin Max aus Deutschland, und ich spreche Deutsch.
```
âœ… **Eigenschaften**:
- `this` wird auf `person` gesetzt.
- Die Argumente werden **einzeln Ã¼bergeben**.

---

## **2. `apply()` â€“ Ã„hnlich wie `call()`, aber mit Array als Argumente**
Die Methode `apply()` funktioniert wie `call()`, aber Argumente werden als **Array** Ã¼bergeben.

```javascript
begruessen.apply(person, ["Frankreich", "FranzÃ¶sisch"]);
// Hallo, ich bin Max aus Frankreich, und ich spreche FranzÃ¶sisch.
```
âœ… **Unterschied zu `call()`**:
- Argumente werden **als Array** (`[]`) Ã¼bergeben, nicht einzeln.

---

## **3. `bind()` â€“ Neue Funktion mit festem `this` erstellen**
Die Methode `bind()` gibt eine **neue Funktion** zurÃ¼ck, in der `this` dauerhaft an ein Objekt gebunden ist.

```javascript
const begruessungMax = begruessen.bind(person);
begruessungMax("Spanien", "Spanisch");
// Hallo, ich bin Max aus Spanien, und ich spreche Spanisch.
```
âœ… **Eigenschaften**:
- `this` bleibt dauerhaft auf `person` gebunden.
- Gibt eine **neue Funktion** zurÃ¼ck, die spÃ¤ter aufgerufen werden kann.

---

## **4. `bind()` fÃ¼r Methoden in Objekten**
Ein hÃ¤ufiges Problem: **`this`-Verlust in Event-Handlern**.

```javascript
const user = {
  name: "Lisa",
  sagHallo() {
    console.log(`Hallo, ich bin ${this.name}`);
  }
};

const hallo = user.sagHallo;
hallo(); // Fehler: `this` ist `undefined` oder `window`
```
âœ… **LÃ¶sung: `bind()` verwenden**:
```javascript
const halloGebunden = user.sagHallo.bind(user);
halloGebunden(); // Hallo, ich bin Lisa
```
- `bind()` sorgt dafÃ¼r, dass `this` auf `user` bleibt.

---

## **5. `bind()` in Event-Handlern**
Beim Event-Handling in DOM-Elementen verliert `this` oft die Verbindung zum Objekt.

```javascript
const button = document.querySelector("button");

const handler = {
  text: "Geklickt!",
  clickHandler() {
    console.log(this.text);
  }
};

// Funktion ohne Bindung (Fehlverhalten)
button.addEventListener("click", handler.clickHandler); // `this` ist nicht `handler`

// LÃ¶sung: `bind()`
button.addEventListener("click", handler.clickHandler.bind(handler));
```

---

### **Zusammenfassung**
- **`call(obj, arg1, arg2, ...)`** â†’ FÃ¼hrt die Funktion sofort mit `this = obj` aus (Argumente einzeln).
- **`apply(obj, [arg1, arg2, ...])`** â†’ Wie `call()`, aber Argumente als Array.
- **`bind(obj)`** â†’ Erstellt eine neue Funktion mit festem `this`, die spÃ¤ter aufgerufen wird.

ğŸ”— [MDN-Dokumentation zu `call`, `apply` und `bind`](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Function/bind)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

23. ### <a name="23"></a> Closures (AbschlÃ¼sse)

### **Closures (AbschlÃ¼sse) in JavaScript**  

Ein **Closure** entsteht, wenn eine **innere Funktion** auf die **Variablen einer Ã¤uÃŸeren Funktion** zugreift, auch nach dem Abschluss der Ã¤uÃŸeren Funktion. Dadurch bleibt der Zugriff auf **private Daten** erhalten.

---

## **1. Einfaches Beispiel fÃ¼r ein Closure**  
```javascript
function begruessung(name) {
  return function() {
    console.log(`Hallo, ${name}!`);
  };
}

const sagHallo = begruessung("Max");
sagHallo(); // Hallo, Max!
```
âœ… **ErklÃ¤rung**:  
- `begruessung("Max")` gibt eine **innere Funktion** zurÃ¼ck.  
- Diese Funktion merkt sich `name`, selbst nachdem `begruessung` beendet wurde.

---

## **2. Datenkapselung mit Closures**  
Closures kÃ¶nnen **private Variablen** simulieren:

```javascript
function zaehler() {
  let count = 0; // Private Variable

  return {
    hoch: function() { count++; console.log(count); },
    runter: function() { count--; console.log(count); },
    wert: function() { return count; }
  };
}

const meinZaehler = zaehler();
meinZaehler.hoch(); // 1
meinZaehler.hoch(); // 2
meinZaehler.runter(); // 1
console.log(meinZaehler.wert()); // 1
```
âœ… **Vorteile**:
- `count` ist **nicht direkt zugÃ¤nglich** (private Variable).
- Zugriff nur Ã¼ber die bereitgestellten Methoden.

---

## **3. Closures in `setTimeout` und Event-Handlern**  
```javascript
function verzÃ¶gerteNachricht(nachricht, delay) {
  setTimeout(function() {
    console.log(nachricht);
  }, delay);
}

verzÃ¶gerteNachricht("Hallo nach 2 Sekunden!", 2000);
```
- Die innere Funktion speichert `nachricht` und `delay`, bis `setTimeout` sie ausfÃ¼hrt.

---

## **4. Closure in einer Schleife (Problem & LÃ¶sung)**  
âŒ **Problem mit `var` (kein Block-Scope)**  
```javascript
for (var i = 1; i <= 3; i++) {
  setTimeout(function() {
    console.log(i);
  }, i * 1000);
}
// Ausgabe nach 3 Sekunden: 4, 4, 4 (falsche Werte!)
```
âœ… **LÃ¶sung mit `let` (Block-Scope)**  
```javascript
for (let i = 1; i <= 3; i++) {
  setTimeout(function() {
    console.log(i);
  }, i * 1000);
}
// Ausgabe: 1, 2, 3 (korrekt)
```
âœ… **Alternative LÃ¶sung mit Closure (`var`)**  
```javascript
for (var i = 1; i <= 3; i++) {
  (function(j) {
    setTimeout(function() {
      console.log(j);
    }, j * 1000);
  })(i);
}
```
- Hier wird `i` als Parameter (`j`) an eine sofort ausgefÃ¼hrte Funktion (`IIFE`) Ã¼bergeben.

---

### **Zusammenfassung**  
- **Closures** ermÃ¶glichen Zugriff auf Variablen einer Ã¤uÃŸeren Funktion, auch nach deren AusfÃ¼hrung.  
- **NÃ¼tzlich fÃ¼r**:
  - **Datenkapselung** (private Variablen).
  - **Callbacks und Event-Handler**.
  - **Speicherung von Werten Ã¼ber Zeit** (z. B. `setTimeout`).  
- **Probleme mit `var`** â†’ Verwende `let` oder eine IIFE-LÃ¶sung.

ğŸ”— [MDN-Dokumentation zu Closures](https://developer.mozilla.org/de/docs/Web/JavaScript/Closures)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

24. ### <a name="24"></a> Callback-Funktionen in JavaScript

### **Callback-Funktionen in JavaScript**  

Eine **Callback-Funktion** ist eine Funktion, die als Argument an eine andere Funktion Ã¼bergeben wird und **zu einem spÃ¤teren Zeitpunkt** aufgerufen wird. Callbacks sind essenziell fÃ¼r **asynchrone Operationen** (z. B. `setTimeout`, Event-Handling, HTTP-Anfragen).

---

## **1. Einfaches Beispiel fÃ¼r Callbacks**  
```javascript
function begruessen(name, callback) {
  console.log(`Hallo, ${name}!`);
  callback();
}

function verabschieden() {
  console.log("TschÃ¼ss!");
}

begruessen("Max", verabschieden);
// Hallo, Max!
// TschÃ¼ss!
```
âœ… **ErklÃ¤rung**:
- `verabschieden` wird als **Callback** an `begruessen` Ã¼bergeben.
- Nach der BegrÃ¼ÃŸung wird `callback()` ausgefÃ¼hrt.

---

## **2. Callbacks mit `setTimeout` (asynchrones Verhalten)**  
```javascript
function ladeDaten(callback) {
  console.log("Daten werden geladen...");
  setTimeout(() => {
    console.log("Daten erfolgreich geladen.");
    callback();
  }, 2000);
}

function verarbeiteDaten() {
  console.log("Daten werden verarbeitet...");
}

ladeDaten(verarbeiteDaten);
/*
Daten werden geladen...
(Daten werden nach 2 Sekunden geladen)
Daten erfolgreich geladen.
Daten werden verarbeitet...
*/
```
âœ… **ErklÃ¤rung**:
- `ladeDaten()` simuliert eine **asynchrone Operation**.
- Nach 2 Sekunden wird `callback()` (`verarbeiteDaten()`) ausgefÃ¼hrt.

---

## **3. Callbacks in Arrays (z. B. `forEach`, `map`, `filter`)**
```javascript
const zahlen = [1, 2, 3, 4, 5];

zahlen.forEach((zahl) => {
  console.log(zahl * 2);
});
/*
2
4
6
8
10
*/
```
- `forEach()` nimmt eine **Callback-Funktion** als Argument.
- Die Callback-Funktion wird fÃ¼r jedes Element des Arrays ausgefÃ¼hrt.

---

## **4. Callback Hell (verschachtelte Callbacks)**
**Problem**: Wenn Callbacks tief verschachtelt werden, entsteht **"Callback Hell"** (schwer lesbarer Code).

```javascript
function schritt1(callback) {
  setTimeout(() => {
    console.log("Schritt 1 erledigt");
    callback();
  }, 1000);
}

function schritt2(callback) {
  setTimeout(() => {
    console.log("Schritt 2 erledigt");
    callback();
  }, 1000);
}

function schritt3(callback) {
  setTimeout(() => {
    console.log("Schritt 3 erledigt");
    callback();
  }, 1000);
}

schritt1(() => {
  schritt2(() => {
    schritt3(() => {
      console.log("Alle Schritte erledigt!");
    });
  });
});
```
âŒ **Problem:** Der Code ist schwer zu lesen und zu warten.

âœ… **LÃ¶sung:** Verwende **Promises** oder **async/await** statt Callbacks.

---

### **Zusammenfassung**  
- **Callback-Funktionen** werden als Argumente an andere Funktionen Ã¼bergeben und spÃ¤ter ausgefÃ¼hrt.  
- NÃ¼tzlich fÃ¼r **asynchrone Operationen** (z. B. `setTimeout`, HTTP-Anfragen, Events).  
- **Array-Methoden** wie `forEach`, `map`, `filter` verwenden Callbacks.  
- **Callback Hell** (tiefe Verschachtelung) â†’ Ersetze Callbacks durch **Promises** oder **async/await**.

ğŸ”— [MDN-Dokumentation zu Callbacks](https://developer.mozilla.org/de/docs/Glossary/Callback-Funktion)  

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

25. ### <a name="25"></a> Konstruktor-Funktionen

In JavaScript sind **Konstruktor-Funktionen** spezielle Funktionen, die zur Erstellung von Objekten verwendet werden. Sie werden mit dem SchlÃ¼sselwort `new` aufgerufen und ermÃ¶glichen die Wiederverwendung von Objektstrukturen.

### **Syntax einer Konstruktor-Funktion**
```javascript
function Person(name, alter) {
  this.name = name; // Eigenschaft "name"
  this.alter = alter; // Eigenschaft "alter"

  this.greet = function() {
    console.log(`Hallo, mein Name ist ${this.name} und ich bin ${this.alter} Jahre alt.`);
  };
}

const person1 = new Person("Max", 30);
const person2 = new Person("Anna", 25);

person1.greet(); // Hallo, mein Name ist Max und ich bin 30 Jahre alt.
person2.greet(); // Hallo, mein Name ist Anna und ich bin 25 Jahre alt.
```
- Das SchlÃ¼sselwort `this` referenziert das erstellte Objekt.
- `new Person("Max", 30)` erzeugt ein neues Objekt mit den Eigenschaften `name` und `alter`.

### **Prototyp-Methode statt Direktdefinition**
Jede Instanz einer Konstruktor-Funktion erhÃ¤lt eine eigene Kopie der Methoden. Eine effizientere LÃ¶sung ist die Verwendung des **Prototyps**, da Methoden dann von allen Instanzen geteilt werden:

```javascript
function Person(name, alter) {
  this.name = name;
  this.alter = alter;
}

// Methode im Prototyp definieren (spart Speicherplatz)
Person.prototype.greet = function() {
  console.log(`Hallo, mein Name ist ${this.name} und ich bin ${this.alter} Jahre alt.`);
};

const person3 = new Person("Lena", 28);
person3.greet(); // Hallo, mein Name ist Lena und ich bin 28 Jahre alt.
```

### **Zusammenfassung**
- Konstruktor-Funktionen werden mit `new` aufgerufen.
- `this` verweist auf die erstellte Instanz.
- Methoden sollten Ã¼ber `prototype` hinzugefÃ¼gt werden, um Speicher zu sparen.

ğŸ”— [MDN-Dokumentation zu Konstruktor-Funktionen](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Operators/new)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

26. ### <a name="26"></a> Aufrufkontext (this)

Der **Aufrufkontext (`this`)** in JavaScript bestimmt, auf welches Objekt sich `this` innerhalb einer Funktion oder Methode bezieht. Der Wert von `this` hÃ¤ngt davon ab, wie die Funktion aufgerufen wird.

### **1. Globaler Kontext (`this` in der obersten Ebene)**
Im globalen Kontext verweist `this`:
- Im **Browser** auf das `window`-Objekt.
- In **Node.js** auf `global`.

```javascript
console.log(this); // Im Browser: window, in Node.js: global
```

### **2. `this` in einer Funktion**
Ohne `use strict` verweist `this` in einer normalen Funktion auf das globale Objekt. Mit `"use strict"` ist `this` `undefined`.

```javascript
function test() {
  console.log(this);
}

test(); // Browser: window, Node.js: global (ohne strict)
```

Mit **strict mode**:

```javascript
"use strict";
function testStrict() {
  console.log(this);
}

testStrict(); // undefined
```

### **3. `this` in Objekten (Methoden)**
Wird eine Funktion als Methode eines Objekts aufgerufen, verweist `this` auf das Objekt selbst.

```javascript
const person = {
  name: "Max",
  greet: function() {
    console.log(`Hallo, ich bin ${this.name}`);
  }
};

person.greet(); // Hallo, ich bin Max
```

### **4. `this` in Konstruktor-Funktionen**
Bei Konstruktor-Funktionen verweist `this` auf die neu erstellte Instanz.

```javascript
function Person(name) {
  this.name = name;
}

const max = new Person("Max");
console.log(max.name); // Max
```

### **5. `this` in Arrow-Funktionen**
Arrow-Funktionen Ã¼bernehmen `this` aus dem umgebenden Lexikalischen Kontext (kein eigenes `this`!).

```javascript
const person = {
  name: "Anna",
  greet: function() {
    const arrowFunction = () => console.log(this.name);
    arrowFunction(); // this bleibt auf `person` bezogen
  }
};

person.greet(); // Anna
```

### **6. Explizite Steuerung von `this` (`call`, `apply`, `bind`)**
Man kann `this` manuell setzen mit `call()`, `apply()` oder `bind()`.

```javascript
function greet() {
  console.log(`Hallo, ich bin ${this.name}`);
}

const user = { name: "Lisa" };

greet.call(user);  // Hallo, ich bin Lisa
greet.apply(user); // Hallo, ich bin Lisa

const boundGreet = greet.bind(user);
boundGreet(); // Hallo, ich bin Lisa
```

### **Zusammenfassung**
- `this` hÃ¤ngt vom **Aufrufkontext** ab.
- In einer **Funktion** (strict mode) ist `this` `undefined`, sonst `window/global`.
- In **Methoden** zeigt `this` auf das aufrufende Objekt.
- In **Konstruktoren** verweist `this` auf die erstellte Instanz.
- **Arrow-Funktionen** haben kein eigenes `this`, sondern Ã¼bernehmen es aus der Umgebung.
- **`call`, `apply`, `bind`** erlauben das manuelle Setzen von `this`.

ğŸ”— [MDN-Dokumentation zu `this`](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Operators/this)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

27. ### <a name="27"></a> Getter und Setter (Objekteigenschaften)

In JavaScript ermÃ¶glichen **Getter** und **Setter** den kontrollierten Zugriff auf Objekteigenschaften. Sie werden mit `get` und `set` innerhalb eines Objekts oder einer Klasse definiert.

---

### **1. Getter (`get`)**
Getter sind Methoden, die eine Eigenschaft abrufen, aber wie normale Eigenschaften verwendet werden.

```javascript
const person = {
  vorname: "Max",
  nachname: "Mustermann",
  
  get vollerName() {
    return `${this.vorname} ${this.nachname}`;
  }
};

console.log(person.vollerName); // Max Mustermann
```
- `vollerName` wird als Eigenschaft aufgerufen (`person.vollerName`), aber intern als Methode definiert.

---

### **2. Setter (`set`)**
Setter ermÃ¶glichen das Festlegen von Eigenschaftswerten und kÃ¶nnen Validierung oder Formatierung enthalten.

```javascript
const user = {
  _alter: 0, // Private Variable (Konvention: Unterstrich)

  get alter() {
    return this._alter;
  },

  set alter(value) {
    if (value < 0) {
      console.log("Alter kann nicht negativ sein!");
    } else {
      this._alter = value;
    }
  }
};

user.alter = 25;
console.log(user.alter); // 25

user.alter = -5; // Alter kann nicht negativ sein!
```
- Der `set`-Methodenaufruf `user.alter = -5` verhindert ungÃ¼ltige Werte.

---

### **3. Getter und Setter in Klassen**
In Klassen kÃ¶nnen Getter und Setter auf Instanzvariablen zugreifen.

```javascript
class Auto {
  constructor(marke, baujahr) {
    this.marke = marke;
    this._baujahr = baujahr; // Private Variable
  }

  get baujahr() {
    return this._baujahr;
  }

  set baujahr(value) {
    if (value < 1886) {
      console.log("UngÃ¼ltiges Baujahr!");
    } else {
      this._baujahr = value;
    }
  }
}

const meinAuto = new Auto("Tesla", 2022);
console.log(meinAuto.baujahr); // 2022

meinAuto.baujahr = 1800; // UngÃ¼ltiges Baujahr!
```

---

### **Zusammenfassung**
- **Getter (`get`)**: Erlauben den kontrollierten Zugriff auf Eigenschaften.
- **Setter (`set`)**: ErmÃ¶glichen das Setzen und Validieren von Werten.
- Werden oft fÃ¼r **Datenkapselung** verwendet.
- KÃ¶nnen in **Objekten** und **Klassen** definiert werden.

ğŸ”— [MDN-Dokumentation zu Getter und Setter](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Functions/get)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

28. ### <a name="28"></a> Generatorfunktionen in JavaScript

### **Generatorfunktionen in JavaScript**
Generatorfunktionen (`function*`) ermÃ¶glichen das **pausieren und fortsetzen** der CodeausfÃ¼hrung mit `yield`. Sie sind besonders nÃ¼tzlich fÃ¼r iterative Prozesse und Lazy Evaluation.

---

### **1. Syntax einer Generatorfunktion**
```javascript
function* meineGeneratorFunktion() {
  yield 1;
  yield 2;
  yield 3;
}

const generator = meineGeneratorFunktion();

console.log(generator.next()); // { value: 1, done: false }
console.log(generator.next()); // { value: 2, done: false }
console.log(generator.next()); // { value: 3, done: false }
console.log(generator.next()); // { value: undefined, done: true }
```
- Das `yield`-SchlÃ¼sselwort pausiert die Funktion und gibt einen Wert zurÃ¼ck.
- `next()` setzt die Funktion an der letzten `yield`-Stelle fort.

---

### **2. Generator in einer Schleife**
Man kann Generatoren mit `for...of` durchlaufen:

```javascript
function* zahlenGenerator() {
  yield 10;
  yield 20;
  yield 30;
}

for (const zahl of zahlenGenerator()) {
  console.log(zahl);
}
// 10
// 20
// 30
```

---

### **3. Unendliche Generatoren**
Generatoren kÃ¶nnen **endlos laufen**, ohne den Speicher zu Ã¼berlasten:

```javascript
function* unendlicherZÃ¤hler() {
  let i = 1;
  while (true) {
    yield i++;
  }
}

const counter = unendlicherZÃ¤hler();
console.log(counter.next().value); // 1
console.log(counter.next().value); // 2
console.log(counter.next().value); // 3
```

---

### **4. `yield` mit Parametern**
Man kann `next(value)` verwenden, um Werte an den Generator zurÃ¼ckzugeben:

```javascript
function* bidirektionalerGenerator() {
  const wert1 = yield "Erster Wert?";
  const wert2 = yield `Zweiter Wert ist ${wert1}`;
  return `Dritter Wert ist ${wert2}`;
}

const gen = bidirektionalerGenerator();
console.log(gen.next().value);      // "Erster Wert?"
console.log(gen.next(42).value);    // "Zweiter Wert ist 42"
console.log(gen.next(100).value);   // "Dritter Wert ist 100"
```

---

### **5. `yield*` fÃ¼r geschachtelte Generatoren**
Mit `yield*` kann man einen anderen Generator aufrufen:

```javascript
function* unterGenerator() {
  yield "A";
  yield "B";
}

function* hauptGenerator() {
  yield* unterGenerator();
  yield "C";
}

for (const wert of hauptGenerator()) {
  console.log(wert);
}
// A
// B
// C
```

---

### **Zusammenfassung**
- Generatorfunktionen (`function*`) erlauben das **pausieren und fortsetzen** der CodeausfÃ¼hrung.
- `yield` gibt einen Wert zurÃ¼ck, `next()` setzt die Funktion fort.
- Generatoren eignen sich fÃ¼r **Lazy Evaluation, unendliche Sequenzen** und **asynchrone Verarbeitung**.
- `yield*` ermÃ¶glicht das Delegieren an andere Generatoren.

ğŸ”— [MDN-Dokumentation zu Generatorfunktionen](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Statements/function*)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

29. ### <a name="29"></a> Rekursion in JavaScript

### **Rekursion in JavaScript**
Rekursion bedeutet, dass eine Funktion sich **selbst aufruft**, bis eine **Abbruchbedingung** erreicht ist. Sie wird oft fÃ¼r Probleme mit **natÃ¼rlicher Teilung** verwendet, z. B. Baumstrukturen oder mathematische Berechnungen.

---

### **1. Einfaches Beispiel: Countdown**
```javascript
function countdown(n) {
  if (n <= 0) {
    console.log("Fertig!");
    return;
  }
  console.log(n);
  countdown(n - 1); // Rekursiver Aufruf
}

countdown(5);
/*
5
4
3
2
1
Fertig!
*/
```
- Die Funktion ruft sich mit `n - 1` selbst auf.
- Sobald `n <= 0`, stoppt die Rekursion (**Abbruchbedingung**).

---

### **2. FakultÃ¤t berechnen (n!)**
Die **FakultÃ¤t** eines Zahl `n` ist `n * (n-1) * (n-2) * ... * 1`.

```javascript
function fakultaet(n) {
  if (n === 0) return 1; // Abbruchbedingung
  return n * fakultaet(n - 1); // Rekursiver Aufruf
}

console.log(fakultaet(5)); // 120 (5*4*3*2*1)
```
- Ohne Abbruchbedingung wÃ¼rde die Funktion **unendlich laufen**.

---

### **3. Fibonacci-Folge**
Die **Fibonacci-Zahlen** sind definiert als:
- `fib(0) = 0`, `fib(1) = 1`
- `fib(n) = fib(n-1) + fib(n-2)`

```javascript
function fibonacci(n) {
  if (n <= 1) return n; // BasisfÃ¤lle
  return fibonacci(n - 1) + fibonacci(n - 2);
}

console.log(fibonacci(6)); // 8 (0,1,1,2,3,5,8)
```
âŒ **Problem:** Rekursion kann ineffizient sein, da viele Werte mehrfach berechnet werden.

âœ… **LÃ¶sung:** **Memoization** zur Optimierung:

```javascript
function fibonacciMemo(n, memo = {}) {
  if (n in memo) return memo[n];
  if (n <= 1) return n;
  
  memo[n] = fibonacciMemo(n - 1, memo) + fibonacciMemo(n - 2, memo);
  return memo[n];
}

console.log(fibonacciMemo(50)); // Sehr schnelle Berechnung
```

---

### **4. Rekursion fÃ¼r verschachtelte Strukturen (Baum-Durchlauf)**
Rekursion ist ideal fÃ¼r **hierarchische Daten**, wie verschachtelte Objekte oder BÃ¤ume.

```javascript
const baum = {
  wert: 1,
  kinder: [
    { wert: 2, kinder: [{ wert: 4 }, { wert: 5 }] },
    { wert: 3, kinder: [{ wert: 6 }] }
  ]
};

function durchlaufeBaum(knoten) {
  console.log(knoten.wert);
  if (knoten.kinder) {
    knoten.kinder.forEach(durchlaufeBaum);
  }
}

durchlaufeBaum(baum);
/*
1
2
4
5
3
6
*/
```
- Die Funktion ruft sich **fÃ¼r jedes Kind** des Knotens auf.

---

### **5. Tail Call Optimization (TCO)**
Moderne JavaScript-Engines optimieren **Tail-Recursive-Funktionen** (wenn der letzte Ausdruck ein rekursiver Aufruf ist), um **Stack-ÃœberlÃ¤ufe zu vermeiden**.

```javascript
function summe(n, akk = 0) {
  if (n === 0) return akk;
  return summe(n - 1, akk + n); // Tail Call (optimierbar)
}

console.log(summe(10000)); // Kein Stack Overflow in TCO-fÃ¤higen Umgebungen
```

---

### **Zusammenfassung**
- **Rekursion** bedeutet, dass eine Funktion sich **selbst aufruft**.
- **Wichtig:** Immer eine **Abbruchbedingung** (`if`) definieren, um Endlosschleifen zu vermeiden.
- **Memoization** kann ineffiziente Rekursion optimieren.
- **Ideal fÃ¼r:** Mathematische Probleme, hierarchische Strukturen (BÃ¤ume), Algorithmen wie Tiefensuche.
- **Tail Call Optimization (TCO)** reduziert Speicherverbrauch, aber nicht in allen JavaScript-Engines unterstÃ¼tzt.

ğŸ”— [MDN-Dokumentation zu Rekursion](https://developer.mozilla.org/de/docs/Glossary/Rekursion)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

30. ### <a name="30"></a> Memoization

### **Memoization in JavaScript**  

ğŸ“Œ **Memoization ist eine Optimierungstechnik**, bei der **Funktionen Zwischenergebnisse speichern**, um wiederholte Berechnungen zu vermeiden.  
Das verbessert die **Performance**, insbesondere bei **teuren Berechnungen oder rekursiven Funktionen**.

---

## **1. Einfache Memoization mit einem Objekt (`{}`)**  
ğŸ“Œ **Speichert bereits berechnete Ergebnisse in einem Cache (Objekt).**  
```javascript
function memoize(fn) {
  const cache = {};
  return function (...args) {
    const key = JSON.stringify(args);
    if (cache[key]) {
      console.log("Cache-Hit:", key);
      return cache[key]; // Gibt das gespeicherte Ergebnis zurÃ¼ck
    }
    console.log("Cache-Miss:", key);
    const result = fn(...args);
    cache[key] = result;
    return result;
  };
}

// Beispiel: Teure Berechnung
function teureBerechnung(x) {
  console.log("Teure Berechnung fÃ¼r:", x);
  return x * x;
}

const memoizedBerechnung = memoize(teureBerechnung);

console.log(memoizedBerechnung(5)); // âœ… Teure Berechnung â†’ 25
console.log(memoizedBerechnung(5)); // âœ… Cache-Hit â†’ 25 (ohne Berechnung)
console.log(memoizedBerechnung(10)); // âœ… Teure Berechnung â†’ 100
```
âœ… **Reduziert wiederholte Berechnungen & spart Rechenzeit**  

---

## **2. Memoization fÃ¼r Rekursion (Fibonacci-Funktion)**
ğŸ“Œ **Memoization ist besonders nÃ¼tzlich fÃ¼r rekursive Funktionen, wie Fibonacci.**  
```javascript
function memoize(fn) {
  const cache = {};
  return function (n) {
    if (n in cache) return cache[n]; // Cache-Hit
    cache[n] = fn(n);
    return cache[n];
  };
}

const fibonacci = memoize(function (n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
});

console.log(fibonacci(10)); // âœ… Schneller als normale Rekursion
console.log(fibonacci(40)); // âœ… Ohne Memoization extrem langsam!
```
âœ… **Verringert exponentielle Rekursionszeit â†’ von `O(2^n)` auf `O(n)`**  

---

## **3. Memoization mit `Map()` fÃ¼r besseren Cache**
ğŸ“Œ **Verwendet `Map()`, um Objekte als SchlÃ¼ssel zu unterstÃ¼tzen.**  
```javascript
function memoize(fn) {
  const cache = new Map();
  return function (...args) {
    const key = args.join(",");
    if (cache.has(key)) return cache.get(key);
    const result = fn(...args);
    cache.set(key, result);
    return result;
  };
}
```
âœ… **Bessere Performance als `{}` durch `Map()` fÃ¼r komplexe SchlÃ¼ssel.**  

---

### **Zusammenfassung**
| Feature | Vorteile |
|---------|----------|
| **Memoization** | Speichert Ergebnisse fÃ¼r wiederholte Berechnungen |
| **Cache mit `{}`** | Einfach, aber nur fÃ¼r Strings als SchlÃ¼ssel |
| **Cache mit `Map()`** | Besser fÃ¼r komplexe SchlÃ¼ssel |
| **Besonders nÃ¼tzlich fÃ¼r** | Rekursion, teure API-Calls, komplexe Berechnungen |

ğŸ”— [MDN-Dokumentation zu Memoization](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

31. ### <a name="31"></a> Objekte, Destrukturierung von Objekten (ES6)

### **Objekte & Destrukturierung von Objekten (ES6) in JavaScript**  

---

## **1. Objekte in JavaScript**  
Ein **Objekt** ist eine Sammlung von **SchlÃ¼ssel-Wert-Paaren**.

```javascript
const person = {
  name: "Max",
  alter: 30,
  beruf: "Entwickler"
};

console.log(person.name);  // Max
console.log(person["alter"]); // 30
```
âœ… **Eigenschaften von Objekten**:  
- Werte kÃ¶nnen **beliebige Datentypen** sein (Strings, Arrays, andere Objekte).
- Zugriff Ã¼ber **Punkt-Notation (`.`)** oder **Array-Notation (`[]`)**.

---

## **2. ES6-Destrukturierung von Objekten**  
Mit **Destrukturierung** kann man **Eigenschaften direkt extrahieren**.

```javascript
const person = { name: "Anna", alter: 25, beruf: "Designer" };

const { name, alter } = person;

console.log(name); // Anna
console.log(alter); // 25
```
âœ… **Vorteile**:  
- Spart **Schreibarbeit** (`person.name` â†’ `name`).
- Einfachere **Funktionseingaben**.

---

## **3. Destrukturierung mit Standardwerten**
Falls eine Eigenschaft **nicht existiert**, kann ein **Standardwert** gesetzt werden.

```javascript
const user = { name: "Lisa" };

const { name, alter = 18 } = user;

console.log(alter); // 18 (Standardwert)
```

---

## **4. Umbenennung von Variablen bei der Destrukturierung**
Man kann Eigenschaftsnamen **umbenennen**.

```javascript
const auto = { marke: "Tesla", baujahr: 2023 };

const { marke: hersteller, baujahr } = auto;

console.log(hersteller); // Tesla
```

---

## **5. Destrukturierung in Funktionen**  
```javascript
function zeigeInfo({ name, alter }) {
  console.log(`${name} ist ${alter} Jahre alt.`);
}

const person = { name: "Tom", alter: 40 };
zeigeInfo(person); // Tom ist 40 Jahre alt.
```
âœ… **Vorteile**:  
- Die Funktion erhÃ¤lt direkt die **relevanten Werte**.

---

## **6. Verschachtelte Objekte destrukturieren**
```javascript
const student = {
  name: "Sophia",
  adresse: {
    stadt: "Berlin",
    land: "Deutschland"
  }
};

const { adresse: { stadt, land } } = student;

console.log(stadt); // Berlin
console.log(land); // Deutschland
```
âœ… **Hierbei wird `adresse` nicht als Variable erstellt!**  
Falls nÃ¶tig, kann man `adresse` zusÃ¤tzlich speichern:
```javascript
const { adresse, adresse: { stadt } } = student;
console.log(adresse); // { stadt: "Berlin", land: "Deutschland" }
```

---

### **Zusammenfassung**
- **Objekte** sind Sammlungen von SchlÃ¼ssel-Wert-Paaren.
- **Destrukturierung** vereinfacht den Zugriff auf Eigenschaften.
- **Standardwerte** kÃ¶nnen gesetzt werden.
- **Eigenschaftsnamen kÃ¶nnen umbenannt werden**.
- **Verschachtelte Objekte** lassen sich destrukturieren.
- **NÃ¼tzlich in Funktionen**, um nur relevante Daten zu extrahieren.

ğŸ”— [MDN-Dokumentation zur Destrukturierung](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Operators/Destrukturierende_Zuweisung)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

32. ### <a name="32"></a> Methoden Object, Object.prototype

### **Methoden von `Object` & `Object.prototype` in JavaScript**

In JavaScript gibt es zwei Kategorien von Methoden fÃ¼r Objekte:

1. **`Object`-Methoden** â†’ Statische Methoden von `Object`
2. **`Object.prototype`-Methoden** â†’ Methoden, die jedes Objekt erbt

---

## **1. `Object`-Methoden (statische Methoden)**
Diese Methoden werden direkt auf `Object` aufgerufen.

### **1.1 `Object.keys(obj)` â€“ Alle SchlÃ¼ssel eines Objekts**
```javascript
const person = { name: "Anna", alter: 28, beruf: "Designer" };

console.log(Object.keys(person)); // ["name", "alter", "beruf"]
```

### **1.2 `Object.values(obj)` â€“ Alle Werte eines Objekts**
```javascript
console.log(Object.values(person)); // ["Anna", 28, "Designer"]
```

### **1.3 `Object.entries(obj)` â€“ SchlÃ¼ssel-Wert-Paare als Array**
```javascript
console.log(Object.entries(person));
// [["name", "Anna"], ["alter", 28], ["beruf", "Designer"]]
```

### **1.4 `Object.assign(target, source)` â€“ Objekte zusammenfÃ¼hren**
```javascript
const obj1 = { a: 1 };
const obj2 = { b: 2 };
const merged = Object.assign({}, obj1, obj2);

console.log(merged); // { a: 1, b: 2 }
```

### **1.5 `Object.freeze(obj)` â€“ Objekt unverÃ¤nderlich machen**
```javascript
const buch = { titel: "JavaScript", preis: 30 };
Object.freeze(buch);

buch.preis = 40; // Fehler (im strikten Modus)
console.log(buch.preis); // 30 (unverÃ¤ndert)
```

### **1.6 `Object.seal(obj)` â€“ Keine neuen Eigenschaften, aber Ã„nderung erlaubt**
```javascript
const auto = { marke: "Tesla", farbe: "Rot" };
Object.seal(auto);

auto.farbe = "Blau"; // OK
auto.modell = "Model S"; // âŒ Fehler (Eigenschaft kann nicht hinzugefÃ¼gt werden)
console.log(auto); // { marke: "Tesla", farbe: "Blau" }
```

### **1.7 `Object.create(proto)` â€“ Neues Objekt mit bestimmtem Prototyp**
```javascript
const tier = { typ: "SÃ¤ugetier" };
const hund = Object.create(tier);

console.log(hund.typ); // "SÃ¤ugetier" (geerbt von `tier`)
```

---

## **2. `Object.prototype`-Methoden**
Diese Methoden sind fÃ¼r **alle Objekte verfÃ¼gbar**, weil sie von `Object.prototype` erben.

### **2.1 `obj.hasOwnProperty(prop)` â€“ PrÃ¼ft, ob eine Eigenschaft direkt existiert**
```javascript
const person = { name: "Max" };

console.log(person.hasOwnProperty("name")); // true
console.log(person.hasOwnProperty("alter")); // false
```
ğŸ”¹ **Warum wichtig?**  
Verhindert, dass geerbte Eigenschaften (`prototype`) fÃ¤lschlicherweise als eigene Eigenschaften interpretiert werden.

---

### **2.2 `obj.toString()` â€“ Objekt in String umwandeln**
```javascript
const zahl = 123;
console.log(zahl.toString()); // "123"

const array = [1, 2, 3];
console.log(array.toString()); // "1,2,3"
```

---

### **2.3 `obj.valueOf()` â€“ Gibt den PrimÃ¤rwert eines Objekts zurÃ¼ck**
```javascript
const num = new Number(42);
console.log(num.valueOf()); // 42
```

---

### **2.4 `obj.isPrototypeOf(obj2)` â€“ PrÃ¼ft, ob ein Objekt Prototyp eines anderen ist**
```javascript
function Tier() {}
const hund = new Tier();

console.log(Tier.prototype.isPrototypeOf(hund)); // true
```

---

### **Zusammenfassung**
- **`Object.keys()`**, **`Object.values()`**, **`Object.entries()`** â†’ Arbeiten mit Eigenschaften.
- **`Object.assign()`**, **`Object.create()`**, **`Object.freeze()`**, **`Object.seal()`** â†’ Objektverwaltung.
- **`hasOwnProperty()`** â†’ PrÃ¼ft, ob eine Eigenschaft direkt im Objekt existiert.
- **`toString()`**, **`valueOf()`** â†’ Umwandlung von Objekten in Strings oder primitive Werte.

ğŸ”— [MDN-Dokumentation zu `Object`](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Object)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

33. ### <a name="33"></a> MÃ¶glichkeiten zur Objekterstellung

### **MÃ¶glichkeiten zur Objekterstellung in JavaScript**  

In JavaScript gibt es mehrere MÃ¶glichkeiten, ein Objekt zu erstellen. Jede Methode hat ihre eigenen **AnwendungsfÃ¤lle und Vorteile**.

---

## **1. Objekt-Literal (`{}`)**
Die einfachste Methode, um ein Objekt zu erstellen.

```javascript
const person = {
  name: "Max",
  alter: 30,
  beruf: "Entwickler"
};

console.log(person.name); // Max
```
âœ… **Vorteile**:  
- Schnell und einfach fÃ¼r kleine Objekte  
- Kein `new` oder Prototyp erforderlich  

---

## **2. `Object.create(prototype)`**
Erstellt ein neues Objekt mit einem bestimmten **Prototyp**.

```javascript
const tier = {
  typ: "SÃ¤ugetier"
};

const hund = Object.create(tier);
hund.name = "Bello";

console.log(hund.typ); // "SÃ¤ugetier" (geerbt von `tier`)
console.log(hund.hasOwnProperty("typ")); // false (kommt aus dem Prototyp)
```
âœ… **Vorteile**:  
- Erlaubt direkte Kontrolle Ã¼ber den **Prototyp**  
- Gut fÃ¼r **Prototypen-Vererbung**  

---

## **3. `new Object()` (Konstruktor von `Object`)**
Alternative zu `{}`.

```javascript
const person = new Object();
person.name = "Anna";
person.alter = 25;

console.log(person.name); // Anna
```
âŒ **Weniger gebrÃ¤uchlich**, da `{}` kÃ¼rzer und verstÃ¤ndlicher ist.

---

## **4. Konstruktorfunktion**
Verwendet eine Funktion, um **mehrere Objekte mit Ã¤hnlicher Struktur** zu erstellen.

```javascript
function Person(name, alter) {
  this.name = name;
  this.alter = alter;
}

const person1 = new Person("Lisa", 28);
const person2 = new Person("Tom", 35);

console.log(person1.name); // Lisa
console.log(person2.alter); // 35
```
âœ… **Vorteile**:  
- ErmÃ¶glicht das Erstellen **mehrerer Instanzen**  
- `this` verweist auf das erstellte Objekt  
âŒ **Nachteile**:  
- Methoden werden bei jeder Instanz neu erstellt (besser `prototype` verwenden).  

---

## **5. Konstruktorfunktion mit `prototype` (Speichereffizienter)**
```javascript
function Auto(marke) {
  this.marke = marke;
}

Auto.prototype.fahren = function() {
  console.log(`${this.marke} fÃ¤hrt.`);
};

const meinAuto = new Auto("Tesla");
meinAuto.fahren(); // Tesla fÃ¤hrt.
```
âœ… **Speichert Methoden im Prototyp, nicht bei jeder Instanz**.

---

## **6. ES6 Klassen (`class`)**
Klassen sind eine modernere Alternative zu Konstruktorfunktionen.

```javascript
class Fahrzeug {
  constructor(marke) {
    this.marke = marke;
  }

  fahren() {
    console.log(`${this.marke} fÃ¤hrt.`);
  }
}

const auto = new Fahrzeug("BMW");
auto.fahren(); // BMW fÃ¤hrt.
```
âœ… **Vorteile**:  
- Klarere Syntax  
- Bessere Lesbarkeit fÃ¼r objektorientierte Programmierung  

---

## **7. Fabrikfunktion (Factory Function)**
Eine **Funktion, die Objekte zurÃ¼ckgibt**, ohne `new`.

```javascript
function erstellePerson(name, alter) {
  return {
    name,
    alter,
    sagHallo() {
      console.log(`Hallo, ich bin ${this.name}.`);
    }
  };
}

const person = erstellePerson("Markus", 40);
person.sagHallo(); // Hallo, ich bin Markus.
```
âœ… **Vorteile**:  
- Kein `new` erforderlich  
- Gut fÃ¼r **geschlossene (private) Variablen**  

---

## **8. JSON (`JSON.parse()` & `JSON.stringify()`)**
### **Objekt aus JSON-String erstellen**
```javascript
const jsonString = '{"name": "Elena", "alter": 22}';
const person = JSON.parse(jsonString);

console.log(person.name); // Elena
```

### **Objekt in JSON umwandeln**
```javascript
const jsonDaten = JSON.stringify(person);
console.log(jsonDaten); // {"name":"Elena","alter":22}
```
âœ… **Wichtig fÃ¼r:**  
- **DatenÃ¼bertragung (APIs)**  
- **Speicherung in `localStorage`**  

---

### **Zusammenfassung**
| Methode | Vorteile | Nachteile |
|---------|---------|-----------|
| **`{}` (Objekt-Literal)** | Einfach, direkt | Nicht fÃ¼r viele Instanzen |
| **`Object.create(proto)`** | Direktes Prototyp-Handling | Komplexe Vererbung |
| **`new Object()`** | Alternative zu `{}` | LÃ¤nger als `{}` |
| **Konstruktorfunktion (`new`)** | Strukturierte Erstellung | Methoden ineffizient ohne `prototype` |
| **Konstruktorfunktion mit `prototype`** | Speicheroptimiert | Weniger intuitiv als `class` |
| **`class` (ES6)** | Klarer, modernes OOP | Komplexer als einfache Objekte |
| **Fabrikfunktion (`Factory Function`)** | Kein `new`, einfach zu lesen | Kein direkter Prototypzugriff |
| **JSON (`JSON.parse()`)** | API-kompatibel | Kein Verhalten (Methoden) |

ğŸ”— [MDN-Dokumentation zu Objekten](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Object)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**  

34. ### <a name="34"></a> Kopieren von Objekten

### **Kopieren von Objekten in JavaScript**  

Beim Kopieren von Objekten in JavaScript gibt es zwei Arten:  

1. **Shallow Copy (flache Kopie)** â€“ Kopiert nur die erste Ebene der Eigenschaften (tiefer liegende Objekte bleiben referenziert).  
2. **Deep Copy (tiefe Kopie)** â€“ Erstellt eine vollstÃ¤ndige Kopie, auch von verschachtelten Objekten.  

---

## **1. Shallow Copy (Flache Kopie)**  

Flache Kopien duplizieren nur die **oberste Ebene** des Objekts. Falls das Objekt **verschachtelte Objekte** enthÃ¤lt, bleiben diese referenziert (Ã„nderungen im Original wirken sich auf die Kopie aus).  

### **1.1 `Object.assign(target, source)`**
```javascript
const original = { a: 1, b: { c: 2 } };
const kopie = Object.assign({}, original);

kopie.a = 42;
kopie.b.c = 99; // Achtung: Referenzierte Objekte werden nicht kopiert!

console.log(original.b.c); // 99 (auch geÃ¤ndert!)
```

âœ… **Schnelle flache Kopie**  
âŒ **Nicht fÃ¼r verschachtelte Objekte geeignet**

---

### **1.2 Spread-Operator (`{ ...obj }`)**
```javascript
const original = { a: 1, b: { c: 2 } };
const kopie = { ...original };

kopie.a = 42;
kopie.b.c = 99; // Wieder nur eine Referenz!

console.log(original.b.c); // 99 (Original ebenfalls verÃ¤ndert!)
```
âœ… **Einfacher als `Object.assign()`**  
âŒ **Nur erste Ebene wird kopiert**

---

## **2. Deep Copy (Tiefe Kopie)**  

### **2.1 `JSON.parse(JSON.stringify(obj))` (einfache LÃ¶sung)**
```javascript
const original = { a: 1, b: { c: 2 } };
const kopie = JSON.parse(JSON.stringify(original));

kopie.b.c = 99;

console.log(original.b.c); // 2 (Original bleibt unverÃ¤ndert)
```
âœ… **Einfache Methode fÃ¼r tiefe Kopien**  
âŒ **Verliert Funktionen, `undefined`, Symbole**  

---

### **2.2 Rekursive Funktion fÃ¼r tiefe Kopie**
```javascript
function deepCopy(obj) {
  if (obj === null || typeof obj !== "object") return obj;

  const kopie = Array.isArray(obj) ? [] : {};

  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      kopie[key] = deepCopy(obj[key]);
    }
  }
  return kopie;
}

const original = { a: 1, b: { c: 2 } };
const kopie = deepCopy(original);

kopie.b.c = 99;

console.log(original.b.c); // 2 (Original bleibt unverÃ¤ndert)
```
âœ… **Kopiert auch Funktionen, Arrays, `undefined`**  
âŒ **Aufwendiger als `JSON.parse()`**

---

### **2.3 `structuredClone(obj)` (Moderne LÃ¶sung)**
```javascript
const original = { a: 1, b: { c: 2 }, d: new Date() };
const kopie = structuredClone(original);

kopie.b.c = 99;

console.log(original.b.c); // 2 (Original bleibt unverÃ¤ndert)
console.log(kopie.d instanceof Date); // true (Kopiert auch `Date`!)
```
âœ… **UnterstÃ¼tzt `Date`, Arrays, `Map`, `Set`**  
âœ… **Schnell & sicher**  
âŒ **Nicht in Ã¤lteren Browsern verfÃ¼gbar**  

---

### **Zusammenfassung**
| Methode | Typ | Vorteile | Nachteile |
|---------|-----|----------|------------|
| **`Object.assign({}, obj)`** | Flach | Schnell & einfach | Tiefe Objekte bleiben referenziert |
| **`{ ...obj }` (Spread)** | Flach | KÃ¼rzere Syntax | Keine tiefe Kopie |
| **`JSON.parse(JSON.stringify(obj))`** | Tief | Einfach & schnell | Verliert Methoden & `undefined` |
| **Rekursive Funktion** | Tief | Behandelt alle Datentypen | Komplexer |
| **`structuredClone(obj)`** | Tief | Beste moderne LÃ¶sung | Nicht Ã¼berall unterstÃ¼tzt |

ğŸ”— [MDN-Dokumentation zu `structuredClone()`](https://developer.mozilla.org/de/docs/Web/API/structuredClone)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

35. ### <a name="35"></a> Property Descriptors (Eigenschaftsbeschreibungen)

### **Property Descriptors (Eigenschaftsbeschreibungen) in JavaScript**  

Jede Eigenschaft eines Objekts hat **Eigenschaftsbeschreibungen** (**Property Descriptors**), die bestimmen, wie die Eigenschaft funktioniert. Diese kÃ¶nnen mit `Object.getOwnPropertyDescriptor()` und `Object.defineProperty()` verwaltet werden.

---

## **1. Property Descriptor auslesen**
Mit `Object.getOwnPropertyDescriptor(obj, prop)` kann man die Eigenschaften einer Eigenschaft abrufen.

```javascript
const person = { name: "Max" };

console.log(Object.getOwnPropertyDescriptor(person, "name"));
/*
{
  value: 'Max',
  writable: true,
  enumerable: true,
  configurable: true
}
*/
```

âœ… **Standardwerte fÃ¼r eine Eigenschaft**:  
- `writable: true` â†’ Wert kann geÃ¤ndert werden  
- `enumerable: true` â†’ Eigenschaft wird in Schleifen (`for...in`, `Object.keys()`) angezeigt  
- `configurable: true` â†’ Eigenschaft kann gelÃ¶scht oder verÃ¤ndert werden  

---

## **2. Eigenschaften mit `Object.defineProperty()` setzen**  
Mit `Object.defineProperty(obj, prop, descriptor)` kann man Eigenschaften **kontrollierter definieren**.

### **2.1 `writable: false` â€“ Schreibschutz aktivieren**
```javascript
const auto = {};
Object.defineProperty(auto, "marke", {
  value: "Tesla",
  writable: false
});

auto.marke = "BMW"; // âŒ Keine Ã„nderung mÃ¶glich!
console.log(auto.marke); // "Tesla"
```

---

### **2.2 `enumerable: false` â€“ Eigenschaft verstecken**
```javascript
const benutzer = { name: "Anna", passwort: "geheim" };

Object.defineProperty(benutzer, "passwort", {
  enumerable: false
});

console.log(Object.keys(benutzer)); // ["name"] (passwort wird nicht angezeigt)
```
âœ… **Gut fÃ¼r sensible Daten!**

---

### **2.3 `configurable: false` â€“ Eigenschaft gegen Ã„nderungen sperren**
```javascript
const buch = { titel: "JavaScript Guide" };

Object.defineProperty(buch, "titel", {
  configurable: false
});

// LÃ¶schen schlÃ¤gt fehl:
delete buch.titel; 
console.log(buch.titel); // "JavaScript Guide"

// `configurable: false` verhindert Neudefinition:
Object.defineProperty(buch, "titel", { writable: true }); // âŒ Fehler!
```
âœ… **SchÃ¼tzt eine Eigenschaft vor Modifikationen oder LÃ¶schung**

---

## **3. Getter & Setter mit `defineProperty()`**
Man kann auch Getter und Setter definieren.

```javascript
const konto = {
  _saldo: 1000
};

Object.defineProperty(konto, "saldo", {
  get() {
    return `${this._saldo} EUR`;
  },
  set(value) {
    if (value < 0) {
      console.log("Saldo kann nicht negativ sein!");
    } else {
      this._saldo = value;
    }
  }
});

console.log(konto.saldo); // "1000 EUR"
konto.saldo = 500; 
console.log(konto.saldo); // "500 EUR"
konto.saldo = -200; // âŒ "Saldo kann nicht negativ sein!"
```
âœ… **Steuert den Zugriff auf eine Eigenschaft durch Regeln**

---

### **Zusammenfassung**
| Eigenschaft | Bedeutung |
|------------|-----------|
| `value` | Der Wert der Eigenschaft |
| `writable` | Kann der Wert geÃ¤ndert werden? (`true` / `false`) |
| `enumerable` | Wird die Eigenschaft in `Object.keys()` und Schleifen (`for...in`) angezeigt? |
| `configurable` | Kann die Eigenschaft gelÃ¶scht oder verÃ¤ndert werden? |
| `get()` | Gibt einen Wert zurÃ¼ck (Getter) |
| `set(value)` | Setzt einen Wert mit Logik (Setter) |

ğŸ”— [MDN-Dokumentation zu Property Descriptors](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

36. ### <a name="36"></a> Private und geschÃ¼tzte Eigenschaften von Objekten

### **Private und geschÃ¼tzte Eigenschaften von Objekten in JavaScript**  

JavaScript bietet verschiedene MÃ¶glichkeiten, **private** oder **geschÃ¼tzte Eigenschaften** zu definieren, um Daten **vor direktem Zugriff zu schÃ¼tzen**.

---

## **1. Konvention: `_` fÃ¼r "geschÃ¼tzte" Eigenschaften**  
Es gibt **keine echte Privateigenschaft** in normalen Objekten, aber Konventionen helfen:

```javascript
class Nutzer {
  constructor(name) {
    this.name = name;
    this._passwort = "geheim"; // GeschÃ¼tzt (Konvention: `_`)
  }

  zeigePasswort() {
    return this._passwort;
  }
}

const user = new Nutzer("Anna");
console.log(user._passwort); // âŒ Sollte nicht direkt genutzt werden
console.log(user.zeigePasswort()); // âœ… "geheim"
```
âœ… **NÃ¼tzlich, aber nicht wirklich privat!**  
âŒ **Jeder kann `_passwort` trotzdem lesen und Ã¤ndern!**

---

## **2. Private Eigenschaften mit `#` (ES2020+)**
Seit ES2020 kÃ¶nnen **private Eigenschaften** mit `#` definiert werden. Sie sind **auÃŸerhalb der Klasse nicht zugÃ¤nglich**.

```javascript
class Konto {
  #saldo = 1000; // Private Variable mit `#`

  getSaldo() {
    return this.#saldo;
  }

  einzahlen(betrag) {
    if (betrag > 0) this.#saldo += betrag;
  }
}

const meinKonto = new Konto();
console.log(meinKonto.getSaldo()); // âœ… 1000
meinKonto.einzahlen(500);
console.log(meinKonto.getSaldo()); // âœ… 1500

console.log(meinKonto.#saldo); // âŒ Fehler: Private Eigenschaft nicht zugÃ¤nglich!
```
âœ… **Echte Privateigenschaften** (nicht von auÃŸen sichtbar)  
âŒ **Nicht kompatibel mit Ã¤lteren JavaScript-Versionen**

---

## **3. Private Eigenschaften mit Closures (Ã¤ltere Alternative)**
Vor ES2020 wurden Closures genutzt, um Eigenschaften **privat zu halten**:

```javascript
function erstelleKonto() {
  let saldo = 1000; // Private Variable

  return {
    getSaldo: () => saldo,
    einzahlen: (betrag) => { if (betrag > 0) saldo += betrag; }
  };
}

const konto = erstelleKonto();
console.log(konto.getSaldo()); // âœ… 1000
konto.einzahlen(500);
console.log(konto.getSaldo()); // âœ… 1500

console.log(konto.saldo); // âŒ `saldo` ist nicht zugÃ¤nglich!
```
âœ… **Private Daten sind geschÃ¼tzt**  
âŒ **Nicht so intuitiv wie `class` mit `#`**

---

## **4. `WeakMap` fÃ¼r private Eigenschaften**
Eine andere Technik ist die Nutzung von `WeakMap`, um private Eigenschaften auÃŸerhalb des Objekts zu speichern.

```javascript
const privateDaten = new WeakMap();

class Benutzer {
  constructor(name) {
    privateDaten.set(this, { passwort: "geheim" });
    this.name = name;
  }

  getPasswort() {
    return privateDaten.get(this).passwort;
  }
}

const benutzer = new Benutzer("Tom");
console.log(benutzer.getPasswort()); // âœ… "geheim"

console.log(benutzer.passwort); // âŒ `undefined`
```
âœ… **Sicherer als `_`-Konvention, aber komplexer**  
âœ… **Privat, da `WeakMap`-Werte nicht direkt zugÃ¤nglich sind**  
âŒ **Mehr Overhead als `#`-Privateigenschaften**

---

### **Zusammenfassung**
| Methode | Privat? | Einfachheit | KompatibilitÃ¤t |
|---------|---------|------------|---------------|
| `_geschÃ¼tzt` (Konvention) | âŒ Nein | âœ… Einfach | âœ… Ãœberall |
| `#privat` (ES2020+) | âœ… Ja | âœ… Einfach | âŒ Nicht in Ã¤lteren Browsern |
| **Closure (Funktion + `let`)** | âœ… Ja | âŒ UmstÃ¤ndlich | âœ… Ãœberall |
| `WeakMap` | âœ… Ja | âŒ Komplexer | âœ… Ãœberall |

ğŸ”— [MDN-Dokumentation zu privaten Feldern (`#`)](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Classes/Private_class_fields)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

37. ### <a name="37"></a> Prototypen, Prototypen-Kette

### **Prototypen und Prototypen-Kette in JavaScript**  

In JavaScript basiert die **Objektvererbung** auf **Prototypen**. Jedes Objekt hat eine **interne Verbindung zu einem Prototypen**, von dem es Eigenschaften und Methoden erben kann.

---

## **1. Prototyp eines Objekts**
Jedes JavaScript-Objekt hat eine versteckte Verbindung (`[[Prototype]]`) zu einem Prototyp-Objekt, das mit `Object.getPrototypeOf(obj)` oder `__proto__` sichtbar gemacht werden kann.

```javascript
const person = { name: "Max" };

console.log(Object.getPrototypeOf(person)); 
console.log(person.__proto__ === Object.prototype); // true
```
âœ… **`Object.prototype` ist der Standard-Prototyp fÃ¼r Objekte.**  
âœ… **`Object.getPrototypeOf(obj)` ist sicherer als `obj.__proto__`**  

---

## **2. Prototypen-Kette (Prototype Chain)**
Wenn eine Eigenschaft nicht im Objekt selbst gefunden wird, sucht JavaScript sie **im Prototypen**.

```javascript
const tier = {
  atmen() {
    console.log("Das Tier atmet.");
  }
};

const hund = Object.create(tier); // `hund` erbt von `tier`
hund.bellen = function() {
  console.log("Wuff!");
};

hund.bellen(); // "Wuff!"
hund.atmen(); // "Das Tier atmet." (geerbt von `tier`)
console.log(Object.getPrototypeOf(hund) === tier); // true
```
âœ… **Eigenschaften werden Ã¼ber die Prototypen-Kette vererbt.**  
âœ… **Wenn eine Eigenschaft fehlt, wird im nÃ¤chsten Prototyp gesucht.**  

---

## **3. Eigene Prototypen mit Konstruktorfunktionen**
Jede Funktion hat eine `prototype`-Eigenschaft, die fÃ¼r die Vererbung genutzt wird.

```javascript
function Person(name) {
  this.name = name;
}

Person.prototype.greet = function() {
  console.log(`Hallo, ich bin ${this.name}.`);
};

const max = new Person("Max");
max.greet(); // "Hallo, ich bin Max."
console.log(max.__proto__ === Person.prototype); // true
```
âœ… **Methoden werden nur einmal im Prototyp gespeichert, nicht in jeder Instanz.**  
âŒ **Ohne `new` wird `this` nicht richtig gesetzt.**  

---

## **4. Prototyp-Kette mit Klassen (`class`)**
ES6 **Klassen (`class`)** sind eine modernere Syntax fÃ¼r Prototypen.

```javascript
class Tier {
  atmen() {
    console.log("Das Tier atmet.");
  }
}

class Hund extends Tier {
  bellen() {
    console.log("Wuff!");
  }
}

const bello = new Hund();
bello.bellen(); // "Wuff!"
bello.atmen(); // "Das Tier atmet." (geerbt von `Tier`)
```
âœ… **Klarere Syntax fÃ¼r Vererbung.**  
âœ… **Nutzen intern Prototypen (`extends`).**  

---

## **5. `Object.create(prototype)` fÃ¼r Prototypen**
```javascript
const katze = Object.create(tier);
katze.miauen = function() {
  console.log("Miau!");
};

katze.atmen(); // "Das Tier atmet." (geerbt)
```
âœ… **Flexibel, kein `new` nÃ¶tig.**  
âŒ **Kein `instanceof`-Support.**  

---

### **Zusammenfassung**
| Methode | Beschreibung | Vorteile | Nachteile |
|---------|-------------|----------|-----------|
| `Object.create(proto)` | Erstellt ein Objekt mit bestimmtem Prototyp | Einfach, flexibel | Kein `instanceof` |
| **Konstruktorfunktion + `prototype`** | Klassische Methode zur Vererbung | Speicheroptimiert | Braucht `new` |
| **ES6 `class` + `extends`** | Modernere Syntax fÃ¼r Vererbung | Lesbar, `super()`-Support | Nur syntaktischer Zucker |
| **Prototyp-Kette** | Automatische Suche in `[[Prototype]]` | ErmÃ¶glicht Vererbung | Kann unÃ¼bersichtlich werden |

ğŸ”— [MDN-Dokumentation zu Prototypen](https://developer.mozilla.org/de/docs/Learn/JavaScript/Objects/Prototypes)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

38. ### <a name="38"></a> Object.create()

### **`Object.create()` in JavaScript**  

Die Methode `Object.create(proto)` erstellt ein neues Objekt mit einem bestimmten **Prototypen**. Dadurch kann man einfach Objekte **vererben**, ohne Konstruktorfunktionen oder Klassen zu verwenden.

---

## **1. Einfaches Beispiel: Objekt mit Prototyp**
```javascript
const tier = {
  atmen() {
    console.log("Das Tier atmet.");
  }
};

const hund = Object.create(tier);
hund.bellen = function() {
  console.log("Wuff!");
};

hund.atmen(); // "Das Tier atmet." (geerbt von `tier`)
hund.bellen(); // "Wuff!"
console.log(Object.getPrototypeOf(hund) === tier); // true
```
âœ… **`hund` erbt die Methode `atmen()` von `tier`.**  
âœ… **Prototype Chain wird genutzt.**  

---

## **2. `Object.create(proto, properties)` mit Eigenschaften**
Man kann Eigenschaften direkt definieren.

```javascript
const person = {
  beschreibung() {
    return `${this.name} ist ${this.alter} Jahre alt.`;
  }
};

const max = Object.create(person, {
  name: { value: "Max", writable: true, enumerable: true },
  alter: { value: 30, writable: true, enumerable: true }
});

console.log(max.beschreibung()); // "Max ist 30 Jahre alt."
console.log(Object.keys(max)); // ["name", "alter"] (enumerable: true)
```
âœ… **Man kann `writable`, `enumerable`, `configurable` setzen.**  

---

## **3. `Object.create(null)` â€“ Objekt ohne Prototyp**
Erstellt ein **komplett leeres Objekt** (kein `Object.prototype`).

```javascript
const obj = Object.create(null);
obj.name = "Test";

console.log(obj.name); // "Test"
console.log(obj.toString); // âŒ `undefined` (kein `Object.prototype`)
```
âœ… **Gut fÃ¼r "reine" Key-Value-Maps (z. B. fÃ¼r Dictionary-Speicherung).**  
âŒ **Keine Standardmethoden (`toString`, `hasOwnProperty`).**  

---

## **4. Vererbung mit `Object.create()`**
```javascript
const fahrzeug = {
  start() {
    console.log(`${this.marke} startet.`);
  }
};

const auto = Object.create(fahrzeug);
auto.marke = "Tesla";

auto.start(); // "Tesla startet."
```
âœ… **Einfachere Alternative zu `class` oder Konstruktorfunktionen.**  

---

### **Zusammenfassung**
| Methode | Beschreibung | Vorteile | Nachteile |
|---------|-------------|----------|-----------|
| `Object.create(proto)` | Erstellt Objekt mit Prototyp `proto` | Speicheroptimiert, flexibel | Kein direkter `instanceof`-Support |
| `Object.create(proto, props)` | Erstellt Objekt + Eigenschaftsdefinition | Kontrolle Ã¼ber Eigenschaften | Komplexer |
| `Object.create(null)` | Objekt ohne Prototyp (`Object.prototype` fehlt) | Kein Overhead | Keine Standardmethoden |

ğŸ”— [MDN-Dokumentation zu `Object.create()`](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Object/create)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

39. ### <a name="39"></a> Unterschied zwischen klassischer und prototypischer Vererbung

### **Unterschied zwischen klassischer und prototypischer Vererbung in JavaScript**  

JavaScript nutzt **prototypische Vererbung**, wÃ¤hrend viele andere Sprachen wie Java oder C++ **klassische Vererbung** (klassenbasiert) verwenden. Ab **ES6** gibt es jedoch die `class`-Syntax, die auf Prototypen basiert, aber klassisches Verhalten nachahmt.

---

## **1. Klassische Vererbung (Klassenbasiert â€“ ES6 `class`)**
In klassischer Vererbung erstellt man **eine Klasse**, die als Blaupause fÃ¼r Objekte dient. Subklassen kÃ¶nnen von einer Superklasse erben.

```javascript
class Tier {
  constructor(name) {
    this.name = name;
  }

  laufen() {
    console.log(`${this.name} lÃ¤uft.`);
  }
}

class Hund extends Tier {
  bellen() {
    console.log(`${this.name} bellt: Wuff!`);
  }
}

const rex = new Hund("Rex");
rex.laufen(); // "Rex lÃ¤uft."
rex.bellen(); // "Rex bellt: Wuff!"
```
âœ… **Vorteile:**  
- Klare Struktur, leicht verstÃ¤ndlich  
- `super()` ermÃ¶glicht Zugriff auf die Superklasse  
- Bessere Lesbarkeit fÃ¼r Entwickler mit OOP-Erfahrung  

âŒ **Nachteile:**  
- Statischer als Prototypen  
- Weniger flexibel fÃ¼r dynamische Objekte  

---

## **2. Prototypische Vererbung (`Object.create()` oder `prototype`)**
Hier gibt es **keine Klassen**. Objekte erben direkt von anderen Objekten Ã¼ber die **Prototype Chain**.

```javascript
const tier = {
  laufen() {
    console.log("Das Tier lÃ¤uft.");
  }
};

const hund = Object.create(tier);
hund.bellen = function() {
  console.log("Wuff!");
};

hund.laufen(); // "Das Tier lÃ¤uft." (geerbt von `tier`)
hund.bellen(); // "Wuff!"
```
âœ… **Vorteile:**  
- Mehr **FlexibilitÃ¤t** (dynamische Objekte, keine feste Klassendefinition)  
- **Direkte Vererbung von Objekten**  
- Speicherfreundlich (Methoden im Prototyp gespeichert)  

âŒ **Nachteile:**  
- Weniger intuitiv fÃ¼r Entwickler mit OOP-Hintergrund  
- Keine direkte `instanceof`-ÃœberprÃ¼fung  

---

## **3. Vergleich: Klassisch vs. Prototypisch**

| Merkmal | Klassische Vererbung (`class`) | Prototypische Vererbung (`Object.create()` / `prototype`) |
|---------|---------------------------------|---------------------------------|
| **Basis** | Klassen mit Konstruktoren | Objekte erben direkt von anderen Objekten |
| **Syntax** | `class` und `extends` | `Object.create()` oder `prototype` |
| **Methodenspeicher** | Im `prototype` der Klasse | Direkt im Prototyp-Objekt |
| **FlexibilitÃ¤t** | Statisch, festgelegte Struktur | Dynamisch, Objekte kÃ¶nnen geÃ¤ndert werden |
| **Performance** | Optimiert fÃ¼r OOP | Speicherfreundlich, da Prototypen gemeinsam genutzt werden |

---

### **Zusammenfassung**
- **`class` (ES6)** â†’ Klassische Syntax, aber basiert intern auf **Prototypen**.
- **`Object.create(proto)` oder `prototype`** â†’ Direktes Erben von Objekten, flexibler.
- **Prototypische Vererbung ist dynamischer**, klassisches OOP ist strukturierter.

ğŸ”— [MDN-Dokumentation zu Vererbung](https://developer.mozilla.org/de/docs/Learn/JavaScript/Objects/Inheritance)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

40. ### <a name="40"></a> 


  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**  

41. ### <a name="41"></a> Arrays und Pseudo-Arrays, Array-Destrukturierung

### **Arrays und Pseudo-Arrays, Array-Destrukturierung in JavaScript**  

---

## **1. Arrays in JavaScript**
Ein **Array** ist eine geordnete Liste von Werten, die mit Index (`0`-basiert) zugÃ¤nglich sind.

```javascript
const zahlen = [10, 20, 30];
console.log(zahlen[0]); // 10
console.log(zahlen.length); // 3
```
âœ… **Arrays sind dynamisch und kÃ¶nnen verschiedene Datentypen speichern.**  

---

## **2. Pseudo-Arrays (Array-Ã¤hnliche Objekte)**
Pseudo-Arrays haben **LÃ¤ngen- und Indexeigenschaften**, aber **nicht alle Array-Methoden**.

### **2.1 `arguments`-Objekt (funktionales Pseudo-Array)**
```javascript
function summe() {
  console.log(arguments); // Pseudo-Array
  return Array.from(arguments).reduce((acc, val) => acc + val, 0);
}

console.log(summe(1, 2, 3)); // 6
```
âœ… `Array.from(arguments)` konvertiert ein Pseudo-Array in ein echtes Array.  

---

### **2.2 `NodeList` und `HTMLCollection` (DOM-Pseudo-Arrays)**
```javascript
const alleDivs = document.querySelectorAll("div");
console.log(alleDivs instanceof NodeList); // true

const echteArray = Array.from(alleDivs);
console.log(echteArray.map(div => div.innerText)); // Array-Methoden nutzbar
```
âœ… **`NodeList` ist kein echtes Array â†’ `Array.from()` oder Spread-Operator nutzen.**  

---

## **3. Array-Destrukturierung (ES6)**  
Mit **Destrukturierung** kÃ¶nnen Werte direkt aus einem Array extrahiert werden.

### **3.1 Grundlegende Destrukturierung**
```javascript
const zahlen = [10, 20, 30];
const [erstes, zweites] = zahlen;

console.log(erstes); // 10
console.log(zweites); // 20
```
âœ… **VerkÃ¼rzt den Code bei Wertzuweisungen.**  

---

### **3.2 Ãœberspringen von Werten**
```javascript
const zahlen = [10, 20, 30, 40];
const [, , drittes] = zahlen;

console.log(drittes); // 30
```
âœ… **LÃ¤sst bestimmte Elemente aus.**  

---

### **3.3 Destrukturierung mit Rest-Operator (`...`)**
```javascript
const [erstes, ...rest] = [1, 2, 3, 4, 5];

console.log(erstes); // 1
console.log(rest); // [2, 3, 4, 5]
```
âœ… **Ideal fÃ¼r Variablen mit dynamischer LÃ¤nge.**  

---

### **3.4 Werte tauschen mit Destrukturierung**
```javascript
let a = 5, b = 10;
[a, b] = [b, a];

console.log(a, b); // 10, 5
```
âœ… **Kein temporÃ¤rer Zwischenspeicher nÃ¶tig.**  

---

### **3.5 Destrukturierung in Funktionsparametern**
```javascript
function zeigePerson([name, alter]) {
  console.log(`${name} ist ${alter} Jahre alt.`);
}

const daten = ["Lisa", 30];
zeigePerson(daten); // Lisa ist 30 Jahre alt.
```
âœ… **Perfekt fÃ¼r Funktionen mit Array-Parametern.**  

---

### **Zusammenfassung**
| Thema | Beschreibung |
|-------|-------------|
| **Array** | Geordnete Liste von Werten (`[1, 2, 3]`) |
| **Pseudo-Arrays** | `arguments`, `NodeList` â€“ Kein echtes Array |
| **Destrukturierung** | Extrahiert Werte aus Arrays |
| **Rest-Operator (`...`)** | Speichert den Rest der Werte |
| **Tauschen mit Destrukturierung** | `[a, b] = [b, a]` |

ğŸ”— [MDN-Dokumentation zur Array-Destrukturierung](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Operators/Destrukturierende_Zuweisung#arrays)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

42. ### <a name="42"></a> Methoden Array, Array.prototype

### **Methoden fÃ¼r Arrays und `Array.prototype` in JavaScript**  

JavaScript-Arrays besitzen viele Methoden, die das Arbeiten mit Daten erleichtern. Sie sind in zwei Kategorien unterteilt:

1. **Statische Methoden** (`Array.method()`)
2. **Instanzmethoden** (`Array.prototype.method()` â€“ fÃ¼r einzelne Arrays)

---

## **1. Statische Methoden (`Array.method()`)**
Diese Methoden werden direkt auf `Array` angewendet.

### **1.1 `Array.from(iterable)` â€“ Pseudo-Array zu echtem Array konvertieren**
```javascript
const pseudoArray = document.querySelectorAll("div"); // NodeList (kein echtes Array)
const echtesArray = Array.from(pseudoArray);

console.log(echtesArray instanceof Array); // true
```
âœ… **Konvertiert `NodeList`, `arguments`, `Set` in Arrays**  

---

### **1.2 `Array.isArray(value)` â€“ PrÃ¼ft, ob ein Wert ein echtes Array ist**
```javascript
console.log(Array.isArray([1, 2, 3])); // true
console.log(Array.isArray({ 0: "a", length: 1 })); // false
```
âœ… **Sicherer als `instanceof Array`, weil auch fÃ¼r `iframes` funktioniert.**  

---

### **1.3 `Array.of(...values)` â€“ Erstellt ein Array aus Argumenten**
```javascript
console.log(Array.of(1, 2, 3)); // [1, 2, 3]
console.log(Array(3)); // [empty Ã— 3] (Sonderverhalten!)
```
âœ… **Verhindert `Array(3)`-Problem (leeres Array mit LÃ¤nge 3).**  

---

## **2. Instanzmethoden (`Array.prototype.method()`)**
Diese Methoden werden auf einzelne Arrays angewendet.

---

### **2.1 Mutierende Methoden (verÃ¤ndern das Array)**
#### **`push()` â€“ Element(e) ans Ende hinzufÃ¼gen**
```javascript
const zahlen = [1, 2];
zahlen.push(3, 4);
console.log(zahlen); // [1, 2, 3, 4]
```

#### **`pop()` â€“ Letztes Element entfernen**
```javascript
const namen = ["Max", "Anna"];
namen.pop();
console.log(namen); // ["Max"]
```

#### **`shift()` â€“ Erstes Element entfernen**
```javascript
const queue = ["Erster", "Zweiter"];
queue.shift();
console.log(queue); // ["Zweiter"]
```

#### **`unshift()` â€“ Element(e) am Anfang hinzufÃ¼gen**
```javascript
const liste = ["B"];
liste.unshift("A");
console.log(liste); // ["A", "B"]
```

#### **`splice(start, deleteCount, ...items)` â€“ Elemente entfernen/hinzufÃ¼gen**
```javascript
const farben = ["Rot", "GrÃ¼n", "Blau"];
farben.splice(1, 1, "Gelb"); // 1 Element ab Index 1 ersetzen
console.log(farben); // ["Rot", "Gelb", "Blau"]
```
âœ… **Vielseitig: Entfernen, EinfÃ¼gen und Ersetzen von Elementen.**  

---

### **2.2 Nicht-mutierende Methoden (erstellt neue Arrays)**
#### **`slice(start, end)` â€“ Teilausschnitt eines Arrays**
```javascript
const zahlen = [1, 2, 3, 4];
console.log(zahlen.slice(1, 3)); // [2, 3] (Index 1 bis 2)
```

#### **`concat(arr)` â€“ Arrays verbinden**
```javascript
const a = [1, 2], b = [3, 4];
console.log(a.concat(b)); // [1, 2, 3, 4]
```

#### **`join(separator)` â€“ Array zu String**
```javascript
const worte = ["Hallo", "Welt"];
console.log(worte.join(" ")); // "Hallo Welt"
```

---

### **2.3 Iterationsmethoden**
#### **`forEach(callback)` â€“ Jedes Element durchlaufen**
```javascript
const zahlen = [1, 2, 3];
zahlen.forEach((zahl) => console.log(zahl * 2));
// 2
// 4
// 6
```
âœ… **Ersetzt `for`-Schleife fÃ¼r Arrays.**  

---

### **2.4 Methoden fÃ¼r neue Arrays**
#### **`map(callback)` â€“ Jedes Element transformieren**
```javascript
const zahlen = [1, 2, 3];
const verdoppelt = zahlen.map((zahl) => zahl * 2);
console.log(verdoppelt); // [2, 4, 6]
```
âœ… **Ã„ndert Werte ohne Original-Array zu modifizieren.**  

---

#### **`filter(callback)` â€“ Elemente basierend auf Bedingung filtern**
```javascript
const zahlen = [10, 20, 30, 40];
const gefiltert = zahlen.filter((zahl) => zahl > 20);
console.log(gefiltert); // [30, 40]
```
âœ… **Perfekt fÃ¼r Datenverarbeitung.**  

---

#### **`reduce(callback, startwert)` â€“ Werte reduzieren (z. B. Summe)**
```javascript
const zahlen = [1, 2, 3, 4];
const summe = zahlen.reduce((acc, zahl) => acc + zahl, 0);
console.log(summe); // 10
```
âœ… **Wird oft fÃ¼r Summen, Durchschnittswerte und Objektverarbeitung genutzt.**  

---

### **2.5 Suchen und PrÃ¼fen**
#### **`find(callback)` â€“ Erstes passendes Element**
```javascript
const leute = [{ name: "Max", alter: 30 }, { name: "Anna", alter: 25 }];
const ergebnis = leute.find(person => person.alter > 28);
console.log(ergebnis); // { name: "Max", alter: 30 }
```

#### **`findIndex(callback)` â€“ Index des ersten passenden Elements**
```javascript
const zahlen = [10, 20, 30];
console.log(zahlen.findIndex(n => n === 20)); // 1
```

#### **`some(callback)` â€“ PrÃ¼ft, ob mind. ein Element passt**
```javascript
const zahlen = [3, 7, 11];
console.log(zahlen.some(n => n > 5)); // true
```

#### **`every(callback)` â€“ PrÃ¼ft, ob ALLE Elemente passen**
```javascript
console.log(zahlen.every(n => n > 2)); // true
console.log(zahlen.every(n => n > 5)); // false
```

---

### **2.6 Sortieren**
#### **`sort([compareFunction])` â€“ Sortiert das Array**
```javascript
const zahlen = [10, 2, 30, 4];
zahlen.sort((a, b) => a - b);
console.log(zahlen); // [2, 4, 10, 30]
```
âŒ **Standard `sort()` sortiert alphabetisch â€“ Immer `compareFunction` nutzen!**  

---

### **Zusammenfassung**
| Methode | Typ | Funktion |
|---------|-----|----------|
| `push()`, `pop()`, `shift()`, `unshift()` | Mutierend | Elemente hinzufÃ¼gen/entfernen |
| `slice()`, `concat()`, `join()` | Nicht-mutierend | Neues Array/Strings erstellen |
| `map()`, `filter()`, `reduce()` | Iterativ | Transformation & Aggregation |
| `find()`, `some()`, `every()` | Suchmethoden | Elemente finden & prÃ¼fen |
| `sort()`, `reverse()` | Sortieren | Reihenfolge Ã¤ndern |

ğŸ”— [MDN-Dokumentation zu Arrays](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Array)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

43. ### <a name="43"></a> Kopieren von Arrays

### **Kopieren von Arrays in JavaScript**  

Beim Kopieren von Arrays gibt es zwei Methoden:  

1. **Shallow Copy (flache Kopie)** â€“ Erstellt eine Kopie der obersten Ebene, verschachtelte Objekte/Arrays bleiben referenziert.  
2. **Deep Copy (tiefe Kopie)** â€“ Erstellt eine komplette Kopie inklusive aller verschachtelten Werte.

---

## **1. Flache Kopie (Shallow Copy)**
Eine **flache Kopie** dupliziert nur die oberste Ebene des Arrays. **Verschachtelte Objekte bleiben referenziert**.

### **1.1 Spread-Operator (`[...]`)**
```javascript
const original = [1, 2, [3, 4]];
const kopie = [...original];

kopie[0] = 99;
kopie[2][0] = 999; // âš ï¸ Ã„nderung in verschachteltem Array!

console.log(original); // [1, 2, [999, 4]] (Ã„nderung Ã¼bernommen!)
console.log(kopie); // [99, 2, [999, 4]]
```
âœ… **KÃ¼rzeste Methode**  
âŒ **Tief verschachtelte Werte bleiben referenziert!**  

---

### **1.2 `Array.slice()` â€“ Erstellt eine neue Kopie**
```javascript
const original = [1, 2, 3];
const kopie = original.slice();

kopie[0] = 99;

console.log(original); // [1, 2, 3] (unverÃ¤ndert)
console.log(kopie); // [99, 2, 3]
```
âœ… **Gut fÃ¼r flache Arrays**  
âŒ **Verschachtelte Werte bleiben referenziert**  

---

### **1.3 `Array.from()` â€“ Erstellt eine Kopie**
```javascript
const original = [1, 2, { a: 3 }];
const kopie = Array.from(original);

kopie[2].a = 99; // âš ï¸ Referenzierte Objekte werden nicht kopiert!

console.log(original); // [1, 2, { a: 99 }]
console.log(kopie); // [1, 2, { a: 99 }]
```
âœ… **NÃ¼tzlich fÃ¼r `arguments` oder `NodeList`**  
âŒ **Verschachtelte Objekte bleiben referenziert**  

---

## **2. Tiefe Kopie (Deep Copy)**
Eine **tiefe Kopie** dupliziert **das gesamte Array und alle verschachtelten Werte**, sodass keine Referenz bestehen bleibt.

### **2.1 `JSON.parse(JSON.stringify(array))` (Einfache LÃ¶sung)**
```javascript
const original = [1, 2, { a: 3 }];
const kopie = JSON.parse(JSON.stringify(original));

kopie[2].a = 99;

console.log(original); // [1, 2, { a: 3 }] (unverÃ¤ndert)
console.log(kopie); // [1, 2, { a: 99 }]
```
âœ… **Einfache Methode fÃ¼r tiefe Kopien**  
âŒ **Verliert Methoden, `undefined`, `Symbol`, `Date`**  

---

### **2.2 `structuredClone(array)` (Moderne LÃ¶sung)**
```javascript
const original = [1, 2, { a: 3 }, new Date()];
const kopie = structuredClone(original);

kopie[2].a = 99;

console.log(original); // [1, 2, { a: 3 }, Date]
console.log(kopie); // [1, 2, { a: 99 }, Date]
```
âœ… **ErhÃ¤lt `Date`, `Map`, `Set`**  
âŒ **Nicht in Ã¤lteren Browsern unterstÃ¼tzt**  

---

### **2.3 Rekursive Deep Copy-Funktion**
Falls `structuredClone()` nicht verfÃ¼gbar ist, kann man eine **eigene Funktion** schreiben.

```javascript
function deepCopy(arr) {
  return arr.map(item => 
    Array.isArray(item) ? deepCopy(item) : 
    typeof item === "object" && item !== null ? {...item} : item
  );
}

const original = [1, 2, { a: 3 }, [4, 5]];
const kopie = deepCopy(original);

kopie[2].a = 99;
kopie[3][0] = 999;

console.log(original); // [1, 2, { a: 3 }, [4, 5]]
console.log(kopie); // [1, 2, { a: 99 }, [999, 5]]
```
âœ… **Flexible und funktionale LÃ¶sung**  
âŒ **Verliert Methoden und komplexe Objekte (`Date`, `Map`, `Set`)**  

---

### **Zusammenfassung**
| Methode | Typ | Vorteile | Nachteile |
|---------|-----|----------|-----------|
| **`slice()` / `[...arr]`** | Flach | Schnell, einfach | Tiefe Werte bleiben referenziert |
| **`JSON.parse(JSON.stringify(arr))`** | Tief | Einfach, gut fÃ¼r Objekte | Verliert `undefined`, Methoden, `Date` |
| **`structuredClone(arr)`** | Tief | Beste moderne LÃ¶sung | Nicht in Ã¤lteren Browsern |
| **Rekursive Funktion (`deepCopy()`)** | Tief | Anpassbar | Kein `Date`, `Map`, `Set` |

ğŸ”— [MDN-Dokumentation zu `structuredClone()`](https://developer.mozilla.org/de/docs/Web/API/structuredClone)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

44. ### <a name="44"></a> Map, Set, WeakSet, WeakMap

### **`Map`, `Set`, `WeakMap`, `WeakSet` in JavaScript**  

JavaScript bietet **`Map`** und **`Set`** als moderne Alternativen zu **Objekten (`{}`) und Arrays (`[]`)**, sowie **`WeakMap`** und **`WeakSet`** fÃ¼r schwache Referenzen.

---

## **1. `Map` â€“ SchlÃ¼ssel-Wert-Speicher mit beliebigen SchlÃ¼sseltypen**  

Ein **`Map`** ist eine geordnete Sammlung von **SchlÃ¼ssel-Wert-Paaren**, bei der **beliebige Werte** als SchlÃ¼ssel verwendet werden kÃ¶nnen (z. B. Objekte oder Funktionen).  

### **1.1 Erstellen & BefÃ¼llen einer Map**
```javascript
const benutzerMap = new Map();
benutzerMap.set("name", "Max");
benutzerMap.set(42, "Alter");
benutzerMap.set({ id: 1 }, "Objekt als SchlÃ¼ssel");

console.log(benutzerMap.get("name")); // Max
console.log(benutzerMap.get(42)); // Alter
```
âœ… **Beliebige SchlÃ¼ssel mÃ¶glich (Objekte, Zahlen, Strings, Funktionen)**  
âœ… **ErhÃ¤lt Reihenfolge der EintrÃ¤ge**  

---

### **1.2 Methoden von `Map`**
```javascript
console.log(benutzerMap.has(42)); // true
benutzerMap.delete(42);
console.log(benutzerMap.size); // 2
benutzerMap.clear(); // LÃ¶scht alle EintrÃ¤ge
```

---

### **1.3 `forEach()`, `keys()`, `values()`, `entries()`**
```javascript
const map = new Map([
  ["name", "Anna"],
  ["stadt", "Berlin"]
]);

// Iteration
map.forEach((wert, schlÃ¼ssel) => console.log(`${schlÃ¼ssel}: ${wert}`));

console.log([...map.keys()]); // ["name", "stadt"]
console.log([...map.values()]); // ["Anna", "Berlin"]
console.log([...map.entries()]); // [["name", "Anna"], ["stadt", "Berlin"]]
```

---

## **2. `Set` â€“ Sammlung eindeutiger Werte**  

Ein **`Set`** speichert **einzigartige Werte** (keine Duplikate).

### **2.1 Erstellen & BefÃ¼llen eines Sets**
```javascript
const zahlenSet = new Set([1, 2, 3, 3, 4]);

console.log(zahlenSet.size); // 4 (kein doppeltes 3)
```

---

### **2.2 Methoden von `Set`**
```javascript
zahlenSet.add(5);
console.log(zahlenSet.has(3)); // true
zahlenSet.delete(2);
zahlenSet.clear(); // LÃ¶scht alle EintrÃ¤ge
```

---

### **2.3 `forEach()`, `keys()`, `values()`, `entries()`**
```javascript
const set = new Set(["Apfel", "Banane", "Kirsche"]);
set.forEach((wert) => console.log(wert));

console.log([...set.keys()]); // ["Apfel", "Banane", "Kirsche"]
console.log([...set.values()]); // ["Apfel", "Banane", "Kirsche"]
console.log([...set.entries()]); // [["Apfel", "Apfel"], ["Banane", "Banane"], ["Kirsche", "Kirsche"]]
```
âœ… **Perfekt fÃ¼r Listen ohne doppelte Werte**  

---

## **3. `WeakMap` â€“ SchlÃ¼ssel-Objekte mit automatischem Speicherfreigeben**  

Ein **`WeakMap`** speichert nur **Objekte als SchlÃ¼ssel** und erlaubt **automatische Speicherbereinigung (Garbage Collection)**, wenn das Objekt nicht mehr verwendet wird.

### **3.1 Erstellen & Verwenden einer `WeakMap`**
```javascript
const weakMap = new WeakMap();
let obj = { id: 1 };

weakMap.set(obj, "Daten fÃ¼r das Objekt");
console.log(weakMap.get(obj)); // "Daten fÃ¼r das Objekt"

obj = null; // Das Objekt wird entfernt -> automatisch aus WeakMap gelÃ¶scht
```
âœ… **Speichert nur Objekte als SchlÃ¼ssel**  
âœ… **Automatische Speicherfreigabe bei `null`**  
âŒ **Hat keine `size`, `keys()`, `values()` oder Iterationsmethoden**  

---

## **4. `WeakSet` â€“ Sammlung von Objekten mit automatischer Speicherfreigabe**  

Ein **`WeakSet`** speichert **nur Objekte** und entfernt sie automatisch, wenn sie nicht mehr referenziert werden.

### **4.1 Erstellen & Verwenden eines `WeakSet`**
```javascript
const weakSet = new WeakSet();
let obj1 = { name: "Max" };

weakSet.add(obj1);
console.log(weakSet.has(obj1)); // true

obj1 = null; // Objekt wird entfernt -> automatisch aus WeakSet gelÃ¶scht
```
âœ… **Perfekt fÃ¼r "Markierungen" an Objekten**  
âŒ **Keine Iterationsmethoden (`forEach()`, `keys()`, etc.)**  

---

### **Zusammenfassung**
| Struktur | SchlÃ¼sseltyp | Werte dÃ¼rfen sein | Iterierbar? | Speicherbereinigung |
|----------|-------------|-------------------|-------------|---------------------|
| **Map** | Beliebig | Beliebig | âœ… Ja | âŒ Nein |
| **Set** | Keine SchlÃ¼ssel | Einzigartige Werte | âœ… Ja | âŒ Nein |
| **WeakMap** | Nur Objekte | Beliebig | âŒ Nein | âœ… Ja |
| **WeakSet** | Keine SchlÃ¼ssel | Nur Objekte | âŒ Nein | âœ… Ja |

ğŸ”— [MDN-Dokumentation zu `Map`](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Map)  
ğŸ”— [MDN-Dokumentation zu `Set`](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Set)  

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

45. ### <a name="45"></a> Live Collections (lebendige Sammlungen)

### **Live Collections (lebendige Sammlungen) in JavaScript**  

**Live Collections** sind **Datenstrukturen im DOM**, die sich **automatisch aktualisieren**, wenn sich das Dokument Ã¤ndert.  

---

## **1. Arten von Live Collections**
- **`HTMLCollection`** â†’ Ergebnis von `getElementsByTagName()`, `getElementsByClassName()`
- **`NodeList` (manchmal live)** â†’ Ergebnis von `querySelectorAll()` (statisch) oder `childNodes` (live)

---

## **2. `HTMLCollection` â€“ Automatisch aktualisierbare Liste von Elementen**
Ein **`HTMLCollection`** wird live aktualisiert, wenn sich das DOM verÃ¤ndert.

```javascript
const divs = document.getElementsByTagName("div");
console.log(divs.length); // Anzahl der <div>-Elemente

const neuesDiv = document.createElement("div");
document.body.appendChild(neuesDiv); // Ein neues <div> wird hinzugefÃ¼gt

console.log(divs.length); // Live-Collection zeigt automatisch die neue Anzahl!
```
âœ… **Live (automatische Updates)**  
âŒ **Hat keine Array-Methoden (`map()`, `filter()`, etc.)**  

---

## **3. `NodeList` â€“ Live vs. Statische Liste**
Nicht alle `NodeList`-Sammlungen sind live!  

### **3.1 Live `NodeList` (z. B. `childNodes`)**
```javascript
const nodes = document.body.childNodes;
console.log(nodes.length);

const neuerText = document.createTextNode("Hallo!");
document.body.appendChild(neuerText);

console.log(nodes.length); // Wird automatisch aktualisiert!
```
âœ… **Live-Updates bei Ã„nderungen**  
âŒ **EnthÃ¤lt auch `TextNodes` und `Comments`**  

---

### **3.2 Statische `NodeList` (`querySelectorAll()`)**
```javascript
const liste = document.querySelectorAll("li");
console.log(liste.length); // Anzahl der <li>-Elemente

const neuesLi = document.createElement("li");
document.querySelector("ul").appendChild(neuesLi);

console.log(liste.length); // âŒ Bleibt unverÃ¤ndert (statisch)!
```
âœ… **Hat `forEach()` & andere Array-Methoden**  
âŒ **Bleibt unverÃ¤ndert, wenn DOM geÃ¤ndert wird**  

---

## **4. Live Collection in einer Schleife (Problem!)**
Ein **groÃŸes Problem** mit Live Collections: Ã„nderungen wÃ¤hrend einer Schleife fÃ¼hren zu unerwartetem Verhalten.

```javascript
const elemente = document.getElementsByTagName("p");

for (let i = 0; i < elemente.length; i++) {
  document.body.removeChild(elemente[i]); // âš ï¸ Fehler: `elemente.length` Ã¤ndert sich!
}
```
âœ… **LÃ¶sung:** RÃ¼ckwÃ¤rts iterieren oder `Array.from()` verwenden.

```javascript
const elemente = Array.from(document.getElementsByTagName("p"));

elemente.forEach(p => document.body.removeChild(p)); // Funktioniert sicher
```

---

### **Zusammenfassung**
| Sammlung | Live? | Methoden verfÃ¼gbar? | Typ |
|----------|------|----------------|------|
| **`HTMLCollection`** | âœ… Ja | âŒ Keine Array-Methoden | Elemente |
| **`NodeList` (z. B. `childNodes`)** | âœ… Ja | âŒ Nur `forEach()` | Knoten (Elemente, Text) |
| **`NodeList` (`querySelectorAll()`)** | âŒ Nein | âœ… Array-Methoden | Elemente |

ğŸ”— [MDN-Dokumentation zu Live Collections](https://developer.mozilla.org/de/docs/Web/API/HTMLCollection)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

46. ### <a name="46"></a> 


  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

47. ### <a name="47"></a> 


  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

48. ### <a name="48"></a> 


  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

49. ### <a name="49"></a> 


  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

50. ### <a name="50"></a> 


  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

51. ### <a name="51"></a> Spread-Operator (ES6-ES9)

### **Spread-Operator (`...`) in JavaScript (ES6-ES9)**  

Der **Spread-Operator (`...`)** wird in JavaScript verwendet, um **Arrays, Objekte und Funktionsargumente zu "entpacken"**. Er wurde mit **ES6** eingefÃ¼hrt und in spÃ¤teren Versionen erweitert.

---

## **1. Spread-Operator mit Arrays**  

### **1.1 Array-Kopieren (`Shallow Copy`)**
```javascript
const zahlen = [1, 2, 3];
const kopie = [...zahlen];

kopie.push(4);
console.log(zahlen); // [1, 2, 3] (unverÃ¤ndert)
console.log(kopie); // [1, 2, 3, 4]
```
âœ… **Erstellt eine flache Kopie des Arrays**  
âŒ **Verschachtelte Arrays werden referenziert!**  

---

### **1.2 Arrays zusammenfÃ¼gen (Alternative zu `concat()`)**
```javascript
const a = [1, 2], b = [3, 4];
const zusammen = [...a, ...b];

console.log(zusammen); // [1, 2, 3, 4]
```

---

### **1.3 Elemente hinzufÃ¼gen**
```javascript
const zahlen = [1, 2, 3];
const erweitert = [0, ...zahlen, 4];

console.log(erweitert); // [0, 1, 2, 3, 4]
```

---

## **2. Spread-Operator mit Objekten (`ES9`)**
Ab **ES9 (ES2018)** kann der Spread-Operator auch fÃ¼r **Objekte** verwendet werden.

### **2.1 Objekt-Kopieren**
```javascript
const person = { name: "Max", alter: 30 };
const kopie = { ...person };

kopie.alter = 31;
console.log(person.alter); // 30 (unverÃ¤ndert)
console.log(kopie.alter); // 31
```
âœ… **Flache Kopie des Objekts**  

---

### **2.2 Objekte zusammenfÃ¼hren**
```javascript
const user = { name: "Anna", alter: 25 };
const zusatz = { beruf: "Designer" };

const merged = { ...user, ...zusatz };
console.log(merged); // { name: "Anna", alter: 25, beruf: "Designer" }
```
âœ… **Alternative zu `Object.assign()`**  

---

### **2.3 Standardwerte Ã¼berschreiben**
```javascript
const defaultSettings = { theme: "light", showSidebar: true };
const userSettings = { theme: "dark" };

const settings = { ...defaultSettings, ...userSettings };
console.log(settings); // { theme: "dark", showSidebar: true }
```
âœ… **SpÃ¤ter hinzugefÃ¼gte Werte Ã¼berschreiben frÃ¼here Werte**  

---

## **3. Spread-Operator in Funktionsaufrufen**
### **3.1 Argumente an Funktionen Ã¼bergeben**
```javascript
function summe(a, b, c) {
  return a + b + c;
}

const zahlen = [1, 2, 3];
console.log(summe(...zahlen)); // 6
```
âœ… **Alternative zu `apply()`**  
```javascript
console.log(Math.max(...[10, 20, 30])); // 30
```

---

## **4. Unterschied zwischen Spread (`...`) und Rest-Parameter (`...`)**
**Spread (`...`)** â†’ **Entpackt** Werte aus Arrays oder Objekten.  
**Rest (`...`)** â†’ **Sammelt** Werte in Arrays.

```javascript
function beispiel(a, ...rest) {
  console.log(a); // Erstes Argument
  console.log(rest); // Restliche Argumente als Array
}

beispiel(1, 2, 3, 4);
// 1
// [2, 3, 4]
```

---

### **Zusammenfassung**
| Feature | Spread (`...`) fÃ¼r Arrays | Spread (`...`) fÃ¼r Objekte |
|---------|------------------|------------------|
| **Kopieren** | `const arr2 = [...arr1]` | `const obj2 = { ...obj1 }` |
| **ZusammenfÃ¼gen** | `[...arr1, ...arr2]` | `{ ...obj1, ...obj2 }` |
| **Elemente einfÃ¼gen** | `[1, ...arr, 4]` | `{ key: "new", ...obj }` |
| **Funktion Argumente** | `sum(...arr)` | âŒ Nicht mÃ¶glich |

ğŸ”— [MDN-Dokumentation zum Spread-Operator](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Operators/Spread_syntax)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)** 

52. ### <a name="52"></a> Rest-Operator und Standardparameter (ES6)

### **Rest-Operator (`...`) und Standardparameter (ES6) in JavaScript**  

Der **Rest-Operator (`...`)** sammelt mehrere Werte in **einem Array**.  
Standardparameter (`=`) setzen **Standardwerte fÃ¼r Funktionsargumente**.

---

## **1. Rest-Operator (`...`) â€“ Sammelt Werte in Arrays**  

### **1.1 Funktionsargumente sammeln**
```javascript
function summe(...zahlen) {
  return zahlen.reduce((acc, val) => acc + val, 0);
}

console.log(summe(1, 2, 3, 4)); // 10
```
âœ… **Unbegrenzte Argumente als Array empfangen**  
âŒ **Muss am **Ende** der Parameterliste stehen!**  

---

### **1.2 Rest-Parameter mit festen Parametern**
```javascript
function ersteUndRest(erstes, ...rest) {
  console.log(erstes); // Erstes Argument
  console.log(rest); // Rest als Array
}

ersteUndRest("A", "B", "C", "D");
// "A"
// ["B", "C", "D"]
```

---

### **1.3 Rest-Operator in Array-Destrukturierung**
```javascript
const zahlen = [1, 2, 3, 4, 5];
const [erstes, zweites, ...rest] = zahlen;

console.log(erstes, zweites); // 1, 2
console.log(rest); // [3, 4, 5]
```
âœ… **Perfekt fÃ¼r Teillisten**  

---

### **1.4 Rest-Operator in Objekt-Destrukturierung**
```javascript
const person = { name: "Max", alter: 30, beruf: "Entwickler" };
const { name, ...rest } = person;

console.log(name); // "Max"
console.log(rest); // { alter: 30, beruf: "Entwickler" }
```
âœ… **NÃ¼tzlich fÃ¼r das Entfernen einzelner Eigenschaften**  

---

## **2. Standardparameter â€“ Vorgabewerte fÃ¼r Funktionsargumente**
Falls ein Parameter **nicht Ã¼bergeben wird**, erhÃ¤lt er einen **Standardwert**.

```javascript
function begruessung(name = "Gast") {
  console.log(`Hallo, ${name}!`);
}

begruessung("Anna"); // "Hallo, Anna!"
begruessung(); // "Hallo, Gast!"
```
âœ… **Verhindert `undefined`-Werte in Funktionen**  

---

### **2.1 Standardwerte mit Berechnung**
```javascript
function mult(a, b = a) {
  return a * b;
}

console.log(mult(3)); // 9 (b = 3)
console.log(mult(3, 4)); // 12
```
âœ… **Ein Parameter kann als Standardwert fÃ¼r einen anderen genutzt werden**  

---

### **2.2 Kombination von Rest-Operator und Standardwerten**
```javascript
function summeMitStart(start = 0, ...zahlen) {
  return zahlen.reduce((acc, val) => acc + val, start);
}

console.log(summeMitStart(10, 1, 2, 3)); // 16 (10 + 1 + 2 + 3)
console.log(summeMitStart()); // 0
```

---

### **Zusammenfassung**
| Feature | Beschreibung | Beispiel |
|---------|-------------|----------|
| **Rest-Operator (`...`)** | Sammelt mehrere Werte als Array | `function test(...args) {}` |
| **Array-Destrukturierung** | Teilt Array-Werte in Variablen | `[a, ...rest] = [1, 2, 3]` |
| **Objekt-Destrukturierung** | Entfernt Eigenschaft aus Objekt | `{ key, ...rest } = obj` |
| **Standardparameter** | Setzt Standardwerte fÃ¼r Argumente | `function(a = 5) {}` |

ğŸ”— [MDN-Dokumentation zu Rest-Operator & Standardparametern](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Functions/Default_parameters)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

53. ### <a name="53"></a> Symbol

### **`Symbol` in JavaScript (ES6)**  

Ein **`Symbol`** ist ein einzigartiger, unverÃ¤nderlicher Wert, der als **SchlÃ¼ssel fÃ¼r Objekte** verwendet werden kann.  
Es wurde in **ES6 (ECMAScript 2015)** eingefÃ¼hrt und hilft, **Namenskonflikte zu vermeiden**.

---

## **1. Symbol erstellen**
```javascript
const id = Symbol();
console.log(typeof id); // "symbol"
```
âœ… **Jedes `Symbol()` ist einzigartig!**  

---

## **2. Symbol mit Beschreibung**
```javascript
const userID = Symbol("Benutzer-ID");
console.log(userID.toString()); // "Symbol(Benutzer-ID)"
```
âœ… **Die Beschreibung dient nur zu Debugging-Zwecken.**  

---

## **3. Symbol als Objekt-SchlÃ¼ssel**
```javascript
const user = {
  name: "Max",
  [userID]: 12345 // Symbol als SchlÃ¼ssel
};

console.log(user[userID]); // 12345
console.log(Object.keys(user)); // ["name"] (Symbol wird nicht angezeigt!)
console.log(Object.getOwnPropertySymbols(user)); // [Symbol(Benutzer-ID)]
```
âœ… **Verhindert unbeabsichtigten Zugriff auf Eigenschaften**  

âŒ **Wird nicht in `Object.keys()` oder `for...in` angezeigt!**  

---

## **4. Globale Symbol-Registrierung mit `Symbol.for()`**
```javascript
const sym1 = Symbol.for("globalID");
const sym2 = Symbol.for("globalID");

console.log(sym1 === sym2); // true
```
âœ… **`Symbol.for("name")` erstellt ein globales Symbol oder gibt ein existierendes zurÃ¼ck.**  

```javascript
console.log(Symbol.keyFor(sym1)); // "globalID"
```
âœ… **`Symbol.keyFor(symbol)` gibt den Symbol-Namen zurÃ¼ck.**  

âŒ **Unterschied zu `Symbol()` â†’ `Symbol.for()` erzeugt **KEIN** einzigartiges Symbol!**  

---

## **5. Eingebaute (`Well-Known`) Symbole**
JavaScript hat **vordefinierte Symbole**, die das Verhalten von Objekten Ã¤ndern kÃ¶nnen.

| Symbol | Zweck |
|--------|--------|
| `Symbol.iterator` | Definiert eine Iteration fÃ¼r `for...of` |
| `Symbol.toPrimitive` | Steuert die Typumwandlung eines Objekts |
| `Symbol.toStringTag` | Ã„ndert den `toString()`-Ausgabe |

### **Beispiel: `Symbol.iterator` fÃ¼r benutzerdefinierte Iterationen**
```javascript
const meineZahlen = {
  werte: [1, 2, 3],
  [Symbol.iterator]() {
    let index = 0;
    return {
      next: () => ({
        value: this.werte[index++],
        done: index > this.werte.length
      })
    };
  }
};

for (const zahl of meineZahlen) {
  console.log(zahl); // 1, 2, 3
}
```
âœ… **ErmÃ¶glicht benutzerdefinierte `for...of`-Schleifen!**  

---

### **Zusammenfassung**
| Feature | Beschreibung |
|---------|-------------|
| **`Symbol()`** | Erzeugt ein einzigartiges Symbol |
| **`Symbol("beschreibung")`** | Symbol mit Debug-Beschreibung |
| **`Symbol.for("key")`** | Erstellt oder ruft ein globales Symbol ab |
| **`Object.getOwnPropertySymbols(obj)`** | Zeigt alle Symbole eines Objekts |
| **Well-Known Symbols** | `Symbol.iterator`, `Symbol.toPrimitive`, `Symbol.toStringTag` |

ğŸ”— [MDN-Dokumentation zu `Symbol`](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Symbol)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

54. ### <a name="54"></a> BigInt

### **BigInt in JavaScript (ES11 / ES2020)**  

**BigInt** ist ein spezieller Zahlentyp fÃ¼r sehr groÃŸe Ganzzahlen, die Ã¼ber den sicheren Bereich von `Number` (`2^53 - 1`) hinausgehen.

---

## **1. Warum BigInt?**  

Die grÃ¶ÃŸte sichere Zahl in JavaScript ist:  
```javascript
console.log(Number.MAX_SAFE_INTEGER); // 9007199254740991
```
Wird eine grÃ¶ÃŸere Zahl verwendet, kann es zu **PrÃ¤zisionsfehlern** kommen:  
```javascript
console.log(9007199254740991 + 1); // 9007199254740992 âœ…
console.log(9007199254740991 + 2); // 9007199254740992 âŒ (Fehler!)
```
**LÃ¶sung:** Verwende `BigInt` fÃ¼r groÃŸe Zahlen.  

---

## **2. BigInt erstellen**
```javascript
const groÃŸeZahl = 123456789012345678901234567890n;
console.log(groÃŸeZahl); // 123456789012345678901234567890n
console.log(typeof groÃŸeZahl); // "bigint"
```
âœ… **BigInt wird mit `n` am Ende geschrieben**  

```javascript
const andereZahl = BigInt(12345678901234567890);
console.log(andereZahl); // 12345678901234567890n
```
âœ… **`BigInt()`-Konstruktor funktioniert ebenfalls**  

---

## **3. Rechnen mit BigInt**
```javascript
const a = 10n;
const b = 20n;

console.log(a + b); // 30n
console.log(a * b); // 200n
console.log(a / 3n); // 3n (Abrundung!)
```
âœ… **Alle arithmetischen Operationen sind mÃ¶glich**  
âŒ **Division rundet immer ab (kein Gleitkomma!)**  

---

## **4. BigInt und normale Zahlen (`Number`)**
```javascript
const big = 100n;
const num = 50;

console.log(big + BigInt(num)); // âœ… 150n
console.log(Number(big) + num); // âœ… 150
```
âŒ **Mischen von `BigInt` und `Number` ist nicht erlaubt!**  
```javascript
console.log(big + num); // âŒ TypeError
```
âœ… **LÃ¶sung: `BigInt()` oder `Number()` verwenden**  

---

## **5. Vergleiche mit BigInt**
Vergleiche (`==` oder `===`) funktionieren wie gewohnt:  
```javascript
console.log(10n == 10); // âœ… true (automatische Konvertierung)
console.log(10n === 10); // âŒ false (unterschiedlicher Typ)
console.log(10n > 5); // âœ… true
```
âœ… **`==` vergleicht den Wert, `===` vergleicht auch den Typ**  

---

## **6. BigInt in `Math`-Methoden**
BigInt **funktioniert nicht** mit `Math`-Funktionen:  
```javascript
console.log(Math.sqrt(16n)); // âŒ TypeError
```
âœ… **LÃ¶sung:** `Number(bigInt)` nutzen  
```javascript
console.log(Math.sqrt(Number(16n))); // âœ… 4
```

---

### **Zusammenfassung**
| Feature | Beschreibung |
|---------|-------------|
| **`BigInt(n)` oder `n`-Suffix** | Erstellt eine groÃŸe Ganzzahl |
| **Arithmetik (`+`, `-`, `*`, `/`)** | Funktioniert, aber Division rundet ab |
| **Vergleich (`==`, `===`, `<`, `>`)** | Funktioniert, aber `===` vergleicht auch den Typ |
| **BigInt & Number mischen** | âŒ Nicht erlaubt (`TypeError`) |
| **Keine `Math`-Funktionen** | âŒ `Math.sqrt(16n)` funktioniert nicht |

ğŸ”— [MDN-Dokumentation zu BigInt](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/BigInt)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

55. ### <a name="55"></a> Module import/export (ES6) & CommonJS

### **JavaScript-Module: `import/export` (ES6) & CommonJS**  

JavaScript unterstÃ¼tzt **zwei Modulsysteme**:  
1. **ES6-Module** (`import/export`) â†’ **FÃ¼r Browser & moderne JavaScript-Engines**  
2. **CommonJS** (`require/module.exports`) â†’ **FÃ¼r Node.js**  

---

## **1. ES6-Module (`import/export`) â€“ Modern**
### **1.1 Standard-Export (`export default`)**
```javascript
// ğŸ“ math.js (Modul)
export default function add(a, b) {
  return a + b;
}
```

```javascript
// ğŸ“ main.js
import add from "./math.js";

console.log(add(2, 3)); // 5
```
âœ… **`export default` â†’ Import ohne `{}` mÃ¶glich**  

---

### **1.2 Benannte Exporte (`export`)**
```javascript
// ğŸ“ utils.js
export function greet(name) {
  return `Hallo, ${name}!`;
}

export const PI = 3.1415;
```

```javascript
// ğŸ“ main.js
import { greet, PI } from "./utils.js";

console.log(greet("Max")); // "Hallo, Max!"
console.log(PI); // 3.1415
```
âœ… **Mehrere benannte Exporte mÃ¶glich**  

```javascript
// Alternativer Import (Alias vergeben)
import { greet as hello } from "./utils.js";
console.log(hello("Anna")); // "Hallo, Anna!"
```

---

### **1.3 Alles importieren (`* as`)**
```javascript
import * as utils from "./utils.js";

console.log(utils.greet("Lisa")); // "Hallo, Lisa!"
console.log(utils.PI); // 3.1415
```
âœ… **Praktisch fÃ¼r Modul-BÃ¼ndelung**  

---

### **1.4 Dynamischer Import (`import()`)**
```javascript
async function ladeModul() {
  const math = await import("./math.js");
  console.log(math.default(2, 3)); // 5
}
ladeModul();
```
âœ… **ErmÃ¶glicht asynchrones Laden von Modulen**  

---

## **2. CommonJS (`require/module.exports`) â€“ FÃ¼r Node.js**
Vor ES6 wurde **CommonJS** in **Node.js** verwendet.

### **2.1 Export (`module.exports`)**
```javascript
// ğŸ“ math.js
module.exports = function add(a, b) {
  return a + b;
};
```

### **2.2 Import (`require()`)**
```javascript
// ğŸ“ main.js
const add = require("./math");

console.log(add(2, 3)); // 5
```
âœ… **Funktioniert in Ã¤lteren Node.js-Versionen**  
âŒ **Nicht fÃ¼r Browser geeignet!**  

---

## **3. Unterschiede: ES6 vs. CommonJS**
| Feature | ES6-Module (`import/export`) | CommonJS (`require/module.exports`) |
|---------|------------------|-------------------|
| **Verwendet in** | Browser, Node.js | Nur Node.js |
| **Synchron / Asynchron** | Asynchron (lazily loaded) | Synchron (blockiert) |
| **Syntax** | `import/export` | `require/module.exports` |
| **Standard-Export** | `export default` | `module.exports =` |
| **Dynamischer Import** | `import()` | `require()` |

---

### **Zusammenfassung**
1. **ES6-Module** (`import/export`) â†’ Standard fÃ¼r moderne JavaScript-Projekte.  
2. **CommonJS** (`require/module.exports`) â†’ Wird in **Ã¤lteren Node.js-Projekten** verwendet.  
3. **Dynamischer `import()`** ermÃ¶glicht **lazy loading** fÃ¼r bessere Performance.  

ğŸ”— [MDN-Dokumentation zu `import/export`](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Statements/import)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

56. ### <a name="56"></a> Proxy und Reflect

### **`Proxy` und `Reflect` in JavaScript**  

**`Proxy` und `Reflect`** sind zwei moderne APIs in JavaScript, die es ermÃ¶glichen, das Verhalten von Objekten zu **Ã¼berwachen und zu manipulieren**.  
- **`Proxy`**: Erstellt eine "Zwischenschicht" zwischen einem Objekt und seinem Zugriff.  
- **`Reflect`**: Bietet Methoden zur Interaktion mit Objekten, Ã¤hnlich wie `Object`-Methoden, aber mit besserer Kontrolle.  

---

## **1. `Proxy` â€“ Objekte abfangen und modifizieren**
ğŸ“Œ **Mit `new Proxy(target, handler)` kann das Verhalten eines Objekts verÃ¤ndert werden.**  
- `target`: Das zu Ã¼berwachende Objekt  
- `handler`: Ein Objekt mit "Traps" (Methoden zur Abfangung von Aktionen)  

```javascript
const person = { name: "Max", alter: 30 };

const proxy = new Proxy(person, {
  get(target, prop) {
    return prop in target ? target[prop] : "Eigenschaft existiert nicht";
  }
});

console.log(proxy.name); // âœ… "Max"
console.log(proxy.alter); // âœ… 30
console.log(proxy.geburtsjahr); // âœ… "Eigenschaft existiert nicht"
```
âœ… **Verhindert `undefined`, wenn eine Eigenschaft nicht existiert**  

---

## **2. `Proxy` fÃ¼r Validierung (`set`-Trap)**
ğŸ“Œ **Kann Werte vor der Speicherung Ã¼berprÃ¼fen.**  
```javascript
const benutzer = {
  name: "Anna",
  alter: 25
};

const proxy = new Proxy(benutzer, {
  set(target, prop, value) {
    if (prop === "alter" && value < 0) {
      console.log("Alter kann nicht negativ sein!");
      return false;
    }
    target[prop] = value;
    return true;
  }
});

proxy.alter = 30; // âœ… OK
proxy.alter = -5; // âŒ "Alter kann nicht negativ sein!"
console.log(proxy.alter); // âœ… 30 (alte Wert bleibt erhalten)
```
âœ… **Erlaubt Validierungen & verhindert ungÃ¼ltige Daten**  

---

## **3. `Reflect` â€“ Objektinteraktionen mit weniger Fehlern**
ğŸ“Œ **`Reflect` ist eine Sammlung von Methoden zur Interaktion mit Objekten.**  

### **Warum `Reflect`?**
- Ersetzt direkte Methodenaufrufe (`Object.getOwnPropertyDescriptor()`, `delete obj.prop` etc.)
- Gibt immer einen RÃ¼ckgabewert (`true` oder `false` statt Fehler)
- Wird oft mit `Proxy` kombiniert

```javascript
const benutzer = { name: "Tom" };

console.log(Reflect.get(benutzer, "name")); // âœ… "Tom"
Reflect.set(benutzer, "name", "Alex");
console.log(benutzer.name); // âœ… "Alex"

Reflect.deleteProperty(benutzer, "name");
console.log(benutzer.name); // âœ… undefined
```
âœ… **Mehr Kontrolle und weniger Fehler als direkte `delete`-Befehle**  

---

## **4. Kombination: `Proxy` + `Reflect`**
ğŸ“Œ **Verwenden von `Reflect` innerhalb eines `Proxy` fÃ¼r sauberen Code.**  
```javascript
const produkt = { preis: 10 };

const proxy = new Proxy(produkt, {
  get(target, prop) {
    console.log(`Zugriff auf ${prop}`);
    return Reflect.get(target, prop);
  },
  set(target, prop, value) {
    if (prop === "preis" && value < 0) {
      console.log("Preis kann nicht negativ sein!");
      return false;
    }
    return Reflect.set(target, prop, value);
  }
});

console.log(proxy.preis); // âœ… Zugriff auf preis â†’ 10
proxy.preis = -5; // âŒ "Preis kann nicht negativ sein!"
proxy.preis = 20; // âœ… OK
console.log(proxy.preis); // âœ… 20
```
âœ… **Sauberer Code durch `Reflect.get()` & `Reflect.set()`**  

---

### **Zusammenfassung**
| Feature | `Proxy` | `Reflect` |
|---------|--------|----------|
| **Hauptzweck** | Abfangen & Manipulieren von Objekten | Methoden zur Objektmanipulation |
| **Zugriff auf Eigenschaften (`get`)** | `Proxy.get()` | `Reflect.get()` |
| **Eigenschaften setzen (`set`)** | `Proxy.set()` | `Reflect.set()` |
| **Eigenschaft lÃ¶schen (`delete`)** | `delete obj.key` | `Reflect.deleteProperty()` |
| **Einsatzgebiet** | Kontrolle Ã¼ber Objekte (Validierung, Logging) | Saubere & sichere Methoden |

ğŸ”— [MDN-Dokumentation zu `Proxy`](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Proxy)  
ğŸ”— [MDN-Dokumentation zu `Reflect`](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Reflect)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

57. ### <a name="57"></a> 


  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

58. ### <a name="58"></a> 


  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

59. ### <a name="59"></a> 


  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

60. ### <a name="60"></a> 


  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

61. ### <a name="61"></a> Ereignisse und ihre Handler

### **Ereignisse und ihre Handler in JavaScript**  

JavaScript-Ereignisse (`events`) ermÃ¶glichen **Interaktionen mit der Webseite**.  
Ein **Ereignis-Handler** (`event handler`) ist eine Funktion, die auf ein Ereignis reagiert.

---

## **1. Ereignisse mit `addEventListener()` (Empfohlene Methode)**  
```javascript
document.getElementById("btn").addEventListener("click", function() {
  console.log("Button wurde geklickt!");
});
```
âœ… **Mehrere Event-Listener mÃ¶glich**  
âœ… **Kann mit `removeEventListener()` entfernt werden**  

```javascript
function handler() {
  console.log("Event ausgelÃ¶st!");
}

document.getElementById("btn").addEventListener("click", handler);
document.getElementById("btn").removeEventListener("click", handler);
```
âŒ **Funktion muss benannt sein, um sie zu entfernen**  

---

## **2. Direktes Event-Handling (veraltete Methode)**
```html
<button onclick="alert('Geklickt!')">Klick mich</button>
```
âŒ **Nicht empfohlen, da HTML und JS vermischt werden**  

---

## **3. `onEvent`-Eigenschaft (nicht empfohlen)**
```javascript
document.getElementById("btn").onclick = function() {
  console.log("Button geklickt!");
};
```
âŒ **Ãœberschreibt vorherige Event-Handler**  

---

## **4. Wichtige Event-Objekte**
Das **Event-Objekt (`event`)** enthÃ¤lt Informationen Ã¼ber das Ereignis.

### **4.1 `event.target` â€“ Element, das das Ereignis ausgelÃ¶st hat**
```javascript
document.getElementById("btn").addEventListener("click", function(event) {
  console.log(event.target); // Gibt das geklickte Element zurÃ¼ck
});
```

### **4.2 `event.preventDefault()` â€“ Standardverhalten verhindern**
```javascript
document.querySelector("a").addEventListener("click", function(event) {
  event.preventDefault(); // Verhindert das Laden der Seite
  console.log("Link wurde geklickt!");
});
```

---

## **5. Event-Delegation (Optimierte Event-Behandlung)**
Anstatt jedem Element einen Event-Listener zuzuweisen, kann das **Ã¼bergeordnete Element** die Ereignisse abfangen.

```javascript
document.getElementById("liste").addEventListener("click", function(event) {
  if (event.target.tagName === "LI") {
    console.log(`Geklickt: ${event.target.innerText}`);
  }
});
```
âœ… **Weniger Event-Listener â†’ Bessere Performance**  

---

## **6. Bubbling & Capturing (Event Propagation)**
Ein Ereignis durchlÃ¤uft **drei Phasen**:  
1. **Capturing Phase** (`window â†’ Eltern â†’ Kind`)  
2. **Target Phase** (Event erreicht das Ziel)  
3. **Bubbling Phase** (Event steigt von **Kind â†’ Eltern â†’ window** auf)

### **6.1 Bubbling (Standardverhalten)**
```javascript
document.getElementById("child").addEventListener("click", function() {
  console.log("Child geklickt!");
});

document.getElementById("parent").addEventListener("click", function() {
  console.log("Parent geklickt!");
});
```
Wenn `child` geklickt wird:  
```
Child geklickt!
Parent geklickt!  // (Weil das Event "hochblubbert")
```

### **6.2 Event nur auf Ziel stoppen**
```javascript
document.getElementById("child").addEventListener("click", function(event) {
  event.stopPropagation(); // Stoppt das Bubbling
  console.log("Nur Child wird ausgelÃ¶st!");
});
```

---

### **Zusammenfassung**
| Methode | Vorteil | Nachteil |
|---------|---------|---------|
| **`addEventListener()`** | Mehrere Listener, entfernbare Events | Funktion muss benannt sein zum Entfernen |
| **`onclick = function`** | Einfach | Ãœberschreibt frÃ¼here Handler |
| **Inline `onclick="..."`** | Schnell | Vermischt HTML & JavaScript |
| **Event-Delegation** | Spart Ressourcen | Muss `event.target` prÃ¼fen |
| **`stopPropagation()`** | Verhindert Bubbling | Kann ungewollte Effekte haben |

ğŸ”— [MDN-Dokumentation zu `addEventListener()`](https://developer.mozilla.org/de/docs/Web/API/EventTarget/addEventListener)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**  

62. ### <a name="62"></a> Ereignis-Bubbling (event bubbling)

### **Ereignis-Bubbling (`event bubbling`) in JavaScript**  

**Ereignis-Bubbling** beschreibt, wie ein **Ereignis von einem untergeordneten (`child`) Element zu den Ã¼bergeordneten (`parent`) Elementen "hochblubbert"**.  

---

## **1. Standardverhalten: Bubbling**
Wenn ein `click`-Event auf einem `child`-Element ausgelÃ¶st wird, **wird das Ereignis automatisch an die Eltern weitergegeben**.  
Das bedeutet: **Erst das geklickte Element verarbeitet das Event, dann seine Eltern (bis zum `document`).**

```html
<div id="parent">
  <button id="child">Klick mich</button>
</div>
```

```javascript
document.getElementById("child").addEventListener("click", () => {
  console.log("Child geklickt!");
});

document.getElementById("parent").addEventListener("click", () => {
  console.log("Parent geklickt!");
});
```

**Klick auf den Button (`#child`) â†’ Ausgabe:**  
```
Child geklickt!
Parent geklickt!
```
âœ… **Das `click`-Ereignis "blubbert" vom `child` zum `parent`.**  

---

## **2. `stopPropagation()` â€“ Bubbling verhindern**
Falls das Ereignis **nicht an Eltern weitergegeben werden soll**, kann `event.stopPropagation()` verwendet werden.

```javascript
document.getElementById("child").addEventListener("click", (event) => {
  event.stopPropagation(); // Stoppt das Bubbling
  console.log("Nur Child wird ausgelÃ¶st!");
});
```
**Klick auf `#child` â†’ Ausgabe:**  
```
Nur Child wird ausgelÃ¶st!
```
âœ… **Das `click`-Event bleibt auf `child`, `parent` wird nicht aufgerufen.**  

---

## **3. `capture: true` â€“ Capturing-Phase aktivieren**
StandardmÃ¤ÃŸig wird ein Event zuerst auf dem `child` ausgefÃ¼hrt.  
Mit `{ capture: true }` kann das Ereignis zuerst im `parent` verarbeitet werden (Capturing statt Bubbling).

```javascript
document.getElementById("parent").addEventListener("click", () => {
  console.log("Parent geklickt (Capturing)!");
}, { capture: true });
```
**Klick auf `#child` â†’ Ausgabe:**  
```
Parent geklickt (Capturing)!
Child geklickt!
```
âœ… **Das Event wird zuerst im `parent` verarbeitet und dann im `child`.**  

---

## **4. `stopImmediatePropagation()` â€“ Alle weiteren Handler blockieren**
Falls ein Element mehrere Event-Listener hat, kann **`stopImmediatePropagation()`** verhindern, dass weitere Listener ausgefÃ¼hrt werden.

```javascript
document.getElementById("child").addEventListener("click", (event) => {
  event.stopImmediatePropagation();
  console.log("Erster Listener");
});

document.getElementById("child").addEventListener("click", () => {
  console.log("Zweiter Listener");
});
```
âœ… **Nur "Erster Listener" wird ausgefÃ¼hrt, der zweite wird blockiert.**  

---

### **Zusammenfassung**
| Methode | Wirkung |
|---------|---------|
| **Bubbling (Standard)** | Event wandert von `child` zu `parent`. |
| **`event.stopPropagation()`** | Verhindert Bubbling (nur `child` feuert). |
| **`{ capture: true }`** | Aktiviert **Capturing-Phase** (Eltern zuerst). |
| **`event.stopImmediatePropagation()`** | Blockiert ALLE Event-Handler auf dem Element. |

ğŸ”— [MDN-Dokumentation zu `event.stopPropagation()`](https://developer.mozilla.org/de/docs/Web/API/Event/stopPropagation)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

63. ### <a name="63"></a> Ereignis-Delegation

### **Ereignis-Delegation (`event delegation`) in JavaScript**  

**Ereignis-Delegation** bedeutet, dass **ein Ã¼bergeordnetes Element (`parent`) ein Ereignis fÃ¼r seine untergeordneten (`child`) Elemente verarbeitet**.  
Das nutzt **Ereignis-Bubbling**, um nicht fÃ¼r jedes Kind-Element einen eigenen Event-Listener zu setzen.

---

## **1. Warum Ereignis-Delegation?**
âœ… **Bessere Performance** (weniger Event-Listener)  
âœ… **Funktioniert auch fÃ¼r dynamisch erstellte Elemente**  
âœ… **Einfacher zu verwalten**  

---

## **2. Beispiel ohne Delegation (Ineffizient)**
```javascript
document.querySelectorAll("li").forEach(li => {
  li.addEventListener("click", () => {
    console.log("LI geklickt!");
  });
});
```
âŒ **Jedes `li`-Element bekommt einen eigenen Event-Listener!**  
âŒ **Neue `li`-Elemente funktionieren nicht automatisch**  

---

## **3. Ereignis-Delegation (Empfohlene Methode)**
```javascript
document.getElementById("liste").addEventListener("click", (event) => {
  if (event.target.tagName === "LI") {
    console.log(`Geklickt: ${event.target.innerText}`);
  }
});
```
âœ… **Nur ein Event-Listener fÃ¼r die gesamte Liste (`#liste`)**  
âœ… **Funktioniert auch fÃ¼r spÃ¤ter hinzugefÃ¼gte `li`-Elemente**  

---

## **4. Dynamische Elemente automatisch unterstÃ¼tzen**
```javascript
document.getElementById("liste").addEventListener("click", (event) => {
  if (event.target.matches("li")) {
    console.log(`Neu geklickt: ${event.target.innerText}`);
  }
});

document.getElementById("addItem").addEventListener("click", () => {
  const neuesLi = document.createElement("li");
  neuesLi.textContent = "Neues Item";
  document.getElementById("liste").appendChild(neuesLi);
});
```
âœ… **Neue Elemente (`<li>`) funktionieren ohne zusÃ¤tzlichen Code!**  

---

## **5. `event.target` vs. `event.currentTarget`**
- **`event.target`** â†’ Das Element, das das Ereignis ausgelÃ¶st hat (`<li>`).  
- **`event.currentTarget`** â†’ Das Element, an dem der Event-Listener hÃ¤ngt (`#liste`).

```javascript
document.getElementById("liste").addEventListener("click", (event) => {
  console.log("target:", event.target); // Das geklickte `li`
  console.log("currentTarget:", event.currentTarget); // `#liste`
});
```

---

## **6. `stopPropagation()` verhindern, wenn nÃ¶tig**
Falls ein `li` innerhalb eines anderen Elements liegt, kann `event.stopPropagation()` ungewollte Effekte verhindern:

```javascript
document.getElementById("liste").addEventListener("click", (event) => {
  if (event.target.matches("button")) {
    event.stopPropagation(); // Verhindert, dass `li`-Events ebenfalls feuern
  }
});
```

---

### **Zusammenfassung**
| Methode | Vorteil |
|---------|---------|
| **Direkter Event-Listener pro Element** | âŒ Ineffizient bei vielen Elementen |
| **Event-Delegation (`addEventListener()` am `parent`)** | âœ… Weniger Event-Listener, bessere Performance |
| **`event.target`** | âœ… Gibt das **eigentliche geklickte Element** zurÃ¼ck |
| **`event.currentTarget`** | âœ… Gibt das **Element mit dem Event-Listener** zurÃ¼ck |
| **Dynamische Elemente** | âœ… Funktionieren automatisch |

ğŸ”— [MDN-Dokumentation zu `event delegation`](https://developer.mozilla.org/de/docs/Learn/JavaScript/Building_blocks/Events#event_delegation)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

64. ### <a name="64"></a> Unterschied zwischen load und DOMContentLoaded

### **Unterschied zwischen `load` und `DOMContentLoaded` in JavaScript**  

Beide Ereignisse werden im **Window- oder Document-Objekt** ausgelÃ¶st, aber sie haben unterschiedliche Zeitpunkte und Zwecke.

---

## **1. `DOMContentLoaded` â€“ DOM ist geladen, aber Ressourcen noch nicht**
```javascript
document.addEventListener("DOMContentLoaded", () => {
  console.log("DOM ist vollstÃ¤ndig geladen!");
});
```
âœ… **LÃ¤uft, sobald das HTML-Dokument geparst wurde**  
âœ… **Bilder, Stylesheets & externe Ressourcen kÃ¶nnen noch laden**  
âœ… **Ideal fÃ¼r DOM-Manipulationen (z. B. `document.querySelector`)**  

---

## **2. `load` â€“ Alles ist vollstÃ¤ndig geladen**
```javascript
window.addEventListener("load", () => {
  console.log("Seite und alle Ressourcen sind vollstÃ¤ndig geladen!");
});
```
âœ… **LÃ¤uft erst, wenn ALLE Ressourcen (CSS, Bilder, Skripte) geladen sind**  
âœ… **Gut fÃ¼r Skripte, die auf vollstÃ¤ndige Inhalte (z. B. Bilder) angewiesen sind**  

---

## **3. Unterschied in der Praxis**
```javascript
document.addEventListener("DOMContentLoaded", () => {
  console.log("HTML ist fertig!");
});

window.addEventListener("load", () => {
  console.log("Alles (inkl. Bilder) ist geladen!");
});
```
**Wenn die Seite lÃ¤dt:**  
```
HTML ist fertig!  // (DOMContentLoaded)
Alles (inkl. Bilder) ist geladen!  // (load)
```

---

## **4. Wann welches Event nutzen?**
| Event | Wann wird es ausgelÃ¶st? | Wann verwenden? |
|-------|-----------------|----------------|
| **`DOMContentLoaded`** | Sobald das HTML vollstÃ¤ndig geladen und geparst ist | Wenn **DOM-Manipulationen** notwendig sind |
| **`load`** | Wenn **alle Ressourcen (CSS, Bilder, Skripte, Fonts)** geladen sind | Wenn Skripte auf **Bilder oder CSS-Abmessungen** angewiesen sind |

ğŸ”— [MDN-Dokumentation zu `DOMContentLoaded`](https://developer.mozilla.org/de/docs/Web/API/Document/DOMContentLoaded_event)  
ğŸ”— [MDN-Dokumentation zu `load`](https://developer.mozilla.org/de/docs/Web/API/Window/load_event)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

65. ### <a name="65"></a> Elemente von der Seite abrufen

### **Elemente von der Seite abrufen in JavaScript**  

JavaScript bietet mehrere Methoden, um **HTML-Elemente** aus dem DOM abzurufen.

---

## **1. `getElementById()` â€“ Einzelnes Element per `id` abrufen**
```javascript
const element = document.getElementById("meinElement");
console.log(element);
```
âœ… **Schnell und effizient**  
âŒ **Nur fÃ¼r ein einzelnes Element mit `id`**  

---

## **2. `getElementsByClassName()` â€“ Elemente per `class` abrufen (Live Collection)**
```javascript
const elements = document.getElementsByClassName("meineKlasse");
console.log(elements[0]); // Erstes Element mit der Klasse
```
âœ… **Live Collection â†’ Aktualisiert sich bei DOM-Ã„nderungen**  
âŒ **Keine Array-Methoden (`map()`, `filter()`)** â†’ `Array.from()` verwenden  

---

## **3. `getElementsByTagName()` â€“ Alle Elemente eines bestimmten Tags abrufen (Live Collection)**
```javascript
const alleDivs = document.getElementsByTagName("div");
console.log(alleDivs.length); // Anzahl der <div>-Elemente
```
âœ… **Schnell fÃ¼r bestimmte Tags (`div`, `p`, `a`)**  
âŒ **Auch eine Live Collection (kein echtes Array)**  

---

## **4. `querySelector()` â€“ Erstes passendes Element per CSS-Selektor abrufen**
```javascript
const erstesDiv = document.querySelector("div");
console.log(erstesDiv);
```
âœ… **Sehr flexibel (CSS-Selektoren wie `#id`, `.class`, `[attr]`)**  
âœ… **Findet nur das erste passende Element**  

---

## **5. `querySelectorAll()` â€“ Alle passenden Elemente abrufen (Statische `NodeList`)**
```javascript
const alleButtons = document.querySelectorAll("button");
console.log(alleButtons);
```
âœ… **Erzeugt eine `NodeList` (Ã¤hnlich einem Array, aber nicht live)**  
âœ… **UnterstÃ¼tzt `forEach()`, `map()`**  
âŒ **Ã„ndert sich nicht, wenn neue Elemente ins DOM kommen**  

---

## **6. `document.forms` â€“ Alle `<form>`-Elemente abrufen**
```javascript
console.log(document.forms);
console.log(document.forms[0].elements); // Alle Eingabefelder der ersten Form
```
âœ… **NÃ¼tzlich fÃ¼r Formulareingaben**  

---

## **7. `document.images`, `document.links` â€“ Spezielle Sammlungen**
```javascript
console.log(document.images); // Alle Bilder (`<img>`)
console.log(document.links); // Alle Links (`<a>`)
```
âœ… **Schneller Zugriff auf spezielle Elemente**  

---

## **Zusammenfassung**
| Methode | RÃ¼ckgabe | Besonderheiten |
|---------|---------|---------------|
| **`getElementById("id")`** | Einzelnes Element (`Element`) | Schnell, aber nur fÃ¼r `id` |
| **`getElementsByClassName("class")`** | Live Collection (`HTMLCollection`) | Kein echtes Array, dynamisch |
| **`getElementsByTagName("tag")`** | Live Collection (`HTMLCollection`) | EnthÃ¤lt alle Elemente des Typs |
| **`querySelector("css-selektor")`** | Erstes passendes Element (`Element`) | Flexibel mit CSS-Selektoren |
| **`querySelectorAll("css-selektor")`** | Statische `NodeList` | UnterstÃ¼tzt `forEach()`, `map()` |
| **`document.forms`** | `HTMLCollection` | Zugriff auf Formulare |
| **`document.images`, `document.links`** | `HTMLCollection` | Schneller Zugriff auf Bilder/Links |

ğŸ”— [MDN-Dokumentation zu `document.querySelector()`](https://developer.mozilla.org/de/docs/Web/API/Document/querySelector)  
ğŸ”— [MDN-Dokumentation zu `getElementById()`](https://developer.mozilla.org/de/docs/Web/API/Document/getElementById)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

66. ### <a name="66"></a> Methoden zum Abrufen von DOM-Elementen in JavaScript

### **Methoden zum Abrufen von DOM-Elementen in JavaScript**  

JavaScript bietet mehrere **DOM-Methoden**, um Elemente aus dem HTML-Dokument abzurufen.  
Hier sind die wichtigsten Methoden mit ihren Unterschieden.

---

## **1. `getElementById(id)` â€“ Einzelnes Element per `id`**
```javascript
const element = document.getElementById("meinElement");
console.log(element);
```
âœ… **Schnell und effizient**  
âœ… **Gibt ein einzelnes Element zurÃ¼ck**  
âŒ **Nur fÃ¼r `id`, keine `class` oder `tag`-Suche**  

---

## **2. `getElementsByClassName(className)` â€“ Alle Elemente mit einer `class` (Live Collection)**
```javascript
const elements = document.getElementsByClassName("meineKlasse");
console.log(elements[0]); // Erstes Element mit der Klasse
```
âœ… **Findet mehrere Elemente**  
âœ… **Schneller als `querySelectorAll()`**  
âŒ **Live Collection (verÃ¤ndert sich bei DOM-Updates)**  
âŒ **Kein echtes Array (`map()`, `filter()` fehlen)**  

ğŸ“Œ **LÃ¶sung: Umwandlung in ein echtes Array**
```javascript
const elementsArray = Array.from(document.getElementsByClassName("meineKlasse"));
```

---

## **3. `getElementsByTagName(tagName)` â€“ Alle Elemente eines bestimmten Tags (Live Collection)**
```javascript
const alleDivs = document.getElementsByTagName("div");
console.log(alleDivs.length); // Anzahl der <div>-Elemente
```
âœ… **Schnell fÃ¼r bestimmte Tags (`div`, `p`, `a`)**  
âœ… **Gibt eine Live Collection zurÃ¼ck**  
âŒ **Kein echtes Array**  

---

## **4. `querySelector(selector)` â€“ Erstes passendes Element per CSS-Selektor**
```javascript
const erstesDiv = document.querySelector("div");
console.log(erstesDiv);
```
âœ… **Sehr flexibel (CSS-Selektoren wie `#id`, `.class`, `[attr]`)**  
âœ… **Gibt nur das erste gefundene Element zurÃ¼ck**  
âŒ **Langsamer als `getElementById()`**  

---

## **5. `querySelectorAll(selector)` â€“ Alle passenden Elemente abrufen (`NodeList`)**
```javascript
const alleButtons = document.querySelectorAll("button");
console.log(alleButtons);
```
âœ… **Erzeugt eine `NodeList` (Ã¤hnlich einem Array, aber nicht live)**  
âœ… **UnterstÃ¼tzt `forEach()`, `map()`**  
âŒ **Ã„ndert sich nicht automatisch bei DOM-Updates**  

ğŸ“Œ **LÃ¶sung: In ein echtes Array umwandeln**
```javascript
const echteArray = [...document.querySelectorAll("button")];
```

---

## **6. `document.forms`, `document.images`, `document.links` â€“ Spezielle Sammlungen**
```javascript
console.log(document.forms); // Alle Formulare
console.log(document.images); // Alle Bilder (`<img>`)
console.log(document.links); // Alle Links (`<a>`)
```
âœ… **Schneller Zugriff auf bestimmte Elemente**  

---

## **7. `document.body`, `document.head`, `document.documentElement`**
```javascript
console.log(document.body); // <body>...</body>
console.log(document.head); // <head>...</head>
console.log(document.documentElement); // <html>...</html>
```
âœ… **Direkter Zugriff auf die Hauptbereiche des Dokuments**  

---

## **Zusammenfassung**
| Methode | RÃ¼ckgabe | Besonderheiten |
|---------|---------|---------------|
| **`getElementById("id")`** | Einzelnes Element (`Element`) | Schnell, nur fÃ¼r `id` |
| **`getElementsByClassName("class")`** | Live Collection (`HTMLCollection`) | Kein echtes Array |
| **`getElementsByTagName("tag")`** | Live Collection (`HTMLCollection`) | EnthÃ¤lt alle Elemente des Typs |
| **`querySelector("css-selektor")`** | Erstes passendes Element (`Element`) | Flexibel mit CSS-Selektoren |
| **`querySelectorAll("css-selektor")`** | Statische `NodeList` | UnterstÃ¼tzt `forEach()`, `map()` |
| **`document.forms`** | `HTMLCollection` | Zugriff auf Formulare |
| **`document.images`, `document.links`** | `HTMLCollection` | Schneller Zugriff auf Bilder/Links |

ğŸ”— [MDN-Dokumentation zu `document.querySelector()`](https://developer.mozilla.org/de/docs/Web/API/Document/querySelector)  
ğŸ”— [MDN-Dokumentation zu `getElementById()`](https://developer.mozilla.org/de/docs/Web/API/Document/getElementById)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

67. ### <a name="67"></a> Navigation durch DOM-Elemente

### **Navigation durch DOM-Elemente in JavaScript**  

JavaScript bietet verschiedene Methoden, um durch das **Document Object Model (DOM)** zu navigieren.  

---

## **1. Eltern-Element abrufen (`parentNode` & `parentElement`)**  
```javascript
const kind = document.getElementById("child");
console.log(kind.parentNode); // Gibt das Ã¼bergeordnete Element zurÃ¼ck
console.log(kind.parentElement); // Meist dasselbe wie `parentNode`
```
âœ… **`parentNode` enthÃ¤lt auch `document`, `parentElement` nicht.**  

---

## **2. Kind-Elemente abrufen (`childNodes` & `children`)**  
```javascript
const eltern = document.getElementById("parent");

console.log(eltern.childNodes); // NodeList (inkl. Text & Kommentare)
console.log(eltern.children); // HTMLCollection (nur Elemente)
```
âœ… **`children` gibt nur echte HTML-Elemente zurÃ¼ck.**  

---

## **3. Erstes & letztes Kind abrufen (`firstChild`, `firstElementChild`)**  
```javascript
console.log(eltern.firstChild); // Erstes Node (auch Text!)
console.log(eltern.firstElementChild); // Erstes echtes Element
console.log(eltern.lastElementChild); // Letztes echtes Element
```
âœ… **`firstChild` kann auch Textknoten sein!**  

---

## **4. Geschwister-Elemente abrufen (`nextSibling`, `previousSibling`)**  
```javascript
const aktuelles = document.getElementById("item");

console.log(aktuelles.nextSibling); // NÃ¤chstes Node (inkl. Text)
console.log(aktuelles.nextElementSibling); // NÃ¤chstes echtes Element
console.log(aktuelles.previousElementSibling); // Vorheriges echtes Element
```
âœ… **`nextElementSibling` & `previousElementSibling` ignorieren Textknoten.**  

---

## **5. Alle Nachfahren (`querySelectorAll()`)**  
```javascript
const nachfahren = document.getElementById("container").querySelectorAll("p");
console.log(nachfahren); // Alle <p>-Elemente innerhalb von #container
```
âœ… **Ideal fÃ¼r selektives Finden von Elementen.**  

---

## **6. Alle Vorfahren (`closest()`)**
```javascript
const item = document.getElementById("child");
console.log(item.closest(".container")); // NÃ¤chstes Ã¼bergeordnetes `.container`
```
âœ… **Findet das nÃ¤chste Ã¼bergeordnete Element mit bestimmtem Selektor.**  

---

### **Zusammenfassung**
| Methode | RÃ¼ckgabe | Besonderheiten |
|---------|---------|---------------|
| **`parentNode` / `parentElement`** | Ãœbergeordnetes Element | `parentElement` gibt nur HTML-Elemente zurÃ¼ck |
| **`childNodes`** | Alle Knoten (inkl. Text) | EnthÃ¤lt auch Leerzeichen & Kommentare |
| **`children`** | Nur HTML-Elemente | Schneller als `childNodes` |
| **`firstChild` / `firstElementChild`** | Erstes Kind | `firstChild` kann auch ein Textknoten sein |
| **`nextSibling` / `nextElementSibling`** | NÃ¤chstes Geschwister-Element | `nextElementSibling` ignoriert Textknoten |
| **`closest(selector)`** | NÃ¤chstes Ã¼bergeordnetes Element | Findet den nÃ¤chsten passenden Vorfahren |

ğŸ”— [MDN-Dokumentation zu `parentElement`](https://developer.mozilla.org/de/docs/Web/API/Node/parentElement)  
ğŸ”— [MDN-Dokumentation zu `closest()`](https://developer.mozilla.org/de/docs/Web/API/Element/closest)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

68. ### <a name="68"></a> classList, className und Ereignisdelegation

### **`classList`, `className` und Ereignisdelegation in JavaScript**  

Diese Konzepte helfen, **CSS-Klassen** zu verwalten und **Ereignisse effizient zu handhaben**.

---

## **1. `classList` â€“ Klassen effizient verwalten (Empfohlen)**
`classList` bietet Methoden, um Klassen hinzuzufÃ¼gen, zu entfernen oder zu toggeln.

```javascript
const element = document.getElementById("meinElement");

// Klasse hinzufÃ¼gen
element.classList.add("neue-klasse");

// Klasse entfernen
element.classList.remove("alte-klasse");

// Klasse umschalten (toggle)
element.classList.toggle("aktiv");

// PrÃ¼fen, ob Klasse existiert
console.log(element.classList.contains("aktiv")); // true oder false
```
âœ… **Mehrere Klassen gleichzeitig verwalten**  
âœ… **`toggle()` erleichtert Umschalten**  

---

## **2. `className` â€“ Klassen als String verwalten (veraltet)**
```javascript
const element = document.getElementById("meinElement");

// Alle Klassen setzen (Ã¼berschreibt vorhandene Klassen!)
element.className = "klasse1 klasse2";
```
âŒ **Ãœberschreibt alle vorhandenen Klassen!**  
âœ… **Praktisch, wenn alle Klassen auf einmal geÃ¤ndert werden mÃ¼ssen.**  

ğŸ“Œ **LÃ¶sung zum HinzufÃ¼gen mit `className` (unsicher)**  
```javascript
element.className += " neue-klasse"; // âŒ Funktioniert, kann aber doppelte Klassen erzeugen
```
ğŸ“Œ **Besser mit `classList.add()`**  

---

## **3. Ereignisdelegation â€“ Events effizient verwalten**
**Ereignisdelegation** ermÃ¶glicht es, Ereignisse auf **Ã¼bergeordnete (`parent`) Elemente** zu setzen, statt auf jedes einzelne Kind-Element (`child`).

```html
<ul id="liste">
  <li>Klick mich 1</li>
  <li>Klick mich 2</li>
  <li>Klick mich 3</li>
</ul>
```

```javascript
document.getElementById("liste").addEventListener("click", (event) => {
  if (event.target.tagName === "LI") {
    event.target.classList.toggle("aktiv"); // Klasse umschalten
    console.log(`Geklickt: ${event.target.innerText}`);
  }
});
```
âœ… **Nur ein Event-Listener fÃ¼r die gesamte Liste**  
âœ… **Neue `li`-Elemente funktionieren automatisch**  

ğŸ“Œ **Vergleich ohne Delegation (schlecht)**  
```javascript
document.querySelectorAll("li").forEach((li) => {
  li.addEventListener("click", () => console.log("LI geklickt!"));
});
```
âŒ **Setzt viele Event-Listener â†’ Langsamer, ineffizient**  

---

### **Zusammenfassung**
| Feature | Methode | Vorteile | Nachteile |
|---------|---------|----------|-----------|
| **Klassen verwalten** | `classList.add()`, `remove()`, `toggle()` | âœ… Sicher & effizient | âŒ Nicht fÃ¼r kompletten Austausch geeignet |
| **Alle Klassen setzen** | `className = "..."` | âœ… Einfach, wenn alle Klassen Ã¼berschrieben werden | âŒ Ãœberschreibt bestehende Klassen |
| **Ereignisdelegation** | `parent.addEventListener("click", callback)` | âœ… Spart Ressourcen, funktioniert mit neuen Elementen | âŒ Muss `event.target` prÃ¼fen |

ğŸ”— [MDN-Dokumentation zu `classList`](https://developer.mozilla.org/de/docs/Web/API/Element/classList)  
ğŸ”— [MDN-Dokumentation zu Ereignisdelegation](https://developer.mozilla.org/de/docs/Learn/JavaScript/Building_blocks/Events#event_delegation)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

69. ### <a name="69"></a> Manipulation von Seitenelementen

### **Manipulation von Seitenelementen in JavaScript**  

Mit JavaScript kÃ¶nnen HTML-Elemente dynamisch **geÃ¤ndert, hinzugefÃ¼gt oder entfernt** werden.

---

## **1. Inhalt Ã¤ndern (`innerHTML`, `textContent`)**
### **1.1 `innerHTML` â€“ HTML-Inhalt setzen (nicht sicher!)**
```javascript
document.getElementById("element").innerHTML = "<strong>Neuer Text</strong>";
```
âŒ **GefÃ¤hrlich: Kann SicherheitslÃ¼cken (XSS) verursachen**  

---

### **1.2 `textContent` â€“ Nur Text setzen (sicher!)**
```javascript
document.getElementById("element").textContent = "<strong>Nur Text</strong>";
```
âœ… **Sicherer als `innerHTML` (keine HTML-AusfÃ¼hrung)**  

---

## **2. Attribute Ã¤ndern (`setAttribute`, `getAttribute`, `removeAttribute`)**
```javascript
const link = document.getElementById("meinLink");

link.setAttribute("href", "https://example.com");
console.log(link.getAttribute("href")); // "https://example.com"
link.removeAttribute("target");
```
âœ… **Funktioniert fÃ¼r alle HTML-Attribute**  

---

## **3. CSS-Klassen verwalten (`classList`)**
```javascript
const box = document.getElementById("box");

box.classList.add("highlight");  // Klasse hinzufÃ¼gen
box.classList.remove("hidden");  // Klasse entfernen
box.classList.toggle("aktiv");   // Umschalten
console.log(box.classList.contains("aktiv")); // true oder false
```
âœ… **Besser als `className` (vermeidet Ãœberschreibung)**  

---

## **4. CSS direkt Ã¤ndern (`style`)**
```javascript
const element = document.getElementById("element");
element.style.color = "red";
element.style.fontSize = "20px";
```
âœ… **Direkte CSS-Ã„nderung mÃ¶glich**  
âŒ **Nicht fÃ¼r komplexe Stylesheets geeignet**  

ğŸ“Œ **Besser: Klasse hinzufÃ¼gen statt Inline-Styles**  
```javascript
element.classList.add("rote-schrift");
```

---

## **5. Elemente erstellen, hinzufÃ¼gen & entfernen**
### **5.1 Neues Element erstellen (`createElement`)**
```javascript
const neuerAbsatz = document.createElement("p");
neuerAbsatz.textContent = "Ich bin neu!";
document.body.appendChild(neuerAbsatz);
```

---

### **5.2 Element an bestimmter Stelle einfÃ¼gen (`insertBefore`)**
```javascript
const liste = document.getElementById("liste");
const neuerEintrag = document.createElement("li");
neuerEintrag.textContent = "Neues Item";

liste.insertBefore(neuerEintrag, liste.children[1]); // Vor 2. Element einfÃ¼gen
```

---

### **5.3 Element entfernen (`remove`)**
```javascript
document.getElementById("zuEntfernen").remove();
```
ğŸ“Œ **Ã„ltere Methode (`removeChild`)**
```javascript
const parent = document.getElementById("container");
const kind = document.getElementById("child");

parent.removeChild(kind);
```

---

### **6. Ereignisse hinzufÃ¼gen (`addEventListener`)**
```javascript
document.getElementById("btn").addEventListener("click", () => {
  alert("Button wurde geklickt!");
});
```

---

### **Zusammenfassung**
| Aktion | Methode | Beschreibung |
|--------|---------|-------------|
| **Inhalt Ã¤ndern** | `innerHTML`, `textContent` | `innerHTML` fÃ¼r HTML, `textContent` fÃ¼r sicheren Text |
| **Attribute Ã¤ndern** | `setAttribute`, `getAttribute`, `removeAttribute` | Manipuliert HTML-Attribute |
| **CSS-Klassen** | `classList.add()`, `remove()`, `toggle()` | Klassen effizient verwalten |
| **CSS-Styles** | `element.style.property` | Direktes Ã„ndern von Styles |
| **Elemente erstellen** | `createElement`, `appendChild`, `insertBefore` | FÃ¼gt neue Elemente hinzu |
| **Elemente entfernen** | `remove()`, `removeChild()` | Entfernt HTML-Elemente |
| **Ereignisse** | `addEventListener()` | Reagiert auf Benutzeraktionen |

ğŸ”— [MDN-Dokumentation zu `document.createElement()`](https://developer.mozilla.org/de/docs/Web/API/Document/createElement)  
ğŸ”— [MDN-Dokumentation zu `classList`](https://developer.mozilla.org/de/docs/Web/API/Element/classList)  

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

70. ### <a name="70"></a> Dokument- und Fensterparameter sowie deren Nutzung

### **Dokument- und Fensterparameter sowie deren Nutzung in JavaScript**  

JavaScript bietet verschiedene **Eigenschaften und Methoden**, um Informationen Ã¼ber das **Dokument (HTML-Seite)** und das **Fenster (Browser-Viewport)** zu erhalten und zu manipulieren.

---

## **1. Fenster-Parameter (`window`-Objekt)**  
Das `window`-Objekt reprÃ¤sentiert das **Browser-Fenster** und enthÃ¤lt Methoden, um GrÃ¶ÃŸe, Position und Verhalten zu steuern.

### **1.1 FenstergrÃ¶ÃŸe (`innerWidth`, `innerHeight`)**
```javascript
console.log(window.innerWidth);  // Breite des sichtbaren Bereichs (Viewport)
console.log(window.innerHeight); // HÃ¶he des Viewports
```
âœ… **Gibt die GrÃ¶ÃŸe des nutzbaren Bereichs im Browser zurÃ¼ck.**  

---

### **1.2 Scroll-Position (`scrollX`, `scrollY`)**
```javascript
console.log(window.scrollX); // Horizontale Scroll-Position
console.log(window.scrollY); // Vertikale Scroll-Position
```
âœ… **Hilfreich fÃ¼r Sticky-Navigationen oder Lazy Loading.**  

ğŸ“Œ **Scroll-Position Ã¤ndern:**
```javascript
window.scrollTo(0, 100); // Scrollt zur Y-Position 100px
window.scrollBy(0, 50);  // Scrollt 50px nach unten
```

---

### **1.3 BildschirmgrÃ¶ÃŸe (`screen`-Objekt)**
```javascript
console.log(screen.width, screen.height); // GesamtbildschirmgrÃ¶ÃŸe
console.log(screen.availWidth, screen.availHeight); // Nutzbare FlÃ¤che
```
âœ… **Zeigt auch verfÃ¼gbare FlÃ¤che ohne Taskleiste.**  

---

### **1.4 Fenster Ã¶ffnen & schlieÃŸen (`open()`, `close()`)**
```javascript
const neuesFenster = window.open("https://example.com", "_blank", "width=600,height=400");
neuesFenster.close(); // SchlieÃŸt das Fenster
```
âœ… **ErmÃ¶glicht das Ã–ffnen neuer Tabs/Fenster.**  
âŒ **Kann durch Pop-up-Blocker verhindert werden.**  

---

## **2. Dokument-Parameter (`document`-Objekt)**
Das `document`-Objekt reprÃ¤sentiert die HTML-Seite.

---

### **2.1 Titel und URL abrufen**
```javascript
console.log(document.title);  // Gibt den Seitentitel zurÃ¼ck
console.log(document.URL);    // Aktuelle URL der Seite
```

ğŸ“Œ **Titel setzen:**
```javascript
document.title = "Neuer Titel";
```

---

### **2.2 DokumentgrÃ¶ÃŸe (`document.documentElement.scrollHeight`)**
```javascript
console.log(document.documentElement.scrollHeight); // Gesamte DokumenthÃ¶he
console.log(document.documentElement.scrollWidth);  // Gesamte Breite
```
âœ… **Wichtig fÃ¼r Infinite-Scrolling oder dynamisches Laden.**  

---

### **2.3 Dokument-Elemente abrufen**
```javascript
console.log(document.body); // Zugriff auf <body>
console.log(document.head); // Zugriff auf <head>
console.log(document.documentElement); // Zugriff auf <html>
```

---

## **3. Fenster-Ereignisse (`resize`, `scroll`, `load`)**
```javascript
window.addEventListener("resize", () => {
  console.log(`Neue GrÃ¶ÃŸe: ${window.innerWidth} x ${window.innerHeight}`);
});

window.addEventListener("scroll", () => {
  console.log(`Scroll-Position: ${window.scrollY}`);
});
```
âœ… **Ideal fÃ¼r responsives Verhalten & dynamisches Layout.**  

---

## **4. `navigator`-Objekt â€“ Browser-Informationen**
```javascript
console.log(navigator.userAgent); // Gibt Browser-Info zurÃ¼ck
console.log(navigator.language);  // Sprache des Browsers
console.log(navigator.platform);  // Betriebssystem
```
âœ… **Wird fÃ¼r GerÃ¤te- & Browser-Erkennung genutzt.**  

---

### **Zusammenfassung**
| Feature | Methode/Eigenschaft | Beschreibung |
|---------|------------------|-------------|
| **FenstergrÃ¶ÃŸe** | `window.innerWidth`, `window.innerHeight` | Gibt die Viewport-GrÃ¶ÃŸe zurÃ¼ck |
| **Scroll-Position** | `window.scrollX`, `window.scrollY` | Aktuelle Scroll-Position |
| **DokumentgrÃ¶ÃŸe** | `document.documentElement.scrollHeight` | Gesamte HÃ¶he des Dokuments |
| **URL & Titel** | `document.URL`, `document.title` | Zeigt und setzt Seitentitel & URL |
| **BildschirmgrÃ¶ÃŸe** | `screen.width`, `screen.height` | BildschirmauflÃ¶sung |
| **Browser-Info** | `navigator.userAgent`, `navigator.language` | Browser- und GerÃ¤teinformationen |
| **Fenster-Events** | `resize`, `scroll`, `load` | Reagiert auf GrÃ¶ÃŸen- und ScrollÃ¤nderungen |

ğŸ”— [MDN-Dokumentation zu `window`](https://developer.mozilla.org/de/docs/Web/API/Window)  
ğŸ”— [MDN-Dokumentation zu `document`](https://developer.mozilla.org/de/docs/Web/API/Document)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

71. ### <a name="71"></a> Web Animations API

### **Web Animations API in JavaScript**  

Die **Web Animations API (WAAPI)** ermÃ¶glicht Animationen direkt mit **JavaScript**, ohne CSS `@keyframes` oder externe Bibliotheken wie jQuery oder GSAP.

---

## **1. Grundlegende Animation mit `element.animate()`**
```javascript
const box = document.getElementById("box");

box.animate(
  [
    { transform: "translateX(0px)" }, 
    { transform: "translateX(200px)" }
  ],
  {
    duration: 1000,  // Dauer in ms (1s)
    iterations: 1,   // Anzahl der Wiederholungen
    easing: "ease-in-out" // Animationstiming
  }
);
```
âœ… **Direkte Steuerung per JavaScript**  
âœ… **Kein zusÃ¤tzliches CSS nÃ¶tig**  

---

## **2. Eigenschaften der Web Animations API**
Ein `animate()`-Aufruf benÃ¶tigt **zwei Parameter**:  
1. **Keyframes** â†’ Eine Liste von Werten, die das Element durchlÃ¤uft.  
2. **Timing-Optionen** â†’ Steuerung von Dauer, Wiederholungen & VerzÃ¶gerung.  

### **2.1 Keyframe-Optionen**
```javascript
const keyframes = [
  { opacity: 0, transform: "translateY(-50px)" },
  { opacity: 1, transform: "translateY(0px)" }
];
```

### **2.2 Timing-Optionen**
```javascript
const options = {
  duration: 1500,  // Animation dauert 1,5 Sekunden
  iterations: Infinity, // Endlos wiederholen
  easing: "ease-in-out", // Weiche Bewegung
  delay: 500, // VerzÃ¶gerung um 0,5s
  fill: "forwards" // Bleibt im Endzustand stehen
};
```

---

## **3. Animation speichern & steuern (`play()`, `pause()`, `reverse()`)**
```javascript
const animation = box.animate(keyframes, options);

// Steuerung der Animation
animation.pause();   // Stoppt die Animation
animation.play();    // Startet sie erneut
animation.reverse(); // LÃ¤uft rÃ¼ckwÃ¤rts
animation.cancel();  // Setzt sie zurÃ¼ck
```
âœ… **Manuelle Steuerung mÃ¶glich**  

---

## **4. Animation mit `finished`-Promise abfragen**
```javascript
animation.finished.then(() => {
  console.log("Animation ist fertig!");
});
```
âœ… **Perfekt fÃ¼r Callback-Funktionen**  

---

## **5. Animation mit `animate()` und `addEventListener`**
```javascript
document.getElementById("btn").addEventListener("click", () => {
  box.animate(
    [
      { transform: "scale(1)" },
      { transform: "scale(1.2)" },
      { transform: "scale(1)" }
    ],
    { duration: 500, iterations: 1 }
  );
});
```
âœ… **Event-Listener kÃ¶nnen Animationen starten**  

---

### **Zusammenfassung**
| Feature | Methode / Eigenschaft | Beschreibung |
|---------|-----------------|--------------|
| **Element animieren** | `element.animate(keyframes, options)` | Startet eine Animation |
| **Animation stoppen** | `animation.pause()` | Stoppt die Animation |
| **Animation fortsetzen** | `animation.play()` | Setzt sie fort |
| **Animation rÃ¼ckgÃ¤ngig** | `animation.reverse()` | Spielt sie rÃ¼ckwÃ¤rts ab |
| **Animation nach Fertigstellung** | `animation.finished.then(callback)` | FÃ¼hrt eine Aktion nach Beendigung aus |

ğŸ”— [MDN-Dokumentation zur Web Animations API](https://developer.mozilla.org/de/docs/Web/API/Web_Animations_API)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**  

72. ### <a name="72"></a> requestAnimationFrame

### **`requestAnimationFrame()` in JavaScript**  

Die Methode **`requestAnimationFrame()`** wird verwendet, um **leistungsoptimierte Animationen** zu erstellen. Sie sorgt fÃ¼r eine **flÃ¼ssige Darstellung**, indem sie Animationen an die Bildwiederholrate (meist **60 FPS**) des Bildschirms anpasst.

---

## **1. Grundlegendes Beispiel â€“ Ein Element bewegen**
```javascript
const box = document.getElementById("box");

let position = 0;
function animate() {
  position += 2;
  box.style.transform = `translateX(${position}px)`;

  if (position < 200) {
    requestAnimationFrame(animate); // NÃ¤chsten Frame planen
  }
}

animate(); // Animation starten
```
âœ… **Effizienter als `setInterval()` oder `setTimeout()`**  
âœ… **Wird automatisch gestoppt, wenn der Tab inaktiv ist**  

---

## **2. Vergleich: `setInterval()` vs. `requestAnimationFrame()`**
### **Mit `setInterval()` (nicht empfohlen)**
```javascript
setInterval(() => {
  box.style.transform = `translateX(${position}px)`;
  position += 2;
}, 16); // ~60 FPS (1000ms / 60 = ~16ms)
```
âŒ **Kann ruckeln, da das Timing nicht an die tatsÃ¤chliche Framerate angepasst wird.**  

### **Mit `requestAnimationFrame()` (empfohlen)**
```javascript
function animate() {
  position += 2;
  box.style.transform = `translateX(${position}px)`;
  requestAnimationFrame(animate);
}
animate();
```
âœ… **Wird synchron zur Bildschirmwiederholrate ausgefÃ¼hrt**  

---

## **3. Animation stoppen (`cancelAnimationFrame()`)**
```javascript
let animationId;
function move() {
  position += 2;
  box.style.transform = `translateX(${position}px)`;
  if (position < 200) {
    animationId = requestAnimationFrame(move);
  }
}

move(); // Startet die Animation

setTimeout(() => {
  cancelAnimationFrame(animationId); // Stoppt die Animation
}, 1000);
```
âœ… **Animation kann jederzeit gestoppt werden**  

---

## **4. FPS messen mit `performance.now()`**
```javascript
let lastTime = performance.now();

function trackFPS() {
  let now = performance.now();
  let fps = Math.round(1000 / (now - lastTime));
  console.log(`FPS: ${fps}`);
  lastTime = now;
  requestAnimationFrame(trackFPS);
}

trackFPS();
```
âœ… **Hilft, die Performance zu analysieren**  

---

### **Zusammenfassung**
| Feature | Methode | Beschreibung |
|---------|---------|--------------|
| **Animation starten** | `requestAnimationFrame(callback)` | Startet eine flÃ¼ssige Animation |
| **Animation stoppen** | `cancelAnimationFrame(id)` | Stoppt eine geplante Animation |
| **Effizienz** | Synchronisiert mit 60 FPS | Verhindert Ruckler und CPU-Ãœberlastung |
| **Alternative zu** | `setInterval()`, `setTimeout()` | Bessere Performance & Energieeffizienz |

ğŸ”— [MDN-Dokumentation zu `requestAnimationFrame()`](https://developer.mozilla.org/de/docs/Web/API/window/requestAnimationFrame)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)** 

73. ### <a name="73"></a> Debouncing und Throttling

### **Debouncing & Throttling in JavaScript**  
Diese beiden Techniken optimieren die Performance von Funktionen, die oft aufgerufen werden, z. B. bei:  
- **Scroll-Events**
- **Resize-Events**
- **Suchfeld-Eingaben**
- **Button-Klicks**

---

## **1. Debouncing (VerzÃ¶gertes AusfÃ¼hren)**
ğŸ“Œ **Debouncing sorgt dafÃ¼r, dass eine Funktion erst nach einer bestimmten Wartezeit (`delay`) ausgefÃ¼hrt wird.**  
- **Gut fÃ¼r Suchfelder:** Verhindert mehrfaches Senden von API-Anfragen beim Tippen.  
- **Wird bei jeder neuen Eingabe zurÃ¼ckgesetzt (letzter Aufruf zÃ¤hlt).**  

### **Beispiel: Debouncing mit `setTimeout()`**
```javascript
function debounce(func, delay) {
  let timer;
  return function (...args) {
    clearTimeout(timer);
    timer = setTimeout(() => func(...args), delay);
  };
}

// Anwendung: Verhindert mehrfaches AuslÃ¶sen bei Eingaben
const searchInput = document.getElementById("search");

searchInput.addEventListener("input", debounce((event) => {
  console.log("Suche:", event.target.value); // Wird erst nach `delay` ms ausgefÃ¼hrt
}, 500));
```
âœ… **Verhindert zu viele API-Anfragen beim schnellen Tippen**  
âœ… **Nur der letzte Aufruf wird ausgefÃ¼hrt**  

---

## **2. Throttling (Begrenztes AusfÃ¼hren)**
ğŸ“Œ **Throttling stellt sicher, dass eine Funktion nur in festen Zeitintervallen (`limit`) aufgerufen wird.**  
- **Gut fÃ¼r Scroll- oder Resize-Events:** Verhindert zu hÃ¤ufige Funktionsaufrufe.  
- **Reduziert die Anzahl der Funktionsaufrufe auf einen bestimmten Zeitraum.**  

### **Beispiel: Throttling mit `setTimeout()`**
```javascript
function throttle(func, limit) {
  let lastCall = 0;
  return function (...args) {
    const now = Date.now();
    if (now - lastCall >= limit) {
      lastCall = now;
      func(...args);
    }
  };
}

// Anwendung: Scroll-Event nur alle 300ms ausfÃ¼hren
window.addEventListener("scroll", throttle(() => {
  console.log("Scroll-Event ausgelÃ¶st");
}, 300));
```
âœ… **Verhindert zu viele Aufrufe bei schnellen Scrollbewegungen**  
âœ… **Stellt sicher, dass die Funktion in regelmÃ¤ÃŸigen AbstÃ¤nden ausgefÃ¼hrt wird**  

---

## **3. Unterschied zwischen Debouncing & Throttling**
| Technik | Wann wird die Funktion ausgefÃ¼hrt? | Anwendung |
|---------|--------------------------------|------------|
| **Debouncing** | **Nur nach VerzÃ¶gerung, wenn keine neue Aktion erfolgt** | **Suchfelder, Formularvalidierung** |
| **Throttling** | **In festen Intervallen, unabhÃ¤ngig von der Aktion** | **Scroll-, Resize-Events, Button-Klicks** |

---

### **Zusammenfassung**
- **Debouncing:** FÃ¼hrt die Funktion **nur aus, wenn kein neuer Aufruf innerhalb des Intervalls erfolgt**.  
- **Throttling:** FÃ¼hrt die Funktion **in festen ZeitabstÃ¤nden aus**, unabhÃ¤ngig davon, wie oft das Event ausgelÃ¶st wird.  

ğŸ”— [MDN-Dokumentation zu `setTimeout()`](https://developer.mozilla.org/en-US/docs/Web/API/setTimeout)  
ğŸ”— [MDN-Dokumentation zu `requestAnimationFrame()` (Alternative fÃ¼r Throttling)](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)** 

74. ### <a name="74"></a> IntersectionObserver API

### **`IntersectionObserver` API in JavaScript**  

Die **`IntersectionObserver` API** ermÃ¶glicht es, Elemente zu beobachten und zu erkennen, ob sie **sichtbar im Viewport sind**.  
Das ist nÃ¼tzlich fÃ¼r:
- **Lazy Loading (Bilder erst laden, wenn sichtbar)**
- **Unendliches Scrollen (Infinite Scroll)**
- **Animationen beim Scrollen starten**
- **SEO-Optimierung (Content erst sichtbar machen, wenn nÃ¶tig)**

---

## **1. Grundlegendes Beispiel: Ein Element beobachten**
```javascript
const element = document.querySelector(".box");

const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      console.log("Das Element ist sichtbar!");
    }
  });
}, {
  root: null, // `null` = gesamter Viewport als Referenz
  threshold: 0.5 // 50% des Elements mÃ¼ssen sichtbar sein
});

observer.observe(element);
```
âœ… **`entry.isIntersecting` ist `true`, wenn das Element sichtbar ist.**  
âœ… **Das `threshold: 0.5` bedeutet, dass **50% des Elements sichtbar sein mÃ¼ssen**, um das Event auszulÃ¶sen.**  

---

## **2. Lazy Loading mit `IntersectionObserver`**
ğŸ“Œ **Bilder erst laden, wenn sie in den Viewport kommen**  

```javascript
const images = document.querySelectorAll("img[data-src]");

const lazyLoad = new IntersectionObserver((entries, observer) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      entry.target.src = entry.target.dataset.src; // Bildquelle aktualisieren
      observer.unobserve(entry.target); // Stoppt das Beobachten
    }
  });
});

images.forEach(img => lazyLoad.observe(img));
```
âœ… **LÃ¤dt nur Bilder, wenn sie wirklich sichtbar sind â†’ bessere Performance!**  
âœ… **Bilder werden nach dem Laden nicht weiter beobachtet (`unobserve()`).**  

---

## **3. Animation beim Scrollen starten**
ğŸ“Œ **Elemente erst animieren, wenn sie sichtbar werden**  

```javascript
const boxes = document.querySelectorAll(".box");

const animateOnScroll = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      entry.target.classList.add("visible");
    }
  });
}, { threshold: 0.2 });

boxes.forEach(box => animateOnScroll.observe(box));
```
ğŸ“Œ **CSS fÃ¼r die Animation:**
```css
.box {
  opacity: 0;
  transform: translateY(50px);
  transition: opacity 0.5s, transform 0.5s;
}

.box.visible {
  opacity: 1;
  transform: translateY(0);
}
```
âœ… **Funktioniert besser als `onscroll`, da es nur aktiviert wird, wenn das Element sichtbar ist!**  

---

## **4. `rootMargin` fÃ¼r Performance-Optimierung**
ğŸ“Œ **`rootMargin` kann das Beobachtungsfenster erweitern/verkleinern.**  
- `rootMargin: "0px 0px -50px 0px"` â†’ **FrÃ¼her auslÃ¶sen, bevor das Element ganz sichtbar ist.**  
- `rootMargin: "100px"` â†’ **LÃ¤dt Elemente 100px vorher ein.**  

```javascript
const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      console.log("Element wurde sichtbar!");
    }
  });
}, {
  root: null, // Standard: gesamter Viewport
  threshold: 0.5, // 50% des Elements sichtbar
  rootMargin: "100px" // LÃ¤dt schon 100px vorher
});

observer.observe(document.querySelector(".box"));
```
âœ… **Verhindert, dass Elemente zu spÃ¤t geladen werden**  
âœ… **Besonders nÃ¼tzlich fÃ¼r Lazy Loading & Infinite Scroll**  

---

## **5. Unendliches Scrollen (Infinite Scroll)**
ğŸ“Œ **Neue Inhalte laden, wenn das Ende erreicht ist**  

```javascript
const loadMoreTrigger = document.querySelector("#loadMore");

const infiniteScroll = new IntersectionObserver((entries) => {
  if (entries[0].isIntersecting) {
    console.log("Mehr Inhalte laden...");
    // API-Anfrage oder neue Elemente hinzufÃ¼gen
  }
}, { rootMargin: "100px" });

infiniteScroll.observe(loadMoreTrigger);
```
âœ… **Verhindert unnÃ¶tige Anfragen bei jedem Scrollen**  
âœ… **Ersetzt manuelles `scroll`-Event**  

---

### **Zusammenfassung**
| Feature | Beschreibung |
|---------|-------------|
| **`isIntersecting`** | PrÃ¼ft, ob ein Element im Viewport ist |
| **`threshold`** | Wert zwischen `0` (sichtbar) und `1` (voll sichtbar) |
| **`rootMargin`** | Abstand zum Viewport (z. B. `100px`) |
| **`unobserve()`** | Stoppt das Beobachten eines Elements |

ğŸ”— [MDN-Dokumentation zu `IntersectionObserver`](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)** 

75. ### <a name="75"></a> Unterschied zwischen innerHTML, textContent und innerText

### **Unterschied zwischen `innerHTML`, `textContent` und `innerText` in JavaScript**  

ğŸ“Œ **Diese drei Methoden werden verwendet, um den Inhalt eines HTML-Elements zu lesen oder zu Ã¤ndern, haben aber unterschiedliche Eigenschaften.**

---

## **1. `innerHTML` â€“ HTML als String interpretieren**  
ğŸ“Œ **Liest oder setzt den kompletten HTML-Inhalt eines Elements, einschlieÃŸlich HTML-Tags.**  
```javascript
const div = document.getElementById("test");
div.innerHTML = "<strong>Fett</strong> und <em>Kursiv</em>";
console.log(div.innerHTML); // âœ… "<strong>Fett</strong> und <em>Kursiv</em>"
```
âœ… **Kann HTML interpretieren (z. B. `<strong>` bleibt erhalten)**  
âŒ **Kann ein Sicherheitsrisiko sein (`XSS-Angriffe` durch `innerHTML = userInput`)**  

---

## **2. `textContent` â€“ Reiner Text, ignoriert HTML**  
ğŸ“Œ **Setzt oder liest den reinen Text, ohne HTML zu interpretieren.**  
```javascript
const div = document.getElementById("test");
div.textContent = "<strong>Fett</strong> und <em>Kursiv</em>";
console.log(div.textContent); // âœ… "<strong>Fett</strong> und <em>Kursiv</em>"
```
âœ… **Sicher vor XSS-Angriffen (keine HTML-Verarbeitung)**  
âœ… **Nimmt auch versteckten Text (`display: none`) mit**  

---

## **3. `innerText` â€“ Sichtbarer Text (beachtet CSS)**  
ğŸ“Œ **Liest oder setzt nur den sichtbaren Text (CSS-`display: none` wird ignoriert).**  
```javascript
const div = document.getElementById("test");
div.innerText = "<strong>Fett</strong> und <em>Kursiv</em>";
console.log(div.innerText); // âœ… "<strong>Fett</strong> und <em>Kursiv</em>"
```
âœ… **Beachtet CSS (`display: none`-Texte werden ignoriert)**  
âœ… **Performance kann schlechter sein, da CSS beachtet wird**  

---

### **Unterschiede zusammengefasst**
| Methode | HTML wird interpretiert? | `display: none`-Text sichtbar? | Sicher gegen XSS? |
|---------|------------------|----------------------|----------------|
| **`innerHTML`** | âœ… Ja | âœ… Ja | âŒ Nein |
| **`textContent`** | âŒ Nein | âœ… Ja | âœ… Ja |
| **`innerText`** | âŒ Nein | âŒ Nein | âœ… Ja |

ğŸ”— [MDN-Dokumentation zu `innerHTML`](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML)  
ğŸ”— [MDN-Dokumentation zu `textContent`](https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent)  
ğŸ”— [MDN-Dokumentation zu `innerText`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/innerText)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)** 

76. ### <a name="76"></a> setTimeout und setInterval, Besonderheiten

### **`setTimeout()` und `setInterval()` in JavaScript**  

Diese Methoden werden verwendet, um **zeitverzÃ¶gerte oder wiederholte AusfÃ¼hrungen** von Funktionen zu steuern.  

---

## **1. `setTimeout(callback, delay)` â€“ VerzÃ¶gerte AusfÃ¼hrung**
FÃ¼hrt eine Funktion **nach einer bestimmten Zeit (ms)** einmal aus.

```javascript
setTimeout(() => {
  console.log("Nach 2 Sekunden ausgefÃ¼hrt!");
}, 2000);
```
âœ… **Einmalige VerzÃ¶gerung**  
âŒ **Funktioniert asynchron â€“ lÃ¤uft unabhÃ¤ngig vom Hauptcode**  

---

### **1.1 `setTimeout()` abbrechen mit `clearTimeout()`**
```javascript
const timeoutId = setTimeout(() => {
  console.log("Das wird nicht ausgefÃ¼hrt!");
}, 2000);

clearTimeout(timeoutId); // LÃ¶scht den Timeout
```
âœ… **NÃ¼tzlich, um VerzÃ¶gerungen zu stoppen (z. B. Ladeanimationen)**  

---

## **2. `setInterval(callback, delay)` â€“ Wiederholte AusfÃ¼hrung**
FÃ¼hrt eine Funktion **immer wieder nach einer bestimmten Zeit aus**.

```javascript
const intervalId = setInterval(() => {
  console.log("Alle 2 Sekunden wiederholt!");
}, 2000);
```
âœ… **Perfekt fÃ¼r zyklische Updates (z. B. Uhren, Echtzeit-Daten)**  

---

### **2.1 `setInterval()` abbrechen mit `clearInterval()`**
```javascript
const intervalId = setInterval(() => {
  console.log("Wiederholung...");
}, 1000);

setTimeout(() => {
  clearInterval(intervalId); // Stoppt den `setInterval`
  console.log("Interval gestoppt!");
}, 5000);
```
âœ… **NÃ¼tzlich, um Loops zu stoppen (z. B. nach X Sekunden)**  

---

## **3. `setTimeout()` als `setInterval()`-Alternative**
Manchmal ist es besser, `setTimeout()` rekursiv zu verwenden, statt `setInterval()`.

```javascript
function wiederhole() {
  console.log("Wiederholung...");
  setTimeout(wiederhole, 1000); // Wartet 1 Sekunde und ruft sich erneut auf
}

wiederhole();
```
âœ… **Bessere Kontrolle als `setInterval()` (z. B. variabler Delay)**  

---

## **4. Besonderheiten & Probleme**
### **4.1 `setTimeout(0)` â€“ Wann wird es ausgefÃ¼hrt?**
```javascript
console.log("Start");

setTimeout(() => {
  console.log("Timeout mit 0 ms!");
}, 0);

console.log("Ende");
```
**Konsolenausgabe:**
```
Start
Ende
Timeout mit 0 ms!
```
ğŸ“Œ **Grund:** `setTimeout(0)` wird erst nach dem aktuellen Callstack ausgefÃ¼hrt!  

---

### **4.2 `setInterval()` kann ungenau sein**
```javascript
let count = 0;
const start = Date.now();

const interval = setInterval(() => {
  count++;
  console.log(`Laufzeit: ${Date.now() - start} ms`);
  if (count === 5) clearInterval(interval);
}, 1000);
```
âŒ **`setInterval(1000)` lÃ¤uft nicht exakt jede Sekunde, weil andere Code-AusfÃ¼hrungen VerzÃ¶gerungen verursachen kÃ¶nnen.**  
âœ… **Besser:** `setTimeout()` rekursiv nutzen (siehe Punkt 3).  

---

### **Zusammenfassung**
| Methode | Beschreibung | Stoppen mit |
|---------|-------------|------------|
| **`setTimeout(callback, delay)`** | FÃ¼hrt `callback` **einmal** nach `delay` ms aus | `clearTimeout(id)` |
| **`setInterval(callback, delay)`** | FÃ¼hrt `callback` **wiederholt** alle `delay` ms aus | `clearInterval(id)` |
| **Alternative** | `setTimeout()` rekursiv als `setInterval()`-Ersatz nutzen | - |

ğŸ”— [MDN-Dokumentation zu `setTimeout()`](https://developer.mozilla.org/de/docs/Web/API/setTimeout)  
ğŸ”— [MDN-Dokumentation zu `setInterval()`](https://developer.mozilla.org/de/docs/Web/API/setInterval)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)** 

77. ### <a name="77"></a> AJAX und XMLHttpRequest

### **AJAX und `XMLHttpRequest` in JavaScript**  

**AJAX (Asynchronous JavaScript and XML)** ermÃ¶glicht das **asynchrone Laden von Daten** in eine Webseite, ohne die Seite neu zu laden.  
Dazu wird hÃ¤ufig das **`XMLHttpRequest`-Objekt (XHR)** oder die modernere **`fetch()`-API** verwendet.

---

## **1. Grundlagen: `XMLHttpRequest`**
```javascript
const xhr = new XMLHttpRequest();
xhr.open("GET", "https://jsonplaceholder.typicode.com/posts/1", true);
xhr.onreadystatechange = function () {
  if (xhr.readyState === 4 && xhr.status === 200) {
    console.log(JSON.parse(xhr.responseText)); // Antwort als JSON ausgeben
  }
};
xhr.send();
```
âœ… **`xhr.open(method, url, async)`** â†’ Ã–ffnet eine Verbindung  
âœ… **`xhr.send()`** â†’ Sendet die Anfrage  

---

## **2. `readyState` Werte (`onreadystatechange`)**
| `readyState` | Bedeutung |
|-------------|-----------|
| `0` | Anfrage nicht initialisiert (`UNSENT`) |
| `1` | Verbindung geÃ¶ffnet (`OPENED`) |
| `2` | Anfrage gesendet (`HEADERS_RECEIVED`) |
| `3` | Antwort wird geladen (`LOADING`) |
| `4` | Antwort vollstÃ¤ndig (`DONE`) |

---

## **3. HTTP-Methoden mit `XMLHttpRequest`**
### **3.1 `GET`-Anfrage**
```javascript
xhr.open("GET", "https://jsonplaceholder.typicode.com/users", true);
xhr.send();
```

### **3.2 `POST`-Anfrage (Daten senden)**
```javascript
const xhr = new XMLHttpRequest();
xhr.open("POST", "https://jsonplaceholder.typicode.com/posts", true);
xhr.setRequestHeader("Content-Type", "application/json;charset=UTF-8");

xhr.onreadystatechange = function () {
  if (xhr.readyState === 4 && xhr.status === 201) {
    console.log("Erfolgreich gesendet:", JSON.parse(xhr.responseText));
  }
};

const daten = JSON.stringify({ title: "Neuer Beitrag", body: "Inhalt", userId: 1 });
xhr.send(daten);
```
âœ… **`xhr.setRequestHeader()` setzt die benÃ¶tigten Header fÃ¼r JSON-Daten**  

---

## **4. Fehlerbehandlung**
```javascript
xhr.onerror = function () {
  console.log("Fehler beim Laden der Daten!");
};
```
âœ… **Wichtig fÃ¼r Netzwerkfehler**  

---

## **5. `fetch()` als moderner Ersatz fÃ¼r `XMLHttpRequest`**
```javascript
fetch("https://jsonplaceholder.typicode.com/posts/1")
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error("Fehler:", error));
```
âœ… **KÃ¼rzere Syntax**  
âœ… **Verwendet Promises statt `onreadystatechange`**  

---

### **Zusammenfassung**
| Methode | Beschreibung |
|---------|-------------|
| **`XMLHttpRequest`** | Ã„ltere AJAX-Technik, erfordert `onreadystatechange` |
| **`fetch()`** | Moderner, nutzt Promises, kÃ¼rzere Syntax |
| **`readyState`** | Zeigt Status der Anfrage (`0-4`) |
| **`xhr.setRequestHeader()`** | Setzt HTTP-Header fÃ¼r Anfragen |

ğŸ”— [MDN-Dokumentation zu `XMLHttpRequest`](https://developer.mozilla.org/de/docs/Web/API/XMLHttpRequest)  
ğŸ”— [MDN-Dokumentation zu `fetch()`](https://developer.mozilla.org/de/docs/Web/API/Fetch_API)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)** 

78. ### <a name="78"></a> Promise (ES6)

### **Promise (ES6) in JavaScript**  

Ein **Promise** ist ein **Objekt**, das einen **asynchronen Prozess** reprÃ¤sentiert. Es kann folgende ZustÃ¤nde haben:  

- **`pending`** â†’ Der Promise wird ausgefÃ¼hrt (noch nicht abgeschlossen).  
- **`fulfilled`** â†’ Der Promise wurde erfolgreich abgeschlossen (`resolve`).  
- **`rejected`** â†’ Der Promise ist fehlgeschlagen (`reject`).  

---

## **1. Einfache `Promise`-Erstellung**
```javascript
const meinPromise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("Erfolg!"); // Promise erfolgreich
    // reject("Fehler!"); // Falls Fehler auftritt
  }, 2000);
});

meinPromise
  .then((ergebnis) => console.log(ergebnis)) // "Erfolg!"
  .catch((fehler) => console.error(fehler)) // Falls `reject` ausgefÃ¼hrt wurde
  .finally(() => console.log("Fertig!")); // Wird immer ausgefÃ¼hrt
```
âœ… **`resolve(value)`** â†’ Erfolg (geht in `.then()`)  
âœ… **`reject(error)`** â†’ Fehler (geht in `.catch()`)  
âœ… **`finally()`** â†’ Wird immer ausgefÃ¼hrt  

---

## **2. Verkettung von Promises (`then()`)**
```javascript
new Promise((resolve) => resolve(2))
  .then((wert) => wert * 2)
  .then((wert) => wert + 3)
  .then((wert) => console.log(wert)); // 7
```
âœ… **`then()` gibt automatisch einen neuen Promise zurÃ¼ck**  

---

## **3. `Promise.all()` â€“ Mehrere Promises parallel ausfÃ¼hren**
```javascript
const p1 = new Promise((resolve) => setTimeout(() => resolve("A"), 1000));
const p2 = new Promise((resolve) => setTimeout(() => resolve("B"), 2000));

Promise.all([p1, p2]).then((ergebnisse) => console.log(ergebnisse)); // ["A", "B"] nach 2s
```
âœ… **Wird erst ausgefÃ¼hrt, wenn ALLE Promises erfolgreich sind**  
âŒ **Falls ein Promise fehlschlÃ¤gt, wird der gesamte `Promise.all()` abgebrochen**  

ğŸ“Œ **Fehlertolerante Alternative: `Promise.allSettled()`**
```javascript
Promise.allSettled([p1, Promise.reject("Fehler")])
  .then((ergebnisse) => console.log(ergebnisse));
```
âœ… **Jedes Promise gibt seinen Status zurÃ¼ck (`fulfilled` oder `rejected`)**  

---

## **4. `Promise.race()` â€“ Erstes abgeschlossenes Promise gewinnt**
```javascript
Promise.race([
  new Promise((resolve) => setTimeout(() => resolve("Schnell"), 1000)),
  new Promise((resolve) => setTimeout(() => resolve("Langsam"), 3000))
]).then((ergebnis) => console.log(ergebnis)); // "Schnell" nach 1s
```
âœ… **NÃ¼tzlich fÃ¼r Timeout-Strategien**  

---

## **5. `Promise.any()` â€“ Erster `resolve()` gewinnt (ES2021)**
```javascript
Promise.any([
  Promise.reject("Fehler 1"),
  new Promise((resolve) => setTimeout(() => resolve("Erfolg"), 2000)),
  Promise.reject("Fehler 2")
]).then((ergebnis) => console.log(ergebnis)); // "Erfolg" nach 2s
```
âœ… **Ignoriert Fehler, solange mindestens ein Promise erfolgreich ist**  
âŒ **Falls alle fehlschlagen â†’ `AggregateError`**  

---

## **6. `async/await` als Alternative zu Promises**
```javascript
async function ladeDaten() {
  try {
    let daten = await fetch("https://jsonplaceholder.typicode.com/posts/1");
    let json = await daten.json();
    console.log(json);
  } catch (fehler) {
    console.error("Fehler:", fehler);
  }
}

ladeDaten();
```
âœ… **Bessere Lesbarkeit als `.then()`-Ketten**  
âœ… **Kann mit `try/catch` Fehler abfangen**  

---

### **Zusammenfassung**
| Methode | Beschreibung |
|---------|-------------|
| **`then()`** | Wird bei `resolve()` ausgefÃ¼hrt |
| **`catch()`** | Wird bei `reject()` ausgefÃ¼hrt |
| **`finally()`** | Wird immer ausgefÃ¼hrt |
| **`Promise.all([])`** | Wartet auf alle Promises, bricht bei Fehler ab |
| **`Promise.allSettled([])`** | Wartet auf alle Promises, gibt Status zurÃ¼ck |
| **`Promise.race([])`** | Nimmt das erste Promise, das fertig ist |
| **`Promise.any([])`** | Nimmt das erste erfolgreiche Promise |

ğŸ”— [MDN-Dokumentation zu Promises](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Promise)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)** 

79. ### <a name="79"></a> Fetch API

### **Fetch API in JavaScript**  

Die **Fetch API** ist eine moderne MÃ¶glichkeit, um **asynchrone HTTP-Anfragen** zu senden. Sie bietet eine **promisbasierte API** und ist eine Alternative zu `XMLHttpRequest`.

---

## **1. Grundlegende Verwendung von `fetch()`**
```javascript
fetch("https://jsonplaceholder.typicode.com/posts/1")
  .then((response) => response.json()) // Antwort als JSON parsen
  .then((data) => console.log(data))    // Die Daten weiterverarbeiten
  .catch((error) => console.error("Fehler:", error)); // Fehlerbehandlung
```
âœ… **`fetch()` gibt ein Promise zurÃ¼ck**, das mit der Antwort (Response) aufgelÃ¶st wird.  
âœ… **Antworten mÃ¼ssen explizit in das gewÃ¼nschte Format (z. B. `json()`) umgewandelt werden.**

---

## **2. `fetch()` mit POST-Anfragen und Senden von Daten**
```javascript
fetch("https://jsonplaceholder.typicode.com/posts", {
  method: "POST",                       // HTTP-Methode
  headers: {                            // Header
    "Content-Type": "application/json"
  },
  body: JSON.stringify({                // Daten, die gesendet werden
    title: "Neuer Post",
    body: "Dies ist ein neuer Beitrag.",
    userId: 1
  })
})
  .then((response) => response.json())
  .then((data) => console.log(data))
  .catch((error) => console.error("Fehler:", error));
```
âœ… **`method`** gibt die HTTP-Methode an (`GET`, `POST`, etc.)  
âœ… **`headers`** definieren die Header der Anfrage  
âœ… **`body`** enthÃ¤lt die gesendeten Daten (wird normalerweise als JSON-String Ã¼bertragen)

---

## **3. Behandlung der Antwort**
### **3.1 ÃœberprÃ¼fen des Statuscodes**
```javascript
fetch("https://jsonplaceholder.typicode.com/posts/1")
  .then((response) => {
    if (!response.ok) { // Statuscode 200-299
      throw new Error("Fehler beim Abrufen der Daten");
    }
    return response.json();
  })
  .then((data) => console.log(data))
  .catch((error) => console.error("Fehler:", error));
```
âœ… **`response.ok`** Ã¼berprÃ¼ft, ob der Statuscode im Bereich 200-299 liegt.  
âœ… **Fehlerbehandlung** ist wichtig, um auf HTTP-Fehler zu reagieren.

---

### **3.2 Umwandeln der Antwort in andere Formate**
```javascript
fetch("https://jsonplaceholder.typicode.com/posts/1")
  .then((response) => response.text()) // Antwort als Text
  .then((text) => console.log(text))    // Textinhalt ausgeben

fetch("https://jsonplaceholder.typicode.com/posts/1")
  .then((response) => response.blob()) // Antwort als Blob (z. B. Bild)
  .then((blob) => console.log(blob))    // Blob weiterverarbeiten
```
âœ… **`text()`**, **`json()`**, **`blob()`** und andere Methoden wandeln die Antwort in unterschiedliche Formate um.

---

## **4. `async/await` mit Fetch API**
```javascript
async function fetchDaten() {
  try {
    const response = await fetch("https://jsonplaceholder.typicode.com/posts/1");
    if (!response.ok) {
      throw new Error("Fehler beim Abrufen der Daten");
    }
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error("Fehler:", error);
  }
}

fetchDaten();
```
âœ… **`async/await` macht den Code lesbarer und synchroner.**  
âœ… **Fehler kÃ¶nnen direkt mit `try/catch` abgefangen werden.**

---

## **5. CORS (Cross-Origin Resource Sharing)**
**CORS** steuert, ob eine Webanwendung **Anfragen von einer anderen DomÃ¤ne** ausfÃ¼hren kann. Wenn ein Fehler auftritt, sieht die Fehlermeldung z. B. so aus:
```
Access to fetch at 'https://example.com' from origin 'https://yourwebsite.com' has been blocked by CORS policy.
```
âœ… **CORS-Probleme kÃ¶nnen mit Serverkonfigurationen oder durch HinzufÃ¼gen von CORS-Headern auf dem Server behoben werden.**

---

## **6. Optionen wie `mode`, `credentials`, `cache`**
```javascript
fetch("https://jsonplaceholder.typicode.com/posts/1", {
  method: "GET",
  headers: {
    "Accept": "application/json"
  },
  mode: "cors",          // CORS-Modus (z. B. "cors", "no-cors", "same-origin")
  credentials: "same-origin",  // Senden von Cookies nur bei derselben Herkunft
  cache: "no-cache"      // Cache-Optionen (z. B. "no-cache", "reload", "force-cache")
})
  .then((response) => response.json())
  .then((data) => console.log(data));
```
âœ… **`mode`** regelt CORS-Handling.  
âœ… **`credentials`** steuert das Senden von Cookies und Authentifizierung.  
âœ… **`cache`** bietet Optionen zur Caching-Strategie.

---

### **Zusammenfassung**
| Methode | Beschreibung |
|---------|-------------|
| **`fetch(url, options)`** | Senden von HTTP-Anfragen (z. B. `GET`, `POST`) |
| **`response.json()`** | Antwort als JSON parsen |
| **`response.text()`** | Antwort als Text parsen |
| **`response.blob()`** | Antwort als Blob parsen (z. B. Bilder) |
| **`response.ok`** | ÃœberprÃ¼ft, ob die Antwort erfolgreich war (Status 200-299) |
| **`async/await`** | Verbessert die Lesbarkeit und Fehlerbehandlung von `fetch()` |

ğŸ”— [MDN-Dokumentation zu `fetch()`](https://developer.mozilla.org/de/docs/Web/API/Fetch_API)  
ğŸ”— [MDN-Dokumentation zu `Response`](https://developer.mozilla.org/de/docs/Web/API/Response)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)** 

80. ### <a name="80"></a> Async/Await (ES8)

### **Async/Await (ES8) in JavaScript**  

**`async/await`** ist eine **modernere Alternative** zu Promises (`.then()`-Ketten) und macht asynchronen Code **lesbarer und synchroner**.

---

## **1. `async`-Funktion erstellen**
Eine **`async`-Funktion** gibt immer **ein Promise zurÃ¼ck**.

```javascript
async function beispiel() {
  return "Hallo Welt!";
}

beispiel().then(console.log); // "Hallo Welt!"
```
âœ… **Automatische RÃ¼ckgabe eines Promises**  
âœ… **Kein explizites `return new Promise()` nÃ¶tig**  

---

## **2. `await` â€“ Warte auf Promise-Ergebnisse**
```javascript
async function ladeDaten() {
  let response = await fetch("https://jsonplaceholder.typicode.com/posts/1");
  let daten = await response.json();
  console.log(daten);
}

ladeDaten();
```
âœ… **`await` wartet, bis das Promise aufgelÃ¶st wurde**  
âœ… **Kein `.then()` nÃ¶tig**  

---

## **3. Fehlerbehandlung mit `try/catch`**
```javascript
async function ladeDatenMitFehler() {
  try {
    let response = await fetch("https://jsonplaceholder.typicode.com/invalid-url");
    if (!response.ok) throw new Error("Fehlerhafte Anfrage!");
    
    let daten = await response.json();
    console.log(daten);
  } catch (error) {
    console.error("Fehler:", error);
  }
}

ladeDatenMitFehler();
```
âœ… **Besser als `.catch()` fÃ¼r Fehlerbehandlung**  

---

## **4. `async/await` mit mehreren Promises (`Promise.all`)**
```javascript
async function ladeMehrereDaten() {
  let [benutzer, beitraege] = await Promise.all([
    fetch("https://jsonplaceholder.typicode.com/users/1").then((res) => res.json()),
    fetch("https://jsonplaceholder.typicode.com/posts?userId=1").then((res) => res.json()),
  ]);

  console.log(benutzer, beitraege);
}

ladeMehrereDaten();
```
âœ… **Effizient â€“ Beide Anfragen laufen gleichzeitig!**  

---

## **5. `await` in Schleifen (nacheinander ausfÃ¼hren)**
```javascript
async function ladeNacheinander() {
  for (let id of [1, 2, 3]) {
    let res = await fetch(`https://jsonplaceholder.typicode.com/posts/${id}`);
    let daten = await res.json();
    console.log(daten.title);
  }
}

ladeNacheinander();
```
âœ… **FÃ¼hrt Anfragen in einer Schleife nacheinander aus**  
âŒ **Langsamer als `Promise.all()` (kein paralleles Laden)**  

---

## **6. `await` in einer normalen Funktion (geht nicht)**
âŒ **`await` kann nur in `async`-Funktionen verwendet werden!**
```javascript
// UngÃ¼ltig:
function test() {
  let data = await fetch("https://jsonplaceholder.typicode.com/posts/1"); // âŒ Fehler!
}
```
âœ… **LÃ¶sung:** Funktion in `async`-Funktion umwandeln  
```javascript
async function test() {
  let data = await fetch("https://jsonplaceholder.typicode.com/posts/1");
  console.log(await data.json());
}
```

---

### **Zusammenfassung**
| Feature | Beschreibung |
|---------|-------------|
| **`async function()`** | Erstellt eine asynchrone Funktion, gibt ein Promise zurÃ¼ck |
| **`await`** | Wartet auf das Ergebnis eines Promises |
| **`try/catch`** | FÃ¤ngt Fehler in `async`-Funktionen ab |
| **`Promise.all()`** | FÃ¼hrt mehrere Promises parallel aus |
| **`await` in Schleifen** | FÃ¼hrt Promises nacheinander aus |

ğŸ”— [MDN-Dokumentation zu `async/await`](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Statements/async_function)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)** 

81. ### <a name="81"></a> try...catch, throw-Anweisung

### **`try...catch` und `throw` in JavaScript**  

Die **`try...catch`-Anweisung** dient zur **Fehlerbehandlung**, wÃ¤hrend **`throw`** es ermÃ¶glicht, manuell Fehler auszulÃ¶sen.

---

## **1. Grundlegende Fehlerbehandlung mit `try...catch`**
```javascript
try {
  let x = y + 1; // Fehler: `y` ist nicht definiert
} catch (error) {
  console.log("Fehler:", error.message);
}
```
âœ… **`try`-Block fÃ¼hrt den Code aus**  
âœ… **`catch`-Block fÃ¤ngt Fehler ab und verhindert Absturz**  

---

## **2. `catch` kann Fehlerdetails abrufen**
```javascript
try {
  let x = y + 1;
} catch (error) {
  console.log("Fehlertyp:", error.name); // ReferenceError
  console.log("Fehlermeldung:", error.message); // y is not defined
}
```
âœ… **`error.name` â†’ Fehlertyp (z. B. `ReferenceError`, `TypeError`)**  
âœ… **`error.message` â†’ Detaillierte Fehlermeldung**  

---

## **3. `throw` â€“ Eigene Fehler auslÃ¶sen**
```javascript
function prÃ¼feAlter(alter) {
  if (alter < 18) {
    throw new Error("Du bist zu jung!");
  }
  return "Zugang erlaubt";
}

try {
  console.log(prÃ¼feAlter(16));
} catch (error) {
  console.error("Fehler:", error.message);
}
```
âœ… **`throw` kann benutzerdefinierte Fehler auslÃ¶sen**  

ğŸ“Œ **Ohne `try...catch` wÃ¼rde das Skript abstÃ¼rzen!**  

---

## **4. `finally` â€“ Code immer ausfÃ¼hren**
```javascript
try {
  console.log("Code wird ausgefÃ¼hrt");
} catch (error) {
  console.log("Fehler passiert");
} finally {
  console.log("Wird immer ausgefÃ¼hrt!");
}
```
âœ… **`finally` wird immer ausgefÃ¼hrt â€“ auch bei Fehlern!**  

---

## **5. `try...catch` mit `async/await`**
```javascript
async function ladeDaten() {
  try {
    let response = await fetch("https://jsonplaceholder.typicode.com/invalid-url");
    if (!response.ok) throw new Error("Fehlerhafte Anfrage!");
    
    let daten = await response.json();
    console.log(daten);
  } catch (error) {
    console.error("Fehler:", error.message);
  }
}

ladeDaten();
```
âœ… **FÃ¤ngt Fehler bei `fetch()` oder anderen Promises ab**  

---

### **Zusammenfassung**
| Anweisung | Beschreibung |
|-----------|-------------|
| **`try {}`** | FÃ¼hrt den Code aus |
| **`catch(error) {}`** | FÃ¤ngt Fehler ab |
| **`error.name`** | Zeigt den Fehler-Typ (z. B. `TypeError`) |
| **`error.message`** | Gibt die Fehlermeldung aus |
| **`throw new Error("...")`** | LÃ¶st einen eigenen Fehler aus |
| **`finally {}`** | Wird immer ausgefÃ¼hrt, egal ob Fehler oder nicht |

ğŸ”— [MDN-Dokumentation zu `try...catch`](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Statements/try...catch)  
ğŸ”— [MDN-Dokumentation zu `throw`](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Statements/throw)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)** 

82. ### <a name="82"></a> Axios-Bibliothek

### **Axios-Bibliothek in JavaScript**  

**Axios** ist eine beliebte **HTTP-Client-Bibliothek**, die einfacher und leistungsfÃ¤higer als die native `fetch()`-API ist.  
Sie basiert auf **Promises** und unterstÃ¼tzt **automatische JSON-Verarbeitung, Fehlerbehandlung und Abbruch von Anfragen**.

ğŸ“Œ **Installation (fÃ¼r Node.js / Browser mit npm):**
```bash
npm install axios
```
ğŸ“Œ **CDN fÃ¼r den Browser:**
```html
<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
```

---

## **1. `GET`-Anfrage mit Axios**
```javascript
axios.get("https://jsonplaceholder.typicode.com/posts/1")
  .then((response) => console.log(response.data)) // JSON-Daten ausgeben
  .catch((error) => console.error("Fehler:", error));
```
âœ… **`axios.get(url)`** â†’ FÃ¼hrt eine `GET`-Anfrage aus  
âœ… **Antwort ist bereits in `response.data` (kein `response.json()` nÃ¶tig)**  

---

## **2. `POST`-Anfrage mit Axios**
```javascript
axios.post("https://jsonplaceholder.typicode.com/posts", {
  title: "Neuer Beitrag",
  body: "Inhalt des Beitrags",
  userId: 1
})
  .then((response) => console.log(response.data))
  .catch((error) => console.error("Fehler:", error));
```
âœ… **Automatische Umwandlung in JSON**  
âœ… **Kein `fetch() + JSON.stringify()` nÃ¶tig**  

---

## **3. `PUT` und `DELETE` mit Axios**
```javascript
// Eintrag aktualisieren (PUT)
axios.put("https://jsonplaceholder.typicode.com/posts/1", {
  title: "Aktualisierter Titel",
  body: "Neuer Inhalt"
});

// Eintrag lÃ¶schen (DELETE)
axios.delete("https://jsonplaceholder.typicode.com/posts/1")
  .then(() => console.log("Erfolgreich gelÃ¶scht!"));
```
âœ… **PUT: Ãœberschreibt die gesamte Ressource**  
âœ… **DELETE: Entfernt eine Ressource**  

---

## **4. `async/await` mit Axios**
```javascript
async function ladeDaten() {
  try {
    const response = await axios.get("https://jsonplaceholder.typicode.com/posts");
    console.log(response.data);
  } catch (error) {
    console.error("Fehler:", error);
  }
}

ladeDaten();
```
âœ… **Verbessert Lesbarkeit im Vergleich zu `.then()`**  

---

## **5. Mehrere Anfragen gleichzeitig (`axios.all()`)**
```javascript
axios.all([
  axios.get("https://jsonplaceholder.typicode.com/users/1"),
  axios.get("https://jsonplaceholder.typicode.com/posts?userId=1")
])
  .then(axios.spread((benutzer, beitraege) => {
    console.log("Benutzer:", benutzer.data);
    console.log("BeitrÃ¤ge:", beitraege.data);
  }));
```
âœ… **FÃ¼hrt mehrere Anfragen parallel aus**  

---

## **6. Abbrechen von Anfragen mit `CancelToken`**
```javascript
const source = axios.CancelToken.source();

axios.get("https://jsonplaceholder.typicode.com/posts", { cancelToken: source.token })
  .catch((thrown) => {
    if (axios.isCancel(thrown)) {
      console.log("Anfrage abgebrochen:", thrown.message);
    }
  });

// Abbrechen der Anfrage
source.cancel("Anfrage wurde manuell abgebrochen.");
```
âœ… **Perfekt fÃ¼r das Abbrechen von Requests in SPA-Apps**  

---

## **7. Fehlerbehandlung mit `response.status`**
```javascript
axios.get("https://jsonplaceholder.typicode.com/invalid-url")
  .then((response) => console.log(response.data))
  .catch((error) => {
    if (error.response) {
      console.log("Fehlerstatus:", error.response.status); // z. B. 404
    } else {
      console.log("Netzwerkfehler:", error.message);
    }
  });
```
âœ… **Detaillierte Fehlerbehandlung basierend auf HTTP-Statuscodes**  

---

### **Zusammenfassung**
| Methode | Beschreibung |
|---------|-------------|
| **`axios.get(url)`** | FÃ¼hrt eine `GET`-Anfrage aus |
| **`axios.post(url, data)`** | Sendet eine `POST`-Anfrage |
| **`axios.put(url, data)`** | Aktualisiert eine Ressource (`PUT`) |
| **`axios.delete(url)`** | LÃ¶scht eine Ressource |
| **`axios.all([req1, req2])`** | FÃ¼hrt mehrere Anfragen parallel aus |
| **`axios.CancelToken`** | Erlaubt das Abbrechen von Anfragen |

ğŸ”— [Axios-Dokumentation](https://axios-http.com/docs/intro)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**   

83. ### <a name="83"></a> Event Loop, synchrone und asynchrone Operationen

### **Event Loop, synchrone und asynchrone Operationen in JavaScript**  

Der **Event Loop** ist der Mechanismus in JavaScript, der zwischen **synchronem und asynchronem Code** vermittelt und dafÃ¼r sorgt, dass asynchrone Operationen **nicht blockierend** ablaufen.

---

## **1. Synchrone vs. Asynchrone Operationen**
ğŸ“Œ **Synchrone Operationen** werden in der Reihenfolge ausgefÃ¼hrt, in der sie im Code stehen.  

```javascript
console.log("Erste Ausgabe");
console.log("Zweite Ausgabe");
```
**Konsolenausgabe:**  
```
Erste Ausgabe
Zweite Ausgabe
```
âœ… **Einfach, aber kann blockieren**  

ğŸ“Œ **Asynchrone Operationen** laufen im **Hintergrund** und werden erst spÃ¤ter ausgefÃ¼hrt.  

```javascript
console.log("Start");

setTimeout(() => {
  console.log("Asynchrone Ausgabe");
}, 2000);

console.log("Ende");
```
**Konsolenausgabe:**  
```
Start
Ende
Asynchrone Ausgabe (nach 2 Sekunden)
```
âœ… **Verhindert Blockieren des Hauptprogramms**  

---

## **2. Der Event Loop â€“ Wie funktioniert er?**
JavaScript lÃ¤uft **single-threaded**, was bedeutet, dass es **nur eine HauptausfÃ¼hrungsschleife** gibt.  

**Der Ablauf im Event Loop:**
1. **Call Stack (Aufrufstapel)** â€“ Hier werden **synchrone Operationen** direkt ausgefÃ¼hrt.  
2. **Web APIs (z. B. `setTimeout`)** â€“ Hier laufen **asynchrone Funktionen** im Hintergrund.  
3. **Callback Queue (Warteschlange)** â€“ Hier werden **fertige asynchrone Operationen** auf ihren Aufruf gewartet.  
4. **Event Loop** â€“ PrÃ¼ft, ob der Call Stack leer ist, und fÃ¼hrt dann Code aus der Callback Queue aus.  

---

## **3. Beispiel: Event Loop in Aktion**
```javascript
console.log("1");

setTimeout(() => console.log("2"), 0);

Promise.resolve().then(() => console.log("3"));

console.log("4");
```
**Konsolenausgabe:**
```
1
4
3
2
```
ğŸ“Œ **Warum?**
1. **`console.log("1")`** â†’ Wird direkt ausgefÃ¼hrt (Call Stack).  
2. **`setTimeout(..., 0)`** â†’ Kommt in die Web API, wird nach 0 ms in die Callback Queue geschoben.  
3. **`Promise.resolve().then(...)`** â†’ Kommt in die **Microtask Queue** (hÃ¶here PrioritÃ¤t!).  
4. **`console.log("4")`** â†’ Wird direkt ausgefÃ¼hrt.  
5. **Event Loop** prÃ¼ft: **Microtasks (Promise)** werden VOR `setTimeout()`-Callbacks ausgefÃ¼hrt â†’ **`3` kommt vor `2`**.  

---

## **4. Unterschied: Callback Queue vs. Microtask Queue**
- **Callback Queue:** EnthÃ¤lt **`setTimeout`**, **`setInterval`**, **`setImmediate`**-Callbacks.  
- **Microtask Queue:** EnthÃ¤lt **`Promise.then()`**, **`MutationObserver`** (hÃ¶here PrioritÃ¤t).  

**Reihenfolge:**  
1. **Call Stack wird geleert**  
2. **Alle Microtasks (`Promise.then()`) werden ausgefÃ¼hrt**  
3. **Erst dann kommen `setTimeout()` & `setInterval()` aus der Callback Queue**  

---

## **5. Praxis: Reihenfolge verstehen**
```javascript
setTimeout(() => console.log("Timeout"), 0);
Promise.resolve().then(() => console.log("Promise"));
console.log("Sofort");
```
**Konsolenausgabe:**
```
Sofort
Promise
Timeout
```
âœ… **Promiseketten (`.then()`) haben Vorrang vor `setTimeout()`**  

---

## **6. Blockierende Operationen vermeiden**
Wenn eine **langsame Schleife** den Call Stack blockiert, wird der Event Loop **angehalten**.

```javascript
console.log("Start");

for (let i = 0; i < 1e9; i++) {} // âŒ Blockiert die UI!

console.log("Ende");
```
âŒ **Alles bleibt hÃ¤ngen, da die Schleife nicht unterbrochen wird.**  

ğŸ“Œ **Besser: Asynchron mit `setTimeout()` ausfÃ¼hren**
```javascript
console.log("Start");

setTimeout(() => {
  for (let i = 0; i < 1e9; i++) {} // Wird verzÃ¶gert ausgefÃ¼hrt
  console.log("Lange Berechnung fertig");
}, 0);

console.log("Ende");
```
âœ… **Verhindert Blockieren der Hauptschleife**  

---

### **Zusammenfassung**
| Begriff | Beschreibung |
|---------|-------------|
| **Call Stack** | Stapel fÃ¼r synchronen Code |
| **Web APIs** | Verarbeitet asynchrone Operationen (`setTimeout`, `fetch`) |
| **Callback Queue** | Warteschlange fÃ¼r `setTimeout`, `setInterval` |
| **Microtask Queue** | Warteschlange fÃ¼r `Promise.then()`, hat hÃ¶here PrioritÃ¤t |
| **Event Loop** | Steuert die AusfÃ¼hrung von Code zwischen Stack, Queues & Web APIs |

ğŸ”— [MDN-Dokumentation zum Event Loop](https://developer.mozilla.org/de/docs/Web/JavaScript/EventLoop)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)** 

84. ### <a name="84"></a> MÃ¶glichkeiten zum Senden von Serveranfragen

### **MÃ¶glichkeiten zum Senden von Serveranfragen in JavaScript**  

JavaScript bietet mehrere Methoden, um **HTTP-Anfragen** an einen Server zu senden.  
Hier sind die wichtigsten Techniken:

---

## **1. `fetch()` (Moderne LÃ¶sung, Promises)**
```javascript
fetch("https://jsonplaceholder.typicode.com/posts/1")
  .then((response) => response.json()) // Antwort als JSON parsen
  .then((data) => console.log(data))    // Daten ausgeben
  .catch((error) => console.error("Fehler:", error));
```
âœ… **Einfach & nativ in JS verfÃ¼gbar**  
âœ… **UnterstÃ¼tzt `async/await` fÃ¼r bessere Lesbarkeit**  
âŒ **Kein automatischer Timeout oder Fehlerhandling fÃ¼r HTTP-Fehler**  

ğŸ“Œ **POST-Anfrage mit `fetch()`**
```javascript
fetch("https://jsonplaceholder.typicode.com/posts", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ title: "Neuer Beitrag", body: "Text", userId: 1 })
})
  .then((response) => response.json())
  .then((data) => console.log(data));
```

---

## **2. `XMLHttpRequest` (Ã„ltere Methode)**
```javascript
const xhr = new XMLHttpRequest();
xhr.open("GET", "https://jsonplaceholder.typicode.com/posts/1", true);

xhr.onload = function () {
  if (xhr.status === 200) {
    console.log(JSON.parse(xhr.responseText));
  }
};

xhr.onerror = function () {
  console.error("Fehler bei der Anfrage");
};

xhr.send();
```
âœ… **Funktioniert in Ã¤lteren Browsern**  
âŒ **Komplexer als `fetch()` und nicht Promise-basiert**  

---

## **3. `Axios` (Beliebte externe Bibliothek)**
ğŸ“Œ **Installation (fÃ¼r Node.js & Browser mit npm)**
```bash
npm install axios
```
ğŸ“Œ **CDN fÃ¼r den Browser**
```html
<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
```
ğŸ“Œ **GET-Anfrage mit Axios**
```javascript
axios.get("https://jsonplaceholder.typicode.com/posts/1")
  .then((response) => console.log(response.data))
  .catch((error) => console.error("Fehler:", error));
```
ğŸ“Œ **POST-Anfrage mit Axios**
```javascript
axios.post("https://jsonplaceholder.typicode.com/posts", {
  title: "Neuer Post",
  body: "Inhalt",
  userId: 1
})
  .then((response) => console.log(response.data));
```
âœ… **Promise-basiert und einfach zu benutzen**  
âœ… **Automatische Fehlerbehandlung**  
âœ… **UnterstÃ¼tzt `async/await` & Abbruch von Anfragen**  

---

## **4. `WebSockets` (Echtzeit-Kommunikation)**
ğŸ“Œ **Verwendet fÃ¼r Live-Daten wie Chat, Spiele & FinanzmÃ¤rkte**
```javascript
const socket = new WebSocket("wss://example.com/socket");

socket.onopen = () => {
  console.log("Verbindung geÃ¶ffnet");
  socket.send("Hallo, Server!");
};

socket.onmessage = (event) => {
  console.log("Nachricht vom Server:", event.data);
};

socket.onerror = (error) => {
  console.error("WebSocket-Fehler:", error);
};

socket.onclose = () => {
  console.log("Verbindung geschlossen");
};
```
âœ… **Ideal fÃ¼r Echtzeitkommunikation**  
âŒ **Server muss WebSockets unterstÃ¼tzen**  

---

## **5. `EventSource` (Server-Sent Events, SSE)**
ğŸ“Œ **FÃ¼r einseitige Updates (Server â†’ Client), z. B. News-Feeds**
```javascript
const eventSource = new EventSource("https://example.com/stream");

eventSource.onmessage = (event) => {
  console.log("Neue Nachricht:", event.data);
};

eventSource.onerror = () => {
  console.error("Verbindung unterbrochen");
};
```
âœ… **Weniger Overhead als WebSockets**  
âŒ **Nur fÃ¼r Server â†’ Client-Nachrichten**  

---

### **Zusammenfassung**
| Methode | Beschreibung | Vorteile | Nachteile |
|---------|-------------|----------|-----------|
| **`fetch()`** | Moderne API fÃ¼r HTTP-Anfragen | Einfach, `async/await`, Promises | Kein Timeout, Fehlerbehandlung nÃ¶tig |
| **`XMLHttpRequest`** | Ã„ltere Methode fÃ¼r AJAX | Funktioniert Ã¼berall | Komplexer, nicht Promise-basiert |
| **`Axios`** | Externe Bibliothek fÃ¼r HTTP | Einfach, `async/await`, Abbruch mÃ¶glich | Externer Import nÃ¶tig |
| **`WebSockets`** | Zwei-Wege-Kommunikation in Echtzeit | Live-Daten, geringe Latenz | Server-UnterstÃ¼tzung nÃ¶tig |
| **`EventSource`** | Einweg-Kommunikation Server â†’ Client | Einfach fÃ¼r Live-Updates | Kein Client â†’ Server-Kanal |

ğŸ”— [MDN-Dokumentation zu `fetch()`](https://developer.mozilla.org/de/docs/Web/API/Fetch_API)  
ğŸ”— [Axios-Dokumentation](https://axios-http.com/docs/intro)  
ğŸ”— [WebSockets-Dokumentation](https://developer.mozilla.org/de/docs/Web/API/WebSockets_API)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)** 

85. ### <a name="85"></a> Long Polling (Langes Abfragen)

### **Long Polling (Langes Abfragen) in JavaScript**  

**Long Polling** ist eine Technik zur **Echtzeitkommunikation**, bei der der Client eine **lang laufende HTTP-Anfrage** an den Server sendet und auf eine Antwort wartet.  
Sobald neue Daten verfÃ¼gbar sind, antwortet der Server und der Client sendet eine neue Anfrage.  

ğŸ”¹ **Wird verwendet, wenn WebSockets oder Server-Sent Events (SSE) nicht verfÃ¼gbar sind.**  

---

## **1. Funktionsweise von Long Polling**
1. Der **Client** sendet eine `GET`-Anfrage an den **Server**.  
2. Der **Server** hÃ¤lt die Verbindung offen, bis neue Daten verfÃ¼gbar sind.  
3. Sobald neue Daten vorhanden sind, antwortet der **Server** und schlieÃŸt die Verbindung.  
4. Der **Client** sendet sofort eine neue Anfrage (wiederholte Anfragen erzeugen ein "Live-Update").  

---

## **2. Beispiel: Long Polling mit `fetch()`**
```javascript
function longPolling() {
  fetch("https://example.com/api/updates")
    .then(response => response.json())
    .then(data => {
      console.log("Neue Daten:", data);
      longPolling(); // Neue Anfrage nach Antwort starten
    })
    .catch(error => {
      console.error("Fehler:", error);
      setTimeout(longPolling, 5000); // Bei Fehler nach 5 Sekunden erneut versuchen
    });
}

longPolling(); // Startet den Long Polling-Prozess
```
âœ… **Server sendet Daten nur, wenn neue Informationen verfÃ¼gbar sind**  
âœ… **Direkt nach einer Antwort startet eine neue Anfrage**  

---

## **3. Beispiel: Long Polling mit `async/await`**
```javascript
async function longPolling() {
  try {
    const response = await fetch("https://example.com/api/updates");
    const data = await response.json();
    console.log("Neue Daten:", data);
  } catch (error) {
    console.error("Fehler:", error);
  } finally {
    longPolling(); // Wiederholen
  }
}

longPolling();
```
âœ… **`async/await` verbessert die Lesbarkeit**  
âœ… **Fehlertolerant durch `try/catch`**  

---

## **4. Beispiel: Long Polling mit `XMLHttpRequest` (Ã¤ltere Methode)**
```javascript
function longPolling() {
  const xhr = new XMLHttpRequest();
  xhr.open("GET", "https://example.com/api/updates", true);

  xhr.onload = function () {
    if (xhr.status === 200) {
      console.log("Neue Daten:", JSON.parse(xhr.responseText));
    }
    longPolling(); // Erneute Anfrage nach Antwort
  };

  xhr.onerror = function () {
    console.error("Fehler bei der Anfrage");
    setTimeout(longPolling, 5000); // Nach 5 Sekunden erneut versuchen
  };

  xhr.send();
}

longPolling();
```
âœ… **Funktioniert auch in Ã¤lteren Browsern**  
âŒ **Komplexer als `fetch()` oder `async/await`**  

---

## **5. Vergleich: Long Polling vs. Alternativen**
| Technik | Beschreibung | Vorteile | Nachteile |
|---------|-------------|----------|-----------|
| **Long Polling** | Wiederholte `GET`-Anfragen fÃ¼r Echtzeit-Updates | Funktioniert Ã¼berall, kein WebSocket-Server nÃ¶tig | Hohe Serverlast |
| **WebSockets** | Permanente Zwei-Wege-Verbindung | Sehr schnell, geringe Serverlast | WebSocket-Server erforderlich |
| **Server-Sent Events (SSE)** | Nur Server â†’ Client-Nachrichten | Einfach zu implementieren | Nur Einweg-Kommunikation |
| **Short Polling** | RegelmÃ¤ÃŸige `GET`-Anfragen in Intervallen | Einfach umzusetzen | VerzÃ¶gerte Updates, hÃ¶here Last |

ğŸ”— [MDN-Dokumentation zu Long Polling](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/Polling)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)** 

86. ### <a name="86"></a> Web Socket

### **WebSockets in JavaScript**  

**WebSockets** ermÃ¶glichen eine **bidirektionale (zweiwege) Echtzeit-Kommunikation** zwischen **Client** (Browser) und **Server** Ã¼ber eine dauerhafte Verbindung.  
Im Gegensatz zu **HTTP**, das fÃ¼r **jeden Request eine neue Verbindung** Ã¶ffnet, bleibt die **WebSocket-Verbindung offen**, wodurch **schnellere und effizientere Kommunikation** mÃ¶glich ist.

---

## **1. WebSocket-Verbindung aufbauen**
```javascript
const socket = new WebSocket("wss://example.com/socket");

// Verbindung erfolgreich geÃ¶ffnet
socket.onopen = () => {
  console.log("WebSocket-Verbindung hergestellt");
  socket.send("Hallo, Server!");
};

// Nachricht vom Server empfangen
socket.onmessage = (event) => {
  console.log("Nachricht vom Server:", event.data);
};

// Fehlerbehandlung
socket.onerror = (error) => {
  console.error("WebSocket-Fehler:", error);
};

// Verbindung geschlossen
socket.onclose = (event) => {
  console.log("WebSocket geschlossen:", event.reason);
};
```
âœ… **Sofortige DatenÃ¼bertragung nach Verbindungsaufbau**  
âœ… **Effizient fÃ¼r Chats, Echtzeitdaten (FinanzmÃ¤rkte, Spiele, IoT, etc.)**  

---

## **2. Nachrichten an den Server senden**
```javascript
socket.send(JSON.stringify({ type: "message", text: "Hallo, Server!" }));
```
âœ… **Daten kÃ¶nnen als JSON-Objekte gesendet werden**  

---

## **3. Verbindung sicher schlieÃŸen**
```javascript
socket.close(1000, "Verbindung beendet");
```
ğŸ“Œ **WebSocket-Schlusscodes (Status-Codes):**
- `1000` â†’ **Normaler Verbindungsabbruch**
- `1001` â†’ **Client oder Server geht offline**
- `1006` â†’ **Verbindung wurde unerwartet getrennt**

---

## **4. WebSocket-Server mit Node.js (Beispiel)**
**ğŸ“Œ Server mit `ws`-Bibliothek erstellen**  
ğŸ“Œ **Installation:**
```bash
npm install ws
```

ğŸ“Œ **Node.js WebSocket-Server:**
```javascript
const WebSocket = require("ws");
const server = new WebSocket.Server({ port: 8080 });

server.on("connection", (ws) => {
  console.log("Neuer Client verbunden");

  ws.on("message", (message) => {
    console.log("Nachricht erhalten:", message);
    ws.send(`Server antwortet: ${message}`);
  });

  ws.on("close", () => {
    console.log("Client hat die Verbindung geschlossen");
  });
});
```
âœ… **Funktioniert mit jedem WebSocket-Client (Browser, Node.js, mobile Apps)**  

---

## **5. Vergleich: WebSockets vs. Alternativen**
| Technologie | Beschreibung | Vorteile | Nachteile |
|-------------|-------------|----------|-----------|
| **WebSockets** | Dauerhafte Echtzeit-Verbindung | Schnell, bidirektional, effizient | WebSocket-Server nÃ¶tig |
| **AJAX (Polling)** | RegelmÃ¤ÃŸige `GET`-Anfragen | Einfach zu implementieren | Hohe Serverlast, VerzÃ¶gerungen |
| **Long Polling** | Server hÃ¤lt Verbindung offen | Bessere Echtzeit-Daten als AJAX | HÃ¶here Serverbelastung als WebSockets |
| **Server-Sent Events (SSE)** | Einweg-Stream Server â†’ Client | Einfach, weniger Overhead | Kein Client â†’ Server-Kanal |

---

### **Zusammenfassung**
- WebSockets bieten eine **bidirektionale** Echtzeitkommunikation.
- **Ideal fÃ¼r Chats, Live-Updates, Multiplayer-Spiele & FinanzmÃ¤rkte**.
- **Alternative: SSE (nur Server â†’ Client) oder Long Polling (weniger effizient)**.

ğŸ”— [MDN-Dokumentation zu WebSockets](https://developer.mozilla.org/de/docs/Web/API/WebSockets_API)  
ğŸ”— [ws-Bibliothek fÃ¼r Node.js](https://github.com/websockets/ws)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)** 

87. ### <a name="87"></a> Was sind Web Workers und wofÃ¼r braucht man sie?

### **Web Workers in JavaScript â€“ Hintergrundprozesse fÃ¼r bessere Performance**  

**Web Workers** sind **separate Threads**, die in JavaScript **unabhÃ¤ngig vom Hauptthread** laufen.  
Sie ermÃ¶glichen die **Parallelverarbeitung**, ohne die Hauptseite zu blockieren.

---

## **1. Warum Web Workers?**  
ğŸ“Œ **JavaScript ist Single-Threaded** â†’ Langsame Operationen (z. B. schwere Berechnungen, API-Anfragen) kÃ¶nnen die **UI blockieren**.  
âœ… **Web Workers lÃ¶sen das Problem**, indem sie Rechenaufgaben in einem separaten Thread ausfÃ¼hren.  

**Beispiel: Ohne Web Workers (Blockierung der UI)**  
```javascript
console.log("Start");

// Blockierende Schleife (UI hÃ¤ngt!)
for (let i = 0; i < 1e9; i++) {}

console.log("Ende");
```
âŒ **Der Browser friert ein, weil JavaScript den Hauptthread blockiert.**  

---

## **2. Web Worker erstellen**
**ğŸ“Œ Web Workers werden in einer separaten Datei (`worker.js`) definiert.**  

ğŸ“Œ **Hauptthread (`main.js`):**
```javascript
const worker = new Worker("worker.js");

worker.onmessage = (event) => {
  console.log("Ergebnis vom Worker:", event.data);
};

worker.postMessage(10); // Sende Daten an den Worker
```
ğŸ“Œ **Worker-Thread (`worker.js`):**
```javascript
onmessage = function (event) {
  let zahl = event.data;
  let ergebnis = zahl * 2; // Beispiel: Berechnung
  postMessage(ergebnis); // Antwort zurÃ¼ck an Hauptthread
};
```
âœ… **Hauptseite bleibt reaktionsfÃ¤hig, wÃ¤hrend der Worker arbeitet.**  

---

## **3. Daten zwischen Hauptthread & Worker senden**
### **3.1 Hauptthread â†’ Worker**
```javascript
worker.postMessage({ zahl: 5, text: "Hallo" });
```
âœ… **Daten als JSON-Objekt senden**  

### **3.2 Worker â†’ Hauptthread**
```javascript
postMessage("Fertig!");
```

---

## **4. Worker beenden**
```javascript
worker.terminate(); // Stoppt den Worker sofort
```
âœ… **Verhindert unnÃ¶tige CPU-Auslastung**  

---

## **5. EinschrÃ¤nkungen von Web Workers**
- âŒ **Kein direkter Zugriff auf DOM (`document`, `window`, `alert()`)**  
- âŒ **MÃ¼ssen in separaten Dateien (`worker.js`) gespeichert werden**  
- âœ… **Kommunikation nur Ã¼ber `postMessage()`**  

---

## **6. Beispiel: Aufwendige Berechnung mit Web Worker**
ğŸ“Œ **Hauptthread (`main.js`):**
```javascript
const worker = new Worker("worker.js");

worker.onmessage = (event) => {
  console.log("Faktorielle Berechnung:", event.data);
};

worker.postMessage(10);
```
ğŸ“Œ **Worker (`worker.js`):**
```javascript
onmessage = function (event) {
  let n = event.data;
  let ergebnis = 1;
  for (let i = 2; i <= n; i++) ergebnis *= i;
  postMessage(ergebnis);
};
```
âœ… **Hauptthread bleibt ungestÃ¶rt, wÃ¤hrend der Worker rechnet.**  

---

## **7. `SharedWorker` (Ein Worker fÃ¼r mehrere Tabs)**
ğŸ“Œ **Standard-Workers kÃ¶nnen nur vom Ersteller genutzt werden. `SharedWorker` kann von mehreren Tabs einer Seite geteilt werden.**  

ğŸ“Œ **Shared Worker (sharedWorker.js):**
```javascript
onconnect = function (event) {
  const port = event.ports[0];

  port.onmessage = function (event) {
    port.postMessage("Empfangen: " + event.data);
  };
};
```
ğŸ“Œ **Hauptseite (`main.js`):**
```javascript
const sharedWorker = new SharedWorker("sharedWorker.js");

sharedWorker.port.onmessage = function (event) {
  console.log("Antwort vom Worker:", event.data);
};

sharedWorker.port.postMessage("Hallo Worker!");
```
âœ… **Mehrere Tabs kÃ¶nnen denselben Worker verwenden.**  

---

### **Zusammenfassung**
| Feature | Beschreibung |
|---------|-------------|
| **Web Worker** | FÃ¼hrt Berechnungen in einem separaten Thread aus |
| **postMessage()** | Kommunikation zwischen Worker & Hauptthread |
| **terminate()** | Beendet den Worker |
| **Kein Zugriff auf DOM** | `document`, `window`, `alert()` sind nicht verfÃ¼gbar |
| **Shared Worker** | Kann von mehreren Tabs genutzt werden |

ğŸ”— [MDN-Dokumentation zu Web Workers](https://developer.mozilla.org/de/docs/Web/API/Web_Workers_API)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)** 

88. ### <a name="88"></a> Microtasks vs. Macrotasks

### **Microtasks vs. Macrotasks in JavaScript**  

In JavaScript gibt es zwei Arten von asynchronen Aufgaben:  
- **Microtasks** (hÃ¶here PrioritÃ¤t, laufen zuerst)  
- **Macrotasks** (laufen nach den Microtasks)  

Diese Aufgaben beeinflussen die **Reihenfolge der AusfÃ¼hrung** im **Event Loop**.

---

## **1. Microtasks (`Promise.then`, `queueMicrotask`, `MutationObserver`)**
ğŸ“Œ **Microtasks haben eine hÃ¶here PrioritÃ¤t und werden direkt nach dem aktuellen Callstack ausgefÃ¼hrt.**  
**Beispiele:**  
âœ… **`Promise.then()`**  
âœ… **`queueMicrotask()`** (direkt auszufÃ¼hrender Microtask)  
âœ… **`MutationObserver`** (Beobachtung von DOM-Ã„nderungen)  

```javascript
console.log("Start");

Promise.resolve().then(() => console.log("Microtask 1"));
queueMicrotask(() => console.log("Microtask 2"));

console.log("End");
```
**Erwartete Ausgabe:**  
```
Start
End
Microtask 1
Microtask 2
```
âœ… **Microtasks laufen sofort nach `console.log("End")`, weil sie vor Macrotasks priorisiert werden.**  

---

## **2. Macrotasks (`setTimeout`, `setImmediate`, `setInterval`, `requestAnimationFrame`)**
ğŸ“Œ **Macrotasks werden nach der aktuellen AusfÃ¼hrung & allen Microtasks ausgefÃ¼hrt.**  
**Beispiele:**  
âœ… **`setTimeout()`**  
âœ… **`setImmediate()`** (Node.js)  
âœ… **`setInterval()`**  
âœ… **`requestAnimationFrame()`** (fÃ¼r Animationen im Browser)  

```javascript
console.log("Start");

setTimeout(() => console.log("Macrotask 1"), 0);
setTimeout(() => console.log("Macrotask 2"), 0);

console.log("End");
```
**Erwartete Ausgabe:**  
```
Start
End
Macrotask 1
Macrotask 2
```
âœ… **Obwohl `setTimeout(..., 0)` sofort ausgelÃ¶st wird, wird es erst nach allen synchronen Aufgaben und Microtasks ausgefÃ¼hrt.**  

---

## **3. Microtasks vs. Macrotasks im Event Loop**
ğŸ“Œ **Microtasks haben immer Vorrang vor Macrotasks!**  

```javascript
console.log("Start");

setTimeout(() => console.log("Macrotask"), 0);

Promise.resolve().then(() => console.log("Microtask"));

console.log("End");
```
**Erwartete Ausgabe:**  
```
Start
End
Microtask
Macrotask
```
âœ… **Der Microtask (`Promise.then`) wird vor der Macrotask (`setTimeout`) ausgefÃ¼hrt!**  

---

## **4. Reihenfolge in einer Kombination von Microtasks & Macrotasks**
```javascript
console.log("Start");

setTimeout(() => console.log("Macrotask 1"), 0);

Promise.resolve().then(() => console.log("Microtask 1"));
Promise.resolve().then(() => console.log("Microtask 2"));

setTimeout(() => console.log("Macrotask 2"), 0);

console.log("End");
```
**Erwartete Ausgabe:**  
```
Start
End
Microtask 1
Microtask 2
Macrotask 1
Macrotask 2
```
âœ… **Microtasks (Promises) laufen vor den Macrotasks (setTimeout).**  

---

## **5. `queueMicrotask()` â€“ Ein sicherer Microtask**
ğŸ“Œ **`queueMicrotask()` ermÃ¶glicht das HinzufÃ¼gen von Microtasks innerhalb einer Funktion.**  

```javascript
console.log("Start");

queueMicrotask(() => console.log("Microtask"));

console.log("End");
```
**Erwartete Ausgabe:**  
```
Start
End
Microtask
```
âœ… **`queueMicrotask()` hat die gleiche PrioritÃ¤t wie `Promise.then()`.**  

---

### **Zusammenfassung**
| Feature | Microtask (`Promise.then`, `queueMicrotask`) | Macrotask (`setTimeout`, `setInterval`) |
|---------|--------------------------------|------------------------------|
| **PrioritÃ¤t** | HÃ¶her (lÃ¤uft vor Macrotasks) | Niedriger (lÃ¤uft nach Microtasks) |
| **Beispiele** | `Promise.then()`, `queueMicrotask()` | `setTimeout()`, `setInterval()` |
| **Wann ausgefÃ¼hrt?** | Direkt nach dem Callstack | Nach allen Microtasks |
| **Typische Verwendung** | **Datenverarbeitung, kleine Updates** | **Timer, UI-Updates, Netzwerkanfragen** |

ğŸ”— [MDN-Dokumentation zum Event Loop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)** 

89. ### <a name="89"></a> 


  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)** 

90. ### <a name="90"></a> 


  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)** 

91. ### <a name="91"></a> Klassen (ES6)

### **Klassen (`class`) in JavaScript (ES6)**  

**Klassen** in JavaScript sind eine **ES6-Syntax** fÃ¼r die objektorientierte Programmierung (OOP). Sie sind eine **vereinfachte Schreibweise** fÃ¼r das Prototypensystem.

---

## **1. Grundlegende Klassendefinition**
```javascript
class Person {
  constructor(name, alter) {
    this.name = name;
    this.alter = alter;
  }

  // Methode
  vorstellen() {
    console.log(`Hallo, ich bin ${this.name} und ${this.alter} Jahre alt.`);
  }
}

// Instanz der Klasse erstellen
const max = new Person("Max", 30);
max.vorstellen();
```
âœ… **`constructor` wird beim Erstellen eines Objekts ausgefÃ¼hrt**  
âœ… **Methoden (`vorstellen()`) sind automatisch im `prototype` gespeichert**  

---

## **2. Klassenvererbung (`extends`, `super`)**
```javascript
class Mitarbeiter extends Person {
  constructor(name, alter, beruf) {
    super(name, alter); // Ruft den `constructor` der Elternklasse auf
    this.beruf = beruf;
  }

  vorstellen() {
    super.vorstellen(); // Ruft die Methode der Elternklasse auf
    console.log(`Ich arbeite als ${this.beruf}.`);
  }
}

const anna = new Mitarbeiter("Anna", 28, "Entwicklerin");
anna.vorstellen();
```
âœ… **`extends` â†’ Erbt von einer anderen Klasse**  
âœ… **`super()` â†’ Ruft den `constructor` der Elternklasse auf**  
âœ… **`super.method()` â†’ Ruft eine Methode der Elternklasse auf**  

---

## **3. Getter & Setter fÃ¼r Eigenschaften**
```javascript
class Auto {
  constructor(marke) {
    this._marke = marke; // Private Konvention (_)
  }

  get marke() {
    return this._marke.toUpperCase();
  }

  set marke(neueMarke) {
    this._marke = neueMarke;
  }
}

const meinAuto = new Auto("BMW");
console.log(meinAuto.marke); // "BMW"
meinAuto.marke = "Audi";
console.log(meinAuto.marke); // "AUDI"
```
âœ… **Getter (`get`) â†’ ErmÃ¶glicht eine abgeleitete Darstellung**  
âœ… **Setter (`set`) â†’ ErmÃ¶glicht Validierung oder Transformation von Daten**  

---

## **4. Statische Methoden & Eigenschaften**
```javascript
class Mathe {
  static addiere(a, b) {
    return a + b;
  }
}

console.log(Mathe.addiere(5, 3)); // 8
```
âœ… **`static` Methoden gehÃ¶ren zur Klasse, nicht zur Instanz**  

---

## **5. Private Eigenschaften & Methoden (`#`)**
ğŸ“Œ **Seit ES2020 kÃ¶nnen echte private Felder mit `#` definiert werden.**
```javascript
class Konto {
  #saldo = 0; // Privates Feld

  einzahlen(betrag) {
    this.#saldo += betrag;
  }

  get saldo() {
    return this.#saldo;
  }
}

const meinKonto = new Konto();
meinKonto.einzahlen(100);
console.log(meinKonto.saldo); // 100
// console.log(meinKonto.#saldo); // âŒ Fehler! Private Eigenschaft
```
âœ… **Private Felder sind wirklich nicht von auÃŸen zugÃ¤nglich!**  
âŒ **Nur in moderneren Browsern verfÃ¼gbar**  

---

## **6. Klassen als `Expressions`**
```javascript
const Auto = class {
  constructor(marke) {
    this.marke = marke;
  }
};

const bmw = new Auto("BMW");
console.log(bmw.marke); // "BMW"
```
âœ… **Funktioniert Ã¤hnlich wie `function expressions` (`const foo = function() {}`)**  

---

## **7. `instanceof` â€“ PrÃ¼fen, ob ein Objekt zu einer Klasse gehÃ¶rt**
```javascript
console.log(anna instanceof Person); // true
console.log(anna instanceof Mitarbeiter); // true
console.log(max instanceof Mitarbeiter); // false
```
âœ… **ÃœberprÃ¼ft die ZugehÃ¶rigkeit eines Objekts zu einer Klasse**  

---

### **Zusammenfassung**
| Feature | Beschreibung |
|---------|-------------|
| **`class`** | Erstellt eine Klasse |
| **`constructor`** | Initialisiert Eigenschaften |
| **`extends`** | Vererbung von einer anderen Klasse |
| **`super()`** | Ruft Konstruktor/Methode der Elternklasse auf |
| **`get` / `set`** | Getter & Setter fÃ¼r Eigenschaften |
| **`static`** | Statische Methoden & Eigenschaften |
| **`#privat`** | Private Eigenschaften (ab ES2020) |

ğŸ”— [MDN-Dokumentation zu Klassen](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Classes)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)** 

92. ### <a name="92"></a> Klassenvererbung, private und geschÃ¼tzte Eigenschaften

### **Klassenvererbung, private und geschÃ¼tzte Eigenschaften in JavaScript**  

In JavaScript ermÃ¶glicht **ES6-Klassenvererbung (`extends`)** das Wiederverwenden von Code durch **Vererbung**.  
Ab **ES2020** sind auch **private Eigenschaften (`#`)** verfÃ¼gbar.

---

## **1. Klassenvererbung (`extends`, `super`)**
Eine Klasse kann Eigenschaften und Methoden von einer anderen Klasse erben.

```javascript
class Person {
  constructor(name, alter) {
    this.name = name;
    this.alter = alter;
  }

  vorstellen() {
    console.log(`Hallo, ich bin ${this.name} und ${this.alter} Jahre alt.`);
  }
}

// Vererbung mit `extends`
class Mitarbeiter extends Person {
  constructor(name, alter, beruf) {
    super(name, alter); // Ruft den Konstruktor der Elternklasse auf
    this.beruf = beruf;
  }

  vorstellen() {
    super.vorstellen(); // Ruft die Methode der Elternklasse auf
    console.log(`Ich arbeite als ${this.beruf}.`);
  }
}

const anna = new Mitarbeiter("Anna", 28, "Entwicklerin");
anna.vorstellen();
```
âœ… **`extends`** â†’ Erbt von einer Elternklasse  
âœ… **`super()`** â†’ Ruft den Konstruktor der Elternklasse auf  
âœ… **`super.methode()`** â†’ Ruft eine Methode der Elternklasse auf  

---

## **2. Private Eigenschaften (`#`) â€“ ES2020**
ğŸ“Œ **Private Eigenschaften sind nur innerhalb der Klasse sichtbar.**  

```javascript
class Konto {
  #saldo = 0; // Private Eigenschaft mit `#`

  einzahlen(betrag) {
    if (betrag > 0) this.#saldo += betrag;
  }

  get saldo() {
    return this.#saldo;
  }
}

const meinKonto = new Konto();
meinKonto.einzahlen(100);
console.log(meinKonto.saldo); // 100
// console.log(meinKonto.#saldo); // âŒ Fehler! Nicht von auÃŸen zugÃ¤nglich
```
âœ… **`#privat` â†’ Kann nicht auÃŸerhalb der Klasse geÃ¤ndert oder gelesen werden**  
âŒ **Nicht in Ã¤lteren Browsern unterstÃ¼tzt**  

---

## **3. GeschÃ¼tzte Eigenschaften (Konvention `_`)**
ğŸ“Œ **JavaScript hat keine echte `protected`-Eigenschaft, aber `_` wird als Konvention genutzt.**  
```javascript
class Auto {
  constructor(marke) {
    this._marke = marke; // "GeschÃ¼tzt" durch Konvention
  }
}

class Sportwagen extends Auto {
  zeigeMarke() {
    console.log(`Marke: ${this._marke}`); // Zugriff in der Unterklasse mÃ¶glich
  }
}

const porsche = new Sportwagen("Porsche");
porsche.zeigeMarke(); // "Marke: Porsche"
console.log(porsche._marke); // âŒ Konvention sagt: Nicht auÃŸerhalb der Klasse nutzen!
```
âœ… **Zugriff in der Unterklasse erlaubt**  
âŒ **Keine echte ZugriffsbeschrÃ¤nkung**  

---

## **4. Statische Methoden & Eigenschaften (`static`)**
ğŸ“Œ **Statische Methoden und Eigenschaften gehÃ¶ren zur Klasse, nicht zur Instanz.**  
```javascript
class Mathe {
  static addiere(a, b) {
    return a + b;
  }
}

console.log(Mathe.addiere(5, 3)); // 8
```
âœ… **Kann direkt Ã¼ber `Klasse.method()` aufgerufen werden**  
âŒ **Nicht von Instanzen zugÃ¤nglich**  

---

## **5. `instanceof` â€“ PrÃ¼fen, ob ein Objekt zu einer Klasse gehÃ¶rt**
```javascript
console.log(anna instanceof Person); // true
console.log(anna instanceof Mitarbeiter); // true
console.log(anna instanceof Array); // false
```
âœ… **ÃœberprÃ¼ft die ZugehÃ¶rigkeit eines Objekts zu einer Klasse**  

---

### **Zusammenfassung**
| Feature | Beschreibung |
|---------|-------------|
| **`extends`** | Vererbung von einer anderen Klasse |
| **`super()`** | Ruft Konstruktor der Elternklasse auf |
| **`#privat`** | Echte private Eigenschaften (ab ES2020) |
| **`_geschÃ¼tzt`** | Konvention fÃ¼r geschÃ¼tzte Eigenschaften |
| **`static`** | Statische Methoden/Eigenschaften |
| **`instanceof`** | PrÃ¼ft, ob ein Objekt zu einer Klasse gehÃ¶rt |

ğŸ”— [MDN-Dokumentation zu Klassen](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Classes)  
ğŸ”— [MDN-Dokumentation zu privaten Eigenschaften](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Classes/Private_class_fields)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

93. ### <a name="93"></a> Kapselung (Encapsulation)

### **Kapselung (Encapsulation) in JavaScript**  

**Kapselung** bedeutet, dass **Daten innerhalb eines Objekts geschÃ¼tzt** werden, sodass sie nicht direkt von auÃŸen geÃ¤ndert werden kÃ¶nnen.  
In JavaScript kann Kapselung mit **private Eigenschaften (`#`), Gettern/Settern und Closures** erreicht werden.

---

## **1. Kapselung mit privaten Eigenschaften (`#`) â€“ ES2020**
ğŸ“Œ **Private Eigenschaften sind nur innerhalb der Klasse sichtbar.**  

```javascript
class Konto {
  #saldo = 0; // Private Eigenschaft

  einzahlen(betrag) {
    if (betrag > 0) this.#saldo += betrag;
  }

  get saldo() {
    return this.#saldo;
  }
}

const meinKonto = new Konto();
meinKonto.einzahlen(100);
console.log(meinKonto.saldo); // âœ… 100
// console.log(meinKonto.#saldo); // âŒ Fehler! Nicht von auÃŸen zugÃ¤nglich
```
âœ… **Echte PrivatsphÃ¤re: `#saldo` ist von auÃŸen nicht erreichbar**  
âŒ **Nicht in Ã¤lteren Browsern verfÃ¼gbar**  

---

## **2. Kapselung mit Getter & Setter**
ğŸ“Œ **Getter & Setter ermÃ¶glichen kontrollierten Zugriff auf Eigenschaften.**  
```javascript
class Auto {
  constructor(marke) {
    this._marke = marke; // GeschÃ¼tzt durch Konvention "_"
  }

  get marke() {
    return this._marke.toUpperCase();
  }

  set marke(neueMarke) {
    if (neueMarke.length > 0) this._marke = neueMarke;
  }
}

const bmw = new Auto("BMW");
console.log(bmw.marke); // âœ… "BMW"
bmw.marke = "Audi";
console.log(bmw.marke); // âœ… "AUDI"
```
âœ… **Getter ermÃ¶glicht formatierte Ausgabe**  
âœ… **Setter verhindert ungÃ¼ltige Werte**  

---

## **3. Kapselung mit Closures (IIFE) â€“ Alternative ohne Klassen**
ğŸ“Œ **PrivatsphÃ¤re kann auch mit Closures erreicht werden.**  
```javascript
const konto = (function () {
  let saldo = 0; // Private Variable

  return {
    einzahlen(betrag) {
      if (betrag > 0) saldo += betrag;
    },
    getSaldo() {
      return saldo;
    }
  };
})();

konto.einzahlen(100);
console.log(konto.getSaldo()); // âœ… 100
// console.log(konto.saldo); // âŒ Fehler! saldo ist nicht zugÃ¤nglich
```
âœ… **Daten sind vollstÃ¤ndig gekapselt**  
âŒ **Kein Zugriff von Unterklassen mÃ¶glich**  

---

## **4. GeschÃ¼tzte Eigenschaften (`_`) â€“ Konvention**
ğŸ“Œ **In JavaScript gibt es kein echtes `protected`, daher wird `_` als Konvention genutzt.**  
```javascript
class Fahrzeug {
  constructor(typ) {
    this._typ = typ; // "GeschÃ¼tzt" durch Konvention
  }
}

class Auto extends Fahrzeug {
  zeigeTyp() {
    console.log(`Fahrzeugtyp: ${this._typ}`); // Zugriff in Unterklasse erlaubt
  }
}

const porsche = new Auto("Sportwagen");
porsche.zeigeTyp(); // âœ… "Fahrzeugtyp: Sportwagen"
console.log(porsche._typ); // âŒ Konvention sagt: Nicht von auÃŸen nutzen!
```
âœ… **Kann in Unterklassen genutzt werden**  
âŒ **Nicht wirklich geschÃ¼tzt â€“ `porsche._typ` ist von auÃŸen zugÃ¤nglich**  

---

### **Zusammenfassung**
| Methode | Beschreibung | Schutzstufe |
|---------|-------------|-------------|
| **`#privat`** | Echte private Eigenschaften (ab ES2020) | ğŸ”’ VollstÃ¤ndig privat |
| **Getter/Setter** | Kontrollierter Zugriff auf Eigenschaften | ğŸŸ¡ Halb-privat |
| **Closures (IIFE)** | Private Variablen ohne Klassen | ğŸ”’ VollstÃ¤ndig privat |
| **`_geschÃ¼tzt`** | Nur Konvention fÃ¼r "geschÃ¼tzte" Felder | âš ï¸ Kein echter Schutz |

ğŸ”— [MDN-Dokumentation zu privaten Eigenschaften](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Classes/Private_class_fields)  
ğŸ”— [MDN-Dokumentation zu Getter & Setter](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Functions/get)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

94. ### <a name="94"></a> Was ist funktionale Programmierung? Grundlagen (First-Class-Funktionen, Higher-Order-Funktionen, Pure Functions, Immutability, Lazy Evaluation usw.)

### **Funktionale Programmierung in JavaScript â€“ Grundlagen**  

**Funktionale Programmierung (FP)** ist ein **paradigmatischer Ansatz**, der Programme aus **reinen Funktionen** ohne verÃ¤nderbare ZustÃ¤nde (`immutability`) und Nebenwirkungen (`side effects`) aufbaut.  

---

## **1. Grundlagen der funktionalen Programmierung**
ğŸ”¹ **First-Class-Funktionen** â€“ Funktionen sind **Werte**, die gespeichert, Ã¼bergeben und zurÃ¼ckgegeben werden kÃ¶nnen.  
ğŸ”¹ **Higher-Order-Funktionen** â€“ Funktionen, die andere Funktionen als Parameter oder RÃ¼ckgabewert haben.  
ğŸ”¹ **Pure Functions** â€“ Funktionen, die nur vom Input abhÃ¤ngen und **keine Nebenwirkungen** haben.  
ğŸ”¹ **Immutability** â€“ Daten werden **nicht verÃ¤ndert**, sondern neue Kopien erstellt.  
ğŸ”¹ **Lazy Evaluation** â€“ Berechnungen werden nur ausgefÃ¼hrt, wenn sie benÃ¶tigt werden.  

---

## **2. First-Class-Funktionen**
ğŸ“Œ **In JavaScript sind Funktionen "first-class citizens" â€“ sie kÃ¶nnen wie Variablen behandelt werden.**  

```javascript
const begruessung = function(name) {
  return `Hallo, ${name}!`;
};

console.log(begruessung("Max")); // âœ… "Hallo, Max!"
```
âœ… **Funktionen kÃ¶nnen in Variablen gespeichert und als Werte genutzt werden.**  

---

## **3. Higher-Order-Funktionen (HOF)**
ğŸ“Œ **Funktionen, die andere Funktionen als Argumente nehmen oder zurÃ¼ckgeben.**  

```javascript
function ausfÃ¼hren(operation, a, b) {
  return operation(a, b);
}

const addiere = (x, y) => x + y;
const multiplizieren = (x, y) => x * y;

console.log(ausfÃ¼hren(addiere, 3, 4)); // âœ… 7
console.log(ausfÃ¼hren(multiplizieren, 3, 4)); // âœ… 12
```
âœ… **Macht den Code flexibler und wiederverwendbar.**  

---

## **4. Pure Functions (Reine Funktionen)**
ğŸ“Œ **Eine Funktion ist "rein", wenn sie:**
- Nur von **ihren Parametern** abhÃ¤ngt.
- **Keine Seiteneffekte** (`side effects`) erzeugt.
- Immer **dieselbe Ausgabe** fÃ¼r denselben Input liefert.

âŒ **Nicht rein (verÃ¤ndert externe Variable)**  
```javascript
let saldo = 100;
function abheben(betrag) {
  saldo -= betrag; // âŒ Nebenwirkung (Mutation)
  return saldo;
}
```
âœ… **Reine Funktion (Keine externe VerÃ¤nderung)**  
```javascript
function neuesSaldo(saldo, betrag) {
  return saldo - betrag;
}
console.log(neuesSaldo(100, 20)); // âœ… 80
console.log(neuesSaldo(100, 20)); // âœ… 80 (Immer gleiche Ausgabe)
```
âœ… **Erleichtert Debugging & macht Code vorhersehbar.**  

---

## **5. Immutability (UnverÃ¤nderlichkeit)**
ğŸ“Œ **In funktionaler Programmierung werden Objekte nicht verÃ¤ndert, sondern neue Kopien erstellt.**  

âŒ **Mutation (verÃ¤ndert das Original-Array)**  
```javascript
const zahlen = [1, 2, 3];
zahlen.push(4); // âŒ Ã„ndert das Original-Array
console.log(zahlen); // [1, 2, 3, 4]
```
âœ… **UnverÃ¤nderlichkeit durch `map()`**  
```javascript
const neueZahlen = [...zahlen, 4]; // âœ… Erstellt neue Kopie
console.log(neueZahlen); // [1, 2, 3, 4]
```
âœ… **Daten bleiben unverÃ¤ndert, sicher & vorhersehbar.**  

---

## **6. Lazy Evaluation (Faule Auswertung)**
ğŸ“Œ **Funktionen werden erst ausgefÃ¼hrt, wenn das Ergebnis wirklich benÃ¶tigt wird.**  

```javascript
function generiereZahlen() {
  console.log("Berechnung lÃ¤uft...");
  return [1, 2, 3, 4, 5];
}

const zahlen = generiereZahlen; // âœ… Funktion gespeichert, aber nicht ausgefÃ¼hrt!
console.log(zahlen()); // "Berechnung lÃ¤uft..." + [1, 2, 3, 4, 5]
```
âœ… **Vermeidet unnÃ¶tige Berechnungen.**  

---

## **7. Funktionale Array-Methoden (`map()`, `filter()`, `reduce()`)**
ğŸ“Œ **JavaScript bietet viele Funktionen, um Daten funktional zu transformieren.**  

### **7.1 `map()` â€“ Jedes Element transformieren**
```javascript
const zahlen = [1, 2, 3];
const verdoppelt = zahlen.map((x) => x * 2);
console.log(verdoppelt); // âœ… [2, 4, 6]
```
âœ… **Erstellt eine neue Kopie der Daten.**  

---

### **7.2 `filter()` â€“ Elemente herausfiltern**
```javascript
const zahlen = [1, 2, 3, 4, 5];
const gerade = zahlen.filter((x) => x % 2 === 0);
console.log(gerade); // âœ… [2, 4]
```
âœ… **BehÃ¤lt nur Elemente, die die Bedingung erfÃ¼llen.**  

---

### **7.3 `reduce()` â€“ Werte zusammenfassen**
```javascript
const zahlen = [1, 2, 3, 4];
const summe = zahlen.reduce((acc, x) => acc + x, 0);
console.log(summe); // âœ… 10
```
âœ… **Funktionale Alternative zu Schleifen.**  

---

### **Zusammenfassung**
| Konzept | Beschreibung |
|---------|-------------|
| **First-Class-Funktionen** | Funktionen kÃ¶nnen als Werte behandelt werden |
| **Higher-Order-Funktionen** | Funktionen, die andere Funktionen als Argumente oder RÃ¼ckgabewerte haben |
| **Pure Functions** | Funktionen ohne Seiteneffekte, die immer denselben Output fÃ¼r denselben Input liefern |
| **Immutability** | Daten werden nicht verÃ¤ndert, sondern neue Kopien erstellt |
| **Lazy Evaluation** | Berechnungen werden nur ausgefÃ¼hrt, wenn sie benÃ¶tigt werden |
| **`map()`, `filter()`, `reduce()`** | Funktionale Methoden zur Transformation von Arrays |

ğŸ”— [MDN-Dokumentation zu funktionaler Programmierung](https://developer.mozilla.org/en-US/docs/Glossary/Functional_programming)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

95. ### <a name="95"></a> RegulÃ¤re AusdrÃ¼cke (RegExp)

### **RegulÃ¤re AusdrÃ¼cke (`RegExp`) in JavaScript**  

RegulÃ¤re AusdrÃ¼cke (**Regular Expressions, RegExp**) sind **Muster**, um **Texte zu durchsuchen, zu validieren oder zu ersetzen**.  

---

## **1. RegulÃ¤ren Ausdruck erstellen**
### **1.1 Mit SchrÃ¤gstrichen (`/regex/`)**
```javascript
const regex = /hallo/;
console.log(regex.test("hallo Welt")); // âœ… true
console.log(regex.test("Hallo Welt")); // âŒ false (GroÃŸ-/Kleinschreibung beachtet)
```
âœ… **Direkte Schreibweise**  

### **1.2 Mit `RegExp`-Konstruktor**
```javascript
const regex = new RegExp("hallo", "i"); // "i" ignoriert GroÃŸ-/Kleinschreibung
console.log(regex.test("Hallo Welt")); // âœ… true
```
âœ… **Dynamische Muster mÃ¶glich (`new RegExp(variable)`)**  

---

## **2. Flags (`/pattern/flags`)**
| Flag | Bedeutung |
|------|-----------|
| **`g`** | Global â€“ Alle Vorkommen suchen |
| **`i`** | Case-insensitive â€“ GroÃŸ-/Kleinschreibung ignorieren |
| **`m`** | Multiline â€“ Mehrzeilenmodus |
| **`s`** | Dotall â€“ `.` erfasst auch ZeilenumbrÃ¼che |
| **`u`** | Unicode-UnterstÃ¼tzung |
| **`y`** | Sticky â€“ Sucht genau ab aktueller Position |

```javascript
const regex = /hallo/gi;
console.log("Hallo hallo hallo".match(regex)); // âœ… ["Hallo", "hallo", "hallo"]
```

---

## **3. Zeichenklassen (`[...]`, `\d`, `\w`, `\s`)**
| Zeichen | Bedeutung | Beispiel |
|---------|-----------|----------|
| **`.`** | Jedes Zeichen auÃŸer Zeilenumbruch | `/h.llo/` â†’ `hallo`, `hxllo` |
| **`\d`** | Ziffer `[0-9]` | `/\d/` â†’ `5`, `9` |
| **`\w`** | Wortzeichen `[a-zA-Z0-9_]` | `/\w/` â†’ `a`, `9`, `_` |
| **`\s`** | Leerzeichen, Tab, Zeilenumbruch | `/\s/` â†’ `" "` |
| **`\b`** | Wortgrenze | `/\btest\b/` findet `test`, aber nicht `testing` |
| **`[xyz]`** | Eines dieser Zeichen | `/[aeiou]/` â†’ findet Vokale |

```javascript
console.log(/\d/.test("Haus 123")); // âœ… true (Ziffer gefunden)
console.log(/\w+/.exec("Hallo Welt!")); // âœ… ["Hallo"]
```

---

## **4. Quantoren (`+`, `*`, `?`, `{n,m}`)**
| Quantor | Bedeutung | Beispiel |
|---------|-----------|----------|
| **`+`** | Mindestens einmal | `/a+/` â†’ `aaa` in `"baa"` |
| **`*`** | Beliebig oft (auch 0-mal) | `/bo*l/` â†’ `bl`, `bol`, `bool` |
| **`?`** | Optional (0 oder 1-mal) | `/colou?r/` â†’ `color`, `colour` |
| **`{n}`** | Genau `n` Wiederholungen | `/\d{4}/` â†’ `2023` |
| **`{n,}`** | Mindestens `n`-mal | `/\d{2,}/` â†’ `12`, `123` |
| **`{n,m}`** | Zwischen `n` und `m`-mal | `/a{2,4}/` â†’ `aa`, `aaa`, `aaaa` |

```javascript
console.log(/a{2,}/.test("baaa")); // âœ… true (mind. 2-mal `a`)
console.log(/bo*l/.test("bl")); // âœ… true (kein `o` nÃ¶tig)
```

---

## **5. Gruppen (`()`, `|`, `?:`)**
| Zeichen | Bedeutung | Beispiel |
|---------|-----------|----------|
| **`(abc)`** | Gruppe | `/H(a|e)llo/` â†’ `Hallo`, `Hello` |
| **`(?:abc)`** | Nicht speichernde Gruppe | `/H(?:e|a)llo/` â†’ Kein Gruppenspeicher |
| **`|`** | ODER (Alternation) | `/rot|blau/` â†’ `rot`, `blau` |

```javascript
console.log(/(Hallo|Hi) Welt/.test("Hi Welt")); // âœ… true
console.log(/(abc){2}/.test("abcabc")); // âœ… true (2-mal `abc`)
```

---

## **6. Methoden mit `RegExp`**
| Methode | Beschreibung |
|---------|-------------|
| **`regex.test(str)`** | Gibt `true` zurÃ¼ck, wenn Ãœbereinstimmung gefunden |
| **`regex.exec(str)`** | Gibt erstes Match als Array zurÃ¼ck |
| **`str.match(regex)`** | Findet alle Ãœbereinstimmungen |
| **`str.replace(regex, ersatz)`** | Ersetzt Ãœbereinstimmungen |
| **`str.search(regex)`** | Gibt Index des ersten Treffers zurÃ¼ck |

```javascript
const text = "Die Zahl 42 ist wichtig!";
console.log(/\d+/.test(text)); // âœ… true
console.log(text.match(/\d+/)); // âœ… ["42"]
console.log(text.replace(/\d+/, "100")); // âœ… "Die Zahl 100 ist wichtig!"
```

---

## **7. Lookaheads & Lookbehinds**
| Lookaround | Beschreibung | Beispiel |
|------------|-------------|----------|
| **`(?=...)`** | Positiver Lookahead | `/\d(?=â‚¬)/` â†’ `5` in `5â‚¬` |
| **`(?!...)`** | Negativer Lookahead | `/\d(?!â‚¬)/` â†’ `5` in `5$` |
| **`(?<=...)`** | Positives Lookbehind | `/(?<=â‚¬)\d/` â†’ `5` in `â‚¬5` |
| **`(?<!...)`** | Negatives Lookbehind | `/(?<!â‚¬)\d/` â†’ `5` in `$5` |

```javascript
console.log(/(?<=â‚¬)\d+/.exec("â‚¬100")); // âœ… ["100"]
console.log(/\d+(?=â‚¬)/.exec("50â‚¬")); // âœ… ["50"]
```

---

### **Zusammenfassung**
| Konzept | Beispiel | Bedeutung |
|---------|---------|-----------|
| **Zeichenklassen** | `/\d/`, `/\w/` | `\d` = Zahl, `\w` = Wortzeichen |
| **Quantoren** | `/a+/`, `/b{2,4}/` | `+` mind. 1-mal, `{2,4}` 2-4-mal |
| **Gruppen** | `/(abc|def)/` | Sucht `abc` oder `def` |
| **Lookaheads** | `\d+(?=â‚¬)` | Zahl vor `â‚¬` |
| **Lookbehinds** | `(?<=â‚¬)\d+` | Zahl nach `â‚¬` |
| **Testen** | `/regex/.test("text")` | Gibt `true` oder `false` zurÃ¼ck |

ğŸ”— [MDN-Dokumentation zu RegExp](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/RegExp)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

96. ### <a name="96"></a> JSON

### **JSON in JavaScript**  

**JSON (JavaScript Object Notation)** ist ein **leichtgewichtiges Datenformat**, das fÃ¼r **DatenÃ¼bertragung und Speicherung** genutzt wird.  
Es basiert auf **SchlÃ¼ssel-Wert-Paaren** und ist in vielen Programmiersprachen verwendbar.

---

## **1. JSON-Struktur**
ğŸ“Œ **JSON ist Ã¤hnlich zu JavaScript-Objekten, aber mit einigen Unterschieden:**
- **SchlÃ¼ssel mÃ¼ssen Strings sein** (`"key": "value"`)
- **Werte kÃ¶nnen sein:** `String`, `Number`, `Boolean`, `Array`, `Object`, `null`
- **Kein `undefined` oder Funktionen erlaubt**

```json
{
  "name": "Max",
  "alter": 30,
  "verheiratet": false,
  "kinder": ["Anna", "Tom"],
  "adresse": { "stadt": "Berlin", "plz": "10115" }
}
```

âœ… **JSON ist universell lesbar und speicherbar**  
âŒ **Kommentare sind nicht erlaubt**  

---

## **2. JSON zu JavaScript-Objekt (`JSON.parse()`)**
ğŸ“Œ **Daten aus JSON in ein JavaScript-Objekt umwandeln.**  

```javascript
const jsonString = '{"name": "Max", "alter": 30}';
const person = JSON.parse(jsonString);
console.log(person.name); // âœ… "Max"
```
âœ… **Wandelt JSON-Text in ein echtes JavaScript-Objekt um**  

---

## **3. JavaScript-Objekt zu JSON (`JSON.stringify()`)**
ğŸ“Œ **Ein JavaScript-Objekt in eine JSON-Zeichenkette umwandeln.**  

```javascript
const person = { name: "Max", alter: 30 };
const jsonString = JSON.stringify(person);
console.log(jsonString); // âœ… '{"name":"Max","alter":30}'
```
âœ… **NÃ¼tzlich fÃ¼r API-Anfragen oder lokale Speicherung**  

---

## **4. Formatierte JSON-Ausgabe (`JSON.stringify(obj, null, 2)`)**
```javascript
const jsonString = JSON.stringify(person, null, 2);
console.log(jsonString);
```
**Ergebnis (lesbar formatiert):**
```json
{
  "name": "Max",
  "alter": 30
}
```
âœ… **Praktisch fÃ¼r Logging oder Debugging**  

---

## **5. JSON mit `fetch()` nutzen**
ğŸ“Œ **JSON-Daten von einer API abrufen und in ein JavaScript-Objekt umwandeln.**  

```javascript
fetch("https://jsonplaceholder.typicode.com/users/1")
  .then(response => response.json()) // âœ… JSON-Text in Objekt umwandeln
  .then(data => console.log(data.name)) // âœ… "Leanne Graham"
  .catch(error => console.error("Fehler:", error));
```
âœ… **JSON ist das Standardformat fÃ¼r API-Kommunikation**  

---

## **6. JSON-Validierung mit `try...catch`**
ğŸ“Œ **Falls JSON fehlerhaft ist, kann ein `try...catch`-Block Fehler abfangen.**  

```javascript
const jsonString = '{"name": "Max", "alter": }'; // âŒ Fehlerhafter JSON
try {
  const person = JSON.parse(jsonString);
  console.log(person);
} catch (error) {
  console.error("UngÃ¼ltiges JSON:", error.message);
}
```
âœ… **Verhindert AbstÃ¼rze durch fehlerhafte JSON-Daten**  

---

## **7. Unterschied: `JSON.parse()` vs. `eval()`**
```javascript
const jsonString = '{"name": "Max"}';

// Sicher:
const person = JSON.parse(jsonString);

// Unsicher:
const unsicher = eval("(" + jsonString + ")"); // âŒ Kann schÃ¤dlichen Code ausfÃ¼hren!
```
âœ… **`JSON.parse()` ist sicherer als `eval()`**  

---

### **Zusammenfassung**
| Methode | Beschreibung |
|---------|-------------|
| **`JSON.parse(jsonString)`** | Wandelt JSON-String in JavaScript-Objekt |
| **`JSON.stringify(obj)`** | Wandelt JavaScript-Objekt in JSON-String |
| **`JSON.stringify(obj, null, 2)`** | Formatiert JSON fÃ¼r bessere Lesbarkeit |
| **`fetch(url).then(res => res.json())`** | Holt JSON-Daten von einer API |
| **`try...catch` fÃ¼r `JSON.parse()`** | FÃ¤ngt JSON-Fehler ab |

ğŸ”— [MDN-Dokumentation zu JSON](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/JSON)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

97. ### <a name="97"></a> Design-Patterns in JavaScript (Singleton, Factory, Observer, etc.)

### **Design Patterns in JavaScript**  
Design-Patterns sind bewÃ¤hrte **LÃ¶sungsmuster** fÃ¼r wiederkehrende Probleme in der Softwareentwicklung.  
Hier sind einige der **wichtigsten Design-Patterns in JavaScript**:

---

## **1. Singleton (Nur eine Instanz)**
ğŸ“Œ **Stellt sicher, dass eine Klasse nur eine einzige Instanz hat.**  
ğŸ“Œ **Gut fÃ¼r: Datenbankverbindungen, Konfigurationsobjekte, globale Caches**  

```javascript
class Singleton {
  constructor() {
    if (!Singleton.instance) {
      Singleton.instance = this;
    }
    return Singleton.instance;
  }

  getData() {
    return "Ich bin die einzige Instanz!";
  }
}

const obj1 = new Singleton();
const obj2 = new Singleton();

console.log(obj1 === obj2); // âœ… true (beide sind dieselbe Instanz)
```
âœ… **Verhindert mehrere Instanzen**  

---

## **2. Factory (Objekterstellung nach Typ)**
ğŸ“Œ **Erzeugt Objekte, ohne direkt den Konstruktor zu verwenden.**  
ğŸ“Œ **Gut fÃ¼r: Erstellen vieler Ã¤hnlicher Objekte mit unterschiedlichen Konfigurationen**  

```javascript
class Auto {
  constructor(typ) {
    this.typ = typ;
  }

  info() {
    console.log(`Das ist ein ${this.typ}`);
  }
}

class AutoFactory {
  static createAuto(typ) {
    return new Auto(typ);
  }
}

const bmw = AutoFactory.createAuto("BMW");
const audi = AutoFactory.createAuto("Audi");

bmw.info(); // âœ… "Das ist ein BMW"
audi.info(); // âœ… "Das ist ein Audi"
```
âœ… **ErmÃ¶glicht eine flexible Objekterstellung**  

---

## **3. Observer (Event Listener)**
ğŸ“Œ **Ein Objekt (Subscriber) kann Ã„nderungen eines anderen Objekts (Publisher) beobachten.**  
ğŸ“Œ **Gut fÃ¼r: Event-Systeme, Redux, Live-Daten-Updates**  

```javascript
class EventManager {
  constructor() {
    this.subscribers = [];
  }

  subscribe(callback) {
    this.subscribers.push(callback);
  }

  notify(data) {
    this.subscribers.forEach(callback => callback(data));
  }
}

const eventManager = new EventManager();

eventManager.subscribe((message) => console.log("Listener 1:", message));
eventManager.subscribe((message) => console.log("Listener 2:", message));

eventManager.notify("Neues Event!"); 
// âœ… "Listener 1: Neues Event!"
// âœ… "Listener 2: Neues Event!"
```
âœ… **Perfekt fÃ¼r asynchrone Event-Handling-Systeme**  

---

## **4. Module Pattern (PrivatsphÃ¤re fÃ¼r Variablen)**
ğŸ“Œ **SchÃ¼tzt Variablen mit Closures und gibt nur notwendige Methoden frei.**  
ğŸ“Œ **Gut fÃ¼r: Code-Kapselung, Verhindern von globalen Variablen**  

```javascript
const CounterModule = (function () {
  let count = 0;

  return {
    increment: () => ++count,
    decrement: () => --count,
    getCount: () => count,
  };
})();

console.log(CounterModule.increment()); // âœ… 1
console.log(CounterModule.increment()); // âœ… 2
console.log(CounterModule.getCount());  // âœ… 2
```
âœ… **Variablen (`count`) sind nicht von auÃŸen zugÃ¤nglich**  

---

## **5. Prototype (Objektbasierte Vererbung)**
ğŸ“Œ **ErmÃ¶glicht das Erstellen von Objekten basierend auf einem vorhandenen Objekt.**  
ğŸ“Œ **Gut fÃ¼r: Speicheroptimierung, Vererbung ohne Klassen**  

```javascript
const AutoPrototype = {
  info() {
    console.log(`Das ist ein ${this.typ}`);
  }
};

const bmw = Object.create(AutoPrototype);
bmw.typ = "BMW";
bmw.info(); // âœ… "Das ist ein BMW"
```
âœ… **Spart Speicher durch geteilte Methoden in `Prototype`**  

---

## **6. Decorator (FunktionalitÃ¤t erweitern)**
ğŸ“Œ **ErmÃ¶glicht das HinzufÃ¼gen von Verhalten zu Objekten ohne deren Originalcode zu Ã¤ndern.**  
ğŸ“Œ **Gut fÃ¼r: Logging, Performance-Tracking, erweiterbare Klassen**  

```javascript
function logger(func) {
  return function (...args) {
    console.log(`Aufruf mit: ${args}`);
    return func(...args);
  };
}

function add(a, b) {
  return a + b;
}

const loggedAdd = logger(add);

console.log(loggedAdd(5, 3)); // âœ… "Aufruf mit: 5,3" â†’ 8
```
âœ… **Erweitert Funktionen, ohne deren Code zu Ã¤ndern**  

---

### **Zusammenfassung**
| Pattern | Beschreibung | Anwendung |
|---------|-------------|-----------|
| **Singleton** | Stellt sicher, dass es nur eine Instanz gibt | Globale Caches, Datenbankverbindungen |
| **Factory** | Erstellt Objekte flexibel, ohne `new` | Dynamische Objekterstellung |
| **Observer** | Beobachtet Ã„nderungen (Events) | Event-Handling, Redux |
| **Module** | Kapselt Code & verhindert globale Variablen | Sichere API-Module |
| **Prototype** | Nutzt Prototypen fÃ¼r Vererbung | Speicheroptimierung |
| **Decorator** | FÃ¼gt Funktionen zu Objekten hinzu | Logging, Performance-Tracking |

ğŸ”— [MDN: JavaScript Design Patterns](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Design_Patterns)  
ğŸ”— [Refactoring Guru: Design Patterns](https://refactoring.guru/design-patterns/javascript)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

98. ### <a name="98"></a> 


  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

99. ### <a name="99"></a> 


  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

100. ### <a name="100"></a> 


  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

101. ### <a name="101"></a> Erstellen von Tabs in einem Projekt

### **Erstellen von Tabs in JavaScript**  

Tabs sind eine hÃ¤ufige UI-Komponente, um Inhalte **in verschiedene Bereiche zu unterteilen**.  
Hier zeige ich eine **einfache, moderne** Methode, um Tabs mit **JavaScript, HTML und CSS** zu erstellen.

---

## **1. HTML-Grundstruktur**
```html
<div class="tabs">
  <button class="tab-button active" data-tab="1">Tab 1</button>
  <button class="tab-button" data-tab="2">Tab 2</button>
  <button class="tab-button" data-tab="3">Tab 3</button>
</div>

<div class="tab-content active" id="tab-1">
  <p>Inhalt fÃ¼r Tab 1</p>
</div>
<div class="tab-content" id="tab-2">
  <p>Inhalt fÃ¼r Tab 2</p>
</div>
<div class="tab-content" id="tab-3">
  <p>Inhalt fÃ¼r Tab 3</p>
</div>
```
âœ… **`data-tab="1"` fÃ¼r Zuordnung von Tabs zu Inhalten**  
âœ… **`active`-Klasse fÃ¼r das aktuell sichtbare Tab**  

---

## **2. CSS-Styling**
```css
.tabs {
  display: flex;
  gap: 10px;
}

.tab-button {
  padding: 10px;
  border: none;
  background: lightgray;
  cursor: pointer;
}

.tab-button.active {
  background: blue;
  color: white;
}

.tab-content {
  display: none;
  padding: 10px;
  border: 1px solid #ccc;
  margin-top: 10px;
}

.tab-content.active {
  display: block;
}
```
âœ… **Nur der aktive Tab ist sichtbar (`display: block`)**  
âœ… **Visuelle Hervorhebung des aktiven Buttons (`background: blue`)**  

---

## **3. JavaScript fÃ¼r die Tab-FunktionalitÃ¤t**
```javascript
document.addEventListener("DOMContentLoaded", () => {
  const buttons = document.querySelectorAll(".tab-button");
  const contents = document.querySelectorAll(".tab-content");

  buttons.forEach((button) => {
    button.addEventListener("click", () => {
      // Entferne `active` von allen Buttons und Inhalten
      buttons.forEach((btn) => btn.classList.remove("active"));
      contents.forEach((content) => content.classList.remove("active"));

      // Aktiviere den geklickten Tab
      button.classList.add("active");
      document.getElementById(`tab-${button.dataset.tab}`).classList.add("active");
    });
  });
});
```
âœ… **Event-Listener fÃ¼r alle Buttons**  
âœ… **Wechselt die `active`-Klasse fÃ¼r den geklickten Tab**  
âœ… **Verwendet `dataset.tab`, um Inhalt zuzuordnen (`data-tab="1" â†’ id="tab-1"`)**  

---

### **Fazit**
âœ” **Einfach & modern mit JavaScript, HTML & CSS**  
âœ” **Ohne externe Bibliotheken**  
âœ” **Kann leicht erweitert oder gestylt werden**  

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**  

102. ### <a name="102"></a> Countdown-Timer

### **Countdown-Timer in JavaScript**  

Ein **Countdown-Timer** kann in vielen Anwendungen verwendet werden, z. B. fÃ¼r **Veranstaltungen, Werbeaktionen oder Online-Tests**.  
Hier zeige ich eine **dynamische LÃ¶sung mit JavaScript, HTML & CSS**.

---

## **1. HTML-Grundstruktur**
```html
<div class="timer">
  <h2>Countdown:</h2>
  <div id="countdown">
    <span id="days">00</span> Tage 
    <span id="hours">00</span> Stunden 
    <span id="minutes">00</span> Minuten 
    <span id="seconds">00</span> Sekunden
  </div>
</div>
```
âœ… **Zeigt Tage, Stunden, Minuten & Sekunden an**  

---

## **2. CSS-Styling (optional)**
```css
.timer {
  font-family: Arial, sans-serif;
  text-align: center;
  font-size: 24px;
  background: #222;
  color: white;
  padding: 20px;
  border-radius: 10px;
}

#countdown span {
  font-weight: bold;
  font-size: 30px;
  margin: 0 5px;
}
```
âœ… **Macht den Timer Ã¼bersichtlicher & modern**  

---

## **3. JavaScript fÃ¼r den Countdown-Timer**
```javascript
function startCountdown(endTime) {
  function updateTimer() {
    const now = new Date().getTime();
    const distance = endTime - now;

    if (distance <= 0) {
      clearInterval(timerInterval);
      document.getElementById("countdown").innerHTML = "Zeit abgelaufen!";
      return;
    }

    const days = Math.floor(distance / (1000 * 60 * 60 * 24));
    const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
    const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
    const seconds = Math.floor((distance % (1000 * 60)) / 1000);

    document.getElementById("days").textContent = days.toString().padStart(2, "0");
    document.getElementById("hours").textContent = hours.toString().padStart(2, "0");
    document.getElementById("minutes").textContent = minutes.toString().padStart(2, "0");
    document.getElementById("seconds").textContent = seconds.toString().padStart(2, "0");
  }

  updateTimer();
  const timerInterval = setInterval(updateTimer, 1000);
}

// Countdown auf ein zukÃ¼nftiges Datum setzen (z. B. Neujahr)
const countdownDate = new Date("December 31, 2024 23:59:59").getTime();
startCountdown(countdownDate);
```

âœ… **Berechnet die verbleibende Zeit bis zum `countdownDate`**  
âœ… **Aktualisiert den Timer jede Sekunde (`setInterval`)**  
âœ… **Zeigt `"Zeit abgelaufen!"`, wenn die Zeit vorbei ist**  

---

### **Erweiterungen**
ğŸ”¹ **Live-Anpassung des Enddatums?** â€“ Ãœber ein Eingabefeld setzen  
ğŸ”¹ **Animationen hinzufÃ¼gen?** â€“ `fade-in` Effekt fÃ¼r Sekunden  
ğŸ”¹ **Ton abspielen?** â€“ Sound beim Ablauf des Countdowns  

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)** 

103. ### <a name="103"></a> Modales Fenster

### **Modales Fenster (Modal) in JavaScript**  

Ein **modales Fenster** ist eine UI-Komponente, die sich Ã¼ber den Inhalt legt und Benutzeraktionen erfordert (z. B. BestÃ¤tigungen oder Formulareingaben).  
Hier erstellen wir ein **eigenes modales Fenster mit HTML, CSS & JavaScript**.

---

## **1. HTML-Struktur**
```html
<button id="openModal">Ã–ffne Modal</button>

<div id="modal" class="modal">
  <div class="modal-content">
    <span class="close">&times;</span>
    <h2>Modales Fenster</h2>
    <p>Dies ist ein Beispiel fÃ¼r ein modales Fenster.</p>
  </div>
</div>
```
âœ… **Das Modal ist anfangs unsichtbar und wird durch den Button geÃ¶ffnet**  
âœ… **Das `span.close`-Element schlieÃŸt das Modal**  

---

## **2. CSS-Styling**
```css
/* Modal-Hintergrund */
.modal {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
  justify-content: center;
  align-items: center;
}

/* Modal-Inhalt */
.modal-content {
  background: white;
  padding: 20px;
  border-radius: 10px;
  width: 300px;
  text-align: center;
  position: relative;
}

/* SchlieÃŸen-Button */
.close {
  position: absolute;
  top: 10px;
  right: 15px;
  font-size: 24px;
  cursor: pointer;
}
```
âœ… **Das `modal` ist `display: none`, bis es aktiviert wird**  
âœ… **Der `close`-Button schlieÃŸt das Modal**  
âœ… **Hintergrund wird abgedunkelt (`rgba(0, 0, 0, 0.5)`)**  

---

## **3. JavaScript fÃ¼r Modal-FunktionalitÃ¤t**
```javascript
document.addEventListener("DOMContentLoaded", () => {
  const modal = document.getElementById("modal");
  const openBtn = document.getElementById("openModal");
  const closeBtn = document.querySelector(".close");

  // Ã–ffne das Modal
  openBtn.addEventListener("click", () => {
    modal.style.display = "flex";
  });

  // SchlieÃŸe das Modal
  closeBtn.addEventListener("click", () => {
    modal.style.display = "none";
  });

  // SchlieÃŸen beim Klicken auÃŸerhalb des Modal-Inhalts
  window.addEventListener("click", (event) => {
    if (event.target === modal) {
      modal.style.display = "none";
    }
  });
});
```
âœ… **`click`-Event Ã¶ffnet & schlieÃŸt das Modal**  
âœ… **Modal wird geschlossen, wenn man auf den dunklen Hintergrund klickt**  
âœ… **`window.addEventListener("click", ...)` sorgt fÃ¼r benutzerfreundliches SchlieÃŸen**  

---

### **Erweiterungen**
ğŸ”¹ **Animationen (`opacity`, `transform`) fÃ¼r sanfte ÃœbergÃ¤nge hinzufÃ¼gen**  
ğŸ”¹ **Tastatursteuerung (`ESC`-Taste zum SchlieÃŸen)**  
ğŸ”¹ **Mehrere Modals in einer Seite verwalten**  

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)** 

104. ### <a name="104"></a> Slider

### **Bild-Slider (Karussell) in JavaScript**  

Ein **Slider** (Karussell) zeigt mehrere Bilder oder Inhalte **nacheinander**, oft mit Steuerungselementen (Pfeile, Punkte).  
Hier erstellen wir einen **einfachen und modernen Slider mit HTML, CSS & JavaScript**.

---

## **1. HTML-Struktur**
```html
<div class="slider">
  <div class="slider-container">
    <div class="slide active"><img src="image1.jpg" alt="Bild 1"></div>
    <div class="slide"><img src="image2.jpg" alt="Bild 2"></div>
    <div class="slide"><img src="image3.jpg" alt="Bild 3"></div>
  </div>

  <button id="prev" class="slider-btn">&#10094;</button>
  <button id="next" class="slider-btn">&#10095;</button>
</div>
```
âœ… **Bilder werden in `.slider-container` platziert**  
âœ… **VorwÃ¤rts-/RÃ¼ckwÃ¤rtsbuttons mit `id="prev"` & `id="next"`**  

---

## **2. CSS-Styling**
```css
.slider {
  position: relative;
  max-width: 600px;
  margin: auto;
  overflow: hidden;
}

.slider-container {
  display: flex;
  transition: transform 0.5s ease-in-out;
}

.slide {
  min-width: 100%;
  transition: opacity 0.5s;
}

img {
  width: 100%;
  display: block;
}

.slider-btn {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  background: rgba(0, 0, 0, 0.5);
  color: white;
  border: none;
  padding: 10px;
  cursor: pointer;
}

#prev { left: 10px; }
#next { right: 10px; }
```
âœ… **Slider bewegt sich mit `flexbox` & `transform: translateX()`**  
âœ… **Buttons Ã¼berlagern das Bild fÃ¼r Navigation**  

---

## **3. JavaScript fÃ¼r Slider-FunktionalitÃ¤t**
```javascript
document.addEventListener("DOMContentLoaded", () => {
  const slides = document.querySelectorAll(".slide");
  let index = 0;

  function showSlide(i) {
    slides.forEach((slide, idx) => {
      slide.style.display = idx === i ? "block" : "none";
    });
  }

  document.getElementById("prev").addEventListener("click", () => {
    index = (index - 1 + slides.length) % slides.length;
    showSlide(index);
  });

  document.getElementById("next").addEventListener("click", () => {
    index = (index + 1) % slides.length;
    showSlide(index);
  });

  showSlide(index);
});
```
âœ… **Funktion `showSlide(i)` zeigt nur ein Bild gleichzeitig**  
âœ… **Navigation mit `prev` / `next`-Buttons**  
âœ… **Runde Logik: Letztes Bild â†’ Erstes Bild und umgekehrt**  

---

## **4. Automatischer Slider (`setInterval`)**
ğŸ“Œ **LÃ¤sst den Slider alle 3 Sekunden automatisch wechseln**
```javascript
setInterval(() => {
  index = (index + 1) % slides.length;
  showSlide(index);
}, 3000);
```
âœ… **Verhindert, dass der Nutzer klicken muss**  

---

### **Erweiterungen**
ğŸ”¹ **Mit `transform: translateX()` fÃ¼r flÃ¼ssige Animationen**  
ğŸ”¹ **Pagination (Punkte unter den Bildern zum Wechseln)**  
ğŸ”¹ **Swipe-Funktion fÃ¼r mobile GerÃ¤te (`touchstart`, `touchend`)**  

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)** 

105. ### <a name="105"></a> Rechner

### **Einfacher Rechner in JavaScript**  

Hier erstellen wir einen **einfachen Taschenrechner** mit **HTML, CSS & JavaScript**, der die Grundrechenarten (`+`, `-`, `*`, `/`) unterstÃ¼tzt.

---

## **1. HTML-Struktur**
```html
<div class="calculator">
  <input type="text" id="display" disabled />
  <div class="buttons">
    <button class="btn" data-value="7">7</button>
    <button class="btn" data-value="8">8</button>
    <button class="btn" data-value="9">9</button>
    <button class="btn" data-value="/">Ã·</button>

    <button class="btn" data-value="4">4</button>
    <button class="btn" data-value="5">5</button>
    <button class="btn" data-value="6">6</button>
    <button class="btn" data-value="*">Ã—</button>

    <button class="btn" data-value="1">1</button>
    <button class="btn" data-value="2">2</button>
    <button class="btn" data-value="3">3</button>
    <button class="btn" data-value="-">âˆ’</button>

    <button class="btn" data-value="0">0</button>
    <button class="btn" data-value=".">.</button>
    <button class="btn clear" data-value="C">C</button>
    <button class="btn" data-value="+">+</button>

    <button class="btn equal" data-value="=">=</button>
  </div>
</div>
```
âœ… **`<input>` als Display fÃ¼r die Berechnung**  
âœ… **Buttons fÃ¼r Zahlen & Operatoren mit `data-value`**  

---

## **2. CSS-Styling**
```css
.calculator {
  width: 250px;
  margin: 50px auto;
  padding: 10px;
  background: #222;
  color: white;
  border-radius: 10px;
  text-align: center;
}

#display {
  width: 100%;
  height: 50px;
  font-size: 24px;
  text-align: right;
  padding: 10px;
  border: none;
  background: #333;
  color: white;
}

.buttons {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 5px;
  margin-top: 10px;
}

.btn {
  padding: 15px;
  font-size: 20px;
  border: none;
  background: #444;
  color: white;
  cursor: pointer;
  border-radius: 5px;
}

.btn:hover {
  background: #666;
}

.equal {
  grid-column: span 4;
  background: #f39c12;
}

.clear {
  background: #e74c3c;
}
```
âœ… **Raster-Layout mit `grid-template-columns`**  
âœ… **Buttons mit `hover`-Effekt & Highlight-Farben fÃ¼r `=` & `C`**  

---

## **3. JavaScript fÃ¼r die Taschenrechner-FunktionalitÃ¤t**
```javascript
document.addEventListener("DOMContentLoaded", () => {
  const display = document.getElementById("display");
  const buttons = document.querySelectorAll(".btn");

  buttons.forEach(button => {
    button.addEventListener("click", () => {
      const value = button.dataset.value;

      if (value === "=") {
        try {
          display.value = eval(display.value); // Berechnung
        } catch {
          display.value = "Fehler";
        }
      } else if (value === "C") {
        display.value = ""; // Reset
      } else {
        display.value += value; // Zahlen & Operatoren hinzufÃ¼gen
      }
    });
  });
});
```
âœ… **`eval()` berechnet den Ausdruck (z. B. `3+5*2`)**  
âœ… **Fehlermeldung bei ungÃ¼ltiger Eingabe (`try...catch`)**  
âœ… **`C` lÃ¶scht das Eingabefeld**  

---

## **4. Erweiterungen**
ğŸ”¹ **Ersetze `eval()` mit `Function()` fÃ¼r mehr Sicherheit**  
ğŸ”¹ **UnterstÃ¼tzung fÃ¼r `Backspace` (`â†` lÃ¶schen letzte Zahl)**  
ğŸ”¹ **Dunkler/heller Modus mit CSS-Variablen**  

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)** 

106. ### <a name="106"></a> 


  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)** 

107. ### <a name="107"></a> 


  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)** 

108. ### <a name="108"></a> 


  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)** 

109. ### <a name="109"></a> 


  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)** 

110. ### <a name="110"></a> 


  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)** 

111. ### <a name="111"></a> 


  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**   
