<a name="top"></a>

[–ù–∞ –≥–ª–∞–≤–Ω—É—é](../../README.md)

[–ü–µ—Ä–µ–π—Ç–∏ –∫ –≤–æ–ø—Ä–æ—Å–∞–º](#questions)

| ‚Ññ. | –í–æ–ø—Ä–æ—Å |
| --- | --------- |
|   | ReactJS Grundlagen |
|1 | [Was ist React und welche Probleme l√∂st es?](#1) |
|2 | [Was ist JSX und warum wird es verwendet?](#2) |
|3 | [Was ist Virtual DOM und wie funktioniert es?](#3) |
|4 | [Was ist der Unterschied zwischen React und ReactDOM?](#4) |
|5 | [Warum importieren wir React, auch wenn es scheinbar nicht benutzt wird?](#5) |
|6 | [Was ist ein React Fragment und warum ist es n√ºtzlich?](#6) |
|7 | [Was ist der Unterschied zwischen einem Element, einer Komponente und einer Instanz?](#7) |
|8 | [Was ist das Fiber-Architekturmodell in React?](#8) |
|9 | [Was bedeutet ‚ÄûBatching‚Äú in React?](#9) |
|10 | [Was ist die Rolle des key in React-Listen?](#10) |
|11 | [Wie funktioniert die Wiederverwendung von Komponenten?](#11) |
|12 | [](#12) |
|13 | [](#13) |
|14 | [](#14) |
|15 | [](#15) |
|16 | [](#16) |
|17 | [](#17) |
|18 | [](#18) |
|19 | [](#19) |
|20 | [](#20) |
|   | Komponenten, Props & State |
|21 | [Was sind Props und wozu werden sie verwendet?](#21) |
|22 | [Was ist der Unterschied zwischen Props und State?](#22) |
|23 | [Warum sind Props nur lesbar?](#23) |
|24 | [Wie funktioniert der unidirektionale Datenfluss in React?](#24) |
|25 | [Was ist State in Klassen- und Funktionskomponenten?](#25) |
|26 | [Wie funktioniert setState?](#26) |
|27 | [Was ist der Unterschied zwischen kontrollierten und unkontrollierten Komponenten?](#27) |
|28 | [Was sind Default Props und PropTypes?](#28) |
|29 | [Was ist React.memo und wof√ºr wird es verwendet?](#29) |
|30 | [Was ist PureComponent und wie unterscheidet es sich von Component?](#30) |
|31 | [Wann sollte shouldComponentUpdate verwendet werden?](#31) |
|32 | [Was ist ein ref und wann wird er eingesetzt?](#32) |
|33 | [Was bedeutet ‚ÄûLifting State Up‚Äú?](#33) |
|34 | [](#34) |
|35 | [](#35) |
|36 | [](#36) |
|37 | [](#37) |
|38 | [](#38) |
|39 | [](#39) |
|40 | [](#40) |
|   | Lebenszyklus von Komponenten |
|41 | [Was sind die Phasen des Komponentenlebenszyklus?](#41) |
|42 | [Welche Lifecycle-Methoden gibt es in Klassenkomponenten?](#42) |
|43 | [Welche Lifecycle-Methoden sind veraltet?](#43) |
|44 | [Wie kann man Lifecycle-Methoden mit Hooks ersetzen?](#44) |
|45 | [Was ist componentDidMount und was ist das √Ñquivalent mit Hooks?](#45) |
|46 | [](#46) |
|47 | [](#47) |
|48 | [](#48) |
|49 | [](#49) |
|50 | [](#50) |
|   | Hooks |
|51 | [Was sind Hooks in React?](#51) |
|52 | [Wie funktionieren useState und useEffect?](#52) |
|53 | [Was macht useContext?](#53) |
|54 | [Was ist useRef und wann wird es verwendet?](#54) |
|55 | [Was ist useCallback, useMemo, useReducer?](#55) |
|56 | [Wie schreibt man einen benutzerdefinierten Hook?](#56) |
|57 | [Wie verhindert man eine Endlosschleife in useEffect?](#57) |
|58 | [Wie implementiert man Timeout oder Interval mit Hooks?](#58) |
|59 | [](#59) |
|60 | [](#60) |
|   | React-Patterns und Konzepte |
|61 | [Was ist ein Higher-Order Component (HOC)?](#61) |
|62 | [Was ist das Render-Prop-Pattern?](#62) |
|63 | [Was ist die Context-API und wie funktioniert useContext?](#63) |
|64 | [Was sind Portale in React?](#64) |
|65 | [Was ist bedingtes Rendern (Conditional Rendering)?](#65) |
|66 | [Was ist ein Error Boundary?](#66) |
|67 | [Wie funktioniert Event-Handling in React?](#67) |
|68 | [Was ist ein synthetisches Ereignis (SyntheticEvent)?](#68) |
|69 | [Was ist props.children?](#69) |
|70 | [Was bedeutet ‚Äûcontrolled component‚Äú und ‚Äûuncontrolled component‚Äú bei Formularen?](#70) |
|71 | [](#71) |
|72 | [](#72) |
|73 | [](#73) |
|74 | [](#74) |
|75 | [](#75) |
|   | Daten & API |
|76 | [Wie f√ºhrt man API-Aufrufe mit Fetch oder Axios durch?](#76) |
|77 | [Wie verwaltet man Lade-, Fehler- und Erfolgsstatus?](#77) |
|78 | [Wie funktioniert WebSocket mit React?](#78) |
|79 | [Wie kann man Daten zwischen Komponenten weitergeben?](#79) |
|80 | [Wie macht man einen Datenabruf nur beim ersten Rendern?](#80) |
|81 | [Was ist das Problem bei ‚Äûstale closures‚Äú mit Hooks?](#81) |
|82 | [Wie funktioniert die Fehlerbehandlung mit try/catch in React?](#82) |
|83 | [Wie kann man ein Mock-API oder Mock Server verwenden?](#83) |
|84 | [Wie funktioniert Suspense f√ºr Datenabfragen?](#84) |
|85 | [](#85) |
|86 | [](#86) |
|87 | [](#87) |
|88 | [](#88) |
|89 | [](#89) |
|90 | [](#90) |
|   | Testing |
|91 | [Was ist Unit-, Integration- und E2E-Testing?](#91) |
|92 | [Was ist Snapshot-Testing?](#92) |
|93 | [Welche Tools nutzt man f√ºr React-Tests (Jest, React Testing Library)?](#93) |
|94 | [Wie testet man Komponenten, Props und Events?](#94) |
|95 | [Wie testet man benutzerdefinierte Hooks?](#95) |
|96 | [](#96) |
|97 | [](#97) |
|98 | [](#98) |
|99 | [](#99) |
|100 | [](#100) |
|   | Routing mit React Router |
|101 | [Wie funktioniert Routing in React mit react-router-dom?](#101) |
|102 | [Was sind die Unterschiede zwischen react-router v5 und v6?](#102) |
|103 | [Was sind Route, Link, Navigate, Outlet?](#103) |
|104 | [Wie erstellt man Nested Routes?](#104) |
|105 | [Wie implementiert man Redirects?](#105) |
|106 | [Wie funktioniert programmgesteuerte Navigation (useNavigate)?](#106) |
|107 | [](#107) |
|108 | [](#108) |
|109 | [](#109) |
|110 | [](#110) |
|   | Redux & Redux Toolkit |
|111 | [Was ist Redux und wie funktioniert es?](#111) |
|112 | [Was sind Actions, Reducer und Store?](#112) |
|113 | [Wie funktioniert Redux Toolkit (createSlice, configureStore, createAsyncThunk)?](#113) |
|114 | [Was ist RTK Query?](#114) |
|115 | [Was ist der Unterschied zwischen Redux und der Context-API?](#115) |
|116 | [Was ist connect() in Redux?](#116) |
|117 | [Was sind Middleware in Redux (z. B. redux-thunk, redux-logger)?](#117) |
|118 | [Was ist createSelector und wie funktioniert Reselect?](#118) |
|119 | [Wie verbindet man Redux mit React √ºber Hooks (useSelector, useDispatch)?](#119) |
|120 | [](#120) |
|121 | [](#121) |
|122 | [](#122) |
|123 | [](#123) |
|124 | [](#124) |
|125 | [](#125) |
|126 | [](#126) |
|127 | [](#127) |
|128 | [](#128) |
|129 | [](#129) |
|130 | [](#130) |
|   | Optimierung & Performance |
|131 | [Was ist Code-Splitting?](#131) |
|132 | [Wie funktionieren React.lazy und Suspense?](#132) |
|133 | [Was ist Tree Shaking?](#133) |
|134 | [Was ist Server-Side Rendering (SSR) und Hydration?](#134) |
|135 | [Wie geht man mit Hydration-Fehlern bei SSR um?](#135) |
|136 | [Was bedeutet Virtualisierung (z. B. mit react-window)?](#136) |
|137 | [Wie verhindert man unn√∂tige Re-Renders?](#137) |
|138 | [Was ist React Transition Group?](#138) |
|139 | [Was ist React Strict Mode und welche Vorteile bietet er?](#139) |
|140 | [Was ist Concurrent Mode und welche Probleme l√∂st er?](#140) |
|141 | [](#141) |
|142 | [](#142) |
|143 | [](#143) |
|144 | [](#144) |
|145 | [](#145) |
|   | Sonstiges |
|146 | [Was ist ein Service Worker?](#146) |
|147 | [Was ist react-helmet und wie hilft es beim SEO?](#147) |
|148 | [Wie funktioniert Lazy Loading mit dynamic import()?](#148) |
|149 | [Was ist ein Finite-State Machine (FSM), z. B. mit XState?](#149) |
|150 | [Wie kann man ein Formular mit Formik und Yup erstellen und validieren?](#150) |
|151 | [Wie konfiguriert man ESLint und Prettier in einem React-Projekt?](#151) |
|152 | [Wie funktioniert dynamic import() in React (Syntax, Anwendungsf√§lle)?](#152) |
|153 | [](#153) |
|154 | [](#154) |
|155 | [](#155) |
|156 | [](#156) |
|157 | [](#157) |
|158 | [](#158) |
|159 | [](#159) |
|160 | [](#160) |
|   | React + TypeScript |
|161 | [Was ist der Unterschied zwischen interface und type in TypeScript?](#161) |
|162 | [Wie typisiert man Props und State in einer funktionalen Komponente?](#162) |
|163 | [Wie nutzt man Generics in React mit TypeScript (z. B. f√ºr Listen)?](#163) |
|164 | [Wie typisiert man Events in React mit TypeScript (onChange, onClick, FormEvent, MouseEvent)?](#164) |
|165 | [Wie erstellt man einen benutzerdefinierten Hook mit TypeScript?](#165) |
|166 | [Wie typisiert man useReducer mit TypeScript?](#166) |
|167 | [Wie typisiert man children korrekt in React-Komponenten?](#167) |
|168 | [Was ist React.FC und welche Vor- und Nachteile hat es?](#168) |
|169 | [Wie typisiert man eine Komponente mit optionalen Props?](#169) |
|170 | [Wie arbeitet man mit Drittanbieter-Bibliotheken, die keine Typen enthalten?](#170) |
|171 | [Was ist der Unterschied zwischen ESM und CommonJS?](#171) |
|172 | [](#172) |
|173 | [](#173) |
|174 | [](#174) |
|175 | [](#175) |
|176 | [](#176) |
|177 | [](#177) |
|178 | [](#178) |
|179 | [](#179) |
|180 | [](#180) |
|181 | [](#181) |
|182 | [](#182) |
|183 | [](#183) |
|184 | [](#184) |
|185 | [](#185) |
|186 | [](#186) |
|187 | [](#187) |
|188 | [](#188) |
|189 | [](#189) |
|190 | [](#190) |
|191 | [](#191) |
|192 | [](#192) |
|193 | [](#193) |
|194 | [](#194) |
|195 | [](#195) |
|196 | [](#196) |
|197 | [](#197) |
|198 | [](#198) |
|199 | [](#199) |
|200 | [](#200) |



<a name="questions"></a>

## ReactJS 

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**
  
1. ### <a name="1"></a> Was ist React und welche Probleme l√∂st es?

# Was ist React und welche Probleme l√∂st es?

**React** ist eine JavaScript-Bibliothek zur Erstellung von **Benutzeroberfl√§chen (UIs)**. Sie wurde von **Meta (Facebook)** entwickelt und hilft beim Bau interaktiver, dynamischer Webanwendungen.

---

## üîß Welche Probleme l√∂st React?

1. **Komplexit√§t gro√üer Anwendungen**  
   ‚Üí React zerlegt die UI in **kleine, wiederverwendbare Komponenten**, wodurch der Code modular und wartbar bleibt.

2. **Manuelles DOM-Handling**  
   ‚Üí Mit dem **virtuellen DOM** optimiert React DOM-√Ñnderungen und verbessert die Performance.

3. **Unstrukturierter Code (z.‚ÄØB. bei jQuery)**  
   ‚Üí React f√∂rdert einen **komponentenbasierten Aufbau**, bei dem Logik, Markup und Styling zusammengeh√∂ren.

4. **Schwierige Zustandsverwaltung (State)**  
   ‚Üí React bietet eingebaute Hooks wie `useState` oder `useReducer`, um den Zustand klar und vorhersehbar zu verwalten.

---

## üí° Beispielcode

```jsx
import { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0); // React verwaltet den Zustand intern

  return (
    <button onClick={() => setCount(count + 1)}>
      Du hast {count} Mal geklickt
    </button>
  );
}
```

‚û°Ô∏è **React aktualisiert automatisch das UI**, wenn sich der Zustand √§ndert ‚Äì kein manuelles DOM-Update notwendig.

---

## üìù Zusammenfassung

React ist eine **komponentenbasierte UI-Bibliothek**, die typische Probleme der Webentwicklung l√∂st:

- un√ºbersichtlicher Code  
- ineffiziente DOM-Manipulation  
- schwieriges State-Management  
- mangelnde Wiederverwendbarkeit

---

## üîó Quellen

- [React ‚Äì Offizielle Einf√ºhrung](https://react.dev/learn)
- [React auf MDN Web Docs](https://developer.mozilla.org/de/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_starten)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

2. ### <a name="2"></a> Was ist JSX und warum wird es verwendet?

# Was ist JSX und warum wird es verwendet?

**JSX (JavaScript XML)** ist eine **Erweiterungssyntax f√ºr JavaScript**, die es erm√∂glicht, HTML-√§hnlichen Code innerhalb von JavaScript zu schreiben. JSX wird von **React** verwendet, um die Struktur der Benutzeroberfl√§che deklarativ zu beschreiben.

---

## üîç Warum JSX?

1. **Bessere Lesbarkeit**  
   ‚Üí JSX kombiniert **HTML-Struktur und JavaScript-Logik** in einem einzigen Codeblock ‚Äì ideal f√ºr Komponenten.

2. **Deklarativer Stil**  
   ‚Üí Statt manuelle DOM-Elemente mit `document.createElement` zu erzeugen, beschreibt JSX **was** dargestellt werden soll, nicht **wie**.

3. **Kompakter und effizienter Code**  
   ‚Üí JSX kompiliert zu `React.createElement(...)`-Aufrufen, die das virtuelle DOM erzeugen.

---

## üí° Beispielcode

```jsx
function Welcome(props) {
  return <h1>Hallo, {props.name}!</h1>;
}
```

‚û°Ô∏è Der obige JSX-Code wird von Babel kompiliert zu:

```js
React.createElement('h1', null, 'Hallo, ', props.name);
```

---

## üìå Wichtig

JSX ist **nicht zwingend erforderlich**, aber stark empfohlen, da es:

- die Entwicklung mit React beschleunigt  
- die Struktur klarer macht  
- die Fehleranf√§lligkeit reduziert

---

## üìù Zusammenfassung

JSX ist eine JavaScript-Erweiterung, die HTML-√§hnlichen Code im JavaScript erm√∂glicht.  
Es erleichtert die Entwicklung mit React durch bessere Lesbarkeit, Wartbarkeit und Integration von Logik und Layout.

---

## üîó Quellen

- [JSX in React ‚Äì react.dev](https://react.dev/learn/writing-markup-with-jsx)  
- [JSX auf MDN Web Docs](https://developer.mozilla.org/de/docs/Web/JavaScript/JavaScript_technologies_overview#jsx)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

3. ### <a name="3"></a> Was ist Virtual DOM und wie funktioniert es?

# Was ist Virtual DOM und wie funktioniert es?

**Virtual DOM** ist eine in JavaScript abgebildete, **leichte Kopie des echten DOM**. React nutzt dieses Konzept, um effizient UI-√Ñnderungen zu erkennen und durchzuf√ºhren, ohne den echten DOM direkt zu manipulieren ‚Äì was langsam und ressourcenintensiv w√§re.

---

## üîß Wie funktioniert Virtual DOM?

1. **Rendern in den virtuellen DOM**  
   ‚Üí React rendert Komponenten zuerst **im virtuellen DOM**, nicht direkt im echten DOM.

2. **Vergleich (Diffing)**  
   ‚Üí React vergleicht (diffing) den **alten virtuellen DOM** mit dem **neuen**, um herauszufinden, **welche Teile sich ver√§ndert haben**.

3. **Minimaler Update im echten DOM**  
   ‚Üí Nur die **ver√§nderten Teile** werden effizient und gezielt im echten DOM aktualisiert.

---

## üí° Beispiel: Wie React intern arbeitet

```jsx
const element = <h1>Hello, world!</h1>;
ReactDOM.render(element, document.getElementById('root'));
```

**Ablauf:**

1. JSX wird zu `React.createElement()` ‚Üí virtuelles DOM-Element
2. React baut daraus eine virtuelle Baumstruktur
3. Bei √Ñnderungen:
   - React erstellt einen neuen virtuellen DOM
   - vergleicht ihn mit dem alten
   - findet Unterschiede
   - updated gezielt den echten DOM

---

## üìà Vorteile

- **Performance**: weniger direkte DOM-Zugriffe
- **Klarer Codefluss**: UI-Updates sind vorhersehbar und deklarativ
- **Skalierbarkeit**: geeignet f√ºr gro√üe, dynamische Anwendungen

---

## üìù Zusammenfassung

Der Virtual DOM ist eine **interne, optimierte Datenstruktur** in React, die es erlaubt, **nur notwendige DOM-√Ñnderungen** durchzuf√ºhren. Dadurch wird die Performance deutlich verbessert und die UI bleibt synchron mit dem App-Zustand.

---

## üîó Quellen

- [React: Rendering und Virtual DOM](https://react.dev/learn/rendering-elements)  
- [MDN: DOM vs Virtual DOM (extern)](https://developer.mozilla.org/)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

4. ### <a name="4"></a> Was ist der Unterschied zwischen React und ReactDOM?

# Was ist der Unterschied zwischen React und ReactDOM?

**React** und **ReactDOM** sind zwei getrennte Pakete mit unterschiedlichen Aufgaben in einer React-Anwendung.

---

## üì¶ React

Das Paket `react` enth√§lt:

- Die **Core-Funktionalit√§t** von React
- **Komponentenlogik**, z.‚ÄØB. `useState`, `useEffect`, `useReducer`
- Das Erstellen von **React-Elementen** √ºber `React.createElement()`
- JSX-Verarbeitung (nach dem Transpiling)

### Beispiel:

```jsx
import { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);
  return <button onClick={() => setCount(count + 1)}>Z√§hler: {count}</button>;
}
```

---

## üåê ReactDOM

Das Paket `react-dom` wird verwendet, um **React-Komponenten in das DOM** des Browsers zu rendern.

- Bindeglied zwischen **virtuellem DOM (React)** und **echtem DOM (Browser)**
- Enth√§lt Methoden wie `ReactDOM.createRoot()` oder `ReactDOM.render()` (fr√ºher)

### Beispiel:

```jsx
import ReactDOM from 'react-dom/client';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);
```

---

## üìù Zusammenfassung

| Paket      | Aufgabe                          |
|------------|----------------------------------|
| `react`    | Erstellen von Komponenten, Hooks, virtueller DOM |
| `react-dom`| Rendering ins Browser-DOM        |

---

## üîó Quellen

- [React ‚Äì Einf√ºhrung](https://react.dev/learn)  
- [ReactDOM API ‚Äì react.dev](https://react.dev/reference/react-dom)  
- [MDN Web Docs: Einf√ºhrung in React](https://developer.mozilla.org/de/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_starten)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

5. ### <a name="5"></a> Warum importieren wir React, auch wenn es scheinbar nicht benutzt wird?

# Warum importieren wir React, auch wenn es scheinbar nicht benutzt wird?

Fr√ºher (vor React 17) musste man `React` **immer importieren**, wenn man JSX benutzt hat, **auch wenn man React nicht direkt im Code verwendet** hat.

---

## üß† Warum?

JSX wird vom Compiler (z.‚ÄØB. Babel) in `React.createElement()`-Aufrufe umgewandelt:

```jsx
const element = <h1>Hello</h1>;
```

wird zu:

```js
const element = React.createElement('h1', null, 'Hello');
```

‚û°Ô∏è Deshalb musste `React` **immer verf√ºgbar** sein.

---

## üîÑ Seit React 17+

Dank des neuen JSX-Transform ist der `React`-Import **nicht mehr zwingend n√∂tig**, **wenn du einen modernen Build-Tool (z.‚ÄØB. Vite, CRA, Next.js)** verwendest.

### Beispiel (ab React 17):

```jsx
function App() {
  return <h1>Hello World</h1>;
}

// kein expliziter Import von React n√∂tig, wenn JSX-Transform aktiv
```

---

## üì¶ Voraussetzung

Damit das funktioniert, muss dein Projekt folgende Bedingungen erf√ºllen:

- React 17 oder neuer  
- JSX-Transform ist im Build-Tool (z.‚ÄØB. Babel, Vite, CRA) aktiviert  
- Du benutzt keine `React.createElement()` direkt

---

## üìù Zusammenfassung

Fr√ºher war der Import von `React` bei JSX zwingend, da JSX zu `React.createElement()` kompiliert wurde.  
Seit React 17 ist der Import **nicht mehr notwendig**, wenn moderne Tools und der neue JSX-Transform verwendet werden.

---

## üîó Quellen

- [JSX-Transform Erkl√§rung ‚Äì React](https://react.dev/learn/writing-markup-with-jsx#the-new-jsx-transform)
- [JSX auf MDN](https://developer.mozilla.org/de/docs/Web/JavaScript/JavaScript_technologies_overview#jsx)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

6. ### <a name="6"></a> Was ist ein React Fragment und warum ist es n√ºtzlich?

# Was ist ein React Fragment und warum ist es n√ºtzlich?

Ein **React Fragment** (`<React.Fragment>` oder `<> </>`) ist ein **Wrapper ohne zus√§tzliches HTML-Element im DOM**.  
Er wird verwendet, wenn eine Komponente **mehrere Elemente zur√ºckgeben** muss, ohne unn√∂tiges Markup zu erzeugen.

---

## üîç Warum n√ºtzlich?

- Vermeidet zus√§tzliche DOM-Knoten (z.‚ÄØB. unn√∂tige `<div>`s)
- Macht den DOM sauberer und strukturierter
- Erforderlich, da JSX nur **ein Wurzelelement** pro Komponente erlaubt

---

## üí° Beispiel mit Fragment

```jsx
function UserInfo() {
  return (
    <>
      <h1>Max Mustermann</h1>
      <p>Frontend Developer</p>
    </>
  );
}
```

Das erzeugt im echten DOM **nur `<h1>` und `<p>`**, **kein zus√§tzliches Wrapper-Element**.

---

## üí° Alternativ: `React.Fragment` mit Key (n√ºtzlich in Listen)

```jsx
<>
  {items.map(item => (
    <React.Fragment key={item.id}>
      <dt>{item.name}</dt>
      <dd>{item.description}</dd>
    </React.Fragment>
  ))}
</>
```

‚û°Ô∏è Nur `React.Fragment` (nicht `<>`) unterst√ºtzt `key`-Props.

---

## üìù Zusammenfassung

React Fragments erlauben das Gruppieren mehrerer Elemente **ohne zus√§tzliches DOM-Element**.  
Sie sorgen f√ºr **sauberen Code und schlankes HTML**.

---

## üîó Quellen

- [Fragments ‚Äì React Docs](https://react.dev/reference/react/Fragment)  
- [JSX mit Fragmenten ‚Äì MDN](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#react_fragments)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

7. ### <a name="7"></a> Was ist der Unterschied zwischen einem Element, einer Komponente und einer Instanz?

# Was ist der Unterschied zwischen einem Element, einer Komponente und einer Instanz?

In React gibt es drei zentrale Begriffe, die oft verwechselt werden: **Element**, **Komponente** und **Instanz**.  
Hier ist eine klare Unterscheidung:

---

## 1. üß± React Element

Ein **React-Element** ist ein **einfaches JavaScript-Objekt**, das beschreibt, **was im UI gerendert werden soll**.

Es ist **keine Komponente** selbst, sondern das Ergebnis von JSX oder `React.createElement()`.

### Beispiel:

```jsx
const element = <h1>Hello, world!</h1>;
```

‚û°Ô∏è Das ist ein **React-Element**, kein DOM-Knoten.

---

## 2. ‚öôÔ∏è React Komponente

Eine **Komponente** ist eine **Funktion oder Klasse**, die ein React-Element zur√ºckgibt.

Sie beschreibt **wie ein UI-Teil aussehen und sich verhalten soll**. Komponenten k√∂nnen **wiederverwendet** und **verschachtelt** werden.

### Beispiel:

```jsx
function Welcome(props) {
  return <h1>Hallo, {props.name}</h1>;
}
```

‚û°Ô∏è Dies ist eine **Komponente**, die ein **Element** zur√ºckgibt.

---

## 3. üß¨ Instanz (Komponenteninstanz)

Eine **Instanz** entsteht, wenn React eine Komponente **rendert** und ihren internen Zustand (State, Lifecycle etc.) verwaltet.  
Bei **Funktionalen Komponenten** ist die Instanzierung ‚Äûunsichtbar‚Äú, bei **Klassenkomponenten** existiert ein echtes Objekt.

‚û°Ô∏è Die Instanz ist das **laufende Exemplar** einer Komponente mit Daten, Hooks, Events etc.

---

## üîÅ Vergleich

| Begriff       | Was ist es?                         | Beispiel                                      |
|---------------|--------------------------------------|-----------------------------------------------|
| Element       | Objekt, das UI beschreibt            | `<div>Hello</div>`                            |
| Komponente    | Funktion/Klasse, die ein Element zur√ºckgibt | `function App() { return <div /> }`        |
| Instanz       | Laufzeit-Exemplar einer Komponente   | Ausf√ºhrung mit State, Props etc.              |

---

## üìù Zusammenfassung

- **Element**: Beschreibung eines UI-Teils (z.‚ÄØB. `<h1>Hello</h1>`)
- **Komponente**: Funktion/Klasse, die Elemente zur√ºckgibt
- **Instanz**: Laufendes Objekt der Komponente zur Laufzeit mit State und Verhalten

---

## üîó Quellen

- [React: Komponenten & Rendering ‚Äì react.dev](https://react.dev/learn/your-first-component)  
- [MDN: JSX und React-Komponenten](https://developer.mozilla.org/de/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_starten)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

8. ### <a name="8"></a> Was ist das Fiber-Architekturmodell in React?

# Was ist das Fiber-Architekturmodell in React?

**Fiber** ist die **neue Rendering-Engine von React**, eingef√ºhrt mit React 16.  
Sie ersetzt das alte, **rekursive Rendering-Modell** und erm√∂glicht eine **feinere Steuerung des Renderprozesses**.

---

## üéØ Warum wurde Fiber eingef√ºhrt?

Das alte Modell (Stack Reconciler) hatte folgende Probleme:

- UI konnte bei gro√üen Updates **nicht unterbrochen** werden  
- Keine **Priorisierung** von wichtigen Updates (z.‚ÄØB. Benutzerinteraktionen)
- Kein gutes Fundament f√ºr **Concurrent Mode**, **Suspense** oder **Time Slicing**

---

## üß¨ Was macht Fiber besser?

### ‚úÖ Unterbrechbares Rendering

React kann Rendering-Arbeit **in kleine Schritte aufteilen** und zwischenzeitlich pausieren oder abbrechen.

### ‚úÖ Priorisierung

Fiber erlaubt die **Zuweisung von Priorit√§ten** zu verschiedenen Updates:  
‚Üí z.‚ÄØB. Benutzerinteraktionen werden schneller behandelt als langsame Datenupdates.

### ‚úÖ Besseres Fehler-Handling

Fiber macht es m√∂glich, **Fehlergrenzen (Error Boundaries)** effizient zu verwenden.

---

## üîß Wie funktioniert Fiber technisch?

- React erstellt beim Rendern eine **Fiber-Node** f√ºr jedes Element
- Diese Nodes bilden einen **Fiber-Tree**, √§hnlich wie ein virtuelles DOM
- Der Tree wird **inkrementell** und **asynchron** verarbeitet
- Nach dem Vergleich (Reconciliation) folgt die **Commit-Phase**, wo echte DOM-Updates stattfinden

---

## üí° Beispiel: Priorisierung

```jsx
startTransition(() => {
  // niedrige Priorit√§t ‚Äì z.‚ÄØB. Daten neu laden
  setSearchQuery(input);
});
```

‚û°Ô∏è Dank Fiber kann React Hintergrundarbeit (wie Filterung) **niedrig priorisieren**.

---

## üìù Zusammenfassung

Das **Fiber-Modell** ist Reacts moderne Rendering-Architektur.  
Es bringt:

- unterbrechbares Rendering  
- Priorisierung von Updates  
- bessere Performance bei gro√üen Anwendungen  
- Grundlage f√ºr neue Features wie **Concurrent Mode** und **Suspense**

---

## üîó Quellen

- [React: Einf√ºhrung in Fiber](https://react.dev/learn/rendering-and-committing)  
- [React Fiber Architecture (Deep Dive ‚Äì englisch)](https://github.com/acdlite/react-fiber-architecture)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

9. ### <a name="9"></a> Was bedeutet ‚ÄûBatching‚Äú in React?

# Was bedeutet ‚ÄûBatching‚Äú in React?

**Batching** bezeichnet in React den Prozess, **mehrere State-√Ñnderungen zu einer einzigen Rendering-Phase zusammenzufassen**, um unn√∂tige Re-Renders zu vermeiden und die Performance zu verbessern.

---

## üéØ Warum ist Batching wichtig?

Ohne Batching w√ºrde jede einzelne `setState`- oder `useState`-√Ñnderung **sofort** ein neues Rendern ausl√∂sen ‚Äì selbst wenn sie direkt hintereinander stehen.

### Beispiel **ohne Batching (theoretisch)**

```jsx
setCount(count + 1);
setName('Anna');
```

‚Üí Ohne Batching: 2 Re-Renders  
‚Üí Mit Batching: **nur 1 Re-Render**

---

## üß† Wie funktioniert Batching?

- In **Event-Handlern** (z.‚ÄØB. `onClick`, `onChange`) **batcht React automatisch**
- Seit React 18 funktioniert Batching auch in **`setTimeout`, Promises, async/await**, etc.

### Beispiel:

```jsx
function handleClick() {
  setCount(c => c + 1);
  setName('Anna');
}
```

‚û°Ô∏è React f√ºhrt **nur einen Re-Render** durch, obwohl 2 States ge√§ndert wurden.

---

## üîÅ Batching in asynchronem Code (ab React 18)

```jsx
useEffect(() => {
  fetchData().then(() => {
    setLoading(false);
    setData(result);
  });
}, []);
```

‚Üí Auch hier wird **automatisch gebatcht** (ab React 18), sodass nur ein Re-Render erfolgt.

---

## üõ†Ô∏è Manuelles Batching (z.‚ÄØB. au√üerhalb von React-Kontexten)

Falls n√∂tig, kann man `flushSync()` oder `unstable_batchedUpdates()` verwenden ‚Äì aber in der Regel ist das nicht notwendig.

---

## üìù Zusammenfassung

**Batching** fasst mehrere State-√Ñnderungen in einer Rendering-Phase zusammen.  
Das reduziert die Anzahl der Re-Renders und verbessert die Performance ‚Äì vor allem bei komplexen Komponenten.

---

## üîó Quellen

- [Batching ‚Äì React Docs](https://react.dev/learn/state-a-components-memory#react-batches-state-updates)  
- [React 18 Automatic Batching](https://react.dev/learn/queueing-a-series-of-state-updates#react-batches-state-updates)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

10. ### <a name="10"></a> Was ist die Rolle des key in React-Listen?

# Was ist die Rolle des `key` in React-Listen?

In React ist der `key` ein **einzigartiger Identifikator** f√ºr jedes Element in einer Liste.  
Er hilft React, **zu erkennen, welche Elemente sich ge√§ndert, hinzugef√ºgt oder entfernt** haben.

---

## üéØ Warum ist `key` wichtig?

React verwendet `key`, um die **Effizienz beim Rendering** zu erh√∂hen:

- Vermeidet unn√∂tige Neurenderings
- Beibehaltung des Zustands bei gleichbleibenden Komponenten
- Pr√§zises **Vergleichen alter und neuer Elemente** im virtuellen DOM

---

## ‚ùå Problem ohne `key`

```jsx
{items.map(item => (
  <li>{item.text}</li>  // kein key ‚Üí ineffizient und potenziell buggy
))}
```

‚û°Ô∏è React kann nicht eindeutig zuordnen, welches Element welches ist.

---

## ‚úÖ Richtige Nutzung von `key`

```jsx
{items.map(item => (
  <li key={item.id}>{item.text}</li>
))}
```

‚û°Ô∏è `key={item.id}` sorgt daf√ºr, dass React jedes Element **korrekt identifiziert**.

---

## ‚ö†Ô∏è Warnung: Kein Index als `key`, au√üer in Sonderf√§llen

```jsx
// schlecht bei dynamischen Listen
<li key={index}>{item.text}</li>
```

Vermeide den **Array-Index als key**, weil das zu **falschen Updates** f√ºhren kann, wenn sich die Reihenfolge √§ndert.

---

## üìù Zusammenfassung

Der `key` in React-Listen dient zur **eindeutigen Identifizierung von Listenelementen**.  
Er verbessert die Performance und verhindert Rendering-Probleme.  
‚Üí Verwende **stabile, eindeutige Werte** wie `id`, nicht den Array-Index.

---

## üîó Quellen

- [Rendering-Listen mit keys ‚Äì react.dev](https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key)  
- [React keys auf MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#react_keys)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

11. ### <a name="11"></a> Wie funktioniert die Wiederverwendung von Komponenten?

# Wie funktioniert die Wiederverwendung von Komponenten?

In React bedeutet **Wiederverwendung**, dass dieselbe Komponente **mehrfach an verschiedenen Stellen mit unterschiedlichen Daten (Props)** eingesetzt werden kann.  
Das macht den Code **modular, DRY (Don't Repeat Yourself)** und wartungsfreundlich.

---

## üîÅ Wie funktioniert das?

### 1. **Komponente erstellen (z.‚ÄØB. `Button`)**

```jsx
function Button({ label, onClick }) {
  return <button onClick={onClick}>{label}</button>;
}
```

### 2. **Wiederverwendung mit unterschiedlichen Props**

```jsx
<Button label="Speichern" onClick={saveData} />
<Button label="L√∂schen" onClick={deleteData} />
```

‚û°Ô∏è React verwendet dieselbe **Komponentenlogik**, aber mit unterschiedlichen **Eigenschaften (Props)**.

---

## üì¶ Vorteile der Wiederverwendung

- ‚úÖ Einheitliches Verhalten
- ‚úÖ Leichter wartbar
- ‚úÖ Skalierbarer Code
- ‚úÖ Kombinierbarkeit zu gr√∂√üeren Komponenten

---

## üí° Wiederverwendung auch innerhalb anderer Komponenten

```jsx
function Dialog() {
  return (
    <div>
      <Button label="Abbrechen" onClick={closeDialog} />
      <Button label="Best√§tigen" onClick={confirmAction} />
    </div>
  );
}
```

‚û°Ô∏è Komponenten k√∂nnen **geschachtelt und kombiniert** werden.

---

## üìù Zusammenfassung

Komponenten werden in React wiederverwendet, indem man sie **mit verschiedenen Props mehrfach rendert**.  
Das f√∂rdert sauberen, wartbaren und skalierbaren Code.

---

## üîó Quellen

- [React Komponenten wiederverwenden ‚Äì react.dev](https://react.dev/learn/passing-props-to-a-component)  
- [Komponentenstruktur ‚Äì MDN Web Docs](https://developer.mozilla.org/de/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_components)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

12. ### <a name="12"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

13. ### <a name="13"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

14. ### <a name="14"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

15. ### <a name="15"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

16. ### <a name="16"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

17. ### <a name="17"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

18. ### <a name="18"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

19. ### <a name="19"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

20. ### <a name="20"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

21. ### <a name="21"></a> Was sind Props und wozu werden sie verwendet?

# Was sind Props und wozu werden sie verwendet?

**Props** (kurz f√ºr **"Properties"**) sind **Daten, die von einer Elternkomponente an eine Kindkomponente √ºbergeben werden**.  
Sie machen React-Komponenten **dynamisch und wiederverwendbar**.

---

## üß† Eigenschaften von Props

- Props sind **nur lesbar** (readonly)
- Sie werden **als Objekt** an Komponenten √ºbergeben
- Sie erm√∂glichen das **Anpassen des Verhaltens oder Inhalts** einer Komponente

---

## üí° Beispiel

### Elternkomponente:

```jsx
function App() {
  return <Welcome name="Sergii" />;
}
```

### Kindkomponente:

```jsx
function Welcome(props) {
  return <h1>Hallo, {props.name}!</h1>;
}
```

‚û°Ô∏è `name="Sergii"` ist ein **Prop**, das an `Welcome` √ºbergeben wird.  
Im Code erreichbar √ºber `props.name`.

---

## üéØ Wozu werden Props verwendet?

- Weitergabe von Daten zwischen Komponenten  
- Wiederverwendung einer Komponente mit **unterschiedlichen Inhalten**  
- Kommunikation **von Eltern zu Kind**

---

## üì¶ Props mit Destructuring

```jsx
function Welcome({ name }) {
  return <h1>Hallo, {name}!</h1>;
}
```

‚û°Ô∏è Kurzform f√ºr besseren Lesefluss.

---

## üìù Zusammenfassung

**Props** sind Eingabedaten f√ºr Komponenten.  
Sie erm√∂glichen die **dynamische Anpassung** von Komponenten und f√∂rdern **Wiederverwendbarkeit**.  
Props flie√üen **nur von oben nach unten** (Parent ‚Üí Child).

---

## üîó Quellen

- [Props in React ‚Äì react.dev](https://react.dev/learn/passing-props-to-a-component)  
- [Komponenten und Props ‚Äì MDN Web Docs](https://developer.mozilla.org/de/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_components#eigenschaften_props)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

22. ### <a name="22"></a> Was ist der Unterschied zwischen Props und State?

# Was ist der Unterschied zwischen Props und State?

In React sind **Props** und **State** zwei zentrale Konzepte zur Steuerung von Daten in Komponenten.  
Sie dienen unterschiedlichen Zwecken und haben verschiedene Eigenschaften.

---

## üì¶ Props

- **Daten von au√üen** ‚Üí werden von der **Elternkomponente √ºbergeben**
- **Readonly**: k√∂nnen innerhalb der Komponente **nicht ver√§ndert** werden
- Erlauben die **Wiederverwendung von Komponenten**
- Flie√üen **von oben nach unten** (unidirektional)

### Beispiel:

```jsx
function Welcome({ name }) {
  return <h1>Hallo, {name}!</h1>;
}
```

‚Üí `name` ist ein **Prop**, das z.‚ÄØB. von `<Welcome name="Anna" />` kommt

---

## üîÑ State

- **Interne Daten** einer Komponente  
- K√∂nnen sich **im Lauf der Zeit √§ndern** (z.‚ÄØB. durch Benutzerinteraktion)
- √Ñnderungen am State f√ºhren zu **einem Re-Render**
- Wird mit Hooks wie `useState` verwaltet

### Beispiel:

```jsx
function Counter() {
  const [count, setCount] = useState(0);
  return <button onClick={() => setCount(count + 1)}>Z√§hler: {count}</button>;
}
```

‚Üí `count` ist der **State** der Komponente

---

## üîÅ Vergleich Props vs. State

| Merkmal          | Props                      | State                          |
|------------------|----------------------------|--------------------------------|
| Ursprung         | Elternkomponente           | Innerhalb der Komponente       |
| Ver√§nderbar?     | ‚ùå Nein (readonly)         | ‚úÖ Ja (mit `setState` / `useState`) |
| Zweck            | Konfiguration von au√üen    | Dynamische, sich √§ndernde Daten |
| Kontrolle        | Vom Elternteil gesteuert   | Von der Komponente selbst      |

---

## üìù Zusammenfassung

- **Props**: Eingabedaten von au√üen, unver√§nderlich, durch Eltern gesteuert  
- **State**: Interner Zustand, ver√§nderlich, durch die Komponente selbst verwaltet

Beides zusammen macht Komponenten **dynamisch und wiederverwendbar**.

---

## üîó Quellen

- [Props vs. State ‚Äì react.dev](https://react.dev/learn/state-a-components-memory#comparing-state-and-props)  
- [MDN: Komponenten mit Props und State](https://developer.mozilla.org/de/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_components)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

23. ### <a name="23"></a> Warum sind Props nur lesbar?

# Warum sind Props nur lesbar?

**Props** (Properties) sind in React **nur lesbar**, weil sie die Daten darstellen,  
die **von au√üen** (also von der Elternkomponente) **an eine Kindkomponente √ºbergeben werden**.

---

## üéØ Hauptgr√ºnde f√ºr die Unver√§nderlichkeit von Props

### 1. üîí **Datenfluss kontrollieren (Unidirektionalit√§t)**

React folgt dem Prinzip des **einseitigen Datenflusses**:  
Daten flie√üen **von oben (Parent) nach unten (Child)**.  
Wenn Kind-Komponenten Props ver√§ndern k√∂nnten, w√ºrde der Datenfluss **chaotisch und unvorhersehbar** werden.

---

### 2. üß© **Komponenten bleiben vorhersehbar und wiederverwendbar**

Eine Komponente, die ihre Props **nicht ver√§ndert**, ist:

- einfacher zu testen  
- leichter wiederzuverwenden  
- unabh√§ngig vom Kontext, in dem sie verwendet wird

---

### 3. üîÅ √Ñnderungen sollen in der Elternkomponente passieren

Wenn sich ein Wert √§ndern soll, soll die **Elternkomponente** dies tun und **neue Props √ºbergeben**.

### Beispiel:

```jsx
function Child({ count }) {
  // count ist readonly
  return <p>Z√§hler: {count}</p>;
}
```

‚û°Ô∏è Wenn `count` ver√§ndert werden soll, muss das in der **Elternkomponente** passieren, z.‚ÄØB. mit `useState`.

---

## üîß Was tun, wenn sich Werte √§ndern sollen?

Verwende **State (`useState`)** in der Elternkomponente und gib ggf. **Callback-Funktionen** per Prop mit.

```jsx
function Parent() {
  const [count, setCount] = useState(0);

  return <Child count={count} onIncrement={() => setCount(count + 1)} />;
}
```

---

## üìù Zusammenfassung

**Props sind nur lesbar**, um den **einseitigen Datenfluss** zu erhalten, die **Vorhersehbarkeit** der Komponenten zu sichern und √Ñnderungen **kontrolliert √ºber die Elternkomponente** zu steuern.

---

## üîó Quellen

- [Props in React ‚Äì react.dev](https://react.dev/learn/passing-props-to-a-component)  
- [Datenfluss in React ‚Äì react.dev](https://react.dev/learn/thinking-in-react#step-5-add-inverse-data-flow)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

24. ### <a name="24"></a> Wie funktioniert der unidirektionale Datenfluss in React?

# Wie funktioniert der unidirektionale Datenfluss in React?

In React bedeutet **unidirektionaler Datenfluss**, dass **Daten immer nur in eine Richtung flie√üen**:  
**von der Elternkomponente zur Kindkomponente**.

---

## üîÅ Was hei√üt das konkret?

- Elternkomponenten **geben Daten √ºber Props weiter**
- Kindkomponenten k√∂nnen diese Props **verwenden**, aber **nicht ver√§ndern**
- √Ñnderungen am Zustand (State) **finden immer in der zust√§ndigen Komponente statt**

---

## üì¶ Beispiel

```jsx
function Parent() {
  const [count, setCount] = useState(0);

  return <Child count={count} onIncrement={() => setCount(count + 1)} />;
}

function Child({ count, onIncrement }) {
  return (
    <div>
      <p>Z√§hler: {count}</p>
      <button onClick={onIncrement}>+1</button>
    </div>
  );
}
```

### Erkl√§rung:

- `Parent` h√§lt den **State**
- `Child` bekommt `count` und `onIncrement` als **Props**
- Der Datenfluss geht **von Parent ‚Üí Child**
- √Ñnderungen (Button-Klick) **l√∂sen in der Elternkomponente eine State-√Ñnderung aus**, die **neue Props an das Kind sendet**

---

## üéØ Vorteile des unidirektionalen Datenflusses

- ‚úÖ **Vorhersehbares Verhalten**
- ‚úÖ **Bessere Debuggability**
- ‚úÖ Klare Trennung von Zust√§ndigkeiten
- ‚úÖ Weniger Fehler durch unkontrollierte Daten√§nderungen

---

## üîÅ Daten ‚Äûnach oben‚Äú geben (umgekehrt)

Kindkomponenten k√∂nnen √ºber **Callback-Funktionen als Prop** indirekt Daten nach oben melden:

```jsx
onChange={(newValue) => parentCallback(newValue)}
```

‚û°Ô∏è So bleibt die **Datenkontrolle bei der Elternkomponente**.

---

## üìù Zusammenfassung

Der **unidirektionale Datenfluss** sorgt daf√ºr, dass Daten in React immer von **Eltern zu Kind** flie√üen.  
Das sorgt f√ºr eine **klare Struktur**, bessere Wartbarkeit und **kontrollierbare Zustands√§nderungen**.

---

## üîó Quellen

- [Thinking in React ‚Äì react.dev](https://react.dev/learn/thinking-in-react#step-5-add-inverse-data-flow)  
- [Props und Datenfluss ‚Äì MDN](https://developer.mozilla.org/de/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_components#datenfluss)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

25. ### <a name="25"></a> Was ist State in Klassen- und Funktionskomponenten?

# Was ist State in Klassen- und Funktionskomponenten?

**State** ist ein **interner Speicher** (Zustand) einer React-Komponente, der sich **√ºber die Zeit √§ndern** kann.  
√Ñnderungen am State l√∂sen ein **automatisches Re-Rendern** der Komponente aus.

---

## ‚öôÔ∏è State in Funktionskomponenten (mit Hooks)

Seit React 16.8 wird State in Funktionskomponenten mit dem Hook `useState` verwaltet.

### Beispiel:

```jsx
import { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0); // count = aktueller Wert, setCount = Funktion zum √Ñndern

  return (
    <button onClick={() => setCount(count + 1)}>
      Du hast {count} Mal geklickt
    </button>
  );
}
```

‚û°Ô∏è Jeder `setCount` l√∂st ein **Re-Rendern** der Komponente mit dem neuen Wert aus.

---

## üèóÔ∏è State in Klassenkomponenten (vor Hooks)

Vor Hooks wurde der State mit `this.state` und `this.setState()` in **Klassenkomponenten** verwendet.

### Beispiel:

```jsx
import React, { Component } from 'react';

class Counter extends Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 }; // Initialwert
  }

  render() {
    return (
      <button onClick={() => this.setState({ count: this.state.count + 1 })}>
        Du hast {this.state.count} Mal geklickt
      </button>
    );
  }
}
```

‚û°Ô∏è `this.setState()` aktualisiert den Zustand **asynchron** und triggert ein Re-Render.

---

## üîÅ Vergleich: Funktions- vs. Klassenkomponenten

| Merkmal         | Funktionskomponente      | Klassenkomponente           |
|-----------------|--------------------------|-----------------------------|
| Einf√ºhrung ab   | React 16.8 (mit Hooks)   | Fr√ºhere React-Versionen     |
| State-Verwaltung| `useState()`             | `this.state` + `setState()` |
| Syntax          | Einfacher, moderner      | Komplexer, mehr Boilerplate |

---

## üìù Zusammenfassung

**State** ist der dynamische Datenbereich einer Komponente.  
- In **Funktionskomponenten** nutzt man `useState`  
- In **Klassenkomponenten** verwendet man `this.state` und `this.setState`  
State-√Ñnderungen f√ºhren **automatisch zu UI-Updates**

---

## üîó Quellen

- [State in React ‚Äì react.dev](https://react.dev/learn/state-a-components-memory)  
- [useState Hook ‚Äì react.dev](https://react.dev/reference/react/useState)  
- [MDN: Klassenkomponenten und State](https://developer.mozilla.org/de/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_components#state_in_klassenkomponenten)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

26. ### <a name="26"></a> Wie funktioniert setState?

# Wie funktioniert `setState`?

`setState` ist die Methode in React, mit der der **Zustand (State)** einer Komponente **aktualisiert** wird.  
Sie ist in **Klassenkomponenten** verf√ºgbar und wird in **Funktionskomponenten** durch `useState` ersetzt.

---

## ‚öôÔ∏è `setState` in Klassenkomponenten

### Beispiel:

```jsx
class Counter extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }

  increment = () => {
    this.setState({ count: this.state.count + 1 });
  };

  render() {
    return <button onClick={this.increment}>Z√§hler: {this.state.count}</button>;
  }
}
```

### Was passiert hier?

1. `this.setState(...)` wird aufgerufen
2. React **merged** das neue Objekt mit dem aktuellen `state`
3. Es erfolgt ein **Re-Render** der Komponente mit dem neuen Zustand

---

## ‚ö†Ô∏è Wichtig: `setState` ist **asynchron**

Das bedeutet: Wenn du direkt nach `setState` auf `this.state` zugreifst, ist der neue Wert noch **nicht garantiert verf√ºgbar**.

### Falsch:

```js
this.setState({ count: this.state.count + 1 });
console.log(this.state.count); // Kann noch alt sein!
```

---

## ‚úÖ Korrekt mit Callback-Funktion (abh√§ngig vom vorherigen Wert)

```js
this.setState((prevState) => ({
  count: prevState.count + 1
}));
```

‚û°Ô∏è So stellst du sicher, dass du immer mit dem aktuellen Zustand arbeitest ‚Äì auch bei mehreren State-Updates hintereinander.

---

## üìò In Funktionskomponenten

Verwendet man stattdessen `useState`:

```jsx
const [count, setCount] = useState(0);
setCount(count + 1);
```

---

## üìù Zusammenfassung

- `setState` aktualisiert den Zustand in **Klassenkomponenten**
- Updates sind **asynchron** und k√∂nnen **gebatcht** werden
- Verwende Callback-Form (`prevState`) bei abh√§ngigen Updates
- In **Funktionskomponenten** wird `useState` verwendet

---

## üîó Quellen

- [setState ‚Äì React Docs](https://react.dev/reference/react/Component#setstate)  
- [State-Updates richtig ausf√ºhren ‚Äì react.dev](https://react.dev/learn/queueing-a-series-of-state-updates)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

27. ### <a name="27"></a> Was ist der Unterschied zwischen kontrollierten und unkontrollierten Komponenten?

# Was ist der Unterschied zwischen kontrollierten und unkontrollierten Komponenten?

In React unterscheidet man zwischen **kontrollierten** und **unkontrollierten Komponenten**,  
wenn es um die Verwaltung von Formular-Elementen wie `<input>`, `<textarea>` oder `<select>` geht.

---

## ‚úÖ Kontrollierte Komponenten

Bei **kontrollierten Komponenten** wird der **Wert eines Formularfelds durch den React-State gesteuert**.

### Merkmale:

- Der **aktuelle Wert** kommt aus dem `useState`-State
- √Ñnderungen werden √ºber `onChange` an React gemeldet
- Die Komponente ist **vollst√§ndig unter Reacts Kontrolle**

### Beispiel:

```jsx
function ControlledInput() {
  const [value, setValue] = useState('');

  return (
    <input 
      value={value} 
      onChange={(e) => setValue(e.target.value)} 
    />
  );
}
```

‚û°Ô∏è Der `value` wird durch den State bestimmt. React "besitzt" das Eingabefeld.

---

## ‚ùå Unkontrollierte Komponenten

Bei **unkontrollierten Komponenten** √ºbernimmt **das DOM selbst die Kontrolle √ºber den Wert**.  
React greift bei Bedarf √ºber ein **Ref** darauf zu.

### Merkmale:

- Kein `useState`, kein `onChange`
- Zugriff √ºber `useRef` ‚Üí z.‚ÄØB. beim Abschicken eines Formulars
- Das Feld verwaltet seinen Zustand **eigenst√§ndig**

### Beispiel:

```jsx
function UncontrolledInput() {
  const inputRef = useRef();

  const handleSubmit = () => {
    alert(inputRef.current.value);
  };

  return (
    <>
      <input ref={inputRef} />
      <button onClick={handleSubmit}>Absenden</button>
    </>
  );
}
```

‚û°Ô∏è React greift **nur lesend** auf den DOM zu ‚Äì keine direkte Kontrolle √ºber den Wert.

---

## üîÅ Vergleich

| Merkmal               | Kontrolliert                 | Unkontrolliert              |
|------------------------|------------------------------|------------------------------|
| Wertquelle             | React-State (`useState`)     | DOM                          |
| Kontrolle              | React                        | Browser                      |
| Zugriff auf Wert       | `value` + `onChange`         | `useRef().current.value`     |
| Empfohlen f√ºr          | Validierung, komplexe Logik  | einfache Formulare, schnelles Prototyping |

---

## üìù Zusammenfassung

- **Kontrollierte Komponenten**: React verwaltet den Eingabewert ‚Üí pr√§zise, kontrolliert, ideal f√ºr Validierung
- **Unkontrollierte Komponenten**: DOM verwaltet den Wert ‚Üí einfacher, aber weniger flexibel

---

## üîó Quellen

- [Kontrollierte Komponenten ‚Äì react.dev](https://react.dev/learn/sharing-state-between-components#controlled-and-uncontrolled-components)  
- [Formulare in React ‚Äì MDN](https://developer.mozilla.org/de/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_forms)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

28. ### <a name="28"></a> Was sind Default Props und PropTypes?

# Was sind Default Props und PropTypes?

In React bieten **Default Props** und **PropTypes** zwei M√∂glichkeiten, um die Verwendung von **Props sicherer und robuster** zu machen.

---

## ‚úÖ 1. Default Props

**Default Props** sind **Standardwerte** f√ºr Props, die verwendet werden,  
wenn ein Prop **nicht vom Elternteil √ºbergeben wurde**.

### Beispiel:

```jsx
function Welcome({ name }) {
  return <h1>Hallo, {name}!</h1>;
}

Welcome.defaultProps = {
  name: 'Gast',
};
```

‚û°Ô∏è Wenn `name` nicht √ºbergeben wurde, zeigt die Komponente automatisch `Hallo, Gast!` an.

---

## ‚úÖ 2. PropTypes

**PropTypes** werden verwendet, um die **Datentypen der Props zu validieren**.  
React gibt **eine Warnung in der Konsole**, wenn ein Prop nicht dem erwarteten Typ entspricht.

### Beispiel:

```jsx
import PropTypes from 'prop-types';

function Welcome({ name, age }) {
  return (
    <p>
      Hallo, {name}! Du bist {age} Jahre alt.
    </p>
  );
}

Welcome.propTypes = {
  name: PropTypes.string.isRequired,
  age: PropTypes.number,
};
```

‚û°Ô∏è Warnung in der Konsole, wenn z.‚ÄØB. `name` fehlt oder `age` kein `number` ist.

---

## üì¶ Unterst√ºtzte Typen

| Typ               | Beschreibung                        |
|-------------------|--------------------------------------|
| `PropTypes.string`| Zeichenkette                         |
| `PropTypes.number`| Zahl                                 |
| `PropTypes.bool`  | Boolean                              |
| `PropTypes.func`  | Funktion                             |
| `PropTypes.array` | Array                                |
| `PropTypes.object`| Objekt                               |
| `.isRequired`     | Macht das Prop erforderlich          |

---

## üìù Zusammenfassung

- **Default Props**: Definieren **Standardwerte**, wenn keine Props √ºbergeben werden
- **PropTypes**: Helfen bei der **Typpr√ºfung** von Props zur Laufzeit (f√ºr Debugging und Klarheit)

---

## üîó Quellen

- [React: Default Props ‚Äì react.dev](https://react.dev/learn/passing-props-to-a-component#default-props)  
- [PropTypes ‚Äì React Docs](https://reactjs.org/docs/typechecking-with-proptypes.html)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

29. ### <a name="29"></a> Was ist React.memo und wof√ºr wird es verwendet?

# Was ist `React.memo` und wof√ºr wird es verwendet?

**`React.memo`** ist eine **Higher-Order-Komponente (HOC)**, die eine **Funktionskomponente speichert (memoisiert)**  
und **nur neu rendert**, wenn sich ihre **Props tats√§chlich ge√§ndert haben**.

---

## üéØ Zweck von `React.memo`

- Vermeidet **unn√∂tige Re-Renders**  
- Verbessert die **Performance** gro√üer Anwendungen  
- N√ºtzlich bei **teuren Berechnungen oder komplexem UI**

---

## üß† Wie funktioniert es?

```jsx
const MemoizedComponent = React.memo(MyComponent);
```

React vergleicht bei jedem Render die **alten und neuen Props mit `===`**.  
Nur bei √Ñnderung wird `MyComponent` neu gerendert.

---

## üí° Beispiel

```jsx
const Greeting = React.memo(function Greeting({ name }) {
  console.log('gerendert');
  return <p>Hallo, {name}</p>;
});
```

‚û°Ô∏è Wird `name` nicht ge√§ndert, wird die Komponente **nicht neu gerendert**.

---

## üîß Mit benutzerdefiniertem Vergleich (optional)

```jsx
function areEqual(prevProps, nextProps) {
  return prevProps.name === nextProps.name;
}

const MemoGreeting = React.memo(Greeting, areEqual);
```

‚û°Ô∏è Du kannst einen **eigenen Vergleichsalgorithmus** definieren.

---

## ‚ö†Ô∏è Wann NICHT verwenden?

- Bei **h√§ufig wechselnden Props**
- Bei **sehr einfachen Komponenten**
- Wenn Re-Renders keine merkliche Performance-Auswirkung haben

---

## üìù Zusammenfassung

- `React.memo` verhindert unn√∂tige Re-Renders von **Funktionskomponenten**
- Es vergleicht Props und rendert nur bei √Ñnderungen
- Ideal bei **leistungsintensiven Komponenten** mit stabilen Props

---

## üîó Quellen

- [React.memo ‚Äì React Docs](https://react.dev/reference/react/memo)  
- [Optimizing Performance ‚Äì React](https://react.dev/learn/optimizing-performance#memoizing-components)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

30. ### <a name="30"></a> Was ist PureComponent und wie unterscheidet es sich von Component?

# Was ist `PureComponent` und wie unterscheidet es sich von `Component`?

In React gibt es zwei Basisklassen f√ºr Klassenkomponenten:

- `React.Component`
- `React.PureComponent`

Der Unterschied liegt im **Verhalten beim Rendern**.

---

## ‚úÖ `React.Component`

- Jede √Ñnderung von `state` oder `props` ‚Üí **f√ºhrt immer zu einem Re-Render**
- Kein Vergleich alter und neuer Props/State
- Du kannst `shouldComponentUpdate()` selbst √ºberschreiben, um Rendering zu optimieren

---

## ‚úÖ `React.PureComponent`

- F√ºhrt **automatisch einen flachen Vergleich** (`shallow compare`) von `props` und `state` durch
- **Rendert nur**, wenn sich etwas **tats√§chlich ge√§ndert hat**
- Du musst `shouldComponentUpdate()` **nicht selbst schreiben**

---

## üí° Beispiel

```jsx
class MyComponent extends React.Component {
  render() {
    console.log('MyComponent rendert immer');
    return <div>{this.props.text}</div>;
  }
}

class MyPureComponent extends React.PureComponent {
  render() {
    console.log('MyPureComponent rendert nur bei √Ñnderung');
    return <div>{this.props.text}</div>;
  }
}
```

Wenn `text` sich nicht √§ndert, wird **`MyPureComponent` nicht neu gerendert**,  
aber **`MyComponent` rendert trotzdem**.

---

## ‚ö†Ô∏è Einschr√§nkung

- `PureComponent` macht **nur einen flachen Vergleich**
  - √Ñnderungen in **verschachtelten Objekten/Arrays** werden **nicht erkannt**
- Beispiel:

```js
this.setState({ data: { name: 'Max' } }); // Neuer Objekt-Referenz, aber inhaltlich gleich ‚Üí Re-Render
```

---

## üîÅ Vergleich

| Merkmal              | `Component`            | `PureComponent`                   |
|----------------------|------------------------|------------------------------------|
| Re-Render bei Update | immer                  | nur bei √Ñnderungen (shallow check)|
| Performance          | normal                 | optimiert f√ºr einfache Props/State|
| shouldComponentUpdate| manuell definierbar    | intern automatisch                |

---

## üìù Zusammenfassung

- `Component`: rendert immer bei State-/Props-√Ñnderung
- `PureComponent`: rendert nur bei tats√§chlicher √Ñnderung (flacher Vergleich)
- Ideal bei **statischen Props oder Performance-kritischen Klassenkomponenten**

---

## üîó Quellen

- [React.PureComponent ‚Äì React Docs](https://react.dev/reference/react/PureComponent)  
- [React-Komponenten optimieren ‚Äì react.dev](https://react.dev/learn/optimizing-performance#purecomponents)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

31. ### <a name="31"></a> Wann sollte shouldComponentUpdate verwendet werden?

# Wann sollte `shouldComponentUpdate` verwendet werden?

Die Methode **`shouldComponentUpdate(nextProps, nextState)`** wird in **Klassenkomponenten** verwendet,  
um zu **steuern, ob eine Komponente neu gerendert werden soll**.

---

## üéØ Zweck

- **Performance-Optimierung**: Vermeide unn√∂tige Re-Renders bei unver√§nderten Props oder State
- Besonders n√ºtzlich bei **gro√üen Komponenten** oder **h√§ufigen Updates**

---

## üí° Beispiel

```jsx
class MyComponent extends React.Component {
  shouldComponentUpdate(nextProps) {
    return nextProps.value !== this.props.value;
  }

  render() {
    console.log('gerendert');
    return <div>{this.props.value}</div>;
  }
}
```

‚û°Ô∏è Die Komponente rendert **nur**, wenn sich `value` ge√§ndert hat.

---

## üß† Wann sinnvoll?

| Situation | Verwendung von `shouldComponentUpdate` sinnvoll? |
|-----------|--------------------------------------------------|
| Gro√üe Komponenten mit viel DOM | ‚úÖ Ja                       |
| Props √§ndern sich selten       | ‚úÖ Ja                       |
| Props enthalten komplexe Objekte (z.‚ÄØB. Arrays) | ‚úÖ mit Deep Compare |
| Kleine statische Komponenten   | ‚ùå Nicht n√∂tig              |
| Du verwendest `PureComponent`  | ‚ùå Schon eingebaut          |

---

## ‚ö†Ô∏è Vorsicht bei Objekten und Arrays

```js
shouldComponentUpdate(nextProps) {
  return nextProps.data !== this.props.data;
}
```

‚Üí **Referenzvergleich**: wenn `data` neu erstellt wird, auch mit gleichem Inhalt, erfolgt ein Re-Render.  
‚Üí Bei komplexeren Strukturen: ggf. **tiefer Vergleich (deep equality)** erforderlich.

---

## üìù Zusammenfassung

`shouldComponentUpdate` wird verwendet, um **Rerender manuell zu kontrollieren**,  
wenn **Props oder State sich nicht tats√§chlich ge√§ndert haben**.  
Das spart Rechenzeit und verbessert die **Performance**, insbesondere bei gro√üen Komponenten.

---

## üîó Quellen

- [shouldComponentUpdate ‚Äì React Docs](https://react.dev/reference/react/Component#shouldcomponentupdate)  
- [React Performance ‚Äì react.dev](https://react.dev/learn/optimizing-performance)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

32. ### <a name="32"></a> Was ist ein ref und wann wird er eingesetzt?

# Was ist ein `ref` und wann wird er eingesetzt?

Ein **`ref` (reference)** in React ist ein Objekt, das **direkten Zugriff auf ein DOM-Element oder eine React-Komponente** erm√∂glicht ‚Äì **ohne den √ºblichen Datenfluss √ºber Props oder State**.

---

## üß† Wof√ºr werden Refs verwendet?

- üìå **Direkter Zugriff auf DOM-Elemente**
- üéÆ **Manuelles Fokus-Management** (z.‚ÄØB. `input.focus()`)
- ‚èØÔ∏è **Steuerung von Medien (Video/Audio)**
- üì¶ **Integration von Drittanbieter-Bibliotheken**
- üß™ **Lesen von Werten in unkontrollierten Komponenten**

---

## üí° Beispiel: DOM-Element fokussieren

```jsx
import { useRef, useEffect } from 'react';

function FocusInput() {
  const inputRef = useRef(null);

  useEffect(() => {
    inputRef.current.focus(); // Direktes DOM-Zugreifen
  }, []);

  return <input ref={inputRef} />;
}
```

‚û°Ô∏è `inputRef.current` zeigt auf das `<input>` DOM-Element.

---

## üì¶ `useRef` vs. `createRef`

| Hook/Method        | Verwendung                        |
|--------------------|-----------------------------------|
| `useRef()`         | In **Funktionskomponenten**       |
| `createRef()`      | In **Klassenkomponenten**         |

---

## üß¨ Beispiel: Unkontrolliertes Eingabefeld

```jsx
function UncontrolledForm() {
  const inputRef = useRef();

  const handleSubmit = () => {
    alert(`Eingegeben: ${inputRef.current.value}`);
  };

  return (
    <>
      <input ref={inputRef} />
      <button onClick={handleSubmit}>Absenden</button>
    </>
  );
}
```

‚û°Ô∏è Zugriff auf den Wert **ohne State/Props**.

---

## ‚ö†Ô∏è Wann **nicht** verwenden?

- ‚ùå Kein Ersatz f√ºr `state` bei kontrollierten Komponenten  
- ‚ùå Kein Mittel zur Datenverarbeitung oder Logiksteuerung  
- ‚ùå Nicht f√ºr das Ausl√∂sen von Re-Renders gedacht

---

## üìù Zusammenfassung

Ein `ref` ist eine **Referenz auf ein DOM-Element oder eine Komponente**.  
Er wird eingesetzt, wenn React **nicht der beste Ort zur Verwaltung von Verhalten ist**, z.‚ÄØB. bei Fokus, Scroll, Animationen oder Drittanbieter-APIs.

---

## üîó Quellen

- [Refs und DOM ‚Äì React Docs](https://react.dev/learn/referencing-values-with-refs)  
- [useRef Hook ‚Äì react.dev](https://react.dev/reference/react/useRef)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

33. ### <a name="33"></a> Was bedeutet ‚ÄûLifting State Up‚Äú?

# Was bedeutet ‚ÄûLifting State Up‚Äú?

**‚ÄûLifting State Up‚Äú** bezeichnet ein Muster in React, bei dem **mehrere Komponenten denselben State ben√∂tigen** ‚Äì  
aber **nur eine Elternkomponente** diesen Zustand verwalten soll.

---

## üéØ Warum ‚ÄûState anheben‚Äú?

Wenn zwei oder mehr Komponenten auf denselben Wert zugreifen oder ihn √§ndern m√ºssen,  
ist es besser, den **State in die n√§chste gemeinsame Elternkomponente zu verschieben**.

---

## üí° Beispiel

### ‚úÖ Struktur mit ‚ÄûLifting State Up‚Äú

```jsx
function Parent() {
  const [text, setText] = useState('');

  return (
    <>
      <Input text={text} onTextChange={setText} />
      <Display text={text} />
    </>
  );
}

function Input({ text, onTextChange }) {
  return (
    <input 
      value={text} 
      onChange={(e) => onTextChange(e.target.value)} 
    />
  );
}

function Display({ text }) {
  return <p>Aktueller Text: {text}</p>;
}
```

‚û°Ô∏è `Parent` verwaltet den Zustand `text`,  
und beide Kind-Komponenten (`Input`, `Display`) **bekommen diesen State als Prop**.

---

## üîÅ Vorteile

- ‚úÖ **Zentrale Datenquelle** f√ºr mehrere Komponenten
- ‚úÖ Einfache Synchronisation und Datenfluss
- ‚úÖ Vermeidung von doppeltem State

---

## ‚ö†Ô∏è Typischer Anwendungsfall

- Zwei Komponenten m√ºssen sich **auf denselben Wert beziehen**
- Eine Komponente √§ndert den Wert, die andere zeigt ihn an

---

## üìù Zusammenfassung

**‚ÄûLifting State Up‚Äú** bedeutet, den gemeinsamen Zustand in eine **h√∂herliegende Elternkomponente zu verschieben**,  
damit mehrere untergeordnete Komponenten synchron auf denselben Wert zugreifen k√∂nnen.

---

## üîó Quellen

- [Lifting State Up ‚Äì react.dev](https://react.dev/learn/sharing-state-between-components#lifting-state-up)  
- [State Sharing in React ‚Äì MDN](https://developer.mozilla.org/de/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_components#lifting_state_up)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

34. ### <a name="34"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

35. ### <a name="35"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

36. ### <a name="36"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

37. ### <a name="37"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

38. ### <a name="38"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

39. ### <a name="39"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

40. ### <a name="40"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

41. ### <a name="41"></a> Was sind die Phasen des Komponentenlebenszyklus?

# Was sind die Phasen des Komponentenlebenszyklus?

Der **Komponentenlebenszyklus** in React beschreibt die **Abfolge von Ereignissen**,  
die eine Komponente w√§hrend ihres Bestehens durchl√§uft ‚Äì vom Erstellen bis zum Entfernen aus dem DOM.

‚û°Ô∏è Lebenszyklus-Methoden gelten haupts√§chlich f√ºr **Klassenkomponenten**.  
In **Funktionskomponenten** verwendet man **Hooks** wie `useEffect`.

---

## üìÖ Die 3 Hauptphasen

### 1. üèóÔ∏è **Mounting (Einf√ºgen)**  
Die Komponente wird in den DOM eingef√ºgt.

| Methode             | Beschreibung                                      |
|---------------------|---------------------------------------------------|
| `constructor()`     | Initialisierung, z.‚ÄØB. State setzen               |
| `render()`          | Gibt JSX zur√ºck                                   |
| `componentDidMount()` | Wird **nach dem ersten Render** aufgerufen       |

---

### 2. üîÑ **Updating (Aktualisierung)**  
Wenn Props oder State sich √§ndern, wird die Komponente neu gerendert.

| Methode                 | Beschreibung                                         |
|-------------------------|------------------------------------------------------|
| `render()`              | Gibt JSX erneut zur√ºck                               |
| `componentDidUpdate()`  | Wird **nach jeder √Ñnderung** von Props oder State aufgerufen |

---

### 3. ‚ùå **Unmounting (Entfernen)**  
Die Komponente wird aus dem DOM entfernt.

| Methode                | Beschreibung                           |
|------------------------|----------------------------------------|
| `componentWillUnmount()` | Aufr√§umarbeiten (z.‚ÄØB. Event-Listener entfernen) |

---

## ‚ö†Ô∏è Veraltete Methoden (nicht mehr empfohlen)

- `componentWillMount()`  
- `componentWillReceiveProps()`  
- `componentWillUpdate()`  

‚û°Ô∏è Stattdessen: moderne Methoden oder `useEffect` in Funktionskomponenten verwenden.

---

## üîÅ Lifecycle in Funktionskomponenten

Mit **`useEffect()`** k√∂nnen alle drei Phasen abgebildet werden:

```jsx
useEffect(() => {
  // Mounting & Updating
  return () => {
    // Unmounting
  };
}, [dependencies]);
```

- Kein zweiter Parameter ‚Üí bei jedem Render
- Leeres Array `[]` ‚Üí nur beim Mount
- Mit R√ºckgabefunktion ‚Üí beim Unmount

---

## üìù Zusammenfassung

| Phase       | Methode (Klasse)             | Hook (Funktion)         |
|-------------|------------------------------|-------------------------|
| Mounting    | `constructor`, `componentDidMount` | `useEffect(() => {...}, [])` |
| Updating    | `componentDidUpdate`         | `useEffect(() => {...}, [dep])` |
| Unmounting  | `componentWillUnmount`       | `useEffect(() => {... return () => {...} })` |

---

## üîó Quellen

- [Komponenten-Lebenszyklus ‚Äì React Docs](https://react.dev/learn/referencing-values-with-refs#synchronizing-with-effects)  
- [MDN: Lebenszyklusmethoden in Klassenkomponenten](https://developer.mozilla.org/de/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_components#lebenszyklusmethoden)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

42. ### <a name="42"></a> Welche Lifecycle-Methoden gibt es in Klassenkomponenten?

# Welche Lifecycle-Methoden gibt es in Klassenkomponenten?

In **React-Klassenkomponenten** sind **Lifecycle-Methoden** spezielle Funktionen,  
die automatisch zu bestimmten Zeitpunkten im **Lebenszyklus einer Komponente** aufgerufen werden.

---

## üß≠ √úbersicht: Lifecycle-Phasen & Methoden

### 1. üèóÔ∏è Mounting (Einf√ºgen in den DOM)

| Methode                 | Beschreibung                                      |
|-------------------------|---------------------------------------------------|
| `constructor()`         | Initialisiert State und bindet Methoden           |
| `static getDerivedStateFromProps()` | Reagiert auf Props vor dem ersten Render (selten genutzt) |
| `render()`              | Gibt JSX zur√ºck                                   |
| `componentDidMount()`   | Wird **nach dem ersten Render** aufgerufen (z.‚ÄØB. Daten laden) |

---

### 2. üîÑ Updating (Wenn Props oder State sich √§ndern)

| Methode                        | Beschreibung                                                |
|--------------------------------|-------------------------------------------------------------|
| `static getDerivedStateFromProps()` | (auch hier nutzbar ‚Äì selten n√∂tig)                   |
| `shouldComponentUpdate()`      | Steuert, ob neu gerendert werden soll (Performance)         |
| `render()`                     | Gibt aktualisiertes JSX zur√ºck                              |
| `getSnapshotBeforeUpdate()`    | Erfasst DOM-Infos vor dem Update (z.‚ÄØB. Scrollposition)      |
| `componentDidUpdate()`         | Wird **nach jedem Update** aufgerufen                       |

---

### 3. ‚ùå Unmounting (Entfernen aus dem DOM)

| Methode                 | Beschreibung                                        |
|-------------------------|-----------------------------------------------------|
| `componentWillUnmount()`| Aufr√§umen (Timer l√∂schen, EventListener entfernen etc.) |

---

### 4. ‚ö†Ô∏è Legacy-Methoden (veraltet, nicht mehr empfohlen)

| Methode                    | Hinweis                                               |
|----------------------------|-------------------------------------------------------|
| `componentWillMount()`     | ersetzt durch `constructor()`                        |
| `componentWillReceiveProps()` | ersetzt durch `getDerivedStateFromProps()`       |
| `componentWillUpdate()`    | ersetzt durch `getSnapshotBeforeUpdate()`            |

‚û°Ô∏è Diese Methoden sind **deprecated** und in neuem Code **nicht mehr verwenden**.

---

## üìù Zusammenfassung

| Phase        | Wichtige Methoden                              |
|--------------|-------------------------------------------------|
| Mounting     | `constructor`, `render`, `componentDidMount`   |
| Updating     | `shouldComponentUpdate`, `render`, `componentDidUpdate` |
| Unmounting   | `componentWillUnmount`                         |

Nutze in neuen Projekten **Funktionskomponenten mit `useEffect()`**, wann immer m√∂glich.

---

## üîó Quellen

- [Lifecycle-Methoden ‚Äì React Docs](https://react.dev/reference/react/Component)  
- [MDN: Komponentenlebenszyklus](https://developer.mozilla.org/de/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_components#lebenszyklusmethoden)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

43. ### <a name="43"></a> Welche Lifecycle-Methoden sind veraltet?

# Welche Lifecycle-Methoden sind veraltet?

React hat mit Version **16.3** einige Lifecycle-Methoden als **veraltet (deprecated)** markiert,  
weil sie zu **Fehlverhalten** oder **unerwarteten Updates** f√ºhren konnten ‚Äì insbesondere mit **asynchronem Rendering (z.‚ÄØB. Concurrent Mode)**.

---

## ‚ö†Ô∏è Veraltete Lifecycle-Methoden

| Methode                    | Status            | Empfehlung                     |
|----------------------------|-------------------|--------------------------------|
| `componentWillMount()`     | ‚ùå Veraltet        | Verwende stattdessen `constructor` oder `componentDidMount` |
| `componentWillReceiveProps(nextProps)` | ‚ùå Veraltet | Ersetze durch `getDerivedStateFromProps(nextProps, state)` |
| `componentWillUpdate(nextProps, nextState)` | ‚ùå Veraltet | Ersetze durch `getSnapshotBeforeUpdate(prevProps, prevState)` |

---

## üì¶ Warum wurden sie entfernt?

- Sie wurden **vor dem eigentlichen Rendern** aufgerufen  
- Bei **asynchronem Rendering** (React 18+) k√∂nnen sie mehrfach oder versp√§tet aufgerufen werden  
- Das f√ºhrte zu **Seiteneffekten** (z.‚ÄØB. doppelte Datenanforderungen)

---

## üîÑ Alternativen

| Veraltete Methode         | Alternative                             |
|---------------------------|------------------------------------------|
| `componentWillMount()`    | `constructor()` oder `componentDidMount()` |
| `componentWillReceiveProps()` | `getDerivedStateFromProps()`        |
| `componentWillUpdate()`   | `getSnapshotBeforeUpdate()` + `componentDidUpdate()` |

---

## üß† Hinweis

React f√ºhrt diese Methoden in bestimmten Build-Tools mit dem Pr√§fix **`UNSAFE_`** weiter,  
z.‚ÄØB. `UNSAFE_componentWillMount()` ‚Äì **diese solltest du aber vermeiden!**

---

## üìù Zusammenfassung

Folgende Methoden gelten als **veraltet**:

- `componentWillMount()`  
- `componentWillReceiveProps()`  
- `componentWillUpdate()`

Stattdessen solltest du **neue Lifecycle-Methoden** oder **Hooks wie `useEffect()`** in Funktionskomponenten verwenden.

---

## üîó Quellen

- [React Docs ‚Äì Legacy Lifecycle Methods](https://reactjs.org/docs/react-component.html#legacy-lifecycle-methods)  
- [React Blog ‚Äì Update on Async Rendering](https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

44. ### <a name="44"></a> Wie kann man Lifecycle-Methoden mit Hooks ersetzen?

# Wie kann man Lifecycle-Methoden mit Hooks ersetzen?

In **Funktionskomponenten** verwendet man den **Hook `useEffect()`**, um Verhalten zu implementieren,  
das fr√ºher in **Lifecycle-Methoden von Klassenkomponenten** enthalten war.

---

## üîÅ Vergleich: Klassenmethoden vs. `useEffect`

| Klassenkomponente               | Funktionskomponente mit Hook         |
|----------------------------------|--------------------------------------|
| `componentDidMount()`            | `useEffect(() => { ... }, [])`       |
| `componentDidUpdate()`           | `useEffect(() => { ... }, [deps])`   |
| `componentWillUnmount()`         | `useEffect(() => { return () => {...} }, [])` |
| `componentDidUpdate()` (spezifisch) | `useEffect()` mit bestimmten Abh√§ngigkeiten |

---

## üí° Beispiel 1: `componentDidMount`

```jsx
useEffect(() => {
  console.log('Komponente wurde gemountet');
}, []);
```

‚û°Ô∏è Wird **nur einmal beim Mount** aufgerufen (`[]` = leere Abh√§ngigkeiten)

---

## üí° Beispiel 2: `componentDidUpdate`

```jsx
useEffect(() => {
  console.log('State oder Prop wurde ge√§ndert');
}, [value]);
```

‚û°Ô∏è Wird aufgerufen, wenn sich `value` √§ndert

---

## üí° Beispiel 3: `componentWillUnmount`

```jsx
useEffect(() => {
  return () => {
    console.log('Komponente wird entfernt');
  };
}, []);
```

‚û°Ô∏è R√ºckgabefunktion von `useEffect` = **Aufr√§umcode (Cleanup)**

---

## üîÅ Kombinierte Nutzung

```jsx
useEffect(() => {
  // Mount & Update
  console.log('Mount oder Update');

  return () => {
    // Unmount
    console.log('Cleanup bei Unmount oder vor n√§chstem Update');
  };
}, [someValue]);
```

---

## üß† Hinweis

- `useEffect()` kann **mehrmals pro Komponente verwendet** werden
- Nutze **mehrere `useEffect`-Bl√∂cke** f√ºr klar getrennte Logik (z.‚ÄØB. Daten laden, Events, Timer)

---

## üìù Zusammenfassung

Lifecycle-Methoden in Klassenkomponenten werden durch **`useEffect`** ersetzt.  
Je nach Abh√§ngigkeitsarray (`[]`, `[dep]`, leer) kannst du steuern, ob der Code beim **Mount**, **Update** oder **Unmount** ausgef√ºhrt wird.

---

## üîó Quellen

- [useEffect ‚Äì React Docs](https://react.dev/reference/react/useEffect)  
- [Effekte verstehen ‚Äì react.dev](https://react.dev/learn/synchronizing-with-effects)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

45. ### <a name="45"></a> Was ist componentDidMount und was ist das √Ñquivalent mit Hooks?

# Was ist `componentDidMount` und was ist das √Ñquivalent mit Hooks?

## üìå `componentDidMount` (in Klassenkomponenten)

`componentDidMount()` ist eine **Lifecycle-Methode**, die aufgerufen wird,  
**nachdem** die Komponente **zum ersten Mal** in den DOM eingef√ºgt wurde.

### Typische Anwendungsf√§lle:

- Daten vom Server laden (API-Aufrufe)
- Event-Listener registrieren
- Initiale DOM-Manipulation (z.‚ÄØB. Fokus setzen)

### Beispiel (Klasse):

```jsx
class MyComponent extends React.Component {
  componentDidMount() {
    console.log('Komponente wurde gemountet');
  }

  render() {
    return <div>Hallo</div>;
  }
}
```

---

## ‚úÖ √Ñquivalent mit Hooks: `useEffect(() => { ... }, [])`

In **Funktionskomponenten** erreichst du das gleiche Verhalten mit dem Hook `useEffect`  
und einem **leeren Abh√§ngigkeitsarray (`[]`)**.

### Beispiel (Funktion):

```jsx
import { useEffect } from 'react';

function MyComponent() {
  useEffect(() => {
    console.log('Komponente wurde gemountet');
  }, []);

  return <div>Hallo</div>;
}
```

‚û°Ô∏è Der Effekt wird **nur einmal beim ersten Render** ausgef√ºhrt ‚Äì genau wie `componentDidMount`.

---

## üìù Zusammenfassung

| Klassenkomponente              | Funktionskomponente           |
|--------------------------------|-------------------------------|
| `componentDidMount()`          | `useEffect(() => { ... }, [])` |

Beide Varianten eignen sich f√ºr **initiale Logik**, die **nur einmal** beim Mounting ausgef√ºhrt werden soll.

---

## üîó Quellen

- [componentDidMount ‚Äì React Docs](https://react.dev/reference/react/Component#componentdidmount)  
- [useEffect Hook ‚Äì React Docs](https://react.dev/reference/react/useEffect)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

46. ### <a name="46"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

47. ### <a name="47"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

48. ### <a name="48"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

49. ### <a name="49"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

50. ### <a name="50"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

51. ### <a name="51"></a> Was sind Hooks in React?

# Was sind Hooks in React?

**Hooks** sind **Funktionen**, die es dir erm√∂glichen, in **Funktionskomponenten** von React  
**State** und andere **React-Funktionen** zu verwenden ‚Äì **ohne Klassen zu schreiben**.

Sie wurden mit **React 16.8** eingef√ºhrt.

---

## üéØ Warum Hooks?

Vor Hooks waren **Klassenkomponenten n√∂tig**, um z.‚ÄØB.:

- State zu verwalten
- Lifecycle-Methoden zu verwenden
- auf den DOM zuzugreifen

‚û°Ô∏è Mit Hooks kannst du das **alles auch in Funktionskomponenten** tun ‚Äì **einfacher, klarer, wiederverwendbarer**.

---

## üîß Wichtige React-Hooks

| Hook            | Beschreibung                                    |
|------------------|-------------------------------------------------|
| `useState()`     | Lokaler Zustand (State)                        |
| `useEffect()`    | Nebenwirkungen / Lifecycle-Ersatz              |
| `useRef()`       | Zugriff auf DOM oder persistente Werte         |
| `useContext()`   | Zugriff auf globale Daten aus einem Context    |
| `useReducer()`   | Alternative zu `useState` f√ºr komplexeren State|
| `useMemo()`      | Ergebnis zwischenspeichern (Memoisierung)      |
| `useCallback()`  | Funktionen zwischenspeichern (verhindert Neu-Erstellung) |
| `useLayoutEffect()` | wie `useEffect`, aber synchron nach Layout  |

---

## üí° Beispiel: `useState` und `useEffect`

```jsx
import { useState, useEffect } from 'react';

function Timer() {
  const [seconds, setSeconds] = useState(0);

  useEffect(() => {
    const interval = setInterval(() => {
      setSeconds(s => s + 1);
    }, 1000);

    return () => clearInterval(interval); // Aufr√§umen bei Unmount
  }, []);

  return <p>Timer: {seconds} Sekunden</p>;
}
```

---

## üîÅ Regeln f√ºr Hooks

1. ‚úÖ Nur in **Funktionskomponenten oder eigenen Hooks** verwenden  
2. ‚úÖ Nur **ganz oben im Funktionsk√∂rper aufrufen** (nicht in Bedingungen, Schleifen, etc.)

---

## üìù Zusammenfassung

**Hooks** sind moderne Werkzeuge, um **State, Effekte und andere React-Funktionalit√§ten**  
in **Funktionskomponenten** zu nutzen ‚Äì ohne Klassen.  
Sie machen Komponenten **einfacher, flexibler und wiederverwendbar**.

---

## üîó Quellen

- [Einf√ºhrung in Hooks ‚Äì react.dev](https://react.dev/learn/state-a-components-memory)  
- [Alle React-Hooks ‚Äì React Docs](https://react.dev/reference/react)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

52. ### <a name="52"></a> Wie funktionieren useState und useEffect?

# Wie funktionieren `useState` und `useEffect`?

Die Hooks **`useState`** und **`useEffect`** geh√∂ren zu den wichtigsten Bausteinen  
in React-Funktionskomponenten.  
Sie ersetzen `this.state` und Lifecycle-Methoden wie `componentDidMount`.

---

## üß† `useState` ‚Äì Zustand in Funktionskomponenten

Mit `useState` kannst du **lokale Zust√§nde (State)** in einer Komponente erstellen und aktualisieren.

### Syntax:

```jsx
const [state, setState] = useState(anfangsWert);
```

- `state`: aktueller Wert
- `setState`: Funktion zum √Ñndern des Werts
- `useState(...)`: Initialwert beim ersten Render

### Beispiel:

```jsx
const [count, setCount] = useState(0);

<button onClick={() => setCount(count + 1)}>
  Geklickt: {count}
</button>
```

‚û°Ô∏è Jeder `setCount(...)` l√∂st ein Re-Rendern der Komponente aus.

---

## ‚öôÔ∏è `useEffect` ‚Äì Nebenwirkungen / Lifecycle-Ersatz

`useEffect` f√ºhrt **Seiteneffekte (Effects)** aus, z.‚ÄØB.:

- API-Aufrufe
- EventListener setzen
- Timer starten
- Cleanup beim Unmount

### Syntax:

```jsx
useEffect(() => {
  // Code beim Mount oder Update

  return () => {
    // Cleanup beim Unmount
  };
}, [abh√§ngigkeiten]);
```

---

## üí° Beispiel: `useState` + `useEffect`

```jsx
import { useState, useEffect } from 'react';

function Timer() {
  const [seconds, setSeconds] = useState(0);

  useEffect(() => {
    const interval = setInterval(() => {
      setSeconds(s => s + 1);
    }, 1000);

    return () => clearInterval(interval); // Aufr√§umen beim Unmount
  }, []);

  return <p>Zeit: {seconds} Sek.</p>;
}
```

- ‚è±Ô∏è Timer startet beim Mount (`[]`)
- ‚õî Aufr√§umen mit `clearInterval` beim Unmount

---

## üìù Zusammenfassung

| Hook        | Zweck                               | Wird verwendet f√ºr                       |
|-------------|--------------------------------------|-------------------------------------------|
| `useState`  | Lokalen Zustand speichern            | Z√§hler, Formulare, Flags usw.             |
| `useEffect` | Effekte und Lifecycle-Verhalten      | Daten laden, Timer, Event-Handling, Cleanup |

---

## üîó Quellen

- [useState ‚Äì React Docs](https://react.dev/reference/react/useState)  
- [useEffect ‚Äì React Docs](https://react.dev/reference/react/useEffect)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

53. ### <a name="53"></a> Was macht useContext?

# Was macht `useContext`?

Der Hook **`useContext`** erm√∂glicht dir den **Zugriff auf globale Daten** (z.‚ÄØB. Theme, Sprache, User),  
die mit Reacts **Context API** bereitgestellt werden ‚Äì **ohne Props manuell durch alle Komponenten zu leiten**.

---

## üéØ Warum `useContext`?

- ‚úÖ Vermeidet **Prop-Drilling** (Props durch viele Ebenen weitergeben)  
- ‚úÖ Erm√∂glicht Zugriff auf **globale Zust√§nde oder Konfigurationen**  
- ‚úÖ Macht den Code **lesbarer und wartbarer**

---

## üß± Funktionsweise

1. ‚úÖ Erstelle einen Context mit `React.createContext()`  
2. ‚úÖ Umgib die betroffenen Komponenten mit dem `<Provider>`  
3. ‚úÖ Verwende `useContext(...)` in einer Komponente, um auf die Werte zuzugreifen

---

## üí° Beispiel

```jsx
import { createContext, useContext } from 'react';

// 1. Context erstellen
const ThemeContext = createContext('light');

function App() {
  return (
    // 2. Context-Provider mit aktuellem Wert
    <ThemeContext.Provider value="dark">
      <Toolbar />
    </ThemeContext.Provider>
  );
}

function Toolbar() {
  return (
    <div>
      <ThemeButton />
    </div>
  );
}

// 3. useContext verwenden
function ThemeButton() {
  const theme = useContext(ThemeContext);
  return <button className={theme}>Theme: {theme}</button>;
}
```

‚û°Ô∏è `ThemeButton` erh√§lt den Wert **direkt aus dem Kontext**, **ohne Props** von `App ‚Üí Toolbar ‚Üí ThemeButton`.

---

## üß† Wichtig

- `useContext` **abonniert** den Context ‚Äì bei √Ñnderungen wird die Komponente **neu gerendert**
- Der Context-Wert kann **beliebige Datentypen enthalten** (String, Object, Funktion, etc.)

---

## üìù Zusammenfassung

- `useContext` liest Werte aus einem **React Context**  
- Ideal, um globale Daten wie Theme, Sprache oder Authentifizierung zu teilen  
- Vermeidet manuelles Weitergeben von Props durch die Komponenten-Hierarchie

---

## üîó Quellen

- [useContext ‚Äì React Docs](https://react.dev/reference/react/useContext)  
- [Context API ‚Äì React Docs](https://react.dev/learn/passing-data-deeply-with-context)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

54. ### <a name="54"></a> Was ist useRef und wann wird es verwendet?

# Was ist `useRef` und wann wird es verwendet?

Der Hook **`useRef`** wird in React verwendet, um **eine Referenz auf ein DOM-Element** oder **einen stabilen Wert** zu speichern,  
der **√ºber Re-Renders hinweg erhalten bleibt**, ohne ein Re-Render auszul√∂sen.

---

## üì¶ Was macht `useRef`?

- Erstellt ein **ref-Objekt**: `{ current: ... }`
- Wird **nicht beim Re-Render ver√§ndert**
- Wird **nicht automatisch im UI angezeigt**
- Kann sowohl f√ºr **DOM-Zugriff** als auch f√ºr **persistente Werte** verwendet werden

---

## üí° Anwendungsf√§lle

### 1. üìå Zugriff auf DOM-Elemente

```jsx
import { useRef, useEffect } from 'react';

function InputFocus() {
  const inputRef = useRef();

  useEffect(() => {
    inputRef.current.focus(); // Fokus setzen beim Mount
  }, []);

  return <input ref={inputRef} />;
}
```

‚û°Ô∏è Zugriff auf das echte DOM-Element, ohne `document.querySelector`.

---

### 2. üéØ Persistente Werte zwischen Renders (ohne Re-Render auszul√∂sen)

```jsx
const renderCount = useRef(0);
renderCount.current++;
console.log('Render: ', renderCount.current);
```

‚û°Ô∏è Ideal z.‚ÄØB. f√ºr Z√§hler, Timer-IDs, vorherige Werte usw.

---

### 3. üßπ Aufr√§um-Referenzen

```jsx
const intervalId = useRef();

useEffect(() => {
  intervalId.current = setInterval(...);

  return () => clearInterval(intervalId.current);
}, []);
```

‚û°Ô∏è Praktisch f√ºr Cleanup-Logik in `useEffect`.

---

## üîÅ Vergleich zu `state`

| Hook      | Re-Renders bei √Ñnderung? | Persistiert zwischen Renders? | Typischer Anwendungsfall         |
|-----------|---------------------------|-------------------------------|----------------------------------|
| `useState`| ‚úÖ Ja                     | ‚úÖ Ja                          | UI-Zust√§nde                     |
| `useRef`  | ‚ùå Nein                   | ‚úÖ Ja                          | DOM-Zugriff, Werte au√üerhalb der UI |

---

## üìù Zusammenfassung

- `useRef` wird verwendet f√ºr:
  - **DOM-Zugriff**
  - **Zwischenspeicherung von Werten ohne Re-Renders**
  - **Cleanup / Speichern von IDs, vorherigen Werten etc.**
- Das ref-Objekt hat eine `.current`-Eigenschaft, die ver√§ndert werden kann, ohne UI zu beeinflussen

---

## üîó Quellen

- [useRef ‚Äì React Docs](https://react.dev/reference/react/useRef)  
- [React: Refs und DOM ‚Äì react.dev](https://react.dev/learn/referencing-values-with-refs)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

55. ### <a name="55"></a> Was ist useCallback, useMemo, useReducer?

# Was ist `useCallback`, `useMemo`, `useReducer`?

Diese drei React-Hooks sind **fortgeschrittene Werkzeuge**,  
die helfen, **Performance zu optimieren** oder **komplexeren State** zu verwalten.

---

## ‚úÖ `useCallback`

`useCallback(fn, deps)` gibt eine **zwischengespeicherte (memoisierte)** Version der Funktion `fn` zur√ºck,  
die **nur neu erstellt wird**, wenn sich eine der **Abh√§ngigkeiten (`deps`)** √§ndert.

### Zweck:
- ‚úÖ Verhindert **unn√∂tige Neudefinition** von Funktionen
- ‚úÖ Vermeidet **unn√∂tige Re-Renders** von Kindkomponenten, die Funktionen als Props bekommen

### Beispiel:

```jsx
const handleClick = useCallback(() => {
  console.log('Geklickt!');
}, []);
```

---

## ‚úÖ `useMemo`

`useMemo(() => result, deps)` berechnet und speichert einen **Wert**,  
und **berechnet ihn nur neu**, wenn sich eine Abh√§ngigkeit √§ndert.

### Zweck:
- ‚úÖ Vermeidet **teure Berechnungen bei jedem Render**
- ‚úÖ Liefert **stabilen Wert** √ºber mehrere Renders hinweg

### Beispiel:

```jsx
const sortedItems = useMemo(() => {
  return items.sort((a, b) => a.value - b.value);
}, [items]);
```

---

## ‚úÖ `useReducer`

`useReducer(reducer, initialState)` ist eine Alternative zu `useState`,  
die sich besonders bei **komplexem State oder mehreren abh√§ngigen Zust√§nden** lohnt.

### Zweck:
- ‚úÖ Klare Struktur f√ºr **State-Management**
- ‚úÖ √Ñhnlich wie `Redux`-Reducer

### Beispiel:

```jsx
function reducer(state, action) {
  switch (action.type) {
    case 'increment': return { count: state.count + 1 };
    case 'decrement': return { count: state.count - 1 };
    default: return state;
  }
}

const [state, dispatch] = useReducer(reducer, { count: 0 });

<button onClick={() => dispatch({ type: 'increment' })}>
  {state.count}
</button>
```

---

## üîÅ Vergleich

| Hook         | Zweck                                  | Typischer Einsatz                    |
|--------------|-----------------------------------------|--------------------------------------|
| `useCallback`| Funktion nur bei Bedarf neu erstellen   | Callback-Props, Performance-Tuning   |
| `useMemo`    | Teure Berechnung nur bei √Ñnderung       | sortieren, filtern, berechnen        |
| `useReducer` | Komplexen State zentral verwalten       | Formulare, komplexe Logik, Redux-Ersatz |

---

## üìù Zusammenfassung

- `useCallback`: Memoisiert Funktionen  
- `useMemo`: Memoisiert Werte  
- `useReducer`: Komplexes State-Management mit einer zentralen Logik

Diese Hooks verbessern **Performance und Struktur** bei wachsender App-Komplexit√§t.

---

## üîó Quellen

- [useCallback ‚Äì React Docs](https://react.dev/reference/react/useCallback)  
- [useMemo ‚Äì React Docs](https://react.dev/reference/react/useMemo)  
- [useReducer ‚Äì React Docs](https://react.dev/reference/react/useReducer)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

56. ### <a name="56"></a> Wie schreibt man einen benutzerdefinierten Hook?

# Wie schreibt man einen benutzerdefinierten Hook?

Ein **benutzerdefinierter Hook** (engl. *custom hook*) ist eine **eigene JavaScript-Funktion**,  
die **andere Hooks verwendet**, um **wiederverwendbare Logik** aus React-Komponenten auszulagern.

---

## üéØ Warum benutzerdefinierte Hooks?

- ‚úÖ Wiederverwendbare Logik kapseln (z.‚ÄØB. Formular, API, Timer)
- ‚úÖ Komponenten schlanker und verst√§ndlicher machen
- ‚úÖ Mehrere Hooks gemeinsam verwenden

---

## üì¶ Regeln f√ºr eigene Hooks

1. Beginnt immer mit `use` (z.‚ÄØB. `useForm`, `useTimer`)  
2. Darf **nur innerhalb von Funktionskomponenten oder anderen Hooks** aufgerufen werden  
3. Nutzt beliebige andere React-Hooks (`useState`, `useEffect`, `useRef`, usw.)

---

## üí° Beispiel: `useWindowWidth`

```jsx
import { useState, useEffect } from 'react';

function useWindowWidth() {
  const [width, setWidth] = useState(window.innerWidth);

  useEffect(() => {
    function handleResize() {
      setWidth(window.innerWidth);
    }

    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  return width;
}
```

‚û°Ô∏è Dieser Hook liefert die **aktuelle Fensterbreite** und aktualisiert sie automatisch bei Resize.

---

## ‚úÖ Verwendung in Komponente

```jsx
function App() {
  const width = useWindowWidth();

  return <p>Fensterbreite: {width}px</p>;
}
```

---

## üîÅ Beispiel: `useLocalStorage`

```jsx
function useLocalStorage(key, initialValue) {
  const [value, setValue] = useState(() => {
    const saved = localStorage.getItem(key);
    return saved ? JSON.parse(saved) : initialValue;
  });

  useEffect(() => {
    localStorage.setItem(key, JSON.stringify(value));
  }, [key, value]);

  return [value, setValue];
}
```

‚û°Ô∏è Verwaltet einen State **synchron mit localStorage**.

---

## üìù Zusammenfassung

- Benutzerdefinierte Hooks sind **Funktionen mit eigenen Namen**, die andere Hooks enthalten
- Sie dienen der **Wiederverwendung von Logik**
- Sie **starten immer mit `use`**
- Sie machen Komponenten **sauberer, testbarer und wartbarer**

---

## üîó Quellen

- [Eigene Hooks erstellen ‚Äì React Docs](https://react.dev/learn/reusing-logic-with-custom-hooks)  
- [Custom Hooks ‚Äì React API Docs](https://react.dev/reference/react#custom-hooks)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

57. ### <a name="57"></a> Wie verhindert man eine Endlosschleife in useEffect?

# Wie verhindert man eine Endlosschleife in `useEffect`?

Eine **Endlosschleife** in `useEffect` entsteht meist dann, wenn der Effekt bei jedem Render erneut ausgef√ºhrt wird,  
weil sich eine **Abh√§ngigkeit st√§ndig ver√§ndert** oder **nicht korrekt definiert wurde**.

---

## ‚ö†Ô∏è Ursachen f√ºr Endlosschleifen

### 1. ‚ùå Fehlende Abh√§ngigkeitsliste

```jsx
useEffect(() => {
  fetchData(); // Wird bei jedem Render erneut aufgerufen!
});
```

‚û°Ô∏è Ohne `[]` wird der Effekt **bei jedem Render** ausgef√ºhrt ‚Üí Endlosschleife m√∂glich.

---

### 2. ‚ùå Abh√§ngigkeit ver√§ndert sich bei jedem Render

```jsx
useEffect(() => {
  const data = { id: 1 }; // neues Objekt bei jedem Render
  doSomething(data);
}, [{ id: 1 }]);
```

‚û°Ô∏è Das Objekt `{ id: 1 }` ist **bei jedem Render neu** ‚Üí `useEffect` wird st√§ndig neu ausgef√ºhrt.

---

## ‚úÖ L√∂sungen

### ‚úÖ 1. Leeres Array (`[]`) ‚Üí nur beim Mount

```jsx
useEffect(() => {
  fetchData(); // wird nur einmal ausgef√ºhrt
}, []);
```

‚û°Ô∏è Effekt l√§uft **nur beim ersten Render**

---

### ‚úÖ 2. Stabile Abh√§ngigkeiten verwenden

Vermeide Funktionen/Objekte als Abh√§ngigkeiten, **wenn sie bei jedem Render neu erzeugt werden**.

### Statt:

```jsx
useEffect(() => {
  doSomething(() => {});
}, []);
```

### Besser:

```jsx
const stableFn = useCallback(() => {
  doSomething();
}, []);

useEffect(() => {
  stableFn();
}, [stableFn]);
```

---

### ‚úÖ 3. Werte in `useRef` speichern, die keinen Re-Render ausl√∂sen sollen

```jsx
const dataRef = useRef({ id: 1 });

useEffect(() => {
  doSomething(dataRef.current);
}, []);
```

---

## üìù Zusammenfassung

Um Endlosschleifen in `useEffect` zu vermeiden:

- ‚úÖ Nutze ein **leeres Abh√§ngigkeitsarray `[]`** f√ºr einmalige Ausf√ºhrung
- ‚úÖ **Memoisiere Funktionen oder Objekte** mit `useCallback` oder `useMemo`
- ‚úÖ Verwende `useRef`, wenn keine Reaktivit√§t notwendig ist
- ‚ùå Vermeide **direkte Objekterzeugung** oder **Funktionen** in der Abh√§ngigkeitsliste

---

## üîó Quellen

- [useEffect ‚Äì React Docs](https://react.dev/reference/react/useEffect)  
- [Effekt-Abh√§ngigkeiten verstehen ‚Äì react.dev](https://react.dev/learn/synchronizing-with-effects#specifying-dependencies)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

58. ### <a name="58"></a> Wie implementiert man Timeout oder Interval mit Hooks?

# Wie implementiert man `setTimeout` oder `setInterval` mit Hooks?

Mit **`useEffect`** und **`useRef`** kannst du in Funktionskomponenten sauber **Timeouts** und **Intervalle** verwalten ‚Äì  
inklusive **automatischem Aufr√§umen** beim Unmount.

---

## ‚è±Ô∏è `setTimeout` mit `useEffect`

```jsx
import { useEffect } from 'react';

function TimeoutExample() {
  useEffect(() => {
    const timeoutId = setTimeout(() => {
      console.log('Einmaliger Timeout nach 3 Sekunden');
    }, 3000);

    return () => clearTimeout(timeoutId); // Cleanup bei Unmount
  }, []);

  return <p>Warte auf Timeout‚Ä¶</p>;
}
```

‚û°Ô∏è Der Effekt wird **nur einmal** beim Mount ausgef√ºhrt (`[]`).

---

## üîÅ `setInterval` mit `useEffect`

```jsx
import { useEffect, useState } from 'react';

function IntervalExample() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const intervalId = setInterval(() => {
      setCount(c => c + 1); // Immer aktuellen Wert verwenden
    }, 1000);

    return () => clearInterval(intervalId); // Aufr√§umen beim Unmount
  }, []);

  return <p>Z√§hler: {count}</p>;
}
```

‚û°Ô∏è Der Intervall wird beim Mount gestartet und beim Unmount gestoppt.

---

## üí° Tipp: `useRef` f√ºr Zugriff auf aktuelle Werte

F√ºr erweiterte Kontrolle (z.‚ÄØB. stoppen/starten), verwende `useRef`:

```jsx
const intervalRef = useRef();

useEffect(() => {
  intervalRef.current = setInterval(() => {
    ...
  }, 1000);

  return () => clearInterval(intervalRef.current);
}, []);
```

---

## üìù Zusammenfassung

| Ziel          | Hook             | Beschreibung                          |
|---------------|------------------|----------------------------------------|
| `setTimeout`  | `useEffect`      | Einmalige Verz√∂gerung                  |
| `setInterval` | `useEffect`      | Wiederholende Aktion mit Cleanup       |
| Kontrolle     | `useRef`         | ID speichern, Zugriff auf aktuellen Zustand |

---

## üîó Quellen

- [useEffect ‚Äì React Docs](https://react.dev/reference/react/useEffect)  
- [MDN ‚Äì setTimeout](https://developer.mozilla.org/de/docs/Web/API/setTimeout)  
- [MDN ‚Äì setInterval](https://developer.mozilla.org/de/docs/Web/API/setInterval)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

59. ### <a name="59"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

60. ### <a name="60"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

61. ### <a name="61"></a> Was ist ein Higher-Order Component (HOC)?

# Was ist ein Higher-Order Component (HOC)?

Ein **Higher-Order Component (HOC)** ist ein **Designmuster in React**,  
bei dem **eine Funktion eine Komponente nimmt und eine neue, erweiterte Komponente zur√ºckgibt**.

---

## üéØ Zweck eines HOC

- ‚úÖ **Wiederverwendbare Logik** auf mehrere Komponenten anwenden  
- ‚úÖ Komponenten **mit zus√§tzlichen Props, Verhalten oder Styling** erweitern  
- ‚úÖ Trennung von Zust√§ndigkeiten (Separation of Concerns)

---

## üì¶ Definition

```js
const EnhancedComponent = withSomething(WrappedComponent);
```

‚û°Ô∏è `withSomething` ist das HOC, `WrappedComponent` ist die Originalkomponente.

---

## üí° Einfaches Beispiel: `withLogger`

```jsx
function withLogger(WrappedComponent) {
  return function EnhancedComponent(props) {
    console.log('Props:', props);
    return <WrappedComponent {...props} />;
  };
}
```

### Verwendung:

```jsx
const LoggedButton = withLogger(Button);
```

‚û°Ô∏è Jedes Mal, wenn `LoggedButton` verwendet wird, werden die Props geloggt.

---

## üîÅ Typische Anwendungsf√§lle

- Zugriffsschutz (z.‚ÄØB. `withAuth`)
- Theming (z.‚ÄØB. `withTheme`)
- Logging & Analytics
- Fehlerbehandlung (`withErrorBoundary`)
- Datenanbindung (z.‚ÄØB. `connect()` in Redux)

---

## ‚ö†Ô∏è Hinweise

- HOCs **ver√§ndern nicht** die urspr√ºngliche Komponente, sondern **verpacken sie**
- HOC **d√ºrfen keine Seiteneffekte beim Rendern haben**
- Der **Komponentenname sollte erhalten bleiben** (z.‚ÄØB. mit `displayName`), f√ºr Debugging

---

## üìù Zusammenfassung

Ein **Higher-Order Component (HOC)** ist eine Funktion,  
die eine Komponente nimmt und **eine neue Komponente mit erweitertem Verhalten** zur√ºckgibt.  
Sie ist ein m√§chtiges Werkzeug zur **Wiederverwendung von Logik und Struktur**.

---

## üîó Quellen

- [React Docs ‚Äì Higher-Order Components](https://reactjs.org/docs/higher-order-components.html)  
- [MDN ‚Äì React Komponentendesignmuster](https://developer.mozilla.org/de/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_components#higher-order-components)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

62. ### <a name="62"></a> Was ist das Render-Prop-Pattern?

# Was ist das Render-Prop-Pattern?

Das **Render-Prop-Pattern** ist ein **React-Designmuster**,  
bei dem eine Komponente eine **Funktion als Prop (render prop)** erh√§lt,  
um **flexibel zu steuern, was gerendert werden soll**.

---

## üéØ Zweck des Patterns

- ‚úÖ Erm√∂glicht das **Teilen von wiederverwendbarer Logik**
- ‚úÖ Gibt der Elternkomponente die **volle Kontrolle √ºber das gerenderte UI**
- ‚úÖ Alternative zu HOCs oder Hooks bei **logikbasiertem Code-Sharing**

---

## üì¶ Struktur

```jsx
<MyComponent render={(data) => (
  <p>{data.message}</p>
)} />
```

Oder via `children`-Prop:

```jsx
<MyComponent>
  {(data) => <p>{data.message}</p>}
</MyComponent>
```

---

## üí° Beispiel: `MouseTracker` mit Render-Prop

```jsx
function MouseTracker({ render }) {
  const [position, setPosition] = useState({ x: 0, y: 0 });

  useEffect(() => {
    const handleMove = (e) => setPosition({ x: e.clientX, y: e.clientY });
    window.addEventListener('mousemove', handleMove);
    return () => window.removeEventListener('mousemove', handleMove);
  }, []);

  return render(position);
}
```

### Verwendung:

```jsx
<MouseTracker
  render={({ x, y }) => (
    <p>Position: {x}, {y}</p>
  )}
/>
```

---

## üîÅ Vorteile gegen√ºber HOC

| Aspekt               | Render-Prop             | HOC                           |
|----------------------|-------------------------|--------------------------------|
| Mehrfach verwendbar  | ‚úÖ Ja                   | ‚úÖ Ja                          |
| Flexibel im UI       | ‚úÖ Sehr flexibel         | ‚ùå Eingeschr√§nkter UI-Zugriff |
| Komponentenbaum flach| ‚úÖ Ja                   | ‚ùå Kann tiefe Wrapper erzeugen |

---

## ‚ö†Ô∏è Nachteile

- Kann bei vielen Ebenen zu **"Wrapper Hell"** f√ºhren (√§hnlich wie HOC)
- Wird heute oft durch **Hooks ersetzt**, da diese **einfacher und lesbarer** sind

---

## üìù Zusammenfassung

Das **Render-Prop-Pattern** erm√∂glicht das **Weitergeben von Logik √ºber Funktionen als Props**.  
Die aufrufende Komponente entscheidet, **wie das UI aussehen soll**, w√§hrend die Logik zentral bleibt.

---

## üîó Quellen

- [Render Props ‚Äì React Docs](https://reactjs.org/docs/render-props.html)  
- [React Patterns ‚Äì Render Props](https://reactpatterns.com/#render-callback)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

63. ### <a name="63"></a> Was ist die Context-API und wie funktioniert useContext?

# Was ist die Context-API und wie funktioniert `useContext`?

Die **Context-API** von React ist ein integrierter Mechanismus,  
um **globale Daten (z.‚ÄØB. Theme, Sprache, Benutzerinfos)**  
an beliebige Komponenten im Komponentenbaum **weiterzugeben**,  
**ohne Props manuell durch mehrere Ebenen zu reichen**.

---

## üéØ Warum Context?

- ‚úÖ Vermeidet **Prop-Drilling**  
- ‚úÖ Ideal f√ºr **globale Zust√§nde oder Konfigurationen**  
- ‚úÖ Einfach zu kombinieren mit `useContext`

---

## üß± Bestandteile der Context-API

1. **`createContext()`** ‚Äì erstellt einen neuen Kontext  
2. **`<Provider>`** ‚Äì stellt einen Wert zur Verf√ºgung  
3. **`useContext(Context)`** ‚Äì liest den aktuellen Wert des Kontexts

---

## üí° Beispiel: ThemeContext

### 1. Context erstellen:

```jsx
import { createContext } from 'react';

const ThemeContext = createContext('light'); // optionaler Default-Wert
```

---

### 2. Provider verwenden:

```jsx
function App() {
  return (
    <ThemeContext.Provider value="dark">
      <Toolbar />
    </ThemeContext.Provider>
  );
}
```

---

### 3. Zugriff mit `useContext`:

```jsx
import { useContext } from 'react';

function ThemeButton() {
  const theme = useContext(ThemeContext); // "dark"
  return <button className={theme}>Aktuelles Theme: {theme}</button>;
}
```

‚û°Ô∏è `ThemeButton` hat Zugriff auf den Kontextwert, ohne dass Props √ºber `Toolbar` weitergegeben werden m√ºssen.

---

## üìå Wichtig zu wissen

- Jeder Context-Wert ist **nur innerhalb seines `<Provider>` sichtbar**  
- Komponenten werden **neu gerendert**, wenn sich der Context-Wert √§ndert  
- Context ist **nicht als globaler State-Ersatz f√ºr komplexe Logik** gedacht (‚Üí besser: Redux, Zustand, etc.)

---

## üìù Zusammenfassung

- Die **Context-API** erlaubt das **Teilen globaler Werte** im Komponentenbaum  
- Mit `useContext(Context)` kannst du in Funktionskomponenten **einfach auf diese Werte zugreifen**  
- Sie ist n√ºtzlich f√ºr Dinge wie **Themen, Sprache, Benutzerinfo, Feature-Flags**

---

## üîó Quellen

- [Context ‚Äì React Docs](https://react.dev/learn/passing-data-deeply-with-context)  
- [useContext ‚Äì React Docs](https://react.dev/reference/react/useContext)  
- [MDN: Context in React](https://developer.mozilla.org/de/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_components#context)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

64. ### <a name="64"></a> Was sind Portale in React?

# Was sind Portale in React?

**Portale** (engl. *Portals*) in React erm√∂glichen es, **Komponenten au√üerhalb der normalen DOM-Hierarchie**  
zu rendern ‚Äì also **au√üerhalb des `div#root`**, aber trotzdem **vollst√§ndig von React verwaltet**.

---

## üéØ Wann braucht man ein Portal?

- Modale Dialoge (z.‚ÄØB. `<Modal />`)  
- Tooltips  
- Dropdown-Men√ºs  
- Overlays  
- Elemente, die visuell **√ºber anderen Komponenten liegen** m√ºssen

‚û°Ô∏è Diese Elemente m√ºssen oft **am Ende des `<body>`** gerendert werden, um korrekt zu funktionieren (z.‚ÄØB. Z-Index, Positionierung).

---

## üí° Beispiel: Portal verwenden

### 1. Ziel-Element im HTML

```html
<body>
  <div id="root"></div>
  <div id="modal-root"></div> <!-- Hier wird das Portal platziert -->
</body>
```

---

### 2. Komponente mit Portal

```jsx
import { createPortal } from 'react-dom';

function Modal({ children }) {
  return createPortal(
    <div className="modal">{children}</div>,
    document.getElementById('modal-root')
  );
}
```

---

### 3. Verwendung in der App

```jsx
function App() {
  return (
    <>
      <h1>Seite</h1>
      <Modal>
        <p>Ich werde au√üerhalb von #root gerendert!</p>
      </Modal>
    </>
  );
}
```

‚û°Ô∏è Das Modal wird **optisch au√üerhalb** des Hauptbaums gerendert,  
aber **logisch bleibt es Teil von React** ‚Äì inklusive Props, State, Events usw.

---

## üîÅ Vorteile von Portalen

| Vorteil                    | Beschreibung                                       |
|----------------------------|----------------------------------------------------|
| üîÑ Event-Bubbling bleibt   | Events funktionieren weiterhin wie gewohnt         |
| üéØ Flexibles Layout        | Bessere Positionierung im DOM                      |
| üîí Kein CSS-Zusammensto√ü   | Vermeidet Probleme mit `overflow: hidden`, `z-index` etc.

---

## üìù Zusammenfassung

- Portale rendern Komponenten **au√üerhalb des DOM-Hierarchie der Eltern**
- N√ºtzlich f√ºr **Modale, Tooltips, Overlays**
- Implementiert mit `ReactDOM.createPortal(element, domNode)`

---

## üîó Quellen

- [Portals ‚Äì React Docs](https://reactjs.org/docs/portals.html)  
- [MDN: DOM-Portale und Modale](https://developer.mozilla.org/de/docs/Web/HTML/Element/dialog)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

65. ### <a name="65"></a> Was ist bedingtes Rendern (Conditional Rendering)?

# Was ist bedingtes Rendern (Conditional Rendering) in React?

**Bedingtes Rendern** bedeutet in React, dass eine Komponente **abh√§ngig von einer Bedingung**  
**unterschiedlichen JSX-Inhalt rendert** ‚Äì also **dynamisch entscheidet, was angezeigt wird**.

---

## üéØ Anwendungsbeispiele

- Benutzer ist **eingeloggt oder nicht**
- Ladevorgang (`Loading...`) vs. Datenanzeige
- Verschiedene UI-Elemente abh√§ngig von Status, Rollen, Berechtigungen

---

## üîß Methoden f√ºr bedingtes Rendern

### ‚úÖ 1. `if`-Anweisung

```jsx
if (isLoggedIn) {
  return <Dashboard />;
} else {
  return <LoginForm />;
}
```

---

### ‚úÖ 2. Tern√§rer Operator (`? :`)

```jsx
return (
  <div>
    {isLoading ? <p>Lade Daten...</p> : <DataList />}
  </div>
);
```

---

### ‚úÖ 3. Logischer UND-Operator (`&&`)

```jsx
{hasPermission && <DeleteButton />}
```

‚û°Ô∏è Rendert `DeleteButton` **nur**, wenn `hasPermission === true` ist.

---

### ‚úÖ 4. Optionales Rendering mit `null`

```jsx
{shouldShow ? <Component /> : null}
```

‚û°Ô∏è Wenn `shouldShow === false`, wird **gar nichts** gerendert.

---

## üìù Zusammenfassung

**Conditional Rendering** bedeutet, dass JSX **dynamisch** auf Basis von Bedingungen  
**unterschiedlichen Inhalt rendert**.  
React unterst√ºtzt daf√ºr mehrere Schreibweisen:  
`if`, `? :`, `&&`, R√ºckgabe von `null`.

---

## üîó Quellen

- [Conditional Rendering ‚Äì React Docs](https://react.dev/learn/conditional-rendering)  
- [MDN: Bedingte Ausdr√ºcke](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Operators/Conditional_Operator)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

66. ### <a name="66"></a> Was ist ein Error Boundary?

# Was ist ein Error Boundary in React?

Ein **Error Boundary** (Fehlergrenze) ist eine **spezielle React-Komponente**,  
die **JavaScript-Fehler** in ihrer **Kind-Komponenten-Hierarchie abf√§ngt**,  
um zu verhindern, dass der **gesamte UI-Baum zusammenbricht**.

---

## üéØ Zweck von Error Boundaries

- ‚úÖ Fehler im UI **abfangen**, anzeigen und kontrolliert behandeln  
- ‚úÖ Verhindert den **Absturz der gesamten App**  
- ‚úÖ Zeigt stattdessen **Fallback-UI** oder eine Fehlermeldung an

---

## üì¶ Wann tritt ein Fehler auf?

Error Boundaries fangen **nur Fehler w√§hrend des Renderns**,  
in **Lifecycle-Methoden** und in **Konstruktoren von Klassenkomponenten** ab.

**Nicht abgefangen werden**:
- Fehler in Event-Handlern (diese m√ºssen manuell mit `try/catch` behandelt werden)
- Fehler in `async`-Funktionen
- Fehler au√üerhalb des React-Baums

---

## üí° Beispiel: Error Boundary (Klassenkomponente)

```jsx
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, info) {
    console.error('Fehler abgefangen:', error, info);
  }

  render() {
    if (this.state.hasError) {
      return <h2>Etwas ist schiefgelaufen.</h2>;
    }

    return this.props.children;
  }
}
```

---

### ‚úÖ Verwendung:

```jsx
<ErrorBoundary>
  <ProblematicComponent />
</ErrorBoundary>
```

‚û°Ô∏è Wenn `ProblematicComponent` crasht, zeigt `ErrorBoundary` stattdessen die Fallback-UI.

---

## üß™ Wann verwenden?

- Um Teile der App **abzusichern** (z.‚ÄØB. Seitenbereiche, Widgets)
- Um **Logs zu erfassen** (`componentDidCatch`)
- Um den Nutzer bei Fehlern **nicht allein zu lassen**

---

## üìù Zusammenfassung

Ein **Error Boundary** ist eine **Klassenkomponente**,  
die Fehler in der React-Komponentenstruktur **abf√§ngt und behandelt**,  
ohne dass die ganze App abst√ºrzt.  
Sie bietet eine **Fallback-UI** und hilft bei **Debugging & Stabilit√§t**.

---

## üîó Quellen

- [Error Boundaries ‚Äì React Docs](https://react.dev/learn/managing-errors)  
- [MDN: Fehlerbehandlung in React](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch#handling_errors_in_react)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

67. ### <a name="67"></a> Wie funktioniert Event-Handling in React?

# Wie funktioniert Event-Handling in React?

**Event-Handling** in React funktioniert √§hnlich wie in HTML/JavaScript,  
aber mit einigen **Unterschieden in Syntax und Verhalten**.

---

## üéØ Besonderheiten in React

- React verwendet **camelCase** statt Kleinschreibung:
  - `onClick` statt `onclick`
- Event-Handler werden als **Funktionen (nicht Strings)** √ºbergeben:
  - `{handleClick}` statt `"handleClick()"`

---

## üí° Beispiel: Klick-Event

```jsx
function Button() {
  function handleClick() {
    alert('Button wurde geklickt!');
  }

  return <button onClick={handleClick}>Klicken</button>;
}
```

---

## üì¶ Event-Objekt

React stellt ein **synthetisches Event-Objekt** (`SyntheticEvent`) bereit,  
das mit allen Browsern konsistent funktioniert.

```jsx
function Input() {
  function handleChange(e) {
    console.log('Eingegeben:', e.target.value);
  }

  return <input onChange={handleChange} />;
}
```

‚û°Ô∏è `e` ist das SyntheticEvent, das sich **√§hnlich wie ein native DOM-Event** verh√§lt.

---

## üîÅ Weitere Event-Beispiele

| Event         | Attribut        | Beispiel                           |
|---------------|------------------|------------------------------------|
| Klick         | `onClick`        | `<button onClick={fn} />`          |
| Eingabe       | `onChange`       | `<input onChange={fn} />`          |
| Fokus         | `onFocus`        | `<input onFocus={fn} />`           |
| Maus bewegen  | `onMouseMove`    | `<div onMouseMove={fn} />`         |
| Formular      | `onSubmit`       | `<form onSubmit={fn} />`           |
| Taste dr√ºcken | `onKeyDown`      | `<input onKeyDown={fn} />`         |

---

## ‚úÖ Standardverhalten verhindern

```jsx
function Form() {
  function handleSubmit(e) {
    e.preventDefault(); // verhindert Seitenreload
    console.log('Formular abgesendet');
  }

  return <form onSubmit={handleSubmit}>...</form>;
}
```

---

## üìù Zusammenfassung

- React verwendet eigene Events (`SyntheticEvent`) mit vertrauter API  
- Event-Handler werden als Funktionen mit camelCase geschrieben  
- Du kannst Standardverhalten (z.‚ÄØB. Form-Submit) mit `e.preventDefault()` unterdr√ºcken

---

## üîó Quellen

- [Events in React ‚Äì React Docs](https://react.dev/learn/responding-to-events)  
- [React Event Handling ‚Äì MDN](https://developer.mozilla.org/en-US/docs/Web/Events)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

68. ### <a name="68"></a> Was ist ein synthetisches Ereignis (SyntheticEvent)?

# Was ist ein synthetisches Ereignis (SyntheticEvent) in React?

Ein **synthetisches Ereignis** (`SyntheticEvent`) ist ein von React bereitgestelltes **plattformsicheres Wrapper-Objekt**  
f√ºr native DOM-Ereignisse wie `click`, `change`, `submit`, etc.

---

## üéØ Zweck von `SyntheticEvent`

- ‚úÖ Einheitliches Verhalten in **allen Browsern**
- ‚úÖ Automatisches **Event-Pooling** (fr√ºher)
- ‚úÖ Konsistente API f√ºr alle Event-Typen
- ‚úÖ Kombiniert die Vorteile von DOM- und Custom-Events

---

## üì¶ Eigenschaften

- `SyntheticEvent` hat die **gleichen Methoden und Eigenschaften** wie ein normales DOM-Event:  
  - `e.target`, `e.preventDefault()`, `e.stopPropagation()` usw.
- Funktioniert f√ºr **alle Event-Typen**: Maus, Tastatur, Formulare, Fokus, usw.

---

## üí° Beispiel

```jsx
function Form() {
  function handleSubmit(e) {
    e.preventDefault(); // verhindert Reload
    console.log('Eingabefeld:', e.target.elements.name.value);
  }

  return (
    <form onSubmit={handleSubmit}>
      <input name="name" />
      <button type="submit">Absenden</button>
    </form>
  );
}
```

‚û°Ô∏è `e` ist ein `SyntheticEvent`, nicht das native `Event`-Objekt des Browsers.

---

## ‚ö†Ô∏è Hinweis: Event-Pooling (fr√ºher)

Fr√ºher wurden `SyntheticEvent`-Objekte **recycelt** (Event Pooling), was bedeutete:  
Zugriff auf das Event nach dem Event-Handler war **nicht mehr m√∂glich**.  
**Seit React 17+ ist Pooling deaktiviert.**

---

## üìù Zusammenfassung

Ein `SyntheticEvent` ist Reacts **einheitliche Event-API**,  
die unabh√§ngig vom Browser funktioniert und dieselbe Oberfl√§che wie das native DOM-Event bietet.  
Du kannst es wie gewohnt verwenden (`e.preventDefault()`, `e.target.value`, etc.).

---

## üîó Quellen

- [React Docs ‚Äì SyntheticEvent](https://react.dev/reference/react-dom/SyntheticEvent)  
- [MDN: DOM Events √úbersicht](https://developer.mozilla.org/de/docs/Web/Events)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

69. ### <a name="69"></a> Was ist props.children?

# Was ist `props.children` in React?

**`props.children`** ist eine spezielle React-Prop,  
die automatisch alle **verschachtelten Elemente (Child-Komponenten oder JSX-Inhalte)** enth√§lt,  
die **innerhalb einer Komponente √ºbergeben** werden.

---

## üéØ Wozu wird `props.children` verwendet?

- ‚úÖ Um **dynamisch Inhalte zu rendern**, die von au√üen √ºbergeben werden  
- ‚úÖ Um **Wrapper-Komponenten** (z.‚ÄØB. Layouts, Container) zu erstellen  
- ‚úÖ F√ºr **wiederverwendbare UI-Strukturen**

---

## üí° Beispiel

```jsx
function Card(props) {
  return <div className="card">{props.children}</div>;
}

function App() {
  return (
    <Card>
      <h2>Titel</h2>
      <p>Das ist der Inhalt der Card.</p>
    </Card>
  );
}
```

‚û°Ô∏è Die `Card`-Komponente erh√§lt:

```jsx
<h2>...</h2>
<p>...</p>
```

als `props.children` und rendert sie **im Inneren**.

---

## üì¶ Typen von `props.children`

- Kann ein **Element**, ein **Text**, ein **Array**, `null`, `undefined` oder ein **Fragment** sein
- Du kannst `children` auch **pr√ºfen oder filtern**, z.‚ÄØB. mit `React.Children`

---

## üß™ Beispiel mit mehreren Kindern

```jsx
function Wrapper({ children }) {
  return (
    <section>
      {React.Children.map(children, (child, index) => (
        <div key={index}>{child}</div>
      ))}
    </section>
  );
}
```

‚û°Ô∏è So kannst du **alle `children` gezielt verarbeiten**.

---

## üìù Zusammenfassung

- `props.children` enth√§lt **alle JSX-Inhalte**, die **zwischen den Tags** einer Komponente √ºbergeben werden  
- Es macht Komponenten **flexibel und wiederverwendbar**
- Typisch bei Layout-Komponenten, Dialogen, Containern

---

## üîó Quellen

- [React Docs ‚Äì Children](https://react.dev/learn/passing-props-to-a-component#using-the-children-prop)  
- [React.Children API ‚Äì React Docs](https://react.dev/reference/react/Children)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

70. ### <a name="70"></a> Was bedeutet ‚Äûcontrolled component‚Äú und ‚Äûuncontrolled component‚Äú bei Formularen?

# Was bedeutet ‚Äûcontrolled component‚Äú und ‚Äûuncontrolled component‚Äú bei Formularen in React?

In React beschreibt man Formular-Elemente wie `<input>`, `<textarea>` oder `<select>` als  
**controlled** oder **uncontrolled**, je nachdem, **wie ihr Wert verwaltet wird**.

---

## ‚úÖ Controlled Component

Ein **controlled component** wird **vollst√§ndig durch React kontrolliert** ‚Äì  
der Wert kommt aus dem **State** und wird √ºber `onChange` aktualisiert.

### Eigenschaften:

- Wert liegt im React-State
- √Ñnderungen erfolgen √ºber `setState` / `useState`
- Ideal f√ºr Validierung, dynamische Formulare, zentrale Kontrolle

### Beispiel:

```jsx
function Form() {
  const [name, setName] = useState('');

  return (
    <input 
      value={name}
      onChange={(e) => setName(e.target.value)}
    />
  );
}
```

‚û°Ô∏è Das Eingabefeld zeigt **immer den aktuellen State-Wert**.

---

## ‚ùå Uncontrolled Component

Ein **uncontrolled component** verwaltet seinen Wert **intern im DOM**,  
React **greift nur √ºber ein Ref** darauf zu ‚Äì z.‚ÄØB. beim Absenden des Formulars.

### Eigenschaften:

- Kein React-State f√ºr den Wert
- Zugriff √ºber `ref`
- Einfach, aber schwerer zu validieren

### Beispiel:

```jsx
function Form() {
  const inputRef = useRef();

  const handleSubmit = (e) => {
    e.preventDefault();
    alert(inputRef.current.value);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input ref={inputRef} />
      <button type="submit">Absenden</button>
    </form>
  );
}
```

‚û°Ô∏è Der Wert wird **nicht in React gespeichert**, sondern **aus dem DOM gelesen**.

---

## üîÅ Vergleich

| Merkmal              | Controlled                   | Uncontrolled                    |
|----------------------|------------------------------|----------------------------------|
| Datenquelle          | React-State (`useState`)     | DOM (intern)                     |
| Zugriff              | `value` + `onChange`         | `ref.current.value`              |
| Validierung          | Einfach                      | Komplizierter                    |
| Flexibilit√§t         | Hoch                         | Gering                           |
| Initialwert          | via State                    | via `defaultValue`               |

---

## üìù Zusammenfassung

- **Controlled Components**: React verwaltet den Formularwert ‚Üí vollst√§ndig kontrollierbar
- **Uncontrolled Components**: Der Browser verwaltet den Wert ‚Üí Zugriff nur √ºber Ref
- Controlled ist der **empfohlene Standard**, besonders bei komplexen Formularen

---

## üîó Quellen

- [Controlled Components ‚Äì React Docs](https://react.dev/learn/sharing-state-between-components#controlled-and-uncontrolled-components)  
- [Formulare in React ‚Äì MDN](https://developer.mozilla.org/de/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_forms)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

71. ### <a name="71"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

72. ### <a name="72"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

73. ### <a name="73"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

74. ### <a name="74"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

75. ### <a name="75"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

76. ### <a name="76"></a> Wie f√ºhrt man API-Aufrufe mit Fetch oder Axios durch?

# Wie f√ºhrt man API-Aufrufe mit `fetch` oder `axios` in React durch?

In React kannst du API-Anfragen auf zwei g√§ngige Arten durchf√ºhren:

1. Mit dem **integrierten `fetch`-API** (nativ in JavaScript)
2. Mit der **Axios-Bibliothek** (komfortabler, aber extern)

---

## ‚úÖ 1. API-Aufruf mit `fetch`

```jsx
import { useEffect, useState } from 'react';

function UserList() {
  const [users, setUsers] = useState([]);
  const [error, setError] = useState(null);

  useEffect(() => {
    fetch('https://jsonplaceholder.typicode.com/users')
      .then((res) => {
        if (!res.ok) throw new Error('Fehler beim Laden');
        return res.json();
      })
      .then((data) => setUsers(data))
      .catch((err) => setError(err.message));
  }, []);

  if (error) return <p>Fehler: {error}</p>;
  return (
    <ul>
      {users.map((u) => (
        <li key={u.id}>{u.name}</li>
      ))}
    </ul>
  );
}
```

---

## ‚úÖ 2. API-Aufruf mit `axios`

### Installation:

```bash
npm install axios
```

### Verwendung:

```jsx
import axios from 'axios';
import { useEffect, useState } from 'react';

function PostList() {
  const [posts, setPosts] = useState([]);
  const [error, setError] = useState(null);

  useEffect(() => {
    axios
      .get('https://jsonplaceholder.typicode.com/posts')
      .then((res) => setPosts(res.data))
      .catch((err) => setError(err.message));
  }, []);

  if (error) return <p>Fehler: {error}</p>;
  return (
    <ul>
      {posts.map((p) => (
        <li key={p.id}>{p.title}</li>
      ))}
    </ul>
  );
}
```

---

## üîÅ Vergleich: `fetch` vs. `axios`

| Merkmal             | `fetch` (nativ)              | `axios` (Bibliothek)             |
|---------------------|------------------------------|----------------------------------|
| Integriert in JS?   | ‚úÖ Ja                         | ‚ùå Nein (muss installiert werden) |
| JSON automatisch?   | ‚ùå Nein (manuell: `.json()`) | ‚úÖ Ja (direkt `res.data`)         |
| Fehlerbehandlung    | Manuell mit `res.ok` pr√ºfen  | Automatisch bei HTTP-Fehler      |
| Unterst√ºtzt Abbrechen | ‚ùå Nur mit AbortController | ‚úÖ Ja                             |

---

## üìù Zusammenfassung

- Mit `fetch` und `axios` kannst du in `useEffect` **API-Daten laden**
- `fetch`: nativ, minimalistisch  
- `axios`: komfortabler, bessere Fehlerbehandlung  
- Immer Fehler abfangen (`.catch`) und Zustand (`loading`, `error`, `data`) verwalten

---

## üîó Quellen

- [fetch ‚Äì MDN Web Docs](https://developer.mozilla.org/de/docs/Web/API/Fetch_API)
- [Axios ‚Äì GitHub Docs](https://axios-http.com/docs/intro)
- [Daten in React laden ‚Äì React Docs](https://react.dev/learn/you-might-not-need-an-effect#fetching-data)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

77. ### <a name="77"></a> Wie verwaltet man Lade-, Fehler- und Erfolgsstatus?

# Wie verwaltet man Lade-, Fehler- und Erfolgsstatus in React?

Beim **Abrufen von Daten (API)** ist es wichtig, den **Status** der Anfrage zu verwalten:

1. üîÑ **Ladezustand** (`isLoading`)
2. ‚úÖ **Erfolgszustand** (Daten verf√ºgbar)
3. ‚ùå **Fehlerzustand** (Fehler beim Laden)

Diese drei Zust√§nde werden meist mit **`useState` und `useEffect`** verwaltet.

---

## üí° Beispiel mit `fetch`

```jsx
import { useState, useEffect } from 'react';

function UserList() {
  const [users, setUsers] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    fetch('https://jsonplaceholder.typicode.com/users')
      .then((res) => {
        if (!res.ok) throw new Error('Fehler beim Laden');
        return res.json();
      })
      .then((data) => {
        setUsers(data);
        setError(null);
      })
      .catch((err) => setError(err.message))
      .finally(() => setIsLoading(false));
  }, []);

  if (isLoading) return <p>‚è≥ Lade Daten...</p>;
  if (error) return <p>‚ùå Fehler: {error}</p>;

  return (
    <ul>
      {users.map((user) => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

---

## ‚úÖ Statusverwaltung im √úberblick

| Zustand     | Variable     | Bedeutung                                 |
|-------------|--------------|--------------------------------------------|
| Ladezustand | `isLoading`  | Wird `true` beim Start der Anfrage         |
| Erfolgsdaten| `data`, `users`, etc. | Wird nach erfolgreichem Laden gesetzt |
| Fehlerzustand| `error`     | Wird gesetzt, wenn `.catch()` ausgel√∂st wird |

---

## üîÑ Alternativen

- Eigener **Custom Hook** (`useFetch`, `useApi`)
- **State Machine** (z.‚ÄØB. mit `xstate`)
- Zustand mit `useReducer` verwalten, wenn komplexer

---

## üìù Zusammenfassung

- Nutze `useState` f√ºr `isLoading`, `error` und `data`
- Nutze `useEffect`, um Daten zu laden
- Zeige je nach Zustand: Ladeanzeige, Fehlernachricht oder Daten

---

## üîó Quellen

- [React: API-Daten laden ‚Äì react.dev](https://react.dev/learn/you-might-not-need-an-effect#fetching-data)  
- [fetch API ‚Äì MDN Docs](https://developer.mozilla.org/de/docs/Web/API/Fetch_API)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

78. ### <a name="78"></a> Wie funktioniert WebSocket mit React?

# Wie funktioniert WebSocket mit React?

**WebSockets** erm√∂glichen eine **bidirektionale, permanente Verbindung** zwischen Client (Browser) und Server.  
In React kannst du damit **Echtzeit-Daten** verarbeiten ‚Äì z.‚ÄØB. f√ºr Chats, Benachrichtigungen oder Live-Dashboards.

---

## üîÑ Grundprinzip WebSocket

1. Verbindung zum Server aufbauen
2. Nachrichten senden & empfangen
3. Verbindung schlie√üen (bei Unmount oder Fehler)

---

## üí° Beispiel: WebSocket in React verwenden

```jsx
import { useEffect, useRef, useState } from 'react';

function WebSocketComponent() {
  const socketRef = useRef(null);
  const [messages, setMessages] = useState([]);

  useEffect(() => {
    // 1. Verbindung aufbauen
    socketRef.current = new WebSocket('wss://example.com/socket');

    // 2. Nachricht empfangen
    socketRef.current.onmessage = (event) => {
      setMessages((prev) => [...prev, event.data]);
    };

    // 3. Fehlerbehandlung
    socketRef.current.onerror = (err) => {
      console.error('WebSocket-Fehler:', err);
    };

    // 4. Aufr√§umen beim Unmount
    return () => {
      socketRef.current.close();
    };
  }, []);

  // Nachricht senden (z.‚ÄØB. beim Button-Klick)
  const sendMessage = () => {
    if (socketRef.current.readyState === WebSocket.OPEN) {
      socketRef.current.send('Hallo vom Client!');
    }
  };

  return (
    <div>
      <h3>Empfangene Nachrichten:</h3>
      <ul>
        {messages.map((msg, i) => (
          <li key={i}>{msg}</li>
        ))}
      </ul>
      <button onClick={sendMessage}>Nachricht senden</button>
    </div>
  );
}
```

---

## üîÅ Tipps f√ºr den produktiven Einsatz

- Nutze `useRef`, damit WebSocket-Verbindung **nicht bei jedem Render neu aufgebaut** wird  
- Pr√ºfe `socket.readyState`, bevor du Nachrichten sendest  
- Verwende ggf. **Reconnect-Strategien**, falls Verbindung abbricht  
- F√ºr gro√üe Projekte: verwalte WebSocket √ºber `Context` oder `Redux`

---

## üìù Zusammenfassung

- WebSocket bietet eine **dauerhafte Verbindung** zwischen React-Client und Server  
- Ideal f√ºr **Live-Kommunikation** (Chat, Echtzeitdaten)  
- In React: mit `useEffect`, `useRef` und `setState` kombinieren  
- Nicht vergessen: **Verbindung schlie√üen** bei Unmount

---

## üîó Quellen

- [MDN: WebSocket API](https://developer.mozilla.org/de/docs/Web/API/WebSocket)  
- [React + WebSocket Guide ‚Äì LogRocket](https://blog.logrocket.com/using-websocket-react-guide/)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

79. ### <a name="79"></a> Wie kann man Daten zwischen Komponenten weitergeben?

# Wie kann man Daten zwischen Komponenten weitergeben?

In React gibt es mehrere Wege, **Daten zwischen Komponenten** auszutauschen.  
Welcher Weg sinnvoll ist, h√§ngt davon ab, **wie die Komponenten zueinander stehen**.

---

## 1Ô∏è‚É£ Parent ‚Üí Child: via **Props**

Der klassische und einfachste Weg:  
Elternkomponente √ºbergibt Daten an Kindkomponente als `props`.

```jsx
function Child({ username }) {
  return <p>Hallo, {username}!</p>;
}

function Parent() {
  return <Child username="Sergii" />;
}
```

‚û°Ô∏è Einfache, **unidirektionale Datenweitergabe**.

---

## 2Ô∏è‚É£ Child ‚Üí Parent: via **Callback-Funktion als Prop**

Kindkomponente ruft eine Funktion auf, die der Elternkomponente geh√∂rt.

```jsx
function Child({ onNameChange }) {
  return <input onChange={(e) => onNameChange(e.target.value)} />;
}

function Parent() {
  const [name, setName] = useState('');
  return (
    <>
      <Child onNameChange={setName} />
      <p>Name: {name}</p>
    </>
  );
}
```

‚û°Ô∏è **"Lifting State Up"**: Eltern verwalten den Zustand.

---

## 3Ô∏è‚É£ Geschwister-Komponenten (Sibling ‚Üí Sibling): via **gemeinsamen Eltern-State**

Beide Kinder greifen auf den **Zustand in der Elternkomponente** zu.

```jsx
function Input({ onChange }) {
  return <input onChange={(e) => onChange(e.target.value)} />;
}

function Display({ value }) {
  return <p>Wert: {value}</p>;
}

function Parent() {
  const [text, setText] = useState('');
  return (
    <>
      <Input onChange={setText} />
      <Display value={text} />
    </>
  );
}
```

---

## 4Ô∏è‚É£ Tief verschachtelte Komponenten: via **Context API**

Nutze `createContext`, `Provider` und `useContext`,  
um Daten **global im Baum** verf√ºgbar zu machen.

```jsx
const ThemeContext = createContext();

function App() {
  return (
    <ThemeContext.Provider value="dark">
      <DeepChild />
    </ThemeContext.Provider>
  );
}

function DeepChild() {
  const theme = useContext(ThemeContext);
  return <p>Aktuelles Theme: {theme}</p>;
}
```

---

## 5Ô∏è‚É£ App-weite Zust√§nde: via **State-Management** (z.‚ÄØB. Redux, Zustand)

F√ºr sehr gro√üe Apps oder komplexe Interaktionen.

```jsx
// Redux: useSelector, useDispatch
// Zustand: useStore()
// Recoil, Jotai, MobX = Alternativen
```

---

## üìù Zusammenfassung

| Beziehung          | L√∂sung                         |
|--------------------|---------------------------------|
| Eltern ‚Üí Kind      | Props                          |
| Kind ‚Üí Eltern      | Callback-Funktion als Prop     |
| Geschwister        | Gemeinsamer Eltern-State       |
| Tief verschachtelt | Context API                    |
| Global             | State-Management-Library       |

---

## üîó Quellen

- [React ‚Äì Props](https://react.dev/learn/passing-props-to-a-component)  
- [React ‚Äì State Heben](https://react.dev/learn/sharing-state-between-components)  
- [React ‚Äì Context API](https://react.dev/learn/passing-data-deeply-with-context)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

80. ### <a name="80"></a> Wie macht man einen Datenabruf nur beim ersten Rendern?

# Wie macht man einen Datenabruf nur beim ersten Rendern in React?

Um eine API-Anfrage **nur einmal beim ersten Laden der Komponente** durchzuf√ºhren,  
nutzt man den Hook **`useEffect` mit leerem Abh√§ngigkeits-Array `[]`**.

---

## üí° Beispiel: API-Fetch beim Mount

```jsx
import { useEffect, useState } from 'react';

function UserList() {
  const [users, setUsers] = useState([]);

  useEffect(() => {
    fetch('https://jsonplaceholder.typicode.com/users')
      .then((res) => res.json())
      .then((data) => setUsers(data));
  }, []); // ‚Üê nur beim ersten Rendern!

  return (
    <ul>
      {users.map((u) => (
        <li key={u.id}>{u.name}</li>
      ))}
    </ul>
  );
}
```

---

## üìå Erkl√§rung

- Das leere Array `[]` bedeutet:  
  **Dieser Effekt l√§uft nur einmal ‚Äì beim ersten Rendern (Mount)**.
- Keine erneute Ausf√ºhrung bei Re-Renders oder State-√Ñnderungen

---

## üîÅ Alternative: Async-Funktion in `useEffect`

Da `useEffect` keine `async`-Funktion direkt erlaubt:

```jsx
useEffect(() => {
  async function fetchData() {
    const res = await fetch('...');
    const data = await res.json();
    setUsers(data);
  }

  fetchData();
}, []);
```

---

## üìù Zusammenfassung

- Verwende `useEffect(() => { ... }, [])`, um einen Effekt **nur einmal beim ersten Rendern** auszuf√ºhren  
- Ideal f√ºr **API-Anfragen, Initialdaten oder Setup-Logik**  
- Async-Aufrufe m√ºssen in eine **innere Funktion** ausgelagert werden

---

## üîó Quellen

- [React Docs ‚Äì useEffect](https://react.dev/reference/react/useEffect)  
- [Daten beim Mount laden ‚Äì React Patterns](https://reactpatterns.com/#fetch-on-mount)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

81. ### <a name="81"></a> Was ist das Problem bei ‚Äûstale closures‚Äú mit Hooks?

# Was ist das Problem bei ‚Äûstale closures‚Äú mit Hooks?

Ein **‚Äûstale closure‚Äú** (veraltete Funktionseinbettung) tritt auf,  
wenn eine **Funktion in einem Hook (z.‚ÄØB. `useEffect`, `setInterval`, `addEventListener`)**  
auf **einen veralteten Wert aus dem vorherigen Render** zugreift.

---

## üì¶ Was ist eine Closure?

Eine **Closure** ist eine Funktion, die Zugriff auf Variablen aus dem **Umgebungskontext** (z.‚ÄØB. vorherigem Render) hat.

Wenn ein Hook eine Funktion verwendet, ‚Äûmerkt‚Äú sich diese Funktion **den Zustand des Wertes zu diesem Zeitpunkt**.

---

## üí° Beispiel: Problem mit `setInterval`

```jsx
function Timer() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const id = setInterval(() => {
      setCount(count + 1); // ‚ùå count ist immer 0!
    }, 1000);

    return () => clearInterval(id);
  }, []);
  
  return <p>Z√§hler: {count}</p>;
}
```

### üî¥ Problem:

- Die `count`-Variable ist **eingefroren (stale)** bei `0`, weil `useEffect` nur **einmal** ausgef√ºhrt wird
- Der Callback in `setInterval` ‚Äûsieht‚Äú nie die neuen `count`-Werte

---

## ‚úÖ L√∂sung 1: Funktionales `setState`

```jsx
setCount((prev) => prev + 1);
```

```jsx
useEffect(() => {
  const id = setInterval(() => {
    setCount((prev) => prev + 1); // ‚úÖ aktueller Wert
  }, 1000);

  return () => clearInterval(id);
}, []);
```

‚û°Ô∏è `prev` wird **zur aktuellen Version** von `count`, unabh√§ngig vom Closure

---

## ‚úÖ L√∂sung 2: useRef f√ºr aktuelle Werte

```jsx
const countRef = useRef(count);

useEffect(() => {
  countRef.current = count;
}, [count]);

useEffect(() => {
  const id = setInterval(() => {
    console.log(countRef.current); // immer aktuell
  }, 1000);

  return () => clearInterval(id);
}, []);
```

‚û°Ô∏è `useRef` bleibt **zwischen Renders gleich** und kann **aktualisiert** werden.

---

## üìù Zusammenfassung

- Ein **stale closure** tritt auf, wenn eine Funktion auf **veraltete Werte** zugreift  
- Typisch bei: `setInterval`, `useEffect`, Event-Handlern  
- L√∂sungen:
  - ‚úÖ Funktionales `setState`
  - ‚úÖ `useRef` zur Speicherung aktueller Werte

---

## üîó Quellen

- [React Docs ‚Äì useEffect Gotchas](https://react.dev/learn/synchronizing-with-effects#you-might-see-stale-values-inside-an-effect)  
- [Dan Abramov ‚Äì A Complete Guide to useEffect](https://overreacted.io/a-complete-guide-to-useeffect/)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

82. ### <a name="82"></a> Wie funktioniert die Fehlerbehandlung mit try/catch in React?

# Wie funktioniert die Fehlerbehandlung mit `try/catch` in React?

In React wird `try/catch` verwendet, um **synchronen und asynchronen Code** innerhalb von Funktionen  
(z.‚ÄØB. Event-Handlern, `async`-Funktionen) **gezielt abzusichern**.

‚ö†Ô∏è `try/catch` funktioniert **nicht f√ºr Renderfehler** in JSX ‚Äì daf√ºr ben√∂tigt man **Error Boundaries**.

---

## ‚úÖ Verwendung in Event-Handlern

```jsx
function Button() {
  const handleClick = () => {
    try {
      // synchroner Fehler
      throw new Error('Etwas ist schiefgelaufen!');
    } catch (err) {
      console.error('Fehler:', err.message);
    }
  };

  return <button onClick={handleClick}>Klick mich</button>;
}
```

---

## ‚úÖ Verwendung in `async`-Funktionen (z.‚ÄØB. Daten laden)

```jsx
function DataLoader() {
  const [data, setData] = useState(null);
  const [error, setError] = useState(null);

  useEffect(() => {
    async function fetchData() {
      try {
        const res = await fetch('https://api.example.com/data');
        if (!res.ok) throw new Error('Fehler beim Abrufen');
        const json = await res.json();
        setData(json);
      } catch (err) {
        setError(err.message);
      }
    }

    fetchData();
  }, []);

  if (error) return <p>‚ùå Fehler: {error}</p>;
  if (!data) return <p>‚è≥ L√§dt...</p>;
  return <pre>{JSON.stringify(data, null, 2)}</pre>;
}
```

---

## üî¥ Kein `try/catch` f√ºr Renderfehler

```jsx
function App() {
  try {
    return <ProblematicComponent />; // ‚ùå try/catch greift hier nicht
  } catch (e) {
    return <p>Fehler!</p>; // ‚ùå wird nicht erreicht
  }
}
```

‚û°Ô∏è React rendert **asynchron**, deshalb **fangen Error Boundaries** solche Fehler ab, nicht `try/catch`.

---

## üìù Zusammenfassung

| Fehlerquelle      | `try/catch` geeignet? | Alternative                     |
|------------------|------------------------|---------------------------------|
| Event-Handler     | ‚úÖ Ja                  | ‚Äî                               |
| `async`-Funktionen| ‚úÖ Ja                  | ‚Äî                               |
| Renderzeit (JSX)  | ‚ùå Nein                | ‚ùó `ErrorBoundary` verwenden     |

---

## üîó Quellen

- [React Docs ‚Äì Fehlerbehandlung](https://react.dev/learn/managing-errors)  
- [MDN ‚Äì try...catch](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Statements/try...catch)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

83. ### <a name="83"></a> Wie kann man ein Mock-API oder Mock Server verwenden?

# Wie kann man ein Mock-API oder Mock Server in React verwenden?

Ein **Mock-API** oder **Mock-Server** simuliert eine echte Backend-API,  
um die Entwicklung und das Testen von Frontend-Komponenten zu erm√∂glichen ‚Äì  
ohne auf ein echtes Backend warten zu m√ºssen.

---

## üéØ Vorteile

- Unabh√§ngige Entwicklung von Frontend und Backend
- Offline arbeiten m√∂glich
- Schnelleres Testen von UI-Logik
- Kontrolle √ºber Antwortdaten, Fehler, Ladezeiten

---

## ‚úÖ M√∂glichkeiten f√ºr Mocking

### 1Ô∏è‚É£ **JSON Server (lokal)**

Schneller REST-API-Mock √ºber eine JSON-Datei.

#### üîß Installation:

```bash
npm install -g json-server
```

#### üìÅ `db.json`

```json
{
  "users": [
    { "id": 1, "name": "Alice" },
    { "id": 2, "name": "Bob" }
  ]
}
```

#### üöÄ Starten:

```bash
json-server --watch db.json --port 4000
```

‚û°Ô∏è API verf√ºgbar unter `http://localhost:4000/users`

---

### 2Ô∏è‚É£ **Mock Service Worker (MSW)** ‚Äì empfohlen f√ºr komplexe Szenarien

Interceptet echte Requests auf Netzwerkebene ‚Üí realistisch & flexibel.

#### üîß Installation:

```bash
npm install msw --save-dev
```

#### üìÅ Beispiel-Handler:

```js
// src/mocks/handlers.js
import { rest } from 'msw';

export const handlers = [
  rest.get('/api/users', (req, res, ctx) => {
    return res(
      ctx.status(200),
      ctx.json([{ id: 1, name: 'Sergii' }, { id: 2, name: 'Anna' }])
    );
  }),
];
```

#### üß© Setup:

```js
// src/mocks/browser.js
import { setupWorker } from 'msw';
import { handlers } from './handlers';

export const worker = setupWorker(...handlers);
```

```js
// index.js
if (process.env.NODE_ENV === 'development') {
  const { worker } = require('./mocks/browser');
  worker.start();
}
```

---

### 3Ô∏è‚É£ **Online-Tools / √∂ffentliche APIs**

- [https://reqres.in](https://reqres.in)
- [https://jsonplaceholder.typicode.com](https://jsonplaceholder.typicode.com)
- [https://mockapi.io](https://mockapi.io)

‚û°Ô∏è Gut f√ºr schnelles Testen ohne lokale Einrichtung

---

## üìù Zusammenfassung

| Methode         | Geeignet f√ºr                  | Vorteile                    |
|------------------|-------------------------------|-----------------------------|
| `json-server`    | Lokale Fake-REST-API          | Schnell, einfach            |
| `msw`            | Realistisches Mocking (XHR)   | Sehr m√§chtig, intercepts    |
| `mockapi.io`     | Online-Testing                | Kein Setup n√∂tig            |

---

## üîó Quellen

- [Mock Service Worker ‚Äì offizielle Website](https://mswjs.io)  
- [JSON Server ‚Äì GitHub](https://github.com/typicode/json-server)  
- [jsonplaceholder ‚Äì Fake API](https://jsonplaceholder.typicode.com)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

84. ### <a name="84"></a> Wie funktioniert Suspense f√ºr Datenabfragen?

# Wie funktioniert `React.Suspense` f√ºr Datenabfragen?

`React.Suspense` erlaubt es, **asynchrone Datenladevorg√§nge** elegant zu behandeln,  
indem eine **Fallback-UI** (z.‚ÄØB. Ladeanzeige) angezeigt wird,  
solange **komponentenabh√§ngige Daten noch nicht verf√ºgbar** sind.

---

## ‚ö†Ô∏è Wichtig:

- Suspense f√ºr Daten funktioniert **nur mit speziellen Data Fetching Libraries**, z.‚ÄØB.:
  - **React Query (TanStack Query)**
  - **Relay**
  - oder man schreibt einen eigenen **Wrapper mit `Promise`-suspending**

---

## ‚úÖ Beispiel mit React Query (empfohlener Weg)

### üîß Setup:

```bash
npm install @tanstack/react-query
```

### üì¶ App mit QueryClient + Suspense:

```jsx
import {
  QueryClient,
  QueryClientProvider,
  useQuery,
} from '@tanstack/react-query';
import { Suspense } from 'react';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      suspense: true,
    },
  },
});

function Users() {
  const { data } = useQuery({
    queryKey: ['users'],
    queryFn: () =>
      fetch('https://jsonplaceholder.typicode.com/users').then((res) =>
        res.json()
      ),
  });

  return (
    <ul>
      {data.map((u) => (
        <li key={u.id}>{u.name}</li>
      ))}
    </ul>
  );
}

export default function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <Suspense fallback={<p>‚è≥ L√§dt Benutzer...</p>}>
        <Users />
      </Suspense>
    </QueryClientProvider>
  );
}
```

---

## üß† Was passiert hier?

- **`Suspense`** zeigt das `fallback`, solange `Users` noch l√§dt.
- Sobald `useQuery` Daten geladen hat, wird `fallback` ersetzt.
- Vorteil: Kein explizites `isLoading` oder `error` n√∂tig ‚Üí cleaner Code

---

## üîÅ Alternative: Eigene Datenquelle mit `suspense`-like Verhalten

```jsx
function wrapPromise(promise) {
  let status = 'pending';
  let result;
  const suspender = promise.then(
    (r) => {
      status = 'success';
      result = r;
    },
    (e) => {
      status = 'error';
      result = e;
    }
  );

  return {
    read() {
      if (status === 'pending') throw suspender;
      if (status === 'error') throw result;
      return result;
    },
  };
}
```

‚û°Ô∏è Diese Technik ist eher experimentell.

---

## üìù Zusammenfassung

- `Suspense` kann Ladezust√§nde abfangen und Fallback anzeigen
- F√ºr Daten: funktioniert nur mit Libraries wie **React Query** oder **Relay**
- Vorteil: **automatisches Laden + saubere Trennung von UI & Logik**

---

## üîó Quellen

- [React Suspense f√ºr Daten ‚Äì React Docs](https://react.dev/reference/react/Suspense)  
- [TanStack Query mit Suspense](https://tanstack.com/query/latest/docs/react/guides/suspense)  
- [MDN: Promises](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Promise)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

85. ### <a name="85"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

86. ### <a name="86"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

87. ### <a name="87"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

88. ### <a name="88"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

89. ### <a name="89"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

90. ### <a name="90"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

91. ### <a name="91"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

92. ### <a name="92"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

93. ### <a name="93"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

94. ### <a name="94"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

95. ### <a name="95"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

96. ### <a name="96"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

97. ### <a name="97"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

98. ### <a name="98"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

99. ### <a name="99"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

100. ### <a name="100"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**    

101. ### <a name="101"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

102. ### <a name="102"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

103. ### <a name="103"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

104. ### <a name="104"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

105. ### <a name="105"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

106. ### <a name="106"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

107. ### <a name="107"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

108. ### <a name="108"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

109. ### <a name="109"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

110. ### <a name="110"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

111. ### <a name="111"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

112. ### <a name="112"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

113. ### <a name="113"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

114. ### <a name="114"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

115. ### <a name="115"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

116. ### <a name="116"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

117. ### <a name="117"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

118. ### <a name="118"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

119. ### <a name="119"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

120. ### <a name="120"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

121. ### <a name="121"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

122. ### <a name="122"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

123. ### <a name="123"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

124. ### <a name="124"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

125. ### <a name="125"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

126. ### <a name="126"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

127. ### <a name="127"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

128. ### <a name="128"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

129. ### <a name="129"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

130. ### <a name="130"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

131. ### <a name="131"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

132. ### <a name="132"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

133. ### <a name="133"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

134. ### <a name="134"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

135. ### <a name="135"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

136. ### <a name="136"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

137. ### <a name="137"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

138. ### <a name="138"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

139. ### <a name="139"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

140. ### <a name="140"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

141. ### <a name="141"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

142. ### <a name="142"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

143. ### <a name="143"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

144. ### <a name="144"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

145. ### <a name="145"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

146. ### <a name="146"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

147. ### <a name="147"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

148. ### <a name="148"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

149. ### <a name="149"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

150. ### <a name="150"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

151. ### <a name="151"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

152. ### <a name="152"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

153. ### <a name="153"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

154. ### <a name="154"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

155. ### <a name="155"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

156. ### <a name="156"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

157. ### <a name="157"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

158. ### <a name="158"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

159. ### <a name="159"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

160. ### <a name="160"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

161. ### <a name="161"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

162. ### <a name="162"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

163. ### <a name="163"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

164. ### <a name="164"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

165. ### <a name="165"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

166. ### <a name="166"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

167. ### <a name="167"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

168. ### <a name="168"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

169. ### <a name="169"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

170. ### <a name="170"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

171. ### <a name="171"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

172. ### <a name="172"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

173. ### <a name="173"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

174. ### <a name="174"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

175. ### <a name="175"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

176. ### <a name="176"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

177. ### <a name="177"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

178. ### <a name="178"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

179. ### <a name="179"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

180. ### <a name="180"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

181. ### <a name="181"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

182. ### <a name="182"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

183. ### <a name="183"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

184. ### <a name="184"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

185. ### <a name="185"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

186. ### <a name="186"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

187. ### <a name="187"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

188. ### <a name="188"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

189. ### <a name="189"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

190. ### <a name="190"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

191. ### <a name="191"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

192. ### <a name="192"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

193. ### <a name="193"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

194. ### <a name="194"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

195. ### <a name="195"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

196. ### <a name="196"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

197. ### <a name="197"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

198. ### <a name="198"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

199. ### <a name="199"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

200. ### <a name="200"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**      
