<a name="top"></a>

[ĞĞ° Ğ³Ğ»Ğ°Ğ²Ğ½ÑƒÑ](../../README.md)

[ĞŸĞµÑ€ĞµĞ¹Ñ‚Ğ¸ Ğº Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑĞ°Ğ¼](#questions)

| â„–. | Ğ’Ğ¾Ğ¿Ñ€Ğ¾Ñ |
| --- | --------- |
|   | ReactJS Grundlagen |
|1 | [Was ist React und welche Probleme lÃ¶st es?](#1) |
|2 | [Was ist JSX und warum wird es verwendet?](#2) |
|3 | [Was ist Virtual DOM und wie funktioniert es?](#3) |
|4 | [Was ist der Unterschied zwischen React und ReactDOM?](#4) |
|5 | [Warum importieren wir React, auch wenn es scheinbar nicht benutzt wird?](#5) |
|6 | [Was ist ein React Fragment und warum ist es nÃ¼tzlich?](#6) |
|7 | [Was ist der Unterschied zwischen einem Element, einer Komponente und einer Instanz?](#7) |
|8 | [Was ist das Fiber-Architekturmodell in React?](#8) |
|9 | [Was bedeutet â€Batchingâ€œ in React?](#9) |
|10 | [Was ist die Rolle des key in React-Listen?](#10) |
|11 | [Wie funktioniert die Wiederverwendung von Komponenten?](#11) |
|12 | [](#12) |
|13 | [](#13) |
|14 | [](#14) |
|15 | [](#15) |
|16 | [](#16) |
|17 | [](#17) |
|18 | [](#18) |
|19 | [](#19) |
|20 | [](#20) |
|   | Komponenten, Props & State |
|21 | [Was sind Props und wozu werden sie verwendet?](#21) |
|22 | [Was ist der Unterschied zwischen Props und State?](#22) |
|23 | [Warum sind Props nur lesbar?](#23) |
|24 | [Wie funktioniert der unidirektionale Datenfluss in React?](#24) |
|25 | [Was ist State in Klassen- und Funktionskomponenten?](#25) |
|26 | [Wie funktioniert setState?](#26) |
|27 | [Was ist der Unterschied zwischen kontrollierten und unkontrollierten Komponenten?](#27) |
|28 | [Was sind Default Props und PropTypes?](#28) |
|29 | [Was ist React.memo und wofÃ¼r wird es verwendet?](#29) |
|30 | [Was ist PureComponent und wie unterscheidet es sich von Component?](#30) |
|31 | [Wann sollte shouldComponentUpdate verwendet werden?](#31) |
|32 | [Was ist ein ref und wann wird er eingesetzt?](#32) |
|33 | [Was bedeutet â€Lifting State Upâ€œ?](#33) |
|34 | [](#34) |
|35 | [](#35) |
|36 | [](#36) |
|37 | [](#37) |
|38 | [](#38) |
|39 | [](#39) |
|40 | [](#40) |
|   | Lebenszyklus von Komponenten |
|41 | [Was sind die Phasen des Komponentenlebenszyklus?](#41) |
|42 | [Welche Lifecycle-Methoden gibt es in Klassenkomponenten?](#42) |
|43 | [Welche Lifecycle-Methoden sind veraltet?](#43) |
|44 | [Wie kann man Lifecycle-Methoden mit Hooks ersetzen?](#44) |
|45 | [Was ist componentDidMount und was ist das Ã„quivalent mit Hooks?](#45) |
|46 | [](#46) |
|47 | [](#47) |
|48 | [](#48) |
|49 | [](#49) |
|50 | [](#50) |
|   | Hooks |
|51 | [Was sind Hooks in React?](#51) |
|52 | [Wie funktionieren useState und useEffect?](#52) |
|53 | [Was macht useContext?](#53) |
|54 | [Was ist useRef und wann wird es verwendet?](#54) |
|55 | [Was ist useCallback, useMemo, useReducer?](#55) |
|56 | [Wie schreibt man einen benutzerdefinierten Hook?](#56) |
|57 | [Wie verhindert man eine Endlosschleife in useEffect?](#57) |
|58 | [Wie implementiert man Timeout oder Interval mit Hooks?](#58) |
|59 | [](#59) |
|60 | [](#60) |
|   | React-Patterns und Konzepte |
|61 | [Was ist ein Higher-Order Component (HOC)?](#61) |
|62 | [Was ist das Render-Prop-Pattern?](#62) |
|63 | [Was ist die Context-API und wie funktioniert useContext?](#63) |
|64 | [Was sind Portale in React?](#64) |
|65 | [Was ist bedingtes Rendern (Conditional Rendering)?](#65) |
|66 | [Was ist ein Error Boundary?](#66) |
|67 | [Wie funktioniert Event-Handling in React?](#67) |
|68 | [Was ist ein synthetisches Ereignis (SyntheticEvent)?](#68) |
|69 | [Was ist props.children?](#69) |
|70 | [Was bedeutet â€controlled componentâ€œ und â€uncontrolled componentâ€œ bei Formularen?](#70) |
|71 | [](#71) |
|72 | [](#72) |
|73 | [](#73) |
|74 | [](#74) |
|75 | [](#75) |
|   | Daten & API |
|76 | [Wie fÃ¼hrt man API-Aufrufe mit Fetch oder Axios durch?](#76) |
|77 | [Wie verwaltet man Lade-, Fehler- und Erfolgsstatus?](#77) |
|78 | [Wie funktioniert WebSocket mit React?](#78) |
|79 | [Wie kann man Daten zwischen Komponenten weitergeben?](#79) |
|80 | [Wie macht man einen Datenabruf nur beim ersten Rendern?](#80) |
|81 | [Was ist das Problem bei â€stale closuresâ€œ mit Hooks?](#81) |
|82 | [Wie funktioniert die Fehlerbehandlung mit try/catch in React?](#82) |
|83 | [Wie kann man ein Mock-API oder Mock Server verwenden?](#83) |
|84 | [Wie funktioniert Suspense fÃ¼r Datenabfragen?](#84) |
|85 | [](#85) |
|86 | [](#86) |
|87 | [](#87) |
|88 | [](#88) |
|89 | [](#89) |
|90 | [](#90) |
|   | Testing |
|91 | [Was ist Unit-, Integration- und E2E-Testing?](#91) |
|92 | [Was ist Snapshot-Testing?](#92) |
|93 | [Welche Tools nutzt man fÃ¼r React-Tests (Jest, React Testing Library)?](#93) |
|94 | [Wie testet man Komponenten, Props und Events?](#94) |
|95 | [Wie testet man benutzerdefinierte Hooks?](#95) |
|96 | [](#96) |
|97 | [](#97) |
|98 | [](#98) |
|99 | [](#99) |
|100 | [](#100) |
|   | Routing mit React Router |
|101 | [Wie funktioniert Routing in React mit react-router-dom?](#101) |
|102 | [Was sind die Unterschiede zwischen react-router v5 und v6?](#102) |
|103 | [Was sind Route, Link, Navigate, Outlet?](#103) |
|104 | [Wie erstellt man Nested Routes?](#104) |
|105 | [Wie implementiert man Redirects?](#105) |
|106 | [Wie funktioniert programmgesteuerte Navigation (useNavigate)?](#106) |
|107 | [](#107) |
|108 | [](#108) |
|109 | [](#109) |
|110 | [](#110) |
|   | Redux & Redux Toolkit |
|111 | [Was ist Redux und wie funktioniert es?](#111) |
|112 | [Was sind Actions, Reducer und Store?](#112) |
|113 | [Wie funktioniert Redux Toolkit (createSlice, configureStore, createAsyncThunk)?](#113) |
|114 | [Was ist RTK Query?](#114) |
|115 | [Was ist der Unterschied zwischen Redux und der Context-API?](#115) |
|116 | [Was ist connect() in Redux?](#116) |
|117 | [Was sind Middleware in Redux (z. B. redux-thunk, redux-logger)?](#117) |
|118 | [Was ist createSelector und wie funktioniert Reselect?](#118) |
|119 | [Wie verbindet man Redux mit React Ã¼ber Hooks (useSelector, useDispatch)?](#119) |
|120 | [](#120) |
|121 | [](#121) |
|122 | [](#122) |
|123 | [](#123) |
|124 | [](#124) |
|125 | [](#125) |
|126 | [](#126) |
|127 | [](#127) |
|128 | [](#128) |
|129 | [](#129) |
|130 | [](#130) |
|   | Optimierung & Performance |
|131 | [Was ist Code-Splitting?](#131) |
|132 | [Wie funktionieren React.lazy und Suspense?](#132) |
|133 | [Was ist Tree Shaking?](#133) |
|134 | [Was ist Server-Side Rendering (SSR) und Hydration?](#134) |
|135 | [Wie geht man mit Hydration-Fehlern bei SSR um?](#135) |
|136 | [Was bedeutet Virtualisierung (z. B. mit react-window)?](#136) |
|137 | [Wie verhindert man unnÃ¶tige Re-Renders?](#137) |
|138 | [Was ist React Transition Group?](#138) |
|139 | [Was ist React Strict Mode und welche Vorteile bietet er?](#139) |
|140 | [Was ist Concurrent Mode und welche Probleme lÃ¶st er?](#140) |
|141 | [](#141) |
|142 | [](#142) |
|143 | [](#143) |
|144 | [](#144) |
|145 | [](#145) |
|   | Sonstiges |
|146 | [Was ist ein Service Worker?](#146) |
|147 | [Was ist react-helmet und wie hilft es beim SEO?](#147) |
|148 | [Wie funktioniert Lazy Loading mit dynamic import()?](#148) |
|149 | [Was ist ein Finite-State Machine (FSM), z. B. mit XState?](#149) |
|150 | [Wie kann man ein Formular mit Formik und Yup erstellen und validieren?](#150) |
|151 | [Wie konfiguriert man ESLint und Prettier in einem React-Projekt?](#151) |
|152 | [Wie funktioniert dynamic import() in React (Syntax, AnwendungsfÃ¤lle)?](#152) |
|153 | [](#153) |
|154 | [](#154) |
|155 | [](#155) |
|156 | [](#156) |
|157 | [](#157) |
|158 | [](#158) |
|159 | [](#159) |
|160 | [](#160) |
|   | React + TypeScript |
|161 | [Was ist der Unterschied zwischen interface und type in TypeScript?](#161) |
|162 | [Wie typisiert man Props und State in einer funktionalen Komponente?](#162) |
|163 | [Wie nutzt man Generics in React mit TypeScript (z. B. fÃ¼r Listen)?](#163) |
|164 | [Wie typisiert man Events in React mit TypeScript (onChange, onClick, FormEvent, MouseEvent)?](#164) |
|165 | [Wie erstellt man einen benutzerdefinierten Hook mit TypeScript?](#165) |
|166 | [Wie typisiert man useReducer mit TypeScript?](#166) |
|167 | [Wie typisiert man children korrekt in React-Komponenten?](#167) |
|168 | [Was ist React.FC und welche Vor- und Nachteile hat es?](#168) |
|169 | [Wie typisiert man eine Komponente mit optionalen Props?](#169) |
|170 | [Wie arbeitet man mit Drittanbieter-Bibliotheken, die keine Typen enthalten?](#170) |
|171 | [Was ist der Unterschied zwischen ESM und CommonJS?](#171) |
|172 | [](#172) |
|173 | [](#173) |
|174 | [](#174) |
|175 | [](#175) |
|176 | [](#176) |
|177 | [](#177) |
|178 | [](#178) |
|179 | [](#179) |
|180 | [](#180) |
|181 | [](#181) |
|182 | [](#182) |
|183 | [](#183) |
|184 | [](#184) |
|185 | [](#185) |
|186 | [](#186) |
|187 | [](#187) |
|188 | [](#188) |
|189 | [](#189) |
|190 | [](#190) |
|191 | [](#191) |
|192 | [](#192) |
|193 | [](#193) |
|194 | [](#194) |
|195 | [](#195) |
|196 | [](#196) |
|197 | [](#197) |
|198 | [](#198) |
|199 | [](#199) |
|200 | [](#200) |



<a name="questions"></a>

## ReactJS 

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**
  
1. ### <a name="1"></a> Was ist React und welche Probleme lÃ¶st es?

# Was ist React und welche Probleme lÃ¶st es?

**React** ist eine JavaScript-Bibliothek zur Erstellung von **BenutzeroberflÃ¤chen (UIs)**. Sie wurde von **Meta (Facebook)** entwickelt und hilft beim Bau interaktiver, dynamischer Webanwendungen.

---

## ğŸ”§ Welche Probleme lÃ¶st React?

1. **KomplexitÃ¤t groÃŸer Anwendungen**  
   â†’ React zerlegt die UI in **kleine, wiederverwendbare Komponenten**, wodurch der Code modular und wartbar bleibt.

2. **Manuelles DOM-Handling**  
   â†’ Mit dem **virtuellen DOM** optimiert React DOM-Ã„nderungen und verbessert die Performance.

3. **Unstrukturierter Code (z.â€¯B. bei jQuery)**  
   â†’ React fÃ¶rdert einen **komponentenbasierten Aufbau**, bei dem Logik, Markup und Styling zusammengehÃ¶ren.

4. **Schwierige Zustandsverwaltung (State)**  
   â†’ React bietet eingebaute Hooks wie `useState` oder `useReducer`, um den Zustand klar und vorhersehbar zu verwalten.

---

## ğŸ’¡ Beispielcode

```jsx
import { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0); // React verwaltet den Zustand intern

  return (
    <button onClick={() => setCount(count + 1)}>
      Du hast {count} Mal geklickt
    </button>
  );
}
```

â¡ï¸ **React aktualisiert automatisch das UI**, wenn sich der Zustand Ã¤ndert â€“ kein manuelles DOM-Update notwendig.

---

## ğŸ“ Zusammenfassung

React ist eine **komponentenbasierte UI-Bibliothek**, die typische Probleme der Webentwicklung lÃ¶st:

- unÃ¼bersichtlicher Code  
- ineffiziente DOM-Manipulation  
- schwieriges State-Management  
- mangelnde Wiederverwendbarkeit

---

## ğŸ”— Quellen

- [React â€“ Offizielle EinfÃ¼hrung](https://react.dev/learn)
- [React auf MDN Web Docs](https://developer.mozilla.org/de/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_starten)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

2. ### <a name="2"></a> Was ist JSX und warum wird es verwendet?

# Was ist JSX und warum wird es verwendet?

**JSX (JavaScript XML)** ist eine **Erweiterungssyntax fÃ¼r JavaScript**, die es ermÃ¶glicht, HTML-Ã¤hnlichen Code innerhalb von JavaScript zu schreiben. JSX wird von **React** verwendet, um die Struktur der BenutzeroberflÃ¤che deklarativ zu beschreiben.

---

## ğŸ” Warum JSX?

1. **Bessere Lesbarkeit**  
   â†’ JSX kombiniert **HTML-Struktur und JavaScript-Logik** in einem einzigen Codeblock â€“ ideal fÃ¼r Komponenten.

2. **Deklarativer Stil**  
   â†’ Statt manuelle DOM-Elemente mit `document.createElement` zu erzeugen, beschreibt JSX **was** dargestellt werden soll, nicht **wie**.

3. **Kompakter und effizienter Code**  
   â†’ JSX kompiliert zu `React.createElement(...)`-Aufrufen, die das virtuelle DOM erzeugen.

---

## ğŸ’¡ Beispielcode

```jsx
function Welcome(props) {
  return <h1>Hallo, {props.name}!</h1>;
}
```

â¡ï¸ Der obige JSX-Code wird von Babel kompiliert zu:

```js
React.createElement('h1', null, 'Hallo, ', props.name);
```

---

## ğŸ“Œ Wichtig

JSX ist **nicht zwingend erforderlich**, aber stark empfohlen, da es:

- die Entwicklung mit React beschleunigt  
- die Struktur klarer macht  
- die FehleranfÃ¤lligkeit reduziert

---

## ğŸ“ Zusammenfassung

JSX ist eine JavaScript-Erweiterung, die HTML-Ã¤hnlichen Code im JavaScript ermÃ¶glicht.  
Es erleichtert die Entwicklung mit React durch bessere Lesbarkeit, Wartbarkeit und Integration von Logik und Layout.

---

## ğŸ”— Quellen

- [JSX in React â€“ react.dev](https://react.dev/learn/writing-markup-with-jsx)  
- [JSX auf MDN Web Docs](https://developer.mozilla.org/de/docs/Web/JavaScript/JavaScript_technologies_overview#jsx)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

3. ### <a name="3"></a> Was ist Virtual DOM und wie funktioniert es?

# Was ist Virtual DOM und wie funktioniert es?

**Virtual DOM** ist eine in JavaScript abgebildete, **leichte Kopie des echten DOM**. React nutzt dieses Konzept, um effizient UI-Ã„nderungen zu erkennen und durchzufÃ¼hren, ohne den echten DOM direkt zu manipulieren â€“ was langsam und ressourcenintensiv wÃ¤re.

---

## ğŸ”§ Wie funktioniert Virtual DOM?

1. **Rendern in den virtuellen DOM**  
   â†’ React rendert Komponenten zuerst **im virtuellen DOM**, nicht direkt im echten DOM.

2. **Vergleich (Diffing)**  
   â†’ React vergleicht (diffing) den **alten virtuellen DOM** mit dem **neuen**, um herauszufinden, **welche Teile sich verÃ¤ndert haben**.

3. **Minimaler Update im echten DOM**  
   â†’ Nur die **verÃ¤nderten Teile** werden effizient und gezielt im echten DOM aktualisiert.

---

## ğŸ’¡ Beispiel: Wie React intern arbeitet

```jsx
const element = <h1>Hello, world!</h1>;
ReactDOM.render(element, document.getElementById('root'));
```

**Ablauf:**

1. JSX wird zu `React.createElement()` â†’ virtuelles DOM-Element
2. React baut daraus eine virtuelle Baumstruktur
3. Bei Ã„nderungen:
   - React erstellt einen neuen virtuellen DOM
   - vergleicht ihn mit dem alten
   - findet Unterschiede
   - updated gezielt den echten DOM

---

## ğŸ“ˆ Vorteile

- **Performance**: weniger direkte DOM-Zugriffe
- **Klarer Codefluss**: UI-Updates sind vorhersehbar und deklarativ
- **Skalierbarkeit**: geeignet fÃ¼r groÃŸe, dynamische Anwendungen

---

## ğŸ“ Zusammenfassung

Der Virtual DOM ist eine **interne, optimierte Datenstruktur** in React, die es erlaubt, **nur notwendige DOM-Ã„nderungen** durchzufÃ¼hren. Dadurch wird die Performance deutlich verbessert und die UI bleibt synchron mit dem App-Zustand.

---

## ğŸ”— Quellen

- [React: Rendering und Virtual DOM](https://react.dev/learn/rendering-elements)  
- [MDN: DOM vs Virtual DOM (extern)](https://developer.mozilla.org/)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

4. ### <a name="4"></a> Was ist der Unterschied zwischen React und ReactDOM?

# Was ist der Unterschied zwischen React und ReactDOM?

**React** und **ReactDOM** sind zwei getrennte Pakete mit unterschiedlichen Aufgaben in einer React-Anwendung.

---

## ğŸ“¦ React

Das Paket `react` enthÃ¤lt:

- Die **Core-FunktionalitÃ¤t** von React
- **Komponentenlogik**, z.â€¯B. `useState`, `useEffect`, `useReducer`
- Das Erstellen von **React-Elementen** Ã¼ber `React.createElement()`
- JSX-Verarbeitung (nach dem Transpiling)

### Beispiel:

```jsx
import { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);
  return <button onClick={() => setCount(count + 1)}>ZÃ¤hler: {count}</button>;
}
```

---

## ğŸŒ ReactDOM

Das Paket `react-dom` wird verwendet, um **React-Komponenten in das DOM** des Browsers zu rendern.

- Bindeglied zwischen **virtuellem DOM (React)** und **echtem DOM (Browser)**
- EnthÃ¤lt Methoden wie `ReactDOM.createRoot()` oder `ReactDOM.render()` (frÃ¼her)

### Beispiel:

```jsx
import ReactDOM from 'react-dom/client';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);
```

---

## ğŸ“ Zusammenfassung

| Paket      | Aufgabe                          |
|------------|----------------------------------|
| `react`    | Erstellen von Komponenten, Hooks, virtueller DOM |
| `react-dom`| Rendering ins Browser-DOM        |

---

## ğŸ”— Quellen

- [React â€“ EinfÃ¼hrung](https://react.dev/learn)  
- [ReactDOM API â€“ react.dev](https://react.dev/reference/react-dom)  
- [MDN Web Docs: EinfÃ¼hrung in React](https://developer.mozilla.org/de/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_starten)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

5. ### <a name="5"></a> Warum importieren wir React, auch wenn es scheinbar nicht benutzt wird?

# Warum importieren wir React, auch wenn es scheinbar nicht benutzt wird?

FrÃ¼her (vor React 17) musste man `React` **immer importieren**, wenn man JSX benutzt hat, **auch wenn man React nicht direkt im Code verwendet** hat.

---

## ğŸ§  Warum?

JSX wird vom Compiler (z.â€¯B. Babel) in `React.createElement()`-Aufrufe umgewandelt:

```jsx
const element = <h1>Hello</h1>;
```

wird zu:

```js
const element = React.createElement('h1', null, 'Hello');
```

â¡ï¸ Deshalb musste `React` **immer verfÃ¼gbar** sein.

---

## ğŸ”„ Seit React 17+

Dank des neuen JSX-Transform ist der `React`-Import **nicht mehr zwingend nÃ¶tig**, **wenn du einen modernen Build-Tool (z.â€¯B. Vite, CRA, Next.js)** verwendest.

### Beispiel (ab React 17):

```jsx
function App() {
  return <h1>Hello World</h1>;
}

// kein expliziter Import von React nÃ¶tig, wenn JSX-Transform aktiv
```

---

## ğŸ“¦ Voraussetzung

Damit das funktioniert, muss dein Projekt folgende Bedingungen erfÃ¼llen:

- React 17 oder neuer  
- JSX-Transform ist im Build-Tool (z.â€¯B. Babel, Vite, CRA) aktiviert  
- Du benutzt keine `React.createElement()` direkt

---

## ğŸ“ Zusammenfassung

FrÃ¼her war der Import von `React` bei JSX zwingend, da JSX zu `React.createElement()` kompiliert wurde.  
Seit React 17 ist der Import **nicht mehr notwendig**, wenn moderne Tools und der neue JSX-Transform verwendet werden.

---

## ğŸ”— Quellen

- [JSX-Transform ErklÃ¤rung â€“ React](https://react.dev/learn/writing-markup-with-jsx#the-new-jsx-transform)
- [JSX auf MDN](https://developer.mozilla.org/de/docs/Web/JavaScript/JavaScript_technologies_overview#jsx)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

6. ### <a name="6"></a> Was ist ein React Fragment und warum ist es nÃ¼tzlich?

# Was ist ein React Fragment und warum ist es nÃ¼tzlich?

Ein **React Fragment** (`<React.Fragment>` oder `<> </>`) ist ein **Wrapper ohne zusÃ¤tzliches HTML-Element im DOM**.  
Er wird verwendet, wenn eine Komponente **mehrere Elemente zurÃ¼ckgeben** muss, ohne unnÃ¶tiges Markup zu erzeugen.

---

## ğŸ” Warum nÃ¼tzlich?

- Vermeidet zusÃ¤tzliche DOM-Knoten (z.â€¯B. unnÃ¶tige `<div>`s)
- Macht den DOM sauberer und strukturierter
- Erforderlich, da JSX nur **ein Wurzelelement** pro Komponente erlaubt

---

## ğŸ’¡ Beispiel mit Fragment

```jsx
function UserInfo() {
  return (
    <>
      <h1>Max Mustermann</h1>
      <p>Frontend Developer</p>
    </>
  );
}
```

Das erzeugt im echten DOM **nur `<h1>` und `<p>`**, **kein zusÃ¤tzliches Wrapper-Element**.

---

## ğŸ’¡ Alternativ: `React.Fragment` mit Key (nÃ¼tzlich in Listen)

```jsx
<>
  {items.map(item => (
    <React.Fragment key={item.id}>
      <dt>{item.name}</dt>
      <dd>{item.description}</dd>
    </React.Fragment>
  ))}
</>
```

â¡ï¸ Nur `React.Fragment` (nicht `<>`) unterstÃ¼tzt `key`-Props.

---

## ğŸ“ Zusammenfassung

React Fragments erlauben das Gruppieren mehrerer Elemente **ohne zusÃ¤tzliches DOM-Element**.  
Sie sorgen fÃ¼r **sauberen Code und schlankes HTML**.

---

## ğŸ”— Quellen

- [Fragments â€“ React Docs](https://react.dev/reference/react/Fragment)  
- [JSX mit Fragmenten â€“ MDN](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#react_fragments)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

7. ### <a name="7"></a> Was ist der Unterschied zwischen einem Element, einer Komponente und einer Instanz?

# Was ist der Unterschied zwischen einem Element, einer Komponente und einer Instanz?

In React gibt es drei zentrale Begriffe, die oft verwechselt werden: **Element**, **Komponente** und **Instanz**.  
Hier ist eine klare Unterscheidung:

---

## 1. ğŸ§± React Element

Ein **React-Element** ist ein **einfaches JavaScript-Objekt**, das beschreibt, **was im UI gerendert werden soll**.

Es ist **keine Komponente** selbst, sondern das Ergebnis von JSX oder `React.createElement()`.

### Beispiel:

```jsx
const element = <h1>Hello, world!</h1>;
```

â¡ï¸ Das ist ein **React-Element**, kein DOM-Knoten.

---

## 2. âš™ï¸ React Komponente

Eine **Komponente** ist eine **Funktion oder Klasse**, die ein React-Element zurÃ¼ckgibt.

Sie beschreibt **wie ein UI-Teil aussehen und sich verhalten soll**. Komponenten kÃ¶nnen **wiederverwendet** und **verschachtelt** werden.

### Beispiel:

```jsx
function Welcome(props) {
  return <h1>Hallo, {props.name}</h1>;
}
```

â¡ï¸ Dies ist eine **Komponente**, die ein **Element** zurÃ¼ckgibt.

---

## 3. ğŸ§¬ Instanz (Komponenteninstanz)

Eine **Instanz** entsteht, wenn React eine Komponente **rendert** und ihren internen Zustand (State, Lifecycle etc.) verwaltet.  
Bei **Funktionalen Komponenten** ist die Instanzierung â€unsichtbarâ€œ, bei **Klassenkomponenten** existiert ein echtes Objekt.

â¡ï¸ Die Instanz ist das **laufende Exemplar** einer Komponente mit Daten, Hooks, Events etc.

---

## ğŸ” Vergleich

| Begriff       | Was ist es?                         | Beispiel                                      |
|---------------|--------------------------------------|-----------------------------------------------|
| Element       | Objekt, das UI beschreibt            | `<div>Hello</div>`                            |
| Komponente    | Funktion/Klasse, die ein Element zurÃ¼ckgibt | `function App() { return <div /> }`        |
| Instanz       | Laufzeit-Exemplar einer Komponente   | AusfÃ¼hrung mit State, Props etc.              |

---

## ğŸ“ Zusammenfassung

- **Element**: Beschreibung eines UI-Teils (z.â€¯B. `<h1>Hello</h1>`)
- **Komponente**: Funktion/Klasse, die Elemente zurÃ¼ckgibt
- **Instanz**: Laufendes Objekt der Komponente zur Laufzeit mit State und Verhalten

---

## ğŸ”— Quellen

- [React: Komponenten & Rendering â€“ react.dev](https://react.dev/learn/your-first-component)  
- [MDN: JSX und React-Komponenten](https://developer.mozilla.org/de/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_starten)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

8. ### <a name="8"></a> Was ist das Fiber-Architekturmodell in React?

# Was ist das Fiber-Architekturmodell in React?

**Fiber** ist die **neue Rendering-Engine von React**, eingefÃ¼hrt mit React 16.  
Sie ersetzt das alte, **rekursive Rendering-Modell** und ermÃ¶glicht eine **feinere Steuerung des Renderprozesses**.

---

## ğŸ¯ Warum wurde Fiber eingefÃ¼hrt?

Das alte Modell (Stack Reconciler) hatte folgende Probleme:

- UI konnte bei groÃŸen Updates **nicht unterbrochen** werden  
- Keine **Priorisierung** von wichtigen Updates (z.â€¯B. Benutzerinteraktionen)
- Kein gutes Fundament fÃ¼r **Concurrent Mode**, **Suspense** oder **Time Slicing**

---

## ğŸ§¬ Was macht Fiber besser?

### âœ… Unterbrechbares Rendering

React kann Rendering-Arbeit **in kleine Schritte aufteilen** und zwischenzeitlich pausieren oder abbrechen.

### âœ… Priorisierung

Fiber erlaubt die **Zuweisung von PrioritÃ¤ten** zu verschiedenen Updates:  
â†’ z.â€¯B. Benutzerinteraktionen werden schneller behandelt als langsame Datenupdates.

### âœ… Besseres Fehler-Handling

Fiber macht es mÃ¶glich, **Fehlergrenzen (Error Boundaries)** effizient zu verwenden.

---

## ğŸ”§ Wie funktioniert Fiber technisch?

- React erstellt beim Rendern eine **Fiber-Node** fÃ¼r jedes Element
- Diese Nodes bilden einen **Fiber-Tree**, Ã¤hnlich wie ein virtuelles DOM
- Der Tree wird **inkrementell** und **asynchron** verarbeitet
- Nach dem Vergleich (Reconciliation) folgt die **Commit-Phase**, wo echte DOM-Updates stattfinden

---

## ğŸ’¡ Beispiel: Priorisierung

```jsx
startTransition(() => {
  // niedrige PrioritÃ¤t â€“ z.â€¯B. Daten neu laden
  setSearchQuery(input);
});
```

â¡ï¸ Dank Fiber kann React Hintergrundarbeit (wie Filterung) **niedrig priorisieren**.

---

## ğŸ“ Zusammenfassung

Das **Fiber-Modell** ist Reacts moderne Rendering-Architektur.  
Es bringt:

- unterbrechbares Rendering  
- Priorisierung von Updates  
- bessere Performance bei groÃŸen Anwendungen  
- Grundlage fÃ¼r neue Features wie **Concurrent Mode** und **Suspense**

---

## ğŸ”— Quellen

- [React: EinfÃ¼hrung in Fiber](https://react.dev/learn/rendering-and-committing)  
- [React Fiber Architecture (Deep Dive â€“ englisch)](https://github.com/acdlite/react-fiber-architecture)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

9. ### <a name="9"></a> Was bedeutet â€Batchingâ€œ in React?

# Was bedeutet â€Batchingâ€œ in React?

**Batching** bezeichnet in React den Prozess, **mehrere State-Ã„nderungen zu einer einzigen Rendering-Phase zusammenzufassen**, um unnÃ¶tige Re-Renders zu vermeiden und die Performance zu verbessern.

---

## ğŸ¯ Warum ist Batching wichtig?

Ohne Batching wÃ¼rde jede einzelne `setState`- oder `useState`-Ã„nderung **sofort** ein neues Rendern auslÃ¶sen â€“ selbst wenn sie direkt hintereinander stehen.

### Beispiel **ohne Batching (theoretisch)**

```jsx
setCount(count + 1);
setName('Anna');
```

â†’ Ohne Batching: 2 Re-Renders  
â†’ Mit Batching: **nur 1 Re-Render**

---

## ğŸ§  Wie funktioniert Batching?

- In **Event-Handlern** (z.â€¯B. `onClick`, `onChange`) **batcht React automatisch**
- Seit React 18 funktioniert Batching auch in **`setTimeout`, Promises, async/await**, etc.

### Beispiel:

```jsx
function handleClick() {
  setCount(c => c + 1);
  setName('Anna');
}
```

â¡ï¸ React fÃ¼hrt **nur einen Re-Render** durch, obwohl 2 States geÃ¤ndert wurden.

---

## ğŸ” Batching in asynchronem Code (ab React 18)

```jsx
useEffect(() => {
  fetchData().then(() => {
    setLoading(false);
    setData(result);
  });
}, []);
```

â†’ Auch hier wird **automatisch gebatcht** (ab React 18), sodass nur ein Re-Render erfolgt.

---

## ğŸ› ï¸ Manuelles Batching (z.â€¯B. auÃŸerhalb von React-Kontexten)

Falls nÃ¶tig, kann man `flushSync()` oder `unstable_batchedUpdates()` verwenden â€“ aber in der Regel ist das nicht notwendig.

---

## ğŸ“ Zusammenfassung

**Batching** fasst mehrere State-Ã„nderungen in einer Rendering-Phase zusammen.  
Das reduziert die Anzahl der Re-Renders und verbessert die Performance â€“ vor allem bei komplexen Komponenten.

---

## ğŸ”— Quellen

- [Batching â€“ React Docs](https://react.dev/learn/state-a-components-memory#react-batches-state-updates)  
- [React 18 Automatic Batching](https://react.dev/learn/queueing-a-series-of-state-updates#react-batches-state-updates)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

10. ### <a name="10"></a> Was ist die Rolle des key in React-Listen?

# Was ist die Rolle des `key` in React-Listen?

In React ist der `key` ein **einzigartiger Identifikator** fÃ¼r jedes Element in einer Liste.  
Er hilft React, **zu erkennen, welche Elemente sich geÃ¤ndert, hinzugefÃ¼gt oder entfernt** haben.

---

## ğŸ¯ Warum ist `key` wichtig?

React verwendet `key`, um die **Effizienz beim Rendering** zu erhÃ¶hen:

- Vermeidet unnÃ¶tige Neurenderings
- Beibehaltung des Zustands bei gleichbleibenden Komponenten
- PrÃ¤zises **Vergleichen alter und neuer Elemente** im virtuellen DOM

---

## âŒ Problem ohne `key`

```jsx
{items.map(item => (
  <li>{item.text}</li>  // kein key â†’ ineffizient und potenziell buggy
))}
```

â¡ï¸ React kann nicht eindeutig zuordnen, welches Element welches ist.

---

## âœ… Richtige Nutzung von `key`

```jsx
{items.map(item => (
  <li key={item.id}>{item.text}</li>
))}
```

â¡ï¸ `key={item.id}` sorgt dafÃ¼r, dass React jedes Element **korrekt identifiziert**.

---

## âš ï¸ Warnung: Kein Index als `key`, auÃŸer in SonderfÃ¤llen

```jsx
// schlecht bei dynamischen Listen
<li key={index}>{item.text}</li>
```

Vermeide den **Array-Index als key**, weil das zu **falschen Updates** fÃ¼hren kann, wenn sich die Reihenfolge Ã¤ndert.

---

## ğŸ“ Zusammenfassung

Der `key` in React-Listen dient zur **eindeutigen Identifizierung von Listenelementen**.  
Er verbessert die Performance und verhindert Rendering-Probleme.  
â†’ Verwende **stabile, eindeutige Werte** wie `id`, nicht den Array-Index.

---

## ğŸ”— Quellen

- [Rendering-Listen mit keys â€“ react.dev](https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key)  
- [React keys auf MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#react_keys)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

11. ### <a name="11"></a> Wie funktioniert die Wiederverwendung von Komponenten?

# Wie funktioniert die Wiederverwendung von Komponenten?

In React bedeutet **Wiederverwendung**, dass dieselbe Komponente **mehrfach an verschiedenen Stellen mit unterschiedlichen Daten (Props)** eingesetzt werden kann.  
Das macht den Code **modular, DRY (Don't Repeat Yourself)** und wartungsfreundlich.

---

## ğŸ” Wie funktioniert das?

### 1. **Komponente erstellen (z.â€¯B. `Button`)**

```jsx
function Button({ label, onClick }) {
  return <button onClick={onClick}>{label}</button>;
}
```

### 2. **Wiederverwendung mit unterschiedlichen Props**

```jsx
<Button label="Speichern" onClick={saveData} />
<Button label="LÃ¶schen" onClick={deleteData} />
```

â¡ï¸ React verwendet dieselbe **Komponentenlogik**, aber mit unterschiedlichen **Eigenschaften (Props)**.

---

## ğŸ“¦ Vorteile der Wiederverwendung

- âœ… Einheitliches Verhalten
- âœ… Leichter wartbar
- âœ… Skalierbarer Code
- âœ… Kombinierbarkeit zu grÃ¶ÃŸeren Komponenten

---

## ğŸ’¡ Wiederverwendung auch innerhalb anderer Komponenten

```jsx
function Dialog() {
  return (
    <div>
      <Button label="Abbrechen" onClick={closeDialog} />
      <Button label="BestÃ¤tigen" onClick={confirmAction} />
    </div>
  );
}
```

â¡ï¸ Komponenten kÃ¶nnen **geschachtelt und kombiniert** werden.

---

## ğŸ“ Zusammenfassung

Komponenten werden in React wiederverwendet, indem man sie **mit verschiedenen Props mehrfach rendert**.  
Das fÃ¶rdert sauberen, wartbaren und skalierbaren Code.

---

## ğŸ”— Quellen

- [React Komponenten wiederverwenden â€“ react.dev](https://react.dev/learn/passing-props-to-a-component)  
- [Komponentenstruktur â€“ MDN Web Docs](https://developer.mozilla.org/de/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_components)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

12. ### <a name="12"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

13. ### <a name="13"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

14. ### <a name="14"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

15. ### <a name="15"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

16. ### <a name="16"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

17. ### <a name="17"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

18. ### <a name="18"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

19. ### <a name="19"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

20. ### <a name="20"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

21. ### <a name="21"></a> Was sind Props und wozu werden sie verwendet?

# Was sind Props und wozu werden sie verwendet?

**Props** (kurz fÃ¼r **"Properties"**) sind **Daten, die von einer Elternkomponente an eine Kindkomponente Ã¼bergeben werden**.  
Sie machen React-Komponenten **dynamisch und wiederverwendbar**.

---

## ğŸ§  Eigenschaften von Props

- Props sind **nur lesbar** (readonly)
- Sie werden **als Objekt** an Komponenten Ã¼bergeben
- Sie ermÃ¶glichen das **Anpassen des Verhaltens oder Inhalts** einer Komponente

---

## ğŸ’¡ Beispiel

### Elternkomponente:

```jsx
function App() {
  return <Welcome name="Sergii" />;
}
```

### Kindkomponente:

```jsx
function Welcome(props) {
  return <h1>Hallo, {props.name}!</h1>;
}
```

â¡ï¸ `name="Sergii"` ist ein **Prop**, das an `Welcome` Ã¼bergeben wird.  
Im Code erreichbar Ã¼ber `props.name`.

---

## ğŸ¯ Wozu werden Props verwendet?

- Weitergabe von Daten zwischen Komponenten  
- Wiederverwendung einer Komponente mit **unterschiedlichen Inhalten**  
- Kommunikation **von Eltern zu Kind**

---

## ğŸ“¦ Props mit Destructuring

```jsx
function Welcome({ name }) {
  return <h1>Hallo, {name}!</h1>;
}
```

â¡ï¸ Kurzform fÃ¼r besseren Lesefluss.

---

## ğŸ“ Zusammenfassung

**Props** sind Eingabedaten fÃ¼r Komponenten.  
Sie ermÃ¶glichen die **dynamische Anpassung** von Komponenten und fÃ¶rdern **Wiederverwendbarkeit**.  
Props flieÃŸen **nur von oben nach unten** (Parent â†’ Child).

---

## ğŸ”— Quellen

- [Props in React â€“ react.dev](https://react.dev/learn/passing-props-to-a-component)  
- [Komponenten und Props â€“ MDN Web Docs](https://developer.mozilla.org/de/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_components#eigenschaften_props)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

22. ### <a name="22"></a> Was ist der Unterschied zwischen Props und State?

# Was ist der Unterschied zwischen Props und State?

In React sind **Props** und **State** zwei zentrale Konzepte zur Steuerung von Daten in Komponenten.  
Sie dienen unterschiedlichen Zwecken und haben verschiedene Eigenschaften.

---

## ğŸ“¦ Props

- **Daten von auÃŸen** â†’ werden von der **Elternkomponente Ã¼bergeben**
- **Readonly**: kÃ¶nnen innerhalb der Komponente **nicht verÃ¤ndert** werden
- Erlauben die **Wiederverwendung von Komponenten**
- FlieÃŸen **von oben nach unten** (unidirektional)

### Beispiel:

```jsx
function Welcome({ name }) {
  return <h1>Hallo, {name}!</h1>;
}
```

â†’ `name` ist ein **Prop**, das z.â€¯B. von `<Welcome name="Anna" />` kommt

---

## ğŸ”„ State

- **Interne Daten** einer Komponente  
- KÃ¶nnen sich **im Lauf der Zeit Ã¤ndern** (z.â€¯B. durch Benutzerinteraktion)
- Ã„nderungen am State fÃ¼hren zu **einem Re-Render**
- Wird mit Hooks wie `useState` verwaltet

### Beispiel:

```jsx
function Counter() {
  const [count, setCount] = useState(0);
  return <button onClick={() => setCount(count + 1)}>ZÃ¤hler: {count}</button>;
}
```

â†’ `count` ist der **State** der Komponente

---

## ğŸ” Vergleich Props vs. State

| Merkmal          | Props                      | State                          |
|------------------|----------------------------|--------------------------------|
| Ursprung         | Elternkomponente           | Innerhalb der Komponente       |
| VerÃ¤nderbar?     | âŒ Nein (readonly)         | âœ… Ja (mit `setState` / `useState`) |
| Zweck            | Konfiguration von auÃŸen    | Dynamische, sich Ã¤ndernde Daten |
| Kontrolle        | Vom Elternteil gesteuert   | Von der Komponente selbst      |

---

## ğŸ“ Zusammenfassung

- **Props**: Eingabedaten von auÃŸen, unverÃ¤nderlich, durch Eltern gesteuert  
- **State**: Interner Zustand, verÃ¤nderlich, durch die Komponente selbst verwaltet

Beides zusammen macht Komponenten **dynamisch und wiederverwendbar**.

---

## ğŸ”— Quellen

- [Props vs. State â€“ react.dev](https://react.dev/learn/state-a-components-memory#comparing-state-and-props)  
- [MDN: Komponenten mit Props und State](https://developer.mozilla.org/de/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_components)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

23. ### <a name="23"></a> Warum sind Props nur lesbar?

# Warum sind Props nur lesbar?

**Props** (Properties) sind in React **nur lesbar**, weil sie die Daten darstellen,  
die **von auÃŸen** (also von der Elternkomponente) **an eine Kindkomponente Ã¼bergeben werden**.

---

## ğŸ¯ HauptgrÃ¼nde fÃ¼r die UnverÃ¤nderlichkeit von Props

### 1. ğŸ”’ **Datenfluss kontrollieren (UnidirektionalitÃ¤t)**

React folgt dem Prinzip des **einseitigen Datenflusses**:  
Daten flieÃŸen **von oben (Parent) nach unten (Child)**.  
Wenn Kind-Komponenten Props verÃ¤ndern kÃ¶nnten, wÃ¼rde der Datenfluss **chaotisch und unvorhersehbar** werden.

---

### 2. ğŸ§© **Komponenten bleiben vorhersehbar und wiederverwendbar**

Eine Komponente, die ihre Props **nicht verÃ¤ndert**, ist:

- einfacher zu testen  
- leichter wiederzuverwenden  
- unabhÃ¤ngig vom Kontext, in dem sie verwendet wird

---

### 3. ğŸ” Ã„nderungen sollen in der Elternkomponente passieren

Wenn sich ein Wert Ã¤ndern soll, soll die **Elternkomponente** dies tun und **neue Props Ã¼bergeben**.

### Beispiel:

```jsx
function Child({ count }) {
  // count ist readonly
  return <p>ZÃ¤hler: {count}</p>;
}
```

â¡ï¸ Wenn `count` verÃ¤ndert werden soll, muss das in der **Elternkomponente** passieren, z.â€¯B. mit `useState`.

---

## ğŸ”§ Was tun, wenn sich Werte Ã¤ndern sollen?

Verwende **State (`useState`)** in der Elternkomponente und gib ggf. **Callback-Funktionen** per Prop mit.

```jsx
function Parent() {
  const [count, setCount] = useState(0);

  return <Child count={count} onIncrement={() => setCount(count + 1)} />;
}
```

---

## ğŸ“ Zusammenfassung

**Props sind nur lesbar**, um den **einseitigen Datenfluss** zu erhalten, die **Vorhersehbarkeit** der Komponenten zu sichern und Ã„nderungen **kontrolliert Ã¼ber die Elternkomponente** zu steuern.

---

## ğŸ”— Quellen

- [Props in React â€“ react.dev](https://react.dev/learn/passing-props-to-a-component)  
- [Datenfluss in React â€“ react.dev](https://react.dev/learn/thinking-in-react#step-5-add-inverse-data-flow)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

24. ### <a name="24"></a> Wie funktioniert der unidirektionale Datenfluss in React?

# Wie funktioniert der unidirektionale Datenfluss in React?

In React bedeutet **unidirektionaler Datenfluss**, dass **Daten immer nur in eine Richtung flieÃŸen**:  
**von der Elternkomponente zur Kindkomponente**.

---

## ğŸ” Was heiÃŸt das konkret?

- Elternkomponenten **geben Daten Ã¼ber Props weiter**
- Kindkomponenten kÃ¶nnen diese Props **verwenden**, aber **nicht verÃ¤ndern**
- Ã„nderungen am Zustand (State) **finden immer in der zustÃ¤ndigen Komponente statt**

---

## ğŸ“¦ Beispiel

```jsx
function Parent() {
  const [count, setCount] = useState(0);

  return <Child count={count} onIncrement={() => setCount(count + 1)} />;
}

function Child({ count, onIncrement }) {
  return (
    <div>
      <p>ZÃ¤hler: {count}</p>
      <button onClick={onIncrement}>+1</button>
    </div>
  );
}
```

### ErklÃ¤rung:

- `Parent` hÃ¤lt den **State**
- `Child` bekommt `count` und `onIncrement` als **Props**
- Der Datenfluss geht **von Parent â†’ Child**
- Ã„nderungen (Button-Klick) **lÃ¶sen in der Elternkomponente eine State-Ã„nderung aus**, die **neue Props an das Kind sendet**

---

## ğŸ¯ Vorteile des unidirektionalen Datenflusses

- âœ… **Vorhersehbares Verhalten**
- âœ… **Bessere Debuggability**
- âœ… Klare Trennung von ZustÃ¤ndigkeiten
- âœ… Weniger Fehler durch unkontrollierte DatenÃ¤nderungen

---

## ğŸ” Daten â€nach obenâ€œ geben (umgekehrt)

Kindkomponenten kÃ¶nnen Ã¼ber **Callback-Funktionen als Prop** indirekt Daten nach oben melden:

```jsx
onChange={(newValue) => parentCallback(newValue)}
```

â¡ï¸ So bleibt die **Datenkontrolle bei der Elternkomponente**.

---

## ğŸ“ Zusammenfassung

Der **unidirektionale Datenfluss** sorgt dafÃ¼r, dass Daten in React immer von **Eltern zu Kind** flieÃŸen.  
Das sorgt fÃ¼r eine **klare Struktur**, bessere Wartbarkeit und **kontrollierbare ZustandsÃ¤nderungen**.

---

## ğŸ”— Quellen

- [Thinking in React â€“ react.dev](https://react.dev/learn/thinking-in-react#step-5-add-inverse-data-flow)  
- [Props und Datenfluss â€“ MDN](https://developer.mozilla.org/de/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_components#datenfluss)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

25. ### <a name="25"></a> Was ist State in Klassen- und Funktionskomponenten?

# Was ist State in Klassen- und Funktionskomponenten?

**State** ist ein **interner Speicher** (Zustand) einer React-Komponente, der sich **Ã¼ber die Zeit Ã¤ndern** kann.  
Ã„nderungen am State lÃ¶sen ein **automatisches Re-Rendern** der Komponente aus.

---

## âš™ï¸ State in Funktionskomponenten (mit Hooks)

Seit React 16.8 wird State in Funktionskomponenten mit dem Hook `useState` verwaltet.

### Beispiel:

```jsx
import { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0); // count = aktueller Wert, setCount = Funktion zum Ã„ndern

  return (
    <button onClick={() => setCount(count + 1)}>
      Du hast {count} Mal geklickt
    </button>
  );
}
```

â¡ï¸ Jeder `setCount` lÃ¶st ein **Re-Rendern** der Komponente mit dem neuen Wert aus.

---

## ğŸ—ï¸ State in Klassenkomponenten (vor Hooks)

Vor Hooks wurde der State mit `this.state` und `this.setState()` in **Klassenkomponenten** verwendet.

### Beispiel:

```jsx
import React, { Component } from 'react';

class Counter extends Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 }; // Initialwert
  }

  render() {
    return (
      <button onClick={() => this.setState({ count: this.state.count + 1 })}>
        Du hast {this.state.count} Mal geklickt
      </button>
    );
  }
}
```

â¡ï¸ `this.setState()` aktualisiert den Zustand **asynchron** und triggert ein Re-Render.

---

## ğŸ” Vergleich: Funktions- vs. Klassenkomponenten

| Merkmal         | Funktionskomponente      | Klassenkomponente           |
|-----------------|--------------------------|-----------------------------|
| EinfÃ¼hrung ab   | React 16.8 (mit Hooks)   | FrÃ¼here React-Versionen     |
| State-Verwaltung| `useState()`             | `this.state` + `setState()` |
| Syntax          | Einfacher, moderner      | Komplexer, mehr Boilerplate |

---

## ğŸ“ Zusammenfassung

**State** ist der dynamische Datenbereich einer Komponente.  
- In **Funktionskomponenten** nutzt man `useState`  
- In **Klassenkomponenten** verwendet man `this.state` und `this.setState`  
State-Ã„nderungen fÃ¼hren **automatisch zu UI-Updates**

---

## ğŸ”— Quellen

- [State in React â€“ react.dev](https://react.dev/learn/state-a-components-memory)  
- [useState Hook â€“ react.dev](https://react.dev/reference/react/useState)  
- [MDN: Klassenkomponenten und State](https://developer.mozilla.org/de/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_components#state_in_klassenkomponenten)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

26. ### <a name="26"></a> Wie funktioniert setState?

# Wie funktioniert `setState`?

`setState` ist die Methode in React, mit der der **Zustand (State)** einer Komponente **aktualisiert** wird.  
Sie ist in **Klassenkomponenten** verfÃ¼gbar und wird in **Funktionskomponenten** durch `useState` ersetzt.

---

## âš™ï¸ `setState` in Klassenkomponenten

### Beispiel:

```jsx
class Counter extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }

  increment = () => {
    this.setState({ count: this.state.count + 1 });
  };

  render() {
    return <button onClick={this.increment}>ZÃ¤hler: {this.state.count}</button>;
  }
}
```

### Was passiert hier?

1. `this.setState(...)` wird aufgerufen
2. React **merged** das neue Objekt mit dem aktuellen `state`
3. Es erfolgt ein **Re-Render** der Komponente mit dem neuen Zustand

---

## âš ï¸ Wichtig: `setState` ist **asynchron**

Das bedeutet: Wenn du direkt nach `setState` auf `this.state` zugreifst, ist der neue Wert noch **nicht garantiert verfÃ¼gbar**.

### Falsch:

```js
this.setState({ count: this.state.count + 1 });
console.log(this.state.count); // Kann noch alt sein!
```

---

## âœ… Korrekt mit Callback-Funktion (abhÃ¤ngig vom vorherigen Wert)

```js
this.setState((prevState) => ({
  count: prevState.count + 1
}));
```

â¡ï¸ So stellst du sicher, dass du immer mit dem aktuellen Zustand arbeitest â€“ auch bei mehreren State-Updates hintereinander.

---

## ğŸ“˜ In Funktionskomponenten

Verwendet man stattdessen `useState`:

```jsx
const [count, setCount] = useState(0);
setCount(count + 1);
```

---

## ğŸ“ Zusammenfassung

- `setState` aktualisiert den Zustand in **Klassenkomponenten**
- Updates sind **asynchron** und kÃ¶nnen **gebatcht** werden
- Verwende Callback-Form (`prevState`) bei abhÃ¤ngigen Updates
- In **Funktionskomponenten** wird `useState` verwendet

---

## ğŸ”— Quellen

- [setState â€“ React Docs](https://react.dev/reference/react/Component#setstate)  
- [State-Updates richtig ausfÃ¼hren â€“ react.dev](https://react.dev/learn/queueing-a-series-of-state-updates)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

27. ### <a name="27"></a> Was ist der Unterschied zwischen kontrollierten und unkontrollierten Komponenten?

# Was ist der Unterschied zwischen kontrollierten und unkontrollierten Komponenten?

In React unterscheidet man zwischen **kontrollierten** und **unkontrollierten Komponenten**,  
wenn es um die Verwaltung von Formular-Elementen wie `<input>`, `<textarea>` oder `<select>` geht.

---

## âœ… Kontrollierte Komponenten

Bei **kontrollierten Komponenten** wird der **Wert eines Formularfelds durch den React-State gesteuert**.

### Merkmale:

- Der **aktuelle Wert** kommt aus dem `useState`-State
- Ã„nderungen werden Ã¼ber `onChange` an React gemeldet
- Die Komponente ist **vollstÃ¤ndig unter Reacts Kontrolle**

### Beispiel:

```jsx
function ControlledInput() {
  const [value, setValue] = useState('');

  return (
    <input 
      value={value} 
      onChange={(e) => setValue(e.target.value)} 
    />
  );
}
```

â¡ï¸ Der `value` wird durch den State bestimmt. React "besitzt" das Eingabefeld.

---

## âŒ Unkontrollierte Komponenten

Bei **unkontrollierten Komponenten** Ã¼bernimmt **das DOM selbst die Kontrolle Ã¼ber den Wert**.  
React greift bei Bedarf Ã¼ber ein **Ref** darauf zu.

### Merkmale:

- Kein `useState`, kein `onChange`
- Zugriff Ã¼ber `useRef` â†’ z.â€¯B. beim Abschicken eines Formulars
- Das Feld verwaltet seinen Zustand **eigenstÃ¤ndig**

### Beispiel:

```jsx
function UncontrolledInput() {
  const inputRef = useRef();

  const handleSubmit = () => {
    alert(inputRef.current.value);
  };

  return (
    <>
      <input ref={inputRef} />
      <button onClick={handleSubmit}>Absenden</button>
    </>
  );
}
```

â¡ï¸ React greift **nur lesend** auf den DOM zu â€“ keine direkte Kontrolle Ã¼ber den Wert.

---

## ğŸ” Vergleich

| Merkmal               | Kontrolliert                 | Unkontrolliert              |
|------------------------|------------------------------|------------------------------|
| Wertquelle             | React-State (`useState`)     | DOM                          |
| Kontrolle              | React                        | Browser                      |
| Zugriff auf Wert       | `value` + `onChange`         | `useRef().current.value`     |
| Empfohlen fÃ¼r          | Validierung, komplexe Logik  | einfache Formulare, schnelles Prototyping |

---

## ğŸ“ Zusammenfassung

- **Kontrollierte Komponenten**: React verwaltet den Eingabewert â†’ prÃ¤zise, kontrolliert, ideal fÃ¼r Validierung
- **Unkontrollierte Komponenten**: DOM verwaltet den Wert â†’ einfacher, aber weniger flexibel

---

## ğŸ”— Quellen

- [Kontrollierte Komponenten â€“ react.dev](https://react.dev/learn/sharing-state-between-components#controlled-and-uncontrolled-components)  
- [Formulare in React â€“ MDN](https://developer.mozilla.org/de/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_forms)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

28. ### <a name="28"></a> Was sind Default Props und PropTypes?

# Was sind Default Props und PropTypes?

In React bieten **Default Props** und **PropTypes** zwei MÃ¶glichkeiten, um die Verwendung von **Props sicherer und robuster** zu machen.

---

## âœ… 1. Default Props

**Default Props** sind **Standardwerte** fÃ¼r Props, die verwendet werden,  
wenn ein Prop **nicht vom Elternteil Ã¼bergeben wurde**.

### Beispiel:

```jsx
function Welcome({ name }) {
  return <h1>Hallo, {name}!</h1>;
}

Welcome.defaultProps = {
  name: 'Gast',
};
```

â¡ï¸ Wenn `name` nicht Ã¼bergeben wurde, zeigt die Komponente automatisch `Hallo, Gast!` an.

---

## âœ… 2. PropTypes

**PropTypes** werden verwendet, um die **Datentypen der Props zu validieren**.  
React gibt **eine Warnung in der Konsole**, wenn ein Prop nicht dem erwarteten Typ entspricht.

### Beispiel:

```jsx
import PropTypes from 'prop-types';

function Welcome({ name, age }) {
  return (
    <p>
      Hallo, {name}! Du bist {age} Jahre alt.
    </p>
  );
}

Welcome.propTypes = {
  name: PropTypes.string.isRequired,
  age: PropTypes.number,
};
```

â¡ï¸ Warnung in der Konsole, wenn z.â€¯B. `name` fehlt oder `age` kein `number` ist.

---

## ğŸ“¦ UnterstÃ¼tzte Typen

| Typ               | Beschreibung                        |
|-------------------|--------------------------------------|
| `PropTypes.string`| Zeichenkette                         |
| `PropTypes.number`| Zahl                                 |
| `PropTypes.bool`  | Boolean                              |
| `PropTypes.func`  | Funktion                             |
| `PropTypes.array` | Array                                |
| `PropTypes.object`| Objekt                               |
| `.isRequired`     | Macht das Prop erforderlich          |

---

## ğŸ“ Zusammenfassung

- **Default Props**: Definieren **Standardwerte**, wenn keine Props Ã¼bergeben werden
- **PropTypes**: Helfen bei der **TypprÃ¼fung** von Props zur Laufzeit (fÃ¼r Debugging und Klarheit)

---

## ğŸ”— Quellen

- [React: Default Props â€“ react.dev](https://react.dev/learn/passing-props-to-a-component#default-props)  
- [PropTypes â€“ React Docs](https://reactjs.org/docs/typechecking-with-proptypes.html)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

29. ### <a name="29"></a> Was ist React.memo und wofÃ¼r wird es verwendet?

# Was ist `React.memo` und wofÃ¼r wird es verwendet?

**`React.memo`** ist eine **Higher-Order-Komponente (HOC)**, die eine **Funktionskomponente speichert (memoisiert)**  
und **nur neu rendert**, wenn sich ihre **Props tatsÃ¤chlich geÃ¤ndert haben**.

---

## ğŸ¯ Zweck von `React.memo`

- Vermeidet **unnÃ¶tige Re-Renders**  
- Verbessert die **Performance** groÃŸer Anwendungen  
- NÃ¼tzlich bei **teuren Berechnungen oder komplexem UI**

---

## ğŸ§  Wie funktioniert es?

```jsx
const MemoizedComponent = React.memo(MyComponent);
```

React vergleicht bei jedem Render die **alten und neuen Props mit `===`**.  
Nur bei Ã„nderung wird `MyComponent` neu gerendert.

---

## ğŸ’¡ Beispiel

```jsx
const Greeting = React.memo(function Greeting({ name }) {
  console.log('gerendert');
  return <p>Hallo, {name}</p>;
});
```

â¡ï¸ Wird `name` nicht geÃ¤ndert, wird die Komponente **nicht neu gerendert**.

---

## ğŸ”§ Mit benutzerdefiniertem Vergleich (optional)

```jsx
function areEqual(prevProps, nextProps) {
  return prevProps.name === nextProps.name;
}

const MemoGreeting = React.memo(Greeting, areEqual);
```

â¡ï¸ Du kannst einen **eigenen Vergleichsalgorithmus** definieren.

---

## âš ï¸ Wann NICHT verwenden?

- Bei **hÃ¤ufig wechselnden Props**
- Bei **sehr einfachen Komponenten**
- Wenn Re-Renders keine merkliche Performance-Auswirkung haben

---

## ğŸ“ Zusammenfassung

- `React.memo` verhindert unnÃ¶tige Re-Renders von **Funktionskomponenten**
- Es vergleicht Props und rendert nur bei Ã„nderungen
- Ideal bei **leistungsintensiven Komponenten** mit stabilen Props

---

## ğŸ”— Quellen

- [React.memo â€“ React Docs](https://react.dev/reference/react/memo)  
- [Optimizing Performance â€“ React](https://react.dev/learn/optimizing-performance#memoizing-components)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

30. ### <a name="30"></a> Was ist PureComponent und wie unterscheidet es sich von Component?

# Was ist `PureComponent` und wie unterscheidet es sich von `Component`?

In React gibt es zwei Basisklassen fÃ¼r Klassenkomponenten:

- `React.Component`
- `React.PureComponent`

Der Unterschied liegt im **Verhalten beim Rendern**.

---

## âœ… `React.Component`

- Jede Ã„nderung von `state` oder `props` â†’ **fÃ¼hrt immer zu einem Re-Render**
- Kein Vergleich alter und neuer Props/State
- Du kannst `shouldComponentUpdate()` selbst Ã¼berschreiben, um Rendering zu optimieren

---

## âœ… `React.PureComponent`

- FÃ¼hrt **automatisch einen flachen Vergleich** (`shallow compare`) von `props` und `state` durch
- **Rendert nur**, wenn sich etwas **tatsÃ¤chlich geÃ¤ndert hat**
- Du musst `shouldComponentUpdate()` **nicht selbst schreiben**

---

## ğŸ’¡ Beispiel

```jsx
class MyComponent extends React.Component {
  render() {
    console.log('MyComponent rendert immer');
    return <div>{this.props.text}</div>;
  }
}

class MyPureComponent extends React.PureComponent {
  render() {
    console.log('MyPureComponent rendert nur bei Ã„nderung');
    return <div>{this.props.text}</div>;
  }
}
```

Wenn `text` sich nicht Ã¤ndert, wird **`MyPureComponent` nicht neu gerendert**,  
aber **`MyComponent` rendert trotzdem**.

---

## âš ï¸ EinschrÃ¤nkung

- `PureComponent` macht **nur einen flachen Vergleich**
  - Ã„nderungen in **verschachtelten Objekten/Arrays** werden **nicht erkannt**
- Beispiel:

```js
this.setState({ data: { name: 'Max' } }); // Neuer Objekt-Referenz, aber inhaltlich gleich â†’ Re-Render
```

---

## ğŸ” Vergleich

| Merkmal              | `Component`            | `PureComponent`                   |
|----------------------|------------------------|------------------------------------|
| Re-Render bei Update | immer                  | nur bei Ã„nderungen (shallow check)|
| Performance          | normal                 | optimiert fÃ¼r einfache Props/State|
| shouldComponentUpdate| manuell definierbar    | intern automatisch                |

---

## ğŸ“ Zusammenfassung

- `Component`: rendert immer bei State-/Props-Ã„nderung
- `PureComponent`: rendert nur bei tatsÃ¤chlicher Ã„nderung (flacher Vergleich)
- Ideal bei **statischen Props oder Performance-kritischen Klassenkomponenten**

---

## ğŸ”— Quellen

- [React.PureComponent â€“ React Docs](https://react.dev/reference/react/PureComponent)  
- [React-Komponenten optimieren â€“ react.dev](https://react.dev/learn/optimizing-performance#purecomponents)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**  

31. ### <a name="31"></a> Wann sollte shouldComponentUpdate verwendet werden?

# Wann sollte `shouldComponentUpdate` verwendet werden?

Die Methode **`shouldComponentUpdate(nextProps, nextState)`** wird in **Klassenkomponenten** verwendet,  
um zu **steuern, ob eine Komponente neu gerendert werden soll**.

---

## ğŸ¯ Zweck

- **Performance-Optimierung**: Vermeide unnÃ¶tige Re-Renders bei unverÃ¤nderten Props oder State
- Besonders nÃ¼tzlich bei **groÃŸen Komponenten** oder **hÃ¤ufigen Updates**

---

## ğŸ’¡ Beispiel

```jsx
class MyComponent extends React.Component {
  shouldComponentUpdate(nextProps) {
    return nextProps.value !== this.props.value;
  }

  render() {
    console.log('gerendert');
    return <div>{this.props.value}</div>;
  }
}
```

â¡ï¸ Die Komponente rendert **nur**, wenn sich `value` geÃ¤ndert hat.

---

## ğŸ§  Wann sinnvoll?

| Situation | Verwendung von `shouldComponentUpdate` sinnvoll? |
|-----------|--------------------------------------------------|
| GroÃŸe Komponenten mit viel DOM | âœ… Ja                       |
| Props Ã¤ndern sich selten       | âœ… Ja                       |
| Props enthalten komplexe Objekte (z.â€¯B. Arrays) | âœ… mit Deep Compare |
| Kleine statische Komponenten   | âŒ Nicht nÃ¶tig              |
| Du verwendest `PureComponent`  | âŒ Schon eingebaut          |

---

## âš ï¸ Vorsicht bei Objekten und Arrays

```js
shouldComponentUpdate(nextProps) {
  return nextProps.data !== this.props.data;
}
```

â†’ **Referenzvergleich**: wenn `data` neu erstellt wird, auch mit gleichem Inhalt, erfolgt ein Re-Render.  
â†’ Bei komplexeren Strukturen: ggf. **tiefer Vergleich (deep equality)** erforderlich.

---

## ğŸ“ Zusammenfassung

`shouldComponentUpdate` wird verwendet, um **Rerender manuell zu kontrollieren**,  
wenn **Props oder State sich nicht tatsÃ¤chlich geÃ¤ndert haben**.  
Das spart Rechenzeit und verbessert die **Performance**, insbesondere bei groÃŸen Komponenten.

---

## ğŸ”— Quellen

- [shouldComponentUpdate â€“ React Docs](https://react.dev/reference/react/Component#shouldcomponentupdate)  
- [React Performance â€“ react.dev](https://react.dev/learn/optimizing-performance)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

32. ### <a name="32"></a> Was ist ein ref und wann wird er eingesetzt?

# Was ist ein `ref` und wann wird er eingesetzt?

Ein **`ref` (reference)** in React ist ein Objekt, das **direkten Zugriff auf ein DOM-Element oder eine React-Komponente** ermÃ¶glicht â€“ **ohne den Ã¼blichen Datenfluss Ã¼ber Props oder State**.

---

## ğŸ§  WofÃ¼r werden Refs verwendet?

- ğŸ“Œ **Direkter Zugriff auf DOM-Elemente**
- ğŸ® **Manuelles Fokus-Management** (z.â€¯B. `input.focus()`)
- â¯ï¸ **Steuerung von Medien (Video/Audio)**
- ğŸ“¦ **Integration von Drittanbieter-Bibliotheken**
- ğŸ§ª **Lesen von Werten in unkontrollierten Komponenten**

---

## ğŸ’¡ Beispiel: DOM-Element fokussieren

```jsx
import { useRef, useEffect } from 'react';

function FocusInput() {
  const inputRef = useRef(null);

  useEffect(() => {
    inputRef.current.focus(); // Direktes DOM-Zugreifen
  }, []);

  return <input ref={inputRef} />;
}
```

â¡ï¸ `inputRef.current` zeigt auf das `<input>` DOM-Element.

---

## ğŸ“¦ `useRef` vs. `createRef`

| Hook/Method        | Verwendung                        |
|--------------------|-----------------------------------|
| `useRef()`         | In **Funktionskomponenten**       |
| `createRef()`      | In **Klassenkomponenten**         |

---

## ğŸ§¬ Beispiel: Unkontrolliertes Eingabefeld

```jsx
function UncontrolledForm() {
  const inputRef = useRef();

  const handleSubmit = () => {
    alert(`Eingegeben: ${inputRef.current.value}`);
  };

  return (
    <>
      <input ref={inputRef} />
      <button onClick={handleSubmit}>Absenden</button>
    </>
  );
}
```

â¡ï¸ Zugriff auf den Wert **ohne State/Props**.

---

## âš ï¸ Wann **nicht** verwenden?

- âŒ Kein Ersatz fÃ¼r `state` bei kontrollierten Komponenten  
- âŒ Kein Mittel zur Datenverarbeitung oder Logiksteuerung  
- âŒ Nicht fÃ¼r das AuslÃ¶sen von Re-Renders gedacht

---

## ğŸ“ Zusammenfassung

Ein `ref` ist eine **Referenz auf ein DOM-Element oder eine Komponente**.  
Er wird eingesetzt, wenn React **nicht der beste Ort zur Verwaltung von Verhalten ist**, z.â€¯B. bei Fokus, Scroll, Animationen oder Drittanbieter-APIs.

---

## ğŸ”— Quellen

- [Refs und DOM â€“ React Docs](https://react.dev/learn/referencing-values-with-refs)  
- [useRef Hook â€“ react.dev](https://react.dev/reference/react/useRef)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

33. ### <a name="33"></a> Was bedeutet â€Lifting State Upâ€œ?

# Was bedeutet â€Lifting State Upâ€œ?

**â€Lifting State Upâ€œ** bezeichnet ein Muster in React, bei dem **mehrere Komponenten denselben State benÃ¶tigen** â€“  
aber **nur eine Elternkomponente** diesen Zustand verwalten soll.

---

## ğŸ¯ Warum â€State anhebenâ€œ?

Wenn zwei oder mehr Komponenten auf denselben Wert zugreifen oder ihn Ã¤ndern mÃ¼ssen,  
ist es besser, den **State in die nÃ¤chste gemeinsame Elternkomponente zu verschieben**.

---

## ğŸ’¡ Beispiel

### âœ… Struktur mit â€Lifting State Upâ€œ

```jsx
function Parent() {
  const [text, setText] = useState('');

  return (
    <>
      <Input text={text} onTextChange={setText} />
      <Display text={text} />
    </>
  );
}

function Input({ text, onTextChange }) {
  return (
    <input 
      value={text} 
      onChange={(e) => onTextChange(e.target.value)} 
    />
  );
}

function Display({ text }) {
  return <p>Aktueller Text: {text}</p>;
}
```

â¡ï¸ `Parent` verwaltet den Zustand `text`,  
und beide Kind-Komponenten (`Input`, `Display`) **bekommen diesen State als Prop**.

---

## ğŸ” Vorteile

- âœ… **Zentrale Datenquelle** fÃ¼r mehrere Komponenten
- âœ… Einfache Synchronisation und Datenfluss
- âœ… Vermeidung von doppeltem State

---

## âš ï¸ Typischer Anwendungsfall

- Zwei Komponenten mÃ¼ssen sich **auf denselben Wert beziehen**
- Eine Komponente Ã¤ndert den Wert, die andere zeigt ihn an

---

## ğŸ“ Zusammenfassung

**â€Lifting State Upâ€œ** bedeutet, den gemeinsamen Zustand in eine **hÃ¶herliegende Elternkomponente zu verschieben**,  
damit mehrere untergeordnete Komponenten synchron auf denselben Wert zugreifen kÃ¶nnen.

---

## ğŸ”— Quellen

- [Lifting State Up â€“ react.dev](https://react.dev/learn/sharing-state-between-components#lifting-state-up)  
- [State Sharing in React â€“ MDN](https://developer.mozilla.org/de/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_components#lifting_state_up)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

34. ### <a name="34"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

35. ### <a name="35"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

36. ### <a name="36"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

37. ### <a name="37"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

38. ### <a name="38"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

39. ### <a name="39"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

40. ### <a name="40"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**  

41. ### <a name="41"></a> Was sind die Phasen des Komponentenlebenszyklus?

# Was sind die Phasen des Komponentenlebenszyklus?

Der **Komponentenlebenszyklus** in React beschreibt die **Abfolge von Ereignissen**,  
die eine Komponente wÃ¤hrend ihres Bestehens durchlÃ¤uft â€“ vom Erstellen bis zum Entfernen aus dem DOM.

â¡ï¸ Lebenszyklus-Methoden gelten hauptsÃ¤chlich fÃ¼r **Klassenkomponenten**.  
In **Funktionskomponenten** verwendet man **Hooks** wie `useEffect`.

---

## ğŸ“… Die 3 Hauptphasen

### 1. ğŸ—ï¸ **Mounting (EinfÃ¼gen)**  
Die Komponente wird in den DOM eingefÃ¼gt.

| Methode             | Beschreibung                                      |
|---------------------|---------------------------------------------------|
| `constructor()`     | Initialisierung, z.â€¯B. State setzen               |
| `render()`          | Gibt JSX zurÃ¼ck                                   |
| `componentDidMount()` | Wird **nach dem ersten Render** aufgerufen       |

---

### 2. ğŸ”„ **Updating (Aktualisierung)**  
Wenn Props oder State sich Ã¤ndern, wird die Komponente neu gerendert.

| Methode                 | Beschreibung                                         |
|-------------------------|------------------------------------------------------|
| `render()`              | Gibt JSX erneut zurÃ¼ck                               |
| `componentDidUpdate()`  | Wird **nach jeder Ã„nderung** von Props oder State aufgerufen |

---

### 3. âŒ **Unmounting (Entfernen)**  
Die Komponente wird aus dem DOM entfernt.

| Methode                | Beschreibung                           |
|------------------------|----------------------------------------|
| `componentWillUnmount()` | AufrÃ¤umarbeiten (z.â€¯B. Event-Listener entfernen) |

---

## âš ï¸ Veraltete Methoden (nicht mehr empfohlen)

- `componentWillMount()`  
- `componentWillReceiveProps()`  
- `componentWillUpdate()`  

â¡ï¸ Stattdessen: moderne Methoden oder `useEffect` in Funktionskomponenten verwenden.

---

## ğŸ” Lifecycle in Funktionskomponenten

Mit **`useEffect()`** kÃ¶nnen alle drei Phasen abgebildet werden:

```jsx
useEffect(() => {
  // Mounting & Updating
  return () => {
    // Unmounting
  };
}, [dependencies]);
```

- Kein zweiter Parameter â†’ bei jedem Render
- Leeres Array `[]` â†’ nur beim Mount
- Mit RÃ¼ckgabefunktion â†’ beim Unmount

---

## ğŸ“ Zusammenfassung

| Phase       | Methode (Klasse)             | Hook (Funktion)         |
|-------------|------------------------------|-------------------------|
| Mounting    | `constructor`, `componentDidMount` | `useEffect(() => {...}, [])` |
| Updating    | `componentDidUpdate`         | `useEffect(() => {...}, [dep])` |
| Unmounting  | `componentWillUnmount`       | `useEffect(() => {... return () => {...} })` |

---

## ğŸ”— Quellen

- [Komponenten-Lebenszyklus â€“ React Docs](https://react.dev/learn/referencing-values-with-refs#synchronizing-with-effects)  
- [MDN: Lebenszyklusmethoden in Klassenkomponenten](https://developer.mozilla.org/de/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_components#lebenszyklusmethoden)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

42. ### <a name="42"></a> Welche Lifecycle-Methoden gibt es in Klassenkomponenten?

# Welche Lifecycle-Methoden gibt es in Klassenkomponenten?

In **React-Klassenkomponenten** sind **Lifecycle-Methoden** spezielle Funktionen,  
die automatisch zu bestimmten Zeitpunkten im **Lebenszyklus einer Komponente** aufgerufen werden.

---

## ğŸ§­ Ãœbersicht: Lifecycle-Phasen & Methoden

### 1. ğŸ—ï¸ Mounting (EinfÃ¼gen in den DOM)

| Methode                 | Beschreibung                                      |
|-------------------------|---------------------------------------------------|
| `constructor()`         | Initialisiert State und bindet Methoden           |
| `static getDerivedStateFromProps()` | Reagiert auf Props vor dem ersten Render (selten genutzt) |
| `render()`              | Gibt JSX zurÃ¼ck                                   |
| `componentDidMount()`   | Wird **nach dem ersten Render** aufgerufen (z.â€¯B. Daten laden) |

---

### 2. ğŸ”„ Updating (Wenn Props oder State sich Ã¤ndern)

| Methode                        | Beschreibung                                                |
|--------------------------------|-------------------------------------------------------------|
| `static getDerivedStateFromProps()` | (auch hier nutzbar â€“ selten nÃ¶tig)                   |
| `shouldComponentUpdate()`      | Steuert, ob neu gerendert werden soll (Performance)         |
| `render()`                     | Gibt aktualisiertes JSX zurÃ¼ck                              |
| `getSnapshotBeforeUpdate()`    | Erfasst DOM-Infos vor dem Update (z.â€¯B. Scrollposition)      |
| `componentDidUpdate()`         | Wird **nach jedem Update** aufgerufen                       |

---

### 3. âŒ Unmounting (Entfernen aus dem DOM)

| Methode                 | Beschreibung                                        |
|-------------------------|-----------------------------------------------------|
| `componentWillUnmount()`| AufrÃ¤umen (Timer lÃ¶schen, EventListener entfernen etc.) |

---

### 4. âš ï¸ Legacy-Methoden (veraltet, nicht mehr empfohlen)

| Methode                    | Hinweis                                               |
|----------------------------|-------------------------------------------------------|
| `componentWillMount()`     | ersetzt durch `constructor()`                        |
| `componentWillReceiveProps()` | ersetzt durch `getDerivedStateFromProps()`       |
| `componentWillUpdate()`    | ersetzt durch `getSnapshotBeforeUpdate()`            |

â¡ï¸ Diese Methoden sind **deprecated** und in neuem Code **nicht mehr verwenden**.

---

## ğŸ“ Zusammenfassung

| Phase        | Wichtige Methoden                              |
|--------------|-------------------------------------------------|
| Mounting     | `constructor`, `render`, `componentDidMount`   |
| Updating     | `shouldComponentUpdate`, `render`, `componentDidUpdate` |
| Unmounting   | `componentWillUnmount`                         |

Nutze in neuen Projekten **Funktionskomponenten mit `useEffect()`**, wann immer mÃ¶glich.

---

## ğŸ”— Quellen

- [Lifecycle-Methoden â€“ React Docs](https://react.dev/reference/react/Component)  
- [MDN: Komponentenlebenszyklus](https://developer.mozilla.org/de/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_components#lebenszyklusmethoden)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

43. ### <a name="43"></a> Welche Lifecycle-Methoden sind veraltet?

# Welche Lifecycle-Methoden sind veraltet?

React hat mit Version **16.3** einige Lifecycle-Methoden als **veraltet (deprecated)** markiert,  
weil sie zu **Fehlverhalten** oder **unerwarteten Updates** fÃ¼hren konnten â€“ insbesondere mit **asynchronem Rendering (z.â€¯B. Concurrent Mode)**.

---

## âš ï¸ Veraltete Lifecycle-Methoden

| Methode                    | Status            | Empfehlung                     |
|----------------------------|-------------------|--------------------------------|
| `componentWillMount()`     | âŒ Veraltet        | Verwende stattdessen `constructor` oder `componentDidMount` |
| `componentWillReceiveProps(nextProps)` | âŒ Veraltet | Ersetze durch `getDerivedStateFromProps(nextProps, state)` |
| `componentWillUpdate(nextProps, nextState)` | âŒ Veraltet | Ersetze durch `getSnapshotBeforeUpdate(prevProps, prevState)` |

---

## ğŸ“¦ Warum wurden sie entfernt?

- Sie wurden **vor dem eigentlichen Rendern** aufgerufen  
- Bei **asynchronem Rendering** (React 18+) kÃ¶nnen sie mehrfach oder verspÃ¤tet aufgerufen werden  
- Das fÃ¼hrte zu **Seiteneffekten** (z.â€¯B. doppelte Datenanforderungen)

---

## ğŸ”„ Alternativen

| Veraltete Methode         | Alternative                             |
|---------------------------|------------------------------------------|
| `componentWillMount()`    | `constructor()` oder `componentDidMount()` |
| `componentWillReceiveProps()` | `getDerivedStateFromProps()`        |
| `componentWillUpdate()`   | `getSnapshotBeforeUpdate()` + `componentDidUpdate()` |

---

## ğŸ§  Hinweis

React fÃ¼hrt diese Methoden in bestimmten Build-Tools mit dem PrÃ¤fix **`UNSAFE_`** weiter,  
z.â€¯B. `UNSAFE_componentWillMount()` â€“ **diese solltest du aber vermeiden!**

---

## ğŸ“ Zusammenfassung

Folgende Methoden gelten als **veraltet**:

- `componentWillMount()`  
- `componentWillReceiveProps()`  
- `componentWillUpdate()`

Stattdessen solltest du **neue Lifecycle-Methoden** oder **Hooks wie `useEffect()`** in Funktionskomponenten verwenden.

---

## ğŸ”— Quellen

- [React Docs â€“ Legacy Lifecycle Methods](https://reactjs.org/docs/react-component.html#legacy-lifecycle-methods)  
- [React Blog â€“ Update on Async Rendering](https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

44. ### <a name="44"></a> Wie kann man Lifecycle-Methoden mit Hooks ersetzen?

# Wie kann man Lifecycle-Methoden mit Hooks ersetzen?

In **Funktionskomponenten** verwendet man den **Hook `useEffect()`**, um Verhalten zu implementieren,  
das frÃ¼her in **Lifecycle-Methoden von Klassenkomponenten** enthalten war.

---

## ğŸ” Vergleich: Klassenmethoden vs. `useEffect`

| Klassenkomponente               | Funktionskomponente mit Hook         |
|----------------------------------|--------------------------------------|
| `componentDidMount()`            | `useEffect(() => { ... }, [])`       |
| `componentDidUpdate()`           | `useEffect(() => { ... }, [deps])`   |
| `componentWillUnmount()`         | `useEffect(() => { return () => {...} }, [])` |
| `componentDidUpdate()` (spezifisch) | `useEffect()` mit bestimmten AbhÃ¤ngigkeiten |

---

## ğŸ’¡ Beispiel 1: `componentDidMount`

```jsx
useEffect(() => {
  console.log('Komponente wurde gemountet');
}, []);
```

â¡ï¸ Wird **nur einmal beim Mount** aufgerufen (`[]` = leere AbhÃ¤ngigkeiten)

---

## ğŸ’¡ Beispiel 2: `componentDidUpdate`

```jsx
useEffect(() => {
  console.log('State oder Prop wurde geÃ¤ndert');
}, [value]);
```

â¡ï¸ Wird aufgerufen, wenn sich `value` Ã¤ndert

---

## ğŸ’¡ Beispiel 3: `componentWillUnmount`

```jsx
useEffect(() => {
  return () => {
    console.log('Komponente wird entfernt');
  };
}, []);
```

â¡ï¸ RÃ¼ckgabefunktion von `useEffect` = **AufrÃ¤umcode (Cleanup)**

---

## ğŸ” Kombinierte Nutzung

```jsx
useEffect(() => {
  // Mount & Update
  console.log('Mount oder Update');

  return () => {
    // Unmount
    console.log('Cleanup bei Unmount oder vor nÃ¤chstem Update');
  };
}, [someValue]);
```

---

## ğŸ§  Hinweis

- `useEffect()` kann **mehrmals pro Komponente verwendet** werden
- Nutze **mehrere `useEffect`-BlÃ¶cke** fÃ¼r klar getrennte Logik (z.â€¯B. Daten laden, Events, Timer)

---

## ğŸ“ Zusammenfassung

Lifecycle-Methoden in Klassenkomponenten werden durch **`useEffect`** ersetzt.  
Je nach AbhÃ¤ngigkeitsarray (`[]`, `[dep]`, leer) kannst du steuern, ob der Code beim **Mount**, **Update** oder **Unmount** ausgefÃ¼hrt wird.

---

## ğŸ”— Quellen

- [useEffect â€“ React Docs](https://react.dev/reference/react/useEffect)  
- [Effekte verstehen â€“ react.dev](https://react.dev/learn/synchronizing-with-effects)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

45. ### <a name="45"></a> Was ist componentDidMount und was ist das Ã„quivalent mit Hooks?

# Was ist `componentDidMount` und was ist das Ã„quivalent mit Hooks?

## ğŸ“Œ `componentDidMount` (in Klassenkomponenten)

`componentDidMount()` ist eine **Lifecycle-Methode**, die aufgerufen wird,  
**nachdem** die Komponente **zum ersten Mal** in den DOM eingefÃ¼gt wurde.

### Typische AnwendungsfÃ¤lle:

- Daten vom Server laden (API-Aufrufe)
- Event-Listener registrieren
- Initiale DOM-Manipulation (z.â€¯B. Fokus setzen)

### Beispiel (Klasse):

```jsx
class MyComponent extends React.Component {
  componentDidMount() {
    console.log('Komponente wurde gemountet');
  }

  render() {
    return <div>Hallo</div>;
  }
}
```

---

## âœ… Ã„quivalent mit Hooks: `useEffect(() => { ... }, [])`

In **Funktionskomponenten** erreichst du das gleiche Verhalten mit dem Hook `useEffect`  
und einem **leeren AbhÃ¤ngigkeitsarray (`[]`)**.

### Beispiel (Funktion):

```jsx
import { useEffect } from 'react';

function MyComponent() {
  useEffect(() => {
    console.log('Komponente wurde gemountet');
  }, []);

  return <div>Hallo</div>;
}
```

â¡ï¸ Der Effekt wird **nur einmal beim ersten Render** ausgefÃ¼hrt â€“ genau wie `componentDidMount`.

---

## ğŸ“ Zusammenfassung

| Klassenkomponente              | Funktionskomponente           |
|--------------------------------|-------------------------------|
| `componentDidMount()`          | `useEffect(() => { ... }, [])` |

Beide Varianten eignen sich fÃ¼r **initiale Logik**, die **nur einmal** beim Mounting ausgefÃ¼hrt werden soll.

---

## ğŸ”— Quellen

- [componentDidMount â€“ React Docs](https://react.dev/reference/react/Component#componentdidmount)  
- [useEffect Hook â€“ React Docs](https://react.dev/reference/react/useEffect)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

46. ### <a name="46"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

47. ### <a name="47"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

48. ### <a name="48"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

49. ### <a name="49"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

50. ### <a name="50"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**  

51. ### <a name="51"></a> Was sind Hooks in React?

# Was sind Hooks in React?

**Hooks** sind **Funktionen**, die es dir ermÃ¶glichen, in **Funktionskomponenten** von React  
**State** und andere **React-Funktionen** zu verwenden â€“ **ohne Klassen zu schreiben**.

Sie wurden mit **React 16.8** eingefÃ¼hrt.

---

## ğŸ¯ Warum Hooks?

Vor Hooks waren **Klassenkomponenten nÃ¶tig**, um z.â€¯B.:

- State zu verwalten
- Lifecycle-Methoden zu verwenden
- auf den DOM zuzugreifen

â¡ï¸ Mit Hooks kannst du das **alles auch in Funktionskomponenten** tun â€“ **einfacher, klarer, wiederverwendbarer**.

---

## ğŸ”§ Wichtige React-Hooks

| Hook            | Beschreibung                                    |
|------------------|-------------------------------------------------|
| `useState()`     | Lokaler Zustand (State)                        |
| `useEffect()`    | Nebenwirkungen / Lifecycle-Ersatz              |
| `useRef()`       | Zugriff auf DOM oder persistente Werte         |
| `useContext()`   | Zugriff auf globale Daten aus einem Context    |
| `useReducer()`   | Alternative zu `useState` fÃ¼r komplexeren State|
| `useMemo()`      | Ergebnis zwischenspeichern (Memoisierung)      |
| `useCallback()`  | Funktionen zwischenspeichern (verhindert Neu-Erstellung) |
| `useLayoutEffect()` | wie `useEffect`, aber synchron nach Layout  |

---

## ğŸ’¡ Beispiel: `useState` und `useEffect`

```jsx
import { useState, useEffect } from 'react';

function Timer() {
  const [seconds, setSeconds] = useState(0);

  useEffect(() => {
    const interval = setInterval(() => {
      setSeconds(s => s + 1);
    }, 1000);

    return () => clearInterval(interval); // AufrÃ¤umen bei Unmount
  }, []);

  return <p>Timer: {seconds} Sekunden</p>;
}
```

---

## ğŸ” Regeln fÃ¼r Hooks

1. âœ… Nur in **Funktionskomponenten oder eigenen Hooks** verwenden  
2. âœ… Nur **ganz oben im FunktionskÃ¶rper aufrufen** (nicht in Bedingungen, Schleifen, etc.)

---

## ğŸ“ Zusammenfassung

**Hooks** sind moderne Werkzeuge, um **State, Effekte und andere React-FunktionalitÃ¤ten**  
in **Funktionskomponenten** zu nutzen â€“ ohne Klassen.  
Sie machen Komponenten **einfacher, flexibler und wiederverwendbar**.

---

## ğŸ”— Quellen

- [EinfÃ¼hrung in Hooks â€“ react.dev](https://react.dev/learn/state-a-components-memory)  
- [Alle React-Hooks â€“ React Docs](https://react.dev/reference/react)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

52. ### <a name="52"></a> Wie funktionieren useState und useEffect?

# Wie funktionieren `useState` und `useEffect`?

Die Hooks **`useState`** und **`useEffect`** gehÃ¶ren zu den wichtigsten Bausteinen  
in React-Funktionskomponenten.  
Sie ersetzen `this.state` und Lifecycle-Methoden wie `componentDidMount`.

---

## ğŸ§  `useState` â€“ Zustand in Funktionskomponenten

Mit `useState` kannst du **lokale ZustÃ¤nde (State)** in einer Komponente erstellen und aktualisieren.

### Syntax:

```jsx
const [state, setState] = useState(anfangsWert);
```

- `state`: aktueller Wert
- `setState`: Funktion zum Ã„ndern des Werts
- `useState(...)`: Initialwert beim ersten Render

### Beispiel:

```jsx
const [count, setCount] = useState(0);

<button onClick={() => setCount(count + 1)}>
  Geklickt: {count}
</button>
```

â¡ï¸ Jeder `setCount(...)` lÃ¶st ein Re-Rendern der Komponente aus.

---

## âš™ï¸ `useEffect` â€“ Nebenwirkungen / Lifecycle-Ersatz

`useEffect` fÃ¼hrt **Seiteneffekte (Effects)** aus, z.â€¯B.:

- API-Aufrufe
- EventListener setzen
- Timer starten
- Cleanup beim Unmount

### Syntax:

```jsx
useEffect(() => {
  // Code beim Mount oder Update

  return () => {
    // Cleanup beim Unmount
  };
}, [abhÃ¤ngigkeiten]);
```

---

## ğŸ’¡ Beispiel: `useState` + `useEffect`

```jsx
import { useState, useEffect } from 'react';

function Timer() {
  const [seconds, setSeconds] = useState(0);

  useEffect(() => {
    const interval = setInterval(() => {
      setSeconds(s => s + 1);
    }, 1000);

    return () => clearInterval(interval); // AufrÃ¤umen beim Unmount
  }, []);

  return <p>Zeit: {seconds} Sek.</p>;
}
```

- â±ï¸ Timer startet beim Mount (`[]`)
- â›” AufrÃ¤umen mit `clearInterval` beim Unmount

---

## ğŸ“ Zusammenfassung

| Hook        | Zweck                               | Wird verwendet fÃ¼r                       |
|-------------|--------------------------------------|-------------------------------------------|
| `useState`  | Lokalen Zustand speichern            | ZÃ¤hler, Formulare, Flags usw.             |
| `useEffect` | Effekte und Lifecycle-Verhalten      | Daten laden, Timer, Event-Handling, Cleanup |

---

## ğŸ”— Quellen

- [useState â€“ React Docs](https://react.dev/reference/react/useState)  
- [useEffect â€“ React Docs](https://react.dev/reference/react/useEffect)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

53. ### <a name="53"></a> Was macht useContext?

# Was macht `useContext`?

Der Hook **`useContext`** ermÃ¶glicht dir den **Zugriff auf globale Daten** (z.â€¯B. Theme, Sprache, User),  
die mit Reacts **Context API** bereitgestellt werden â€“ **ohne Props manuell durch alle Komponenten zu leiten**.

---

## ğŸ¯ Warum `useContext`?

- âœ… Vermeidet **Prop-Drilling** (Props durch viele Ebenen weitergeben)  
- âœ… ErmÃ¶glicht Zugriff auf **globale ZustÃ¤nde oder Konfigurationen**  
- âœ… Macht den Code **lesbarer und wartbarer**

---

## ğŸ§± Funktionsweise

1. âœ… Erstelle einen Context mit `React.createContext()`  
2. âœ… Umgib die betroffenen Komponenten mit dem `<Provider>`  
3. âœ… Verwende `useContext(...)` in einer Komponente, um auf die Werte zuzugreifen

---

## ğŸ’¡ Beispiel

```jsx
import { createContext, useContext } from 'react';

// 1. Context erstellen
const ThemeContext = createContext('light');

function App() {
  return (
    // 2. Context-Provider mit aktuellem Wert
    <ThemeContext.Provider value="dark">
      <Toolbar />
    </ThemeContext.Provider>
  );
}

function Toolbar() {
  return (
    <div>
      <ThemeButton />
    </div>
  );
}

// 3. useContext verwenden
function ThemeButton() {
  const theme = useContext(ThemeContext);
  return <button className={theme}>Theme: {theme}</button>;
}
```

â¡ï¸ `ThemeButton` erhÃ¤lt den Wert **direkt aus dem Kontext**, **ohne Props** von `App â†’ Toolbar â†’ ThemeButton`.

---

## ğŸ§  Wichtig

- `useContext` **abonniert** den Context â€“ bei Ã„nderungen wird die Komponente **neu gerendert**
- Der Context-Wert kann **beliebige Datentypen enthalten** (String, Object, Funktion, etc.)

---

## ğŸ“ Zusammenfassung

- `useContext` liest Werte aus einem **React Context**  
- Ideal, um globale Daten wie Theme, Sprache oder Authentifizierung zu teilen  
- Vermeidet manuelles Weitergeben von Props durch die Komponenten-Hierarchie

---

## ğŸ”— Quellen

- [useContext â€“ React Docs](https://react.dev/reference/react/useContext)  
- [Context API â€“ React Docs](https://react.dev/learn/passing-data-deeply-with-context)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

54. ### <a name="54"></a> Was ist useRef und wann wird es verwendet?

# Was ist `useRef` und wann wird es verwendet?

Der Hook **`useRef`** wird in React verwendet, um **eine Referenz auf ein DOM-Element** oder **einen stabilen Wert** zu speichern,  
der **Ã¼ber Re-Renders hinweg erhalten bleibt**, ohne ein Re-Render auszulÃ¶sen.

---

## ğŸ“¦ Was macht `useRef`?

- Erstellt ein **ref-Objekt**: `{ current: ... }`
- Wird **nicht beim Re-Render verÃ¤ndert**
- Wird **nicht automatisch im UI angezeigt**
- Kann sowohl fÃ¼r **DOM-Zugriff** als auch fÃ¼r **persistente Werte** verwendet werden

---

## ğŸ’¡ AnwendungsfÃ¤lle

### 1. ğŸ“Œ Zugriff auf DOM-Elemente

```jsx
import { useRef, useEffect } from 'react';

function InputFocus() {
  const inputRef = useRef();

  useEffect(() => {
    inputRef.current.focus(); // Fokus setzen beim Mount
  }, []);

  return <input ref={inputRef} />;
}
```

â¡ï¸ Zugriff auf das echte DOM-Element, ohne `document.querySelector`.

---

### 2. ğŸ¯ Persistente Werte zwischen Renders (ohne Re-Render auszulÃ¶sen)

```jsx
const renderCount = useRef(0);
renderCount.current++;
console.log('Render: ', renderCount.current);
```

â¡ï¸ Ideal z.â€¯B. fÃ¼r ZÃ¤hler, Timer-IDs, vorherige Werte usw.

---

### 3. ğŸ§¹ AufrÃ¤um-Referenzen

```jsx
const intervalId = useRef();

useEffect(() => {
  intervalId.current = setInterval(...);

  return () => clearInterval(intervalId.current);
}, []);
```

â¡ï¸ Praktisch fÃ¼r Cleanup-Logik in `useEffect`.

---

## ğŸ” Vergleich zu `state`

| Hook      | Re-Renders bei Ã„nderung? | Persistiert zwischen Renders? | Typischer Anwendungsfall         |
|-----------|---------------------------|-------------------------------|----------------------------------|
| `useState`| âœ… Ja                     | âœ… Ja                          | UI-ZustÃ¤nde                     |
| `useRef`  | âŒ Nein                   | âœ… Ja                          | DOM-Zugriff, Werte auÃŸerhalb der UI |

---

## ğŸ“ Zusammenfassung

- `useRef` wird verwendet fÃ¼r:
  - **DOM-Zugriff**
  - **Zwischenspeicherung von Werten ohne Re-Renders**
  - **Cleanup / Speichern von IDs, vorherigen Werten etc.**
- Das ref-Objekt hat eine `.current`-Eigenschaft, die verÃ¤ndert werden kann, ohne UI zu beeinflussen

---

## ğŸ”— Quellen

- [useRef â€“ React Docs](https://react.dev/reference/react/useRef)  
- [React: Refs und DOM â€“ react.dev](https://react.dev/learn/referencing-values-with-refs)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

55. ### <a name="55"></a> Was ist useCallback, useMemo, useReducer?

# Was ist `useCallback`, `useMemo`, `useReducer`?

Diese drei React-Hooks sind **fortgeschrittene Werkzeuge**,  
die helfen, **Performance zu optimieren** oder **komplexeren State** zu verwalten.

---

## âœ… `useCallback`

`useCallback(fn, deps)` gibt eine **zwischengespeicherte (memoisierte)** Version der Funktion `fn` zurÃ¼ck,  
die **nur neu erstellt wird**, wenn sich eine der **AbhÃ¤ngigkeiten (`deps`)** Ã¤ndert.

### Zweck:
- âœ… Verhindert **unnÃ¶tige Neudefinition** von Funktionen
- âœ… Vermeidet **unnÃ¶tige Re-Renders** von Kindkomponenten, die Funktionen als Props bekommen

### Beispiel:

```jsx
const handleClick = useCallback(() => {
  console.log('Geklickt!');
}, []);
```

---

## âœ… `useMemo`

`useMemo(() => result, deps)` berechnet und speichert einen **Wert**,  
und **berechnet ihn nur neu**, wenn sich eine AbhÃ¤ngigkeit Ã¤ndert.

### Zweck:
- âœ… Vermeidet **teure Berechnungen bei jedem Render**
- âœ… Liefert **stabilen Wert** Ã¼ber mehrere Renders hinweg

### Beispiel:

```jsx
const sortedItems = useMemo(() => {
  return items.sort((a, b) => a.value - b.value);
}, [items]);
```

---

## âœ… `useReducer`

`useReducer(reducer, initialState)` ist eine Alternative zu `useState`,  
die sich besonders bei **komplexem State oder mehreren abhÃ¤ngigen ZustÃ¤nden** lohnt.

### Zweck:
- âœ… Klare Struktur fÃ¼r **State-Management**
- âœ… Ã„hnlich wie `Redux`-Reducer

### Beispiel:

```jsx
function reducer(state, action) {
  switch (action.type) {
    case 'increment': return { count: state.count + 1 };
    case 'decrement': return { count: state.count - 1 };
    default: return state;
  }
}

const [state, dispatch] = useReducer(reducer, { count: 0 });

<button onClick={() => dispatch({ type: 'increment' })}>
  {state.count}
</button>
```

---

## ğŸ” Vergleich

| Hook         | Zweck                                  | Typischer Einsatz                    |
|--------------|-----------------------------------------|--------------------------------------|
| `useCallback`| Funktion nur bei Bedarf neu erstellen   | Callback-Props, Performance-Tuning   |
| `useMemo`    | Teure Berechnung nur bei Ã„nderung       | sortieren, filtern, berechnen        |
| `useReducer` | Komplexen State zentral verwalten       | Formulare, komplexe Logik, Redux-Ersatz |

---

## ğŸ“ Zusammenfassung

- `useCallback`: Memoisiert Funktionen  
- `useMemo`: Memoisiert Werte  
- `useReducer`: Komplexes State-Management mit einer zentralen Logik

Diese Hooks verbessern **Performance und Struktur** bei wachsender App-KomplexitÃ¤t.

---

## ğŸ”— Quellen

- [useCallback â€“ React Docs](https://react.dev/reference/react/useCallback)  
- [useMemo â€“ React Docs](https://react.dev/reference/react/useMemo)  
- [useReducer â€“ React Docs](https://react.dev/reference/react/useReducer)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

56. ### <a name="56"></a> Wie schreibt man einen benutzerdefinierten Hook?

# Wie schreibt man einen benutzerdefinierten Hook?

Ein **benutzerdefinierter Hook** (engl. *custom hook*) ist eine **eigene JavaScript-Funktion**,  
die **andere Hooks verwendet**, um **wiederverwendbare Logik** aus React-Komponenten auszulagern.

---

## ğŸ¯ Warum benutzerdefinierte Hooks?

- âœ… Wiederverwendbare Logik kapseln (z.â€¯B. Formular, API, Timer)
- âœ… Komponenten schlanker und verstÃ¤ndlicher machen
- âœ… Mehrere Hooks gemeinsam verwenden

---

## ğŸ“¦ Regeln fÃ¼r eigene Hooks

1. Beginnt immer mit `use` (z.â€¯B. `useForm`, `useTimer`)  
2. Darf **nur innerhalb von Funktionskomponenten oder anderen Hooks** aufgerufen werden  
3. Nutzt beliebige andere React-Hooks (`useState`, `useEffect`, `useRef`, usw.)

---

## ğŸ’¡ Beispiel: `useWindowWidth`

```jsx
import { useState, useEffect } from 'react';

function useWindowWidth() {
  const [width, setWidth] = useState(window.innerWidth);

  useEffect(() => {
    function handleResize() {
      setWidth(window.innerWidth);
    }

    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  return width;
}
```

â¡ï¸ Dieser Hook liefert die **aktuelle Fensterbreite** und aktualisiert sie automatisch bei Resize.

---

## âœ… Verwendung in Komponente

```jsx
function App() {
  const width = useWindowWidth();

  return <p>Fensterbreite: {width}px</p>;
}
```

---

## ğŸ” Beispiel: `useLocalStorage`

```jsx
function useLocalStorage(key, initialValue) {
  const [value, setValue] = useState(() => {
    const saved = localStorage.getItem(key);
    return saved ? JSON.parse(saved) : initialValue;
  });

  useEffect(() => {
    localStorage.setItem(key, JSON.stringify(value));
  }, [key, value]);

  return [value, setValue];
}
```

â¡ï¸ Verwaltet einen State **synchron mit localStorage**.

---

## ğŸ“ Zusammenfassung

- Benutzerdefinierte Hooks sind **Funktionen mit eigenen Namen**, die andere Hooks enthalten
- Sie dienen der **Wiederverwendung von Logik**
- Sie **starten immer mit `use`**
- Sie machen Komponenten **sauberer, testbarer und wartbarer**

---

## ğŸ”— Quellen

- [Eigene Hooks erstellen â€“ React Docs](https://react.dev/learn/reusing-logic-with-custom-hooks)  
- [Custom Hooks â€“ React API Docs](https://react.dev/reference/react#custom-hooks)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

57. ### <a name="57"></a> Wie verhindert man eine Endlosschleife in useEffect?

# Wie verhindert man eine Endlosschleife in `useEffect`?

Eine **Endlosschleife** in `useEffect` entsteht meist dann, wenn der Effekt bei jedem Render erneut ausgefÃ¼hrt wird,  
weil sich eine **AbhÃ¤ngigkeit stÃ¤ndig verÃ¤ndert** oder **nicht korrekt definiert wurde**.

---

## âš ï¸ Ursachen fÃ¼r Endlosschleifen

### 1. âŒ Fehlende AbhÃ¤ngigkeitsliste

```jsx
useEffect(() => {
  fetchData(); // Wird bei jedem Render erneut aufgerufen!
});
```

â¡ï¸ Ohne `[]` wird der Effekt **bei jedem Render** ausgefÃ¼hrt â†’ Endlosschleife mÃ¶glich.

---

### 2. âŒ AbhÃ¤ngigkeit verÃ¤ndert sich bei jedem Render

```jsx
useEffect(() => {
  const data = { id: 1 }; // neues Objekt bei jedem Render
  doSomething(data);
}, [{ id: 1 }]);
```

â¡ï¸ Das Objekt `{ id: 1 }` ist **bei jedem Render neu** â†’ `useEffect` wird stÃ¤ndig neu ausgefÃ¼hrt.

---

## âœ… LÃ¶sungen

### âœ… 1. Leeres Array (`[]`) â†’ nur beim Mount

```jsx
useEffect(() => {
  fetchData(); // wird nur einmal ausgefÃ¼hrt
}, []);
```

â¡ï¸ Effekt lÃ¤uft **nur beim ersten Render**

---

### âœ… 2. Stabile AbhÃ¤ngigkeiten verwenden

Vermeide Funktionen/Objekte als AbhÃ¤ngigkeiten, **wenn sie bei jedem Render neu erzeugt werden**.

### Statt:

```jsx
useEffect(() => {
  doSomething(() => {});
}, []);
```

### Besser:

```jsx
const stableFn = useCallback(() => {
  doSomething();
}, []);

useEffect(() => {
  stableFn();
}, [stableFn]);
```

---

### âœ… 3. Werte in `useRef` speichern, die keinen Re-Render auslÃ¶sen sollen

```jsx
const dataRef = useRef({ id: 1 });

useEffect(() => {
  doSomething(dataRef.current);
}, []);
```

---

## ğŸ“ Zusammenfassung

Um Endlosschleifen in `useEffect` zu vermeiden:

- âœ… Nutze ein **leeres AbhÃ¤ngigkeitsarray `[]`** fÃ¼r einmalige AusfÃ¼hrung
- âœ… **Memoisiere Funktionen oder Objekte** mit `useCallback` oder `useMemo`
- âœ… Verwende `useRef`, wenn keine ReaktivitÃ¤t notwendig ist
- âŒ Vermeide **direkte Objekterzeugung** oder **Funktionen** in der AbhÃ¤ngigkeitsliste

---

## ğŸ”— Quellen

- [useEffect â€“ React Docs](https://react.dev/reference/react/useEffect)  
- [Effekt-AbhÃ¤ngigkeiten verstehen â€“ react.dev](https://react.dev/learn/synchronizing-with-effects#specifying-dependencies)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

58. ### <a name="58"></a> Wie implementiert man Timeout oder Interval mit Hooks?

# Wie implementiert man `setTimeout` oder `setInterval` mit Hooks?

Mit **`useEffect`** und **`useRef`** kannst du in Funktionskomponenten sauber **Timeouts** und **Intervalle** verwalten â€“  
inklusive **automatischem AufrÃ¤umen** beim Unmount.

---

## â±ï¸ `setTimeout` mit `useEffect`

```jsx
import { useEffect } from 'react';

function TimeoutExample() {
  useEffect(() => {
    const timeoutId = setTimeout(() => {
      console.log('Einmaliger Timeout nach 3 Sekunden');
    }, 3000);

    return () => clearTimeout(timeoutId); // Cleanup bei Unmount
  }, []);

  return <p>Warte auf Timeoutâ€¦</p>;
}
```

â¡ï¸ Der Effekt wird **nur einmal** beim Mount ausgefÃ¼hrt (`[]`).

---

## ğŸ” `setInterval` mit `useEffect`

```jsx
import { useEffect, useState } from 'react';

function IntervalExample() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const intervalId = setInterval(() => {
      setCount(c => c + 1); // Immer aktuellen Wert verwenden
    }, 1000);

    return () => clearInterval(intervalId); // AufrÃ¤umen beim Unmount
  }, []);

  return <p>ZÃ¤hler: {count}</p>;
}
```

â¡ï¸ Der Intervall wird beim Mount gestartet und beim Unmount gestoppt.

---

## ğŸ’¡ Tipp: `useRef` fÃ¼r Zugriff auf aktuelle Werte

FÃ¼r erweiterte Kontrolle (z.â€¯B. stoppen/starten), verwende `useRef`:

```jsx
const intervalRef = useRef();

useEffect(() => {
  intervalRef.current = setInterval(() => {
    ...
  }, 1000);

  return () => clearInterval(intervalRef.current);
}, []);
```

---

## ğŸ“ Zusammenfassung

| Ziel          | Hook             | Beschreibung                          |
|---------------|------------------|----------------------------------------|
| `setTimeout`  | `useEffect`      | Einmalige VerzÃ¶gerung                  |
| `setInterval` | `useEffect`      | Wiederholende Aktion mit Cleanup       |
| Kontrolle     | `useRef`         | ID speichern, Zugriff auf aktuellen Zustand |

---

## ğŸ”— Quellen

- [useEffect â€“ React Docs](https://react.dev/reference/react/useEffect)  
- [MDN â€“ setTimeout](https://developer.mozilla.org/de/docs/Web/API/setTimeout)  
- [MDN â€“ setInterval](https://developer.mozilla.org/de/docs/Web/API/setInterval)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

59. ### <a name="59"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

60. ### <a name="60"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

61. ### <a name="61"></a> Was ist ein Higher-Order Component (HOC)?

# Was ist ein Higher-Order Component (HOC)?

Ein **Higher-Order Component (HOC)** ist ein **Designmuster in React**,  
bei dem **eine Funktion eine Komponente nimmt und eine neue, erweiterte Komponente zurÃ¼ckgibt**.

---

## ğŸ¯ Zweck eines HOC

- âœ… **Wiederverwendbare Logik** auf mehrere Komponenten anwenden  
- âœ… Komponenten **mit zusÃ¤tzlichen Props, Verhalten oder Styling** erweitern  
- âœ… Trennung von ZustÃ¤ndigkeiten (Separation of Concerns)

---

## ğŸ“¦ Definition

```js
const EnhancedComponent = withSomething(WrappedComponent);
```

â¡ï¸ `withSomething` ist das HOC, `WrappedComponent` ist die Originalkomponente.

---

## ğŸ’¡ Einfaches Beispiel: `withLogger`

```jsx
function withLogger(WrappedComponent) {
  return function EnhancedComponent(props) {
    console.log('Props:', props);
    return <WrappedComponent {...props} />;
  };
}
```

### Verwendung:

```jsx
const LoggedButton = withLogger(Button);
```

â¡ï¸ Jedes Mal, wenn `LoggedButton` verwendet wird, werden die Props geloggt.

---

## ğŸ” Typische AnwendungsfÃ¤lle

- Zugriffsschutz (z.â€¯B. `withAuth`)
- Theming (z.â€¯B. `withTheme`)
- Logging & Analytics
- Fehlerbehandlung (`withErrorBoundary`)
- Datenanbindung (z.â€¯B. `connect()` in Redux)

---

## âš ï¸ Hinweise

- HOCs **verÃ¤ndern nicht** die ursprÃ¼ngliche Komponente, sondern **verpacken sie**
- HOC **dÃ¼rfen keine Seiteneffekte beim Rendern haben**
- Der **Komponentenname sollte erhalten bleiben** (z.â€¯B. mit `displayName`), fÃ¼r Debugging

---

## ğŸ“ Zusammenfassung

Ein **Higher-Order Component (HOC)** ist eine Funktion,  
die eine Komponente nimmt und **eine neue Komponente mit erweitertem Verhalten** zurÃ¼ckgibt.  
Sie ist ein mÃ¤chtiges Werkzeug zur **Wiederverwendung von Logik und Struktur**.

---

## ğŸ”— Quellen

- [React Docs â€“ Higher-Order Components](https://reactjs.org/docs/higher-order-components.html)  
- [MDN â€“ React Komponentendesignmuster](https://developer.mozilla.org/de/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_components#higher-order-components)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

62. ### <a name="62"></a> Was ist das Render-Prop-Pattern?

# Was ist das Render-Prop-Pattern?

Das **Render-Prop-Pattern** ist ein **React-Designmuster**,  
bei dem eine Komponente eine **Funktion als Prop (render prop)** erhÃ¤lt,  
um **flexibel zu steuern, was gerendert werden soll**.

---

## ğŸ¯ Zweck des Patterns

- âœ… ErmÃ¶glicht das **Teilen von wiederverwendbarer Logik**
- âœ… Gibt der Elternkomponente die **volle Kontrolle Ã¼ber das gerenderte UI**
- âœ… Alternative zu HOCs oder Hooks bei **logikbasiertem Code-Sharing**

---

## ğŸ“¦ Struktur

```jsx
<MyComponent render={(data) => (
  <p>{data.message}</p>
)} />
```

Oder via `children`-Prop:

```jsx
<MyComponent>
  {(data) => <p>{data.message}</p>}
</MyComponent>
```

---

## ğŸ’¡ Beispiel: `MouseTracker` mit Render-Prop

```jsx
function MouseTracker({ render }) {
  const [position, setPosition] = useState({ x: 0, y: 0 });

  useEffect(() => {
    const handleMove = (e) => setPosition({ x: e.clientX, y: e.clientY });
    window.addEventListener('mousemove', handleMove);
    return () => window.removeEventListener('mousemove', handleMove);
  }, []);

  return render(position);
}
```

### Verwendung:

```jsx
<MouseTracker
  render={({ x, y }) => (
    <p>Position: {x}, {y}</p>
  )}
/>
```

---

## ğŸ” Vorteile gegenÃ¼ber HOC

| Aspekt               | Render-Prop             | HOC                           |
|----------------------|-------------------------|--------------------------------|
| Mehrfach verwendbar  | âœ… Ja                   | âœ… Ja                          |
| Flexibel im UI       | âœ… Sehr flexibel         | âŒ EingeschrÃ¤nkter UI-Zugriff |
| Komponentenbaum flach| âœ… Ja                   | âŒ Kann tiefe Wrapper erzeugen |

---

## âš ï¸ Nachteile

- Kann bei vielen Ebenen zu **"Wrapper Hell"** fÃ¼hren (Ã¤hnlich wie HOC)
- Wird heute oft durch **Hooks ersetzt**, da diese **einfacher und lesbarer** sind

---

## ğŸ“ Zusammenfassung

Das **Render-Prop-Pattern** ermÃ¶glicht das **Weitergeben von Logik Ã¼ber Funktionen als Props**.  
Die aufrufende Komponente entscheidet, **wie das UI aussehen soll**, wÃ¤hrend die Logik zentral bleibt.

---

## ğŸ”— Quellen

- [Render Props â€“ React Docs](https://reactjs.org/docs/render-props.html)  
- [React Patterns â€“ Render Props](https://reactpatterns.com/#render-callback)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

63. ### <a name="63"></a> Was ist die Context-API und wie funktioniert useContext?

# Was ist die Context-API und wie funktioniert `useContext`?

Die **Context-API** von React ist ein integrierter Mechanismus,  
um **globale Daten (z.â€¯B. Theme, Sprache, Benutzerinfos)**  
an beliebige Komponenten im Komponentenbaum **weiterzugeben**,  
**ohne Props manuell durch mehrere Ebenen zu reichen**.

---

## ğŸ¯ Warum Context?

- âœ… Vermeidet **Prop-Drilling**  
- âœ… Ideal fÃ¼r **globale ZustÃ¤nde oder Konfigurationen**  
- âœ… Einfach zu kombinieren mit `useContext`

---

## ğŸ§± Bestandteile der Context-API

1. **`createContext()`** â€“ erstellt einen neuen Kontext  
2. **`<Provider>`** â€“ stellt einen Wert zur VerfÃ¼gung  
3. **`useContext(Context)`** â€“ liest den aktuellen Wert des Kontexts

---

## ğŸ’¡ Beispiel: ThemeContext

### 1. Context erstellen:

```jsx
import { createContext } from 'react';

const ThemeContext = createContext('light'); // optionaler Default-Wert
```

---

### 2. Provider verwenden:

```jsx
function App() {
  return (
    <ThemeContext.Provider value="dark">
      <Toolbar />
    </ThemeContext.Provider>
  );
}
```

---

### 3. Zugriff mit `useContext`:

```jsx
import { useContext } from 'react';

function ThemeButton() {
  const theme = useContext(ThemeContext); // "dark"
  return <button className={theme}>Aktuelles Theme: {theme}</button>;
}
```

â¡ï¸ `ThemeButton` hat Zugriff auf den Kontextwert, ohne dass Props Ã¼ber `Toolbar` weitergegeben werden mÃ¼ssen.

---

## ğŸ“Œ Wichtig zu wissen

- Jeder Context-Wert ist **nur innerhalb seines `<Provider>` sichtbar**  
- Komponenten werden **neu gerendert**, wenn sich der Context-Wert Ã¤ndert  
- Context ist **nicht als globaler State-Ersatz fÃ¼r komplexe Logik** gedacht (â†’ besser: Redux, Zustand, etc.)

---

## ğŸ“ Zusammenfassung

- Die **Context-API** erlaubt das **Teilen globaler Werte** im Komponentenbaum  
- Mit `useContext(Context)` kannst du in Funktionskomponenten **einfach auf diese Werte zugreifen**  
- Sie ist nÃ¼tzlich fÃ¼r Dinge wie **Themen, Sprache, Benutzerinfo, Feature-Flags**

---

## ğŸ”— Quellen

- [Context â€“ React Docs](https://react.dev/learn/passing-data-deeply-with-context)  
- [useContext â€“ React Docs](https://react.dev/reference/react/useContext)  
- [MDN: Context in React](https://developer.mozilla.org/de/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_components#context)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

64. ### <a name="64"></a> Was sind Portale in React?

# Was sind Portale in React?

**Portale** (engl. *Portals*) in React ermÃ¶glichen es, **Komponenten auÃŸerhalb der normalen DOM-Hierarchie**  
zu rendern â€“ also **auÃŸerhalb des `div#root`**, aber trotzdem **vollstÃ¤ndig von React verwaltet**.

---

## ğŸ¯ Wann braucht man ein Portal?

- Modale Dialoge (z.â€¯B. `<Modal />`)  
- Tooltips  
- Dropdown-MenÃ¼s  
- Overlays  
- Elemente, die visuell **Ã¼ber anderen Komponenten liegen** mÃ¼ssen

â¡ï¸ Diese Elemente mÃ¼ssen oft **am Ende des `<body>`** gerendert werden, um korrekt zu funktionieren (z.â€¯B. Z-Index, Positionierung).

---

## ğŸ’¡ Beispiel: Portal verwenden

### 1. Ziel-Element im HTML

```html
<body>
  <div id="root"></div>
  <div id="modal-root"></div> <!-- Hier wird das Portal platziert -->
</body>
```

---

### 2. Komponente mit Portal

```jsx
import { createPortal } from 'react-dom';

function Modal({ children }) {
  return createPortal(
    <div className="modal">{children}</div>,
    document.getElementById('modal-root')
  );
}
```

---

### 3. Verwendung in der App

```jsx
function App() {
  return (
    <>
      <h1>Seite</h1>
      <Modal>
        <p>Ich werde auÃŸerhalb von #root gerendert!</p>
      </Modal>
    </>
  );
}
```

â¡ï¸ Das Modal wird **optisch auÃŸerhalb** des Hauptbaums gerendert,  
aber **logisch bleibt es Teil von React** â€“ inklusive Props, State, Events usw.

---

## ğŸ” Vorteile von Portalen

| Vorteil                    | Beschreibung                                       |
|----------------------------|----------------------------------------------------|
| ğŸ”„ Event-Bubbling bleibt   | Events funktionieren weiterhin wie gewohnt         |
| ğŸ¯ Flexibles Layout        | Bessere Positionierung im DOM                      |
| ğŸ”’ Kein CSS-ZusammenstoÃŸ   | Vermeidet Probleme mit `overflow: hidden`, `z-index` etc.

---

## ğŸ“ Zusammenfassung

- Portale rendern Komponenten **auÃŸerhalb des DOM-Hierarchie der Eltern**
- NÃ¼tzlich fÃ¼r **Modale, Tooltips, Overlays**
- Implementiert mit `ReactDOM.createPortal(element, domNode)`

---

## ğŸ”— Quellen

- [Portals â€“ React Docs](https://reactjs.org/docs/portals.html)  
- [MDN: DOM-Portale und Modale](https://developer.mozilla.org/de/docs/Web/HTML/Element/dialog)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

65. ### <a name="65"></a> Was ist bedingtes Rendern (Conditional Rendering)?

# Was ist bedingtes Rendern (Conditional Rendering) in React?

**Bedingtes Rendern** bedeutet in React, dass eine Komponente **abhÃ¤ngig von einer Bedingung**  
**unterschiedlichen JSX-Inhalt rendert** â€“ also **dynamisch entscheidet, was angezeigt wird**.

---

## ğŸ¯ Anwendungsbeispiele

- Benutzer ist **eingeloggt oder nicht**
- Ladevorgang (`Loading...`) vs. Datenanzeige
- Verschiedene UI-Elemente abhÃ¤ngig von Status, Rollen, Berechtigungen

---

## ğŸ”§ Methoden fÃ¼r bedingtes Rendern

### âœ… 1. `if`-Anweisung

```jsx
if (isLoggedIn) {
  return <Dashboard />;
} else {
  return <LoginForm />;
}
```

---

### âœ… 2. TernÃ¤rer Operator (`? :`)

```jsx
return (
  <div>
    {isLoading ? <p>Lade Daten...</p> : <DataList />}
  </div>
);
```

---

### âœ… 3. Logischer UND-Operator (`&&`)

```jsx
{hasPermission && <DeleteButton />}
```

â¡ï¸ Rendert `DeleteButton` **nur**, wenn `hasPermission === true` ist.

---

### âœ… 4. Optionales Rendering mit `null`

```jsx
{shouldShow ? <Component /> : null}
```

â¡ï¸ Wenn `shouldShow === false`, wird **gar nichts** gerendert.

---

## ğŸ“ Zusammenfassung

**Conditional Rendering** bedeutet, dass JSX **dynamisch** auf Basis von Bedingungen  
**unterschiedlichen Inhalt rendert**.  
React unterstÃ¼tzt dafÃ¼r mehrere Schreibweisen:  
`if`, `? :`, `&&`, RÃ¼ckgabe von `null`.

---

## ğŸ”— Quellen

- [Conditional Rendering â€“ React Docs](https://react.dev/learn/conditional-rendering)  
- [MDN: Bedingte AusdrÃ¼cke](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Operators/Conditional_Operator)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

66. ### <a name="66"></a> Was ist ein Error Boundary?

# Was ist ein Error Boundary in React?

Ein **Error Boundary** (Fehlergrenze) ist eine **spezielle React-Komponente**,  
die **JavaScript-Fehler** in ihrer **Kind-Komponenten-Hierarchie abfÃ¤ngt**,  
um zu verhindern, dass der **gesamte UI-Baum zusammenbricht**.

---

## ğŸ¯ Zweck von Error Boundaries

- âœ… Fehler im UI **abfangen**, anzeigen und kontrolliert behandeln  
- âœ… Verhindert den **Absturz der gesamten App**  
- âœ… Zeigt stattdessen **Fallback-UI** oder eine Fehlermeldung an

---

## ğŸ“¦ Wann tritt ein Fehler auf?

Error Boundaries fangen **nur Fehler wÃ¤hrend des Renderns**,  
in **Lifecycle-Methoden** und in **Konstruktoren von Klassenkomponenten** ab.

**Nicht abgefangen werden**:
- Fehler in Event-Handlern (diese mÃ¼ssen manuell mit `try/catch` behandelt werden)
- Fehler in `async`-Funktionen
- Fehler auÃŸerhalb des React-Baums

---

## ğŸ’¡ Beispiel: Error Boundary (Klassenkomponente)

```jsx
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, info) {
    console.error('Fehler abgefangen:', error, info);
  }

  render() {
    if (this.state.hasError) {
      return <h2>Etwas ist schiefgelaufen.</h2>;
    }

    return this.props.children;
  }
}
```

---

### âœ… Verwendung:

```jsx
<ErrorBoundary>
  <ProblematicComponent />
</ErrorBoundary>
```

â¡ï¸ Wenn `ProblematicComponent` crasht, zeigt `ErrorBoundary` stattdessen die Fallback-UI.

---

## ğŸ§ª Wann verwenden?

- Um Teile der App **abzusichern** (z.â€¯B. Seitenbereiche, Widgets)
- Um **Logs zu erfassen** (`componentDidCatch`)
- Um den Nutzer bei Fehlern **nicht allein zu lassen**

---

## ğŸ“ Zusammenfassung

Ein **Error Boundary** ist eine **Klassenkomponente**,  
die Fehler in der React-Komponentenstruktur **abfÃ¤ngt und behandelt**,  
ohne dass die ganze App abstÃ¼rzt.  
Sie bietet eine **Fallback-UI** und hilft bei **Debugging & StabilitÃ¤t**.

---

## ğŸ”— Quellen

- [Error Boundaries â€“ React Docs](https://react.dev/learn/managing-errors)  
- [MDN: Fehlerbehandlung in React](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch#handling_errors_in_react)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

67. ### <a name="67"></a> Wie funktioniert Event-Handling in React?

# Wie funktioniert Event-Handling in React?

**Event-Handling** in React funktioniert Ã¤hnlich wie in HTML/JavaScript,  
aber mit einigen **Unterschieden in Syntax und Verhalten**.

---

## ğŸ¯ Besonderheiten in React

- React verwendet **camelCase** statt Kleinschreibung:
  - `onClick` statt `onclick`
- Event-Handler werden als **Funktionen (nicht Strings)** Ã¼bergeben:
  - `{handleClick}` statt `"handleClick()"`

---

## ğŸ’¡ Beispiel: Klick-Event

```jsx
function Button() {
  function handleClick() {
    alert('Button wurde geklickt!');
  }

  return <button onClick={handleClick}>Klicken</button>;
}
```

---

## ğŸ“¦ Event-Objekt

React stellt ein **synthetisches Event-Objekt** (`SyntheticEvent`) bereit,  
das mit allen Browsern konsistent funktioniert.

```jsx
function Input() {
  function handleChange(e) {
    console.log('Eingegeben:', e.target.value);
  }

  return <input onChange={handleChange} />;
}
```

â¡ï¸ `e` ist das SyntheticEvent, das sich **Ã¤hnlich wie ein native DOM-Event** verhÃ¤lt.

---

## ğŸ” Weitere Event-Beispiele

| Event         | Attribut        | Beispiel                           |
|---------------|------------------|------------------------------------|
| Klick         | `onClick`        | `<button onClick={fn} />`          |
| Eingabe       | `onChange`       | `<input onChange={fn} />`          |
| Fokus         | `onFocus`        | `<input onFocus={fn} />`           |
| Maus bewegen  | `onMouseMove`    | `<div onMouseMove={fn} />`         |
| Formular      | `onSubmit`       | `<form onSubmit={fn} />`           |
| Taste drÃ¼cken | `onKeyDown`      | `<input onKeyDown={fn} />`         |

---

## âœ… Standardverhalten verhindern

```jsx
function Form() {
  function handleSubmit(e) {
    e.preventDefault(); // verhindert Seitenreload
    console.log('Formular abgesendet');
  }

  return <form onSubmit={handleSubmit}>...</form>;
}
```

---

## ğŸ“ Zusammenfassung

- React verwendet eigene Events (`SyntheticEvent`) mit vertrauter API  
- Event-Handler werden als Funktionen mit camelCase geschrieben  
- Du kannst Standardverhalten (z.â€¯B. Form-Submit) mit `e.preventDefault()` unterdrÃ¼cken

---

## ğŸ”— Quellen

- [Events in React â€“ React Docs](https://react.dev/learn/responding-to-events)  
- [React Event Handling â€“ MDN](https://developer.mozilla.org/en-US/docs/Web/Events)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

68. ### <a name="68"></a> Was ist ein synthetisches Ereignis (SyntheticEvent)?

# Was ist ein synthetisches Ereignis (SyntheticEvent) in React?

Ein **synthetisches Ereignis** (`SyntheticEvent`) ist ein von React bereitgestelltes **plattformsicheres Wrapper-Objekt**  
fÃ¼r native DOM-Ereignisse wie `click`, `change`, `submit`, etc.

---

## ğŸ¯ Zweck von `SyntheticEvent`

- âœ… Einheitliches Verhalten in **allen Browsern**
- âœ… Automatisches **Event-Pooling** (frÃ¼her)
- âœ… Konsistente API fÃ¼r alle Event-Typen
- âœ… Kombiniert die Vorteile von DOM- und Custom-Events

---

## ğŸ“¦ Eigenschaften

- `SyntheticEvent` hat die **gleichen Methoden und Eigenschaften** wie ein normales DOM-Event:  
  - `e.target`, `e.preventDefault()`, `e.stopPropagation()` usw.
- Funktioniert fÃ¼r **alle Event-Typen**: Maus, Tastatur, Formulare, Fokus, usw.

---

## ğŸ’¡ Beispiel

```jsx
function Form() {
  function handleSubmit(e) {
    e.preventDefault(); // verhindert Reload
    console.log('Eingabefeld:', e.target.elements.name.value);
  }

  return (
    <form onSubmit={handleSubmit}>
      <input name="name" />
      <button type="submit">Absenden</button>
    </form>
  );
}
```

â¡ï¸ `e` ist ein `SyntheticEvent`, nicht das native `Event`-Objekt des Browsers.

---

## âš ï¸ Hinweis: Event-Pooling (frÃ¼her)

FrÃ¼her wurden `SyntheticEvent`-Objekte **recycelt** (Event Pooling), was bedeutete:  
Zugriff auf das Event nach dem Event-Handler war **nicht mehr mÃ¶glich**.  
**Seit React 17+ ist Pooling deaktiviert.**

---

## ğŸ“ Zusammenfassung

Ein `SyntheticEvent` ist Reacts **einheitliche Event-API**,  
die unabhÃ¤ngig vom Browser funktioniert und dieselbe OberflÃ¤che wie das native DOM-Event bietet.  
Du kannst es wie gewohnt verwenden (`e.preventDefault()`, `e.target.value`, etc.).

---

## ğŸ”— Quellen

- [React Docs â€“ SyntheticEvent](https://react.dev/reference/react-dom/SyntheticEvent)  
- [MDN: DOM Events Ãœbersicht](https://developer.mozilla.org/de/docs/Web/Events)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

69. ### <a name="69"></a> Was ist props.children?

# Was ist `props.children` in React?

**`props.children`** ist eine spezielle React-Prop,  
die automatisch alle **verschachtelten Elemente (Child-Komponenten oder JSX-Inhalte)** enthÃ¤lt,  
die **innerhalb einer Komponente Ã¼bergeben** werden.

---

## ğŸ¯ Wozu wird `props.children` verwendet?

- âœ… Um **dynamisch Inhalte zu rendern**, die von auÃŸen Ã¼bergeben werden  
- âœ… Um **Wrapper-Komponenten** (z.â€¯B. Layouts, Container) zu erstellen  
- âœ… FÃ¼r **wiederverwendbare UI-Strukturen**

---

## ğŸ’¡ Beispiel

```jsx
function Card(props) {
  return <div className="card">{props.children}</div>;
}

function App() {
  return (
    <Card>
      <h2>Titel</h2>
      <p>Das ist der Inhalt der Card.</p>
    </Card>
  );
}
```

â¡ï¸ Die `Card`-Komponente erhÃ¤lt:

```jsx
<h2>...</h2>
<p>...</p>
```

als `props.children` und rendert sie **im Inneren**.

---

## ğŸ“¦ Typen von `props.children`

- Kann ein **Element**, ein **Text**, ein **Array**, `null`, `undefined` oder ein **Fragment** sein
- Du kannst `children` auch **prÃ¼fen oder filtern**, z.â€¯B. mit `React.Children`

---

## ğŸ§ª Beispiel mit mehreren Kindern

```jsx
function Wrapper({ children }) {
  return (
    <section>
      {React.Children.map(children, (child, index) => (
        <div key={index}>{child}</div>
      ))}
    </section>
  );
}
```

â¡ï¸ So kannst du **alle `children` gezielt verarbeiten**.

---

## ğŸ“ Zusammenfassung

- `props.children` enthÃ¤lt **alle JSX-Inhalte**, die **zwischen den Tags** einer Komponente Ã¼bergeben werden  
- Es macht Komponenten **flexibel und wiederverwendbar**
- Typisch bei Layout-Komponenten, Dialogen, Containern

---

## ğŸ”— Quellen

- [React Docs â€“ Children](https://react.dev/learn/passing-props-to-a-component#using-the-children-prop)  
- [React.Children API â€“ React Docs](https://react.dev/reference/react/Children)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

70. ### <a name="70"></a> Was bedeutet â€controlled componentâ€œ und â€uncontrolled componentâ€œ bei Formularen?

# Was bedeutet â€controlled componentâ€œ und â€uncontrolled componentâ€œ bei Formularen in React?

In React beschreibt man Formular-Elemente wie `<input>`, `<textarea>` oder `<select>` als  
**controlled** oder **uncontrolled**, je nachdem, **wie ihr Wert verwaltet wird**.

---

## âœ… Controlled Component

Ein **controlled component** wird **vollstÃ¤ndig durch React kontrolliert** â€“  
der Wert kommt aus dem **State** und wird Ã¼ber `onChange` aktualisiert.

### Eigenschaften:

- Wert liegt im React-State
- Ã„nderungen erfolgen Ã¼ber `setState` / `useState`
- Ideal fÃ¼r Validierung, dynamische Formulare, zentrale Kontrolle

### Beispiel:

```jsx
function Form() {
  const [name, setName] = useState('');

  return (
    <input 
      value={name}
      onChange={(e) => setName(e.target.value)}
    />
  );
}
```

â¡ï¸ Das Eingabefeld zeigt **immer den aktuellen State-Wert**.

---

## âŒ Uncontrolled Component

Ein **uncontrolled component** verwaltet seinen Wert **intern im DOM**,  
React **greift nur Ã¼ber ein Ref** darauf zu â€“ z.â€¯B. beim Absenden des Formulars.

### Eigenschaften:

- Kein React-State fÃ¼r den Wert
- Zugriff Ã¼ber `ref`
- Einfach, aber schwerer zu validieren

### Beispiel:

```jsx
function Form() {
  const inputRef = useRef();

  const handleSubmit = (e) => {
    e.preventDefault();
    alert(inputRef.current.value);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input ref={inputRef} />
      <button type="submit">Absenden</button>
    </form>
  );
}
```

â¡ï¸ Der Wert wird **nicht in React gespeichert**, sondern **aus dem DOM gelesen**.

---

## ğŸ” Vergleich

| Merkmal              | Controlled                   | Uncontrolled                    |
|----------------------|------------------------------|----------------------------------|
| Datenquelle          | React-State (`useState`)     | DOM (intern)                     |
| Zugriff              | `value` + `onChange`         | `ref.current.value`              |
| Validierung          | Einfach                      | Komplizierter                    |
| FlexibilitÃ¤t         | Hoch                         | Gering                           |
| Initialwert          | via State                    | via `defaultValue`               |

---

## ğŸ“ Zusammenfassung

- **Controlled Components**: React verwaltet den Formularwert â†’ vollstÃ¤ndig kontrollierbar
- **Uncontrolled Components**: Der Browser verwaltet den Wert â†’ Zugriff nur Ã¼ber Ref
- Controlled ist der **empfohlene Standard**, besonders bei komplexen Formularen

---

## ğŸ”— Quellen

- [Controlled Components â€“ React Docs](https://react.dev/learn/sharing-state-between-components#controlled-and-uncontrolled-components)  
- [Formulare in React â€“ MDN](https://developer.mozilla.org/de/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_forms)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

71. ### <a name="71"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

72. ### <a name="72"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

73. ### <a name="73"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

74. ### <a name="74"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

75. ### <a name="75"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

76. ### <a name="76"></a> Wie fÃ¼hrt man API-Aufrufe mit Fetch oder Axios durch?

# Wie fÃ¼hrt man API-Aufrufe mit `fetch` oder `axios` in React durch?

In React kannst du API-Anfragen auf zwei gÃ¤ngige Arten durchfÃ¼hren:

1. Mit dem **integrierten `fetch`-API** (nativ in JavaScript)
2. Mit der **Axios-Bibliothek** (komfortabler, aber extern)

---

## âœ… 1. API-Aufruf mit `fetch`

```jsx
import { useEffect, useState } from 'react';

function UserList() {
  const [users, setUsers] = useState([]);
  const [error, setError] = useState(null);

  useEffect(() => {
    fetch('https://jsonplaceholder.typicode.com/users')
      .then((res) => {
        if (!res.ok) throw new Error('Fehler beim Laden');
        return res.json();
      })
      .then((data) => setUsers(data))
      .catch((err) => setError(err.message));
  }, []);

  if (error) return <p>Fehler: {error}</p>;
  return (
    <ul>
      {users.map((u) => (
        <li key={u.id}>{u.name}</li>
      ))}
    </ul>
  );
}
```

---

## âœ… 2. API-Aufruf mit `axios`

### Installation:

```bash
npm install axios
```

### Verwendung:

```jsx
import axios from 'axios';
import { useEffect, useState } from 'react';

function PostList() {
  const [posts, setPosts] = useState([]);
  const [error, setError] = useState(null);

  useEffect(() => {
    axios
      .get('https://jsonplaceholder.typicode.com/posts')
      .then((res) => setPosts(res.data))
      .catch((err) => setError(err.message));
  }, []);

  if (error) return <p>Fehler: {error}</p>;
  return (
    <ul>
      {posts.map((p) => (
        <li key={p.id}>{p.title}</li>
      ))}
    </ul>
  );
}
```

---

## ğŸ” Vergleich: `fetch` vs. `axios`

| Merkmal             | `fetch` (nativ)              | `axios` (Bibliothek)             |
|---------------------|------------------------------|----------------------------------|
| Integriert in JS?   | âœ… Ja                         | âŒ Nein (muss installiert werden) |
| JSON automatisch?   | âŒ Nein (manuell: `.json()`) | âœ… Ja (direkt `res.data`)         |
| Fehlerbehandlung    | Manuell mit `res.ok` prÃ¼fen  | Automatisch bei HTTP-Fehler      |
| UnterstÃ¼tzt Abbrechen | âŒ Nur mit AbortController | âœ… Ja                             |

---

## ğŸ“ Zusammenfassung

- Mit `fetch` und `axios` kannst du in `useEffect` **API-Daten laden**
- `fetch`: nativ, minimalistisch  
- `axios`: komfortabler, bessere Fehlerbehandlung  
- Immer Fehler abfangen (`.catch`) und Zustand (`loading`, `error`, `data`) verwalten

---

## ğŸ”— Quellen

- [fetch â€“ MDN Web Docs](https://developer.mozilla.org/de/docs/Web/API/Fetch_API)
- [Axios â€“ GitHub Docs](https://axios-http.com/docs/intro)
- [Daten in React laden â€“ React Docs](https://react.dev/learn/you-might-not-need-an-effect#fetching-data)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

77. ### <a name="77"></a> Wie verwaltet man Lade-, Fehler- und Erfolgsstatus?

# Wie verwaltet man Lade-, Fehler- und Erfolgsstatus in React?

Beim **Abrufen von Daten (API)** ist es wichtig, den **Status** der Anfrage zu verwalten:

1. ğŸ”„ **Ladezustand** (`isLoading`)
2. âœ… **Erfolgszustand** (Daten verfÃ¼gbar)
3. âŒ **Fehlerzustand** (Fehler beim Laden)

Diese drei ZustÃ¤nde werden meist mit **`useState` und `useEffect`** verwaltet.

---

## ğŸ’¡ Beispiel mit `fetch`

```jsx
import { useState, useEffect } from 'react';

function UserList() {
  const [users, setUsers] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    fetch('https://jsonplaceholder.typicode.com/users')
      .then((res) => {
        if (!res.ok) throw new Error('Fehler beim Laden');
        return res.json();
      })
      .then((data) => {
        setUsers(data);
        setError(null);
      })
      .catch((err) => setError(err.message))
      .finally(() => setIsLoading(false));
  }, []);

  if (isLoading) return <p>â³ Lade Daten...</p>;
  if (error) return <p>âŒ Fehler: {error}</p>;

  return (
    <ul>
      {users.map((user) => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

---

## âœ… Statusverwaltung im Ãœberblick

| Zustand     | Variable     | Bedeutung                                 |
|-------------|--------------|--------------------------------------------|
| Ladezustand | `isLoading`  | Wird `true` beim Start der Anfrage         |
| Erfolgsdaten| `data`, `users`, etc. | Wird nach erfolgreichem Laden gesetzt |
| Fehlerzustand| `error`     | Wird gesetzt, wenn `.catch()` ausgelÃ¶st wird |

---

## ğŸ”„ Alternativen

- Eigener **Custom Hook** (`useFetch`, `useApi`)
- **State Machine** (z.â€¯B. mit `xstate`)
- Zustand mit `useReducer` verwalten, wenn komplexer

---

## ğŸ“ Zusammenfassung

- Nutze `useState` fÃ¼r `isLoading`, `error` und `data`
- Nutze `useEffect`, um Daten zu laden
- Zeige je nach Zustand: Ladeanzeige, Fehlernachricht oder Daten

---

## ğŸ”— Quellen

- [React: API-Daten laden â€“ react.dev](https://react.dev/learn/you-might-not-need-an-effect#fetching-data)  
- [fetch API â€“ MDN Docs](https://developer.mozilla.org/de/docs/Web/API/Fetch_API)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

78. ### <a name="78"></a> Wie funktioniert WebSocket mit React?

# Wie funktioniert WebSocket mit React?

**WebSockets** ermÃ¶glichen eine **bidirektionale, permanente Verbindung** zwischen Client (Browser) und Server.  
In React kannst du damit **Echtzeit-Daten** verarbeiten â€“ z.â€¯B. fÃ¼r Chats, Benachrichtigungen oder Live-Dashboards.

---

## ğŸ”„ Grundprinzip WebSocket

1. Verbindung zum Server aufbauen
2. Nachrichten senden & empfangen
3. Verbindung schlieÃŸen (bei Unmount oder Fehler)

---

## ğŸ’¡ Beispiel: WebSocket in React verwenden

```jsx
import { useEffect, useRef, useState } from 'react';

function WebSocketComponent() {
  const socketRef = useRef(null);
  const [messages, setMessages] = useState([]);

  useEffect(() => {
    // 1. Verbindung aufbauen
    socketRef.current = new WebSocket('wss://example.com/socket');

    // 2. Nachricht empfangen
    socketRef.current.onmessage = (event) => {
      setMessages((prev) => [...prev, event.data]);
    };

    // 3. Fehlerbehandlung
    socketRef.current.onerror = (err) => {
      console.error('WebSocket-Fehler:', err);
    };

    // 4. AufrÃ¤umen beim Unmount
    return () => {
      socketRef.current.close();
    };
  }, []);

  // Nachricht senden (z.â€¯B. beim Button-Klick)
  const sendMessage = () => {
    if (socketRef.current.readyState === WebSocket.OPEN) {
      socketRef.current.send('Hallo vom Client!');
    }
  };

  return (
    <div>
      <h3>Empfangene Nachrichten:</h3>
      <ul>
        {messages.map((msg, i) => (
          <li key={i}>{msg}</li>
        ))}
      </ul>
      <button onClick={sendMessage}>Nachricht senden</button>
    </div>
  );
}
```

---

## ğŸ” Tipps fÃ¼r den produktiven Einsatz

- Nutze `useRef`, damit WebSocket-Verbindung **nicht bei jedem Render neu aufgebaut** wird  
- PrÃ¼fe `socket.readyState`, bevor du Nachrichten sendest  
- Verwende ggf. **Reconnect-Strategien**, falls Verbindung abbricht  
- FÃ¼r groÃŸe Projekte: verwalte WebSocket Ã¼ber `Context` oder `Redux`

---

## ğŸ“ Zusammenfassung

- WebSocket bietet eine **dauerhafte Verbindung** zwischen React-Client und Server  
- Ideal fÃ¼r **Live-Kommunikation** (Chat, Echtzeitdaten)  
- In React: mit `useEffect`, `useRef` und `setState` kombinieren  
- Nicht vergessen: **Verbindung schlieÃŸen** bei Unmount

---

## ğŸ”— Quellen

- [MDN: WebSocket API](https://developer.mozilla.org/de/docs/Web/API/WebSocket)  
- [React + WebSocket Guide â€“ LogRocket](https://blog.logrocket.com/using-websocket-react-guide/)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

79. ### <a name="79"></a> Wie kann man Daten zwischen Komponenten weitergeben?

# Wie kann man Daten zwischen Komponenten weitergeben?

In React gibt es mehrere Wege, **Daten zwischen Komponenten** auszutauschen.  
Welcher Weg sinnvoll ist, hÃ¤ngt davon ab, **wie die Komponenten zueinander stehen**.

---

## 1ï¸âƒ£ Parent â†’ Child: via **Props**

Der klassische und einfachste Weg:  
Elternkomponente Ã¼bergibt Daten an Kindkomponente als `props`.

```jsx
function Child({ username }) {
  return <p>Hallo, {username}!</p>;
}

function Parent() {
  return <Child username="Sergii" />;
}
```

â¡ï¸ Einfache, **unidirektionale Datenweitergabe**.

---

## 2ï¸âƒ£ Child â†’ Parent: via **Callback-Funktion als Prop**

Kindkomponente ruft eine Funktion auf, die der Elternkomponente gehÃ¶rt.

```jsx
function Child({ onNameChange }) {
  return <input onChange={(e) => onNameChange(e.target.value)} />;
}

function Parent() {
  const [name, setName] = useState('');
  return (
    <>
      <Child onNameChange={setName} />
      <p>Name: {name}</p>
    </>
  );
}
```

â¡ï¸ **"Lifting State Up"**: Eltern verwalten den Zustand.

---

## 3ï¸âƒ£ Geschwister-Komponenten (Sibling â†’ Sibling): via **gemeinsamen Eltern-State**

Beide Kinder greifen auf den **Zustand in der Elternkomponente** zu.

```jsx
function Input({ onChange }) {
  return <input onChange={(e) => onChange(e.target.value)} />;
}

function Display({ value }) {
  return <p>Wert: {value}</p>;
}

function Parent() {
  const [text, setText] = useState('');
  return (
    <>
      <Input onChange={setText} />
      <Display value={text} />
    </>
  );
}
```

---

## 4ï¸âƒ£ Tief verschachtelte Komponenten: via **Context API**

Nutze `createContext`, `Provider` und `useContext`,  
um Daten **global im Baum** verfÃ¼gbar zu machen.

```jsx
const ThemeContext = createContext();

function App() {
  return (
    <ThemeContext.Provider value="dark">
      <DeepChild />
    </ThemeContext.Provider>
  );
}

function DeepChild() {
  const theme = useContext(ThemeContext);
  return <p>Aktuelles Theme: {theme}</p>;
}
```

---

## 5ï¸âƒ£ App-weite ZustÃ¤nde: via **State-Management** (z.â€¯B. Redux, Zustand)

FÃ¼r sehr groÃŸe Apps oder komplexe Interaktionen.

```jsx
// Redux: useSelector, useDispatch
// Zustand: useStore()
// Recoil, Jotai, MobX = Alternativen
```

---

## ğŸ“ Zusammenfassung

| Beziehung          | LÃ¶sung                         |
|--------------------|---------------------------------|
| Eltern â†’ Kind      | Props                          |
| Kind â†’ Eltern      | Callback-Funktion als Prop     |
| Geschwister        | Gemeinsamer Eltern-State       |
| Tief verschachtelt | Context API                    |
| Global             | State-Management-Library       |

---

## ğŸ”— Quellen

- [React â€“ Props](https://react.dev/learn/passing-props-to-a-component)  
- [React â€“ State Heben](https://react.dev/learn/sharing-state-between-components)  
- [React â€“ Context API](https://react.dev/learn/passing-data-deeply-with-context)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

80. ### <a name="80"></a> Wie macht man einen Datenabruf nur beim ersten Rendern?

# Wie macht man einen Datenabruf nur beim ersten Rendern in React?

Um eine API-Anfrage **nur einmal beim ersten Laden der Komponente** durchzufÃ¼hren,  
nutzt man den Hook **`useEffect` mit leerem AbhÃ¤ngigkeits-Array `[]`**.

---

## ğŸ’¡ Beispiel: API-Fetch beim Mount

```jsx
import { useEffect, useState } from 'react';

function UserList() {
  const [users, setUsers] = useState([]);

  useEffect(() => {
    fetch('https://jsonplaceholder.typicode.com/users')
      .then((res) => res.json())
      .then((data) => setUsers(data));
  }, []); // â† nur beim ersten Rendern!

  return (
    <ul>
      {users.map((u) => (
        <li key={u.id}>{u.name}</li>
      ))}
    </ul>
  );
}
```

---

## ğŸ“Œ ErklÃ¤rung

- Das leere Array `[]` bedeutet:  
  **Dieser Effekt lÃ¤uft nur einmal â€“ beim ersten Rendern (Mount)**.
- Keine erneute AusfÃ¼hrung bei Re-Renders oder State-Ã„nderungen

---

## ğŸ” Alternative: Async-Funktion in `useEffect`

Da `useEffect` keine `async`-Funktion direkt erlaubt:

```jsx
useEffect(() => {
  async function fetchData() {
    const res = await fetch('...');
    const data = await res.json();
    setUsers(data);
  }

  fetchData();
}, []);
```

---

## ğŸ“ Zusammenfassung

- Verwende `useEffect(() => { ... }, [])`, um einen Effekt **nur einmal beim ersten Rendern** auszufÃ¼hren  
- Ideal fÃ¼r **API-Anfragen, Initialdaten oder Setup-Logik**  
- Async-Aufrufe mÃ¼ssen in eine **innere Funktion** ausgelagert werden

---

## ğŸ”— Quellen

- [React Docs â€“ useEffect](https://react.dev/reference/react/useEffect)  
- [Daten beim Mount laden â€“ React Patterns](https://reactpatterns.com/#fetch-on-mount)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**  

81. ### <a name="81"></a> Was ist das Problem bei â€stale closuresâ€œ mit Hooks?

# Was ist das Problem bei â€stale closuresâ€œ mit Hooks?

Ein **â€stale closureâ€œ** (veraltete Funktionseinbettung) tritt auf,  
wenn eine **Funktion in einem Hook (z.â€¯B. `useEffect`, `setInterval`, `addEventListener`)**  
auf **einen veralteten Wert aus dem vorherigen Render** zugreift.

---

## ğŸ“¦ Was ist eine Closure?

Eine **Closure** ist eine Funktion, die Zugriff auf Variablen aus dem **Umgebungskontext** (z.â€¯B. vorherigem Render) hat.

Wenn ein Hook eine Funktion verwendet, â€merktâ€œ sich diese Funktion **den Zustand des Wertes zu diesem Zeitpunkt**.

---

## ğŸ’¡ Beispiel: Problem mit `setInterval`

```jsx
function Timer() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const id = setInterval(() => {
      setCount(count + 1); // âŒ count ist immer 0!
    }, 1000);

    return () => clearInterval(id);
  }, []);
  
  return <p>ZÃ¤hler: {count}</p>;
}
```

### ğŸ”´ Problem:

- Die `count`-Variable ist **eingefroren (stale)** bei `0`, weil `useEffect` nur **einmal** ausgefÃ¼hrt wird
- Der Callback in `setInterval` â€siehtâ€œ nie die neuen `count`-Werte

---

## âœ… LÃ¶sung 1: Funktionales `setState`

```jsx
setCount((prev) => prev + 1);
```

```jsx
useEffect(() => {
  const id = setInterval(() => {
    setCount((prev) => prev + 1); // âœ… aktueller Wert
  }, 1000);

  return () => clearInterval(id);
}, []);
```

â¡ï¸ `prev` wird **zur aktuellen Version** von `count`, unabhÃ¤ngig vom Closure

---

## âœ… LÃ¶sung 2: useRef fÃ¼r aktuelle Werte

```jsx
const countRef = useRef(count);

useEffect(() => {
  countRef.current = count;
}, [count]);

useEffect(() => {
  const id = setInterval(() => {
    console.log(countRef.current); // immer aktuell
  }, 1000);

  return () => clearInterval(id);
}, []);
```

â¡ï¸ `useRef` bleibt **zwischen Renders gleich** und kann **aktualisiert** werden.

---

## ğŸ“ Zusammenfassung

- Ein **stale closure** tritt auf, wenn eine Funktion auf **veraltete Werte** zugreift  
- Typisch bei: `setInterval`, `useEffect`, Event-Handlern  
- LÃ¶sungen:
  - âœ… Funktionales `setState`
  - âœ… `useRef` zur Speicherung aktueller Werte

---

## ğŸ”— Quellen

- [React Docs â€“ useEffect Gotchas](https://react.dev/learn/synchronizing-with-effects#you-might-see-stale-values-inside-an-effect)  
- [Dan Abramov â€“ A Complete Guide to useEffect](https://overreacted.io/a-complete-guide-to-useeffect/)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

82. ### <a name="82"></a> Wie funktioniert die Fehlerbehandlung mit try/catch in React?

# Wie funktioniert die Fehlerbehandlung mit `try/catch` in React?

In React wird `try/catch` verwendet, um **synchronen und asynchronen Code** innerhalb von Funktionen  
(z.â€¯B. Event-Handlern, `async`-Funktionen) **gezielt abzusichern**.

âš ï¸ `try/catch` funktioniert **nicht fÃ¼r Renderfehler** in JSX â€“ dafÃ¼r benÃ¶tigt man **Error Boundaries**.

---

## âœ… Verwendung in Event-Handlern

```jsx
function Button() {
  const handleClick = () => {
    try {
      // synchroner Fehler
      throw new Error('Etwas ist schiefgelaufen!');
    } catch (err) {
      console.error('Fehler:', err.message);
    }
  };

  return <button onClick={handleClick}>Klick mich</button>;
}
```

---

## âœ… Verwendung in `async`-Funktionen (z.â€¯B. Daten laden)

```jsx
function DataLoader() {
  const [data, setData] = useState(null);
  const [error, setError] = useState(null);

  useEffect(() => {
    async function fetchData() {
      try {
        const res = await fetch('https://api.example.com/data');
        if (!res.ok) throw new Error('Fehler beim Abrufen');
        const json = await res.json();
        setData(json);
      } catch (err) {
        setError(err.message);
      }
    }

    fetchData();
  }, []);

  if (error) return <p>âŒ Fehler: {error}</p>;
  if (!data) return <p>â³ LÃ¤dt...</p>;
  return <pre>{JSON.stringify(data, null, 2)}</pre>;
}
```

---

## ğŸ”´ Kein `try/catch` fÃ¼r Renderfehler

```jsx
function App() {
  try {
    return <ProblematicComponent />; // âŒ try/catch greift hier nicht
  } catch (e) {
    return <p>Fehler!</p>; // âŒ wird nicht erreicht
  }
}
```

â¡ï¸ React rendert **asynchron**, deshalb **fangen Error Boundaries** solche Fehler ab, nicht `try/catch`.

---

## ğŸ“ Zusammenfassung

| Fehlerquelle      | `try/catch` geeignet? | Alternative                     |
|------------------|------------------------|---------------------------------|
| Event-Handler     | âœ… Ja                  | â€”                               |
| `async`-Funktionen| âœ… Ja                  | â€”                               |
| Renderzeit (JSX)  | âŒ Nein                | â— `ErrorBoundary` verwenden     |

---

## ğŸ”— Quellen

- [React Docs â€“ Fehlerbehandlung](https://react.dev/learn/managing-errors)  
- [MDN â€“ try...catch](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Statements/try...catch)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

83. ### <a name="83"></a> Wie kann man ein Mock-API oder Mock Server verwenden?

# Wie kann man ein Mock-API oder Mock Server in React verwenden?

Ein **Mock-API** oder **Mock-Server** simuliert eine echte Backend-API,  
um die Entwicklung und das Testen von Frontend-Komponenten zu ermÃ¶glichen â€“  
ohne auf ein echtes Backend warten zu mÃ¼ssen.

---

## ğŸ¯ Vorteile

- UnabhÃ¤ngige Entwicklung von Frontend und Backend
- Offline arbeiten mÃ¶glich
- Schnelleres Testen von UI-Logik
- Kontrolle Ã¼ber Antwortdaten, Fehler, Ladezeiten

---

## âœ… MÃ¶glichkeiten fÃ¼r Mocking

### 1ï¸âƒ£ **JSON Server (lokal)**

Schneller REST-API-Mock Ã¼ber eine JSON-Datei.

#### ğŸ”§ Installation:

```bash
npm install -g json-server
```

#### ğŸ“ `db.json`

```json
{
  "users": [
    { "id": 1, "name": "Alice" },
    { "id": 2, "name": "Bob" }
  ]
}
```

#### ğŸš€ Starten:

```bash
json-server --watch db.json --port 4000
```

â¡ï¸ API verfÃ¼gbar unter `http://localhost:4000/users`

---

### 2ï¸âƒ£ **Mock Service Worker (MSW)** â€“ empfohlen fÃ¼r komplexe Szenarien

Interceptet echte Requests auf Netzwerkebene â†’ realistisch & flexibel.

#### ğŸ”§ Installation:

```bash
npm install msw --save-dev
```

#### ğŸ“ Beispiel-Handler:

```js
// src/mocks/handlers.js
import { rest } from 'msw';

export const handlers = [
  rest.get('/api/users', (req, res, ctx) => {
    return res(
      ctx.status(200),
      ctx.json([{ id: 1, name: 'Sergii' }, { id: 2, name: 'Anna' }])
    );
  }),
];
```

#### ğŸ§© Setup:

```js
// src/mocks/browser.js
import { setupWorker } from 'msw';
import { handlers } from './handlers';

export const worker = setupWorker(...handlers);
```

```js
// index.js
if (process.env.NODE_ENV === 'development') {
  const { worker } = require('./mocks/browser');
  worker.start();
}
```

---

### 3ï¸âƒ£ **Online-Tools / Ã¶ffentliche APIs**

- [https://reqres.in](https://reqres.in)
- [https://jsonplaceholder.typicode.com](https://jsonplaceholder.typicode.com)
- [https://mockapi.io](https://mockapi.io)

â¡ï¸ Gut fÃ¼r schnelles Testen ohne lokale Einrichtung

---

## ğŸ“ Zusammenfassung

| Methode         | Geeignet fÃ¼r                  | Vorteile                    |
|------------------|-------------------------------|-----------------------------|
| `json-server`    | Lokale Fake-REST-API          | Schnell, einfach            |
| `msw`            | Realistisches Mocking (XHR)   | Sehr mÃ¤chtig, intercepts    |
| `mockapi.io`     | Online-Testing                | Kein Setup nÃ¶tig            |

---

## ğŸ”— Quellen

- [Mock Service Worker â€“ offizielle Website](https://mswjs.io)  
- [JSON Server â€“ GitHub](https://github.com/typicode/json-server)  
- [jsonplaceholder â€“ Fake API](https://jsonplaceholder.typicode.com)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

84. ### <a name="84"></a> Wie funktioniert Suspense fÃ¼r Datenabfragen?

# Wie funktioniert `React.Suspense` fÃ¼r Datenabfragen?

`React.Suspense` erlaubt es, **asynchrone DatenladevorgÃ¤nge** elegant zu behandeln,  
indem eine **Fallback-UI** (z.â€¯B. Ladeanzeige) angezeigt wird,  
solange **komponentenabhÃ¤ngige Daten noch nicht verfÃ¼gbar** sind.

---

## âš ï¸ Wichtig:

- Suspense fÃ¼r Daten funktioniert **nur mit speziellen Data Fetching Libraries**, z.â€¯B.:
  - **React Query (TanStack Query)**
  - **Relay**
  - oder man schreibt einen eigenen **Wrapper mit `Promise`-suspending**

---

## âœ… Beispiel mit React Query (empfohlener Weg)

### ğŸ”§ Setup:

```bash
npm install @tanstack/react-query
```

### ğŸ“¦ App mit QueryClient + Suspense:

```jsx
import {
  QueryClient,
  QueryClientProvider,
  useQuery,
} from '@tanstack/react-query';
import { Suspense } from 'react';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      suspense: true,
    },
  },
});

function Users() {
  const { data } = useQuery({
    queryKey: ['users'],
    queryFn: () =>
      fetch('https://jsonplaceholder.typicode.com/users').then((res) =>
        res.json()
      ),
  });

  return (
    <ul>
      {data.map((u) => (
        <li key={u.id}>{u.name}</li>
      ))}
    </ul>
  );
}

export default function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <Suspense fallback={<p>â³ LÃ¤dt Benutzer...</p>}>
        <Users />
      </Suspense>
    </QueryClientProvider>
  );
}
```

---

## ğŸ§  Was passiert hier?

- **`Suspense`** zeigt das `fallback`, solange `Users` noch lÃ¤dt.
- Sobald `useQuery` Daten geladen hat, wird `fallback` ersetzt.
- Vorteil: Kein explizites `isLoading` oder `error` nÃ¶tig â†’ cleaner Code

---

## ğŸ” Alternative: Eigene Datenquelle mit `suspense`-like Verhalten

```jsx
function wrapPromise(promise) {
  let status = 'pending';
  let result;
  const suspender = promise.then(
    (r) => {
      status = 'success';
      result = r;
    },
    (e) => {
      status = 'error';
      result = e;
    }
  );

  return {
    read() {
      if (status === 'pending') throw suspender;
      if (status === 'error') throw result;
      return result;
    },
  };
}
```

â¡ï¸ Diese Technik ist eher experimentell.

---

## ğŸ“ Zusammenfassung

- `Suspense` kann LadezustÃ¤nde abfangen und Fallback anzeigen
- FÃ¼r Daten: funktioniert nur mit Libraries wie **React Query** oder **Relay**
- Vorteil: **automatisches Laden + saubere Trennung von UI & Logik**

---

## ğŸ”— Quellen

- [React Suspense fÃ¼r Daten â€“ React Docs](https://react.dev/reference/react/Suspense)  
- [TanStack Query mit Suspense](https://tanstack.com/query/latest/docs/react/guides/suspense)  
- [MDN: Promises](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Promise)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

85. ### <a name="85"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

86. ### <a name="86"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

87. ### <a name="87"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

88. ### <a name="88"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

89. ### <a name="89"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

90. ### <a name="90"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**  

91. ### <a name="91"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

92. ### <a name="92"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

93. ### <a name="93"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

94. ### <a name="94"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

95. ### <a name="95"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

96. ### <a name="96"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

97. ### <a name="97"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

98. ### <a name="98"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

99. ### <a name="99"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

100. ### <a name="100"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**    

101. ### <a name="101"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

102. ### <a name="102"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

103. ### <a name="103"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

104. ### <a name="104"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

105. ### <a name="105"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

106. ### <a name="106"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

107. ### <a name="107"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

108. ### <a name="108"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

109. ### <a name="109"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

110. ### <a name="110"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

111. ### <a name="111"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

112. ### <a name="112"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

113. ### <a name="113"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

114. ### <a name="114"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

115. ### <a name="115"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

116. ### <a name="116"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

117. ### <a name="117"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

118. ### <a name="118"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

119. ### <a name="119"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

120. ### <a name="120"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

121. ### <a name="121"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

122. ### <a name="122"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

123. ### <a name="123"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

124. ### <a name="124"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

125. ### <a name="125"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

126. ### <a name="126"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

127. ### <a name="127"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

128. ### <a name="128"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

129. ### <a name="129"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

130. ### <a name="130"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**  

131. ### <a name="131"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

132. ### <a name="132"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

133. ### <a name="133"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

134. ### <a name="134"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

135. ### <a name="135"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

136. ### <a name="136"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

137. ### <a name="137"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

138. ### <a name="138"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

139. ### <a name="139"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

140. ### <a name="140"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**  

141. ### <a name="141"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

142. ### <a name="142"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

143. ### <a name="143"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

144. ### <a name="144"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

145. ### <a name="145"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

146. ### <a name="146"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

147. ### <a name="147"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

148. ### <a name="148"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

149. ### <a name="149"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

150. ### <a name="150"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**  

151. ### <a name="151"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

152. ### <a name="152"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

153. ### <a name="153"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

154. ### <a name="154"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

155. ### <a name="155"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

156. ### <a name="156"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

157. ### <a name="157"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

158. ### <a name="158"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

159. ### <a name="159"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

160. ### <a name="160"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

161. ### <a name="161"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

162. ### <a name="162"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

163. ### <a name="163"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

164. ### <a name="164"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

165. ### <a name="165"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

166. ### <a name="166"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

167. ### <a name="167"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

168. ### <a name="168"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

169. ### <a name="169"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

170. ### <a name="170"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

171. ### <a name="171"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

172. ### <a name="172"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

173. ### <a name="173"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

174. ### <a name="174"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

175. ### <a name="175"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

176. ### <a name="176"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

177. ### <a name="177"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

178. ### <a name="178"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

179. ### <a name="179"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

180. ### <a name="180"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**  

181. ### <a name="181"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

182. ### <a name="182"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

183. ### <a name="183"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

184. ### <a name="184"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

185. ### <a name="185"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

186. ### <a name="186"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

187. ### <a name="187"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

188. ### <a name="188"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

189. ### <a name="189"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

190. ### <a name="190"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**  

191. ### <a name="191"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

192. ### <a name="192"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

193. ### <a name="193"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

194. ### <a name="194"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

195. ### <a name="195"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

196. ### <a name="196"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

197. ### <a name="197"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

198. ### <a name="198"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

199. ### <a name="199"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

200. ### <a name="200"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**      
