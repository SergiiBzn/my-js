<a name="top"></a>

[ĞĞ° Ğ³Ğ»Ğ°Ğ²Ğ½ÑƒÑ](../../README.md)

[ĞŸĞµÑ€ĞµĞ¹Ñ‚Ğ¸ Ğº Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑĞ°Ğ¼](#questions)

| â„–. | Ğ’Ğ¾Ğ¿Ñ€Ğ¾Ñ |
| --- | --------- |
|   | ReactJS Grundlagen |
|1 | [Was ist React und welche Probleme lÃ¶st es?](#1) |
|2 | [Was ist JSX und warum wird es verwendet?](#2) |
|3 | [Was ist Virtual DOM und wie funktioniert es?](#3) |
|4 | [Was ist der Unterschied zwischen React und ReactDOM?](#4) |
|5 | [Warum importieren wir React, auch wenn es scheinbar nicht benutzt wird?](#5) |
|6 | [Was ist ein React Fragment und warum ist es nÃ¼tzlich?](#6) |
|7 | [Was ist der Unterschied zwischen einem Element, einer Komponente und einer Instanz?](#7) |
|8 | [Was ist das Fiber-Architekturmodell in React?](#8) |
|9 | [Was bedeutet â€Batchingâ€œ in React?](#9) |
|10 | [Was ist die Rolle des key in React-Listen?](#10) |
|11 | [Wie funktioniert die Wiederverwendung von Komponenten?](#11) |
|12 | [](#12) |
|13 | [](#13) |
|14 | [](#14) |
|15 | [](#15) |
|16 | [](#16) |
|17 | [](#17) |
|18 | [](#18) |
|19 | [](#19) |
|20 | [](#20) |
|   | Komponenten, Props & State |
|21 | [Was sind Props und wozu werden sie verwendet?](#21) |
|22 | [Was ist der Unterschied zwischen Props und State?](#22) |
|23 | [Warum sind Props nur lesbar?](#23) |
|24 | [Wie funktioniert der unidirektionale Datenfluss in React?](#24) |
|25 | [Was ist State in Klassen- und Funktionskomponenten?](#25) |
|26 | [Wie funktioniert setState?](#26) |
|27 | [Was ist der Unterschied zwischen kontrollierten und unkontrollierten Komponenten?](#27) |
|28 | [Was sind Default Props und PropTypes?](#28) |
|29 | [Was ist React.memo und wofÃ¼r wird es verwendet?](#29) |
|30 | [Was ist PureComponent und wie unterscheidet es sich von Component?](#30) |
|31 | [Wann sollte shouldComponentUpdate verwendet werden?](#31) |
|32 | [Was ist ein ref und wann wird er eingesetzt?](#32) |
|33 | [Was bedeutet â€Lifting State Upâ€œ?](#33) |
|34 | [](#34) |
|35 | [](#35) |
|36 | [](#36) |
|37 | [](#37) |
|38 | [](#38) |
|39 | [](#39) |
|40 | [](#40) |
|   | Lebenszyklus von Komponenten |
|41 | [Was sind die Phasen des Komponentenlebenszyklus?](#41) |
|42 | [Welche Lifecycle-Methoden gibt es in Klassenkomponenten?](#42) |
|43 | [Welche Lifecycle-Methoden sind veraltet?](#43) |
|44 | [Wie kann man Lifecycle-Methoden mit Hooks ersetzen?](#44) |
|45 | [Was ist componentDidMount und was ist das Ã„quivalent mit Hooks?](#45) |
|46 | [](#46) |
|47 | [](#47) |
|48 | [](#48) |
|49 | [](#49) |
|50 | [](#50) |
|   | Hooks |
|51 | [Was sind Hooks in React?](#51) |
|52 | [Wie funktionieren useState und useEffect?](#52) |
|53 | [Was macht useContext?](#53) |
|54 | [Was ist useRef und wann wird es verwendet?](#54) |
|55 | [Was ist useCallback, useMemo, useReducer?](#55) |
|56 | [Wie schreibt man einen benutzerdefinierten Hook?](#56) |
|57 | [Wie verhindert man eine Endlosschleife in useEffect?](#57) |
|58 | [Wie implementiert man Timeout oder Interval mit Hooks?](#58) |
|59 | [](#59) |
|60 | [](#60) |
|   | React-Patterns und Konzepte |
|61 | [Was ist ein Higher-Order Component (HOC)?](#61) |
|62 | [Was ist das Render-Prop-Pattern?](#62) |
|63 | [Was ist die Context-API und wie funktioniert useContext?](#63) |
|64 | [Was sind Portale in React?](#64) |
|65 | [Was ist bedingtes Rendern (Conditional Rendering)?](#65) |
|66 | [Was ist ein Error Boundary?](#66) |
|67 | [Wie funktioniert Event-Handling in React?](#67) |
|68 | [Was ist ein synthetisches Ereignis (SyntheticEvent)?](#68) |
|69 | [Was ist props.children?](#69) |
|70 | [Was bedeutet â€controlled componentâ€œ und â€uncontrolled componentâ€œ bei Formularen?](#70) |
|71 | [](#71) |
|72 | [](#72) |
|73 | [](#73) |
|74 | [](#74) |
|75 | [](#75) |
|   | Daten & API |
|76 | [Wie fÃ¼hrt man API-Aufrufe mit Fetch oder Axios durch?](#76) |
|77 | [Wie verwaltet man Lade-, Fehler- und Erfolgsstatus?](#77) |
|78 | [Wie funktioniert WebSocket mit React?](#78) |
|79 | [Wie kann man Daten zwischen Komponenten weitergeben?](#79) |
|80 | [Wie macht man einen Datenabruf nur beim ersten Rendern?](#80) |
|81 | [Was ist das Problem bei â€stale closuresâ€œ mit Hooks?](#81) |
|82 | [Wie funktioniert die Fehlerbehandlung mit try/catch in React?](#82) |
|83 | [Wie kann man ein Mock-API oder Mock Server verwenden?](#83) |
|84 | [Wie funktioniert Suspense fÃ¼r Datenabfragen?](#84) |
|85 | [](#85) |
|86 | [](#86) |
|87 | [](#87) |
|88 | [](#88) |
|89 | [](#89) |
|90 | [](#90) |
|   | Testing |
|91 | [Was ist Unit-, Integration- und E2E-Testing?](#91) |
|92 | [Was ist Snapshot-Testing?](#92) |
|93 | [Welche Tools nutzt man fÃ¼r React-Tests (Jest, React Testing Library)?](#93) |
|94 | [Wie testet man Komponenten, Props und Events?](#94) |
|95 | [Wie testet man benutzerdefinierte Hooks?](#95) |
|96 | [](#96) |
|97 | [](#97) |
|98 | [](#98) |
|99 | [](#99) |
|100 | [](#100) |
|   | Routing mit React Router |
|101 | [Wie funktioniert Routing in React mit react-router-dom?](#101) |
|102 | [Was sind die Unterschiede zwischen react-router v5 und v6?](#102) |
|103 | [Was sind Route, Link, Navigate, Outlet?](#103) |
|104 | [Wie erstellt man Nested Routes?](#104) |
|105 | [Wie implementiert man Redirects?](#105) |
|106 | [Wie funktioniert programmgesteuerte Navigation (useNavigate)?](#106) |
|107 | [](#107) |
|108 | [](#108) |
|109 | [](#109) |
|110 | [](#110) |
|   | Redux & Redux Toolkit |
|111 | [Was ist Redux und wie funktioniert es?](#111) |
|112 | [Was sind Actions, Reducer und Store?](#112) |
|113 | [Wie funktioniert Redux Toolkit (createSlice, configureStore, createAsyncThunk)?](#113) |
|114 | [Was ist RTK Query?](#114) |
|115 | [Was ist der Unterschied zwischen Redux und der Context-API?](#115) |
|116 | [Was ist connect() in Redux?](#116) |
|117 | [Was sind Middleware in Redux (z. B. redux-thunk, redux-logger)?](#117) |
|118 | [Was ist createSelector und wie funktioniert Reselect?](#118) |
|119 | [Wie verbindet man Redux mit React Ã¼ber Hooks (useSelector, useDispatch)?](#119) |
|120 | [](#120) |
|121 | [](#121) |
|122 | [](#122) |
|123 | [](#123) |
|124 | [](#124) |
|125 | [](#125) |
|126 | [](#126) |
|127 | [](#127) |
|128 | [](#128) |
|129 | [](#129) |
|130 | [](#130) |
|   | Optimierung & Performance |
|131 | [Was ist Code-Splitting?](#131) |
|132 | [Wie funktionieren React.lazy und Suspense?](#132) |
|133 | [Was ist Tree Shaking?](#133) |
|134 | [Was ist Server-Side Rendering (SSR) und Hydration?](#134) |
|135 | [Wie geht man mit Hydration-Fehlern bei SSR um?](#135) |
|136 | [Was bedeutet Virtualisierung (z. B. mit react-window)?](#136) |
|137 | [Wie verhindert man unnÃ¶tige Re-Renders?](#137) |
|138 | [Was ist React Transition Group?](#138) |
|139 | [Was ist React Strict Mode und welche Vorteile bietet er?](#139) |
|140 | [Was ist Concurrent Mode und welche Probleme lÃ¶st er?](#140) |
|141 | [](#141) |
|142 | [](#142) |
|143 | [](#143) |
|144 | [](#144) |
|145 | [](#145) |
|   | Sonstiges |
|146 | [Was ist ein Service Worker?](#146) |
|147 | [Was ist react-helmet und wie hilft es beim SEO?](#147) |
|148 | [Wie funktioniert Lazy Loading mit dynamic import()?](#148) |
|149 | [Was ist ein Finite-State Machine (FSM), z. B. mit XState?](#149) |
|150 | [Wie kann man ein Formular mit Formik und Yup erstellen und validieren?](#150) |
|151 | [Wie konfiguriert man ESLint und Prettier in einem React-Projekt?](#151) |
|152 | [Wie funktioniert dynamic import() in React (Syntax, AnwendungsfÃ¤lle)?](#152) |
|153 | [](#153) |
|154 | [](#154) |
|155 | [](#155) |
|156 | [](#156) |
|157 | [](#157) |
|158 | [](#158) |
|159 | [](#159) |
|160 | [](#160) |
|   | React + TypeScript |
|161 | [Was ist der Unterschied zwischen interface und type in TypeScript?](#161) |
|162 | [Wie typisiert man Props und State in einer funktionalen Komponente?](#162) |
|163 | [Wie nutzt man Generics in React mit TypeScript (z. B. fÃ¼r Listen)?](#163) |
|164 | [Wie typisiert man Events in React mit TypeScript (onChange, onClick, FormEvent, MouseEvent)?](#164) |
|165 | [Wie erstellt man einen benutzerdefinierten Hook mit TypeScript?](#165) |
|166 | [Wie typisiert man useReducer mit TypeScript?](#166) |
|167 | [Wie typisiert man children korrekt in React-Komponenten?](#167) |
|168 | [Was ist React.FC und welche Vor- und Nachteile hat es?](#168) |
|169 | [Wie typisiert man eine Komponente mit optionalen Props?](#169) |
|170 | [Wie arbeitet man mit Drittanbieter-Bibliotheken, die keine Typen enthalten?](#170) |
|171 | [Was ist der Unterschied zwischen ESM und CommonJS?](#171) |
|172 | [](#172) |
|173 | [](#173) |
|174 | [](#174) |
|175 | [](#175) |
|176 | [](#176) |
|177 | [](#177) |
|178 | [](#178) |
|179 | [](#179) |
|180 | [](#180) |
|181 | [](#181) |
|182 | [](#182) |
|183 | [](#183) |
|184 | [](#184) |
|185 | [](#185) |
|186 | [](#186) |
|187 | [](#187) |
|188 | [](#188) |
|189 | [](#189) |
|190 | [](#190) |
|191 | [](#191) |
|192 | [](#192) |
|193 | [](#193) |
|194 | [](#194) |
|195 | [](#195) |
|196 | [](#196) |
|197 | [](#197) |
|198 | [](#198) |
|199 | [](#199) |
|200 | [](#200) |



<a name="questions"></a>

## ReactJS 

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**
  
1. ### <a name="1"></a> Was ist React und welche Probleme lÃ¶st es?

# Was ist React und welche Probleme lÃ¶st es?

**React** ist eine JavaScript-Bibliothek zur Erstellung von **BenutzeroberflÃ¤chen (UIs)**. Sie wurde von **Meta (Facebook)** entwickelt und hilft beim Bau interaktiver, dynamischer Webanwendungen.

---

## ğŸ”§ Welche Probleme lÃ¶st React?

1. **KomplexitÃ¤t groÃŸer Anwendungen**  
   â†’ React zerlegt die UI in **kleine, wiederverwendbare Komponenten**, wodurch der Code modular und wartbar bleibt.

2. **Manuelles DOM-Handling**  
   â†’ Mit dem **virtuellen DOM** optimiert React DOM-Ã„nderungen und verbessert die Performance.

3. **Unstrukturierter Code (z.â€¯B. bei jQuery)**  
   â†’ React fÃ¶rdert einen **komponentenbasierten Aufbau**, bei dem Logik, Markup und Styling zusammengehÃ¶ren.

4. **Schwierige Zustandsverwaltung (State)**  
   â†’ React bietet eingebaute Hooks wie `useState` oder `useReducer`, um den Zustand klar und vorhersehbar zu verwalten.

---

## ğŸ’¡ Beispielcode

```jsx
import { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0); // React verwaltet den Zustand intern

  return (
    <button onClick={() => setCount(count + 1)}>
      Du hast {count} Mal geklickt
    </button>
  );
}
```

â¡ï¸ **React aktualisiert automatisch das UI**, wenn sich der Zustand Ã¤ndert â€“ kein manuelles DOM-Update notwendig.

---

## ğŸ“ Zusammenfassung

React ist eine **komponentenbasierte UI-Bibliothek**, die typische Probleme der Webentwicklung lÃ¶st:

- unÃ¼bersichtlicher Code  
- ineffiziente DOM-Manipulation  
- schwieriges State-Management  
- mangelnde Wiederverwendbarkeit

---

## ğŸ”— Quellen

- [React â€“ Offizielle EinfÃ¼hrung](https://react.dev/learn)
- [React auf MDN Web Docs](https://developer.mozilla.org/de/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_starten)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

2. ### <a name="2"></a> Was ist JSX und warum wird es verwendet?

# Was ist JSX und warum wird es verwendet?

**JSX (JavaScript XML)** ist eine **Erweiterungssyntax fÃ¼r JavaScript**, die es ermÃ¶glicht, HTML-Ã¤hnlichen Code innerhalb von JavaScript zu schreiben. JSX wird von **React** verwendet, um die Struktur der BenutzeroberflÃ¤che deklarativ zu beschreiben.

---

## ğŸ” Warum JSX?

1. **Bessere Lesbarkeit**  
   â†’ JSX kombiniert **HTML-Struktur und JavaScript-Logik** in einem einzigen Codeblock â€“ ideal fÃ¼r Komponenten.

2. **Deklarativer Stil**  
   â†’ Statt manuelle DOM-Elemente mit `document.createElement` zu erzeugen, beschreibt JSX **was** dargestellt werden soll, nicht **wie**.

3. **Kompakter und effizienter Code**  
   â†’ JSX kompiliert zu `React.createElement(...)`-Aufrufen, die das virtuelle DOM erzeugen.

---

## ğŸ’¡ Beispielcode

```jsx
function Welcome(props) {
  return <h1>Hallo, {props.name}!</h1>;
}
```

â¡ï¸ Der obige JSX-Code wird von Babel kompiliert zu:

```js
React.createElement('h1', null, 'Hallo, ', props.name);
```

---

## ğŸ“Œ Wichtig

JSX ist **nicht zwingend erforderlich**, aber stark empfohlen, da es:

- die Entwicklung mit React beschleunigt  
- die Struktur klarer macht  
- die FehleranfÃ¤lligkeit reduziert

---

## ğŸ“ Zusammenfassung

JSX ist eine JavaScript-Erweiterung, die HTML-Ã¤hnlichen Code im JavaScript ermÃ¶glicht.  
Es erleichtert die Entwicklung mit React durch bessere Lesbarkeit, Wartbarkeit und Integration von Logik und Layout.

---

## ğŸ”— Quellen

- [JSX in React â€“ react.dev](https://react.dev/learn/writing-markup-with-jsx)  
- [JSX auf MDN Web Docs](https://developer.mozilla.org/de/docs/Web/JavaScript/JavaScript_technologies_overview#jsx)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

3. ### <a name="3"></a> Was ist Virtual DOM und wie funktioniert es?

# Was ist Virtual DOM und wie funktioniert es?

**Virtual DOM** ist eine in JavaScript abgebildete, **leichte Kopie des echten DOM**. React nutzt dieses Konzept, um effizient UI-Ã„nderungen zu erkennen und durchzufÃ¼hren, ohne den echten DOM direkt zu manipulieren â€“ was langsam und ressourcenintensiv wÃ¤re.

---

## ğŸ”§ Wie funktioniert Virtual DOM?

1. **Rendern in den virtuellen DOM**  
   â†’ React rendert Komponenten zuerst **im virtuellen DOM**, nicht direkt im echten DOM.

2. **Vergleich (Diffing)**  
   â†’ React vergleicht (diffing) den **alten virtuellen DOM** mit dem **neuen**, um herauszufinden, **welche Teile sich verÃ¤ndert haben**.

3. **Minimaler Update im echten DOM**  
   â†’ Nur die **verÃ¤nderten Teile** werden effizient und gezielt im echten DOM aktualisiert.

---

## ğŸ’¡ Beispiel: Wie React intern arbeitet

```jsx
const element = <h1>Hello, world!</h1>;
ReactDOM.render(element, document.getElementById('root'));
```

**Ablauf:**

1. JSX wird zu `React.createElement()` â†’ virtuelles DOM-Element
2. React baut daraus eine virtuelle Baumstruktur
3. Bei Ã„nderungen:
   - React erstellt einen neuen virtuellen DOM
   - vergleicht ihn mit dem alten
   - findet Unterschiede
   - updated gezielt den echten DOM

---

## ğŸ“ˆ Vorteile

- **Performance**: weniger direkte DOM-Zugriffe
- **Klarer Codefluss**: UI-Updates sind vorhersehbar und deklarativ
- **Skalierbarkeit**: geeignet fÃ¼r groÃŸe, dynamische Anwendungen

---

## ğŸ“ Zusammenfassung

Der Virtual DOM ist eine **interne, optimierte Datenstruktur** in React, die es erlaubt, **nur notwendige DOM-Ã„nderungen** durchzufÃ¼hren. Dadurch wird die Performance deutlich verbessert und die UI bleibt synchron mit dem App-Zustand.

---

## ğŸ”— Quellen

- [React: Rendering und Virtual DOM](https://react.dev/learn/rendering-elements)  
- [MDN: DOM vs Virtual DOM (extern)](https://developer.mozilla.org/)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

4. ### <a name="4"></a> Was ist der Unterschied zwischen React und ReactDOM?

# Was ist der Unterschied zwischen React und ReactDOM?

**React** und **ReactDOM** sind zwei getrennte Pakete mit unterschiedlichen Aufgaben in einer React-Anwendung.

---

## ğŸ“¦ React

Das Paket `react` enthÃ¤lt:

- Die **Core-FunktionalitÃ¤t** von React
- **Komponentenlogik**, z.â€¯B. `useState`, `useEffect`, `useReducer`
- Das Erstellen von **React-Elementen** Ã¼ber `React.createElement()`
- JSX-Verarbeitung (nach dem Transpiling)

### Beispiel:

```jsx
import { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);
  return <button onClick={() => setCount(count + 1)}>ZÃ¤hler: {count}</button>;
}
```

---

## ğŸŒ ReactDOM

Das Paket `react-dom` wird verwendet, um **React-Komponenten in das DOM** des Browsers zu rendern.

- Bindeglied zwischen **virtuellem DOM (React)** und **echtem DOM (Browser)**
- EnthÃ¤lt Methoden wie `ReactDOM.createRoot()` oder `ReactDOM.render()` (frÃ¼her)

### Beispiel:

```jsx
import ReactDOM from 'react-dom/client';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);
```

---

## ğŸ“ Zusammenfassung

| Paket      | Aufgabe                          |
|------------|----------------------------------|
| `react`    | Erstellen von Komponenten, Hooks, virtueller DOM |
| `react-dom`| Rendering ins Browser-DOM        |

---

## ğŸ”— Quellen

- [React â€“ EinfÃ¼hrung](https://react.dev/learn)  
- [ReactDOM API â€“ react.dev](https://react.dev/reference/react-dom)  
- [MDN Web Docs: EinfÃ¼hrung in React](https://developer.mozilla.org/de/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_starten)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

5. ### <a name="5"></a> Warum importieren wir React, auch wenn es scheinbar nicht benutzt wird?

# Warum importieren wir React, auch wenn es scheinbar nicht benutzt wird?

FrÃ¼her (vor React 17) musste man `React` **immer importieren**, wenn man JSX benutzt hat, **auch wenn man React nicht direkt im Code verwendet** hat.

---

## ğŸ§  Warum?

JSX wird vom Compiler (z.â€¯B. Babel) in `React.createElement()`-Aufrufe umgewandelt:

```jsx
const element = <h1>Hello</h1>;
```

wird zu:

```js
const element = React.createElement('h1', null, 'Hello');
```

â¡ï¸ Deshalb musste `React` **immer verfÃ¼gbar** sein.

---

## ğŸ”„ Seit React 17+

Dank des neuen JSX-Transform ist der `React`-Import **nicht mehr zwingend nÃ¶tig**, **wenn du einen modernen Build-Tool (z.â€¯B. Vite, CRA, Next.js)** verwendest.

### Beispiel (ab React 17):

```jsx
function App() {
  return <h1>Hello World</h1>;
}

// kein expliziter Import von React nÃ¶tig, wenn JSX-Transform aktiv
```

---

## ğŸ“¦ Voraussetzung

Damit das funktioniert, muss dein Projekt folgende Bedingungen erfÃ¼llen:

- React 17 oder neuer  
- JSX-Transform ist im Build-Tool (z.â€¯B. Babel, Vite, CRA) aktiviert  
- Du benutzt keine `React.createElement()` direkt

---

## ğŸ“ Zusammenfassung

FrÃ¼her war der Import von `React` bei JSX zwingend, da JSX zu `React.createElement()` kompiliert wurde.  
Seit React 17 ist der Import **nicht mehr notwendig**, wenn moderne Tools und der neue JSX-Transform verwendet werden.

---

## ğŸ”— Quellen

- [JSX-Transform ErklÃ¤rung â€“ React](https://react.dev/learn/writing-markup-with-jsx#the-new-jsx-transform)
- [JSX auf MDN](https://developer.mozilla.org/de/docs/Web/JavaScript/JavaScript_technologies_overview#jsx)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

6. ### <a name="6"></a> Was ist ein React Fragment und warum ist es nÃ¼tzlich?

# Was ist ein React Fragment und warum ist es nÃ¼tzlich?

Ein **React Fragment** (`<React.Fragment>` oder `<> </>`) ist ein **Wrapper ohne zusÃ¤tzliches HTML-Element im DOM**.  
Er wird verwendet, wenn eine Komponente **mehrere Elemente zurÃ¼ckgeben** muss, ohne unnÃ¶tiges Markup zu erzeugen.

---

## ğŸ” Warum nÃ¼tzlich?

- Vermeidet zusÃ¤tzliche DOM-Knoten (z.â€¯B. unnÃ¶tige `<div>`s)
- Macht den DOM sauberer und strukturierter
- Erforderlich, da JSX nur **ein Wurzelelement** pro Komponente erlaubt

---

## ğŸ’¡ Beispiel mit Fragment

```jsx
function UserInfo() {
  return (
    <>
      <h1>Max Mustermann</h1>
      <p>Frontend Developer</p>
    </>
  );
}
```

Das erzeugt im echten DOM **nur `<h1>` und `<p>`**, **kein zusÃ¤tzliches Wrapper-Element**.

---

## ğŸ’¡ Alternativ: `React.Fragment` mit Key (nÃ¼tzlich in Listen)

```jsx
<>
  {items.map(item => (
    <React.Fragment key={item.id}>
      <dt>{item.name}</dt>
      <dd>{item.description}</dd>
    </React.Fragment>
  ))}
</>
```

â¡ï¸ Nur `React.Fragment` (nicht `<>`) unterstÃ¼tzt `key`-Props.

---

## ğŸ“ Zusammenfassung

React Fragments erlauben das Gruppieren mehrerer Elemente **ohne zusÃ¤tzliches DOM-Element**.  
Sie sorgen fÃ¼r **sauberen Code und schlankes HTML**.

---

## ğŸ”— Quellen

- [Fragments â€“ React Docs](https://react.dev/reference/react/Fragment)  
- [JSX mit Fragmenten â€“ MDN](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#react_fragments)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

7. ### <a name="7"></a> Was ist der Unterschied zwischen einem Element, einer Komponente und einer Instanz?

# Was ist der Unterschied zwischen einem Element, einer Komponente und einer Instanz?

In React gibt es drei zentrale Begriffe, die oft verwechselt werden: **Element**, **Komponente** und **Instanz**.  
Hier ist eine klare Unterscheidung:

---

## 1. ğŸ§± React Element

Ein **React-Element** ist ein **einfaches JavaScript-Objekt**, das beschreibt, **was im UI gerendert werden soll**.

Es ist **keine Komponente** selbst, sondern das Ergebnis von JSX oder `React.createElement()`.

### Beispiel:

```jsx
const element = <h1>Hello, world!</h1>;
```

â¡ï¸ Das ist ein **React-Element**, kein DOM-Knoten.

---

## 2. âš™ï¸ React Komponente

Eine **Komponente** ist eine **Funktion oder Klasse**, die ein React-Element zurÃ¼ckgibt.

Sie beschreibt **wie ein UI-Teil aussehen und sich verhalten soll**. Komponenten kÃ¶nnen **wiederverwendet** und **verschachtelt** werden.

### Beispiel:

```jsx
function Welcome(props) {
  return <h1>Hallo, {props.name}</h1>;
}
```

â¡ï¸ Dies ist eine **Komponente**, die ein **Element** zurÃ¼ckgibt.

---

## 3. ğŸ§¬ Instanz (Komponenteninstanz)

Eine **Instanz** entsteht, wenn React eine Komponente **rendert** und ihren internen Zustand (State, Lifecycle etc.) verwaltet.  
Bei **Funktionalen Komponenten** ist die Instanzierung â€unsichtbarâ€œ, bei **Klassenkomponenten** existiert ein echtes Objekt.

â¡ï¸ Die Instanz ist das **laufende Exemplar** einer Komponente mit Daten, Hooks, Events etc.

---

## ğŸ” Vergleich

| Begriff       | Was ist es?                         | Beispiel                                      |
|---------------|--------------------------------------|-----------------------------------------------|
| Element       | Objekt, das UI beschreibt            | `<div>Hello</div>`                            |
| Komponente    | Funktion/Klasse, die ein Element zurÃ¼ckgibt | `function App() { return <div /> }`        |
| Instanz       | Laufzeit-Exemplar einer Komponente   | AusfÃ¼hrung mit State, Props etc.              |

---

## ğŸ“ Zusammenfassung

- **Element**: Beschreibung eines UI-Teils (z.â€¯B. `<h1>Hello</h1>`)
- **Komponente**: Funktion/Klasse, die Elemente zurÃ¼ckgibt
- **Instanz**: Laufendes Objekt der Komponente zur Laufzeit mit State und Verhalten

---

## ğŸ”— Quellen

- [React: Komponenten & Rendering â€“ react.dev](https://react.dev/learn/your-first-component)  
- [MDN: JSX und React-Komponenten](https://developer.mozilla.org/de/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_starten)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

8. ### <a name="8"></a> Was ist das Fiber-Architekturmodell in React?

# Was ist das Fiber-Architekturmodell in React?

**Fiber** ist die **neue Rendering-Engine von React**, eingefÃ¼hrt mit React 16.  
Sie ersetzt das alte, **rekursive Rendering-Modell** und ermÃ¶glicht eine **feinere Steuerung des Renderprozesses**.

---

## ğŸ¯ Warum wurde Fiber eingefÃ¼hrt?

Das alte Modell (Stack Reconciler) hatte folgende Probleme:

- UI konnte bei groÃŸen Updates **nicht unterbrochen** werden  
- Keine **Priorisierung** von wichtigen Updates (z.â€¯B. Benutzerinteraktionen)
- Kein gutes Fundament fÃ¼r **Concurrent Mode**, **Suspense** oder **Time Slicing**

---

## ğŸ§¬ Was macht Fiber besser?

### âœ… Unterbrechbares Rendering

React kann Rendering-Arbeit **in kleine Schritte aufteilen** und zwischenzeitlich pausieren oder abbrechen.

### âœ… Priorisierung

Fiber erlaubt die **Zuweisung von PrioritÃ¤ten** zu verschiedenen Updates:  
â†’ z.â€¯B. Benutzerinteraktionen werden schneller behandelt als langsame Datenupdates.

### âœ… Besseres Fehler-Handling

Fiber macht es mÃ¶glich, **Fehlergrenzen (Error Boundaries)** effizient zu verwenden.

---

## ğŸ”§ Wie funktioniert Fiber technisch?

- React erstellt beim Rendern eine **Fiber-Node** fÃ¼r jedes Element
- Diese Nodes bilden einen **Fiber-Tree**, Ã¤hnlich wie ein virtuelles DOM
- Der Tree wird **inkrementell** und **asynchron** verarbeitet
- Nach dem Vergleich (Reconciliation) folgt die **Commit-Phase**, wo echte DOM-Updates stattfinden

---

## ğŸ’¡ Beispiel: Priorisierung

```jsx
startTransition(() => {
  // niedrige PrioritÃ¤t â€“ z.â€¯B. Daten neu laden
  setSearchQuery(input);
});
```

â¡ï¸ Dank Fiber kann React Hintergrundarbeit (wie Filterung) **niedrig priorisieren**.

---

## ğŸ“ Zusammenfassung

Das **Fiber-Modell** ist Reacts moderne Rendering-Architektur.  
Es bringt:

- unterbrechbares Rendering  
- Priorisierung von Updates  
- bessere Performance bei groÃŸen Anwendungen  
- Grundlage fÃ¼r neue Features wie **Concurrent Mode** und **Suspense**

---

## ğŸ”— Quellen

- [React: EinfÃ¼hrung in Fiber](https://react.dev/learn/rendering-and-committing)  
- [React Fiber Architecture (Deep Dive â€“ englisch)](https://github.com/acdlite/react-fiber-architecture)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

9. ### <a name="9"></a> Was bedeutet â€Batchingâ€œ in React?

# Was bedeutet â€Batchingâ€œ in React?

**Batching** bezeichnet in React den Prozess, **mehrere State-Ã„nderungen zu einer einzigen Rendering-Phase zusammenzufassen**, um unnÃ¶tige Re-Renders zu vermeiden und die Performance zu verbessern.

---

## ğŸ¯ Warum ist Batching wichtig?

Ohne Batching wÃ¼rde jede einzelne `setState`- oder `useState`-Ã„nderung **sofort** ein neues Rendern auslÃ¶sen â€“ selbst wenn sie direkt hintereinander stehen.

### Beispiel **ohne Batching (theoretisch)**

```jsx
setCount(count + 1);
setName('Anna');
```

â†’ Ohne Batching: 2 Re-Renders  
â†’ Mit Batching: **nur 1 Re-Render**

---

## ğŸ§  Wie funktioniert Batching?

- In **Event-Handlern** (z.â€¯B. `onClick`, `onChange`) **batcht React automatisch**
- Seit React 18 funktioniert Batching auch in **`setTimeout`, Promises, async/await**, etc.

### Beispiel:

```jsx
function handleClick() {
  setCount(c => c + 1);
  setName('Anna');
}
```

â¡ï¸ React fÃ¼hrt **nur einen Re-Render** durch, obwohl 2 States geÃ¤ndert wurden.

---

## ğŸ” Batching in asynchronem Code (ab React 18)

```jsx
useEffect(() => {
  fetchData().then(() => {
    setLoading(false);
    setData(result);
  });
}, []);
```

â†’ Auch hier wird **automatisch gebatcht** (ab React 18), sodass nur ein Re-Render erfolgt.

---

## ğŸ› ï¸ Manuelles Batching (z.â€¯B. auÃŸerhalb von React-Kontexten)

Falls nÃ¶tig, kann man `flushSync()` oder `unstable_batchedUpdates()` verwenden â€“ aber in der Regel ist das nicht notwendig.

---

## ğŸ“ Zusammenfassung

**Batching** fasst mehrere State-Ã„nderungen in einer Rendering-Phase zusammen.  
Das reduziert die Anzahl der Re-Renders und verbessert die Performance â€“ vor allem bei komplexen Komponenten.

---

## ğŸ”— Quellen

- [Batching â€“ React Docs](https://react.dev/learn/state-a-components-memory#react-batches-state-updates)  
- [React 18 Automatic Batching](https://react.dev/learn/queueing-a-series-of-state-updates#react-batches-state-updates)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

10. ### <a name="10"></a> Was ist die Rolle des key in React-Listen?

# Was ist die Rolle des `key` in React-Listen?

In React ist der `key` ein **einzigartiger Identifikator** fÃ¼r jedes Element in einer Liste.  
Er hilft React, **zu erkennen, welche Elemente sich geÃ¤ndert, hinzugefÃ¼gt oder entfernt** haben.

---

## ğŸ¯ Warum ist `key` wichtig?

React verwendet `key`, um die **Effizienz beim Rendering** zu erhÃ¶hen:

- Vermeidet unnÃ¶tige Neurenderings
- Beibehaltung des Zustands bei gleichbleibenden Komponenten
- PrÃ¤zises **Vergleichen alter und neuer Elemente** im virtuellen DOM

---

## âŒ Problem ohne `key`

```jsx
{items.map(item => (
  <li>{item.text}</li>  // kein key â†’ ineffizient und potenziell buggy
))}
```

â¡ï¸ React kann nicht eindeutig zuordnen, welches Element welches ist.

---

## âœ… Richtige Nutzung von `key`

```jsx
{items.map(item => (
  <li key={item.id}>{item.text}</li>
))}
```

â¡ï¸ `key={item.id}` sorgt dafÃ¼r, dass React jedes Element **korrekt identifiziert**.

---

## âš ï¸ Warnung: Kein Index als `key`, auÃŸer in SonderfÃ¤llen

```jsx
// schlecht bei dynamischen Listen
<li key={index}>{item.text}</li>
```

Vermeide den **Array-Index als key**, weil das zu **falschen Updates** fÃ¼hren kann, wenn sich die Reihenfolge Ã¤ndert.

---

## ğŸ“ Zusammenfassung

Der `key` in React-Listen dient zur **eindeutigen Identifizierung von Listenelementen**.  
Er verbessert die Performance und verhindert Rendering-Probleme.  
â†’ Verwende **stabile, eindeutige Werte** wie `id`, nicht den Array-Index.

---

## ğŸ”— Quellen

- [Rendering-Listen mit keys â€“ react.dev](https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key)  
- [React keys auf MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#react_keys)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

11. ### <a name="11"></a> Wie funktioniert die Wiederverwendung von Komponenten?

# Wie funktioniert die Wiederverwendung von Komponenten?

In React bedeutet **Wiederverwendung**, dass dieselbe Komponente **mehrfach an verschiedenen Stellen mit unterschiedlichen Daten (Props)** eingesetzt werden kann.  
Das macht den Code **modular, DRY (Don't Repeat Yourself)** und wartungsfreundlich.

---

## ğŸ” Wie funktioniert das?

### 1. **Komponente erstellen (z.â€¯B. `Button`)**

```jsx
function Button({ label, onClick }) {
  return <button onClick={onClick}>{label}</button>;
}
```

### 2. **Wiederverwendung mit unterschiedlichen Props**

```jsx
<Button label="Speichern" onClick={saveData} />
<Button label="LÃ¶schen" onClick={deleteData} />
```

â¡ï¸ React verwendet dieselbe **Komponentenlogik**, aber mit unterschiedlichen **Eigenschaften (Props)**.

---

## ğŸ“¦ Vorteile der Wiederverwendung

- âœ… Einheitliches Verhalten
- âœ… Leichter wartbar
- âœ… Skalierbarer Code
- âœ… Kombinierbarkeit zu grÃ¶ÃŸeren Komponenten

---

## ğŸ’¡ Wiederverwendung auch innerhalb anderer Komponenten

```jsx
function Dialog() {
  return (
    <div>
      <Button label="Abbrechen" onClick={closeDialog} />
      <Button label="BestÃ¤tigen" onClick={confirmAction} />
    </div>
  );
}
```

â¡ï¸ Komponenten kÃ¶nnen **geschachtelt und kombiniert** werden.

---

## ğŸ“ Zusammenfassung

Komponenten werden in React wiederverwendet, indem man sie **mit verschiedenen Props mehrfach rendert**.  
Das fÃ¶rdert sauberen, wartbaren und skalierbaren Code.

---

## ğŸ”— Quellen

- [React Komponenten wiederverwenden â€“ react.dev](https://react.dev/learn/passing-props-to-a-component)  
- [Komponentenstruktur â€“ MDN Web Docs](https://developer.mozilla.org/de/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_components)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

12. ### <a name="12"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

13. ### <a name="13"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

14. ### <a name="14"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

15. ### <a name="15"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

16. ### <a name="16"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

17. ### <a name="17"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

18. ### <a name="18"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

19. ### <a name="19"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

20. ### <a name="20"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

21. ### <a name="21"></a> Was sind Props und wozu werden sie verwendet?

# Was sind Props und wozu werden sie verwendet?

**Props** (kurz fÃ¼r **"Properties"**) sind **Daten, die von einer Elternkomponente an eine Kindkomponente Ã¼bergeben werden**.  
Sie machen React-Komponenten **dynamisch und wiederverwendbar**.

---

## ğŸ§  Eigenschaften von Props

- Props sind **nur lesbar** (readonly)
- Sie werden **als Objekt** an Komponenten Ã¼bergeben
- Sie ermÃ¶glichen das **Anpassen des Verhaltens oder Inhalts** einer Komponente

---

## ğŸ’¡ Beispiel

### Elternkomponente:

```jsx
function App() {
  return <Welcome name="Sergii" />;
}
```

### Kindkomponente:

```jsx
function Welcome(props) {
  return <h1>Hallo, {props.name}!</h1>;
}
```

â¡ï¸ `name="Sergii"` ist ein **Prop**, das an `Welcome` Ã¼bergeben wird.  
Im Code erreichbar Ã¼ber `props.name`.

---

## ğŸ¯ Wozu werden Props verwendet?

- Weitergabe von Daten zwischen Komponenten  
- Wiederverwendung einer Komponente mit **unterschiedlichen Inhalten**  
- Kommunikation **von Eltern zu Kind**

---

## ğŸ“¦ Props mit Destructuring

```jsx
function Welcome({ name }) {
  return <h1>Hallo, {name}!</h1>;
}
```

â¡ï¸ Kurzform fÃ¼r besseren Lesefluss.

---

## ğŸ“ Zusammenfassung

**Props** sind Eingabedaten fÃ¼r Komponenten.  
Sie ermÃ¶glichen die **dynamische Anpassung** von Komponenten und fÃ¶rdern **Wiederverwendbarkeit**.  
Props flieÃŸen **nur von oben nach unten** (Parent â†’ Child).

---

## ğŸ”— Quellen

- [Props in React â€“ react.dev](https://react.dev/learn/passing-props-to-a-component)  
- [Komponenten und Props â€“ MDN Web Docs](https://developer.mozilla.org/de/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_components#eigenschaften_props)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

22. ### <a name="22"></a> Was ist der Unterschied zwischen Props und State?

# Was ist der Unterschied zwischen Props und State?

In React sind **Props** und **State** zwei zentrale Konzepte zur Steuerung von Daten in Komponenten.  
Sie dienen unterschiedlichen Zwecken und haben verschiedene Eigenschaften.

---

## ğŸ“¦ Props

- **Daten von auÃŸen** â†’ werden von der **Elternkomponente Ã¼bergeben**
- **Readonly**: kÃ¶nnen innerhalb der Komponente **nicht verÃ¤ndert** werden
- Erlauben die **Wiederverwendung von Komponenten**
- FlieÃŸen **von oben nach unten** (unidirektional)

### Beispiel:

```jsx
function Welcome({ name }) {
  return <h1>Hallo, {name}!</h1>;
}
```

â†’ `name` ist ein **Prop**, das z.â€¯B. von `<Welcome name="Anna" />` kommt

---

## ğŸ”„ State

- **Interne Daten** einer Komponente  
- KÃ¶nnen sich **im Lauf der Zeit Ã¤ndern** (z.â€¯B. durch Benutzerinteraktion)
- Ã„nderungen am State fÃ¼hren zu **einem Re-Render**
- Wird mit Hooks wie `useState` verwaltet

### Beispiel:

```jsx
function Counter() {
  const [count, setCount] = useState(0);
  return <button onClick={() => setCount(count + 1)}>ZÃ¤hler: {count}</button>;
}
```

â†’ `count` ist der **State** der Komponente

---

## ğŸ” Vergleich Props vs. State

| Merkmal          | Props                      | State                          |
|------------------|----------------------------|--------------------------------|
| Ursprung         | Elternkomponente           | Innerhalb der Komponente       |
| VerÃ¤nderbar?     | âŒ Nein (readonly)         | âœ… Ja (mit `setState` / `useState`) |
| Zweck            | Konfiguration von auÃŸen    | Dynamische, sich Ã¤ndernde Daten |
| Kontrolle        | Vom Elternteil gesteuert   | Von der Komponente selbst      |

---

## ğŸ“ Zusammenfassung

- **Props**: Eingabedaten von auÃŸen, unverÃ¤nderlich, durch Eltern gesteuert  
- **State**: Interner Zustand, verÃ¤nderlich, durch die Komponente selbst verwaltet

Beides zusammen macht Komponenten **dynamisch und wiederverwendbar**.

---

## ğŸ”— Quellen

- [Props vs. State â€“ react.dev](https://react.dev/learn/state-a-components-memory#comparing-state-and-props)  
- [MDN: Komponenten mit Props und State](https://developer.mozilla.org/de/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_components)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

23. ### <a name="23"></a> Warum sind Props nur lesbar?

# Warum sind Props nur lesbar?

**Props** (Properties) sind in React **nur lesbar**, weil sie die Daten darstellen,  
die **von auÃŸen** (also von der Elternkomponente) **an eine Kindkomponente Ã¼bergeben werden**.

---

## ğŸ¯ HauptgrÃ¼nde fÃ¼r die UnverÃ¤nderlichkeit von Props

### 1. ğŸ”’ **Datenfluss kontrollieren (UnidirektionalitÃ¤t)**

React folgt dem Prinzip des **einseitigen Datenflusses**:  
Daten flieÃŸen **von oben (Parent) nach unten (Child)**.  
Wenn Kind-Komponenten Props verÃ¤ndern kÃ¶nnten, wÃ¼rde der Datenfluss **chaotisch und unvorhersehbar** werden.

---

### 2. ğŸ§© **Komponenten bleiben vorhersehbar und wiederverwendbar**

Eine Komponente, die ihre Props **nicht verÃ¤ndert**, ist:

- einfacher zu testen  
- leichter wiederzuverwenden  
- unabhÃ¤ngig vom Kontext, in dem sie verwendet wird

---

### 3. ğŸ” Ã„nderungen sollen in der Elternkomponente passieren

Wenn sich ein Wert Ã¤ndern soll, soll die **Elternkomponente** dies tun und **neue Props Ã¼bergeben**.

### Beispiel:

```jsx
function Child({ count }) {
  // count ist readonly
  return <p>ZÃ¤hler: {count}</p>;
}
```

â¡ï¸ Wenn `count` verÃ¤ndert werden soll, muss das in der **Elternkomponente** passieren, z.â€¯B. mit `useState`.

---

## ğŸ”§ Was tun, wenn sich Werte Ã¤ndern sollen?

Verwende **State (`useState`)** in der Elternkomponente und gib ggf. **Callback-Funktionen** per Prop mit.

```jsx
function Parent() {
  const [count, setCount] = useState(0);

  return <Child count={count} onIncrement={() => setCount(count + 1)} />;
}
```

---

## ğŸ“ Zusammenfassung

**Props sind nur lesbar**, um den **einseitigen Datenfluss** zu erhalten, die **Vorhersehbarkeit** der Komponenten zu sichern und Ã„nderungen **kontrolliert Ã¼ber die Elternkomponente** zu steuern.

---

## ğŸ”— Quellen

- [Props in React â€“ react.dev](https://react.dev/learn/passing-props-to-a-component)  
- [Datenfluss in React â€“ react.dev](https://react.dev/learn/thinking-in-react#step-5-add-inverse-data-flow)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

24. ### <a name="24"></a> Wie funktioniert der unidirektionale Datenfluss in React?

# Wie funktioniert der unidirektionale Datenfluss in React?

In React bedeutet **unidirektionaler Datenfluss**, dass **Daten immer nur in eine Richtung flieÃŸen**:  
**von der Elternkomponente zur Kindkomponente**.

---

## ğŸ” Was heiÃŸt das konkret?

- Elternkomponenten **geben Daten Ã¼ber Props weiter**
- Kindkomponenten kÃ¶nnen diese Props **verwenden**, aber **nicht verÃ¤ndern**
- Ã„nderungen am Zustand (State) **finden immer in der zustÃ¤ndigen Komponente statt**

---

## ğŸ“¦ Beispiel

```jsx
function Parent() {
  const [count, setCount] = useState(0);

  return <Child count={count} onIncrement={() => setCount(count + 1)} />;
}

function Child({ count, onIncrement }) {
  return (
    <div>
      <p>ZÃ¤hler: {count}</p>
      <button onClick={onIncrement}>+1</button>
    </div>
  );
}
```

### ErklÃ¤rung:

- `Parent` hÃ¤lt den **State**
- `Child` bekommt `count` und `onIncrement` als **Props**
- Der Datenfluss geht **von Parent â†’ Child**
- Ã„nderungen (Button-Klick) **lÃ¶sen in der Elternkomponente eine State-Ã„nderung aus**, die **neue Props an das Kind sendet**

---

## ğŸ¯ Vorteile des unidirektionalen Datenflusses

- âœ… **Vorhersehbares Verhalten**
- âœ… **Bessere Debuggability**
- âœ… Klare Trennung von ZustÃ¤ndigkeiten
- âœ… Weniger Fehler durch unkontrollierte DatenÃ¤nderungen

---

## ğŸ” Daten â€nach obenâ€œ geben (umgekehrt)

Kindkomponenten kÃ¶nnen Ã¼ber **Callback-Funktionen als Prop** indirekt Daten nach oben melden:

```jsx
onChange={(newValue) => parentCallback(newValue)}
```

â¡ï¸ So bleibt die **Datenkontrolle bei der Elternkomponente**.

---

## ğŸ“ Zusammenfassung

Der **unidirektionale Datenfluss** sorgt dafÃ¼r, dass Daten in React immer von **Eltern zu Kind** flieÃŸen.  
Das sorgt fÃ¼r eine **klare Struktur**, bessere Wartbarkeit und **kontrollierbare ZustandsÃ¤nderungen**.

---

## ğŸ”— Quellen

- [Thinking in React â€“ react.dev](https://react.dev/learn/thinking-in-react#step-5-add-inverse-data-flow)  
- [Props und Datenfluss â€“ MDN](https://developer.mozilla.org/de/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_components#datenfluss)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

25. ### <a name="25"></a> Was ist State in Klassen- und Funktionskomponenten?

# Was ist State in Klassen- und Funktionskomponenten?

**State** ist ein **interner Speicher** (Zustand) einer React-Komponente, der sich **Ã¼ber die Zeit Ã¤ndern** kann.  
Ã„nderungen am State lÃ¶sen ein **automatisches Re-Rendern** der Komponente aus.

---

## âš™ï¸ State in Funktionskomponenten (mit Hooks)

Seit React 16.8 wird State in Funktionskomponenten mit dem Hook `useState` verwaltet.

### Beispiel:

```jsx
import { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0); // count = aktueller Wert, setCount = Funktion zum Ã„ndern

  return (
    <button onClick={() => setCount(count + 1)}>
      Du hast {count} Mal geklickt
    </button>
  );
}
```

â¡ï¸ Jeder `setCount` lÃ¶st ein **Re-Rendern** der Komponente mit dem neuen Wert aus.

---

## ğŸ—ï¸ State in Klassenkomponenten (vor Hooks)

Vor Hooks wurde der State mit `this.state` und `this.setState()` in **Klassenkomponenten** verwendet.

### Beispiel:

```jsx
import React, { Component } from 'react';

class Counter extends Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 }; // Initialwert
  }

  render() {
    return (
      <button onClick={() => this.setState({ count: this.state.count + 1 })}>
        Du hast {this.state.count} Mal geklickt
      </button>
    );
  }
}
```

â¡ï¸ `this.setState()` aktualisiert den Zustand **asynchron** und triggert ein Re-Render.

---

## ğŸ” Vergleich: Funktions- vs. Klassenkomponenten

| Merkmal         | Funktionskomponente      | Klassenkomponente           |
|-----------------|--------------------------|-----------------------------|
| EinfÃ¼hrung ab   | React 16.8 (mit Hooks)   | FrÃ¼here React-Versionen     |
| State-Verwaltung| `useState()`             | `this.state` + `setState()` |
| Syntax          | Einfacher, moderner      | Komplexer, mehr Boilerplate |

---

## ğŸ“ Zusammenfassung

**State** ist der dynamische Datenbereich einer Komponente.  
- In **Funktionskomponenten** nutzt man `useState`  
- In **Klassenkomponenten** verwendet man `this.state` und `this.setState`  
State-Ã„nderungen fÃ¼hren **automatisch zu UI-Updates**

---

## ğŸ”— Quellen

- [State in React â€“ react.dev](https://react.dev/learn/state-a-components-memory)  
- [useState Hook â€“ react.dev](https://react.dev/reference/react/useState)  
- [MDN: Klassenkomponenten und State](https://developer.mozilla.org/de/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_components#state_in_klassenkomponenten)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

26. ### <a name="26"></a> Wie funktioniert setState?

# Wie funktioniert `setState`?

`setState` ist die Methode in React, mit der der **Zustand (State)** einer Komponente **aktualisiert** wird.  
Sie ist in **Klassenkomponenten** verfÃ¼gbar und wird in **Funktionskomponenten** durch `useState` ersetzt.

---

## âš™ï¸ `setState` in Klassenkomponenten

### Beispiel:

```jsx
class Counter extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }

  increment = () => {
    this.setState({ count: this.state.count + 1 });
  };

  render() {
    return <button onClick={this.increment}>ZÃ¤hler: {this.state.count}</button>;
  }
}
```

### Was passiert hier?

1. `this.setState(...)` wird aufgerufen
2. React **merged** das neue Objekt mit dem aktuellen `state`
3. Es erfolgt ein **Re-Render** der Komponente mit dem neuen Zustand

---

## âš ï¸ Wichtig: `setState` ist **asynchron**

Das bedeutet: Wenn du direkt nach `setState` auf `this.state` zugreifst, ist der neue Wert noch **nicht garantiert verfÃ¼gbar**.

### Falsch:

```js
this.setState({ count: this.state.count + 1 });
console.log(this.state.count); // Kann noch alt sein!
```

---

## âœ… Korrekt mit Callback-Funktion (abhÃ¤ngig vom vorherigen Wert)

```js
this.setState((prevState) => ({
  count: prevState.count + 1
}));
```

â¡ï¸ So stellst du sicher, dass du immer mit dem aktuellen Zustand arbeitest â€“ auch bei mehreren State-Updates hintereinander.

---

## ğŸ“˜ In Funktionskomponenten

Verwendet man stattdessen `useState`:

```jsx
const [count, setCount] = useState(0);
setCount(count + 1);
```

---

## ğŸ“ Zusammenfassung

- `setState` aktualisiert den Zustand in **Klassenkomponenten**
- Updates sind **asynchron** und kÃ¶nnen **gebatcht** werden
- Verwende Callback-Form (`prevState`) bei abhÃ¤ngigen Updates
- In **Funktionskomponenten** wird `useState` verwendet

---

## ğŸ”— Quellen

- [setState â€“ React Docs](https://react.dev/reference/react/Component#setstate)  
- [State-Updates richtig ausfÃ¼hren â€“ react.dev](https://react.dev/learn/queueing-a-series-of-state-updates)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

27. ### <a name="27"></a> Was ist der Unterschied zwischen kontrollierten und unkontrollierten Komponenten?

# Was ist der Unterschied zwischen kontrollierten und unkontrollierten Komponenten?

In React unterscheidet man zwischen **kontrollierten** und **unkontrollierten Komponenten**,  
wenn es um die Verwaltung von Formular-Elementen wie `<input>`, `<textarea>` oder `<select>` geht.

---

## âœ… Kontrollierte Komponenten

Bei **kontrollierten Komponenten** wird der **Wert eines Formularfelds durch den React-State gesteuert**.

### Merkmale:

- Der **aktuelle Wert** kommt aus dem `useState`-State
- Ã„nderungen werden Ã¼ber `onChange` an React gemeldet
- Die Komponente ist **vollstÃ¤ndig unter Reacts Kontrolle**

### Beispiel:

```jsx
function ControlledInput() {
  const [value, setValue] = useState('');

  return (
    <input 
      value={value} 
      onChange={(e) => setValue(e.target.value)} 
    />
  );
}
```

â¡ï¸ Der `value` wird durch den State bestimmt. React "besitzt" das Eingabefeld.

---

## âŒ Unkontrollierte Komponenten

Bei **unkontrollierten Komponenten** Ã¼bernimmt **das DOM selbst die Kontrolle Ã¼ber den Wert**.  
React greift bei Bedarf Ã¼ber ein **Ref** darauf zu.

### Merkmale:

- Kein `useState`, kein `onChange`
- Zugriff Ã¼ber `useRef` â†’ z.â€¯B. beim Abschicken eines Formulars
- Das Feld verwaltet seinen Zustand **eigenstÃ¤ndig**

### Beispiel:

```jsx
function UncontrolledInput() {
  const inputRef = useRef();

  const handleSubmit = () => {
    alert(inputRef.current.value);
  };

  return (
    <>
      <input ref={inputRef} />
      <button onClick={handleSubmit}>Absenden</button>
    </>
  );
}
```

â¡ï¸ React greift **nur lesend** auf den DOM zu â€“ keine direkte Kontrolle Ã¼ber den Wert.

---

## ğŸ” Vergleich

| Merkmal               | Kontrolliert                 | Unkontrolliert              |
|------------------------|------------------------------|------------------------------|
| Wertquelle             | React-State (`useState`)     | DOM                          |
| Kontrolle              | React                        | Browser                      |
| Zugriff auf Wert       | `value` + `onChange`         | `useRef().current.value`     |
| Empfohlen fÃ¼r          | Validierung, komplexe Logik  | einfache Formulare, schnelles Prototyping |

---

## ğŸ“ Zusammenfassung

- **Kontrollierte Komponenten**: React verwaltet den Eingabewert â†’ prÃ¤zise, kontrolliert, ideal fÃ¼r Validierung
- **Unkontrollierte Komponenten**: DOM verwaltet den Wert â†’ einfacher, aber weniger flexibel

---

## ğŸ”— Quellen

- [Kontrollierte Komponenten â€“ react.dev](https://react.dev/learn/sharing-state-between-components#controlled-and-uncontrolled-components)  
- [Formulare in React â€“ MDN](https://developer.mozilla.org/de/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_forms)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

28. ### <a name="28"></a> Was sind Default Props und PropTypes?

# Was sind Default Props und PropTypes?

In React bieten **Default Props** und **PropTypes** zwei MÃ¶glichkeiten, um die Verwendung von **Props sicherer und robuster** zu machen.

---

## âœ… 1. Default Props

**Default Props** sind **Standardwerte** fÃ¼r Props, die verwendet werden,  
wenn ein Prop **nicht vom Elternteil Ã¼bergeben wurde**.

### Beispiel:

```jsx
function Welcome({ name }) {
  return <h1>Hallo, {name}!</h1>;
}

Welcome.defaultProps = {
  name: 'Gast',
};
```

â¡ï¸ Wenn `name` nicht Ã¼bergeben wurde, zeigt die Komponente automatisch `Hallo, Gast!` an.

---

## âœ… 2. PropTypes

**PropTypes** werden verwendet, um die **Datentypen der Props zu validieren**.  
React gibt **eine Warnung in der Konsole**, wenn ein Prop nicht dem erwarteten Typ entspricht.

### Beispiel:

```jsx
import PropTypes from 'prop-types';

function Welcome({ name, age }) {
  return (
    <p>
      Hallo, {name}! Du bist {age} Jahre alt.
    </p>
  );
}

Welcome.propTypes = {
  name: PropTypes.string.isRequired,
  age: PropTypes.number,
};
```

â¡ï¸ Warnung in der Konsole, wenn z.â€¯B. `name` fehlt oder `age` kein `number` ist.

---

## ğŸ“¦ UnterstÃ¼tzte Typen

| Typ               | Beschreibung                        |
|-------------------|--------------------------------------|
| `PropTypes.string`| Zeichenkette                         |
| `PropTypes.number`| Zahl                                 |
| `PropTypes.bool`  | Boolean                              |
| `PropTypes.func`  | Funktion                             |
| `PropTypes.array` | Array                                |
| `PropTypes.object`| Objekt                               |
| `.isRequired`     | Macht das Prop erforderlich          |

---

## ğŸ“ Zusammenfassung

- **Default Props**: Definieren **Standardwerte**, wenn keine Props Ã¼bergeben werden
- **PropTypes**: Helfen bei der **TypprÃ¼fung** von Props zur Laufzeit (fÃ¼r Debugging und Klarheit)

---

## ğŸ”— Quellen

- [React: Default Props â€“ react.dev](https://react.dev/learn/passing-props-to-a-component#default-props)  
- [PropTypes â€“ React Docs](https://reactjs.org/docs/typechecking-with-proptypes.html)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

29. ### <a name="29"></a> Was ist React.memo und wofÃ¼r wird es verwendet?

# Was ist `React.memo` und wofÃ¼r wird es verwendet?

**`React.memo`** ist eine **Higher-Order-Komponente (HOC)**, die eine **Funktionskomponente speichert (memoisiert)**  
und **nur neu rendert**, wenn sich ihre **Props tatsÃ¤chlich geÃ¤ndert haben**.

---

## ğŸ¯ Zweck von `React.memo`

- Vermeidet **unnÃ¶tige Re-Renders**  
- Verbessert die **Performance** groÃŸer Anwendungen  
- NÃ¼tzlich bei **teuren Berechnungen oder komplexem UI**

---

## ğŸ§  Wie funktioniert es?

```jsx
const MemoizedComponent = React.memo(MyComponent);
```

React vergleicht bei jedem Render die **alten und neuen Props mit `===`**.  
Nur bei Ã„nderung wird `MyComponent` neu gerendert.

---

## ğŸ’¡ Beispiel

```jsx
const Greeting = React.memo(function Greeting({ name }) {
  console.log('gerendert');
  return <p>Hallo, {name}</p>;
});
```

â¡ï¸ Wird `name` nicht geÃ¤ndert, wird die Komponente **nicht neu gerendert**.

---

## ğŸ”§ Mit benutzerdefiniertem Vergleich (optional)

```jsx
function areEqual(prevProps, nextProps) {
  return prevProps.name === nextProps.name;
}

const MemoGreeting = React.memo(Greeting, areEqual);
```

â¡ï¸ Du kannst einen **eigenen Vergleichsalgorithmus** definieren.

---

## âš ï¸ Wann NICHT verwenden?

- Bei **hÃ¤ufig wechselnden Props**
- Bei **sehr einfachen Komponenten**
- Wenn Re-Renders keine merkliche Performance-Auswirkung haben

---

## ğŸ“ Zusammenfassung

- `React.memo` verhindert unnÃ¶tige Re-Renders von **Funktionskomponenten**
- Es vergleicht Props und rendert nur bei Ã„nderungen
- Ideal bei **leistungsintensiven Komponenten** mit stabilen Props

---

## ğŸ”— Quellen

- [React.memo â€“ React Docs](https://react.dev/reference/react/memo)  
- [Optimizing Performance â€“ React](https://react.dev/learn/optimizing-performance#memoizing-components)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

30. ### <a name="30"></a> Was ist PureComponent und wie unterscheidet es sich von Component?

# Was ist `PureComponent` und wie unterscheidet es sich von `Component`?

In React gibt es zwei Basisklassen fÃ¼r Klassenkomponenten:

- `React.Component`
- `React.PureComponent`

Der Unterschied liegt im **Verhalten beim Rendern**.

---

## âœ… `React.Component`

- Jede Ã„nderung von `state` oder `props` â†’ **fÃ¼hrt immer zu einem Re-Render**
- Kein Vergleich alter und neuer Props/State
- Du kannst `shouldComponentUpdate()` selbst Ã¼berschreiben, um Rendering zu optimieren

---

## âœ… `React.PureComponent`

- FÃ¼hrt **automatisch einen flachen Vergleich** (`shallow compare`) von `props` und `state` durch
- **Rendert nur**, wenn sich etwas **tatsÃ¤chlich geÃ¤ndert hat**
- Du musst `shouldComponentUpdate()` **nicht selbst schreiben**

---

## ğŸ’¡ Beispiel

```jsx
class MyComponent extends React.Component {
  render() {
    console.log('MyComponent rendert immer');
    return <div>{this.props.text}</div>;
  }
}

class MyPureComponent extends React.PureComponent {
  render() {
    console.log('MyPureComponent rendert nur bei Ã„nderung');
    return <div>{this.props.text}</div>;
  }
}
```

Wenn `text` sich nicht Ã¤ndert, wird **`MyPureComponent` nicht neu gerendert**,  
aber **`MyComponent` rendert trotzdem**.

---

## âš ï¸ EinschrÃ¤nkung

- `PureComponent` macht **nur einen flachen Vergleich**
  - Ã„nderungen in **verschachtelten Objekten/Arrays** werden **nicht erkannt**
- Beispiel:

```js
this.setState({ data: { name: 'Max' } }); // Neuer Objekt-Referenz, aber inhaltlich gleich â†’ Re-Render
```

---

## ğŸ” Vergleich

| Merkmal              | `Component`            | `PureComponent`                   |
|----------------------|------------------------|------------------------------------|
| Re-Render bei Update | immer                  | nur bei Ã„nderungen (shallow check)|
| Performance          | normal                 | optimiert fÃ¼r einfache Props/State|
| shouldComponentUpdate| manuell definierbar    | intern automatisch                |

---

## ğŸ“ Zusammenfassung

- `Component`: rendert immer bei State-/Props-Ã„nderung
- `PureComponent`: rendert nur bei tatsÃ¤chlicher Ã„nderung (flacher Vergleich)
- Ideal bei **statischen Props oder Performance-kritischen Klassenkomponenten**

---

## ğŸ”— Quellen

- [React.PureComponent â€“ React Docs](https://react.dev/reference/react/PureComponent)  
- [React-Komponenten optimieren â€“ react.dev](https://react.dev/learn/optimizing-performance#purecomponents)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**  

31. ### <a name="31"></a> Wann sollte shouldComponentUpdate verwendet werden?

# Wann sollte `shouldComponentUpdate` verwendet werden?

Die Methode **`shouldComponentUpdate(nextProps, nextState)`** wird in **Klassenkomponenten** verwendet,  
um zu **steuern, ob eine Komponente neu gerendert werden soll**.

---

## ğŸ¯ Zweck

- **Performance-Optimierung**: Vermeide unnÃ¶tige Re-Renders bei unverÃ¤nderten Props oder State
- Besonders nÃ¼tzlich bei **groÃŸen Komponenten** oder **hÃ¤ufigen Updates**

---

## ğŸ’¡ Beispiel

```jsx
class MyComponent extends React.Component {
  shouldComponentUpdate(nextProps) {
    return nextProps.value !== this.props.value;
  }

  render() {
    console.log('gerendert');
    return <div>{this.props.value}</div>;
  }
}
```

â¡ï¸ Die Komponente rendert **nur**, wenn sich `value` geÃ¤ndert hat.

---

## ğŸ§  Wann sinnvoll?

| Situation | Verwendung von `shouldComponentUpdate` sinnvoll? |
|-----------|--------------------------------------------------|
| GroÃŸe Komponenten mit viel DOM | âœ… Ja                       |
| Props Ã¤ndern sich selten       | âœ… Ja                       |
| Props enthalten komplexe Objekte (z.â€¯B. Arrays) | âœ… mit Deep Compare |
| Kleine statische Komponenten   | âŒ Nicht nÃ¶tig              |
| Du verwendest `PureComponent`  | âŒ Schon eingebaut          |

---

## âš ï¸ Vorsicht bei Objekten und Arrays

```js
shouldComponentUpdate(nextProps) {
  return nextProps.data !== this.props.data;
}
```

â†’ **Referenzvergleich**: wenn `data` neu erstellt wird, auch mit gleichem Inhalt, erfolgt ein Re-Render.  
â†’ Bei komplexeren Strukturen: ggf. **tiefer Vergleich (deep equality)** erforderlich.

---

## ğŸ“ Zusammenfassung

`shouldComponentUpdate` wird verwendet, um **Rerender manuell zu kontrollieren**,  
wenn **Props oder State sich nicht tatsÃ¤chlich geÃ¤ndert haben**.  
Das spart Rechenzeit und verbessert die **Performance**, insbesondere bei groÃŸen Komponenten.

---

## ğŸ”— Quellen

- [shouldComponentUpdate â€“ React Docs](https://react.dev/reference/react/Component#shouldcomponentupdate)  
- [React Performance â€“ react.dev](https://react.dev/learn/optimizing-performance)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

32. ### <a name="32"></a> Was ist ein ref und wann wird er eingesetzt?

# Was ist ein `ref` und wann wird er eingesetzt?

Ein **`ref` (reference)** in React ist ein Objekt, das **direkten Zugriff auf ein DOM-Element oder eine React-Komponente** ermÃ¶glicht â€“ **ohne den Ã¼blichen Datenfluss Ã¼ber Props oder State**.

---

## ğŸ§  WofÃ¼r werden Refs verwendet?

- ğŸ“Œ **Direkter Zugriff auf DOM-Elemente**
- ğŸ® **Manuelles Fokus-Management** (z.â€¯B. `input.focus()`)
- â¯ï¸ **Steuerung von Medien (Video/Audio)**
- ğŸ“¦ **Integration von Drittanbieter-Bibliotheken**
- ğŸ§ª **Lesen von Werten in unkontrollierten Komponenten**

---

## ğŸ’¡ Beispiel: DOM-Element fokussieren

```jsx
import { useRef, useEffect } from 'react';

function FocusInput() {
  const inputRef = useRef(null);

  useEffect(() => {
    inputRef.current.focus(); // Direktes DOM-Zugreifen
  }, []);

  return <input ref={inputRef} />;
}
```

â¡ï¸ `inputRef.current` zeigt auf das `<input>` DOM-Element.

---

## ğŸ“¦ `useRef` vs. `createRef`

| Hook/Method        | Verwendung                        |
|--------------------|-----------------------------------|
| `useRef()`         | In **Funktionskomponenten**       |
| `createRef()`      | In **Klassenkomponenten**         |

---

## ğŸ§¬ Beispiel: Unkontrolliertes Eingabefeld

```jsx
function UncontrolledForm() {
  const inputRef = useRef();

  const handleSubmit = () => {
    alert(`Eingegeben: ${inputRef.current.value}`);
  };

  return (
    <>
      <input ref={inputRef} />
      <button onClick={handleSubmit}>Absenden</button>
    </>
  );
}
```

â¡ï¸ Zugriff auf den Wert **ohne State/Props**.

---

## âš ï¸ Wann **nicht** verwenden?

- âŒ Kein Ersatz fÃ¼r `state` bei kontrollierten Komponenten  
- âŒ Kein Mittel zur Datenverarbeitung oder Logiksteuerung  
- âŒ Nicht fÃ¼r das AuslÃ¶sen von Re-Renders gedacht

---

## ğŸ“ Zusammenfassung

Ein `ref` ist eine **Referenz auf ein DOM-Element oder eine Komponente**.  
Er wird eingesetzt, wenn React **nicht der beste Ort zur Verwaltung von Verhalten ist**, z.â€¯B. bei Fokus, Scroll, Animationen oder Drittanbieter-APIs.

---

## ğŸ”— Quellen

- [Refs und DOM â€“ React Docs](https://react.dev/learn/referencing-values-with-refs)  
- [useRef Hook â€“ react.dev](https://react.dev/reference/react/useRef)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

33. ### <a name="33"></a> Was bedeutet â€Lifting State Upâ€œ?

# Was bedeutet â€Lifting State Upâ€œ?

**â€Lifting State Upâ€œ** bezeichnet ein Muster in React, bei dem **mehrere Komponenten denselben State benÃ¶tigen** â€“  
aber **nur eine Elternkomponente** diesen Zustand verwalten soll.

---

## ğŸ¯ Warum â€State anhebenâ€œ?

Wenn zwei oder mehr Komponenten auf denselben Wert zugreifen oder ihn Ã¤ndern mÃ¼ssen,  
ist es besser, den **State in die nÃ¤chste gemeinsame Elternkomponente zu verschieben**.

---

## ğŸ’¡ Beispiel

### âœ… Struktur mit â€Lifting State Upâ€œ

```jsx
function Parent() {
  const [text, setText] = useState('');

  return (
    <>
      <Input text={text} onTextChange={setText} />
      <Display text={text} />
    </>
  );
}

function Input({ text, onTextChange }) {
  return (
    <input 
      value={text} 
      onChange={(e) => onTextChange(e.target.value)} 
    />
  );
}

function Display({ text }) {
  return <p>Aktueller Text: {text}</p>;
}
```

â¡ï¸ `Parent` verwaltet den Zustand `text`,  
und beide Kind-Komponenten (`Input`, `Display`) **bekommen diesen State als Prop**.

---

## ğŸ” Vorteile

- âœ… **Zentrale Datenquelle** fÃ¼r mehrere Komponenten
- âœ… Einfache Synchronisation und Datenfluss
- âœ… Vermeidung von doppeltem State

---

## âš ï¸ Typischer Anwendungsfall

- Zwei Komponenten mÃ¼ssen sich **auf denselben Wert beziehen**
- Eine Komponente Ã¤ndert den Wert, die andere zeigt ihn an

---

## ğŸ“ Zusammenfassung

**â€Lifting State Upâ€œ** bedeutet, den gemeinsamen Zustand in eine **hÃ¶herliegende Elternkomponente zu verschieben**,  
damit mehrere untergeordnete Komponenten synchron auf denselben Wert zugreifen kÃ¶nnen.

---

## ğŸ”— Quellen

- [Lifting State Up â€“ react.dev](https://react.dev/learn/sharing-state-between-components#lifting-state-up)  
- [State Sharing in React â€“ MDN](https://developer.mozilla.org/de/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_components#lifting_state_up)

  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

34. ### <a name="34"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

35. ### <a name="35"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

36. ### <a name="36"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

37. ### <a name="37"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

38. ### <a name="38"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

39. ### <a name="39"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

40. ### <a name="40"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**  

41. ### <a name="41"></a> Was sind die Phasen des Komponentenlebenszyklus?



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

42. ### <a name="42"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

43. ### <a name="43"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

44. ### <a name="44"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

45. ### <a name="45"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

46. ### <a name="46"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

47. ### <a name="47"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

48. ### <a name="48"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

49. ### <a name="49"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

50. ### <a name="50"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**  

51. ### <a name="51"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

52. ### <a name="52"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

53. ### <a name="53"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

54. ### <a name="54"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

55. ### <a name="55"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

56. ### <a name="56"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

57. ### <a name="57"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

58. ### <a name="58"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

59. ### <a name="59"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

60. ### <a name="60"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

61. ### <a name="61"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

62. ### <a name="62"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

63. ### <a name="63"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

64. ### <a name="64"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

65. ### <a name="65"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

66. ### <a name="66"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

67. ### <a name="67"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

68. ### <a name="68"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

69. ### <a name="69"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

70. ### <a name="70"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

71. ### <a name="71"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

72. ### <a name="72"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

73. ### <a name="73"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

74. ### <a name="74"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

75. ### <a name="75"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

76. ### <a name="76"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

77. ### <a name="77"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

78. ### <a name="78"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

79. ### <a name="79"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

80. ### <a name="80"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**  

81. ### <a name="81"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

82. ### <a name="82"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

83. ### <a name="83"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

84. ### <a name="84"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

85. ### <a name="85"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

86. ### <a name="86"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

87. ### <a name="87"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

88. ### <a name="88"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

89. ### <a name="89"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

90. ### <a name="90"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**  

91. ### <a name="91"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

92. ### <a name="92"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

93. ### <a name="93"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

94. ### <a name="94"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

95. ### <a name="95"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

96. ### <a name="96"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

97. ### <a name="97"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

98. ### <a name="98"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

99. ### <a name="99"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

100. ### <a name="100"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**    

101. ### <a name="101"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

102. ### <a name="102"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

103. ### <a name="103"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

104. ### <a name="104"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

105. ### <a name="105"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

106. ### <a name="106"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

107. ### <a name="107"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

108. ### <a name="108"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

109. ### <a name="109"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

110. ### <a name="110"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

111. ### <a name="111"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

112. ### <a name="112"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

113. ### <a name="113"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

114. ### <a name="114"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

115. ### <a name="115"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

116. ### <a name="116"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

117. ### <a name="117"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

118. ### <a name="118"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

119. ### <a name="119"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

120. ### <a name="120"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

121. ### <a name="121"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

122. ### <a name="122"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

123. ### <a name="123"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

124. ### <a name="124"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

125. ### <a name="125"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

126. ### <a name="126"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

127. ### <a name="127"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

128. ### <a name="128"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

129. ### <a name="129"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

130. ### <a name="130"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**  

131. ### <a name="131"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

132. ### <a name="132"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

133. ### <a name="133"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

134. ### <a name="134"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

135. ### <a name="135"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

136. ### <a name="136"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

137. ### <a name="137"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

138. ### <a name="138"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

139. ### <a name="139"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

140. ### <a name="140"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**  

141. ### <a name="141"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

142. ### <a name="142"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

143. ### <a name="143"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

144. ### <a name="144"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

145. ### <a name="145"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

146. ### <a name="146"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

147. ### <a name="147"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

148. ### <a name="148"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

149. ### <a name="149"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

150. ### <a name="150"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**  

151. ### <a name="151"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

152. ### <a name="152"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

153. ### <a name="153"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

154. ### <a name="154"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

155. ### <a name="155"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

156. ### <a name="156"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

157. ### <a name="157"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

158. ### <a name="158"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

159. ### <a name="159"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

160. ### <a name="160"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

161. ### <a name="161"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

162. ### <a name="162"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

163. ### <a name="163"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

164. ### <a name="164"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

165. ### <a name="165"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

166. ### <a name="166"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

167. ### <a name="167"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

168. ### <a name="168"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

169. ### <a name="169"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

170. ### <a name="170"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

171. ### <a name="171"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

172. ### <a name="172"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

173. ### <a name="173"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

174. ### <a name="174"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

175. ### <a name="175"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

176. ### <a name="176"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

177. ### <a name="177"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

178. ### <a name="178"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

179. ### <a name="179"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

180. ### <a name="180"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**  

181. ### <a name="181"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

182. ### <a name="182"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

183. ### <a name="183"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

184. ### <a name="184"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

185. ### <a name="185"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

186. ### <a name="186"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

187. ### <a name="187"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

188. ### <a name="188"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

189. ### <a name="189"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

190. ### <a name="190"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**  

191. ### <a name="191"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

192. ### <a name="192"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

193. ### <a name="193"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

194. ### <a name="194"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

195. ### <a name="195"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

196. ### <a name="196"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

197. ### <a name="197"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

198. ### <a name="198"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

199. ### <a name="199"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**

200. ### <a name="200"></a> 



  **[â¬† ĞĞ°Ğ²ĞµÑ€Ñ…](#top)**      
