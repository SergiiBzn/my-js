<a name="top"></a>

[На главную](../README.md)

[Перейти к вопросам](#questions)

| №. | Вопрос |
| --- | --------- |
|   | Общие вопросы |
|1 | [SOLID, KISS, DRY, YAGNI](#1) |
|2 | [Императивное и Декларативное программирование](#2) |
|3 | [HTTP, HTTPS, HTTP Headers, Status Codes, TCP vs UDP, C.O.R.S.](#3) |
|4 | [Параметры запроса и JSON](#4) |
|5 | [Git code](#5) |
|6 | [Связь с сервером: HTTP, REST, websockets](#6) |
|7 | [Методологии ведения разрботки Agile, Scrum, Kanban, Waterfall](#7) |
|8 | [Git info](#8) |
|9 | [Паттерны проектирования](#9) |
|10 | [Структуры данных. Алгоритмы поиска, Сортировки. Сложность алгоритма](#10) |
|11 | [Unit-tests](#11) |
|12 | [Оценка скорости приложения - Google Lighthouse](#12) |
|13 | [Основных модели SDLC](#13) |
|14 | [Предоставление оценок усилий, необходимых для выполнения задач на основе заданной WBS](#14) |
|15 | [](#15) |
|16 | [](#16) |
|17 | [Что такое реактивное программирование? Основные кирпичи (поток, наблюдаемый, подписка)](#17) |
|18 | [gulp / grunt, webpack, bazel](#18) |
|19 | [Хранение паролей и возможности хеширования. Разница между хешем и hmac.](#19) |
|20 | [Атаки на формы и URL-адреса (CSRF, XSS, проблема с семантическими URL-адресами. Фильтрация входных данных.)](#20) |
|21 | [Понимание концепции рефакторинга](#21) |
|22 | [Основные понятия: Test Plan, Test Suite, Test Case. Концепции различных типов тестов: Единичный / Интеграционный / Функциональный. Основы работы с JS Unit.](#22) |
|23 | [Реализация ООП в JS](#23) |
|24 | [Принципы ООП](#24) |
|25 | [Code small](#25) |
|26 | [Continuous delivery, Continuous deployment & Continuous integration (CI/CD)](#26) |
|27 | [Отладке кода, Debugging](#27) |
|28 | [Jira (Redmine,Tfs)](#28) |
|29 | [](#29) |
|30 | [Хранилище данных: Куки, LocalStorage, sessionStorage, IndexedDB](#30) |
|31 | [Критический путь рендеринга](#31) |
|32 | [Кэширование (как работает и зачем нужно)](#32) |
|33 | [](#33) |
|34 | [](#34) ||
|   | Основы JavaScript  |
|100 | [Различие между null и undefined](#100) |
|101 | [Переменные let, const, var. Cтрогий режим](#101) |
|102 | [Классификация типов данных, приведение типов](#102) |
|103 | [Общение с пользователем: alert(), prompt(), confirm()](#103) |
|104 | [Интерполяция (ES6)](#104) |
|105 | [Операторы в JS](#105) |
|106 | [Условия](#106) |
|107 | [Циклы, Цикл в цикле, метки](#107) |
|108 | [Функции, стрелочные ф-ции, IIFE](#108) |
|109 | [Функции привязки контекста (call, apply, bind)](#109) |
|110 | [Замыкание](#110) |
|111 | [Методы и свойства строк и чисел](#111) |
|112 | [Callback- функции](#112) |
|113 | [Объекты, деструктуризация объектов (ES6)](#113) |
|134 | [Методы Object, Object.prototype](#134) |
|114 | [Способы создания объекта](#114) |
|115 | [Копирование объекты?](#115) |
|116 | [Массивы и псевдомассивы, деструктуризация массивов](#116) |
|135 | [Методы Array, Array.prototype](#135) |
|117 | [Копирование массивов](#117) |
|118 | [Private and protected свойства Оььекта](#118) |
|119 | [Spread оператор (ES6-ES9)](#119) |
|120 | [Rest оператор и параметры по умолчанию (ES6)](#120) |
|121 | [Контекст выполнения. Лексическое окружение](#121) |
|122 | [](#122) |
|123 | [События и их обработчики](#123) |
|124 | [Async, defer, динамические скрипты](#124) |
|125 | [typeof - как определить тип значения?](#125) |
|126 | [Почему у переменных примитивного типа данных есть методы? Что такое Autoboxing?](#126) |
|127 | [Сборщик мусора в JS?](#127) |
|128 | [Временная мертвая зона](#128) |
|129 | [Всплытие событий, event bubbling](#129) |
|130 | [Делегирование событий](#130) |
|131 | [Hoisting - Поднятие](#131) |
|132 | [Глобальный объект window](#132) |
|133 | [import/export syntax(ES6 Modules) & CommonJS](#133) |
|136 | [Зная разницу между классом и объектом. Различие между прототипическим и классическим наследованием](#136) |
|137 | [Что такое функциональное программирование? Основы функционального программирования (функция первого класса, функция высшего порядка, лямбда-функции, неизменяемость данных, ленивое вычисление, рекурсия, чистые функции)](#137) |
|138 | [Живые коллекции](#138) |
|139 | [Symbol](#139) |
|140 | [Дескрипторы свойств и полезные методы объектов](#140) |
|141 | [Итерируемые конструкции](#141) |
|142 | [BigInt](#142) |
|143 | [](#143) |
|144 | [](#144) |
|145 | [](#145) |
|146 | [](#146) |
|147 | [](#147) |
|   | JavaScript в работе  |
|201 | [Получение элементов со страницы](#201) |
|202 | [Действия с элементами на странице](#202) |
|203 | [Навигация по DOM - элементам](#203) |
|204 | [Способы получения DOM-элементов в JS](#204) |
|205 | [DOM-дерево (устройство, селекторы)](#205) |
|206 | [ClassList и делегирование событий](#206) |
|207 | [](#207) |
|208 | [Работа с датами](#208) |
|209 | [](#209) |
|210 | [Параметры документа, окна и работа с ними](#210) |
|211 | [](#211) |
|212 | [Разница между событиеми load и DOMContentLoaded](#212) |
|213 | [Создаем табы в новом проекте](#213) |
|214 | [Создаем таймер обратного отсчета на сайте](#214) |
|215 | [Создаем модальное окно](#215) |
|216 | [Создаем слайдер на сайте](#216) |
|217 | [Создаем калькулятор на сайте](#217) |
|218 | [](#218) |
|219 | [](#219) |
|220 | [](#220) |
|   | Продвинутый JavaScript |
|300 | [Функции-конструкторы](#300) |
|301 | [Контекст вызова. This](#301) |
|302 | [Классы (ES6)](#302)  |
|303 | [Наследование классов. Private, protected свойства](#303) |
|304 | [setTimeout и setInterval скрипты и время их выполнения](#304) |
|305 | [JSON](#305) |
|306 | [AJAX и XMLHttpRequest (общение с сервером)](#306) |
|307 | [Promise (ES6)](#307) |
|308 | [Promise](#308) |
|309 | [Fetch API](#309) |
|310 | [Async/Await (ES8)](#310) |
|311 | [try catch, выдача throw](#311) |
|312 | [Библиотека Axios](#312) |
|313 | [Получение данных с сервера. Async/Await. Создание карточек меню. Forms](#313) |
|314 | [Регулярные выражения RegExp](#314) |
|315 | [Web Animations API](#315) |
|316 | [Геттеры и сеттеры (свойства объектов)](#316) |
|317 | [Инкапсуляция](#317) |
|318 | [Функции-генераторы](#318) |
|319 | [JS анимации, requestAnimationFrame](#319) |
|320 | [Event loop, подробная работа асинхронных и синхронных операций](#320) |
|321 | [Что такое Set, Map, WeakSet и WeakMap?](#321) |
|700 | [Map, Set](#700) |
|322 | [Прототипы, цепочка прототипов](#322) |
|323 | [Прототипы, Object.create()](#323) |
|324 | [Длительный опрос как работает](#324) |
|325 | [Web Socket](#325) |
|326 | [Способы отправки запроса на сервер](#326) |
|327 | [Минификация](#327) |
|328 | [Что такое web workers и зачем они нам нужны?](#328) |
|329 | [Typescript или flow](#329) |
|330 | [Рекурсия](#330) |
|331 | [](#331) |
|332 | [](#332) |
|   | HTML |
|401 | [Базовая схема HTML-документа](#401) |
|402 | [Использование символов HTML](#402) |
|403 | [Форматирование текста, абзацы](#403) |
|404 | [HTML-ссылки. Link target](#404) |
|405 | [Таблицы HTML](#405) |
|406 | [Добавление scripts](#406) |
|407 | [Разница между блочными и строчными элементами](#407) |
|408 | [Для чего нужен DOCTYPE?](#408) |
|409 | [Как следует оформлять страницу, содержимое которой может быть на разных языках?](#409) |
|410 | [На что необходимо обратить внимание при разработке мультиязычных сайтов?](#410) |
|411 | [Для чего нужны data- атрибуты?](#411) |
|412 | [Представьте HTML5 как открытую веб-платформу. Из каких блоков состоит HTML5?](#412) |
|413 | [Объясните разницу между cookie, sessionStorage и localStorage](#413) |
|414 | [Объясните разницу между <script>, <script async> и <script defer>](#414) |
|415 | [Почему хорошей практикой считается располагать <link> для подключения CSS между <head></head>, а <script> для подключения JS ставить перед </body>? Знаете ли вы исключения?](#415) |
|416 | [Что такое прогрессивный рендеринг](#416) |
|417 | [Для чего используется атрибут srcset в теге изображения? Опишите процесс, который браузер использует при обработке содержимого этого атрибута](#417) |
|418 | [Что такое семантика?](#418) |
|419 | [](#419) |
|420 | [](#420) |
|421 | [](#421) |
|422 | [](#422) |
|423 | [](#423) |
|   | CSS |
|494 | [](#494) |
|495 | [](#495) |
|496 | [](#496) |
|497 | [](#497) |
|498 | [](#498) |
|499 | [](#499) |	
|500 | [Варианты добавление CSS стилей на страницу?](#500) |	
|501 | [css modules](#501) |
|502 | [Селекторы и их вес](#502) |
|503 | [Positioning](#503) |
|504 | [Margings vs paddings](#504) |
|505 | [Добавление шрифтов](#505) |
|506 | [Видимость элемента. Способы скрыть элемент](#506) |
|507 | [Z-index](#507) |
|508 | [Чем полезны data- атрибуты?](#508) |
|509 | [Что такое кэш приложения в HTML5?](#509) |
|510 | [Объясните разницу между script, script async и script defer](#510) |
|511 | [Дайте пояснения, для какой цели добавленны след. элементы: article, aside, audio, canvas, figcaption, figure, footer, header, hgroup, output, section, video](#511) |
|512 | [Чем отличается article от section?](#512) |
|513 | [Можно ли вложить p в другой такой же p? Можно ли вложить div в p?](#513) |
|514 | [Чем отличается класс (class) от идентификатора (id) в HTML?](#514) |
|515 | [Что такое прогрессивный рендеринг](#515) |
|516 | [Почему хорошей практикой считается располагать <link> для подключения CSS между <head></head>, а <script> для подключения JS ставить перед </body>?](#516) |
|517 | [](#517) |
|518 | [Объясните, что такое плавающие элементы (floats) и как они работают?](#518) |
|519 | [Что такое flexbox?](#519) |
|520 | [Как задать flexbox?](#520) |
|521 | [Какие оси есть в flexbox?](#521) |
|522 | [Какое свойство flexbox отвечает за направление flex items?](#522) |
|523 | [Какое правило flexbox задает вывод flex items в одну строку или в несколько строк?](#523) |
|524 | [Как можно гибко изменять размеры flex элементов?](#524) |
|525 | [Расскажите про flex-grow, flex-shrink, flex-basis?](#525) |
|526 | [Что такое css grid?](#526) |
|527 | [Можно ли использовать css grid и flexbox вместе?](#527) |
|528 | [Объясните, как браузер определяет, на какие элементы накладывать CSS стили?](#528) |
|529 | [Объясните, что такое псевдоэлементы и для чего они нужны.](#529) |
|530 | [Что делает * { box-sizing: border-box; }? В чём его преимущества?](#530) |
|531 | [В чём разница между строчным и блочно-строчным элементом?](#531) |
|532 | [Можете ли вы объяснить разницу между отзывчивым (responsive) сайтом и сайтом, сделанным по принципу mobile-first?](#532) |
|533 | [Свойства display - основные значения и как они работают](#533) |
|534 | [Keyframes для чего нужно и как использовать?](#534) |
|535 | [](#535) |
|536 | [](#536) |
|537 | [](#537)	|
|538 | [](#538)	|
|539 | [](#539)	|
|540 | [](#540)	




<a name="questions"></a>

## Ключевые концепции React

  **[⬆ Наверх](#top)**		
	
1. ### <a name="1"></a> SOLID, KISS, DRY, YAGNI

- DRY – расшифровывается как Don’t Repeat Youself – не повторяйся, также известен как DIE – Duplication Is Evil – дублирование это зло. Этот принцип заключается в том, что нужно избегать повторений одного и того же кода. Лучше использовать универсальные свойства и функции.

- KISS – Keep It Simple, Stupid – не усложняй! Смысл этого принципа программирования заключается в том, что стоит делать максимально простую и понятную архитектуру, применять шаблоны проектирования и не изобретать велосипед.

- YAGNI значит You Ain’t Gonna Need It – вам это не понадобится! Его суть в том, чтобы реализовать только поставленные задачи и отказаться от избыточного функционала.

- SOLID в упрощенном варианте означает, что когда при написании кода используется несколько принципов вместе, то это значительно облегчает дальнейшую поддержку и развитие программы. Полностью акроним расшифровывается так:

1) *Single responsibility* — принцип единственной ответственности обозначает, что каждый объект должен иметь одну обязанность и эта обязанность должна быть полностью инкапсулирована в класс. Все его сервисы должны быть направлены исключительно на обеспечение этой обязанности.
2) *Open-closed* — принцип открытости / закрытости декларирует, что программные сущности (классы, модули, функции и тп) должны быть открыты для расширения, но закрыты для изменения. Это означает, что эти сущности могут менять свое поведение без изменения их исходного кода.
3) *Liskov substitution* — принцип подстановки Барбары Лисков в формулировке Роберта Мартина: «функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа не зная об этом».
4) *Interface segregation* — принцип разделения интерфейса в формулировке Роберта Мартина: «клиенты не должны зависеть от методов, которые они не используют». Принцип разделения интерфейсов говорит о том, что слишком «толстые» интерфейсы необходимо разделять на более маленькие и специфические, чтобы клиенты маленьких интерфейсов знали только о методах, которые необходимы им в работе. В итоге, при изменении метода интерфейса не должны меняться клиенты, которые этот метод не используют.
5) *Dependency inversion* — принцип инверсии зависимостей — модули верхних уровней не должны зависеть от модулей нижних уровней, а оба типа модулей должны зависеть от абстракций; сами абстракции не должны зависеть от деталей, а вот детали должны зависеть от абстракций.

### Solid
```js
// Single Responsibility Principle

class News {
  constructor(title, text) {
    this.title = title
    this.text = text
    this.modified = false
  }

  update(text) {
    this.text = text
    this.modified = true
  }
}

class NewsPrinter {
  constructor(news) {
    this.news = news
  }

  html() {
    return `
      <div class="news">
        <h1>${this.news.title}</h1>
        <p>${this.news.text}</p>
      </div>
    `
  }

  json() {
    return JSON.stringify({
      title: this.news.title,
      text: this.news.text,
      modified: this.news.modified
    }, null, 2)
  }

  xml() {
    return `
      <news>
        <title>${this.news.title}</title>
        <text>${this.news.text}</text>
      </news>
    `
  }
}


const printer = new NewsPrinter(
  new News('Путин', 'Новая конституция')
)

console.log(printer.html())
console.log(printer.xml())
console.log(printer.json())	
```	
```js
// Open Close Principle

class Shape {
  area() {
    throw new Error('Area method should be implemented')
  }
}

class Square extends Shape {
  constructor(size) {
    super()
    this.size = size
  }

  area() {
    return this.size ** 2
  }
}

class Circle extends Shape {
  constructor(radius) {
    super()
    this.radius = radius
  }

  area() {
    return (this.radius ** 2) * Math.PI
  }
}

class Rect extends Shape {
  constructor(width, height) {
    super()
    this.width = width
    this.height = height
  }

  area() {
    return this.width * this.height
  }
}

class Triangle extends Shape {
  constructor(a, b) {
    super()
    this.a = a
    this.b = b
  }

  area() {
    return (this.a * this.b) / 2
  }
}

class AreaCalculator {
  constructor(shapes = []) {
    this.shapes = shapes
  }

  sum() {
    return this.shapes.reduce((acc, shape) => {
      acc += shape.area()
      return acc
    }, 0)
  }
}


const calc = new AreaCalculator([
  new Square(10),
  new Circle(1),
  new Circle(5),
  new Rect(10, 20),
  new Triangle(10, 15)
])

console.log(calc.sum())	
```	
```js
// Liskov substitution principle

class Person {

}

class Member extends Person {
  access() {
    console.log('У тебя есть доступ')
  }
}

class Guest extends Person {
  isGuest = true
}

class Frontend extends Member {
  canCreateFrontend() {}
}

class Backend extends Member {
  canCreateBackend() {}
}

class PersonFromDifferentCompany extends Guest {
  access() {
    throw new Error('У тебя нет доступа! Иди к себе!')
  }
}

function openSecretDoor(member) {
  member.access()
}

openSecretDoor(new Frontend())
openSecretDoor(new Backend())
openSecretDoor(new PersonFromDifferentCompany())  // There should be member!

// ===============

class Component {
  isComponent = true
}

class ComponentWithTemplate extends Component {
  render() {
    return `<div>Component</div>`
  }
}

class HigherOrderComponent extends Component {

}

class HeaderComponent extends ComponentWithTemplate {
  onInit() {}
}

class FooterComponent extends ComponentWithTemplate {
  afterInit() {}
}

class HOC extends HigherOrderComponent {
  render() {
    throw new Error('Render is impossible here')
  }

  wrapComponent(component) {
    component.wrapped = true
    return component
  }
}

function renderComponent(component) {
  console.log(component.render())
}


renderComponent(new HeaderComponent())
renderComponent(new FooterComponent())	
```	
```js
// Interface segregation principle

class Animal {
  constructor(name) {
    this.name = name
  }

  walk() {
    console.log(`${this.name} умеет ходить`)
  }

  swim() {
    console.log(`${this.name} умеет плавать`)
  }

  fly() {
    console.log(`${this.name} умеет летать`)
  }
}

class Dog extends Animal {
  fly() {
    return null
  }
}

class Eagle extends Animal {
  swim() {
    return null
  }
}

class Whale extends Animal {
  fly() {
    return null
  }

  walk() {
    return null
  }
}

// =====

class Animal {
  constructor(name) {
    this.name = name
  }
}

const swimmer = {
  swim() {
    console.log(`${this.name} умеет плавать`)
  }
}

const flier = {
  fly() {
    console.log(`${this.name} умеет летать`)
  }
}

const walker = {
  walk() {
    console.log(`${this.name} умеет ходить`)
  }
}

class Dog extends Animal {}
class Eagle extends Animal {}
class Whale extends Animal {}

Object.assign(Dog.prototype, swimmer, walker)
Object.assign(Eagle.prototype, flier, walker)
Object.assign(Whale.prototype, swimmer)

const dog = new Dog('Рэкс')
dog.walk()
dog.swim()

const eagle = new Eagle('Орел')
eagle.fly()
eagle.walk()

const whale = new Whale('Большой синий друг')
whale.swim()	
```	
```js
// Dependency inversion principle


class Fetch {
  request(url) {
    // return fetch(url).then(r => r.json())
    return Promise.resolve('data from fetch')
  }
}

class LocalStorage {
  get() {
    const dataFromLocalStorage = 'data from local storage'
    return dataFromLocalStorage
  }
}

class FetchClient {
  constructor() {
    this.fetch = new Fetch()
  }

  clientGet() {
    return this.fetch.request('vk.com')
  }
}

class LocalStorageClient {
  constructor() {
    this.localStorage = new LocalStorage()
  }

  clientGet(key) {
    return this.localStorage.get(key)
  }
}


class Database {
  constructor(client) {
    this.client = client
  }

  getData(key) {
    return this.client.clientGet(key)
  }
}


const db = new Database(new LocalStorageClient())

console.log(db.getData('rand'))	
```	

  **[⬆ Наверх](#top)**

2. ### <a name="2"></a> Императивное и Декларативное программирование

`Императивное программирование` — последовательность команд, которая описывает то, как можно добиться результата.

К императивной парадигме относятся следующие виды программирования:
процедурное; структурное; аспектно-ориентированное; объектно-ориентированное и другие.

`Декларативное программирование` — описание того, какой результат нужно получить.

К декларативной парадигме относятся функциональное и логическое программирование


Это своего рода способы программирования, это то, как программа должна выполняться.

1. В *процедурном* программировании программа состоит из структур данных (объектов обработки) и алгоритма (метода обработки). Это явное описание всех вычислений, которые должен проделать компьютер.

2. В *функциональном* программировании единственной управляющей конструкцией является вызов функций. Все функции строятся на основе некоторых базовых функций с помощью композиций.

`Чистые» функции` - это любые функции, исходные данные которых получены исключительно из их входных данных и не вызывают побочных эффектов в приложении. Математические функции являются примерами «чистых» функций. 

`Чистая» функция` - это функция, которая выводит свои данные основываясь исключительно на свои входные данные и не вызывает побочных эффектов в приложении.

Например у нас есть функция, которая получает одно значение x и возвращает в данном случае x + 1:
```js
// function f(x) { return x + 1 }

const f = x => x + 1;
```
 
`Нечистые» функции` бывают разных форм и размеров. Вот некоторые примеры:

- функции, вывод которых зависит от внешнего / глобального состояния;
- функции, которые возвращают разные исходные данные при одинаковых входных;
- функции, которые изменяют состояние приложения;
- функции, которые изменяют «внешний мир».

Функциональное программирование основано на использовании «чистых» функций и строгом контроле побочных эффектов. Способность распознавать любой тип функции является ключевым для функционального программирования.

 `Функции первого класса` - они могут быть переданы другим функциям и их можно вернуть из функций. Так же их можно присваивать переменным.

Пример
/* функция не имеет имени и находится в правой части команды присваивания переменной.*/
```jsx harmony
var dog = function(num) {
    for (var i = 0; i < num; i++) {
        alert("Woof");
    }
};
dog(3); //Эту функцию можно вызвать через переменную dog.
```

`Функции высшего порядка` — это функции, которые работают с другими функциями, либо принимая их в виде параметров, либо возвращая их. Проще говоря, функцией высшего порядка называется такая функция, которая принимает функцию как аргумент или возвращает функцию в виде выходного значения.

Например, встроенные функции JavaScript Array.prototype.map, Array.prototype.filter и Array.prototype.reduce являются функциями высшего порядка.

`Каррирование` – продвинутая техника для работы с функциями. Она используется не только в JavaScript, но и в других языках.

`Каррирование` – это трансформация функций таким образом, чтобы они принимали аргументы не как f(a, b, c), а как f(a)(b)(c).
Каррирование не вызывает функцию. Оно просто трансформирует её.

3. В *объектно-ориентированном* программировании программа представляет собой совокупность объектов, обладающих свойствами и методами, обменивающихся между собой сообщениями, выстраивающихся в иерархию, наследуя свойства и методы.

Пример на JS

Мой любимый пример такой: дан массив чисел, надо написать функцию, которая вернет массив чисел, где каждое число из исходного массива удваивается. Т.е. [1, 2, 3] -> [2, 3, 6]

Императивный стиль:
```jsx harmony
function double (arr) {
  let results = [];
  for (let i = 0; i < arr.length; i++){
    results.push(arr[i] * 2);
  }
  return results;
}
```
Декларативный стиль:
```jsx harmony
function double (arr) {
  return arr.map((item) => item * 2);
}
```
  **[⬆ Наверх](#top)**

3. ### <a name="3"></a> HTTP, HTTPS, HTTP Headers, Status Codes, TCP vs UDP, C.O.R.S.

HTTP — широко распространённый протокол передачи данных, изначально предназначенный для передачи гипертекстовых документов (то есть документов, которые могут содержать ссылки, позволяющие организовать переход к другим документам).

HTTPS - HyperText Transfer Protocol Secure) — расширение протокола HTTP для поддержки шифрования в целях повышения безопасности. Данные в протоколе HTTPS передаются поверх криптографических протоколов TLS или устаревшего в 2015 году SSL. В отличие от HTTP с TCP-портом 80, для HTTPS по умолчанию используется TCP-порт 443.

Заголовки HTTP позволяют клиенту и серверу отправлять дополнительную информацию с HTTP запросом или ответом. В HTTP-заголовке содержится не чувствительное к регистру название, а затем после (:) непосредственно значение. Пробелы перед значением игнорируются.

HTTP-заголовки сопровождают обмен данными по протоколу HTTP. Они могут содержать описание данных и информацию, необходимую для взаимодействия между клиентом и сервером. Заголовки и их статусы перечислены в реестре IANA, который постоянно обновляется.

Status code (Коды ответа):
- Информационные 100 - 199
- Успешные 200 - 299
- Перенаправления 300 - 399
- Клиентские ошибки 400 - 499
- Серверные ошибки 500 - 599

TCP – транспортный протокол передачи данных в сетях TCP/IP, предварительно устанавливающий соединение с сетью. 

UDP – транспортный протокол, передающий сообщения-датаграммы без необходимости установки соединения в IP-сети.

Давайте рассмотрим основные отличия tcp от udp.

- TCP гарантирует доставку пакетов данных в неизменных виде, последовательности и без потерь, UDP ничего не гарантирует.
- TCP нумерует пакеты при передаче, а UDP нет
- TCP работает в дуплексном режиме, в одном пакете можно отправлять информацию и подтверждать получение предыдущего пакета.
- TCP требует заранее установленного соединения, UDP соединения не требует, у него это просто поток данных.
- UDP обеспечивает более высокую скорость передачи данных.
- TCP надежнее и осуществляет контроль над процессом обмена данными.
- UDP предпочтительнее для программ, воспроизводящих потоковое видео, видеофонии и телефонии, сетевых игр.
- UDP не содержит функций восстановления данных


### Что такое CORS? Кросс-доменные запросы? Зачем нужны?	
	
CORS (Cross-Origin Resource Sharing, "Совместное использование ресурсов между разными источниками") - это система, состоящая из отправки HTTP заголовков, которые определяют: заблокировать или выполнить запрос к ограниченному ресурсу на веб-странице из другого домена, отличного от домена происхождения запрашиваемого ресурса.

 
Cross-Origin Resource Sharing (CORS) — механизм, использующий дополнительные HTTP-заголовки, чтобы дать возможность агенту пользователя получать разрешения на доступ к выбранным ресурсам с сервера на источнике (домене), отличном от того, что сайт использует в данный момент. Говорят, что агент пользователя делает запрос с другого источника (cross-origin HTTP request), если источник текущего документа отличается от запрашиваемого ресурса доменом, протоколом или портом.
 
С точки зрения браузера запросы к другому источнику бывают двух видов: «простые» и все остальные.

Простые запросы должны удовлетворять следующим условиям:

- Метод: GET, POST или HEAD.
- Заголовки – мы можем установить только:
1) Accept
2) Accept-Language
3) Content-Language
4) Content-Type со значением application/x-www-form-urlencoded, multipart/form-data или text/plain.
 
Основное их отличие заключается в том, что простые запросы с давних времён выполнялись с использованием тегов <form> или <script>, в то время как непростые долгое время были невозможны для браузеров.

Практическая разница состоит в том, что простые запросы отправляются сразу с заголовком Origin, а для других браузер делает предварительный запрос, спрашивая разрешения.

Для простых запросов:

→ Браузер посылает заголовок Origin с источником.
← Для запросов без авторизационных данных (не отправляются умолчанию) сервер должен установить:
- Access-Control-Allow-Origin в * или то же значение, что и Origin
← Для запросов с авторизационными данными сервер должен установить:
- Access-Control-Allow-Origin в то же значение, что и Origin
- Access-Control-Allow-Credentials в true
 
Дополнительно, чтобы разрешить JavaScript доступ к любым заголовкам ответа, кроме Cache-Control, Content-Language, Content-Type, Expires, Last-Modified или Pragma, сервер должен перечислить разрешённые в заголовке Access-Control-Expose-Headers.

Для непростых запросов перед основным запросом отправляется предзапрос:

→ Браузер посылает запрос OPTIONS на тот же адрес с заголовками:
- Access-Control-Request-Method – содержит запрашиваемый метод,
- Access-Control-Request-Headers – перечисляет непростые запрашиваемые заголовки.
← Сервер должен ответить со статусом 200 и заголовками:
- Access-Control-Allow-Methods со списком разрешённых методов,
- Access-Control-Allow-Headers со списком разрешённых заголовков,
- Access-Control-Max-Age с количеством секунд для кеширования разрешений
→ Затем отправляется основной запрос, применяется предыдущая «простая» схема. 
 
 https://learn.javascript.ru/fetch-crossorigin
 
### Зачем нужен CORS?
 
CORS существует для защиты интернета от злых хакеров.

Многие годы скрипт с одного сайта не мог получить доступ к содержимому другого сайта.

Это простое, но могучее правило было основой интернет-безопасности. Например, хакерский скрипт с сайта hacker.com не мог получить доступ к почтовому ящику пользователя на сайте gmail.com. И люди чувствовали себя спокойно.	
	
https://developer.mozilla.org/ru/docs/Web/HTTP/CORS

  **[⬆ Наверх](#top)**

4. ### <a name="4"></a> Параметры запроса и JSON

- GET - запрашивает представление ресурса. Запросы с использованием этого метода могут только извлекать данные.
- HEAD - запрашивает ресурс так же, как и метод GET, но без тела ответа.
- POST -  используется для отправки сущностей к определённому ресурсу. Часто вызывает изменение состояния или какие-то побочные эффекты на сервере.
- PUT - заменяет все текущие представления ресурса данными запроса.
- DELETE - удаляет указанный ресурс.

- CONNECT - устанавливает "туннель" к серверу, определённому по ресурсу.
- OPTIONS - используется для описания параметров соединения с ресурсом.

- TRACE - выполняет вызов возвращаемого тестового сообщения с ресурса.
- PATCH - используется для частичного изменения ресурса.

JSON — это формат, который хранит структурированную информацию и в основном используется для передачи данных между сервером и клиентом.

Файл JSON представляет собой более простую и лёгкую альтернативу расширению с аналогичными функциями XML (Extensive Markup Language).

`JSON` - это синтаксис для сериализации объектов, массивов, чисел, строк, логических значений и null. Он основан на синтаксисе JavaScript.
	
`JSON.parse(text[, reviver])        в text`	
Разберите строку text как JSON, при необходимости преобразуйте полученное значение и его свойства и верните значение. Любые нарушения синтаксиса JSON, в том числе относящиеся к различиям между JavaScript и JSON, вызывают появление SyntaxError. Эта reviver опция позволяет интерпретировать то, что replacerиспользовалось для обозначения других типов данных.

`JSON.stringify(value[, replacer[, space]])     в JSON`
Вернуть строку JSON, соответствующую указанному значению, необязательно включая только определенные свойства или заменяя значения свойств определенным пользователем способом. По умолчанию все экземпляры undefinedзаменяются на null, а другие неподдерживаемые собственные типы данных подвергаются цензуре. replacer Опция позволяет указать другое поведение.	
	
![1](https://user-images.githubusercontent.com/80325645/137619168-5fab833b-37c0-4923-9713-b40ea232f5e1.png)

Request Payload - это любые данные, отправленные в теле запроса.

PAYLOAD или полезные данные
Вторым блоком идет eyJ1c2VyX2lkIjoxLCJleHAiOjE1ODEzNTcwMzl9

Это есть полезные данные, так же закодированные в Base64. После раскодирования получим:

{"user_id":1,"exp":1581357039}

Данные могут быть любыми. Главное, чтобы по ним можно было идентифицировать пользователя. В нашем случае - это user_id и exp - время окончания действия текущего токена.

Поскольку необходимо ограничивать токен по времени, поле exp обязательно. По нему можно проверить, актуален ли токен или нет.

А FormData - это определённый формат (content-type) передачи данных, а именно multipart/form-data. Также возможны форматы application/json, application/x-www-form-urlencoded и другие.

  **[⬆ Наверх](#top)**

5. ### <a name="5"></a> Git code

https://github.com/nicothin/web-development/tree/master/git	
	
https://frontend-stuff.com/blog/tags/git	

Git позволяет:
- просматривать историю изменений в проекте
- возращаться к старой версии проекта и обратно
- переключаться между несколькими альтернативными версиями проекта
- обмениваться кодом с другими разработчиками и совместно вести разработку	
	
### Инициализация и клонирование репозиториев
	
git init <directory> Создает пустой Git-репозиторий в указанной директории. Если запустить его без аргументов, то будет использоваться текущий каталог, как репозиторий git.

git clone <repo> Клонирует репозиторий по ссылке <repo> на локальный компьютер. Оригинальный репозиторий может находиться в локальной файловой системе или на удаленном компьютере через HTTP или SSH.

### Настройка информации о пользователях, используемой во всех локальных репозиториях
	
git config --global user.name “firstname lastname” Определяет имя автора, которое используется во всех коммитах в текущем репозитории. Обычно используется флаг —global, чтобы установить параметры конфигурации для текущего пользователя.

git config --global user.email “valid-email” Определяет адрес электронной почты, который будет связан с каждым маркером истории.

git config --global color.ui auto Устанавливает автоматическую раскраску командной строки для Git, для удобства просмотра.

git add <directory> Помещает все изменения из указаной <directory> в промежуточную область для следующего коммита. Заменив <directory> на <file>, файл будет добавлен в промежуточную область.

git add . Помещает все твои изменения в текущей директории в промежуточную область.

git commit -m "<message>" Создает коммит сообщение для изменений в промежуточной области, но, вместо запуска текстового редактора использует <message> в качестве сообщения.

git commit -am "<message>" Помещает все изменения в текущей директории в промежуточную область и создаст коммит сообщение с <message> в качестве сообщения.

git status Показывает список измененных файлы в рабочем каталоге: добавлених в промежуточную область или нет.

git log Показывает всю историю коммитов, используя формат по умолчанию. Для настройки см. дополнительные параметры.

git diff Показывает изменения в рабочем каталоге которые еще не добавлены в промежуточную область.

git diff --staged Показывает изменения в рабочем каталоге которые были добавлены в промежуточную область но еще не закоммичены.

### Отмена изменений
	
git revert <commit> Создает новое коммит сообщение, которое отменяет все изменения, сделанные в данном <commit> (хеш коммита), затем применяет его в текущей ветке. Более подробно здесь.

git reset <file> Убирает <file> из промежуточной области, но оставляет рабочий каталог без изменений.

git checkout <file> Отменяет изменения только для определенного файла или каталога, которые не были добавлены в промежуточную область.

### Переписывание Git History
	
git commit --amend Изменяет последнее коммит сообщение и добавляет изменения из промежуточной области. Для того что бы просто изменить сообщение последнего коммита нужно что бы в промежуточной области не было изменений. Более подробно здесь.

git rebase <base> Переносит текущую ветку поверх <base>. <base> - может быть хешем коммита, именем ветки, тегом или относительной ссылкой на HEAD. Применяет любые коммиты текущей ветки поверх указанной.

git reflog Показывает журнал изменений в HEAD локального репозитория. Добавь флаг —relative-date, чтобы показать информацию о дате, или —all, чтобы показать все ссылки.

git reset --hard [commit] Очищает промежуточную область, переписывает рабочее дерево до определенного коммита.

### Git Branches
	
git branch Выводит список всех веток в репозитории. Добавь аргумент <branch>, чтобы создать новую ветку с именем <branch>.

git checkout -b <branch> Создает и переходит на новую ветку с именем <branch>. Удали флаг -b, чтобы перейти на существующую ветку.

git merge <branch> Объединяет указанную ветку <branch> в текущую.

### Удалённые репозитории
	
git remote add <name> <url> Создает новое подключение к удалённому репозиторию. После добавления пульта ты можешь использовать <name> в качестве ярлыка для <url> в других командах.

git fetch <remote> <branch> Извлекает определенную ветку <branch> из репозитория. Убираем <branch>, чтобы получить все удалённые ссылки.

git pull <remote> Стягивает указанную удалённую копию текущей ветки и немедленно объединит её с локальной копией.

git push <remote> <branch> Отправляет локальную ветку в удалённый репозиторий. Создает именованную ветку в репозитории, если такой не существует.

git merge <remote> <branch> Объединяет удалённую ветку с текущей веткой, для её обновления.

### Временные коммиты
	
git stash Временно хранит все изменения в рабочей директории.

git stash list Выводит список сохраненных измененных файлов.

git stash pop Восстанавливает самое последнее сохранение файлов.

git stash drop Сбрасывает последние сохраненные изменение.

### git config
	
git config --global user.name <name> Определяет имя автора, которое будет использоваться для всех коммитов текущим пользователем.

git config --global user.email <email> Определяет адрес электронной почты автора, который будет использоваться для всех коммитов текущим пользователем.

git config --global alias. <alias-name> <git-command> Создает псевдоним (alias) для команды Git. Например: alias.glog log --graph --oneline установит git glog, эквивалентный git log --graph --oneline.

git config --system core.editor <editor> Устанавливает текстовый редактор, используемый командами для всех пользователей на машине. <editor> аргумент должен быть командой, которая запускает нужный редактор (например, vi).

git config --global --edit Открывает файл глобальной конфигурации в текстовом редакторе для ручного редактирования.

### git log
	
git log -<limit> Ограничивает количество коммитов на <limit>. Например: git log -5 ограничит до 5 коммитов.

git log --oneline Конденсирует каждый коммит в одну строку.

git log -p Показывает полный diff последнего коммита.

git log --stat Указывает, какие файлы были изменены, и относительное количество строк, которые были добавлены и удалены из каждого из них.

git log --author=”<pattern>” Ищет коммити определенного автора.

git log --grep=”<pattern>” Ищет коммити с сообщением коммита, которое соответствует <pattern>.

git log <since>..<until> Показывает коммиты, которые происходят между <since> и <until>. Аргументы могут быть идентификатором, именем ветки, HEAD или любым другим видом ссылки.

git log -- <file> Отображает только те коммиты, которые имеют указанный файл.

git log --graph --decorate Флаг --graph рисует, основанный на тексте, график коммитов в левой части коммит-сообщений. --decorate добавляет имена веток или тегов, показанных коммитов.

### git diff
	
git diff HEAD Показывает разницу между рабочим каталогом и последним коммитом.

git diff --cached Показывает разницу между изменениями в промежуточной области и последним коммитом.

### git reset
	
git reset Сбрасываает промежуточную область в соответствии с последним коммитом, но оставляет рабочий каталог без изменений.

git reset --hard Сбрасывает промежуточную область и рабочий каталог в соответствии с последним коммитом и перезаписывает все изменения в рабочем каталоге.

git reset <commit> Перемещает верхушку текущий ветки назад к <commit>; сбрасывает промежуточную область, чтобы соответствовать коммиту, но оставляет рабочий каталог.

git reset --hard <commit> Делает то же, что и предыдущий, но сбрасывает как промежуточную область, так и рабочий каталог для соответствия. Удаляет не зафиксированные изменения и все коммиты после <commit>.

### git rebase
	
git rebase -i <base> Интерактивное перебазирование текущей ветки на новую базу (хеш коммита). Запускает редактор для ввода команд о том, каким образом каждый коммит будет перенесен на новую базу.

### git pull
	
git pull --rebase <remote> Стягивает удаленную копию текущей ветки и перемещает её в локальную копию. Использует git rebase вместо merge для интеграции веток.

### git push
	
git push <remote> --force Принудительная отправка изменений git, даже если они приводят к конфликтному слиянию (non-fast-forward). Не используй флаг --force, если не уверен, что знаешь, что делаешь.

git push <remote> --all Отправка всех локальных веток на указанный <remote>.

git push <remote> --tags Теги не отправляются автоматически, когда ты отправляешь ветку или используешь флаг --all. Флаг --tags отправляет все локальные теги в удаленный репозиторий.	

  **[⬆ Наверх](#top)**

6. ### <a name="6"></a> Связь с сервером: HTTP, REST, websockets

REST (RESTful) - это общие принципы организации взаимодействия приложения/сайта с сервером посредством протокола HTTP. Особенность REST в том, что сервер не запоминает состояние пользователя между запросами - в каждом запросе передаётся информация, идентифицирующая пользователя (например, token, полученный через OAuth-авторизацию) и все параметры, необходимые для выполнения операции.

REST (Representational state transfer) - одна из самых популярных архитектур приложений.
Дело в том, что REST является архитектурным стилем, а не протоколом. С формальной точки зрения - REST - это написание сервера который принимает GET, POST, PUT, PATCH, DELETE запросы по каким-то url (как правило, есть группы url, каждая из которых делает 4 манипуляции с каким-то видом сущностей - Create, Read, Update, Delete).
	
REST архитектура должна придерживаться 6 принципов:
1. Модель клиент-сервер. - Должен быть сервер, у которого прописан набор endpoint’ов и структура payload’ов (полезной нагрузки, тело запроса), которые они могут принимать.
2. Отсутствие состояния - Протокол взаимодействия между клиентом и сервером требует соблюдения следующего условия: в период между запросами клиента никакая информация о состоянии клиента на сервере не хранится (Stateless protocol). Все запросы от клиента должны быть составлены так, чтобы сервер получил всю необходимую информацию для выполнения запроса. Состояние сессии при этом сохраняется на стороне клиент.
3. Кэширование - клиенты, а также промежуточные узлы, могут выполнять кэширование ответов сервера. Ответы сервера, в свою очередь, должны иметь явное или неявное обозначение как кэшируемые или некэшируемые с целью предотвращения получения клиентами устаревших или неверных данных в ответ на последующие запросы.
4. Единообразие интерфейса - Наличие унифицированного интерфейса является фундаментальным требованием дизайна REST-сервисов. Унифицированные интерфейсы позволяют каждому из сервисов развиваться независимо. Имеется в виду, что один раз определив, что в dogs у нас всегда передаётся массив таких объектов.
5. Слои - Клиент обычно не способен точно определить, взаимодействует он напрямую с сервером или же с промежуточным узлом, в связи с иерархической структурой сетей (подразумевая, что такая структура образует слои). Т.е. у нас есть 1 endpoint, но по нему запрос может попасть и быть обработан разными дочерними физическими серверами.
6. Код по требованию (необязательное ограничение) - Сервер может, при оприделённых запросах, загружать код (часто это - React или Angular приложение) клиенту, расширяя его функциональность. 

`HTTP` (англ. HyperText Transfer Protocol — «протокол передачи гипертекста») — протокол прикладного уровня передачи данных, изначально — в виде гипертекстовых документов в формате HTML, в настоящее время используется для передачи произвольных данных.
	
`HTTPS` (аббр. от англ. HyperText Transfer Protocol Secure) — расширение протокола HTTP для поддержки шифрования в целях повышения безопасности. Данные в протоколе HTTPS передаются поверх криптографических протоколов TLS (Transport Layer Security) или устаревшего в 2015 году SSL (Socket Security Layer). В отличие от HTTP с TCP-портом 80, для HTTPS по умолчанию используется TCP-порт 443. Многие web-сервисы переходят исключительно на HTTPS. Если мы хотим, чтобы сервер мог общаться с клиентами и по HTTP, и по HTTPS, нужно настроить на нём поддержку HTTPS. По сути, он будет иметь 2 набора конечных точек доступа к нему (т. е. 2 набора url, которые можно ввести в браузере для доступа к нему).		

Для каждого типа операции используется свой метод HTTP-запроса:

1. получение - GET
2. добавление - POST
3. модификация - PUT
4. удаление - DELETE

	
Протокол `WebSocket` («веб-сокет»), обеспечивает возможность обмена данными между браузером и сервером через постоянное соединение. Данные передаются по нему в обоих направлениях в виде «пакетов», без разрыва соединения и дополнительных HTTP-запросов.
WebSocket особенно хорош для сервисов, которые нуждаются в постоянном обмене данными, например онлайн игры, торговые площадки, работающие в реальном времени, и т.д.
Чтобы открыть веб-сокет-соединение, нам нужно создать объект new WebSocket, указав в url-адресе специальный протокол ws:	

WebSocket особенно хорош для сервисов, которые нуждаются в постоянном обмене данными, например онлайн игры, торговые площадки, работающие в реальном времени
	
Когда new WebSocket(url) создан, он тут же сам начинает устанавливать соединение.
Браузер, при помощи специальных заголовков, спрашивает сервер: «Ты поддерживаешь Websocket?» и если сервер отвечает «да», они начинают работать по протоколу WebSocket, который уже не является HTTP.
	
Метод WebSocket .send() может отправлять и текстовые и бинарные данные.
Вызов socket.send(body) принимает body в виде строки или любом бинарном формате включая Blob, ArrayBuffer и другие. Дополнительных настроек не требуется, просто отправляем в любом формате.
	
Как только объект WebSocket создан, мы должны слушать его события. Их всего 4:
- open – соединение установлено,
- message – получены данные,
- error – ошибка,
- close – соединение закрыто.	

  **[⬆ Наверх](#top)**

7. ### <a name="7"></a> Методологии ведения разрботки Agile, Scrum, Kanban, Waterfall

### Agile

Agile — это не методология, а собирательное название различных методик и подходов к управлению, которые: Фокусируют команду на нуждах и целях клиентов. Упрощают оргструктуру и процессы. Предлагают работу короткими циклами. Активно используют обратную связь. Предполагают повышение полномочий сотрудников. Имеют в своей основе гуманистический подход. Не являются конечным состоянием, а, скорее, образом мышления и жизни.

Преимущества и недостатки метода Agile

К преимуществам метода относятся:
- короткие и понятные итерации — циклы разработки длятся от 2 недели до 2 месяцев, по окончанию которых заказчик получает рабочую версию продукта
- высокая степень вовлечения исполнителей, организаторов и заказчиков проекта
- во главе угла стоит рабочий продукт как основной показатель прогресса — это можно рассматривать как плюс, так и минус, ведь в таком случае к команде проекта выдвигаются высокие требования по самоорганизации
- минимизация рисков благодаря гибкой системе внесения изменений;
- популярность метода среди разработчиков программ для управления бизнеса.


Не избежала методология и недостатков, которые органично «дополняют» её достоинства:
- стимулирование постоянных изменений проекта: гибкость разработки продукта может привести к тому, что он никогда не дойдёт до финальной версии
- повышенные требования к квалификации и опыту команды: помимо непосредственно создания продукта команда должна анализировать возможные способы улучшения эффективности собственной работы, беспрерывно обмениваться информацией по проекту, быть мотивированной и самоорганизованной. Далеко не всегда ресурсы проекта позволяют привлечь таких специалистов
- философский характер методологии: Agile — это не чёткая инструкция к действию, а целая философская концепция. Команда не может механически применить механики «гибкой» разработки, нужно принять ключевые принципы системы
- сложность подсчёта итоговой суммы работы: стимуляция изменений и усовершенствования конечного продукта приводит к плавающему значению стоимости проекта. Поэтому Agile не подойдет для управления проектами в строительстве, где составляется четкая смета под всю работу.

К отдельным agile-подходам относятся scrum и kanban.


### Scrum

Scrum — методология гибкой разработки на основе Agile, в основе которого лежит «спринт» — отрезок от 1 до 4 недель, по окончанию которого должна быть получена рабочая версия продукта.

Scrum – это «подход структуры». Над каждым проектом работает универсальная команда специалистов, к которой присоединяется еще два человека: владелец продукта и scrum-мастер. Первый соединяет команду с заказчиком и следит за развитием проекта (это не формальный руководитель команды, а скорее куратор). Второй помогает первому организовать бизнес-процесс: проводит общие собрания, решает бытовые проблемы, мотивирует команду и следит за соблюдением scrum-подхода.

Scrum-подход делит рабочий процесс на равные спринты – обычно это периоды от недели до месяца, в зависимости от проекта и команды. Перед спринтом формулируются задачи на данный спринт, в конце – обсуждаются результаты, а команда начинает новый спринт. Спринты очень удобно сравнивать между собой, что позволяет управлять эффективностью работы.


### Kanban

Kanban – это «подход баланса». Его задача – сбалансировать разных специалистов внутри команды и избежать ситуации, когда дизайнеры работают сутками, а разработчики жалуются на отсутствие новых задач.

Вся команда едина – в kanban нет ролей владельца продукта и scrum-мастера. Бизнес-процесс делится не на универсальные спринты, а на стадии выполнения конкретных задач: «Планируется», «Разрабатывается», «Тестируется», «Завершено» и др.

Главный показатель эффективности в kanban – это среднее время прохождения задачи по доске. Задача прошла быстро – команда работала продуктивно и слаженно. Задача затянулась – надо думать, на каком этапе и почему возникли задержки и чью работу надо оптимизировать.

В чем разница между Scrum и Kanban?

Основу Scrum составляют короткие спринты, как правило, 2-3-х недельные. Перед началом спринта команда сама формирует список задач на итерацию, далее запускается спринт.

После окончания спринта выполненные задачи заливаются на продакшн, а невыполненные — переносятся в другой спринт. Как правило, задачи, которые делаются во время спринта, не меняются: что было на старте спринта — должно быть сделано любой ценой к окончанию спринта.

На Kanban дает больше гибкости, если под гибкостью понимать частоту смены приоритетов. Если вчера разработчик залил выполненную задачу, а сегодня получили данные с "передовой" и узнали, что вот эта штука не работает так, как было задумано, то дают новые требования. Дополненные новые задачи поднимаются вверх и программист берет эту задачу «сверху», выполняет ее и, к вечеру все работает как надо. Все счастливы и эффективны как никогда.


### Waterfall

Waterfall — методика управления проектами, которая подразумевает последовательный переход с одного этапа на другой без пропусков и возвращений на предыдущие стадии.
Водопадная модель разработки подразумевает последовательное прохождение процесса, разбитого на стадии. Переход к новому этапу возможен только после завершения предыдущего.

Преимущества и недостатки Waterfall

В число наибольших преимуществ методики Waterfall вошли:

- понятная и простая структура процесса разработки — это снижает порог вхождения для команд
- удобная отчётность — можно легко отследить ресурсы, риски, затраченное время и финансы благодаря строгой этапности процесса разработки и детальной документации проекта
- стабильность задач — задачи, которые стоят перед продуктом, ясны команде с самого начала разработки, и остаются неизменными на протяжении всего процесса
- оценка стоимости и сроков сдачи проекта — сроки выпуска готового продукта, как и его итоговая стоимость могут быть просчитаны до момента запуска разработки.


Среди недостатков водопадного метода можно выделить:

- лишенный гибкости процесс — так, если проект требует больше временных и финансовых ресурсов, чем возможно, то под нож пойдёт фаза тестирования. Согласно исследованиям консалт-группы Rothman, стоимость исправления багов после выпуска продукта выше в среднем в 20 раз, чем во время полноценного многоэтапного тестирования в процессе разработки
- «стойкость» к изменениям — жёсткий каркас из этапов разработки и условие предоставление только готового продукта определяют невозможность вносить изменения во время разработки
- инерционность — на первых стадиях прогноз временных и финансовых трат может измениться в сторону увеличения, но изменить проект в сторону оптимизации затрат, изменения функционала или концепции до выпуска готового продукта невозможно
- повышенный риск — классическая система тестирования подразумевает отдельно тестирование каждого из компонентов проекта, в том числе, во взаимодействии с другими. При использовании Waterfall происходит тестирование готового продукта.

### V-модель
	
V-модель – это улучшенная версия классической каскадной модели. Здесь на каждом этапе происходит контроль текущего процесса, для того чтобы убедится в возможности перехода на следующий уровень. В этой модели тестирование начинается еще со стадии написания требований, причем для каждого последующего этапа предусмотрен свой уровень тестового покрытия.	

  **[⬆ Наверх](#top)**

8. ### <a name="8"></a> Git info

https://github.com/nicothin/web-development/tree/master/git#%D0%BA%D0%BE%D0%BD%D1%81%D0%BE%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D1%8B	
	
`Git` — это система управления версиями, которая пришлась по душе практически всем — от разработчиков до дизайнеров. 
`GitHub` можно считать соцсетью для хранения кода.	

Git позволяет:
- просматривать историю изменений в проекте
- возращаться к старой версии проекта и обратно
- переключаться между несколькими альтернативными версиями проекта
- обмениваться кодом с другими разработчиками и совместно вести разработку	
	
### Git flow. Что это? В чем преимущества?

Gitflow — это рабочий процесс, помогающий вести непрерывную разработку программного обеспечения и внедрять методики DevOps. 

git-flow — это набор расширений git предоставляющий высокоуровневые операции над репозиторием для поддержки модели ветвления Vincent Driessen.

![gitflow](https://user-images.githubusercontent.com/80325645/121673066-3280e280-cab9-11eb-95ad-d9533c8bca3f.png)

https://www.atlassian.com/ru/git/tutorials/comparing-workflows/gitflow-workflow

### В чем отличие merge от rebase

Оба метода преследуют одну и ту же цель — интеграция изменений из одной ветки в другую. Различаются принципы работы.

- *merge*: Слияние принимает содержимое ветки источника и объединяет их с целевой веткой. В этом процессе изменяется только целевая ветка. История исходных веток остается неизменной.
	
- *rebase:* Rebase сжимает все изменения и интегрирует их в целевую ветку. Перемещение перезаписывает историю, ввиду того, что передается завершенная работа из одной ветки в другую.

### Что делает команда cherry-pick
Команда git cherry-pick применяет изменения, которые созданы в уже существующих коммитах снова наверху текущей ветки. С помощью этой команды можно переносить изменения из разных веток

### Git — распределённая система контроля версий, которая даёт возможность разработчикам отслеживать изменения в файлах и работать над одним проектом совместно с коллегами.

- git config
Одна из самых часто используемых git команд. Она может быть использована для указания пользовательских настроек, таких как электронная почта, имя пользователя, формат и т.д. К примеру, данная команда используется для установки адреса электронной почты:
- git config --global user.email адрес@gmail.com

- git init
Эта команда используется для создания GIT репозитория. Пример использования:
- git init

- git add
Команда git add может быть использована для добавления файлов в индекс. К примеру, следующая команда добавит файл под названием temp.txt присутствующий в локальном каталоге в индекс:
- git add temp.txt

- git clone
Команда git clone используется для клонирования репозитория. Если репозиторий находится на удаленном сервере, используется команда такого рода:
- git clone имя.пользователя@хост:/путь/до/репозитория

И наоборот, для клонирования локального репозитория используйте:
- git clone /путь/до/репозитория

- git commit
Команда git commit используется для коммита изменений в файлах проекта. Обратите внимание, что коммиты не сразу попадают на удаленный репозиторий. Применение:
- git commit –m “Сообщение идущее вместе с коммитом”

- git status
Команда git status отображает список измененных файлов, вместе с файлами, которые еще не были добавлены в индекс или ожидают коммита. Применение:
- git status

- git push
- git push еще одна из часто используемых git команд. Позволяет поместить изменения в главную ветку удаленного хранилища связанного с рабочим каталогом. Например:
- git push origin master

- git checkout
Команда git checkout может быть использована для создания веток или переключения между ними. К примеру, следующий код создаст новую ветку и переключится на нее:
command git checkout -b <имя-ветки>

Чтобы просто переключиться между ветками используйте:

- git checkout <имя-ветки>

- git remote
Команда позволяет пользователю подключиться к удаленному репозиторию. Данная команда отобразит список удаленных репозиториев, настроенных в данный момент:
- git remote –v

Эта команда позволит пользователю подключить локальный репозиторий к удаленному серверу:
- git remote add origin <адрес.удаленного.сервера>

- git branch
Команда git branch может быть использована для отображения, создания или удаления веток. Для отображения всех существующих веток в репозитории введите:
- git branch

Для удаления ветки:
- git branch –d <имя-ветки>

- git pull
Команда pull используется для объединения изменений, присутствующих в удаленном репозитории, в локальный рабочий каталог. Применение:
- git pull

- git merge
Команда git merge используется для объединения ветки в активную ветвь. Применение:
- git merge <имя-ветки>

- git diff
Команда git diff используется для выявления различий между ветками. Для выявления различий с базовыми файлами, используйте
- git diff --base <имя-файла>

Следующая команда используется для просмотра различий между ветками, которые должны быть объединены, до их объединения:
- git diff <ветвь-источник> <ветвь-цель>
Для простого отображения существующих различий, используйте:
- git diff

- git tag
Используется для маркировки определенных коммитов с помощью простых меток. Примером может быть эта команда:
- git tag 1.1.0 <вставьте-commitID-здесь>

- git log
Запуск команды git log отобразит список всех коммитов в ветке вместе с соответствующими сведениями. Пример результата:
commit 15f4b6c44b3c8344caasdac9e4be13246e21sadw
Author: Alex Hunter <alexh@gmail.com>
Date:   Mon Oct 1 12:56:29 2016 -0600

- git reset
Команда git reset используется для сброса индекса и рабочего каталога до последнего состояния коммита. Применение:
- git reset --hard HEAD

- git rm
- git rm используется для удаления файлов из индекса и рабочего каталога. Применение:
- git rm имяфайла.txt

- git stash
Возможно одна из самых малоизвестных команд git. Она помогает в сохранении изменений на временной основе, эти изменения не попадут в коммит сразу. Применение:
- git stash

- git show
Для просмотра информации о любом git объекте используйте команду git show. Для примера:
- git show

- git fetch
- git fetch позволяет пользователю доставить все объекты из удаленного репозитория, которые не присутствуют в локальном рабочем каталоге. Пример применения:
- git fetch origin

- git ls-tree
Команда git ls-tree используется для просмотра дерева объекта вместе с названием, режимом каждого предмета и значением SHA-1. К примеру:
- git ls-tree HEAD

- git cat-file
Используйте команду git cat-file, чтобы просмотреть тип объекта с помощью SHA-1 значения. Например:
- git cat-file –p d670460b4b4aece5915caf5c68d12f560a9fe3e4

- git grep
- git grep позволяет пользователю проводить поиск фраз и слов в содержимом деревьев. К примеру, для поиска www.hostinger.ru во всех файлах используйте эту команду:
- git grep "www.hostinger.ru"

- gitk
- gitk — это графический интерфейс локального репозитория. Вызвать его можно выполнив данную команду:
- gitk

- git instaweb
С помощью команды git instaweb можно запустить веб-сервер, связанный с локальным репозиторием. Браузер также автоматически будет перенаправляться на него. Например:
- git instaweb –httpd=webrick

- git gc
Для оптимизации репозитория используйте команду git gc. Она поможет удалить и оптимизировать ненужные файлы:
- git gc

- git archive
Команда git archive позволяет пользователю создать .zip или .tar файл содержащий компоненты одного из деревьев репозитория. Например:
- git archive --format=tar master

- git prune
С помощью команды git prune удаляются объекты, не имеющие никаких входящих указателей. Применение:
- git prune

- git fsck
Чтобы выполнить проверку целостности файловой системы git, используйте команду git fsck, при этом будут идентифицированы все поврежденные объекты:
- git fsck

- git rebase
Команда git rebase используется для применения коммитов в другой ветке. Например:
- git rebase master

https://htmlacademy.ru/blog/boost/frontend/first-aid-git

  **[⬆ Наверх](#top)**

9. ### <a name="9"></a> Паттерны проектирования

`Паттерн` - это решение распространенных проблем, возникающих при разработке программного обеспечения - в нашем случае - при написании приложений на JavaScript.

Группы паттернов:

1. Порождающие.
2. Структурные.
3. Поведенческие.

Почему важно знать паттерны?

- Паттерны представляют собой подходы к решению задач в сфере разработки ПО, основанные на опыте большого количества профессиональных разработчиков.
- Паттерны могут быть легко адаптированы для наших нужд.
- Паттерны представляют собой общую схему решения однотипных задач.

`Порождающие дизайн паттерны` - это те паттерны которые позволяют управлять процессом созданния паттернов:
- Конструктор - наиболее частый дизайн паттерн, который позволяет нам создавать новые обьекты определенного типа.
- Фабрика - коолекция элементов похожие по функционалу, необходимо создавать инстенсы у обьектов похожего типа через классы меняя у них значения.
- Прототип - мы можем создавать какие-то обьекты используя как скилет для его прототипа какие-то другие обьекты.
- SingleTon - существует класс в приложение и в приложении может быть только один инстанс данного класса. Используется в базах даных

`Структурные:` эти паттерны отвечают за построение удобных в поддержке иерархий классов.
- Адаптер - это те которые позволяют уже в существующее приложение внедрить новый функционал не ломая его. Он позволяет интегрировать старый интерфейс в новый интерфейс и позволяет им работать совместно при чем не ломая приложение
- Декоратор - с помощью данного патерна мы имеем возможность добавлять новое поведение или функционал для существующих классов.
- Фасад - часто используется, служит для того чтобы создавать более простой и уникальный интерфейс для взаимодействия с различными классами.
- Fleweight - что бы мы могли эффективно передавать и работать с данными через различные типы обьектов. Браузеры используют его что бы избежать повторной загрузки изображений которые были загруженны.
- Proxy - избавление от лишних запросов на сервер

`Поведенческие` позволяют нам улучшить коммуникацию между обьектами разного типа:
- Chain of responsibility - позволяет последовательно у одного и того же обьекта вызывать какой-то набор операций и последовательно их модифицировать.(jQuery)
- Комманд - позволяет создавать определенную абстрактную оболочку над функционалом который позволяет управлять но уже через другой обьект и тем самым записывая определенные состоянии которые были вызваны. (Redux)
- Итератор - идея заключается в том что мы создаем какойто обьект, класс у которого мы можем последовательно получать доступ к определенной информации
- Медиатор - паттерн который в первую очередб позволяет выстраивать очень плотную коммуникацию между различными обьектами разного типа, при этом он предоставляет централизованную абстракцию которая позволяет взаимодействовать группе обьектов через друг друга.
- Observer - формирует зависимости один к многим, идея в том что у нас есть обьект у которго мы можем затригерить вызов изменения, и дальше все другие обьекты которые подписаны на эти изменение они получают эти обновления и делают свой функционал.
- State дизайн паттерн - мы можем создавать различные классы котроые будут элементами Стейта и мы можем делигировать изменеие состояние этих классов на общий класс который будет явлтся стейтом и который будет менять внутренне состояние этих элементов.
- Strategy - позволяет создавать некоторую оболочку для различных интерфейсов для того что бы могли использовать разные алгоритмы, интерфейсы в конкретной задаче. Другими словами определяет семейство некоторых алгоритмов которые наследуют обьекты в неизменяемом порядке.
- Template - определяет некоторый скелет будущего алгоритма но при этом он делигирует создание конкрерного функционала в дочерние классы, тоисть он определяет некоторую структуру а дочерние классы реализовуют конкретный функционал, при этом не изменяя поведение базового класса. 

	
### Примеры
	
`Порождающие дизайн паттерны` - это те паттерны которые позволяют управлять процессом созданния паттернов:
	
- Конструктор - наиболее частый дизайн паттерн, который позволяет нам создавать новые обьекты определенного типа.
```js
// function Server(name, ip) {
//   this.name = name
//   this.ip = ip
// }
//
// Server.prototype.getUrl = function() {
//   return `https://${this.ip}:80`
// }

class Server {
  constructor(name, ip) {
    this.name = name
    this.ip = ip
  }

  getUrl() {
    return `https://${this.ip}:80`
  }
}

const aws = new Server('AWS German', '82.21.21.32')
console.log(aws.getUrl())	
```	
		
- Фабрика - коолекция элементов похожие по функционалу, необходимо создавать инстенсы у обьектов похожего типа через классы меняя у них значения.
```js	
class SimpleMembership {
  constructor(name) {
    this.name = name
    this.cost = 50
  }
}

class StandardMembership {
  constructor(name) {
    this.name = name
    this.cost = 150
  }
}

class PremiumMembership {
  constructor(name) {
    this.name = name
    this.cost = 500
  }
}

class MemberFactory {
  static list = {
    simple: SimpleMembership,
    standard: StandardMembership,
    premium: PremiumMembership
  }

  create(name, type = 'simple') {
    const Membership = MemberFactory.list[type] || MemberFactory.list.simple
    const member = new Membership(name)
    member.type = type
    member.define = function() {
      console.log(`${this.name} (${this.type}): ${this.cost}`)
    }
    return member
  }
}

const factory = new MemberFactory()

const members = [
  factory.create('Vladilen', 'simple'),
  factory.create('Elena', 'premium'),
  factory.create('Vasilisa', 'standard'),
  factory.create('Ivan', 'premium'),
  factory.create('Petr')
]

members.forEach(m => {
  m.define()
})	
```
	
- Прототип - мы можем создавать какие-то обьекты используя как скилет для его прототипа какие-то другие обьекты.
```js
const car = {
  wheels: 4,

  init() {
    console.log(`У меня есть ${this.wheels} колеса, мой владелец ${this.owner}`)
  }
}

const carWithOwner = Object.create(car, {
  owner: {
    value: 'Дмитрий'
  }
})

console.log(carWithOwner.__proto__ === car)

carWithOwner.init()	
```
	
- SingleTon - существует класс в приложение и в приложении может быть только один инстанс данного класса. Используется в базах даных
```js
class Database {
  constructor(data) {
    if (Database.exists) {
      return Database.instance
    }
    Database.instance = this
    Database.exists = true
    this.data = data
  }

  getData() {
    return this.data
  }
}

const mongo = new Database('MongoDB')
console.log(mongo.getData())

const mysql = new Database('MySQL')
console.log(mysql.getData())	
```	

`Структурные:` эти паттерны отвечают за построение удобных в поддержке иерархий классов.
	
- Адаптер - это те которые позволяют уже в существующее приложение внедрить новый функционал не ломая его. Он позволяет интегрировать старый интерфейс в новый интерфейс и позволяет им работать совместно при чем не ломая приложение
```js
class OldCalc {
  operations(t1, t2, operation) {
    switch (operation) {
      case 'add': return t1 + t2
      case 'sub': return t1 - t2
      default: return NaN
    }
  }
}

class NewCalc {
  add(t1, t2) {
    return t1 + t2
  }

  sub(t1, t2) {
    return t1 - t2
  }
}

class CalcAdapter {
  constructor() {
    this.calc = new NewCalc()
  }

  operations(t1, t2, operation) {
    switch (operation) {
      case 'add': return this.calc.add(t1, t2)
      case 'sub': return this.calc.sub(t1, t2)
      default: return NaN
    }
  }
}

const oldCalc = new OldCalc()
console.log(oldCalc.operations(10, 5, 'add'))

const newCalc = new NewCalc()
console.log(newCalc.add(10, 5))

const adapter = new CalcAdapter()
console.log(adapter.operations(25, 10, 'sub'))	
```
	
- Декоратор - с помощью данного патерна мы имеем возможность добавлять новое поведение или функционал для существующих классов.
```js
class Server {
  constructor(ip, port) {
    this.ip = ip
    this.port = port
  }

  get url() {
    return `https://${this.ip}:${this.port}`
  }
}

function aws(server) {
  server.isAWS = true
  server.awsInfo = function() {
    return server.url
  }
  return server
}

function azure(server) {
  server.isAzure = true
  server.port += 500
  return server
}

const s1 = aws(new Server('12.34.56.78', 8080))
console.log(s1.isAWS)
console.log(s1.awsInfo())

const s2 = azure(new Server('98.87.76.12', 1000))
console.log(s2.isAzure)
console.log(s2.url)	
```
	
- Фасад - часто используется, служит для того чтобы создавать более простой и уникальный интерфейс для взаимодействия с различными классами.
```js
class Complaints {
  constructor() {
    this.complaints = []
  }

  reply(complaint) {}

  add(complaint) {
    this.complaints.push(complaint)
    return this.reply(complaint)
  }
}

class ProductComplaints extends Complaints {
  reply({id, customer, details}) {
    return `Product: ${id}: ${customer} (${details})`
  }
}

class ServiceComplaints extends Complaints {
  reply({id, customer, details}) {
    return `Service: ${id}: ${customer} (${details})`
  }
}

class ComplaintRegistry {
  register(customer, type, details) {
    const id = Date.now()
    let complaint

    if (type === 'service') {
      complaint = new ServiceComplaints()
    } else {
      complaint = new ProductComplaints()
    }

    return complaint.add({id, customer, details})
  }
}

const registry = new ComplaintRegistry()

console.log(registry.register('Vladilen', 'service', 'недоступен'))
console.log(registry.register('Elena', 'product', 'вылазит ошибка'))	
```
	
- Fleweight - что бы мы могли эффективно передавать и работать с данными через различные типы обьектов. Браузеры используют его что бы избежать повторной загрузки изображений которые были загруженны.
```js
class Car {
  constructor(model, price) {
    this.model = model
    this.price = price
  }
}

class CarFactory {
  constructor() {
    this.cars = []
  }

  create(model, price) {
    const candidate = this.getCar(model)
    if (candidate) {
      return candidate
    }

    const newCar = new Car(model, price)
    this.cars.push(newCar)
    return newCar
  }

  getCar(model) {
    return this.cars.find(car => car.model === model)
  }
}

const factory = new CarFactory()

const bmwX6 = factory.create('bmw', 10000)
const audi = factory.create('audi', 12000)
const bmwX3 = factory.create('bmw', 8000)

console.log(bmwX3 === bmwX6)	
```
	
- Proxy - избавление от лишних запросов на сервер
```js
function networkFetch(url) {
  return `${url} - Ответ с сервера`
}

const cache = new Set()
const proxiedFetch = new Proxy(networkFetch, {
  apply(target, thisArg, args) {
    const url = args[0]
    if (cache.has(url)) {
      return `${url} - Ответ из кэша`
    } else {
      cache.add(url)
      return Reflect.apply(target, thisArg, args)
    }
  }
})

console.log(proxiedFetch('angular.io'))
console.log(proxiedFetch('react.io'))
console.log(proxiedFetch('angular.io'))	
```	

`Поведенческие` позволяют нам улучшить коммуникацию между обьектами разного типа:
	
- Chain of responsibility - позволяет последовательно у одного и того же обьекта вызывать какой-то набор операций и последовательно их модифицировать.(jQuery)
```js
class MySum {
  constructor(initialValue = 42) {
    this.sum = initialValue
  }

  add(value) {
    this.sum += value
    return this
  }
}

const sum1 = new MySum()
console.log(sum1.add(8).add(10).add(1).add(9).sum)

const sum2 = new MySum(0)
console.log(sum2.add(1).add(2).add(3).sum)	
```
	
- Комманд - позволяет создавать определенную абстрактную оболочку над функционалом который позволяет управлять но уже через другой обьект и тем самым записывая определенные состоянии которые были вызваны. (Redux)
```js
class MyMath {
  constructor(initialValue = 0) {
    this.num = initialValue
  }

  square() {
    return this.num ** 2
  }

  cube() {
    return this.num ** 3
  }
}

class Command {
  constructor(subject) {
    this.subject = subject
    this.commandsExecuted = []
  }

  execute(command) {
    this.commandsExecuted.push(command)
    return this.subject[command]()
  }
}

const x = new Command(new MyMath(2))

console.log(x.execute('square'))
console.log(x.execute('cube'))

console.log(x.commandsExecuted)	
```
	
- Итератор - идея заключается в том что мы создаем какойто обьект, класс у которого мы можем последовательно получать доступ к определенной информации
```js
class MyIterator {
  constructor(data) {
    this.index = 0
    this.data = data
  }

  [Symbol.iterator]() {
    return {
      next: () => {
        if (this.index < this.data.length) {
          return {
            value: this.data[this.index++],
            done: false
          }
        } else {
          this.index = 0
          return {
            done: true,
            value: void 0
          }
        }
      }
    }
  }
}

function* generator(collection) {
  let index = 0

  while (index < collection.length) {
    yield collection[index++]
  }
}


const iterator = new MyIterator(['This', 'is', 'iterator'])
const gen = generator(['This', 'is', 'iterator'])

// for (const val of gen) {
//   console.log('Value: ', val)
// }

console.log(gen.next().value)
console.log(gen.next().value)
console.log(gen.next().value)	
```
	
- Медиатор - паттерн который в первую очередб позволяет выстраивать очень плотную коммуникацию между различными обьектами разного типа, при этом он предоставляет централизованную абстракцию которая позволяет взаимодействовать группе обьектов через друг друга.
```js
class User {
  constructor(name) {
    this.name = name
    this.room = null
  }

  send(message, to) {
    this.room.send(message, this, to)
  }

  receive(message, from) {
    console.log(`${from.name} => ${this.name}: ${message}`)
  }
}

class ChatRoom {
  constructor() {
    this.users = {}
  }

  register(user) {
    this.users[user.name] = user
    user.room = this
  }

  send(message, from, to) {
    if (to) {
      to.receive(message, from)
    } else {
      Object.keys(this.users).forEach(key => {
        if (this.users[key] !== from) {
          this.users[key].receive(message, from)
        }
      })
    }
  }
}

const vlad = new User('Vladilen')
const lena = new User('Elena')
const igor = new User('Igor')

const room = new ChatRoom()

room.register(vlad)
room.register(lena)
room.register(igor)

vlad.send('Hello!', lena)
lena.send('Hello hello!', vlad)
igor.send('Vsem privet')	
```
	
- Observer - формирует зависимости один к многим, идея в том что у нас есть обьект у которго мы можем затригерить вызов изменения, и дальше все другие обьекты которые подписаны на эти изменение они получают эти обновления и делают свой функционал.
```js
class Subject {
  constructor() {
    this.observers = []
  }

  subscribe(observer) {
    this.observers.push(observer)
  }

  unsubscribe(observer) {
    this.observers = this.observers.filter(obs => obs !== observer)
  }

  fire(action) {
    this.observers.forEach(observer => {
      observer.update(action)
    })
  }
}

class Observer {
  constructor(state = 1) {
    this.state = state
    this.initialState = state
  }

  update(action) {
    switch (action.type) {
      case 'INCREMENT':
        this.state = ++this.state
        break
      case 'DECREMENT':
        this.state = --this.state
        break
      case 'ADD':
        this.state += action.payload
        break
      default:
        this.state = this.initialState
    }
  }
}

const stream$ = new Subject()

const obs1 = new Observer()
const obs2 = new Observer(42)

stream$.subscribe(obs1)
stream$.subscribe(obs2)

stream$.fire({type: 'INCREMENT'})
stream$.fire({type: 'INCREMENT'})
stream$.fire({type: 'DECREMENT'})
stream$.fire({type: 'ADD', payload: 10})

console.log(obs1.state)
console.log(obs2.state)	
```
	
- State дизайн паттерн - мы можем создавать различные классы котроые будут элементами Стейта и мы можем делигировать изменеие состояние этих классов на общий класс который будет явлтся стейтом и который будет менять внутренне состояние этих элементов.
```js
class Light {
  constructor(light) {
    this.light = light
  }
}

class RedLight extends Light {
  constructor() {
    super('red')
  }

  sign() {
    return 'СТОП'
  }
}

class YellowLight extends Light {
  constructor() {
    super('yellow')
  }

  sign() {
    return 'ГОТОВЬСЯ'
  }
}

class GreenLight extends Light {
  constructor() {
    super('green')
  }

  sign() {
    return 'ЕДЬ!'
  }
}

class TrafficLight {
  constructor() {
    this.states = [
      new RedLight(),
      new YellowLight(),
      new GreenLight()
    ]
    this.current = this.states[0]
  }

  change() {
    const total = this.states.length
    let index = this.states.findIndex(light => light === this.current)

    if (index + 1 < total) {
      this.current = this.states[index + 1]
    } else {
      this.current = this.states[0]
    }
  }

  sign() {
    return this.current.sign()
  }
}

const traffic = new TrafficLight()
console.log(traffic.sign())
traffic.change()

console.log(traffic.sign())
traffic.change()

console.log(traffic.sign())
traffic.change()

console.log(traffic.sign())
traffic.change()

console.log(traffic.sign())
traffic.change()

console.log(traffic.sign())
traffic.change()	
```
	
- Strategy - позволяет создавать некоторую оболочку для различных интерфейсов для того что бы могли использовать разные алгоритмы, интерфейсы в конкретной задаче. Другими словами определяет семейство некоторых алгоритмов которые наследуют обьекты в неизменяемом порядке.
```js
class Vehicle {
  travelTime() {
    return this.timeTaken
  }
}

class Bus extends Vehicle {
  constructor() {
    super()
    this.timeTaken = 10
  }
}

class Taxi extends Vehicle {
  constructor() {
    super()
    this.timeTaken = 5
  }
}

class Car extends Vehicle {
  constructor() {
    super()
    this.timeTaken = 3
  }
}

class Commute {
  travel(transport) {
    return transport.travelTime()
  }
}

const commute = new Commute()

console.log(commute.travel(new Taxi()))
console.log(commute.travel(new Bus()))
console.log(commute.travel(new Car()))			  
```
			  
- Template - определяет некоторый скелет будущего алгоритма но при этом он делигирует создание конкрерного функционала в дочерние классы, тоисть он определяет некоторую структуру а дочерние классы реализовуют конкретный функционал, при этом не изменяя поведение базового класса.
```js
class Employee {
  constructor(name, salary) {
    this.name = name
    this.salary = salary
  }

  responsibilities() {}

  work() {
    return `${this.name} выполняет ${this.responsibilities()}`
  }

  getPaid() {
    return `${this.name} имеет ЗП ${this.salary}`
  }
}

class Developer extends Employee {
  constructor(name, salary) {
    super(name, salary)
  }

  responsibilities() {
    return 'процесс создания программ'
  }
}

class Tester extends Employee {
  constructor(name, salary) {
    super(name, salary)
  }

  responsibilities() {
    return 'процесс тестирования'
  }
}

const dev = new Developer('Владилен', 100000)
console.log(dev.getPaid())
console.log(dev.work())

const tester = new Tester('Виктория', 90000)
console.log(tester.getPaid())
console.log(tester.work())			  
```			  	
	
https://medium.com/@marina.kovalyova/java-script-design-patterns-569c627d25f9	
	
https://refactoring.guru/ru/design-patterns/catalog	
	
https://proglib.io/p/js-design-patterns/

  **[⬆ Наверх](#top)**

10. ### <a name="10"></a> Структуры данных. Алгоритмы поиска, Сортировки. Сложность алгоритма

*Структура данных* — это контейнер, который хранит данные в определенном макете. Макет определяет эффективность и неэффективность структуры данных по отношению к определенным операциям.

- *Массивы* Одномерные, многомерные. Последовательные. Легко обращаться к необходимым элементам по их индексам.
- *Стеки* Список элементов, организованных по принципу “последним вошел, первый вышел”
- *Очереди* Список элементов, организованных по принципу “первым вошел, первым вышел”.
- *Связный список* Однонаправленный, двунаправленный, круговой. это цепочечная структура данных, где каждый узел состоит из двух частей: данных узла и указателя на следующий узел.
- *Графы*
- *Деревья*

Возможно еще структуры дынных:
- Array (структура данных которая содержит в себе список однотипных элементов)
- Object (Описываем один обьект - персонаж: имя, фамилия, вес)
- Set (похож на массив но не может содержать в себе одинковые элементы)
- Map (аналогия обьекта но усовершенсвованее, мы храним данные как ключ и значение, однако ключем может быть что угодно, Map добавляет удобный интерфейс для работы с этими данними, много рахных методов)
- WeckMap
- WeakSet
- Матрица (Matrix)
- Связный список (Linked list)
- Стек (Stack)
- Очередь (Queue)
- Дерево (Tree)
- Куча (Heap)
- Префиксное дерево (Prefix tree)
- Хеш-таблица (Hash table)

https://robotdreams.cc/blog/58-structure-your-data-please

	
	
*Алгоритм* это набор последовательных действий, которые решают какую-то задачу, в принципи любой фрагмент кода можно назвать алгоритмом.

### Линейный поиск - сложность O(n), где n - колличество элементов в массиве.
	
Просматривайте все один за другим, пока не найдете это». Если элементов в миллион раз больше, это займет в миллион раз больше времени, и это может привести к долгому выполнению или даже зависанию браузера. 
```js
const array = [1,4,5,8,5,1,2,7,5,2,11]
let count = 0
function linearSearch(array, item) {
    for (let i = 0; i < array.length; i++) {
        count += 1
        if (array[i] === item) {
            return i;
        }
    }
    return null
}

console.log(linearSearch(array, 1))
console.log('count = ', count)	
```	
		
	
### Бинарный поиск - сложность O(log2n)				   
				     
Массив отсортированный по порядку, делим массив пополам, смотрим в какой части массива находится искомый обьект, потом делим и его пополам, пока не найдем наш обьект.
				     
```js
const array = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]
let count = 0

function binarySearch(array, item) {
    let start = 0
    let end = array.length
    let middle;
    let found = false
    let position = -1
    while (found === false && start <= end) {
        count+=1
        middle = Math.floor((start + end) / 2);
        if (array[middle] === item) {
            found = true
            position = middle
            return position;
        }
        if (item < array[middle]) {
            end = middle - 1
        } else {
            start = middle + 1
        }
    }
    return position;
}
				 
console.log(binarySearch(array, item))
console.log(count)				 
```				     

				 
### Рекурсивный бинарный поиск - сложность Olog2n				 

```js
function recursiveBinarySearch(array, item, start, end) {
    let middle = Math.floor((start + end) / 2);
    count += 1
    if (item === array[middle]) {
        return middle
    }
    if (item < array[middle]) {
        return recursiveBinarySearch(array, item, 0, middle - 1 )
    } else {
        return recursiveBinarySearch(array, item, middle + 1, end )
    }
}

console.log(recursiveBinarySearch(array, 0, 0, array.length))
console.log(count)				 
```				 				 
				 

### Сортировка выбором - сложность O(n^2)
				 
В основе сортировки выбором лежит следующий подход: мы находим минимальное значение в структуре данных и помещаем его на первую позицию, затем находим второе минимальное значение и помещаем его на вторую позицию и так далее.
				 
```js
const arr = [0,3,2,5,6,8,1,9,4,2,1,2,9,6,4,1,7,-1, -5, 23,6,2,35,6,3,32] // [0,1,1,2,3.......]
let count = 0

function selectionSort(array) {
    for (let i = 0; i < array.length; i++) {
        let indexMin = i
        for (let j = i+1; j < array.length; j++) {
            if (array[j] < array[indexMin]) {
                indexMin = j
            }
            count += 1
        }
        let tmp = array[i]
        array[i] = array[indexMin]
        array[indexMin] = tmp
    }
    return array
}

console.log(selectionSort(arr))
console.log(arr.length) // O(n*n)
console.log('count = ', count)				 
```				 				 

	
### Сортировка пузырьком - O(n*n)
	
Если говорить коротко, алгоритм сортировки пузырьком сравнивает два соседних значения и меняет их местами, если первое значение больше второго. Значения как бы всплывают подобно пузырькам воздуха в воде, выстраиваясь в восходящем порядке.
	
```js
const arr = [0,3,2,5,6,8,23,9,4,2,1,2,9,6,4,1,7,-1, -5, 23,6,2,35,6,3,32,9,4,2,1,2,9,6,4,1,7,-1, -5, 23,9,4,2,1,2,9,6,4,1,7,-1, -5, 23,]
let count = 0

function bubbleSort(array) {
    for (let i = 0; i < array.length; i++) {
        for (let j = 0; j < array.length; j++) {
            if (array[j + 1] < array[j]) {
                let tmp = array[j]
                array[j] = array[j+1]
                array[j+1] = tmp
            }
            count+=1
        }
    }
    return array
}

console.log('length', arr.length)
console.log(bubbleSort(arr)) // O(n*n)
console.log('count = ', count)	
```	
	

### Быстрая сортировка - сложность O(log2n*n)
					
- Выбираем значение в массиве, которое назовем опорным. Обычно это значение в середине массива.
- Осуществляем операцию распределения, в результате которой значения меньше опорного смещаются влево от опорного, а большие — вправо от него.
- Повторяем первые два шага для каждого подмассива (левого и правого), пока массивы не будут полностью отсортированы.

```js
const arr = [0,3,2,5,6,8,23,9,4,2,1,2,9,6,4,1,7,-1, -5, 23,6,2,35,6,3,32,9,4,2,1,2,9,6,4,1,7,-1, -5, 23,9,4,2,1,2,9,6,4,1,7,-1, -5, 23,]
let count = 0

function quickSort(array) {
    if (array.length <= 1) {
        return array
    }
    let pivotIndex = Math.floor(array.length / 2);
    let pivot = array[pivotIndex]
    let less = []
    let greater = []
    for (let i = 0; i < array.length; i++) {
        count += 1
        if(i === pivotIndex)
            continue
        if (array[i] < pivot) {
            less.push(array[i])
        } else {
            greater.push(array[i])
        }
    }
    return [...quickSort(less), pivot, ...quickSort(greater)]
}

console.log(quickSort(arr))
console.log('count', count)					
```					
															
https://tproger.ru/articles/computational-complexity-explained/


### Рекурсия					
					
*Рекурсия это функция которая вызывает сама себя*

```js
const factorial = (n) => {
    if (n === 1) {
        return 1
    }
    return n * factorial(n - 1)
}
	
console.log(factorial(5))	

	
	
// Числа фибоначчи -  1,1,2,3,5,8,13,21

const fibonachi = (n) => {
    if (n === 1 || n === 2) {
        return 1
    }
    return fibonachi(n-1) + fibonachi(n-2)
}

console.log(fibonachi(8))					
```					
					
					
					

### Big O (оценка сложности алгоритмов)

Big O - относительное представления сложности алгоритма, показывает как будет меняться производительность алгоритма в зависимости от роста входящий данных	
	
Нужна для описания сложности алгоритмов, используя понятие времени. В Big O нотации всегда рассматривается худший вариант — искомый элемент может быть самым последним.

- Константная сложность (О1): Получение элемента коллекции это O(1). Будь то получение по индексу в массиве, или по ключу в словаре в нотации Big O это будет O(1).
- Линейная сложность: Перебор коллекции это O(n).
- Квадратичная сложность: Вложенные циклы по той же коллекции это O(n^2).
- Логарифмическая сложность: Разделяй и властвуй (Divide and Conquer) всегда O(log n).
- Merge sort, для маленьких массивов используется Inserted Sort: Итерации которые используют Divide and Conquer это O(n log n).
- Кубическая сложность O(n^3) 
- Экспоненциальная сложность O(2^n)
- Факториальная сложность O(n!)	
	
![49](https://user-images.githubusercontent.com/80325645/130518255-1de96431-96be-481a-be09-e1745fa98398.jpg)

	
### Структуры данных
	
- Графы
	
```js
// Поиск в ширину в графе

const graph = {}
graph.a = ['b', 'c']
graph.b = ['f']
graph.c = ['d', 'e']
graph.d = ['f']
graph.e = ['f']
graph.f = ['g']

function breadthSearch(graph, start, end) {
    let queue = []
    queue.push(start)
    while (queue.length > 0) {
        const current = queue.shift()
        if (!graph[current]) {
            graph[current] = []
        }
        if (graph[current].includes(end)) {
            return true
        } else {
            queue = [...queue, ...graph[current]]
        }
    }
    return false
}

console.log(breadthSearch(graph, 'a', 'e'))	
```
	
- Матрица смежности
```js
const matrix = [
    [0,1,1,0,0,0,0],
    [0,0,0,0,1,0,0],
    [0,0,0,1,0,1,0],
    [0,0,0,0,1,0,0],
    [0,0,0,0,0,0,1],
    [0,0,0,0,1,0,0],
    [0,0,0,0,0,0,0],
]
```	

	
- Алгоритм дейкстры (Графы)
	
```js
// Поиск кратчайшего пути в графе

const graph = {}
graph.a = {b: 2, c: 1}
graph.b = {f: 7}
graph.c = {d: 5, e: 2}
graph.d = {f: 2}
graph.e = {f: 1}
graph.f = {g: 1}
graph.g = {}

function shortPath(graph, start, end) {
    const costs = {}
    const processed = []
    let neighbors = {}
    Object.keys(graph).forEach(node => {
        if (node !== start) {
            let value = graph[start][node]
            costs[node] = value || 100000000
        }
    })
    let node = findNodeLowestCost(costs, processed)
    while (node) {
        const cost = costs[node]
        neighbors = graph[node]
        Object.keys(neighbors).forEach(neighbor => {
            let newCost = cost + neighbors[neighbor]
            if (newCost < costs[neighbor]) {
                costs[neighbor] = newCost
            }
        })
        processed.push(node)
        node = findNodeLowestCost(costs, processed)
    }
    return costs
}


function findNodeLowestCost(costs, processed) {
    let lowestCost = 100000000
    let lowestNode;
    Object.keys(costs).forEach(node => {
        let cost = costs[node]
        if (cost < lowestCost && !processed.includes(node)) {
            lowestCost = cost
            lowestNode = node
        }
    })
    return lowestNode
}

console.log(shortPath(graph, 'a', 'g'));	
```	

			     
- Деревья
			     
```js
const tree = [
    {
        v: 5,
        c: [
            {
                v:10,
                c: [
                    {
                        v:11,
                    }
                ]
            },
            {
                v:7,
                c: [
                    {
                        v:5,
                        c: [
                            {
                                v:1
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        v: 5,
        c: [
            {
                v:10
            },
            {
                v:15
            }
        ]
    }
]

			     
			     
			     
const recursive = (tree) => {
    let sum = 0;
    tree.forEach(node => {
        sum += node.v
        if(!node.c) {
            return node.v
        }
        sum += recursive(node.c)
    })
    return sum
}

const iteration = (tree) => {
    if (!tree.length) {
        return 0
    }
    let sum = 0
    let stack = []
    tree.forEach(node => stack.push(node));
    while (stack.length) {
        const node = stack.pop()
        sum += node.v
        if (node.c) {
            node.c.forEach(child => stack.push(child))
        }
    }
    return sum
}

console.log(iteration(tree))
// console.log(recursive(tree))			     
```			     

*Стек* - элементы всегда добавляются в конец структуры, и извлекаються с конца. это как стопка бумаги, последный лист положил - последний  лист взял
	
	
	
- Кеш
	
```js
function cashFunction(fn) {
    const cash = {}
    return function (n) {
        if (cash[n]) {
            console.log('Взято из кеша', cash[n])
            return cash[n]
        }
        let result = fn(n)
        console.log('Посчитала функция = ', result)
        cash[n] = result
        return result;
    };
}

function factorial(n) {
    let result = 1
    while (n != 1) {
        result *= n
        n -= 1
    }
    return result
}

const cashFactorial = cashFunction(factorial)

cashFactorial(5)
cashFactorial(4)
cashFactorial(3)
cashFactorial(4)
cashFactorial(5)
cashFactorial(1)	
```	

			
- Связный список
	
```js
class LinkedList {
    constructor() {
        this.size = 0
        this.root = null
    }

    add(value) {
        if (this.size === 0) {
            this.root = new Node(value);
            this.size += 1;
            return true;
        }
        let node = this.root
        while (node.next) {
            node = node.next
        }
        let newNode = new Node(value)
        node.next = newNode
        this.size += 1
    }

    getSize() {
        return this.size
    }

    print() {
        let result = []
        let node = this.root
        while (node) {
            result.push(node.value)
            node = node.next
        }
        console.log(result);;
    }
}

class Node {
    constructor(value) {
        this.value = value
        this.next = null
    }
}

const list = new LinkedList()
list.add(5)
list.add(3)
list.add(2)
list.add(5)
list.add(7)

list.print()	
```	

	
- Бинарное дерево
	
```js
class BinaryTree {
    constructor() {
        this.root = null
    }

    add(value) {
        if (!this.root) {
            this.root = new TreeNode(value)
        } else {
            let node = this.root
            let newNode = new TreeNode(value)
            while (node) {
                if (value > node.value) {
                    if (!node.right) {
                        break
                    }
                    node = node.right
                } else {
                    if (!node.left) {
                        break
                    }
                    node = node.left
                }
            }
            if (value > node.value) {
                node.right = newNode
            } else {
                node.left = newNode
            }
        }
    }

    print(root = this.root) {
        if (!root) {
            return true;
        }
        console.log(root.value);
        this.print(root.left)
        this.print(root.right)
    }
}

class TreeNode {
    constructor(value) {
        this.value = value
        this.left = null
        this.right = null
    }
}

const tree = new BinaryTree()
tree.add(5)
tree.add(2)
tree.add(6)
tree.add(2)
tree.add(1)
tree.print()	
```	

	
- Set(хранит уникальные значения) & Map
	
Ключ - значение	

```js
const map = new Map()
const objKey = {id:5}
map.set(objKey, "ulbi tv")

console.log(map.get(objKey));

const set = new Set()

set.add(5)
set.add(5)
set.add(5)
set.add(5)
set.add(5)
set.add(4)
set.add(3)
console.log(set)	
```	
	
	
  **[⬆ Наверх](#top)**

11. ### <a name="11"></a> Unit-tests

*Unit-тесты* — это код, позволяющий проверить на корректность отдельные модули исходного кода. Тесты пишутся для каждой нетривиальной функции.

Юнит-тест — это код, который тестирует юниты (части) кода: функции, модули или классы. ... Вся суть — подать что-то на вход юнита и 

Преимущества юнит-тестирования очевидны:

- Являются низкоуровневым и фокусируется на маленькой части ПО
- Тесты пишут сами разработчики
- Тесты выполняются очень быстро, можно выполнять тесты несколько раз в минуту
- При разработке можно выполнять не все тесты, а только те, которые необходимы именно вам

Таким образом, при использовании юнит тестирования скорость разработки существенно не уменьшается, но при этом возрастает качество самого продукта.

Важное различия в юнит тестировании, это какой тип тестирования вы выберите: Solitary (одинокий) и Sociable (общительный) тест.

Sociable (общительный) тест — это тест который использует реальные методы (или классы), которые входят в тестируемую единицу. Например, вы тестируете метод «цена» из класса заказов. Методу «цена» необходимо вызвать методы из класса клиент и продукт. В данном виде тестов будут вызваны именно эти методы, и ошибка в этих методах приведет к ошибке теста. Методы из классов клиент и продукт называется партнеры (collaborators).

Solitary (одинокий) тест — это тест, который в качестве партнеров использует дубли (TestDouble). Тест-дубли — это общий термин для любого случая, в котором вы заменяете реальный объект, исключительно для целей тестирования.

TDD (**T**est-**D**riven **D**evelopment) — подход к разработке и тестированию, при котором сначала создаются тесты, которым должен удовлетворять код и только потом его реализация. TDD — процесс итеративный. Добавляя в класс что то новое, вы сначала пишите тест на новый функционал и только потом создаете минимальное количество кода, реализующее нужное поведение.

BDD (**B**ehavior-**D**riven **D**evelopment) — расширение подхода TDD к разработке и тестированию, при котором особое внимание уделяется поведению системы/модуля в терминах бизнеса (заказчика). Как правило, такие тесты иллюстрируют и тестируют различные сценарии, которые интересны непосредственно клиенту системы.

https://habr.com/ru/post/336030/

«Пирамида тестов» — метафора, которая означает группировку тестов программного обеспечения по разным уровням детализации. Она также даёт представление, сколько тестов должно быть в каждой из этих групп.

![44](https://user-images.githubusercontent.com/80325645/121665800-41639700-cab1-11eb-85ff-ed4d46928420.jpg)

Оригинальная пирамида тестов Майка Кона состоит из трёх уровней (снизу вверх):

- Юнит-тесты.
- Сервисные тесты.
- Тесты пользовательского интерфейса.

### Рекомендуемые инструменты

Jest — исполнитель тестов на JavaScript, который позволяет взаимодействовать с DOM через jsdom. Несмотря на то, что jsdom только приблизительно реализует работу браузера, в большинстве случаев этого достаточно для тестирования React-компонентов. Jest предлагает отличную скорость итераций вместе с мощными возможностями, например фиктивные модули и таймеры, которые дают больше контроля над исполнением кода.

React Testing Library — это набор вспомогательных функций, позволяющий тестировать React-компоненты не полагаясь на их внутреннюю реализацию. Такой подход упрощает рефакторинг, а также подталкивает вас применять лучшие практики по улучшению доступности. Несмотря на то, что библиотека не позволяет делать «поверхностный» рендер компонента без дочерних компонентов, исполнители тестов, например, Jest позволяет это сделать через фиктивные модули.

  **[⬆ Наверх](#top)**

12. ### <a name="12"></a> Оценка скорости приложения - Google Lighthouse

Google Lighthouse — это инструмент аудита с открытым исходным кодом, который помогает разработчикам повысить производительность и доступность своих веб-проектов. Любой желающий может использовать его бесплатно, чтобы увидеть, как его веб-сайт соответствует высоким стандартам Google в веб разработке.

Lighthouse расскажет вам, насколько ваш веб-сайт соответствует стандартам Google. В отчете будут объяснены сильные и слабые стороны вашего сайта, а также предложены способы повысить его оценку.

https://webdevblog.ru/ispolzovanie-google-lighthouse-dlya-audita-veb-prilozhenij/

  **[⬆ Наверх](#top)**

13. ### <a name="13"></a> Основные модели SDLC

Жизненный цикл разработки программного обеспечения — это методология, которая описывает, как вам следует подходить к разработке программного обеспечения. Этот процесс гарантирует, что вы создаёте программное обеспечение в правильном порядке, и помогает сделать разработку более эффективной.

*Как работает SDLC?*

Жизненный цикл разработки программного обеспечения состоит из семи этапов, описывающих, как следует разрабатывать программный проект. Хотя у каждого есть своё имя для каждой стадии SDLC, вот основные темы, которые вы увидите на протяжении жизненного цикла:

- Анализ и планирование.
- Дизайн.
- Развитие.
- Тестирование.
- Развёртывание.
- Обслуживание и оценка.


### Этап 1: Анализ и планирование

Прежде чем вы сможете разработать проект или создать для него функцию, вам сначала нужно знать, что вы собираетесь построить. Какие особенности должен иметь проект? Каких функций у него не должно быть
 
Хотя многие люди рассматривают разработку программного обеспечения как простое кодирование, на самом деле это гораздо больше, чем просто ввод кода. Вам нужно будет определить объём и границы проекта, прежде чем вы начнёте писать код. Здесь вы поймёте, что вы собираетесь построить и почему.

Читайте также:  Ansible или Puppet: какой из клиентских серверов с открытым исходным кодом лучший?
На этапе анализа и планирования вы будете работать со всеми заинтересованными сторонами проекта — от руководителей до других разработчиков и клиентов — чтобы обеспечить разработку соответствующих спецификаций проекта. Вам необходимо убедиться, что проект соответствует не только ожиданиям клиентов, но и целям вашего собственного бизнеса.


### Этап 2: Дизайн

Итак, у вас есть план того, что вы хотите построить. Теперь вы должны спросить себя: как мы выполним этот план? Как мы собираемся создавать выявленные нами особенности?

Следующим этапом SDLC является этап проектирования. Именно здесь вы будете решать, как должны быть реализованы функции. Работая со всеми заинтересованными сторонами, чтобы ваши планы соответствовали их потребностям.

Работа с другими важна на каждом этапе SDLC, но особенно на этапе проектирования. Вы можете понять, что вам нужно создать, но, если вы не получите мнение всех заинтересованных сторон, ваш дизайн может не соответствовать всем требованиям.


### Этап 3: Разработка

После планирования и проектирования вы готовы приступить к разработке. Здесь вы откроете терминал и текстовый редактор, чтобы начать работу над проектом. Вы потратите много времени на создание всех функций, согласованных в ходе предыдущих обсуждений.

Разработка — это не только написание кода. На этом этапе вам необходимо встретиться с другими разработчиками, чтобы распределить работу и обсудить, кто лучше всего подходит для решения конкретных проблем. Скорее всего, вы разработаете процесс, который поможет вам эффективно писать код в команде.


### Этап 4: Тестирование

Вы сделали тяжёлую работу, и функции, необходимые для создания, готовы, но вы ещё не закончили. Что делать, если ваш код содержит ошибки? Или что, если ваш проект не работает в данном пограничном случае?
 
Здесь вступает в игру фаза тестирования. Вам нужно будет определить, какие проблемы существуют в вашем коде, и создать решения этих проблем, чтобы конечный продукт соответствовал спецификациям, изложенным на этапе анализа.


### Этап 5: Развёртывание

Готовый продукт готов. Вы протестировали код и убедились, что конечный продукт соответствует всем исходным спецификациям. Теперь вы готовы начать развёртывание проекта.
 
Здесь вы перенесёте разработанное вами программное обеспечение из среды тестирования в рабочую среду. Например, с помощью веб-приложения вы можете переместить свой код на работающий веб-сервер, на котором размещён ваш веб-сайт; с игрой вы можете опубликовать свой код в игровом магазине.


### Этап 6: Обслуживание и оценка

Хотя планирование является важной частью SDLC, вы обнаружите, что потребности проекта со временем изменятся. Возможно, пользователи просят добавить другую функцию или обновить библиотеки, чтобы продукт по-прежнему работал с использованием новейших инструментов.

После публикации проекта вы будете отвечать за его поддержку. Часто разработчики используют инструменты мониторинга производительности приложений, чтобы убедиться, что их код работает эффективно. Если разработчики не поддерживают свои приложения, они могут стать нестабильными и перестать соответствовать исходным требованиям проекта. Это вредно для деловых отношений.


*Методология разработки программного обеспечения (SDLC)* представляет собой последовательность действий, которые необходимо выполнить, чтобы получить готовое решение. Проще говоря, это способ создания программного продукта. Проблема в том, что существует множество моделей SDLC, которые используются для разных типов проектов. 

### Каскадная модель (waterfall)

Это линейная и последовательная модель разработки программного обеспечения, в которой фазы проекта следуют одна за другой и включают:

- Исследование. Группа разработчиков собирает требования к проекту и включает их в документ «Спецификации требований к программному обеспечению» (SRS).
- Дизайн. Команда анализирует все требования и выкатывает прототип системы.
- Кодирование. Как только заинтересованные стороны проекта согласовывают прототип, начинается фаза написания кода.
- Тестирование. Команда QA запускает каждый модуль через различные сценарии тестирования и интегрирует их в систему. Как только все компоненты на месте, они тестируют систему целиком.
- Развертывание. Решение доставляется заказчику в полностью рабочем состоянии.
- Обслуживание. Команда разработчиков следит за проектом и при необходимости вносит обновления.

*Каким проектам подходит*

Каскадная модель – хороший вариант, если выполняются эти условия:

- Проект короткий и с нулевым риском.
- Требования фиксированные.
- Технологии стабильны.
- Доступны все необходимые ресурсы.


### V-образная модель SDLC

V-образная модель – это своего рода другая версия каскада, но в её основе лежит контроль качества каждой фазы. Например, когда группа разработчиков собирает требования к проекту, QA-специалисты пишут приемочные тесты на основе этих сценариев.

*Каким проектам подходит*

V-образная модель может быть чрезвычайно полезна в случаях, когда ошибки могут быть фатальными, и в проектах, где точность имеет решающее значение. Например, это решение, основанное на нормативных требованиях, таких как подача налоговых деклараций. Кроме того, эта модель подходит для проектов в сфере здравоохранения.


### Модель эволюционного прототипирования

Это ещё одна вариация каскада. Пока проект проходит через традиционные фазы, прототип продукта пошагово дорабатывается на основе отзывов клиентов. Как правило, первый прототип не проходит приемочный тест, поэтому модель прототипирования включает в себя несколько прототипов.

*Каким проектам подходит*

Модель эволюционного прототипирования может быть полезна для проектов, которые предполагают взаимодействие с пользователем, используют новые технологии, имеют сложную функциональность или должны учитывать быстро меняющиеся требования, которые трудно или невозможно предсказать.


### Итеративная и инкрементальная модель

В инкрементальной и итеративной модели решение разрабатывается небольшими частями через серию циклов. Рабочий процесс выглядит следующим образом:

- Планирование. Собираются все требования к проекту и делятся на составляющие.
- Реализация модулей. Каждая итерация представляет собой «мини-каскад», который имеет такой же процесс: анализ требований модуля, проектирование, реализация и тестирование модулей, интеграция и тестирование всей системы, выпуск версии и оценка. Процесс повторяется до тех пор, пока не будут выполнены все требования.

*Каким проектам подходит*

Модель будет эффективна в следующих случаях:

- Если система состоит из нескольких сегментов с чёткими требованиями.
- Ограниченные ресурсы на проекте или есть ограничения по времени выхода решения на рынок.
- Для стартапов, проходящих инвестиционные раунды.
- Масштабные проекты.
- Проекты, в основе которых новые технологии.
- Проекты, которые потребуется развивать после выпуска.


### Спиральная модель

Этот подход основан на оценке риска, он сочетает в себе функции каскадной, прототипной, итеративной и инкрементной моделей. Модель похожа на спираль с несколькими кругами. Каждый круг – это фаза, состоящая из четырёх элементов:

- Сбор требований. Он включает выявление и анализ потребностей заинтересованных сторон и бизнес-целей.
- Анализ рисков и прототипирование. Команда оценивает все возможные способы удовлетворения потребностей клиентов и выбирает лучшее решение. Затем они выявляют и устраняют риски, связанные с решением, и создают прототип, который развивается с каждым последующим циклом.
- Инжиниринг. Команда инженеров продолжает разработку и тестирование того, что было запланировано на двух предыдущих этапах.
- Планирование следующего этапа. Готовый продукт отправляется заказчику для получения обратной связи. Кроме того, команда разработчиков анализирует весь цикл с точки зрения расписания, бюджета и других критериев.

*Каким проектам подходит*

Спиральная модель подходит для:

- Больших, сложных продуктов, состоящих из нескольких компонентов.
- Проектов с частыми релизами.
- Проектов средней и высокой степени риска.
- Проектов с неясными требованиями.


### Модели гибкой разработки программного обеспечения

Вопреки распространённому мнению Agile не является ни структурой, ни методологией. Это философия с набором принципов, ориентированных на ускорение процесса разработки программного обеспечения, обеспечение 100% удовлетворённости клиентов и предоставление высококачественных решений в быстро меняющейся среде. Фактически, существует 12 принципов гибкой разработки, которые сводятся к следующим ценностям:

- Люди и взаимодействие важнее процессов и инструментов.
- Рабочее программное обеспечение над обширной документацией.
- Сотрудничество с клиентами вместо переговоров по контракту.
- Реагирование на изменения вместо следования плану.


### Scrum

Скрам-проекты разбиты на спринты. Спринт – это небольшой объём работы, который необходимо выполнить в течение определённого периода времени. Обычно заказчику доставляется часть проекта, которая была завершена во время спринта (инкремент продукта, от англ. increment). Скрам подразумевает активное общение и сотрудничество между всеми участниками проекта. Наряду с ежедневными 15-минутными встречами разработчиков, есть также:

- Планирование спринта, когда заинтересованные стороны проекта и команда разработчиков встречаются, чтобы обсудить, что нужно сделать во время следующего спринта.
- Обзор спринта, когда команда разработчиков демонстрирует заинтересованным сторонам, что было сделано во время спринта, и анализируется прогресс в достижении цели проекта.
- Ретроспектива спринта, когда команда разработчиков анализирует спринт и обсуждает, как можно улучшить процессы во время следующих спринтов.

Сердце процессов Scrum – это backlog, своего рода список задач, которые необходимо сделать для завершения проекта. По мере того, как проект продвигается, и команда узнаёт о нём больше, они редактируют бэклог продукта, добавляя, удаляя и переупорядочивая его элементы. Тем не менее, нельзя сделать что-то, если этого нет в очереди продукта.


  **[⬆ Наверх](#top)**

14. ### <a name="14"></a> Предоставление оценок усилий, необходимых для выполнения задач на основе заданной WBS

Структурной декомпозицией работ (Work Breakdown Structure) называют представление проекта, исполненное в виде иерархической структуры работ, что достигается посредством последовательной декомпозиции. Инструмент направлен на детальное планирование, оценку стоимости, определение и распределение персональной ответственности исполнителей и т. д. – то есть, на основные работы и результаты, определяющие содержание проекта

Декомпозиция — разделение на части или категории, выделение простых составляющих.

### Зачем нужна WBS

WBS – крайне полезная вещь в планировании проекта и вот почему:

- WBS – если не единственный, но точно самый эффективный способ наглядно отразить весь объем проекта.
- WBS фокусирует внимание не на процессе а на ожидаемом результате, и создает нужный «посыл».
- В идеале в разработке WBS участвует заказчик или его представитель и вся команда, что позволяет а) обеспечить единое понимание результатов проекта и его объема б) увидеть важность и вклад отдельных элементов в общий результат
- С помощью WBS можно наглядно обосновать необходимости в финансах или человеческих ресурсах, так как против конкретного описанного объема возражать гораздо сложнее, чем против «да что там системку написать, посадите программиста и все».
- WBS помогает предотвратить риски и изменения или по крайней мере значительно (очень значительно!) снизить их вероятность и влияние, так как именно здесь всплывут многие неочевидные ранее вещи и «а мы хотели совсем другое» (и так и должно быть, для этого инструмент и предназначен).
- На уровне WBS уже можно определить и согласовать контрольные точки проекта (как для решений о продолжении проекта после очередного этапа, так и для контроля затрат человеческих и финансовых ресурсов).

  **[⬆ Наверх](#top)**


17. ### <a name="17"></a> Что такое реактивное программирование? Основные кирпичи (поток, наблюдаемый, подписка)

### Реактивное программирование — программирование с асинхронными потоками данных

Для чего нужно реактивное программирование
Реактивный подход повышает уровень абстракции вашего кода и вы можете сконцентрироваться на взаимосвязи событий, которые определяют бизнес-логику, вместо того, чтобы постоянно поддерживать код с большим количеством деталей реализации. Код в реактивном программировании, вероятно, будет короче.

Преимущество более заметно в современных веб- и мобильных приложениях, которые работают с большим количеством разнообразных UI-событий.

Впрочем, ничего нового. Event bus’ы или обычные события клика — это тоже асинхронные потоки данных, которые вы можете прослушивать, чтобы реагировать какими-либо действиями. Реактивность — это та же самая идея, возведенная в абсолют. Вы можете создавать потоки данных не только из событий наведения или кликания мышью. Потоком может быть что угодно: переменные, пользовательский ввод, свойства, кэш, структуры данных и т.п. Например, представьте, что ваша лента новостей в Твиттере — поток событий. Вы можете слушать этот поток и реагировать на события соответственно.

Кроме этого, вы получаете удивительный набор функций для комбинирования, создания и фильтрации этих потоков. Вот где проявляется вся магия этого подхода. Один или несколько потоков могут использоваться как входные данные для другого потока. Вы можете объединять два потока. Также вы можете фильтровать поток, выбирая только те события, которые вам интересны.

Так как потоки — основопологающая вещь в реактивном подходе, давайте рассмотрим их подробнее на примере пользовательского клика мышью

### Поток
Поток — это последовательность событий, упорядоченная по времени. Он может выбрасывать три типа данных: значение (определенного типа), ошибку или сигнал завершения. Сигнал завершения распространяется, когда текущее окно или окно, содержащее кнопку, закрывается.

  **[⬆ Наверх](#top)**

18. ### <a name="18"></a> gulp / grunt, webpack, bazel

### Gulp

Gulp - это инструмент для автоматизации рутинных задач, которые возникают при веб-разработке. Это может быть не только frontend разработка, это может быть и backend разработка.

Если вы работаете с такими технологиями как html,  css, javascript и.т.д. Если вы внедрите в практику своей работы такой инструмент как gulp, вы значительно ускорите скорость вашей работы и, во вторых, этот инструмент "откроет вам дорогу" к новым возможностям, которые значительно повысят ваш уровень веб-разработки и знаний.

Gulp - это просто программа, которая написана на языке программирования Javascript. Для того, чтобы начать его пользоваться, желательно знать, хотя бы основы языка Javascript. Если вы это знаете, то пользоваться программой Gulp для вас будет намного проще. 

Смысл следующий: мы создаем для системы Gulp некие задания. Т.е. описываем эти задания на языке Javascript. Затем, Gulp просто выполняет эти задания в нужной последовательности, так, как мы это прописали. Т.е. Gulp - это просто система по управлению заданиями по веб-разработке. Также ее называют task manager. task - задание, manager - управлять.

Важно понимать, что Gulp - это просто некое ядро, к которому мы прикручиваем дополнительные модули, плагины, которые "учат" Gulp делать какую-то определенную функцию или работу. Устанавливая эти плагины мы получаем новые возможности в системе Gulp, которые мы можем использовать. 

*Список этих задач может быть достаточно большой.*

*Задача 1.* Минификация кода.

Это одна из самых частых задач, для которой чаще всего используют Gulp и подобные ей системы - это задача минификации кода. Т.е. вы написали какой-то код, на каком-то языке программирования. Для вас этот код воспринимается хорошо, но, если вы разместите этот код на рабочем сервере, на котором будет размещаться ваш сайт, то, соответственно, этот код будет загружаться довольно долго из-за того, что в нем есть много лишней информации в виде отступов, комментариев и.т.д. 

Gulp позволяет убрать все лишнее из кода, подготовить его для того, чтобы это можно было выложить на рабочий сервер.   

*Задача 2.* Объединение кода из разных файлов в один.

Вы можете объединять код из CSS, Javascript файлов и.т.д. в один. Это важно сделать также по причине скорости загрузки документа. При работе с протоколом http каждый запрос к файлу - это дополнительное время загрузки страницы.

Если вы объединяете код в один файл, загрузить его проще и быстрее, чем загрузить несколько файлов. 

Это типовая задача, которую приходится решать в современной веб-разработке. Написать программу намного проще, если ее код разбит на модули и независимые части. 

*Задача 3.* Работа с CSS препроцессорами: sass, less, …

Система Gulp позволяет вам использовать их в своей работе и вы получите такой мощный инструмент для того, чтобы улучшить свои навыки веб-разработки.

*Задача 4.* Поддержка новых стандартов языка Javascript.

Т.к. язык Javascript является клиентским языком программирования, то он зависит того браузера, на котором будет работать. Если посетитель вашего сайта пользуется какими-то старыми браузерами, у него новые стандарты не будут работать. С помощью Gulp вы можете решить эту задачу. 

Gulp - это не единственный инструмент, который позволяет решать такие подобные задачи. Важно понимать, что Gulp - это одно из самых простых и легких решений, которые позволяют это сделать.


### Сходства Grunt и Gulp

Grunt и Gulp автоматизируют рутинные задачи разработчика, такие как:

- минификация кода
- анализ качества кода
- оптимизация изображений
- добавление вендорных (браузерных) префиксов
- тестирование

Если в процессе разработки у вас есть задачи повторяющиеся много раз, скорее всего вы сможете их автоматизировать с помощью Grunt или Gulp.
Как сборщик выполняет задачи? Просто. Вы пишите инструкции, которые говорят сборщику, что делать:

- какие файлы использовать
- что делать с этими файлами (минимизировать, конкатенировать, анализировать на ошибки и т.д.)
- куда поместить обработанные файлы
- 
На первый взгляд Grunt и Gulp очень похожи.
Используя любой из этих сборщиков, вы автоматизируете процесс веб-разработки.
В более широком смысле, Grunt и Gulp идентичны тем, что:

- оба автоматизируют процесс разработки
- мы пишем задачи используя javascript
- оба сборщика требуют для работы Nodejs и npm

На этом сходство заканчивается. Способ выполнения задач различен.

`Различия между Grunt и Gulp`

Есть два главных различия между Grunt и Gulp:

- Как настраиваются задачи. Grunt основан на конфигурации. Gulp на потоке.
- Как запускаются задачи. Grunt запускает задачи последовательно. Gulp пытается запустить задачи параллельно.

`Разница в конфигурации задач`

Синтаксис Gulp более краток, чем Grunt. Самое замечательное, что Gulp потоковая система сборки. Для описания задач в Gulp требуется писать гораздо меньше кода.

`Выполнение задач`

*Как Grunt выполняет задачи*

Для выполнения каждого процесса в задаче, Grunt необходимо:

- Открыть необходимый файл
- Запустить текущий процесс
- Сохранить изменения
- Закрыть текущий обработанный файл, чтобы следующий процесс мог получить к нему доступ

*Как выполняет задачи Gulp*

Gulp не требует создания временных файлов между процессами. Файл, после выполнения текущего процесса, сразу передается следующему процесса, не тратя время на сохранение файла.
Gulp использует Orchestrator, который помогает запускать процессы максимально параллельно. Это значит, что Gulp пытается выполнить все задачи одновременно. Теоретически,это позволяет Gulp выполнять задачи быстрее.


### webpack

Вебпак — это сборщик модулей. Он анализирует модули приложения, создает граф зависимостей, затем собирает модули в правильном порядке в один или более бандл (bundle), на который может ссылаться файл «index.html».

`Какие проблемы решает вебпак?`

Обычно, при создании приложения на JavaScript, код разделяется на несколько частей (модулей). Затем в файле «index.html» необходимо указать ссылку на каждый скрипт.

Это не только утомительно, но и подвержено ошибкам. Важно не только не забыть про какой-нибудь скрипт, но и расположить их в правильном порядке. Если загрузить скрипт, зависящий от React, до загрузки самого React, приложение сломается. Вебпак решает эти задачи. Не нужно беспокоиться о последовательном включении всех скриптов.

Как мы скоро узнаем, сбор модулей является лишь одним из аспектов работы вебпака. При необходимости можно заставить вебпак осуществить некоторые преобразования модулей перед их добавлением в бандл. Например, преобразование SASS/LESS в обычный CSS, или современного JavaScript в ES5 для старых браузеров.

*Он также способен выполнять множество иных операций:*

- помогает собрать воедино ваши ресурсы
- следит за изменениями и повторно выполняет задачи
- может выполнить транспиляцию JavaScript следующего поколения до более старого стандарта JavaScript (ES5) с помощью Babel, что позволит использовать новейшие функции JavaScript, не беспокоясь о том, поддерживает их браузер или нет
- может выполнить транспиляцию CoffeeScript в JavaScript
- может конвертировать встроенные изображения в data:URI
- позволяет использовать require() для CSS файлов
- может запустить webpack-dev-server (в нём встроен локальный сервер и livereload (“живая перезагрузка браузера”))
- может работать с Hot Module Replacement (замена горячего модуля)
- может разделить выходной файл (output file) на несколько файлов, чтобы избежать медленной загрузки страницы из-за большого размера JS-файла
- может выполнить Tree Shaking

Webpack не ограничивается одним лишь фронтендом, его также успешно применяют в бэкенд разработке на Node.js.

### bazel

Bazel - это подмножество внутренней системы сборки Google под названием Blaze. Таким образом, Bazel развился, чтобы решить очень большую проблему, которая является несколько (но, возможно, не полностью) уникальной для Google:

- Конфигурационные файлы Bazel гораздо более структурированы, чем Gradles, что позволяет Bazel точно понимать, что делает каждое действие. Это учитывает больший параллелизм и лучшую воспроизводимость.

Файлы сборки Bazel

Bazel работает с двумя конфигурационными файлами: BUILD и WORKSPACE

*Вещи, которые Bazel действительно хорошо включает в себя:*

- бит для воспроизводимости бит. Это ОТЛИЧНО.
- Технология независимой внутрипакетной сборки. У вас есть Python, который зависит от кода C? Какая-то Java, которая требует JavaScript для внешнего интерфейса? Bazel может сделать это, и это одна из немногих систем с открытым исходным кодом, которая может это сделать.
- Благодаря своей воспроизводимости, Bazel может кэшировать результаты сборки и восстанавливать только то, что нужно. Это делает это быстро.
- Базель ГИБКИЙ. У него есть собственный язык доменов, поэтому вы можете расширять его для поддержки всего, что вам нужно, независимо от того, слышали ли об этом создатели. Хотите "собрать" (проверить и проверить синтаксис) Javascript? Java? C? C++? Цель C? Fortran? Brainfuck? НЕТ ПРОБЛЕМ. Если он еще не реализован, вы можете реализовать его. Если вам не нравится, как это работает, вы можете написать свой собственный. Хотите использовать собственный компилятор? Пользовательская статическая проверка? Пользовательский тестовый комплект? Нет проблем. Мир это твоя устрица.

*Плохо о базель*

Базель - это не настоящее управление зависимостями. Он управляет тем, КАКИЕ ваши зависимости, но не какие версии использовать. Если у вас все в вашем дереве зависимостей проверено в одном большом монолитном репозитории кода (как это делает Google с их форком производительности), то это просто прекрасно. "Путь Google" состоит в том, чтобы все строить на чаевых все время и никогда не зависеть от более старых версий.


  **[⬆ Наверх](#top)**

19. ### <a name="19"></a> Хранение паролей и возможности хеширования. Разница между хешем и hmac

hash - это функция, которая создает дайджест из сообщения. Криптографически защищенный hash-это тот, для которого вычислительно невозможно сгенерировать сообщение с заданным дайджестом. Сам по себе hash сообщения не дает никакой информации об отправителе данного сообщения. Если вы можете безопасно передать hash сообщения, то его можно использовать для проверки правильности получения большого сообщения по незащищенному транспорту.

Код аутентификации сообщения-это способ объединения общего секретного ключа с сообщением, чтобы получатель сообщения мог подтвердить, что у отправителя сообщения есть общий секретный ключ, и никто, кто не знает секретного ключа, не мог отправить или изменить сообщение.

HMAC-это код аутентификации сообщения на основе hash. Обычно это включает в себя применение функции hash один или несколько раз к какой-либо комбинации общего секрета и сообщения. HMAC обычно относится к алгоритму, задокументированному в RFC 2104 или FIPS-198.

MAC не шифрует сообщение, поэтому оно находится в виде обычного текста. Он не раскрывает секретный ключ, поэтому MAC может быть отправлен по открытому каналу без ущерба для ключа.

### Разница между хешем и hmac

Основное различие заключается в концептуальности: в то время как хэши используются для гарантии целостности данных, MAC гарантирует аутентификацию AND целостности.

Это означает, что хэш-код слепо генерируется из сообщения без какого-либо внешнего ввода: то, что вы получаете, - это то, что можно использовать для проверки того, изменилось ли сообщение во время его перемещения.

Вместо этого MAC использует закрытый ключ в качестве исходного кода для функции hash, которую он использует при генерации кода: это должно гарантировать получателю, что не только сообщение не было изменено, но и кто его отправил, это то, что мы ожидали: в противном случае злоумышленник не мог знать закрытый ключ, используемый для генерации кода.

Согласно Википедии у вас есть это:

Хотя функции MAC аналогичны криптографическим функциям hash, они обладают различными требованиями к безопасности. Чтобы считаться безопасной, функция MAC должна противостоять экзистенциальной подделке при атаках с открытым текстом. Это означает, что даже если злоумышленник имеет доступ к oracle, который обладает секретным ключом и генерирует MACs для сообщений по выбору злоумышленника, злоумышленник не может угадать MAC для других сообщений, не выполнив неосуществимые объемы вычислений.
Конечно, несмотря на их сходство, они реализованы по-разному: обычно алгоритм генерации MAC основан на алгоритме генерации кода hash с расширением, которое заботится об использовании закрытого ключа.

  **[⬆ Наверх](#top)**

20. ### <a name="20"></a> Атаки на формы и URL-адреса (CSRF, XSS, проблема с семантическими URL-адресами. Фильтрация входных данных)

### CSRF

CSRF (межсайтовая подделка запросов) — это вид атаки на сайт, которая производится с помощью мошеннического сайта или скрипта, который заставляет браузер пользователя выполнить нежелательное действие на доверенном сайте, на котором пользователь авторизован.

Обычно для этого пользователь должен перейти по мошеннической ссылке (которая может быть изменена с помощью сокращателя ссылок).

Методы POST, PUT, DELETE и PATCH должны быть защищены от CSRF.

*Как работает межсайтовая подделка запросов?*

Для того, чтобы злоумышленник осуществил атаку CSRF, нужны определённые условия:

- В приложении есть действие, которое злоумышленник хочет предпринять – например, изменить пароль, перевести средства и так далее.
- Не существует непредсказуемых параметров запроса – злоумышленник может угадать (или знать) все параметры, которые приложение ожидает увидеть из этого типа запроса.
- Действие может быть выполнено с помощью HTTP-запросов, и оно полагается только на файлы cookie, чтобы убедиться, что запрос исходит от пользователя.

CSRF могут быть подвергнуты веб-приложения использующие cookies, браузерную аутентификацию или клиентские сертификаты авторизации. По сути, CSRF подвержены все веб-приложения, которые автоматически добавляют аутентификационные данные пользователя к запросу.

Либо нужно начать с того, что злоумышленник обманом заставит жертву загрузить или отправить информацию в веб-приложение. Это может произойти несколькими способами – например, через фишинговую ссылку.

Эксплойт может быть замаскирован под обычную ссылку или скрыт в теге изображения.

Вот пример атаки через обычную ссылку:
```js
<a href=“вредоносная ссылка”>Unsubscribe here</a>

Или через тэг изображения:

<img src=“вредоносная ссылка” width=“0” height=“0” border=“0”>
```

`Итого`
- CSRF-атака – это когда «злая страница» отправляет форму или запрос на сайт, где посетитель, предположительно, залогинен.
- Если сайт проверяет только куки, то он такую форму принимает. А делать это не следует, так как её сгенерировал злой хакер.
- Для защиты от атаки формы, которые генерирует mail.com, подписываются специальным токеном. Можно подписывать не все формы, а только те, которые осуществляют действия от имени посетителя, то есть могут служить объектом атаки.
- Для подписи XMLHttpRequest токен дополнительно записывается в куку. Тогда JavaScript с домена mail.com сможет прочитать её и добавить в заголовок, а сервер – проверить, что заголовок есть и содержит корректный токен.
- Динамически сгенерированные формы подписываются аналогично: токен из куки добавляется как URL-параметр или дополнительное поле.


### XSS

XSS (англ. Cross-Site Scripting — «межсайтовый скриптинг») — довольно распространенная уязвимость, которую можно обнаружить на множестве веб-приложений. Ее суть довольно проста, злоумышленнику удается внедрить на страницу JavaScript-код, который не был предусмотрен разработчиками. Этот код будет выполняться каждый раз, когда жертвы (обычные пользователи) будут заходить на страницу приложения, куда этот код был добавлен. А дальше существует несколько сценариев развития.

`Как происходит атака межсайтового скриптинга?`
Веб-сайты хранят данные и постоянно отправляют информацию вашему браузеру: атаки межсайтового скриптинга происходят, когда ненадежные источники отправляют пользователям вредоносное содержимое посредством уязвимостей в веб-сайтах с целью кражи персональных данных или нанесения ущерба вашему компьютеру. Например: когда пользователь ищет что-то онлайн, веб-сайт отправляет браузеру данные в форме поисковой выдачи. При атаках типа XSS передаваемая информация содержит вредоносный код и может помочь злоумышленниках украсть персональные данные пользователя. По причине того, что практически каждый веб-сайт хранит и отправляет данные браузерам, межсайтовый скриптинг на сегодняшний день представляет наиболее распространенную уязвимость программного обеспечения.


  **[⬆ Наверх](#top)**

21. ### <a name="21"></a> Понимание концепции рефакторинга

Рефакторинг — это контролируемый процесс улучшения
кода, без написания новой функциональности. Результат
рефакторинга — это чистый код и простой дизайн.

*Правило трёх*
1. Делая что-то в первый раз, вы просто это делаете.
2. Делая что-то аналогичное во второй раз, вы морщитесь от необходимости повторения, но все-таки повторяете то же самое.
3. Делая что-то похожее в третий раз, вы начинаете рефакторинг.

Рефакторинг следует проводить серией небольших изменений, каждое из которых делает существующий код чуть лучше, оставляя программу в рабочем состоянии.

Чистый код — это код, который просто
читать, понимать и поддерживать. Чистый
код улучшает предсказуемость
разработки и повышает
качество продукта.


Грязный код является не только
результатом лени и невежества,
но и побочным продуктом
частых изменений в
процессе разработки.

  **[⬆ Наверх](#top)**

22. ### <a name="22"></a> Основные понятия: Test Plan, Test Suite, Test Case. Концепции различных типов тестов: Единичный / Интеграционный / Функциональный. Основы работы с JS Unit

### Test Plan

Тест-план (Testplan, план тестирования) – это документ, описывающий весь объем работ по тестированию, начиная с описания тестируемых объектов, стратегии, расписания, критериев начала и окончания тестирования, до необходимого в процессе работы оборудования, специальных знаний, а также оценки рисков с вариантами их разрешения.

Как мы можем лицезреть, тест-план является важной составляющей любого грамотно-организованного процесса тестирования, так как содержит в себе всю необходимую информацию, описывающую данный процесс. Но в большинстве случаев, с которыми нам придется столкнуться, тест-план будет играть более формальную роль, но, все же, его присутствие имеет много преимуществ. Например:

- Возможность приоритезации задач по тестированию.
- Построение стратегии тестирование, согласованной со всей командой.
- Возможность вести учет всех требуемых ресурсов, как технических, так и человеческих.
- Планирование использования ресурсов на тестирование.
- Просчет рисков, возможных при проведении тестирования.

В зависимости от конкретизации описываемых задач, тест-план может иметь два уровня детализации: мастер тест-план и детальный тест-план.

Детальный тест-план содержит в себе задачи тестирования для каждой команды, для каждого релиза или итерации проекта.  Создается детальный тест-план либо для декомпозированной части проекта, либо для небольших проектов. Он может состоять из:

- Перечень областей тестирования с приоритетами.
- Стратегия тестирования.
- Перечень возможных рисков.
- Перечень необходимых ресурсов.
- План выполнения проекта.\


### Test Case

Test Case – это тестовый артефакт, суть которого заключается в выполнении некоторого количества действий и/или условий, необходимых для проверки определенной функциональности разрабатываемой программной системы.

Структура данного артефакта заключается в «троице»:

Выполняемое действие (Action) – Ожидаемый результат (Expected result) – Фактический результат (Test result).

Непосредственно сам тестовый случай состоит из 3 частей:

- PreConditions(Предусловия) – либо список шагов, которые приводят проверяемую систему в состояние, пригодное для тестирования, либо список проверок условий того, что система уже находиться в необходимом состоянии.
- Test Case Description(Описание тестового случая) – список действий, с помощью которых осуществляется основная проверка функционала (после которой и сверяется фактический результат с ожидаемым).
- PostConditions(Постусловия) –список действий, которые возвращают систему в исходное состояние.


### Test Suite

Тест Сьют это набор тест кейсов, которые объединены тем что относятся к одному тестируемому модулю, функциональности, приоритету или одному типу тестирования. Каждый тест сьют состоит из более чем одного тест кейса и зачастую выполняется всей «пачкой» в процессе тестирования.

Тест кейсы объединяют в тест сьюты для большего удобства при проходжении тест кейсов, проходя их последовательно от модуля к модулю, от одного типа тестирования к другому а не сумбурно, бросаясь из одного угла в угол, оставив не проверенным большую часть модуля или общей функциональности.


### Единичное тестирование

Единичные тесты – это автоматические тесты, которые проверяют, делает ли данный фрагмент кода то, что вы ожидаете от него, при определенных обстоятельствах. Хорошие модульные тесты проверяют небольшие функциональные возможности, часто на уровне отдельных функций.

### Интеграционное тестирование

Интеграционное тестирование является одним из наиболее распространенных и важных видов тестирования программного обеспечения. После того, как отдельные подразделения или компоненты будут проверены разработчиками как работающие, группа тестировщиков проведет тесты, которые проведут тестирование связи между этими единицами / компонентами или несколькими устройствами / компонентами. Существуют различные подходы к интеграционному тестированию, а именно: интеграционное тестирование сверху вниз, интеграционное тестирование снизу вверх и комбинация этих двух тестов Sand witch.


### Функциональное тестирование

Функциональное тестирование – формальный тип тестирования, выполняемый тестировщиками. Функциональное тестирование сосредоточено на тестировании программного обеспечения на основе документа о состоянии, случаев и требований. Функциональное тестирование является типом тестирования «черного ящика» и не требует знаний внутренней работы программного обеспечения, в отличие от тестирования «белого ящика».


### Основы работы с JS Unit

Unit-тесты — это код, позволяющий проверить на корректность отдельные модули исходного кода. Тесты пишутся для каждой нетривиальной функции.

Юнит-тест — это код, который тестирует юниты (части) кода: функции, модули или классы. ... Вся суть — подать что-то на вход юнита и

Преимущества юнит-тестирования очевидны:

- Являются низкоуровневым и фокусируется на маленькой части ПО
- Тесты пишут сами разработчики
- Тесты выполняются очень быстро, можно выполнять тесты несколько раз в минуту
- При разработке можно выполнять не все тесты, а только те, которые необходимы именно вам

Таким образом, при использовании юнит тестирования скорость разработки существенно не уменьшается, но при этом возрастает качество самого продукта.

Важное различия в юнит тестировании, это какой тип тестирования вы выберите: Solitary (одинокий) и Sociable (общительный) тест.

*Sociable* (общительный) тест — это тест который использует реальные методы (или классы), которые входят в тестируемую единицу. Например, вы тестируете метод «цена» из класса заказов. Методу «цена» необходимо вызвать методы из класса клиент и продукт. В данном виде тестов будут вызваны именно эти методы, и ошибка в этих методах приведет к ошибке теста. Методы из классов клиент и продукт называется партнеры (collaborators).

*Solitary* (одинокий) тест — это тест, который в качестве партнеров использует дубли (TestDouble). Тест-дубли — это общий термин для любого случая, в котором вы заменяете реальный объект, исключительно для целей тестирования.

  **[⬆ Наверх](#top)**

23. ### <a name="23"></a> Реализация ООП в JS

Объектно-ориентированное программирование (ООП) — это шаблон проектирования программного обеспечения, который позволяет решать задачи с точки зрения объектов и их взаимодействий.	
	
```js	
let str = 'some';
let strObj = new String(str);

console.log(typeof(str)); //string
console.log(typeof(strObj)); //jbject

console.dir([1, 2, 3]);


const soldier = {
  health: 400,
  armor: 100,
  sayHello: function() {
    console.log('Hello');
  }
};

const jonh = Object.create(soldier);
// тоже самое только современный вариант < =

// const jonh = {
//   health: 100
// };

// jonh.__proto__ = soldier;
// это устаревший вариант, он не используется, а вот тоже самое, только современный вариант =>

// Object.setPrototypeOf(jonh, soldier);

console.log(jonh);
console.log(jonh.armor);
jonh.sayHello();	
```	
	
Ключевое слово this

this - это объект, свойством которого является функция;
this - дает функциям доступ к своему объекту и его свойствам;
this - помогает выполнить один и тот же код для нескольких объектов;
this - можно рассматривать как кто меня вызвал?; т.е. то, что находится слева от точки. Например, window.a();
this - имеет динамическую область, т. е. не важно, где он был написан, важно, где он был вызван.

```jsx harmony
const obj = {
  name: 'Alex',
  sing() {
    console.log('a this ', this);
    var anotherFunc = function() {
      console.log('b this ', this);
    }
    anotherFunc();
  }
};

obj.sing();

// a this  {name: "Alex", sing: ƒ}
// b this  Window {parent: Window, postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, …}
```
```jsx harmony
var b = {
  name: 'jay',
  say() {
    console.log('this is ', this);
  }
}
b.say()
// this is  {name: "jay", say: ƒ}

var c = {
  name: 'jay',
  say() {
    return function () {
      console.log('this is ', this);
    }
  }
}
c.say()()
// this is  Window {parent: Window, postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, …}

var d = {
  name: 'jay',
  say() {
    // стрелочная функция не имеют собственного контекста выполнения.
    return () => console.log('this is ', this);
  }
}
d.say()()
// this is  {name: "jay", say: ƒ}
```

Стрелочные функции связывают this с лексической областью действия.
```jsx harmony
const obj = {
  name: 'Alex',
  sing() {
    console.log('a this ', this);
    var anotherFunc = () => {
      console.log('b this ', this);
    }
    anotherFunc();
  }
};

obj.sing();

// a this  {name: "Alex", sing: ƒ}
// b this  {name: "Alex", sing: ƒ}
```

Прототип

- Прототип (prototype) - это экземпляр рабочего объекта. Объекты наследуются напрямую от других объектов.
- __proto__ является ссылкой на свойство прототипа родительского объекта, например:
```jsx harmony
const obj = {};
obj.__proto__ === Object.prototype // true
```

- Свойство prototype принадлежит только функциям, в частности, функциям конструктора. Конструктор Object создает обертку объекта.
- Свойства proto и prototype используются для создания цепочки наследования свойств между объектами, начиная с Object и Primitive Types.
- Object.create() можно использовать для создания объектов с его свойством proto, связанным со свойством prototype объекта, переданного в качестве аргумента Object.create().
- Object - это базовая функция (конструктор). Корнем всего в JavaScript является Object, который на самом деле является функцией.
```jsx harmony
typeof Object // "function"
```jsx harmony
Object имеет свойство prototype, которое является базовым объектом для всех вещей в JavaScript, включая функции JavaScript.
```jsx harmony
typeof Object.prototype // "object"
```

ES6 Классы
- Ключевое слово class в JS - синтаксический сахар. Под капотом он всё еще использует прототипное наследование (prototypal inheritance).
- Экземпляры класса должны создаваться с ключевым словом new.
- Метод constructor используется для создания экземпляра state (данных) нового объекта. State обычно уникально для каждого экземпляра.
- Функции обычно не включаются в конструктор, так как они создают ссылку на место в памяти в каждом новом экземпляре класса. Таким образом используя больше памяти, чем необходимо. Включая функции в качестве методов класса, экземпляры класса могут ссылаться на функцию через цепочку прототипов.
- Прототипное наследование (prototypal inheritance) имеет лучшую эффективность памяти, чем классическое наследование, благодаря тому, что оно разделяет ссылки памяти своих свойств прототипа с теми объектами, которые наследуют от него. В классическом наследовании, экземпляры класса создают новые ссылки на память для каждого унаследованного свойства.

Object.create() vs. Classes

- Оба Object.create() и class являются способами создания цепочки прототипов.
- Некоторые люди предпочитают избегать ключевые слова constructor, class и this, чтобы ограничить путаницу из-за this.
- Другие предпочитают использовать ключевые слова constructor, class и this, возможно, из-за его сходства с другими языками с парадигмой объектно-ориентированного программирования.


Private vs. Public vs. Protected

Во многих объектно-ориентированных языках программирования, которые имеют классы, идея private и public полей действительно важна. В JavaScript этого нет. Ранее, если нужно было сделать поле private, к которому нельзя обращаться из класса, мы добавляли подчеркивание _ перед именем, чтобы другие программисты знали, что это private метод. Но, к сожалению, подчеркивание на самом деле ничего не делает.

В JavaScript есть предложение ECMAScript, которое предназначено для объявлений полей класса.

Это модификаторы доступа, которые помогают нам реализовать Encapsulation (или скрытие информации). Они сообщают компилятору, какие другие классы должны иметь доступ к определенному полю или методу.

Private - только текущий класс будет иметь доступ к полю или методу. Protected - только текущий класс и подклассы этого класса будут иметь доступ к полю или методу. Public - любой класс может ссылаться на поле или вызывать метод.

Так как в Javascript таких полей пока нет, для их реализации мы можем использовать TypeScript.

  **[⬆ Наверх](#top)**

24. ### <a name="24"></a> Принципы ООП

Объектно-ориентированное программирование (ООП) — это шаблон проектирования программного обеспечения, который позволяет решать задачи с точки зрения объектов и их взаимодействий.
	
Принципы ООП:
	
- Абстракция — отделение концепции от ее экземпляра;
- Полиморфизм — реализация задач одной и той же идеи разными способами;
- Наследование — способность объекта или класса базироваться на другом объекте или классе. Это главный механизм для повторного использования кода. Наследственное отношение классов четко определяет их иерархию;
- Инкапсуляция — размещение одного объекта или класса внутри другого для разграничения доступа к ним.

4 принципа ООП

`Инкапсуляция` - включает в себя идею о том, что данные объекта не должны быть напрямую доступны. Нужно вызывать методы вместо прямого доступа к данным. Инкапсуляция позволяет нам скрывать/показывать свойства функций.

ООП заключаем код в блоки, которые связаны друг с другом, чтобы эти блоки могли просто взаимодействовать друг с другом, используя методы и свойства, которые мы делаем доступными. Данный принцып делает код проще в обслуживании и более пригодным для повторного использования.

Инкапсуляция с использованием замыкания
```jsx harmony
const createCounter = () => {
  // Переменная, определенная в области действия фабрики или конструктора
  // является приватной для этой функции.
  let count = 0;

  return ({
    // Любые другие функции, определенные в той же области, являются привилегированными:
    // Они имеют доступ к закрытой переменной `count`
    // определенной в любом месте их цепочки областей видимости (содержащей области действия функции).
    click: () => count += 1,
    getCount: () => count.toLocaleString()
  });
};

const counter = createCounter();

counter.click();
counter.click();
counter.click();

console.log(counter.getCount()); // "3"
```

`Абстракция` - это способ создания простой модели, которая содержит только важные свойства с точки зрения контекста приложения, из более сложной модели. Иными словами - это способ скрыть детали реализации и показать пользователям только функциональность. Абстракция игнорирует нерелевантные детали и показывает только необходимые. Важно помнить, что мы не можем создать экземпляр абстрактного класса.

Всё программное обеспечение - это абстракция, скрывающая всю тяжелую работу и бездумные детали.

Многие программные процессы повторяются снова и снова. Поэтому, на этапе декомпозиции проблемы, мы удалим дублирование, записывая какой-либо компонент (функцию, модуль, класс и т. Д.), присваивая ему имя (идентификатор) и повторно используя его столько раз, сколько нам нужно.

Процесс декомпозиции - это процесс абстракции. Успешная абстракция подразумевает, что результатом является набор независимо полезных и перекомпонованных компонентов.

`Полиморфизмом` - является одним из принципов объектно-ориентированного программирования (ООП). Это помогает проектировать объекты таким образом, чтобы они могли совместно использовать или переопределять любое поведение с конкретными предоставленными объектами.

Само слово означает много форм. Существует много толкований того, что именно оно означает, но идея заключается в способности вызывать один и тот же метод для разных объектов, и при этом каждый объект реагирует по-своему.

Чтобы это произошло полиморфизм использует наследование.

В следующем примере дочерний объект, такой как Coder, переопределяет метод say, вызванный из родительского объекта Human, и возвращает новую строку соответственно. Тогда как другой дочерний объект Men, вместо переопределения метода say, наследует его и отображал родительскую строку.
```jsx harmony
class Human {
  constructor(name) {
    this.name = name;
  }

  say() {
    return `Hello, my name is ${this.name}, I like travelling`;
  }
}

class Men extends Human {
  constructor(name) {
    super(name)
  }
  // Берем метод say у родителя.
}

class Coder extends Human {
  constructor(name) {
    super(name)
  }

  say() {
    // Переопределяем метод родителя say для отображения нового значения.
    return `Hello, my name is ${this.name}, I like coding`;
  }
}

const alex = new Men('Alex');
const leo = new Coder('Leo');

alex.say() // "Hello, my name is Alex, I like travelling"
leo.say() // "Hello, my name is Leo, I like coding"
```

`Наследование` - это механизм базирования объекта или class на другом объекте (наследование на основе прототипа) или class (наследование на основе класса). Мы избегаем необходимости переписывать один и тот же код, а также экономим пространство памяти, используя общие методы.
```jsx harmony
class Human {
  constructor(name) {
    this.name = name;
  }

  sayMyName() {
    return 'Hello, I am ' + this.name;
  }
}

class Men extends Human {
  constructor(name) {
    super(name)
  }
}
class Coder extends Human {
  constructor(name) {
    super(name)
  }
}

const alex = new Men('Alex');
const leo = new Coder('Leo');

alex.sayMyName() // Hello, I am Alex
leo.sayMyName() // Hello, I am Leo
```
https://learn.javascript.ru/prototype-inheritance

  **[⬆ Наверх](#top)**

25. ### <a name="25"></a> Code small

Code Smells — это некий набор общих признаков, которые указывают на то, что код недостаточно хорош, и для его чистоты потребуется рефакторинг.

- Дублированный код и логика
- Длинные методы и классы
- Дублирующие методы в тех же или разных классах
- Расходящиеся модификации класса
Если вы хоть раз читали о принципах SOLID (особенно о единственной ответственности), то должны знать, что в одном классе должна существовать только одна причина для изменения кода. То есть, в классе User не должно быть функции, связанных с продуктами или преобразованием файла. Этот code smell можно легко исправить извлечением постороннего метода в новый класс, например, в класс Product или FileSystem.
- Стрельба дробью
Стрельба дробью — антипаттерн в разработке ПО (прим. переводчика) и это полная противоположность расходящимся модификациям. В данном случае, вы будете менять множество классов по единой причине. То есть для применения какого-либо действия всем этим классам потребуется одна и та же причина изменения. Например, вам нужно создать новое правило пользователя «Суперадминистратор», после чего вы должны будете отредактировать ряд методов в классах Profile, Products и Employees. В таком случае призадумайтесь о том, чтобы сгруппировать эти методы в один единый класс, чтобы этот новый класс имел единую причину изменения.
- Завистливая функция
Иногда в своем классе вы находите метод, который активно пользуется другим классом. В таком случае стоит переместить этот метод в тот самый используемый класс. Посмотрите на картинку ниже. Разве не логично будет перенести getFullAddress() из класса User в ContactInfo, раз вся его работа сводится к использованию методов ContactInfo.
- Группы данных
Иногда вы встречаете множество функций с почти одинаковым списком параметров. Этот тип параметров, используемых только вместе, и вызывает code smell группы данных. Взгляните на пример ниже. Вы увидите, что почти все типы бронирования требуют паспортных данных.

  **[⬆ Наверх](#top)**

26. ### <a name="26"></a> Continuous delivery, Continuous deployment & Continuous integration (CI/CD): зачем это нужно?

DevOps — это сокращение от Development Operations. Это связующее звено между командой разработки и командой эксплуатации.

- разработчик отправляет код в центральный репозиторий;
- на сервере непрерывной интеграции изменения объединяются с основным кодом, выполняются юнит – тесты и всё заливается на стейджинг среду;
- в стейджинг среде QA (**Q**uality **A**ssurance) инженеры тестируют приложение;
- дальше всё проверяется для попадания на продакшен;
- развёртывание на продакшене.

*Continuous Delivery* — это серия практик, направленных на то, чтобы обновления программного обеспечения происходили практически постоянно.

*Continuous Deployment* отвечает за то, чтобы весь новый функционал после тестирования сразу же попал в основную программу без ручного вмешательства инженеров DevOps.

*Continuous Integration* — постоянное попадание кода в центральный репозиторий после успешного запуска тестов, поиск и устранение потенциальных проблем как можно быстрее, улучшение качества ПО и сокращение время для выпуска обновлений.

  **[⬆ Наверх](#top)**

27. ### <a name="27"></a> Отладке кода, Debugging

Отладка – это процесс поиска и исправления ошибок в скрипте. Все современные браузеры и большинство других сред разработки поддерживают инструменты для отладки – специальный графический интерфейс, который сильно упрощает отладку. Он также позволяет по шагам отследить, что именно происходит в нашем коде.

Приостановить выполнение скрипта можно тремя способами:

- Точками останова.
- Использованием в коде команды debugger.
- При ошибке (если инструменты разработчика открыты и опция  включена).

При остановке мы можем отлаживать – проанализировать переменные и пошагово пройти по процессу, что поможет отыскать проблему.
	
1. React и Redux
- React Devtools
- Redux Devtools
	
2. Vue
- Vue Devtools
	
3. JavaScript
- Chrome Devtools
- Выражение debugger
- Отладка при помощи старого доброго console.log	

https://learn.javascript.ru/debugging-chrome

  **[⬆ Наверх](#top)**

28. ### <a name="28"></a> Jira (Redmine,Tfs)

Jira - декомпозиция, эстимация, создания тасков, саб-тасков, багов, задачей на сборку

Система багтрекинга нужна для учета и контроля дефектов программы или сайта, для эффективного описания проблем: что сделал, что получил и что ожидал получить.

1. *Возможность отслеживания статуса проблемы*:
    - Предоставляет статусы для каждой проблемы, которые можно отслеживать, как лично, так и используя оповещения на почту или RSS.
2. *Качество описания проблемы*:
    - Обязательные поля для категорий, воспроизводимости, системы, описания и шагов повторения.
3. *Возможность прикрепления файлов*:
    - Можно прикреплять любые файлы в любое время.
4. *Комментирование проблем*:
    - Можно комментировать проблему, как, например, обычные записи в блогах.
5. *Совместная работа над проблемами*:
    - Система ролей и прав доступа.

  **[⬆ Наверх](#top)**

	
29. ### <a name="29"></a> 
	
	
	
  **[⬆ Наверх](#top)**	
	
30. ### <a name="30"></a> Хранилище данных: Куки, LocalStorage, sessionStorage, IndexedDB

### Какие знаешь способы хранения данных в приложении?
 
1. Куки, document.cookie
2. LocalStorage, sessionStorage
3. IndexedDB
 
### Куки, document.cookie
 
Куки – это небольшие строки данных, которые хранятся непосредственно в браузере.
	
Куки обычно устанавливаются веб-сервером при помощи заголовка Set-Cookie. Затем браузер будет автоматически добавлять их в (почти) каждый запрос на тот же домен при помощи заголовка Cookie.

Один из наиболее частых случаев использования куки – это аутентификация:

1. При входе на сайт сервер отсылает в ответ HTTP-заголовок Set-Cookie для того, чтобы установить куки со специальным уникальным идентификатором сессии («session identifier»).
2. Во время следующего запроса к этому же домену браузер посылает на сервер HTTP-заголовок Cookie.
3. Таким образом, сервер понимает, кто сделал запрос.
	
Мы также можем получить доступ к куки непосредственно из браузера, используя свойство document.cookie	
	
document.cookie предоставляет доступ к куки

- операция записи изменяет только то куки, которое было указано.
- имя и значение куки должны быть закодированы.
- одно куки вмещает до 4kb данных, разрешается более 20 куки на сайт (зависит от браузера).
 
Настройки куки:

- path=/, по умолчанию устанавливается текущий путь, делает куки видимым только по указанному пути и ниже.
- domain=site.com, по умолчанию куки видно только на текущем домене, если явно указан домен, то куки видно и на поддоменах.
- expires или max-age устанавливает дату истечения срока действия, без них куки умрёт при закрытии браузера.
- secure делает куки доступным только при использовании HTTPS.
- samesite запрещает браузеру отправлять куки с запросами, поступающими извне, помогает предотвратить XSRF-атаки.
 
Дополнительно:

- Сторонние куки могут быть запрещены браузером, например Safari делает это по умолчанию.
- Установка отслеживающих куки пользователям из стран ЕС требует их явного согласия на это в соответствии с законодательством GDPR.	
	
### В чем смысл cookies?
 
 Cookies — это небольшие текстовые файлы у нас на компьютерах, в которых хранится информация о наших предыдущих действиях на сайтах. Кроме входов в аккаунты они умеют запоминать:

- предпочтения пользователей, например, язык, валюту или размер шрифта.
- товары, которые мы просматривали или добавили в корзину;
- текст, который мы вводили на сайте раньше;
- IP-адрес и местоположение пользователя;
- дату и время посещения сайта;
- версию ОС и браузера;
- клики и переходы.
 
Как работают cookies
 
Когда мы совершаем на сайте какое-то действие, например, добавляем товар в корзину или вводим детали входа в аккаунт, сервер записывает эту информацию в куки и отправляет браузеру вместе со страницей. Когда мы переходим на другую страницу сайта или заходим на него через время, браузер отправляет куки обратно.

Куки бывают временными и постоянными. Постоянные куки остаются на компьютере, когда мы закрываем вкладку с сайтом, а временные удаляются. Какие именно куки использовать на конкретном сайте — временные или постоянные — решает его разработчик. Именно поэтому на одних сайтах мы не выходим из аккаунтов, даже когда заходим на них раз спустя несколько дней, а на других вводим пароль заново, хотя отошли от компьютера на пять минут.	
	
 
### LocalStorage, sessionStorage
 
Объекты веб-хранилища localStorage и sessionStorage позволяют хранить пары ключ/значение в браузере.

- key и value должны быть строками.
- Лимит 2 Мб+, зависит от браузера.
- Данные не имеют «времени истечения».
- Данные привязаны к источнику (домен/протокол/порт).
 
 localStorage:
 - Совместно используется между всеми вкладками и окнами с одинаковым источником
 - «Переживает» перезапуск браузера
 
 sessionStorage:
 - Разделяется в рамках вкладки браузера, среди ифреймов из того же источника
 - «Переживает» перезагрузку страницы (но не закрытие вкладки)
 
 API:

- setItem(key, value) – сохранить пару ключ/значение.
- getItem(key) – получить данные по ключу key.
- removeItem(key) – удалить значение по ключу key.
- clear() – удалить всё.
- key(index) – получить ключ на заданной позиции.
- length – количество элементов в хранилище.
- Используйте Object.keys для получения всех ключей.
- Можно обращаться к ключам как к обычным свойствам объекта, в этом случае событиеstorage не срабатывает.
 
Событие storage:

- Срабатывает при вызове setItem, removeItem, clear.
- Содержит все данные об произошедшем обновлении (key/oldValue/newValue), url документа и объект хранилища storageArea.
- Срабатывает на всех объектах window, которые имеют доступ к хранилищу, кроме того, где оно было сгенерировано (внутри вкладки для sessionStorage, глобально для localStorage).
 
### LocalStorage пример
	
```js
localStorage.setItem('number', 5);

localStorage.getItem('number');

localStorage.removeItem('number');

localStorage.clear();

console.log(localStorage.getItem('number'));

// Пример 
	
const checkbox = document.querySelector('#checkbox'),
      form = document.querySelector('form'),
      change = document.querySelector('#color');

if (localStorage.getItem('isChecked')) {
  checkbox.checked = true;
}

if (localStorage.getItem('bg') === 'changed') {
  form.style.backgroundColor = 'red';
}

checkbox.addEventListener('change', () => {
  localStorage.setItem('isChecked', true);
});

change.addEventListener('click', () => {
  if (localStorage.getItem('bg') === 'changed') {
    localStorage.removeItem('bg');
    form.style.backgroundColor = '#fff';
  } else {
    localStorage.setItem('bg', 'changed');
    form.style.backgroundColor = 'red';
  }
});

const persone = {
  name: 'Alex',
  age: 28
};

const serializedPersone = JSON.stringify(persone);
localStorage.setItem('alex', serializedPersone);

console.log(JSON.parse(localStorage.getItem('alex')));	
```	
	
### IndexedDB
 
IndexedDB можно рассматривать как «localStorage на стероидах». Это простая база данных типа ключ-значение, достаточно мощная для оффлайн приложений, но простая в использовании.

Использование можно описать в нескольких фразах:

1. Подключить обёртку над промисами, например idb.
2. Открыть базу данных: idb.openDb(name, version, onupgradeneeded)
- Создание хранилищ объектов и индексов происходит в обработчике onupgradeneeded.
- Обновление версии – либо сравнивая номера версий, либо можно проверить что существует, а что нет.
3. Для запросов:
- Создать транзакцию db.transaction('books') (можно указать readwrite, если надо).
- Получить хранилище объектов transaction.objectStore('books').
4. Затем для поиска по ключу вызываем методы непосредственно у хранилища объектов.
- Для поиска по любому полю объекта создайте индекс.
5. Если данные не помещаются в памяти, то используйте курсор.
 
```jsx harmony 
<!doctype html>
<script src="https://cdn.jsdelivr.net/npm/idb@3.0.2/build/idb.min.js"></script>

<button onclick="addBook()">Добавить книгу</button>
<button onclick="clearBooks()">Очистить хранилище</button>

<p>Список книг:</p>

<ul id="listElem"></ul>

<script>
let db;

init();

async function init() {
  db = await idb.openDb('booksDb', 1, db => {
    db.createObjectStore('books', {keyPath: 'name'});
  });

  list();
}

async function list() {
  let tx = db.transaction('books');
  let bookStore = tx.objectStore('books');

  let books = await bookStore.getAll();

  if (books.length) {
    listElem.innerHTML = books.map(book => `<li>
        название: ${book.name}, цена: ${book.price}
      </li>`).join('');
  } else {
    listElem.innerHTML = '<li>Книг пока нет. Пожалуйста, добавьте книги.</li>'
  }


}

async function clearBooks() {
  let tx = db.transaction('books', 'readwrite');
  await tx.objectStore('books').clear();
  await list();
}

async function addBook() {
  let name = prompt("Название книги");
  let price = +prompt("Цена книги");

  let tx = db.transaction('books', 'readwrite');

  try {
    await tx.objectStore('books').add({name, price});
    await list();
  } catch(err) {
    if (err.name == 'ConstraintError') {
      alert("Такая книга уже существует");
      await addBook();
    } else {
      throw err;
    }
  }
}

window.addEventListener('unhandledrejection', event => {
  alert("Ошибка: " + event.reason.message);
});

</script>
```

  **[⬆ Наверх](#top)**
	
31. ### <a name="31"></a> Критический путь рендеринга

### Что происходит, когда вводишь адрес в браузер и нажимаешь enter (как до сервера доходит запрос, dns, отрисовка dom, css и т.д.)
 
1. Происходит парсинг URL (**U**niform **R**esource **L**ocator) запроса: является ли это адресом, если нет, то введенная строка расценивается как поисковый запрос и передается на обработку поисковому движку.
2. Производится поиск адреса в кэше и в файле hosts, если не находится, то адрес запрашивается у DNS (**D**omain **N**ame **S**ystem)-сервера. Если DNS-сервер находится в той же подсети, то запрос отправляется этому серверу, если в другой подсети, то запрос отправляется на IP (**I**nternet **P**rotocol) - адрес шлюза по умолчанию.
3. Когда браузер получает IP-адрес конечного сервера, то он берет данные об используемом порте из URL и запускает соединение.
4. Сервер получает HTTP (**H**yper**T**ext **T**ransfer **P**rotocol) запрос, начинает его обработку, проверяет наличие запрашиваемого ресурса и в случае успеха направляет результат клиенту.
5. Браузер получает результат в качества HTML (**H**yper**T**ext **M**arkup **L**anguage). Начинает парсинг HTML, где производит разбор HTML разметки в DOM (**D**ocument **O**bject **M**odel) дерево.
6. Во время разбора HTML производится парсинг и интерпретация CSS (**C**ascading **S**tyle **S**heets).
7. Путем перебора DOM-узлов и вычисления для каждого узла значений CSS-стилей создается дерево рендера.

  **[⬆ Наверх](#top)**
	
32. ### <a name="32"></a> Кэширование (как работает и зачем нужно)

Небольшой объем памяти кэша компенсируется высокой скоростью доступа. В кэше обычно хранится только требуемый набор данных, причем временно, в отличие от баз данных, где данные обычно хранятся полностью и постоянно.
	
Приватный кеш предназначен для отдельного пользователя. Вы, возможно, уже видели параметры кеширования в настройках своего браузера. Кеш браузера содержит все документы, загруженные пользователем по HTTP. Он используется для доступа к ранее загруженным страницам при навигации назад/вперёд, позволяет сохранять страницы, или просматривать их код, не обращаясь лишний раз к серверу. Кроме того, кеш полезен при отключении от сети.
	
В идеале браузерное кэширование должно функционировать следующим образом:
1. сервер отправляет файл клиенту при первичном запросе;
2. клиент кэширует файл на срок, определённый в HTTP-заголовке ответа сервера;
3. по истечении срока клиент делает запрос к серверу на проверку изменений файла;
4. если файл не менялся, он вновь берётся из кэша.	
	
Ресурсы веб-страниц делятся на 2 группы:
- Динамические
Эти ресурсы не хранятся на сервере, а генерируются его средствами при запросах веб-страниц. К таким ресурсам обычно относят HTML-код, который может генерироваться посредством PHP на серверах Apache.
- Статические
Такие ресурсы хранятся на сервере. Как правило, к ним относится медиа-контент (картинки и видео), а также файлы стилей, скриптов и шрифтов.
	
Происходит кеширование статистических ресурсов.	

	
Производительность веб-сайтов и приложений можно значительно повысить за счёт повторного использования ранее полученных ресурсов. Веб-кеши сокращают задержку и снижают сетевой трафик, уменьшая тем самым время, необходимое для отображения ресурсов. Используя HTTP-кеширование, сайты становятся более отзывчивыми.

Как на стороне клиента, так и на стороне сервера можно использовать различные технологии кэширования. Для кэширования на стороне сервера обычно используется прокси-сервер, сохраняющий запросы от веб-серверов, которые за ним расположены, эффективно сокращая нагрузку на них и задержку ответа.
   
Различные виды кеширования
Техника кеширования заключается в сохранении копии полученного ресурса для возврата этой копии в ответ на дальнейшие запросы. Запрос на ресурс, уже имеющийся в веб-кеше, перехватывается, и вместо обращения к исходному серверу выполняется загрузка копии из кеша. Таким образом снижается нагрузка на сервер, которому не приходится самому обслуживать всех клиентов, и повышается производительность — кеш ближе к клиенту и ресурс передаётся быстрее. Кеширование является основным источником повышения производительности веб-сайтов. Однако, кеш надо правильно сконфигурировать: ресурсы редко остаются неизменными, так что копию требуется хранить только до того момента, как ресурс изменился, но не дольше.

Существует несколько видов кешей, которые можно разделить на две основные категории: приватные кеши и кеши совместного использования. В кешах совместного использования (shared cache) хранятся копии, которые могут направляться разным пользователям. Приватный кеш (private cache) предназначен для отдельного пользователя.
 
 Приватный (private) кеш браузера
Приватный кеш предназначен для отдельного пользователя. Вы, возможно, уже видели параметры кеширования в настройках своего браузера. Кеш браузера содержит все документы, загруженные пользователем по HTTP. Он используется для доступа к ранее загруженным страницам при навигации назад/вперёд, позволяет сохранять страницы, или просматривать их код, не обращаясь лишний раз к серверу. Кроме того, кеш полезен при отключении от сети.

Общий (shared) прокси-кеш
Кеш совместного использования — это кеш, который сохраняет ответы, чтобы их потом могли использовать разные пользователи. Например, в локальной сети вашего провайдера или компании, может быть установлен прокси, обслуживающий множество пользователей, чтобы можно было повторно использовать популярные ресурсы, сокращая тем самым сетевой трафик и время ожидания.
 
 https://developer.mozilla.org/ru/docs/Web/HTTP/Caching

  **[⬆ Наверх](#top)**
	
	
33. ### <a name="33"></a> 



  **[⬆ Наверх](#top)**
	
34. ### <a name="34"></a> 



  **[⬆ Наверх](#top)**	
	
	
44. ### <a name="44"></a> 



  **[⬆ Наверх](#top)**
	
45. ### <a name="45"></a> 
	

  **[⬆ Наверх](#top)**	
	
	

100. ### <a name="100"></a> Различие между null и undefined

Необъявленные переменные создаются, когда вы присваиваете значение идентификатору, который не был ранее создан при помощи var,let или const. Необъявленные переменные будут определены глобально, вне текущей области видимости. В строгом режиме, будет ошибка ReferenceError, когда вы попытаетесь назначить значение необъявленной переменной. Необъявленные переменные плохи так же, как и глобальные переменные. Избегайте их любой ценой! Чтобы проверить на их наличие, оберните код в блок try/catch.
```js
function foo() {
  x = 1; // ReferenceError в строгом режиме
}

foo();
console.log(x); // 1
```
	
Переменная undefined - это переменная, которая была объявлена, но ей не было присвоено значение. Ее тип undefined. Если переменной присвоить функцию, которая не возвращает никакого значения, то переменная также будет иметь значение undefined. Чтобы проверить это, сравните, используя оператор строгого равенства (===) или typeof, который вернет строку 'undefined'. Обратите внимание, что вам не следует использовать оператор абстрактного сравнения для проверки, так как он также вернет true, если значение равно null.
```js
var foo;
console.log(foo); // undefined
console.log(foo === undefined); // true
console.log(typeof foo === 'undefined'); // true

console.log(foo == null); // true. Неправильно, не используйте это для проверки!

function bar() {}
var baz = bar();
console.log(baz); // undefined
```
	
Переменной со значением null было явно присвоено значение null. Она отличается от undefined тем, что она была назначена явно. Чтобы проверить на null, просто сравните, используя оператор строгого равенства. Обратите внимание, что, как и выше, вы не должны использовать оператор абстрактного равенства (==) для проверки, так как он также вернет true, если значение равно undefined.	
```js
var foo = null;
console.log(foo === null); // true
console.log(typeof foo === 'object'); // true

console.log(foo == undefined); // true. Неправильно, не используйте это для проверки!
```
	
Личная привычка - я никогда не оставляю свои переменные необъявленными или неприсвоенными. Я явно назначаю им null после объявления, если я не собираюсь их пока использовать. Если вы используете линтер в своем рабочем процессе, он обычно также проверяет, что вы не ссылаетесь на необъявленные переменные.

  **[⬆ Наверх](#top)**		
	
	
101. ### <a name="101"></a> Переменные let, const, var. Cтрогий режим

### Переменные
	
`let` и `const` не существуют до своего объявления, блочная модель видимости

`var` уже есть до обьявления var, значение undefined. не имеет блочной области видимости, у него функциональная область видимости.

Переменные, объявленные при помощи ключевого слова var, относятся к области видимости функции, в которой они созданы. Или, если они созданы вне какой-либо функции - к глобальному объекту. let и const относятся к блочной области видимости - это означает, что они доступны только в пределах ближайшего набора фигурных скобок (функция, блок if-else или цикл for).

```js	
function foo() {
  // Все переменные доступны внутри функции.
  var bar = 'bar';
  let baz = 'baz';
  const qux = 'qux';

  console.log(bar); // bar
  console.log(baz); // baz
  console.log(qux); // qux
}

console.log(bar); // ReferenceError: bar is not defined
console.log(baz); // ReferenceError: baz is not defined
console.log(qux); // ReferenceError: qux is not defined
```	
```js	
if (true) {
  var bar = 'bar';
  let baz = 'baz';
  const qux = 'qux';
}

// переменные, объявленные при помощи var, доступны в любом месте функции.
console.log(bar); // bar
// переменные, объявленные при помощи let и const не доступны вне блока, в котором были определены.
console.log(baz); // ReferenceError: baz is not defined
console.log(qux); // ReferenceError: qux is not defined
```
	
`var` позволяет поднимать переменные, что означает, что на них можно ссылаться в коде до их объявления. let и const не позволяют этого, и выдают ошибку.
```js
console.log(foo); // undefined

var foo = 'foo';

console.log(baz); // ReferenceError: can't access lexical declaration 'baz' before initialization

let baz = 'baz';

console.log(bar); // ReferenceError: can't access lexical declaration 'bar' before initialization

const bar = 'bar';
```
	
Переопределение переменной с помощью `var` не вызовет ошибку, в отличие от `let` и `const`.
```js
var foo = 'foo';
var foo = 'bar';
console.log(foo); // "bar"

let baz = 'baz';
let baz = 'qux'; // Uncaught SyntaxError: Identifier 'baz' has already been declared
```
	
`let` отличается от `const` тем, что изменять значение const нельзя.
```js
// Это нормально.
let foo = 'foo';
foo = 'bar';

// Это вызывает исключение.
const baz = 'baz';
baz = 'qux';
```
	
### Строгий режим
	
'use strict' это директива, используемая для включения строгого режима во всем скрипте или отдельных функциях.

Преимущества:

- Не позволяет случайно создавать глобальные переменные.
- Любое присваивание, которое в обычном режиме завершается неудачей, в строгом режиме выдаст исключение.
- При попытке удалить неудаляемые свойства, выдаст исключение (в то время как в нестрогом режиме никакого действия бы не произошло).
- Требует, чтобы имена параметров функции были уникальными.
- this в глобальной области видимости равно undefined.
- Перехватывает распространенные ошибки, выдавая исключения.
- Исключает неочевидные особенности языка.
 
Недостатки:

- Нельзя использовать некоторые особенности языка, к которым привыкли некоторые разработчики.
- Нет доступа к function.caller и function.arguments.
- Объединение скриптов, написанных в строгом режиме может вызвать проблемы.	
	

  **[⬆ Наверх](#top)**	
	
102. ### <a name="102"></a> Классификация типов данных, приведение типов

- Число «number»
- Число «bigint»
- Строка «string»
- Булевый (логический) тип «boolean»
- Специальное значение «null»
- Специальное значение «undefined»
- Символы «symbol»
- Объекты «object»

Чаще всего значение примитивного типа представлено в низкоуровневой реализации языка.

Все ****примитивы **неизменяемы (immutable)**, то есть они не могут быть изменены. Важно не путать сам примитив с переменной, которой присвоено значение примитивного типа. Переменной может быть переприсвоено новое значение, но существующее значение примитивного типа не может быть изменено подобно объектам, массивам и функциям.

**Объект** относится к структуре данных, содержит в себе данные и инструкции по работе с ними. Объекты могут обозначать реальные вещи. Объекты **изменяемы**.

Одним из фундаментальных отличий объектов от примитивных типов данных является то, что они хранятся и копируются «по ссылке».

Примитивные типы: строки, числа, логические значения – присваиваются и копируются «по значению».

Примитивные типы не имеют методов; из-за этого примитивные типы неизменяемы, потому что у них нет методов, которые могли бы их изменить. Во время использования методов создается *временная оболочка*.

Функция — это особый тип объекта со специальными свойствами, например, `constructor` и `call`.

Метод — это свойство объекта, являющееся функцией.

### Приведение типов:

- to String

1)
```jsx harmony
console.log(typeof(String(null))); //string // редко используеться!
console.log(String(null)); // null

console.log(typeof(String(4))); // string
```
2) конкатинация
```jsx harmony
console.log(typeof(5 + '')); // string
console.log(typeof(null + '')); // string

const num = 5;
console.log('https://vk.com/catalog/' + num);

const fontSize = 26 + 'px';
console.log(fontSize); // 26px - string
```

- to Number

1)
```jsx harmony
console.log(typeof(Number('4'))); // редко используеться!
```
2) 
```jsx harmony
console.log(typeof(+'5'));
```
3)
```jsx harmony
console.log(typeof(parseInt('15px', 10)));
```
```jsx harmony
let answer = +prompt('Hello', '');

console.log(typeof(answer));
```

- to Boolean

0, '', null, undefined, NaN - false;

1)
```jsx harmony
let switcher = null;

if (switcher) {
  console.log('Working...');
}

switcher = 1;

if (switcher) {
  console.log('Working...');
}
```

2)
```jsx harmony
console.log(typeof(Boolean('4')));
```

3)
```jsx harmony
console.log(typeof(!!'44'));
```
	
### Явное и неявное преобразование типов
	
Преобразование типов может быть явным и неявным. Когда разработчик выражает намерение сконвертировать значение одного типа в значение другого типа, записывая это соответствующим образом в коде, скажем, в виде Number(value), это называется явным приведением типов (или явным преобразованием типов).

Так как JavaScript — это язык со слабой типизацией, значения могут быть конвертированы между различными типами автоматически. Это называют неявным приведением типов. Обычно такое происходит, когда в выражениях используют значения различных типов, вроде:

```js	
1 == null
2/’5'
null + new Date()
```
	
Неявное преобразование типов может быть вызвано и контекстом выражения, вроде if (value) {…}, где valueнеявно приводится к логическому типу данных.

Существует оператор, который не вызывает неявного преобразование типов — это оператор строгого равенства, ===. Оператор нестрогого равенства, ==, с другой стороны, выполняет и операцию сравнения, и, если нужно, выполняет неявное преобразование типов.	
	
https://learn.javascript.ru/types	

  **[⬆ Наверх](#top)**
	
103. ### <a name="103"></a> Общение с пользователем: alert(), prompt(), confirm()


`alert` - показывает сообщение.
```js
alert("Hello");
```

`prompt` - показывает сообщение и запрашивает ввод текста от пользователя. Возвращает напечатанный в поле ввода текст или null, если была нажата кнопка «Отмена» или Esc с клавиатуры.
```js
let age = prompt('Сколько тебе лет?', 100);
```
```js
let test = prompt("Test", '');
```

`confirm` - показывает сообщение и ждёт, пока пользователь нажмёт OK или Отмена. Возвращает true, если нажата OK, и false, если нажата кнопка «Отмена» или Esc с клавиатуры.
```js
let isBoss = confirm("Ты здесь главный?");
```

  **[⬆ Наверх](#top)**
	
104. ### <a name="104"></a> Интерполяция (ES6)

Шаблонные литералы заключены в обратные кавычки (` `) вместо двойных или одинарных. Они могут содержать подстановки, обозначаемые знаком доллара и фигурными скобками (${выражение}).
	
```js
const category = 'toys';
console.log(`https://someurl.com/${category}/5`);

const good = 'girl';
console.log(`https://someurl.com/${good}/11`);

const user = 'Ivan';
alert(`Привет, ${user}`);

const user = 'Max';
alert(`Hello ${user}, how are you?`);

const num = 42;
console.log(`Тебе ${num} года?`);	
```

  **[⬆ Наверх](#top)**
	
105. ### <a name="105"></a> Операторы в JS

### Операторы

```js
console.log('arr' + ' - object'); //строка
console.log(4 + ' - object'); //строка
console.log(4 + +'5'); //number 


let incr = 10,
    decr = 10;

incr++;
decr--;

console.log(incr);  //11
console.log(decr); //9

++incr;
--decr;

console.log(incr);  //11
console.log(decr); //9

// следующие строки будут изменятся 

let incr = 10,
    decr = 10;

//постфиксная форма
console.log(incr++);  //10
console.log(decr--); //10

//префиксная форма
console.log(++incr);  //11
console.log(--decr); //9


console.log(5%2); // 1
console.log(9%3); // 0
console.log(8%3); // 8 - (3+3) = 2


// " = " присваивание
// " == or === " знаки сравнения

Использование обычного сравнения == может вызывать проблемы. Например, оно не отличает 0 от false:
	
alert( 0 == false ); // true
	
Та же проблема с пустой строкой:

alert( '' == false ); // true
	
Это происходит из-за того, что операнды разных типов преобразуются оператором == к числу. В итоге, и пустая строка, и false становятся нулём.

Как же тогда отличать 0 от false?

`Оператор строгого равенства` === проверяет равенство без приведения типов.

Другими словами, если a и b имеют разные типы, то проверка a === b немедленно возвращает false без попытки их преобразования.

alert( 0 === false ); // false, так как сравниваются разные типы
	
Ещё есть оператор строгого неравенства !==, аналогичный !=.

Оператор строгого равенства дольше писать, но он делает код более очевидным и оставляет меньше места для ошибок.	

// " == " сравнивается с приведением типов, приводиться к однуму типу данных: 1 == '1' => true
// " === " сравнивается без приведения типов данных


console.log(2*4 == 8); //true
console.log(2*4 == '8'); //true
console.log(2*4 === '8'); //false
console.log(2*4 === 8); //true

// Исключени
console.log(false == '') //true
console.log(false == []) // true
console.log(false == {}) // false
console.log('' == 0) // true
console.log('' == []) // true
console.log('' == {}) // false
console.log(0 == []) //true
console.log(0 == {}) // false
console.log(0 == null) // false	

// Логические операторы	
	
// && (и) - когда два или больше являються правдивыми выражениями
// || (или) - когда хоть один с этих вариантов будет правдивым
// "!" (не)

const isChecked = true,
      isClose = false;

console.log(isChecked && isClose); //false

console.log(isChecked || isClose); //true

console.log(isChecked || !isClose); //true

    
console.log(2+2*2 === 8); //false

console.log(2+2*2 != 8); //true

console.log(2+2*2 !== '6'); //true	
```	
		
Прежде, чем мы двинемся дальше, давайте разберёмся с терминологией.

- Операнд – то, к чему применяется оператор. Например, в умножении 5 * 2 есть два операнда: левый операнд равен 5, а правый операнд равен 2. Иногда их называют «аргументами» вместо «операндов».

- Унарным называется оператор, который применяется к одному операнду. Например, оператор унарный минус "-" меняет знак числа на противоположный:
```js
let x = 1;

x = -x;
alert( x ); // -1, применили унарный минус
```
	
- Бинарным называется оператор, который применяется к двум операндам. Тот же минус существует и в бинарной форме:
```js
let x = 1, y = 3;
alert( y - x ); // 2, бинарный минус вычитает значения	
```

### Логические операторы

- ИЛИ «||» находит первое истинное значение.
цепочка ИЛИ "||" возвращает первое истинное значение или последнее, если такое значение не найдено.

3 || 4 = 3

- И «&&» находит первое ложное значение
И возвращает первое ложное значение. Или последнее, если ничего не найдено.

2 && 3 = 3

Вышеуказанные правила схожи с поведением ИЛИ. Разница в том, что И возвращает первое ложное значение, а ИЛИ - первое истинное.

Приоритет оператора && больше, чем у ||

- && (и) - когда два или больше являються правдивыми выражениями
- || (или) - когда хоть один с этих вариантов будет правдивым
- "!" (не)

	
### Тернарный оператор
	
```js
let result = условие ? значение1 : значение2;
```
Сначала вычисляется условие: если оно истинно, тогда возвращается значение1, в противном случае – значение2.
```js
let accessAllowed = (age > 18) ? true : false;
```

Несколько операторов ?
```js
let age = prompt('Возраст?', 18);

let message = (age < 3) ? 'Здравствуй, малыш!' :
  (age < 18) ? 'Привет!' :
  (age < 100) ? 'Здравствуйте!' :
  'Какой необычный возраст!';

alert( message );
```

```js
let a = 10;
let b = 15;

let result = a > b ? true : false;

console.log(result);
```

```js
let x = 10, y = 7;

let res = x > y ? 'x больше чем y' : 'x меньше чем y';

console.log(res);
```

```js
let booksCount = 19;
let r;

r = (booksCount > 15) ? 'План на год выполнен!' :
  (booksCount > 10) ? 'Уже неплохо!' :
  'Читать и ещё раз читать';

console.log(r)
```

```js
let ab = 5>0 ? true : false;

тоже самое только с if 

if (5>0) {
  console.log(true)
} else {
  console.log(false)
}
```	
	

### Оператор объединения с null '??'

Результат выражения a ?? b будет следующим:

- a, если значение a определено,
- b, если значение a не определено.

То есть оператор ?? возвращает первый аргумент, если он не null/undefined, иначе второй.
```js
let user;

alert(user ?? "Аноним"); // Аноним
```
```js
let us = 'Василий';

console.log(us ?? 'Аноним')
```
```js
let firstName = null;
let lastName = null;
let nickName = "Суперкодер";

// показывает первое определённое значение:
alert(firstName ?? lastName ?? nickName ?? "Аноним"); // Суперкодер
```

Оператор ?? имеет довольно низкий приоритет: 5
```js
let height = null;
let width = null;

// важно: используйте круглые скобки
let area = (height ?? 100) * (width ?? 50);

alert(area); // 5000
```
	
Важное различие между ними заключается в том, что:
- || возвращает первое истинное значение.
- ?? возвращает первое определённое значение.	

Итоги:	
- Оператор объединения с null ?? — это быстрый способ выбрать первое «определённое» значение из списка.
- Используется для присвоения переменным значений по умолчанию:
```js
// будет height=100, если переменная height равна null или undefined
height = height ?? 100;
```
	
- Оператор ?? имеет очень низкий приоритет, лишь немного выше, чем у ? и =, поэтому при использовании его в выражении, скорее всего, потребуются скобки.
- Запрещено использовать вместе с || или && без явно указанных круглых скобок.	

### Опциональная цепочка '?.'
	
`Опциональная цепочка ?.` — это безопасный способ доступа к свойствам вложенных объектов, даже если какое-либо из промежуточных свойств не существует.	
	
Опциональная цепочка ?. останавливает вычисление и возвращает undefined, если значение перед ?. равно undefined или null.
	
Другими словами, value?.prop:

- работает как value.prop, если значение value существует,
- в противном случае (когда value равно undefined/null) он возвращает undefined.
	
Вот безопасный способ получить доступ к user.address.street, используя ?.:
```js
let user = {}; // пользователь без адреса

alert( user?.address?.street ); // undefined (без ошибки)	
```

Синтаксис опциональной цепочки ?. имеет три формы:

- obj?.prop – возвращает obj.prop если obj существует, в противном случае undefined.
- obj?.[prop] – возвращает obj[prop] если obj существует, в противном случае undefined.
- obj.method?.() – вызывает obj.method(), если obj.method существует, в противном случае возвращает undefined.
	
Как мы видим, все они просты и понятны в использовании. ?. проверяет левую часть на null/undefined и позволяет продолжить вычисление, если это не так.

Цепочка ?. позволяет безопасно получать доступ к вложенным свойствам.	
```js
const userData = {
  name: 'Ivan',
  age: null,
  say: function() {
    console.log('Hello');
  }
}

// Так бы мы делали без этого оператора	=>
	
/* if (userData && userData.slills && userData.skills.js) {
  console.log(userData.skills.js);
} */

console.log(userData.skills?.js);

userData.say();
userData.hey?.();	
```	
	
	
### Математические операторы:

- Сложение +,
- Вычитание -,
- Умножение *,
- Деление /,
- Взятие остатка от деления %,
- Возведение в степень **
	
Первые четыре оператора очевидны, а про % и ** стоит сказать несколько слов.

- Взятие остатка %
Оператор взятия остатка %, несмотря на обозначение, никакого отношения к процентам не имеет.

Результат a % b – это остаток от целочисленного деления a на b.

```js
alert( 5 % 2 ); // 1, остаток от деления 5 на 2
alert( 8 % 3 ); // 2, остаток от деления 8 на 3
```		
	
- Возведение в степень **
В выражении a ** b оператор возведения в степень умножает a на само себя b раз.

```js
alert( 2 ** 2 ); // 4  (2 умножено на себя 2 раза)
alert( 2 ** 3 ); // 8  (2 * 2 * 2, 3 раза)
alert( 2 ** 4 ); // 16 (2 * 2 * 2 * 2, 4 раза)
```	
Математически, оператор работает и для нецелых чисел. Например, квадратный корень является возведением в степень 1/2:
```js
alert( 4 ** (1/2) ); // 2 (степень 1/2 эквивалентна взятию квадратного корня)
alert( 8 ** (1/3) ); // 2 (степень 1/3 эквивалентна взятию кубического корня)	
```
	
### Сложение строк при помощи бинарного +

Обычно при помощи плюса '+' складывают числа.

Но если бинарный оператор '+' применить к строкам, то он их объединяет в одну:
```js
let s = "моя" + "строка";
alert(s); // моястрока
```	
Обратите внимание, если хотя бы один операнд является строкой, то второй будет также преобразован в строку.
```js
alert( '1' + 2 ); // "12"
alert( 2 + '1' ); // "21"
```
	
Как видите, не важно, первый или второй операнд является строкой.

Вот пример посложнее:
```js
alert(2 + 2 + '1' ); // будет "41", а не "221"
```	
Здесь операторы работают один за другим. Первый + складывает два числа и возвращает 4, затем следующий + объединяет результат со строкой, производя действие 4 + '1' = 41.

Сложение и преобразование строк — это особенность бинарного плюса +. Другие арифметические операторы работают только с числами и всегда преобразуют операнды в числа.

Например, вычитание и деление:
```js
alert( 6 - '2' ); // 4, '2' приводится к числу
alert( '6' / '2' ); // 3, оба операнда приводятся к числам	
```
	
### Приведение к числу, унарный +

Унарный, то есть применённый к одному значению, плюс + ничего не делает с числами. Но если операнд не число, унарный плюс преобразует его в число.

```js
// Не влияет на числа
let x = 1;
alert( +x ); // 1

let y = -2;
alert( +y ); // -2

// Преобразует не числа в числа
alert( +true ); // 1
alert( +"" );   // 0
```
На самом деле это то же самое, что и Number(...), только короче.

Необходимость преобразовывать строки в числа возникает очень часто. Например, обычно значения полей HTML-формы — это строки. А что, если их нужно, к примеру, сложить?

Бинарный плюс сложит их как строки:
```js
let apples = "2";
let oranges = "3";

alert( apples + oranges ); // "23", так как бинарный плюс объединяет строки
```	
Поэтому используем унарный плюс, чтобы преобразовать к числу:
```js
let apples = "2";
let oranges = "3";

// оба операнда предварительно преобразованы в числа
alert( +apples + +oranges ); // 5

// более длинный вариант
// alert( Number(apples) + Number(oranges) ); // 5
```	
С точки зрения математика, такое изобилие плюсов выглядит странным. Но с точки зрения программиста тут нет ничего особенного: сначала выполнятся унарные плюсы, которые приведут строки к числам, а затем бинарный '+' их сложит.	
	

### Присваивание

Именно поэтому, когда переменной что-либо присваивают, например, x = 2 * 2 + 1, то сначала выполнится арифметика, а уже затем произойдёт присваивание = с сохранением результата в x.
```js
let x = 2 * 2 + 1;

alert( x ); // 5
```	
Присваивание = возвращает значение

Вызов x = value записывает value в x и возвращает его.

Благодаря этому присваивание можно использовать как часть более сложного выражения:
```js
let a = 1;
let b = 2;

let c = 3 - (a = b + 1);

alert( a ); // 3
alert( c ); // 0
```				
В примере выше результатом (a = b + 1) будет значение, которое присваивается переменной a (то есть 3). Потом оно используется для дальнейших вычислений.

- Присваивание по цепочке
```js
let a, b, c;

a = b = c = 2 + 2;

alert( a ); // 4
alert( b ); // 4
alert( c ); // 4
```
	
Такое присваивание работает справа налево. Сначала вычисляется самое правое выражение 2 + 2, и затем результат присваивается переменным слева: c, b и a. В конце у всех переменных будет одно значение.

Опять-таки, чтобы код читался легче, лучше разделять подобные конструкции на несколько строчек:
```
c = 2 + 2;
b = c;
a = c;
```	
Польза от такого стиля особенно ощущается при быстром просмотре кода.

- Сокращённая арифметика с присваиванием
```js
let n = 2;
n = n + 5;
n = n * 2;
```	
Эту запись можно укоротить при помощи совмещённых операторов += и *=:
```js
let n = 2;
n += 5; // теперь n = 7 (работает как n = n + 5)
n *= 2; // теперь n = 14 (работает как n = n * 2)

alert( n ); // 14
```	
Подобные краткие формы записи существуют для всех арифметических и побитовых операторов: /=, -= и так далее.

Вызов с присваиванием имеет в точности такой же приоритет, как обычное присваивание, то есть выполнится после большинства других операций:
```js
let n = 2;

n *= 3 + 5;

alert( n ); // 16  (сначала выполнится правая часть, выражение идентично n *= 8)
```
	
### Инкремент/декремент

Для этого существуют даже специальные операторы:

Инкремент ++ увеличивает переменную на 1:
```js
let counter = 2;
counter++;        // работает как counter = counter + 1, просто запись короче
alert( counter ); // 3
```	
Декремент -- уменьшает переменную на 1:
```js
let counter = 2;
counter--;        // работает как counter = counter - 1, просто запись короче
alert( counter ); // 1
```	

Инкремент/декремент можно применить только к переменной. Попытка использовать его на значении, типа 5++, приведёт к ошибке.

Операторы ++ и -- могут быть расположены не только после, но и до переменной.

Когда оператор идёт после переменной — это «постфиксная форма»: counter++.	
«Префиксная форма» — это когда оператор идёт перед переменной: ++counter.
Обе эти инструкции делают одно и то же: увеличивают counter на 1.

Префиксная форма возвращает новое значение, в то время как постфиксная форма возвращает старое (до увеличения/уменьшения числа).
```js
let counter = 1;
let a = ++counter; // (*)

alert(a); // 2
```	
В строке (*) префиксная форма ++counter увеличивает counter и возвращает новое значение 2. Так что alert покажет 2.

Теперь посмотрим на постфиксную форму:
```js
let counter = 1;
let a = counter++; // (*) меняем ++counter на counter++

alert(a); // 1
```	
В строке (*) постфиксная форма counter++ также увеличивает counter, но возвращает старое значение (которое было до увеличения). Так что alert покажет 1.

Если результат оператора не используется, а нужно только увеличить/уменьшить переменную, тогда без разницы, какую форму использовать:
```js
let counter = 0;
counter++;
++counter;
alert( counter ); // 2, обе строки сделали одно и то же
```	
Если хочется тут же использовать результат, то нужна префиксная форма:
```js
let counter = 0;
alert( ++counter ); // 1
Если нужно увеличить и при этом получить значение переменной до увеличения – нужна постфиксная форма:

let counter = 0;
alert( counter++ ); // 0	
```
	
### Побитовые операторы
	
Побитовые операторы работают с 32-разрядными целыми числами (при необходимости приводят к ним), на уровне их внутреннего двоичного представления.

Поддерживаются следующие побитовые операторы:

- AND(и) ( & )
- OR(или) ( | )
- XOR(побитовое исключающее или) ( ^ )
- NOT(не) ( ~ )
- LEFT SHIFT(левый сдвиг) ( << )
- RIGHT SHIFT(правый сдвиг) ( >> )
- ZERO-FILL RIGHT SHIFT(правый сдвиг с заполнением нулями) ( >>> )


### Оператор «запятая»

Оператор «запятая» предоставляет нам возможность вычислять несколько выражений, разделяя их запятой ,. Каждое выражение выполняется, но возвращается результат только последнего.
```js
let a = (1 + 2, 3 + 4);

alert( a ); // 7 (результат вычисления 3 + 4)	
```	
	
### Выражения
	
Выражением является любой корректный блок кода, который возвращает значение.

Концептуально, существуют два типа выражений: те которые присваивают переменной значение, и те, которые вычисляют значение без его присваивания.

Все выражения в JavaScript делятся на следующие категории:

- Арифметические: вычисляются в число, например: 3.14159 (Используют арифметические операторы).
- Строковые: вычисляются в текстовую строку, например: "Fred" или "234" (Используют строковые операторы).
- Логические: вычисляются в true или false (Используют логические операторы).
- Основные выражения: Базовые ключевые слова и основные выражения в JavaScript.
- Левосторонние выражения: Значениям слева назначаются значения справа.

  **[⬆ Наверх](#top)**
	
106. ### <a name="106"></a> Условия

Инструкция if(...) вычисляет условие в скобках и, если результат true, то выполняет блок кода.	
	
Число 0, пустая строка "", null, undefined и NaN становятся false. Из-за этого их называют «ложными» («falsy») значениями.

Остальные значения становятся true, поэтому их называют «правдивыми» («truthy»).	
	
### if

```js
if (1) {
   console.log(true)
} else {
   console.log(false)
}
```

Инструкция if(...) вычисляет условие в скобках и, если результат true, то выполняет блок кода.
```js
let year = prompt('В каком году была опубликована спецификация ECMAScript-2015?', '');

if (year == 2015) alert( 'Вы правы!' );
```

Инструкция if может содержать необязательный блок «else» («иначе»). Он выполняется, когда условие ложно.
```js
let year = prompt('В каком году была опубликована спецификация ECMAScript-2015?', '');

if (year == 2015) {
  alert( 'Да вы знаток!' );
} else {
  alert( 'А вот и неправильно!' ); // любое значение, кроме 2015
}
```

```js
let year = prompt('В каком году ты родился?', '');

if (year == 1990) {
  console.log('Ты прав!');
} else {
  console.log('Ты ошибаешься:(')
}
```

### else if	

Иногда, нужно проверить несколько вариантов условия. Для этого используется блок else if.
```js
let year = prompt('В каком году была опубликована спецификация ECMAScript-2015?', '');

if (year < 2015) {
  alert( 'Это слишком рано...' );
} else if (year > 2015) {
  alert( 'Это поздновато' );
} else {
  alert( 'Верно!' );
}
```

```js
let year = prompt('В каком году ты родился?', '');

if (year < 1990) {
  console.log('Рановато')
} else if (year > 1990) {
  console.log('Это уже поздно!')
} else {
  console.log('В точку!')
}
```

```js
let age = 17;
let message;

if (age < 3) {
   message = 'Здравствуй, малыш!';
} else if (age < 18) {
   message = 'Привет!';
} else if (age < 100) {
   message = 'Здравствуйте!';
} else {
   message = 'Какой необычный возраст!';
}

console.log(message)
```

### Switch

switch работает только со строгим сравнением и switch так же работает со строками

```js
const number = 42;

switch (number) {
  case 41: console.log('Маловато')
    break;
  case 43: console.log('Многовато')
    break;
  case 42: console.log('В точку!')
    break;
  default: console.log('Ни в этот раз')
    break;
}
```
```js
let n = 3;

switch(n) {
  case 1:
  case 2:
    console.log('Маловато');
    console.log('Все еще мало');
    break;
  case 3:
    console.log('В точку!')
    break;
  case 4:
    console.log('Много');
    break;
  default:
    console.log('Все остальное')
}

console.log(n) // 3
```			
```js
let tr = prompt('Тебе сколько лет?', '18');

switch(tr) {
  case '17':
    console.log('Неправильно');
    break;
  case '18':
    console.log('Верно');
    break;
  case '19':
    console.log('Too much');
    break;
  default:
    console.log('Все возрасты покорны)')
}
```

### Тернарный оператор / Условный оператор
```js
let result = условие ? значение1 : значение2;
```
Сначала вычисляется условие: если оно истинно, тогда возвращается значение1, в противном случае – значение2.
```js
let accessAllowed = (age > 18) ? true : false;
```

Несколько операторов ?
```js
let age = prompt('Возраст?', 18);

let message = (age < 3) ? 'Здравствуй, малыш!' :
  (age < 18) ? 'Привет!' :
  (age < 100) ? 'Здравствуйте!' :
  'Какой необычный возраст!';

alert( message );
```

```js
let a = 10;
let b = 15;

let result = a > b ? true : false;

console.log(result);
```

```js
let x = 10, y = 7;

let res = x > y ? 'x больше чем y' : 'x меньше чем y';

console.log(res);
```

```js
let booksCount = 19;
let r;

r = (booksCount > 15) ? 'План на год выполнен!' :
  (booksCount > 10) ? 'Уже неплохо!' :
  'Читать и ещё раз читать';

console.log(r)
```

```js
let ab = 5>0 ? true : false;

тоже самое только с if 

if (5>0) {
  console.log(true)
} else {
  console.log(false)
}
```

### Оператор объединения
	
Результат выражения a ?? b будет следующим:
- a, если значение a определено,
- b, если значение a не определено.
	
То есть оператор ?? возвращает первый аргумент, если он не null/undefined, иначе второй.	
	
Например, в следующем примере, если переменная user не определена, покажем модальное окно с надписью Аноним:
```js
let user;

alert(user ?? "Аноним"); // Аноним
```	
Конечно, если бы переменная user содержала любое значение, кроме null/undefined, то мы бы увидели его:
```js
let user = "Иван";

alert(user ?? "Аноним"); // Иван	
```
	
Важное различие между ними заключается в том, что:
- || возвращает первое истинное значение.
- ?? возвращает первое определённое значение.	

Итоги:	
- Оператор объединения с null ?? — это быстрый способ выбрать первое «определённое» значение из списка.
- Используется для присвоения переменным значений по умолчанию:
```js
// будет height=100, если переменная height равна null или undefined
height = height ?? 100;
```	
- Оператор ?? имеет очень низкий приоритет, лишь немного выше, чем у ? и =, поэтому при использовании его в выражении, скорее всего, потребуются скобки.
- Запрещено использовать вместе с || или && без явно указанных круглых скобок.

  **[⬆ Наверх](#top)**
	
107. ### <a name="107"></a> Циклы, Цикл в цикле, метки

### while

```js
let i = 0;
while (i < 3) { // выводит 0, затем 1, затем 2
  alert( i );
  i++;
}
```
Любое выражение или переменная может быть условием цикла, а не только сравнение: условие while вычисляется и преобразуется в логическое значение.

Например, while (i) – более краткий вариант while (i != 0):
```js
let i = 3;
while (i) { // когда i будет равно 0, условие станет ложным, и цикл остановится
  alert( i );
  i--;
}
```
Если тело цикла состоит лишь из одной инструкции, мы можем опустить фигурные скобки {…}:
```js
let i = 3;
while (i) alert(i--);
```

### do while
```js
let i = 0;
do {
  alert( i );
  i++;
} while (i < 3);
```
Такая форма синтаксиса оправдана, если вы хотите, чтобы тело цикла выполнилось хотя бы один раз, даже если условие окажется ложным. На практике чаще используется форма с предусловием: while(…) {…}

```js
do {
  console.log(num);
  num++;
} while (num < 55);
```

### for

```js
for (let i = 0; i < 3; i++) { // выведет 0, затем 1, затем 2
  alert(i);
}
```
```js
for (let i = 1; i < 10; i++) {
  if (i === 6) {
    break;
  }
  console.log(i);
}
```
```js
for (let i = 1; i < 10; i++) {
  if (i === 6) {
    continue;
  }
  console.log(i);
}
```
	
```js
for (let i = 0; i < 10; i++) {

  // если true, пропустить оставшуюся часть тела цикла
  if (i % 2 == 0) continue;

  alert(i); // 1, затем 3, 5, 7, 9
}	
```	

```js
for (let i = 5; i <= 10; i++) {
  console.log(i)
}

	
for (let i = 20; i >= 10; i--) {
  if (i === 13) break;
  console.log(i);
}

	
for (let i = 2; i <= 10; i++) {
  if (i % 2 == 0) {
    console.log(i)
  }
}

		       
let i = 2;
while (i <= 16) {
  if(i % 2 === 0) {
    i++;
    continue;
  } else {
    console.log(i)
  }
  i++ 
}

	
for (let i = 2; i <= 16; i++) {
  if (i % 2 === 0) {
      continue;
  } else {
      console.log(i);
  }
}		       
```		       
		       
### Цикл в цикле и метки
		       
```js
for(let i = 0; i < 3; i++) {
  console.log(i);
  for(let j = 0; j < 3; j++) {
    console.log(j);
  }
}		       
```
```
*
**
***
****
*****
```		       
```js
let result = '';
const length = 7;

for (let i = 1; i < length; i++) {

  for (let j = 0; j < i; j++) {
    result += '*'
  }

  result += '\n';
}

console.log(result);		       
```
			
```js
first: for(let i = 0; i < 3; i++) {
  console.log(`First level: ${i}`);
  for(let j = 0; j < 3; j++) {
    console.log(`Second level: ${j}`)
    for(let k = 0; k < 3; k++) {
      if(k === 2) continue first;
      console.log(`Third level: ${k}`)
    }
  }
}


first: for(let i = 0; i < 3; i++) {
  console.log(`First level: ${i}`);
  for(let j = 0; j < 3; j++) {
    console.log(`Second level: ${j}`)
    for(let k = 0; k < 3; k++) {
      if(k === 2) break first;
      console.log(`Third level: ${k}`)
    }
  }
}			
```
			 
		       
  **[⬆ Наверх](#top)**

		       
108. ### <a name="108"></a> Функции, стрелочные ф-ции, IIFE

Функции - ключевая концепция в JavaScript. Важнейшей особенностью языка является первоклассная поддержка функций. Любая функция это объект, и следовательно ею можно манипулировать как объектом, в частности:

- передавать как аргумент и возвращать в качестве результата при вызове других функций (функций высшего порядка);
- создавать анонимно и присваивать в качестве значений переменных или свойств объектов.	

	
### Function Declaration (Объявление Функции):
```js
function sayHi() {
  alert( "Привет" );
}
```
	
### Function Expression (Функциональное Выражение).
```js
let sayHi = function() {
  alert( "Привет" );
};	
```	

	
### Function Expression в сравнении с Function Declaration

- Function Declaration: функция объявляется отдельной конструкцией «function…» в основном потоке кода.
```js
// Function Declaration
function sum(a, b) {
  return a + b;
}
```
	
- Function Expression: функция, созданная внутри другого выражения или синтаксической конструкции. В данном случае функция создаётся в правой части «выражения присваивания» =:
```js
// Function Expression
let sum = function(a, b) {
  return a + b;
};
```	

`Function Expression` создаётся, когда выполнение доходит до него, и затем уже может использоваться.

После того, как поток выполнения достигнет правой части выражения присваивания let sum = function… – с этого момента, функция считается созданной и может быть использована (присвоена переменной, вызвана и т.д. ).

`Function Declaration` можно использовать во всем скрипте (или блоке кода, если функция объявлена в блоке).

Другими словами, когда движок JavaScript готовится выполнять скрипт или блок кода, прежде всего он ищет в нём Function Declaration и создаёт все такие функции. Можно считать этот процесс «стадией инициализации».

В результате, функции, созданные, как Function Declaration могут быть вызваны раньше своих определений.

Например, так будет работать:
```js
sayHi("Вася"); // Привет, Вася

function sayHi(name) {
  alert( `Привет, ${name}` );
}
```

…Если бы это было Function Expression, то такой код вызовет ошибку:
```js
sayHi("Вася"); // ошибка!

let sayHi = function(name) {  // (*) магии больше нет
  alert( `Привет, ${name}` );
};
```
	
Функции, объявленные при помощи Function Expression, создаются тогда, когда выполнение доходит до них. Это случится только на строке, помеченной звёздочкой (*). Слишком поздно.

Ещё одна важная особенность Function Declaration заключается в их блочной области видимости.

В строгом режиме, когда Function Declaration находится в блоке {...}, функция доступна везде внутри блока. Но не снаружи него.	

```js
const usd = 28;
const eur = 32;

function convert(amount, curr) {
  console.log(amount * curr);
}

convert(400, usd)
convert(100, eur);	
```
	
```js
function returnNumber(num) {
  return [num - 1, num, num + 1];
}

console.log(returnNumber(3));	
```	
	
![123](https://user-images.githubusercontent.com/80325645/117417357-ec1cee80-af22-11eb-92f3-64105565c098.jpg)
   

### IIFE	
	
IIFE (Immediately Invoked Function Expression) это JavaScript функция, которая выполняется сразу же после того, как она была определена. ... Благодаря этому переменные IIFE замыкаются в его пределах, и глобальная область видимости ими не засоряется.

```js
(function() {

  let message = "Hello";

  alert(message); // Hello

})();	
```	

Скобки вокруг функции – это трюк, который позволяет показать JavaScript, что функция была создана в контексте другого выражения, и, таким образом, это функциональное выражение: ей не нужно имя и её можно вызвать немедленно.	

```js
// Пути создания IIFE

(function() {
  alert("Скобки вокруг функции");
})();

(function() {
  alert("Скобки вокруг всего");
}());

!function() {
  alert("Выражение начинается с логического оператора NOT");
}();

+function() {
  alert("Выражение начинается с унарного плюса");
}();	
```		

https://learn.javascript.ru/function-expressions

https://learn.javascript.ru/closure#iife

  **[⬆ Наверх](#top)**
	
	
109. ### <a name="109"></a> Функции привязки контекста (call, apply, bind)

### Методы привязки контекста <a name="Metody_privyazki_konteksta"></a>

```jsx harmony
 function hello() {
  console.log('Hello', this)
}

// console.log(hello()) //window

const person = {
  name: 'Spacy',
  age: 30,
  sayHello: hello,
  sayHelloWindow: hello.bind(window), // window
  // sayHelloWindow: hello.bind(document) // documtnt
  logInfo: function(job, phone) {
    console.group(`${this.name} info:`);
    console.log(`Name is ${this.name}`);
    console.log(`Age is ${this.age}`);
    console.log(`Job is ${job}`);
    console.log(`Phone is ${phone}`);
    console.groupEnd();
  }
}

const lena = {
  name: 'Elena',
  age: 25,
}

// console.log(person) // {name: "Spacy", age: 30, sayHello: ƒ}

// console.log(person.sayHello()) // Hello {name: "Spacy", age: 30, sayHello: ƒ}

// console.log(person.sayHelloWindow()); // Hello Window {window: Window, self: Window, document: document, name: "", location: Location, …}

// console.log(this === window) //true

// console.log(person.logInfo())

// console.log(person.logInfo('FRFR', '432523'))

// console.log(person.logInfo.bind(lena)())


// метод bind()- возвращает нам новую функцию, и ее мы можем вызвать в любое время
person.logInfo.bind(lena, 'Frontend', '073-23-12-421')();

// метод call() - задает определенный контекст функции и какие-то параметры через запятую перечисленные, и вызывает функцию сразу
// person.logInfo.call(lena, 'Frontend', '073-23-12-421');

// // метод apply() сразу вызовет эту функцию
// person.logInfo.apply(lena, ['Frontend', '073-23-12-421'])
```

 
### Методы привязки контекста 2: bind, call, apply <a name="Metody_privyazki_konteksta_2"></a>

Метод bind() создаёт новую функцию, которая при вызове устанавливает в качестве контекста выполнения this предоставленное значение. В метод также передаётся набор аргументов, которые будут установлены перед переданными в привязанную функцию аргументами при её вызове.

Метод call() вызывает функцию с указанным значением this и индивидуально предоставленными аргументами. Функция call() принимает список аргументов	
	
Метод apply() вызывает функцию с указанным значением this и аргументами, предоставленными в виде массива (либо массивоподобного объекта ). Функция apply() принимает единичный массив аргументов
	
	
```jsx harmony 
 const auto = {
	brand: 'BMW',
	drive() {
		console.log(this) // {brand: "BMW", drive: ƒ}
		return `Заведем наш ${this.brand}`
	}
}

const motorBike = {
	brand: 'Suzuki'
}

console.log(auto.drive()); // Заведем наш BMW

// const autoDrive = auto.drive;

// console.log(autoDrive()) // Заведем наш undefined
```
 
// ! bind
```jsx harmony
const autoDrive = auto.drive.bind(auto);

console.log(autoDrive()) // Заведем наш BMW


const motorDrive = auto.drive.bind(motorBike)

const motorDrive1 = auto.drive.bind({brand: 'Корабль'});

console.log(motorDrive()); // Заведем наш Suzuki

console.log(motorDrive1()); // Заведем наш Корабль
```
 
// !
```jsx harmony
const $ = document.querySelector.bind(document);

console.log($ === document.querySelector);

const header = $('h2')
console.log(header);
```

// !
```jsx harmony
const bill = {
	tip: 0.1,
	calculate(total) {
		console.log(this);
		return total + total * this.tip;
	}
}

// const pay = bill.calculate(1000);
// console.log(pay); // 1100

const payCount = bill.calculate.bind(bill);

console.log(payCount(1000)); // 1100


const payCount2 = bill.calculate.bind({tip: 0.2}, 1000);

console.log(payCount2()); // 1200
```

// ! call apply
```jsx harmony
const bill2 = {
	tip: 0.1,
	calculate(total) {
		console.log(this);
		return total + total * this.tip;
	}
}


const payBind = bill2.calculate.bind(bill);

console.log(payBind(1000)); // 1100


const payCountCall = bill2.calculate.call(bill2, 1000);

console.log(payCountCall); // 1100


const payCountApply = bill2.calculate.apply(bill2, [1000]);

console.log(payCountApply); // 1100
```

// контекст привязывается один раз, и мы не можем повторно его привязать


// !
```jsx harmony
const bill3 = {
	tip: 0.1,
	calculate(total) {
		console.log(this);
		return total + total * this.tip;
	},
	detail(dish1, dish2, sum) {
		return `Ваш обед ${dish1}, ${dish2} стоит ${this.calculate((sum))}`
	}
}

const a = bill3.detail('pizza', 'salad', 1000);

const b = bill3.detail.call(bill3, 'pizza', 'salad', 1000);

const c = bill3.detail.apply(bill, ['pizza', 'salad', 1000]);


console.log(a); //Ваш обед pizza, salad стоит 1100
console.log(b); //Ваш обед pizza, salad стоит 1100
console.log(c); //Ваш обед pizza, salad стоит 1100
``` 

	
// ### пример: два разных обьекта и функция bind, call, apply
```jsx harmony
var a = {
	b: 5,
	getB: function() {
		return this.b;
	}
};

var obj = {
	a: '1',
	c: 'slovo',
	b: 10
}

console.log(a.getB.call(obj)) // 10

console.log(a.getB.apply(obj)) // 10

console.log(a.getB.bind(obj)()) // 10


// bind

var fn = a.getB.bind(a);

console.log(fn()); // 5


console.log(a.getB.bind(a)()) // 5
```
	
### пример 
```jsx harmony	
var object = {
	a: function() {
		console.log(this.prop);
	},
	prop: 1
};

object.a.prop = 2;
object.a() // 1
var func = object.a.bind({prop: 113});
func() //113
```	
	 

### Методы привязки контекста 3 <a name="Metody_privyazki_konteksta_3"></a>
 
 Решение 1: сделать функцию-обёртку

Самый простой вариант решения – это обернуть вызов в анонимную функцию, создав замыкание:
```jsx harmony
let user = {
  firstName: "Вася",
  sayHi() {
    alert(`Привет, ${this.firstName}!`);
  }
};

setTimeout(function() {
  user.sayHi(); // Привет, Вася!
}, 1000);
Теперь код работает корректно, так как объект user достаётся из замыкания, а затем вызывается его метод sayHi.
```
То же самое, только короче:
```jsx harmony
setTimeout(() => user.sayHi(), 1000); //
```
 
Решение 2: привязать контекст с помощью bind

В современном JavaScript у функций есть встроенный метод bind, который позволяет зафиксировать this.

Базовый синтаксис bind:
```jsx harmony
let boundFunc = func.bind(context);
Например, здесь funcUser передаёт вызов в func, фиксируя this=user:

let user = {
  firstName: "Вася"
};

function func() {
  alert(this.firstName);
}

let funcUser = func.bind(user);
funcUser(); // Вася
Здесь func.bind(user) – это «связанный вариант» func, с фиксированным this=user.
```
Все аргументы передаются исходному методу func как есть, например:
```jsx harmony
let user = {
  firstName: "Вася"
};

function func(phrase) {
  alert(phrase + ', ' + this.firstName);
}

// привязка this к user
let funcUser = func.bind(user);

funcUser("Привет"); // Привет, Вася (аргумент "Привет" передан, при этом this = user)
```
```jsx harmony 
Теперь давайте попробуем с методом объекта:

let user = {
  firstName: "Вася",
  sayHi() {
    alert(`Привет, ${this.firstName}!`);
  }
};

let sayHi = user.sayHi.bind(user); // (*)

sayHi(); // Привет, Вася!

setTimeout(sayHi, 1000); // Привет, Вася!
``` 
В строке (*) мы берём метод user.sayHi и привязываем его к user. Теперь sayHi – это «связанная» функция, которая может быть вызвана отдельно или передана в setTimeout (контекст всегда будет правильным).

Здесь мы можем увидеть, что bind исправляет только this, а аргументы передаются как есть:
 
```jsx harmony
let user = {
  firstName: "Вася",
  say(phrase) {
    alert(`${phrase}, ${this.firstName}!`);
  }
};

let say = user.say.bind(user);

say("Привет"); // Привет, Вася (аргумент "Привет" передан в функцию "say")
say("Пока"); // Пока, Вася
``` 
 
 
### Методы привязки контекста 
```jsx harmony
call - вызов функции с подменой контекста - this внутри функции. Пример:

function f(arg) {
    alert(arg);
    alert(this);
}

f('abc');             // abc, [object Window]

f.call('123', 'abc'); // abc, 123
 
 
apply - вызов функции с переменным количеством аргументов и с подменой контекста. Пример:

function f() {
    alert(this);
    for (var i = 0; i < arguments.length; i++) {
        alert(arguments[i]);
    }
}

f(1, 2, 3);                   // [object Window], 1, 2, 3

f.apply('abc', [1, 2, 3, 4]); // abc, 1, 2, 3, 4
                                         
                                         
bind - создаёт "обёртку" над функцией, которая подменяет контекст этой функции. Поведение похоже на call и apply, но, в отличие от них, bind не вызывает функцию, а лишь возвращает "обёртку", которую можно вызвать позже. Пример:

function f() {
    alert(this);
}

var wrapped = f.bind('abc');

f();         // [object Window]
wrapped();   // abc
                                         
    
                                         
Также bind умеет подменять не только контекст, но и аргументы функции, осуществляя каррирование:

function add(a, b) {
    return a + b;
}

var addOne = add.bind(null, 1);

alert(add(1, 2));   // 3

alert(addOne(2));   // 3
```

  **[⬆ Наверх](#top)**
	
	
110. ### <a name="110"></a> Замыкание

Замыкание – это функция, которая запоминает свои внешние переменные и может получить к ним доступ.
                                         
 То есть, они автоматически запоминают, где были созданы, с помощью скрытого свойства [[Environment]] и все они могут получить доступ к внешним переменным.
 
### Лексический контекст         
Лексический область видимости (lexical scoping): в JavaScript область действия переменной определяется по её расположению в коде (это очевидно лексически), и вложенные функции имеют доступ к переменным, объявленным вовне. Этот механизм и называется Lexical scoping (область действия, ограниченная лексически).	
	
```jsx harmony
function createCalcFunction(n) {
  return function() {
    console.log(1000 * n)
  }
}

const calc = createCalcFunction(42);

calc()



function createIncrementor(n) {
  return function(num) {
    return n + num;
  }
}

const addOne = createIncrementor(1);
const addTen = createIncrementor(10);

console.log(addOne(10));

console.log(addTen(10));
console.log(addTen(41));


function urlGenerator(domain) {
  return function(url) {
    return `https://${url}.${domain}`
  }
}

const comUrl = urlGenerator('com');
const uaUrl = urlGenerator('ua');

console.log(comUrl('google'));
console.log(comUrl('gmail'));

console.log(uaUrl('tsn'));
console.log(uaUrl('megogo'));
```
	
```js	
function bind(context, fn) {
  return function(...args) {
    fn.apply(context, args)
  }
}

function logPerson() {
  console.log(`Person: ${this.name}, ${this.age}, ${this.job}`)
}

const person1 = {name: 'Miza', age: 22, job: 'FrontEnd'};
const person2 = {name: 'Nana', age: 32, job: 'SEO'};

bind(person1, logPerson)();
bind(person2, logPerson)();
	
// задача
	
function external() {
	const externalVar = 'Я - внешняя функция';

	function internal() {
		const internalVar = 'Я - внутренняя функция';

		console.log('internalVar >', internalVar);
		console.log('externalVar >', externalVar);
	}
	return internal;
}

const internalFn = external();
internalFn();

// пример

function createAddress(type) {
	const address = type.toUpperCase();
	return function(name) {
		return `${address} ${name}`;
	}

}

const addressMale = createAddress('Male');
const addressFemale = createAddress('Female');

console.log(addressMale('Василий'));
console.log(addressFemale('Тамара'));

// пример

function createPlayer(name) {
	let score = 0;

	return function scoreCount() {
		score++;
		return `${name} - ${score} баллов!`
	}
}

const playerOne = createPlayer('Василий');
const playerTwo = createPlayer('Александр');

console.log(playerOne())
console.log(playerOne())
console.log(playerOne())

console.log(playerTwo())
console.log(playerTwo())
console.log(playerTwo())	
```	

```js
function createCounter() {
  let counter = 0;

  const myFunction = function() {
    counter = counter + 1;
    return counter;
  }

  return myFunction;
}

const increment = createCounter();
const c1 = increment();
const c2 = increment();
const c3 = increment();

console.log(c1, c2, c3); // 1, 2, 3	
```	
	
https://medium.com/@stasonmars/%D0%BF%D0%BE%D0%BD%D0%B8%D0%BC%D0%B0%D0%B5%D0%BC-%D0%B7%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B2-javascript-%D1%80%D0%B0%D0%B7-%D0%B8-%D0%BD%D0%B0%D0%B2%D1%81%D0%B5%D0%B3%D0%B4%D0%B0-c211805b6898	

  **[⬆ Наверх](#top)**
	
	
111. ### <a name="111"></a> Методы и свойства строк и чисел

arr.length - свойство, пишется через точку

toString() - метод, в конце круглые скобки - вызывают этот метод

```js
// strings

const str = 'test';
const arr = [1, 2, 4];
console.log(str.length);
console.log(arr.length); //length - свойство, пишется через точку

console.log(str[2]);

console.log(str);
console.log(str.toUpperCase());
console.log(str.toLowerCase());


// поиск подстроки:

const fruit = 'Some fruit';
console.log(fruit.indexOf('fruit')); //5
console.log(fruit.indexOf('q')); // -1


const logg = 'Hello world';
console.log(logg.slice(6, 11));  // не включая 11(последний) символ
console.log(logg.slice(6));
console.log(logg.slice(-5, -1));


console.log(logg.substring(6, 11));
// принимает аргументы start и end, можно старт задавать больше чем енд но не надо, -6 нельзя использовать


console.log(logg.substr(6, 5)); // с какого и сколько символов нужно вырезать


// numbers

const num = 12.2;
console.log(Math.round(num)); //12
console.log(Math.floor(num));

const test = '12.2px';
console.log(parseInt(test)); // 12 - number
console.log(parseFloat(test)); // 12.2
```
	
Метод `trim()` возвращает строку с вырезанными пробельными символами с её концов. Метод trim() не изменяет значение самой строки.

```js	
var orig = '   foo  ';
console.log(orig.trim()); // 'foo'

// Другой пример, в котором .trim() убирает пробельные символы только с одной стороны.

var orig = 'foo    ';
console.log(orig.trim()); // 'foo'
```	
	
https://developer.mozilla.org/ru/docs/Learn/JavaScript/First_steps/Useful_string_methods
	
  **[⬆ Наверх](#top)**
	
	
112. ### <a name="112"></a> Callback - функции

```js
function first() {
  // Do something
  setTimeout(function() {
    console.log(1);
  }, 500);
}

function second() {
  console.log(2);
}

first();
second();



function learnJS(lang, callback) {
  console.log(`Я учу: ${lang}`);
  callback();
}

function done() {
  console.log('Я прошел этот урок');
}

learnJS('JavaScript', done);
```
	
  **[⬆ Наверх](#top)**

	
113. ### <a name="113"></a> Объекты, деструктуризация объектов (ES6)

```js	
const obj = new Object(); //не используется, лучще создавать с помощью {}

const option = {
  name: 'test',
  width: 1024,
  heigh: 1024,
  colors: {
    border: 'black',
    bg: 'red'
  }
};


console.log(option.name);

delete option.name;
console.log(option);


console.log(option.colors.bg);

console.log(option['colors']['border']);

// деструктуризация для того что бы не создавать вот такие вложенные структуры 


for (let key in option) {
  console.log(`Свойства ${key} имеет значение ${option[key]}`);
}

// Свойство name имеет значение test


for (let key in option) {
  if (typeof(option[key]) === 'object') {
    for (let i in option[key]) {
      console.log(`Свойства ${i} имеет значение ${option[key][i]}`);
    }
  } else {
    console.log(`Свойства ${key} имеет значение ${option[key]}`);
  } 
}


let counter = 0;
for (let key in option) {
  if (typeof(option[key]) === 'object') {
    for (let i in option[key]) {
      console.log(`Свойства ${i} имеет значение ${option[key][i]}`);
      counter++;  // можно убрать...
    }
  } else {
    console.log(`Свойства ${key} имеет значение ${option[key]}`);
    counter++;
  } 
}

console.log(counter);



const option = {
  name: 'test',
  width: 1024,
  heigh: 1024,
  colors: {
    border: 'black',
    bg: 'red'
  },
  makeTest: function() {  //method
    console.log('Test');
  }
};

option.makeTest();


console.log(Object.keys(option)); // обьект превращает в массив

console.log(Object.keys(option).length); // запомнить!

### Деструктуризация 

Деструктурирующее присваивание – это специальный синтаксис, который позволяет нам «распаковать» массивы или объекты в кучу переменных, так как иногда они более удобны. Деструктуризация также прекрасно работает со сложными функциями, которые имеют много параметров, значений по умолчанию и так далее.
	
// деструктуризация обьектов

const {border, bg} = option.colors;
console.log(border);
	
	
```js
let options = {
  title: "Menu",
  width: 100,
  height: 200
};

let {title, width, height} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
```
Если мы хотим присвоить свойство объекта переменной с другим названием, например, свойство options.width присвоить переменной w, то мы можем использовать двоеточие:
```js
let options = {
  title: "Menu",
  width: 100,
  height: 200
};

// { sourceProperty: targetVariable }
let {width: w, height: h, title} = options;

// width -> w
// height -> h
// title -> title

alert(title);  // Menu
alert(w);      // 100
alert(h); 
```
Для потенциально отсутствующих свойств мы можем установить значения по умолчанию, используя "=", как здесь:
```js
let options = {
  title: "Menu"
};

let {width = 100, height = 200, title} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
```
В приведённом ниже коде options хранит другой объект в свойстве size и массив в свойстве items. Шаблон в левой части присваивания имеет такую же структуру, чтобы извлечь данные из них:
```js
let options = {
  size: {
    width: 100,
    height: 200
  },
  items: ["Cake", "Donut"],
  extra: true
};

// деструктуризация разбита на несколько строк для ясности
let {
  size: { // положим size сюда
    width,
    height
  },
  items: [item1, item2], // добавим элементы к items
  title = "Menu" // отсутствует в объекте (используется значение по умолчанию)
} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
alert(item1);  // Cake
alert(item2);  // Donut
```
	
  **[⬆ Наверх](#top)**
	
134. ### <a name="134"></a> Методы Object, Object.prototype

`Метод Object.create()` позволяет создавать новые объекты и соединять их с прототипами существующих объектов.

Для примера можно создать экземпляр объекта job и расширить его.
```js
// Initialize an object with properties and methods
const job = {
	position: 'cashier',
	type: 'hourly',
	isAvailable: true,
	showDetails() {
		const accepting = this.isAvailable ? 'is accepting applications' : "is not currently accepting applications";
		console.log(`The ${this.position} position is ${this.type} and ${accepting}.`);
	}
};
	
// Use Object.create to pass properties
	
const barista = Object.create(job);
barista.position = "barista";
barista.showDetails();
The barista position is hourly and is accepting applications.
```
Объект barista теперь имеет одно свойство – position, но все остальные свойства и методы из job доступны через прототип. Метод Object.create() полезен для хранения кода DRY благодаря минимизации дублирования.


`Метод Object.keys()` создает массив ключей объекта.

Создайте объект и отобразите его массив ключей.
```js
// Initialize an object
const employees = {
	boss: 'Michael',
	secretary: 'Pam',
	sales: 'Jim',
	accountant: 'Oscar'
};
	
// Get the keys of the object
const keys = Object.keys(employees);
console.log(keys);
["boss", "secretary", "sales", "accountant"]
```
	
Метод Object.keys можно использовать для итерации по ключам и значениям объектов.
```js
// Iterate through the keys
Object.keys(employees).forEach(key => {
	let value = employees[key];
	console.log(`${key}: ${value}`);
});
boss: Michael
secretary: Pam
sales: Jim
accountant: Oscar
```
	
Метод Object.keys также позволяет проверить длину объекта.
```js
// Get the length of the keys
const length = Object.keys(employees).length;
console.log(length);
4
```
С помощью свойства length вам удалось подсчитать свойства employees.


`Метод Object.values()` создает массив значений объекта.
```js
// Initialize an object
const session = {
	id: 1,
	time: `26-July-2018`,
	device: 'mobile',
	browser: 'Chrome'
};
// Get all values of the object
const values = Object.values(session);
console.log(values);
[1, "26-July-2018", "mobile", "Chrome"]
```
Методы Object.keys() и Object.values() позволяют возвращать данные объекта.


`Метод Object.entries()` создает вложенный массив пар «ключ-значение» объекта.
```js
// Initialize an object
const operatingSystem = {
	name: 'Ubuntu',
	version: 18.04,
	license: 'Open Source'
};
// Get the object key/value pairs
const entries = Object.entries(operatingSystem);
console.log(entries);
[
["name", "Ubuntu"] ["version", 18.04] ["license", "Open Source"] ]
```
Получив массив пар «ключ-значение», мы можем использовать метод forEach() для прохождения и работы с результатами.
```js
// Loop through the results
entries.forEach(entry => {
	let key = entry[0];
	let value = entry[1];
	console.log(`${key}: ${value}`);
});
name: Ubuntu
version: 18.04
license: Open Source
```
Метод Object.entries() возвращает только свойства экземпляра объекта, а не унаследованные свойства прототипа.


`Метод Object.assign()` копирует значения из одного объекта в другой.

Создайте два объекта и объедините их с помощью этого метода.
```js
// Initialize an object
const name = {
	firstName: 'Philip',
	lastName: 'Fry'
};
// Initialize another object
const details = {
	job: 'Delivery Boy',
	employer: 'Planet Express'
};
// Merge the objects
const character = Object.assign(name, details);
console.log(character);
{firstName: "Philip", lastName: "Fry", job: "Delivery Boy", employer: "Planet Express"}
```
	
Также можно использовать spread оператор (…). В приведенном ниже коде нужно изменить способ объявления character путем слияния объектов name и details.
```js
// Initialize an object
const name = {
	firstName: 'Philip',
	lastName: 'Fry'
};
// Initialize another object
const details = {
	job: 'Delivery Boy',
	employer: 'Planet Express'
};
// Merge the object with the spread operator
const character = {...name, ...details}
console.log(character);
{firstName: "Philip", lastName: "Fry", job: "Delivery Boy", employer: "Planet Express"}
```

`Метод Object.freeze()` предотвращает модификацию свойств и значений объекта и добавление или удаление свойств объекта.
```js
// Initialize an object
const user = {
	username: 'AzureDiamond',
	password: 'hunter2'
};
// Freeze the object
const newUser = Object.freeze(user);
newUser.password = '*******';
newUser.active = true;
console.log(newUser);
{username: "AzureDiamond", password: "hunter2"}
```js
В приведенном выше примере мы попытались переопределить пароль hunter2 с помощью *******, но свойство password осталось прежним. Мы также попытались добавить новое свойство, active, но оно не было добавлено.

Метод Object.isFrozen() позволяет определить, был ли объект заморожен или нет, и возвращает логическое значение.


`Метод Object.seal()` предотвращает добавление новых свойств объекта, но позволяет изменять существующие свойства. Этот метод похож на Object.freeze(). Обновите консоль, прежде чем выполнить нижеприведенный код, чтобы избежать ошибки.
```js
// Initialize an object
const user = {
	username: 'AzureDiamond',
	password: 'hunter2'
};
// Seal the object
const newUser = Object.seal(user);
newUser.password = '*******';
newUser.active = true;
console.log(newUser);
{username: "AzureDiamond", password: "*******"}
```
Новое свойство active не было добавлено в объект, но свойство password было успешно изменено.


`Метод Object.getPrototypeOf()` используется для получения внутреннего скрытого [[Prototype]] объекта, также доступного через свойство __proto__.

В этом примере попробуйте создать массив с доступом к прототипу Array.
```js
const employees = ['Ron', 'April', 'Andy', 'Leslie'];
Object.getPrototypeOf(employees);
[constructor: ƒ, concat: ƒ, find: ƒ, findIndex: ƒ, pop: ƒ, …]
```
В выводе вы увидите, что прототип массива employee имеет доступ к методам прототипов pop, find и других прототипов Array. Чтобы проверить это, протестируйте прототип employees.
```js
Object.getPrototypeOf(employees) === Array.prototype;
true
```
Этот метод может предоставить дополнительную информацию об объекте или обеспечить доступ к прототипу другого объекта.

Существует также связанный с ним метод Object.setPrototypeOf(), который добавляет один прототип к другому объекту. Но вместо этого рекомендуется использовать Object.create(), поскольку он быстрее и эффективнее.	
	
Методы Object:

`Object.assign()` - Создаёт новый объект путём копирования значений всех собственных перечислимых свойств из одного или более исходных объектов в целевой объект.

`Object.create()` - Создаёт новый объект с указанными объектом прототипа и свойствами.

`Object.getPrototypeOf()` - Возвращает прототип указанного объекта.

`Object.is()` - Определяет, являются ли два значения различимыми (то есть, одинаковыми)

`Object.keys()` - Возвращает массив, содержащий имена всех собственных перечислимых свойств переданного объекта.

`Object.setPrototypeOf()` - Устанавливает прототип (т.е. внутреннее свойство [[Prototype]])

`Object.prototype:`

`Object.prototype.hasOwnProperty()` - Возвращает логическое значение, указывающее, содержит ли указанное свойство непосредственно объект, или он унаследовал его по цепочке прототипов.

`Object.prototype.isPrototypeOf()` - Возвращает логическое значение, указывающее, состоит ли указанный объект в цепочке прототипов объекта, на котором был вызван данный метод.

`Object.prototype.toString()` - Возвращает строковое представление объекта.

`Object.prototype.valueOf()` - Возвращает значение примитива указанного объекта.

https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object

  **[⬆ Наверх](#top)**	
	
114. ### <a name="114"></a> Способы создания объекта

- *1. Литеральная нотация*
```js	
var someObject_1 = {};
Пожалуй самый распространенный и простой способ. Добавим свойства и методы

someObject_1.name = "John";
someObject_1.age = 25;
someObject_1.run = function(){
    console.log("run")
}
А теперь тоже самое, но свойства и методы зададим при создании

var someObject_1 = {
    name: "John",
    age: 25,
    run: function(){
        console.log("run");
    }
};
```
	
- *2. Конструктор Object*
	
Данный способ не рекомендуется к применению, и лучше воспользоваться предыдущим. Тем не менее он существует. Но вероятность его встретить крайне мала
```js
var someObject_2 = new Object();
Так же зададим свойства и методы

var someObject_2 = {
    name: "Nick",
    age: 30,
    jump: function(){
        console.log("jump");
    }
};
```
	
- *3. Функция конструктор*
	
Мы можем написать свою функцию конструктор и создавать объекты с помощью оператора new
```js
function SomeObject_3(name, age){
    this.name = name;
    this.age = age;
}
 
SomeObject_3.prototype.run = function(){
    console.log("run");
}
Создадим объект

var someObject_3 = new SomeObject_3("Alex", 20);
```
	
- *4. Метод Object.create()*
	
Есть еще один способ создания объектов — с помощью метода Object.create(). Он не поддерживается в < IE9. Первый параметр обязательный параметр — это прототип создаваемого объекта, и второй необязательный — список свойств объекта. Для того чтобы создать объект без прототипа, необходимо вызвать метод Object.create() c параметром null.
```js
var someObject_4 = Object.create(Object.prototype);
 
// the full analogue of Object.create (Object.prototype) is
var someObject_4 = {};
 
//object without prototype
var someObject_4 = Object.create(null);
```
													
- *5. С помощью классов*
													
Синтаксис ES6 предоставляет писать классы в JavaScript. По своей сути это является аналогом третьего способа - использование функции конструктора. Только с более простой и понятной записью
```js
class SomeObject_4{
     
    constructor(name, age){
        this.name = name;
        this.age = age;
    }
 
    run(){
        console.log("run");
    }
}
Создадим объект, а точнее экземпляр класса

let someObject_4 = new SomeObject_4("Alex", 20);	
```

  **[⬆ Наверх](#top)**
	
115. ### <a name="115"></a> Копирование объекты?

Примитивные типы: строки, числа, логические значения – присваиваются и копируются «по значению».

Например:
```jsx harmony
let message = "Привет!";
let phrase = message;
```
В результате мы имеем две независимые переменные, каждая из которых хранит строку "Привет!".
 
Как копируются Объекты:
 
- пройтись циклом по оригинальному объекту и скопировать каждое свойство : gростой способ копирования объектов
- Object.assign() : Поверхностное копирование объектов, Копируем методы объекта
- JSON.parse(JSON.stringify(object)) : Глубокое копирование объектов
- Spread (…) : Копируем методы объекта, Поверхностное копирование объектов
 
Введение
Как вы уже наверное знаете, оператор назначения не создаёт копию объекта, а только делает отсылку к нему, давайте посмотрим на следующий код:
```jsx harmony
let obj = {
  a: 1,
  b: 2,
};
let copy = obj;

obj.a = 5;
console.log(copy.a);
// Результат 
// a = 5;
```
Тут переменная obj это контейнер для нового объекта. Переменная copy указывает на этот же объект и является своеобразной отсылкой к нему. Так что, просто напросто, объект { a: 1, b: 2, } как бы говорит нам: Есть два способа получить ко мне доступ. Вы можете получить его через переменную obj или через переменную copy, в обоих случаях получите возможность работать со мной и всё, что бы вы не делали этими способами, отобразится на мне.
Сейчас много говорят про иммутабельность и поверьте, вам стоит прислушаться к этим разговорам. Описанный выше метод исключает любую форму иммутабельности и может привести к ошибкам при использовании оригинального объекта при задействовании уже другой части вашего кода.

### Простой и наивный способ копирования объектов
Простой способ копирования объектов заключается в том, что пройтись циклом по оригинальному объекту и скопировать каждое свойство по очереди. Давайте взглянем на такой код:
```jsx harmony
function copy(mainObj) {
  let objCopy = {}; // objCopy будет хранить копию mainObj
  let key;

  for (key in mainObj) {
    objCopy[key] = mainObj[key]; // копирует каждое свойство objCopy
  }
  return objCopy;
}

const mainObj = {
  a: 2,
  b: 5,
  c: {
    x: 7,
    y: 4,
  },
}

console.log(copy(mainObj));
```

Проблемы при таком методе:
objCopy объект имеет другой метод Object.prototype, отличающийся от mainObj прототип метода, который не совсем то, что нам нужно. Нам нужна точная копия оригинального объекта.
Дескрипторы свойств не скопированы. Перезаписываемый дескриптор со значением выставленным на false, будет выставлен на true в объекте objCopy.
Код выше копирует только перечисляемые свойства объекта mainObj.
Если одно из свойств в оригинальном объекте является тоже объектом, то оно будет расшарено и совместно использоваться, как копией, так и оригинальным объектом, заставляя ссылаться соответствующие свойства на один и тот же объект.


Поверхностное копирование объектов
Поверхностно скопированным объектом, можно называть объект, когда исходные top-level (самые первые в иерархии объекта) свойства скопированы без какой-либо отсылки и существует исходное свойство, чьё значение это объект и он скопирован уже как отсылка. А если исходное значение это отсылка к объекту, то он копирует только отсылку к значению целевого объекта.
Поверхностная копия скопирует только top-level свойства, но вложенные объекты будут использоваться между оригиналом, так и копией.

### Object.assign()

Используем метод Object.assign()
Это метод используется для копирования значений всех собственных перечисляемых свойств из одного или нескольких исходных объектов в один целевой объект.
```jsx harmony
let obj = {
  a: 1,
  b: 2,
};
let objCopy = Object.assign({}, obj);
console.log(objCopy);
// Результат - { a: 1, b: 2 }
Отлично, пока что все работает как надо. Мы сделали копию obj. Давайте посмотрим на наличие иммутабельности:
let obj = {
  a: 1,
  b: 2,
};
let objCopy = Object.assign({}, obj);

console.log(objCopy); // результат - { a: 1, b: 2 }
objCopy.b = 89;
console.log(objCopy); // результат - { a: 1, b: 89 }
console.log(obj); // результат - { a: 1, b: 2 }
```
В коде выше, мы изменили значение свойства b в objCopy объекте на 89 и когда мы вывели измененный objCopy объект в консоль, изменения применились только к objCopy. Последняя строчка кода проверяет то, что объект obj до сих пор не тронут и не изменён. Это подразумевает то, что мы успешно создали копию исходного объекта без каких либо отсылок к нему.

Подводные камни Object.assign()
Не так быстро! Пока мы успешно создали копию и все вроде бы отлично работает, вспомните то, что мы обсуждали поверхностное копирование? Давайте посмотрим на пример ниже:
```jsx harmony
let obj = {
  a: 1,
  b: {
    c: 2,
  },
}
let newObj = Object.assign({}, obj);
console.log(newObj); // { a: 1, b: { c: 2} }

obj.a = 10;
console.log(obj); // { a: 10, b: { c: 2} }
console.log(newObj); // { a: 1, b: { c: 2} }

newObj.a = 20;
console.log(obj); // { a: 10, b: { c: 2} }
console.log(newObj); // { a: 20, b: { c: 2} }

newObj.b.c = 30;
console.log(obj); // { a: 10, b: { c: 30} }
console.log(newObj); // { a: 20, b: { c: 30} }
```
// Обратите внимание: newObj.b.c = 30; Читаем дальше почему
Что? Почему obj.b.c = 30?
Отлично, вот мы попались в ловушку с Object.assign(). Object.assign делает только поверхностную копию. А newObj.b и obj.b вместе отсылаются к одному и тому объекту, так как отдельные копии не создавались, а была сделана отсылка к объекту. Любое изменение сделанное на любом свойстве объекта, применится ко всем отсылкам использующим объект. Как это исправить? Читаем дальше, там будет исправление этой проблемы.
Обратите внимание: свойства в цепочке прототипов и неперечисляемые свойства не могут быть скопированы. Как тут:
```jsx harmony
let someObj = {
  a: 2,
}

let obj = Object.create(someObj, { 
  b: {
    value: 2,  
  },
  c: {
    value: 3,
    enumerable: true,  
  },
});

let objCopy = Object.assign({}, obj);
console.log(objCopy); // { c: 3 }
```
someObj находится в цепочке прототипов obj, поэтому он не скопируется.
Свойство b это неперечисляемое свойство.
Свойство c включает в себя дескриптор перечисляемого свойства, что позволяет ему быть скопированным.


Глубокое копирование объектов
Глубокая копия продублирует каждый объект на пути копирования. Оригинал и скопированный объект не будут иметь ничего общего и совместно использоваться не будут, в общем, это будет копия оригинала. А вот и решение проблемы с который мы столкнулись при использовании Object.assign(). Давайте посмотрим.

### JSON.parse(JSON.stringify(object))

Использование *JSON.parse(JSON.stringify(object));*
Этот подход решает предыдущую проблему. Теперь newObj.b это копия, а не отсылка к оригинальному объекту! Вот так делается глубокое копирование объектов. Пример:
```jsx harmony
let obj = { 
  a: 1,
  b: { 
    c: 2,
  },
}

let newObj = JSON.parse(JSON.stringify(obj));

obj.b.c = 20;
console.log(obj); // { a: 1, b: { c: 20 } }
console.log(newObj); // { a: 1, b: { c: 2 } } (Новый нетронутый объект!)
```
Небольшая загвоздка
К сожалению, этот метод нельзя использовать для копирования методов объекта, которые были написаны пользователем вручную.

Копируем методы объекта
Метод это свойство объекта, которое является функцией. Пока что, в примерах, мы не копировали объект с методом. Давайте попробуем это сделать с помощью уже изученных подходов!
```jsx harmony
let obj = {
  name: 'scotch.io',
  exec: function exec() {
    return true;
  },
}

let method1 = Object.assign({}, obj);
let method2 = JSON.parse(JSON.stringify(obj));

console.log(method1); //Object.assign({}, obj)
/* result
{
  exec: function exec() {
    return true;
  },
  name: "scotch.io"
}
*/

console.log(method2); // JSON.parse(JSON.stringify(obj))
/* result
{
  name: "scotch.io"
}
*/
```
Результат показывает нам то, что Object.assign() можно использовать для копирования методов, а JSON.parse(JSON.stringify(obj)), к сожалению, нет.

 
Копирование циклических объектов
Циклические объекты — это объекты, у которых есть свойства, ссылающиеся сами на себя. Давайте применим уже известные методы копирования для создания копий циклических объектов и посмотрим, как они сейчас сработают.
Применяем JSON.parse(JSON.stringify(object))
Давайте попробуем JSON.parse(JSON.stringify(object)):
// Циклический объект
```jsx harmony
let obj = { 
  a: 'a',
  b: { 
    c: 'c',
    d: 'd',
  },
}

obj.c = obj.b;
obj.e = obj.a;
obj.b.c = obj.c;
obj.b.d = obj.b;
obj.b.e = obj.b.c;

let newObj = JSON.parse(JSON.stringify(obj));

console.log(newObj);
```
Вот результат:

В общем, такой подход не работает для циклических объектов.
Используем Object.assign()
Давайте его попробуем:
```jsx harmony
// Циклический объект
let obj = { 
  a: 'a',
  b: { 
    c: 'c',
    d: 'd',
  },
}

obj.c = obj.b;
obj.e = obj.a;
obj.b.c = obj.c;
obj.b.d = obj.b;
obj.b.e = obj.b.c;

let newObj2 = Object.assign({}, obj);

console.log(newObj2);
```
А вот и результат:

Object.assign() отлично работает для поверхностного копирования циклических объектов, но не будет работать для создания глубокой копии. Посмотрите на circular object tree в консоли вашего браузера. Я уверен, что вы найдете много всего интересного в том, что там происходит.

### Spread (…)

Используем элементы *Spread (…)* (Или оператор расширения)
В ES6 есть элементы rest для деструктурирующего присваивания и spread элементы для работы с литерал массивами. Давайте посмотрим на то, как сработает элемент spread на массиве:
```jsx harmony
const array = [
  "a",
  "c",
  "d", {
    four: 4
  },
];
const newArray = [...array];
console.log(newArray);
// Result 
// ["a", "c", "d", { four: 4 }]
```
Использование оператора расширения на свойствах объекта, создаёт копии собственных перечисляемых свойств из исходного объекта в один целевой объект. 
```jsx harmony
let obj = {
  one: 1,
  two: 2,
}

let newObj = { ...obj };
```
Обратите внимание, что этот подход действенен для поверхностной копии.

https://medium.com/@stasonmars/%D0%BA%D0%BE%D0%BF%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2-%D0%B2-javascript-d25c261a7aff

  **[⬆ Наверх](#top)**
	
116. ### <a name="116"></a> Массивы и псевдомассивы, деструктуризация массивов

Массивы обычно описываются как «объекты, подобные спискам»; они представляют собой в основном отдельные объекты, которые содержат несколько значений, хранящихся в списке. Объекты массива могут храниться в переменных и обрабатываться во многом так же, как и любой другой тип значения, причём разница заключается в том, что мы можем получить доступ к каждому значению внутри списка отдельно и делать супер полезные и эффективные вещи со списком, а также делать то же самое для каждого из значений. Представим, что у нас есть список продуктов и их цены, хранящиеся в массиве, и мы хотим их просмотреть и распечатать на счёте-фактуре, общая сумма всех цен и распечатка общей цены внизу.

const arr = [1, 2, 3, 4, 5];

Массив – это особый тип объекта, предназначенный для работы с упорядоченным набором элементов.

Объявление:
```jsx harmony
// квадратные скобки (обычно)
let arr = [item1, item2...];

// new Array (очень редко)
let arr = new Array(item1, item2...);
```
Вызов new Array(number) создаёт массив с заданной длиной, но без элементов.

Свойство length отражает длину массива или, если точнее, его последний цифровой индекс плюс один. Длина корректируется автоматически методами массива.

Если мы уменьшаем length вручную, массив укорачивается.

Чтобы пройтись по элементам массива:

- for (let i=0; i<arr.length; i++) – работает быстрее всего, совместим со старыми браузерами.
- for (let item of arr) – современный синтаксис только для значений элементов (к индексам нет доступа).
- for (let i in arr) – никогда не используйте для массивов!	
	
```js	
const arr = [1, 2, 3, 6, 8];

console.log(arr.length);


const arr = [1, 2, 3, 6, 8];

// arr[99] = 0;
// console.log(arr.length); //100



for (let i = 0; i < arr.length; i++) {
  console.log(arr[i]);
}


// мы можеи использовать такие ключевые слова как break; и continue;

for (let value of arr) {
  console.log(value);
}


const arr = [1, 2, 3, 6, 8];
```

`Псевдомассив` - обьект структура которого совпадает со структурой массива, он будет выглядеть точно так же как массив
одно условие, у таких псевдомассивов не будет вообще никаких методов(не forEach, не filter, не push и pop и join...)
это просто струтура которая хранить данные по порядку.


### Деструктуризация массива*

```js
// у нас есть массив с именем и фамилией
let arr = ["Ilya", "Kantor"]

// деструктурирующее присваивание
// записывает firstName=arr[0], surname=arr[1]
let [firstName, surname] = arr;

alert(firstName); // Ilya
alert(surname);  // Kantor
```			       
			   			       			       
  **[⬆ Наверх](#top)**

			       
135. ### <a name="135"></a> Методы Array, Array.prototype

### Пример
```js
const people = [
  {name: 'Spacy', age: 30, budget: 40000},
  {name: 'Елена', age: 17, budget: 3400},
  {name: 'Игорь', age: 49, budget: 50000},
  {name: 'Михаил', age: 15, budget: 1800},
  {name: 'Василиса', age: 24, budget: 25000},
  {name: 'Виктор', age: 38, budget: 23000}
]


// for

for (let i = 0; i < people.length; i++) {
  console.log(people[i])
}


//for of

for (let person of people) {
  console.log(person)
}



// ForEach


people.forEach(function(person) {
  console.log(person)
})

// сокращенный вариант

people.forEach(person => console.log(person))



// Map

const newPeople = people.map(person => {
  return person.name
})


const newPeople = people.map(person => `${person.name} (${person.age})`)


const newPeople = people.map(person => person.age * 3)

console.log(newPeople)



// Filter

const adults = []
for (let i = 0; i < people.length; i++) {
  if (people[i].age >= 18) {
    adults.push(people[i])
  }
}

console.log(adults)

// Метод filter =>

const adults = people.filter((person) => {
  if (person.age >= 18) {
    return true;
  }
});

console.log(adults)



const adults = people.filter(person => person.age >= 18)

console.log(adults)


// Reduce

let amount = 0
for (let i = 0; i < people.length; i++) {
  amount += people[i].budget
}

console.log(amount)

// reduce

const amount = people.reduce((total, person) => {
  return total + person.budget
}, 0)

// сокращенно

const amount = people.reduce((total, person) => total + person.budget, 0)

console.log(amount)



// Find

const igor = people.find(person => person.name === 'Игорь')

console.log(igor)



// FindIndex

const igorIndex = people.findIndex(person => person.name === 'Игорь')

console.log(igorIndex)


//

const newPeople = people
.filter(person => person.budget > 3000)
.map(person => {
  return {
    info: `${person.name} (${person.age})`,
    budget: person.budget
  }
})


console.log(newPeople)


// reduce

const amount = people
.filter(person => person.budget > 3000)
.map(person => {
  return {
    info: `${person.name} (${person.age})`,
    budget: Math.sqrt(person.budget)
  }
})
.reduce((total, person) => total + person.budget, 0)


console.log(amount)	
```	
		
```js	
// метод forEach - просто перебирает массив

arr.forEach(function(item, i, arr) {
  console.log(`${i}: ${item} внутри массива ${arr}`);
});


// Методы трансформации и перебора:

// методы map, every, some, filter, reduce - берут исходный материал и его модифицыруют

// метод map() - возвращает новый массив, с модифицированными елементами

// метод filter() - отфильтровываем массив по тому критерию который задаем, например оставить только четный числа
// или оставить только те элементы у которых тип данных строка


// Методы массивов:

// split() превращает сроку в массив

const str = prompt('', '');
const products = str.split(', ');
console.log(products);

const str1 = 'Hello my dear';
const prod = str1.split(',');
console.log(prod);

// join() превращает массив в строку

const str = prompt('', '');
const products = str.split(', ');
console.log(products.join('; '));


const arr1 = ['Hello', 'my', 'world'];
console.log(arr1.join(' '));


// sort() - метод сортировки, сортирует элементы которые находятся внутри массива как строки

const str = prompt('', '');
const products = str.split(', ');
products.sort();
console.log(products.join('; '));


const arr2 = [12, 2, 17, 33, 25];
arr2.sort();
console.log(arr2); // [ 12, 17, 2, 25, 33 ] - сортирует как строки - по символьно!


// sort() - сортирует массив правильно, так как мы создали функцию и указали ее в sort(compareNum)
// [ 2, 12, 17, 25, 33 ]

const arr2 = [12, 2, 17, 33, 25];
arr2.sort(compareNum);
console.log(arr2);

function compareNum(a, b) {
  return a - b;
}	
```	
	
Для добавления/удаления элементов:

`push(...items)` – добавляет элементы в конец,

`pop()` – извлекает элемент с конца,

`shift()` – извлекает элемент с начала,

`unshift(...items)` – добавляет элементы в начало.

`splice(pos, deleteCount, ...items)` – начиная с индекса pos, удаляет deleteCount элементов и вставляет items.

`slice(start, end)` – создаёт новый массив, копируя в него элементы с позиции start до end (не включая end).

`concat(...items)` – возвращает новый массив: копирует все члены текущего массива и добавляет к нему items. Если какой-то из items является массивом, тогда берутся его элементы.

Для поиска среди элементов:

`indexOf/lastIndexOf(item, pos)` – ищет item, начиная с позиции pos, и возвращает его индекс или -1, если ничего не найдено.

`includes(value)` – возвращает true, если в массиве имеется элемент value, в противном случае false.

`find/filter(func)` – фильтрует элементы через функцию и отдаёт первое/все значения, при прохождении которых через функцию возвращается true.

`findIndex` похож на find, но возвращает индекс вместо значения.

Для перебора элементов:

`forEach(func)` – вызывает func для каждого элемента. Ничего не возвращает.

Для преобразования массива:

`map(func)` – создаёт новый массив из результатов вызова func для каждого элемента.

`sort(func)` – сортирует массив «на месте», а потом возвращает его.

`reverse()` – «на месте» меняет порядок следования элементов на противоположный и возвращает изменённый массив.

`split/join` – преобразует строку в массив и обратно.

`reduce(func, initial)` – вычисляет одно значение на основе всего массива, вызывая func для каждого элемента и передавая промежуточный результат между вызовами.

Дополнительно:

`Array.isArray(arr`) проверяет, является ли arr массивом.

Обратите внимание, что методы sort, reverse и splice изменяют исходный массив.

Изученных нами методов достаточно в 99% случаев, но существуют и другие.

`arr.some(fn)/arr.every(fn)` проверяет массив.

Функция fn вызывается для каждого элемента массива аналогично map. Если какие-либо/все результаты вызовов являются true, то метод возвращает true, иначе false.

`arr.fill(value, start, end)` – заполняет массив повторяющимися value, начиная с индекса start до end.

`arr.copyWithin(target, start, end)` – копирует свои элементы, начиная со start и заканчивая end, в собственную позицию target (перезаписывает существующие).

	
```jsx harmony
// Наши данные

const presidents = [
	{ first: 'George', last: 'Washington', born: 1732, died: 1799 },
	{ first: 'John', last: 'Adams', born: 1735, died: 1826 },
	{ first: 'Ronald', last: 'Reagan', born: 1911, died: 2004 },
	{ first: 'Gerald', last: 'Ford', born: 1913, died: 2006 },
	{ first: 'Richard', last: 'Nixon', born: 1913, died: 1994 },
	{ first: 'John F.', last: 'Kennedy', born: 1917, died: 1963 },
	{ first: 'Harry S.', last: 'Truman', born: 1884, died: 1972 },
	{ first: 'Grover', last: 'Cleveland', born: 1837, died: 1908 },
	{ first: 'Chester A.', last: 'Arthur', born: 1829, died: 1886 },
	{ first: 'Abraham', last: 'Lincoln', born: 1809, died: 1865 },
	{ first: 'Franklin', last: 'Pierce', born: 1804, died: 1869 },
	{ first: 'Lyndon B.', last: 'Johnson', born: 1908, died: 1973 },
	{ first: 'Dwight D.', last: 'Eisenhower', born: 1890, died: 1969 },
];


const writers = ['Василий, Жуковский', 'Александр, Грибоедов', 'Александр, Пушкин', 'Владимир, Даль',
	'Николай, Языков', 'Федор, Тютчев', 'Николай, Гоголь', 'Алексей, Кольцов', 'Александр, Герцен',
	'Иван, Гончаров', 'Михаил, Лермонтов', 'Пётр, Ершов', 'Алексей, Толстой', 'Даниил, Заточник',
	'Александр, Радищев', 'Евгений, Баратынский', 'Петр, Вяземский', 'Александр, Бестужев-Марлинский',
	'Михаил, Загоскин', 'Сергей, Аксаков', 'Владимир, Одоевский', 'Григорий, Данилевский',
	'Алексей, Писемский', 'Дмитрий, Григорович', 'Яков, Полонский', 'Леонид, Андреев',
	'Валерий, Брюсов', 'Саша, Черный', 'Юрий, Трифонов', 'Федор, Абрамов',
	'Дмитрий, Кедрин', 'Василий, Шукшин'];



// Array.prototype.filter()
// 1. Отфильтровать президентов которые родились в 1700-х годах.

const born1700 = presidents.filter(president => {
	// if (president.born >= 1700 && president.born < 1800) {
	// 	return true;

		// или так

		return (president.born >= 1700 && president.born < 1800);
	})

console.table(born1700)

// Array.prototype.map()
// 2. Создать массив, который содержит только имя и фамилию каждого президента

const firstLast = presidents.map(president => {
	return `${president.first}, ${president.last}`;
})

console.log(firstLast);

// Array.prototype.sort()
// 3. Отсортировать президентов по году рождения - от старшего к младшему

const oldest = presidents.sort((a, b) => {
	if(a.born > b.born) {
		return 1;
	} else {
		return -1;
	}
})

console.table(oldest);

// Array.prototype.reduce()
// 4. Подсчитать общее количество лет жизни всех президентов

const totalLift = presidents.reduce((total, president) => {
	return total + (president.died - president.born);
}, 0);

console.log(totalLift);


// 5. Отсортировать президентов в зависимости от количества прожитых лет (от большего к меньшему)

const presidentsSorted = presidents.sort((a, b) => {
	const aLift = a.died - a.born;
	const bLift = b.died - b.born;
	if(aLift > bLift) {
		return -1;
	} else {
		return 1;
	}

})

console.table(presidentsSorted)

// 6. Создать список названий городов (City) и областей (County) Калифорнии содержащих "San"
// https://en.wikipedia.org/wiki/List_of_cities_and_towns_in_California

// const table = document.querySelector('.sortable');
// const links = Array.from(table.querySelector('tbody').querySelectorAll('a'));
//
// const names = links.map(link => {
// 	return link.textContent;
// }).filter(city => {
// 	return city.includes('San');
// })
//
// console.log(names);


// 7. Упражнение по сортировке
// Отсортировать массив "writers" по фамилии в алфавитном порядке

const writersName = writers.sort((writerA, writerB) => {
	const [firstA, lastA] = writerA.split(', ');
	const [firstB, lastB] = writerB.split(', ');

	return `${lastA > lastB ? 1 : -1}`;
})

console.table(writersName)

// 8. Упражнение по использованию метода Reduce
// Подсчитать - сколько раз встречается каждый элемент в массиве
const data = ['truck', 'car', 'car', 'truck', 'bike', 'walk', 'car', 'van', 'bike',
	'walk', 'car', 'van', 'car', 'truck'];

const dataCount = data.reduce((objCount, transport) => {
	if (!objCount[transport]) {
		objCount[transport] = 0;
	}
	objCount[transport]++;
	return objCount;
}, {truck: 0})

console.log(dataCount);

// 9. Упражнение по использованию методов .foEach и Object.keys();
// Создать массив, который будет содержать только уникальные значения данного массива:
const fruits = ['apples', 'bananas', 'oranges', 'apples', 'grapes', 'bananas', 'peaches',
	'strawberries', 'oranges', 'apricots', 'bananas'];

const uniqueFruits = {};

fruits.forEach((fruit) => {
	uniqueFruits[fruit] = true;
})

console.log(Object.keys(uniqueFruits))
```

```jsx harmony
const people = [
	{ name: 'Станислав', year: 2000 },
	{ name: 'Василий', year: 1986 },
	{ name: 'Александр', year: 1990 },
	{ name: 'Владимир', year: 2004 },
];

const comments = [
	{ text: 'Отличный пост!', id: 523423 },
	{ text: 'Мне нравится', id: 823423 },
	{ text: 'Продолжай в том же духе', id: 2039842 },
	{ text: 'Все аццццтой !!!!!', id: 123523 },
	{ text: 'Нормально', id: 542328 }
];

//## Методы Some и Every

// Array.prototype.some() -> Проверить, что по крайней мере одному из людей исполнилось 16 лет.

const isSixteen = people.some(person => {
	return new Date().getFullYear() - person.year >= 16;
})

console.log(isSixteen)

// Array.prototype.every() -> Проверить, что каждому из людей исполнилось 16 лет.

const everySixteen = people.every(person => {
	return new Date().getFullYear() - person.year >= 16;
})

console.log(everySixteen)

// ## Array.prototype.find() -> Возвращает первый элемент массива, который удовлетворяет нашим требованиям

// Задача: найти комментарий, c номером ID - 823423

const commentId = comments.find(comment => {
	return comment.id === 823423;
})

console.log(commentId)

// ## Array.prototype.findIndex() -> Возвращает индекс первого элемента, который удовлетворяет нашим требованиям

// Задача: удалить из массива комментарий с номером ID 123523
// 1. Находим индекс нужного нам комментария

const commentIndex = comments.findIndex(comment => {
	return comment.id === 123523;
})

// console.log(commentIndex)

// 2. Удаляем комментарий из массива (используем метод spice()) мкттирует массив

// мутирует масств - не использовать =>

// comments.splice(commentIndex, 1);

// console.log(comments)



// 2.1 Удаляем комментарий из массива (используем метод slice() и оператор spread)
// не мутирует массив

// slice() создает новый массив, куда копирует елементы начиная с индекса старт и до end (не включая end)

const commentsOne = comments.slice(0, commentIndex);

const commentsTwo = comments.slice(commentIndex + 1);

console.log(commentsOne);
console.log(commentsTwo);

// используем оператор spread для копирования всех элементов первого и воторого массива в новый массив newComments:

const commentsRight = [...commentsOne, ...commentsTwo];

console.log(commentsRight);
```	

### Методы Массивов
	
```js
// метод forEach - он не возвращает новый массив, он просто берет массив и его перебирает(выводит в консоль, на страницу и тд)


// filter, map, reduse,  - возвращают нам новый массив


// filter - фильтрует элементы внутри массива


const names = ['Ivan', 'Ann', 'Ksenia', 'Voldemort'];

const shortNames = names.filter(function(name) {
  return name.length < 5;
  // тоже самое
  // if (name.length < 5) {
  //   return name;
  // }

});

console.log(shortNames);


// map
// map - берет исходный массив и меняет его элементы, на выходе получается новый массив с измененными даными

const answers = ['IvAn', 'AnnA', 'Hello'];

const result = answers.map(item => item.toLowerCase());

console.log(result);

// если пишем в одной строке все, то без return, но если пишем в 2 и более строки - нужет return

// или вот так, но лучш создавать отдельную переменную, так будет правильней

//лучше так не делать, а создавать новую переменную

let answers = ['IvAn', 'AnnA', 'Hello'];

answers = answers.map(item => item.toLowerCase());

console.log(answers);



// every/some

// every, some   - возвращают булиновые значения

// some - берет массив, перебирает его, и если у нас хоть один элемент подходит по условию - вернет true, если нет - false

const arr = [4, 'wqqf', 'faedaf'];

console.log(arr.some(item => typeof(item) === 'number'));


// every - если все элементы внутри нашего массива подходят по условие только в таком случае будет true, если не все - false

console.log(arr.every(item => typeof(item) === 'number'));



// reduce

// reduce - служит для того что бы схлопывать или собирать массив в одно единое целое

const array = [4, 5, 1, 3, 2, 6];
                //  0     4
                //  4     5
                //  9     1
                //  10    3

const res = array.reduce((sum, current) => sum + current);

console.log(res);



const array = [4, 5, 1, 3, 2, 6];

                //  3 !!!    4
                //  4     5
                //  9     1
                //  10    3

const res = array.reduce((sum, current) => sum + current, 3);  
// 3 - это начальное значение < = 

console.log(res);



const array = ['apple', 'pear', 'plum'];

const res = array.reduce((sum, current) => `${sum}, ${current}`);

console.log(res);


//Пример

//Object.entries(obj) - превращает обьект в массив массивов

//Object.fromEnries(obj) - превращает массив в обьект


const obj = {
  ivan: 'persone',
  ann: 'persone',
  dog: 'animal',
  cat: 'animal'
};

const newArr = Object.entries(obj)
.filter(item => item[1] === 'persone')
.map(item => item[0]);

console.log(newArr);	
```	
	
	
https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array

https://learn.javascript.ru/array-methods

  **[⬆ Наверх](#top)**			       
	
	
117. ### <a name="117"></a> Копирование массивов

```jsx harmony
// У нас есть массив
const students = ['Сергей', 'Станислав', 'Мария', 'Павел'];

// ## Массивы
// Мы хотим создать копию массива.
const group = students;

// Давайте вненсем изменение в новый массив
group[2] = 'Alexander';

// Посмотрим, что у нас получилось
// console.log(students);
// console.log(group);

// У нас проблема! Исходный массив students был также изменен

// Причина заключается в том, что создавая таким образом массив group -
// мы создали ссылку на объект а не копию объекта!
// Оба объекта ссылаются на один и тот же массив.

// И что же делать? Вместо этого давайте создадим копию массива!

// ** Вариант 1 (метод slice)
const group2 = students.slice();
group[2] = 'Artem';
// console.log(group2);
// console.log(students);


// ** Вариант 2 (метод concat)

const group3 = [].concat(students);
// console.log(group3)

// ** Вариант 3 (оператор spread)
const group4 = [...students];
// console.log(group4)

// ** Вариант 4 (метод Array.from())
const group5 = Array.from(students);

// Таким образом мы создаем копию и не меняем исходный массив!
```

  **[⬆ Наверх](#top)**
	
	
118. ### <a name="118"></a> Private and protected свойства Оььекта

### Private and protected свойства

В JavaScript есть два типа полей (свойств и методов) объекта:

- Публичные: доступны отовсюду. Они составляют внешний интерфейс. До этого момента мы использовали только публичные свойства и методы.
- Приватные: доступны только внутри класса. Они для внутреннего интерфейса.

*Защищённые свойства* обычно начинаются с префикса _.

Это не синтаксис языка: есть хорошо известное соглашение между программистами, что такие свойства и методы не должны быть доступны извне. Большинство программистов следуют этому соглашению.

Так что наше свойство будет называться _waterAmount:
```js
class CoffeeMachine {
  _waterAmount = 0;

  set waterAmount(value) {
    if (value < 0) throw new Error("Отрицательное количество воды");
    this._waterAmount = value;
  }

  get waterAmount() {
    return this._waterAmount;
  }

  constructor(power) {
    this._power = power;
  }

}

// создаём новую кофеварку
let coffeeMachine = new CoffeeMachine(100);

// устанавливаем количество воды
coffeeMachine.waterAmount = -10; // Error: Отрицательное количество воды
```

*Приватные свойства* и методы должны начинаться с #. Они доступны только внутри класса.

Например, в классе ниже есть приватное свойство #waterLimit и приватный метод #checkWater для проверки количества воды:
```js
class CoffeeMachine {
  #waterLimit = 200;

  #checkWater(value) {
    if (value < 0) throw new Error("Отрицательный уровень воды");
    if (value > this.#waterLimit) throw new Error("Слишком много воды");
  }
}

let coffeeMachine = new CoffeeMachine();

// снаружи  нет доступа к приватным методам класса
coffeeMachine.#checkWater(); // Error
coffeeMachine.#waterLimit = 1000; // Error
```
	
  **[⬆ Наверх](#top)**
	
	
119. ### <a name="119"></a> Spread оператор (ES6-ES9)
	
`Spread` - разварачивает массив, и обьект, служит для создания новых обьектов и массивов, и для трансформации их в удобные типы данных	
```js
let arr = [3, 5, 1];

alert( Math.max(...arr) );
```
```js
let arr1 = [1, -2, 3, 4];
let arr2 = [8, 3, -8, 1];

alert( Math.max(...arr1, ...arr2) ); // 8
```
```js
let arr1 = [1, -2, 3, 4];
let arr2 = [8, 3, -8, 1];

alert( Math.max(1, ...arr1, 2, ...arr2, 25) ); // 25
```
```js
let arr = [3, 5, 1];
let arr2 = [8, 9, 15];

let merged = [0, ...arr, 2, ...arr2];

alert(merged); // 0,3,5,1,2,8,9,15 (0, затем arr, затем 2, в конце arr2)
```

  **[⬆ Наверх](#top)**
	
	
120. ### <a name="120"></a> Rest оператор и параметры по умолчанию (ES6)

`Rest` - собирает параметры либо в массив, либо в обьект: sum(a, b, ...rest), {name, age, ...address}	
	
*Остаточные параметры «…»*

Если мы хотим не просто получить первые значения, но и собрать все остальные, то мы можем добавить ещё один параметр, который получает остальные значения, используя оператор «остаточные параметры» – троеточие ("..."):
	
```js
const log = function(a, b, ...rest) {
  console.log(a, b, rest);
}

log('basic', 'rest', 'operator', 'usage'); // basic rest [ 'operator', 'usage' ]	
```	
	
```js
let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

alert(name1); // Julius
alert(name2); // Caesar

// Обратите внимание, что `rest` является массивом.
alert(rest[0]); // Consul
alert(rest[1]); // of the Roman Republic
alert(rest.length); // 2
```
Переменная rest является массивом из оставшихся элементов. Вместо rest можно использовать любое другое название переменной, просто убедитесь, что перед переменной есть три точки и она стоит на последнем месте в деструктурирующем присваивании.
```js
let options = {
  title: "Menu",
  height: 200,
  width: 100
};

// title = свойство с именем title
// rest = объект с остальными свойствами
let {title, ...rest} = options;

// сейчас title="Menu", rest={height: 200, width: 100}
alert(rest.height);  // 200
alert(rest.width); 
```
```js
function showName(firstName, lastName, ...titles) {
  alert( firstName + ' ' + lastName ); // Юлий Цезарь

  // Оставшиеся параметры пойдут в массив
  // titles = ["Консул", "Император"]
  alert( titles[0] ); // Консул
  alert( titles[1] ); // Император
  alert( titles.length ); // 2
}

showName("Юлий", "Цезарь", "Консул", "Император");
```

### Параметры по умолчанию
	
С появлением в ES2015 параметров по умолчанию стало возможным обходиться без проверки параметров в теле функции. Так, в приведённом выше примере достаточно в заголовке функции указать 1 в качестве значения по умолчанию для параметра b:

```js	
function multiply(a, b = 1) {
  return a*b;
}

multiply(5, 2); // 10
multiply(5); // 5
multiply(5, undefined); // 5
```	
	
  **[⬆ Наверх](#top)**
	
121. ### <a name="121"></a> Контекст выполнения. Лексическое окружение

# Контекст выполнения

Контекст выполнения (execution context) - это окружение, в котором выполняется код.

Есть три типа контекстов функции

* Глобальный контекст выполнения. Это базовый, используемый по умолчанию контекст выполнения. Если некий код находится не внутри какой-нибудь функции, значит этот код принадлежит глобальному контексту. Глобальный контекст характеризуется наличием глобального объекта, которым, в случае с браузером, является объект `window`, и тем, что ключевое слово `this` указывает на этот глобальный объект. В программе может быть лишь один глобальный контекст.
* Контекст выполнения функции. Каждый раз, когда вызывается функция, для неё создаётся новый контекст, даже если функция вызывает саму себя (рекурсия). В программе может одновременно присутствовать множество контекстов выполнения функций. При создании нового контекста выполнения функции он проходит через определённую последовательность шагов, о которой мы поговорим ниже.
* Контекст выполнения функции `eval`. Код, выполняемый внутри функции `eval`, также имеет собственный контекст выполнения. Однако функцией `eval` пользуются очень редко, поэтому здесь мы об этом контексте выполнения говорить не будем.

**Стек вызовов** (call stack) или **стек выполнения** (execution stack) - стек для хранения контекстов вызованных функций.

**Стек** - это структура данных, в которой элементы упорядочены так, что последний элемент, который попадает в стек, выходит из него первым (LIFO: last in, first out). Стек похож на стопку книг: та книга, которую мы кладём последней, находится сверху.

Когда JS-движок начинает обрабатывать скрипт, движок создаёт глобальный контекст выполнения и помещает его в текущий стек. При обнаружении команды вызова функции движок создаёт новый контекст выполнения для этой функции и помещает его в верхнюю часть стека.

Движок выполняет функцию, контекст выполнения которой находится в верхней части стека. Когда работа функции завершается, её контекст извлекается из стека и управление передаётся тому контексту, который находится в предыдущем элементе стека.

Перед выполнением JavaScript-кода создаётся контекст выполнения. В процессе его создания выполняются три действия:

1. Определяется значение `this` и осуществляется привязка `this` (this binding).
2. Создаётся компонент `LexicalEnvironment` (лексическое окружение).
3. Создаётся компонент `VariableEnvironment` (окружение переменных).

Концептуально контекст выполнения можно представить так:

```js
ExecutionContext = {
  ThisBinding = <this value>,
  LexicalEnvironment = { ... },
  VariableEnvironment = { ... },
}
```

Жизненный цикл контекста имеет два этапа - этап создания и этап выполнения.

## Привязка this

В глобальном контексте выполнения `this` содержит ссылку на глобальный объект (как уже было сказано, в браузере это объект `window`).

В контексте выполнения функции значение `this` зависит от того, как именно была вызвана функция. Если она вызвана в виде метода объекта, тогда значение `this` привязано к этому объекту. В других случаях `this` привязывается к глобальному объекту или устанавливается в `undefined` (в строгом режиме).

## Лексическое окружение

**Лексическое окружение** - это структура, которая хранит сведения о соответствии идентификаторов и переменных. Под «идентификатором» здесь понимается имя переменной или функции, а под «переменной» - ссылка на конкретный объект (в том числе — на функцию) или примитивное значение.

В лексическом окружении имеется **два компонента**:

1. _Environment Record_ – объект, в котором как свойства хранятся все локальные переменные (а также некоторая другая информация, такая как значение `this`).
2. Ссылка на внешнее окружение. Наличие такой ссылки говорит о том, что у лексического окружения есть доступ к родительскому лексическому окружению (области видимости).

"Переменная" – это просто свойство специального внутреннего объекта: Environment Record. «Получить или изменить переменную», означает, «получить или изменить свойство этого объекта».

Именно из-за формирования записи окружения и выделения памяти под переменные до выполнения кода к ним можно обращаться до их объявления в программе. Такое поведения называется \*\*“всплытие”\*\*или **hoisting**

Однако, важно обратить внимание на то, что для переменных `let` и `const` есть некоторые отличия от `var` переменных в механизме всплытия. Например, если обратиться к переменным `let` и `const` до их объявления, то возникнет ошибка `ReferenceError`, в отличие от переменной `var`, значение которой в таком случае отобразится как `undefined`.

Такая ошибка `ReferenceError` из-за попытки получить или установить значение `let`  или `const` переменной до её объявления называется ошибкой **“Временной мертвой зоны” (Temporal Dead Zone (TDZ) error).**

Временная мертвая зона заканчивается именно тогда, когда **само выполнение кода** доберется до объявления переменной.

```js
console.log(typeof foo); // Uncaught ReferenceError: foo is not defined
console.log(typeof aVariableThatDoesNotExist); // undefined
let foo;
```

В случае с необъявленной переменной `aVariableThatDoesNotExist`, которой не существует, оператор покажет `undefined`. А в случае с объявленной `foo` возникнет ошибка, так как эта переменная объявлена, но запрошена во время действия временной мертвой зоны.

Существует **два типа лексических окружений**:

1. Глобальное окружение (или глобальный контекст выполнения) — это лексическое окружение, у которого нет внешнего окружения. Ссылка глобального окружения на внешнее окружение представлена значением `null`. В глобальном окружении (в записи окружения) доступны встроенные сущности языка (такие, как `Object`, `Array`, и так далее), которые связаны с глобальным объектом, там же находятся и глобальные переменные, определённые пользователем. Значение `this` в этом окружении указывает на глобальный объект.
2. Окружение функции, в котором, в записи окружения, хранятся переменные, объявленные пользователем. Ссылка на внешнее окружение может указывать как на глобальный объект, так и на внешнюю по отношении к рассматриваемой функции функцию.

### Блоки кода

Мы также можем использовать «простые» блоки кода `{...}`, чтобы изолировать переменные в «локальной области видимости».

```js
{
    let foo = 'foo'

    // foo
    console.log(foo)
}

// здесь также будет ошибка
console.log(foo)

{
    let foo = 'foo'
}
```

### **IIFE**

В прошлом в JavaScript не было лексического окружения на уровне блоков кода.

Так что программистам пришлось что-то придумать. И то, что они сделали, называется «immediately-invoked function expressions» (аббревиатура IIFE), что означает функцию, запускаемую сразу после объявления.

Это не то, что мы должны использовать сегодня, но, так как вы можете встретить это в старых скриптах, полезно понимать принцип работы.

```js
(function() {

  let message = "Hello";

  alert(message); // Hello

})();
```

Подробнее: [https://learn.javascript.ru/closure#iife](https://learn.javascript.ru/closure#iife).

## **Окружение переменных**

Окружение переменных (Variable Environment) — это тоже лексическое окружение, запись окружения которого хранит привязки, созданные посредством команд объявления переменных (`VariableStatement`) в текущем контексте выполнения.

Так как окружение переменных также является лексическим окружением, оно обладает всеми вышеописанными свойствами лексического окружения.

В ES6 существует одно различие между компонентами `LexicalEnvironment` и `VariableEnvironment`. Оно заключается в том, что первое используется для хранения объявлений функций и переменных, объявленных с помощью ключевых слов `let` и `const`, а второе — только для хранения привязок переменных, объявленных с использованием ключевого слова `var`.

## Объект arguments

`arguments` - это локальная переменная в любой функции, кроме стрелочных, содержащая параметры функции. Представляет собой итерируемый объект, похожий на массив.

Можно обращаться в параметрам по их индексу, начиная с нуля. Также у объекта есть свойство `length`, которое позволяет определить количество аргументов.

```js
function () {
    console.log(arguments)
}
```

Начиная с ES6 более предпочтительным споособом по сравнению с `arguments` является синтаксис **rest parameters**:

```js
function (...args) {
    console.log(args)
}
```

## Замыкание

**Замыкание** — это комбинация функции и лексического окружения, в котором эта функция была определена. Другими словами, замыкание даёт вам доступ кобласти видимости  внешней функции из внутренней функции. В JavaScript замыкания создаются каждый раз при создании функции, во время её создания.

```js
let name = "John";

function sayHi() {
  alert("Hi, " + name);
}

name = "Pete";

// выведет "Hi, Pete"
sayHi();
```

## Источники

* [https://habr.com/ru/company/ruvds/blog/422089/](https://habr.com/ru/company/ruvds/blog/422089/)
* [https://blog.bitsrc.io/understanding-execution-context-and-execution-stack-in-javascript-1c9ea8642dd0](https://blog.bitsrc.io/understanding-execution-context-and-execution-stack-in-javascript-1c9ea8642dd0)
* [http://jsflow.org/docs/exec-context-fundamentals/](http://jsflow.org/docs/exec-context-fundamentals/)
* [https://developer.mozilla.org/ru/docs/Web/JavaScript/Closures](https://developer.mozilla.org/ru/docs/Web/JavaScript/Closures)


  **[⬆ Наверх](#top)**
	
122. ### <a name="122"></a> 
	
	
  **[⬆ Наверх](#top)**
	
123. ### <a name="123"></a> События и их обработчики

Событие – это сигнал от браузера о том, что что-то произошло. Все DOM-узлы подают такие сигналы (хотя события бывают и не только в DOM).	
Событию можно назначить обработчик, то есть функцию, которая сработает, как только событие произошло.
	
	
`Есть три способа назначения обработчиков событий:`

- Атрибут HTML: onclick="...".
HTML-атрибуты используются редко потому, что JavaScript в HTML-теге выглядит немного странно. К тому же много кода там не напишешь.
	
- DOM-свойство: elem.onclick = function.
DOM-свойства вполне можно использовать, но мы не можем назначить больше одного обработчика на один тип события. Во многих случаях с этим ограничением можно мириться.	
	
- Специальные методы: elem.addEventListener(event, handler[, phase]) для добавления, removeEventListener для удаления.
Последний способ самый гибкий, однако нужно писать больше всего кода. Есть несколько типов событий, которые работают только через него, к примеру transitionend и DOMContentLoaded. Также addEventListener поддерживает объекты в качестве обработчиков событий. В этом случае вызывается метод объекта handleEvent.	

Не важно, как вы назначаете обработчик – он получает объект события первым аргументом. Этот объект содержит подробности о том, что произошло.	
	

Именно благодаря обработчикам JavaScript-код может реагировать на действия пользователя.	
	
1. Использование атрибута HTML
	
Обработчик может быть назначен прямо в разметке, в атрибуте, который называется on<событие>.
```js
<input value="Нажми меня" onclick="alert('Клик!')" type="button">	
```
	
Атрибут HTML-тега – не самое удобное место для написания большого количества кода, поэтому лучше создать отдельную JavaScript-функцию и вызвать её там.
```js
<script>
  function countRabbits() {
    for(let i=1; i<=3; i++) {
      alert("Кролик номер " + i);
    }
  }
</script>

<input type="button" onclick="countRabbits()" value="Считать кроликов!">	
```
	
2. Использование свойства DOM-объекта
	
Можно назначать обработчик, используя свойство DOM-элемента on<событие>.
	
```js
const btn = document.querySelector('button');

btn.onclick = function() {  
   alert('Click');
};	
```	
	
```js
<input id="elem" type="button" value="Нажми меня!">
<script>
  elem.onclick = function() {
    alert('Спасибо');
  };
</script>	
```
	
*Эти два примера кода работают одинаково:*

`Только HTML:`
```js
<input type="button" onclick="alert('Клик!')" value="Кнопка">
```
	
`HTML + JS:`
```js
<input type="button" id="button" value="Кнопка">
<script>
  button.onclick = function() {
    alert('Клик!');
  };
</script>
```
	
Так как у элемента DOM может быть только одно свойство с именем onclick, то назначить более одного обработчика так нельзя.

В примере ниже назначение через JavaScript перезапишет обработчик из атрибута:
```js
<input type="button" id="elem" onclick="alert('Было')" value="Нажми меня">
<script>
  elem.onclick = function() { // перезапишет существующий обработчик
    alert('Станет'); // выведется только это
  };
</script>	
```
	
Кстати, обработчиком можно назначить и уже существующую функцию:
```js
function sayThanks() {
  alert('Спасибо!');
}

elem.onclick = sayThanks;
```	
Убрать обработчик можно назначением elem.onclick = null.	

3. addEventListener

```js
const btn = document.querySelector('button');
	
btn.addEventListener('click', () => {
  alert('Click');
});

btn.addEventListener('click', () => {
  alert('Second click');
});	
```
	
// Самый правильный способ для того что бы назначать обработчик событий один и тот же сразу на несколько элементов
```js
const btns = document.querySelectorAll('button');
	
const deleteElement = (e) => {
  console.log(e.target);
  console.log(e.type);
};

btns.forEach(btn => {
  btn.addEventListener('click', deleteElement, {once: false});
});	
```
	
// Всплытие событий - это когда обработчик событий сначало срабатывает на самом вложенном элементе, затем на родителе и так выше и выше
```js
let i = 0;
const deleteElement = (e) => {
  console.log(e.currentTarget); // редко используют

  console.log(e.target);
  console.log(e.type);

};

btn.addEventListener('click', deleteElement);
overlay.addEventListener('click', deleteElement);	
```
	
// как отменить обработчик событий
```js
const link = document.querySelector('a');

link.addEventListener('click', (event) => {
  event.preventDefault();
	
  console.log(event.target);	
});
	
// или так вот

link.addEventListener('click', function(event) {
  event.preventDefault();

  console.log(event.target);
});	
```	
	
Фундаментальный недостаток описанных выше способов назначения обработчика –- невозможность повесить несколько обработчиков на одно событие.	

```js	
element.addEventListener(event, handler[, options]);
```
	
`event` - Имя события, например "click".
`handler` - Ссылка на функцию-обработчик.
`options`
Дополнительный объект со свойствами:
- once: если true, тогда обработчик будет автоматически удалён после выполнения.
- capture: фаза, на которой должен сработать обработчик, подробнее об этом будет рассказано в главе Всплытие и погружение. Так исторически сложилось, что options может быть false/true, это то же самое, что {capture: false/true}.
- passive: если true, то указывает, что обработчик никогда не вызовет preventDefault().
	
	
Для удаления обработчика следует использовать removeEventListener:
```js
element.removeEventListener(event, handler[, options]);	
```
```js	
function handler() {
  alert( 'Спасибо!' );
}

input.addEventListener("click", handler);
// ....
input.removeEventListener("click", handler);	
```
	
`Метод addEventListener позволяет добавлять несколько обработчиков на одно событие одного элемента, например:`
```js
<input id="elem" type="button" value="Нажми меня"/>

<script>
  function handler1() {
    alert('Спасибо!');
  };

  function handler2() {
    alert('Спасибо ещё раз!');
  }

  elem.onclick = () => alert("Привет");
  elem.addEventListener("click", handler1); // Спасибо!
  elem.addEventListener("click", handler2); // Спасибо ещё раз!
</script>
```
	
### Объект события

Когда происходит событие, браузер создаёт объект события, записывает в него детали и передаёт его в качестве аргумента функции-обработчику.

Пример ниже демонстрирует получение координат мыши из объекта события:
```js
<input type="button" value="Нажми меня" id="elem">

<script>
  elem.onclick = function(event) {
    // вывести тип события, элемент и координаты клика
    alert(event.type + " на " + event.currentTarget);
    alert("Координаты: " + event.clientX + ":" + event.clientY);
  };
</script>
```
	
Некоторые свойства объекта event:

`event.type` - Тип события, в данном случае "click".
`event.currentTarget` - Элемент, на котором сработал обработчик. Значение – обычно такое же, как и у this, но если обработчик является функцией-стрелкой или при помощи bind привязан другой объект в качестве this, то мы можем получить элемент из event.currentTarget.
`event.clientX / event.clientY` - Координаты курсора в момент клика относительно окна, для событий мыши.

`Объект события доступен и в HTML`
```js
<input type="button" onclick="alert(event.type)" value="Тип события">	
```
	
### Объект-обработчик: handleEvent
	
Мы можем назначить обработчиком не только функцию, но и объект при помощи addEventListener. В этом случае, когда происходит событие, вызывается метод объекта handleEvent.
```js
<button id="elem">Нажми меня</button>

<script>
  elem.addEventListener('click', {
    handleEvent(event) {
      alert(event.type + " на " + event.currentTarget);
    }
  });
</script>
```	
Как видим, если addEventListener получает объект в качестве обработчика, он вызывает object.handleEvent(event), когда происходит событие.

Мы также можем использовать класс для этого:
```js
<button id="elem">Нажми меня</button>

<script>
  class Menu {
    handleEvent(event) {
      switch(event.type) {
        case 'mousedown':
          elem.innerHTML = "Нажата кнопка мыши";
          break;
        case 'mouseup':
          elem.innerHTML += "...и отжата.";
          break;
      }
    }
  }

  let menu = new Menu();
  elem.addEventListener('mousedown', menu);
  elem.addEventListener('mouseup', menu);
</script>	
```

  **[⬆ Наверх](#top)**
	
124. ### <a name="124"></a> Async, defer, динамические скрипты

`Тег script:`
Программы на JavaScript могут быть вставлены в любое место HTML-документа с помощью тега <script>.
Для добавления кода JavaScript на страницу используется тег <script>
Скрипт во внешнем файле можно вставить с помощью <script src="path/to/script.js"></script>
    
Аттрибуты async, defer:

`defer:`
Атрибут defer сообщает браузеру, что он должен продолжать обрабатывать страницу и загружать скрипт в фоновом режиме, а затем запустить этот скрипт, когда он загрузится.

- Скрипты с defer никогда не блокируют страницу.
- Скрипты с defer всегда выполняются, когда дерево DOM готово, но до события DOMContentLoaded.

`async:`
Атрибут async означает, что скрипт абсолютно независим:

- Страница не ждёт асинхронных скриптов, содержимое обрабатывается и отображается.
- Событие DOMContentLoaded и асинхронные скрипты не ждут друг друга:
  1) DOMContentLoaded может произойти как до асинхронного скрипта (если асинхронный скрипт завершит загрузку после того, как страница будет готова),
  2) …так и после асинхронного скрипта (если он короткий или уже содержится в HTTP-кеше)
- Остальные скрипты не ждут async, и скрипты c async не ждут другие скрипты.
 
 Так что если у нас есть несколько скриптов с async, они могут выполняться в любом порядке. То, что первое загрузится – запустится в первую очередь
 
1)Содержимое страницы отображается сразу же : async его не блокирует.
2)DOMContentLoaded может произойти как до, так и после async, никаких гарантий нет.
3)Асинхронные скрипты не ждут друг друга. Меньший скрипт small.js идёт вторым, но скорее всего загрузится раньше long.js, поэтому и запустится первым. То есть, скрипты выполняются в порядке загрузки.

https://learn.javascript.ru/script-async-defer

  **[⬆ Наверх](#top)**
	
125. ### <a name="125"></a> typeof - как определить тип значения?

Оператор typeof возвращает тип аргумента. Это полезно, когда мы хотим обрабатывать значения различных типов по-разному или просто хотим сделать проверку.

У него есть две синтаксические формы:
```jsx harmony
Синтаксис оператора: typeof x.
Синтаксис функции: typeof(x).
```
Другими словами, он работает со скобками или без скобок. Результат одинаковый.

Вызов typeof x возвращает строку с именем типа:
```jsx harmony
typeof undefined // "undefined"

typeof 0 // "number"

typeof 10n // "bigint"

typeof true // "boolean"

typeof "foo" // "string"

typeof Symbol("id") // "symbol"

typeof Math // "object"  (1)

typeof null // "object"  (2)

typeof alert // "function"  (3)
```

Последние три строки нуждаются в пояснении:

Math — это встроенный объект, который предоставляет математические операции и константы. Мы рассмотрим его подробнее в главе Числа. Здесь он служит лишь примером объекта.

Результатом вызова typeof null является "object". Это официально признанная ошибка в typeof, ведущая начало с времён создания JavaScript и сохранённая для совместимости. Конечно, null не является объектом. Это специальное значение с отдельным типом.

Вызов typeof alert возвращает "function", потому что alert является функцией. Мы изучим функции в следующих главах, где заодно увидим, что в JavaScript нет специального типа «функция». Функции относятся к объектному типу. Но typeof обрабатывает их особым образом, возвращая "function". Так тоже повелось от создания JavaScript. Формально это неверно, но может быть удобным на практике.

  **[⬆ Наверх](#top)**
	
126. ### <a name="126"></a> Почему у переменных примитивного типа данных есть методы? Что такое Autoboxing?

Каждый примитив имеет свой собственный «объект-обёртку», которые называются: String, Number, Boolean и Symbol. Таким образом, они имеют разный набор методов.

К примеру, существует метод str.toUpperCase(), который возвращает строку в верхнем регистре.

Вот, как он работает:
```jsx harmony
let str = "Привет";

alert( str.toUpperCase() ); // ПРИВЕТ
```
Очень просто, не правда ли? Вот, что на самом деле происходит в str.toUpperCase():

Строка str – примитив. В момент обращения к его свойству, создаётся специальный объект, который знает значение строки и имеет такие полезные методы, как toUpperCase().

Этот метод запускается и возвращает новую строку (показывается в alert).
Специальный объект удаляется, оставляя только примитив str.
Получается, что примитивы могут предоставлять методы, и в то же время оставаться «лёгкими».

### Автоупаковка (autoboxing)

Интересно, что конструктором как примитивных строк, так и объекта является функция String. Еще интереснее, что вы можете вызвать .constructor примитивной строки (и это при том, что мы уже рассмотрели, что примитивные типы не могут иметь методы!).

```jsx harmony
const pet = new String("dog")
pet.constructor === String; // true
String("dog").constructor === String; // true
```
Этот процесс называется автоупаковкой (autoboxing). Когда вы пытаетесь вызвать свойство или метод для определенных примитивных типов, JavaScript преобразует его во временный объект-оболочку и получает доступ к его свойству или методу, не затрагивая сам оригинал.
```jsx harmony
const foo = "bar";
foo.length; // 3
foo === "bar"; // true
```
В приведенном выше примере, чтобы получить доступ к свойству length, JavaScript упаковывает foo в объект-оболочку, получает доступ к свойству length объекта-оболочки, а после уничтожает его. Это делается без изменения foo (foo по-прежнему является примитивной строкой).
Это также объясняет, почему JavaScript не возмущается, когда вы пытаетесь присвоить свойство примитивному типу, потому что присвоение выполняется на временном объекте-оболочке, а не на самом примитивном типе.
```jsx harmony
const foo = 42;
foo.bar = "baz"; // Присвоение, выполняемое на объекте-оболочке
foo.bar; // undefined
```
Он будет возмущаться, если вы попробуете проделать это с примитивным типом, не имеющим объект-оболочку, таким как undefined или null.
```jsx harmony
const foo = null;
foo.bar = "baz"; // Uncaught TypeError: Cannot set property 'bar' of null
```

  **[⬆ Наверх](#top)**
	
127. ### <a name="127"></a> Сборщик мусора в JS?

Основной алгоритм сборки мусора – «алгоритм пометок» (англ. «mark-and-sweep»).

Согласно этому алгоритму, сборщик мусора регулярно выполняет следующие шаги:

- Сборщик мусора «помечает» (запоминает) все корневые объекты.
- Затем он идёт по их ссылкам и помечает все найденные объекты.
- Затем он идёт по ссылкам помеченных объектов и помечает объекты, на которые есть ссылка от них. Все объекты запоминаются, чтобы в будущем не посещать один и тот же объект дважды.
- …И так далее, пока не будут посещены все ссылки (достижимые от корней).
- Все непомеченные объекты удаляются.

Интерпретаторы JavaScript применяют множество оптимизаций, чтобы сборка мусора работала быстрее и не влияла на производительность.

Вот некоторые из оптимизаций:

- Сборка по поколениям (Generational collection) – объекты делятся на «новые» и «старые». Многие объекты появляются, выполняют свою задачу и быстро умирают, их можно удалять более агрессивно. Те, которые живут достаточно долго, становятся «старыми» и проверяются реже.
- Инкрементальная сборка (Incremental collection) – если объектов много, то обход всех ссылок и пометка достижимых объектов может занять значительное время и привести к видимым задержкам выполнения скрипта. Поэтому интерпретатор пытается организовать сборку мусора поэтапно. Этапы выполняются по отдельности один за другим. Это требует дополнительного учёта для отслеживания изменений между этапами, но зато теперь у нас есть много крошечных задержек вместо одной большой.
- Сборка в свободное время (Idle-time collection) – чтобы уменьшить возможное влияние на производительность, сборщик мусора старается работать только во время простоя процессора.

Главное, что нужно знать:

- Сборка мусора выполняется автоматически. Мы не можем ускорить или предотвратить её.
- Объекты сохраняются в памяти, пока они достижимы.
- Если на объект есть ссылка – вовсе не факт, что он является достижимым (из корня): набор взаимосвязанных объектов может стать недоступен в целом, как мы видели в примере выше.	
	
https://learn.javascript.ru/garbage-collection	
	
  **[⬆ Наверх](#top)**
	
128. ### <a name="128"></a> Временная мертвая зона

Попросту говоря: следующий код выбросит ошибку.
```jsx harmony
there = 'там обитают'
// <- ReferenceError: there не определена
let there = 'драконы'
```
Если в коде попробовать обратиться к there до объявления let there, то программа вызовет ошибку. Объявление метода, который ссылается на there до определения последнего — это не страшно, при условии, что метод не выполняется, пока there находится в ВМЗ, а there будет находиться в ВМЗ, пока мы не дойдем до оператора let there (хотя область видимости уже началась). Этот фрагмент кода не вызовет ошибку, поскольку return there не выполняется до тех пор, пока there не выйдет из ВМЗ.
```jsx harmony
function readThere () {
  return there
}
let there = 'драконы'
console.log(readThere())
// <- 'драконы'
```
Но этот фрагмент кода вызовет, поскольку обращение к there происходит до выхода из ВМЗ для there.
```jsx harmony
function readThere () {
  return there
}
console.log(readThere())
// ReferenceError: there не определена
let there = 'драконы'
```
Заметьте, что даже если при первом объявлении there не присваивать ей значения, семантика для этих примеров не изменится. Код ниже всё ещё выкидывает ошибку, поскольку мы по-прежнему пытаемся обратиться к there до выхода из ВМЗ.
```jsx harmony
function readThere () {
  return there
}
console.log(readThere())
// ReferenceError: there не определяется
let there
```
Этот код всё ещё работает, поскольку мы по-прежнему выходим из ВМЗ до какого-либо обращения к there.
```jsx harmony
function readThere () {
  return there
}
let there
console.log(readThere())
// <- undefined
```
Единственная хитрость, о которой стоит помнить (когда дело касается ВМЗ), что функции до своего первого выполнения действуют как «чёрные ящики», поэтому вполне нормально размещать there внутри функций, которые не выполняются, пока мы не выйдем из ВМЗ.

Весь смысл ВМЗ — легче вылавливать ошибки там, где обращение к переменной до её объявления приводит к неожиданностям. Это зачастую происходило в ES5 из-за поднятия и непродуманных соглашений о стиле кода. Учтите, что поднятие применяется и к let тоже — это значит, что переменные будут созданы, когда мы зайдем в область видимости (и ВМЗ появится), но они будут недоступны до тех пор, пока выполнение кода не дойдёт до места фактического объявления переменной, и в этот момент мы выходим из ВМЗ и вправе делать с переменной что угодно.

  **[⬆ Наверх](#top)**
	
129. ### <a name="129"></a> Всплытие событий, event bubbling
	
Когда на элементе происходит событие, обработчики сначала срабатывают на нём, потом на его родителе, затем выше и так далее, вверх по цепочке предков.

Например, есть 3 вложенных элемента FORM > DIV > P с обработчиком на каждом:
```js
<form onclick="alert('form')">FORM
  <div onclick="alert('div')">DIV
    <p onclick="alert('p')">P</p>
  </div>
</form>
	
Клик по внутреннему <p> вызовет обработчик onclick:
1. Сначала на самом <p>.
2. Потом на внешнем <div>.
3. Затем на внешнем <form>.
4. И так далее вверх по цепочке до самого document.
```
	
При наступлении события – самый глубоко вложенный элемент, на котором оно произошло, помечается как «целевой» (event.target).

- Затем событие сначала двигается вниз от корня документа к event.target, по пути вызывая обработчики, поставленные через addEventListener(...., true), где true – это сокращение для {capture: true}.
- Далее обработчики вызываются на целевом элементе.
- Далее событие двигается от event.target вверх к корню документа, по пути вызывая обработчики, поставленные через on<event> и addEventListener без третьего аргумента или с третьим аргументом равным false.
 
Каждый обработчик имеет доступ к свойствам события event:

- event.target – самый глубокий элемент, на котором произошло событие.
- event.currentTarget (=this) – элемент, на котором в данный момент сработал обработчик (тот, на котором «висит» конкретный обработчик)
- event.eventPhase – на какой фазе он сработал (погружение=1, фаза цели=2, всплытие=3).
 
Любой обработчик может остановить событие вызовом event.stopPropagation(), но делать это не рекомендуется, так как в дальнейшем это событие может понадобиться, иногда для самых неожиданных вещей.

В современной разработке стадия погружения используется очень редко, обычно события обрабатываются во время всплытия. И в этом есть логика.
 
### Стандарт DOM Events описывает 3 фазы прохода события:

- Фаза погружения (capturing phase) – событие сначала идёт сверху вниз.
- Фаза цели (target phase) – событие достигло целевого(исходного) элемента.
- Фаза всплытия (bubbling stage) – событие начинает всплывать.

### Прекращение всплытия
	
Всплытие идёт с «целевого» элемента прямо наверх. По умолчанию событие будет всплывать до элемента <html>, а затем до объекта document, а иногда даже до window, вызывая все обработчики на своём пути.

Но любой промежуточный обработчик может решить, что событие полностью обработано, и остановить всплытие.

Для этого нужно вызвать метод event.stopPropagation().

Например, здесь при клике на кнопку <button> обработчик body.onclick не сработает:
```js
<body onclick="alert(`сюда всплытие не дойдёт`)">
  <button onclick="event.stopPropagation()">Кликни меня</button>
</body>	
```	
	
  **[⬆ Наверх](#top)**
	
130. ### <a name="130"></a> Делегирование событий

`Делегирование событий` - это приём, заключающийся в добавлении обработчиков событий к родительскому элементу, а не к дочерним элементам. Обработчик будет срабатывать всякий раз, когда событие будет запущено на дочерних элементах благодаря всплытию событий в DOM. Преимущества этого приёма:

- Экономит объем используемой памяти, т.к. для родительского элемента требуется только один обработчик.
- Не нужно привязывать или убирать обработчики при добавлении и удалении элементов.	

  **[⬆ Наверх](#top)**
	
131. ### <a name="131"></a> Hoisting - Поднятие

Поднятие (hoisting) - это термин, используемый для объяснения поведения объявлений переменных в вашем коде. Переменные, объявленные или инициализированные при помощи ключевого слова var, будут перемещены в верхнюю часть текущей области, что мы называем "поднятием". Однако, "поднимается" только объявление переменной, присвоение значения (если оно имеется) останется на прежнем месте.

Обратите внимание, что объявление фактически не перемещается - движок JavaScript анализирует объявления во время компиляции и узнает о объявлениях и их областях видимости. Просто легче понять подобное поведение, представляя объявления как перемещение наверх своей области видимости. Давайте рассмотрим несколько примеров.

```js	
// объявления переменных через var поднимаются.
console.log(foo); // undefined
var foo = 1;
console.log(foo); // 1

// объявления переменных через let/const НЕ поднимаются.
console.log(bar); // ReferenceError: bar is not defined
let bar = 2;
console.log(bar); // 2
```
	
При объявлении функции ее тело поднимается наверх, в то время как у функциональных выражений (когда переменной присваивается функция) поднимается только переменная.
```js
// Объявление функции
console.log(foo); // [Function: foo]
foo(); // 'FOOOOO'
function foo() {
  console.log('FOOOOO');
}
console.log(foo); // [Function: foo]

// Функциональное выражение
console.log(bar); // undefined
bar(); // Uncaught TypeError: bar is not a function
var bar = function () {
  console.log('BARRRR');
};
console.log(bar); // [Function: bar]	
```
	
Поднятие или hoisting — это механизм в JavaScript, в котором переменные и объявления функций, передвигаются вверх своей области видимости перед тем, как код будет выполнен.

Стоит отметить то, что механизм “поднятия” передвигает только объявления функции или переменной. Назначения переменным остаются на своих местах.

Как следствие, это означает то, что совершенно неважно где были объявлены функция или переменные, все они передвигаются вверх своей области видимости, вне зависимости от того локальная она или же глобальная.

Запомните: поднимаются только функциональные выражения и переменные, объявленные с помощью ключевого слова «var». Обычные функции и стрелочные функции, а также переменные, объявленные с помощью ключевых слов «let» и «const» не поднимаются.

```jsx harmony
console.log(y)
y = 1
console.log(y)
console.log(greet('Mark'))

function greet(name) {
    return 'Hello ' + name + '!'
}

var y
```
Получаем undefined, 1 и 'Hello Mark!'.

Вот как выглядит фаза компиляции:
```jsx harmony
function greet(name) {
    return 'Hello ' + name + '!'
}

var y // присваивается undefined

// ожидается завершение фазы компиляции

// затем начинается фаза выполнения
/*
console.log(y)
y = 1
console.log(y)
console.log(greet('Mark'))
*/
```	
	
  **[⬆ Наверх](#top)**	
	
	
132. ### <a name="132"></a> Глобальный объект window

window — это глобальный объект предоставляемый браузером, внутри которого содержатся все встроенные в браузерный JavaScript функции и свойства. Каждый раз, когда мы вызываем глобальные функции, такие как alert() или prompt(), браузер ищет их в объекте window. То есть в действительности происходит вызов window.alert().
 
- Глобальный объект хранит переменные, которые должны быть доступны в любом месте программы.

Это включает в себя как встроенные объекты, например, Array, так и характерные для окружения свойства, например, window.innerHeight – высота окна браузера.

- Глобальный объект имеет универсальное имя – globalThis.

…Но чаще на него ссылаются по-старому, используя имя, характерное для данного окружения, такое как window (браузер) и global (Node.js). Так как globalThis появился недавно, он не поддерживается в IE и Edge (не-Chromium версия), но можно использовать полифил.

- Следует хранить значения в глобальном объекте, только если они действительно глобальны для нашего проекта. И стараться свести их количество к минимуму.

- В браузерах, если только мы не используем модули, глобальные функции и переменные, объявленные с помощью var, становятся свойствами глобального объекта.

- Для того, чтобы код был проще и в будущем его легче было поддерживать, следует обращаться к свойствам глобального объекта напрямую, как window.x
 
 https://learn.javascript.ru/global-object

  **[⬆ Наверх](#top)**
	
133. ### <a name="133"></a> import/export syntax & CommonJS

### Экспорт

```js
// экспорт массива
export let months = ['Jan', 'Feb', 'Mar', 'Apr', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

// экспорт константы
export const MODULES_BECAME_STANDARD_YEAR = 2015;

// экспорт класса
export class User {
  constructor(name) {
    this.name = name;
  }
}
```
```js
function sayHi(user) {
  alert(`Hello, ${user}!`);
}

function sayBye(user) {
  alert(`Bye, ${user}!`);
}

export {sayHi, sayBye}; // список экспортируемых переменных
```

### Импорт 

Обычно мы располагаем список того, что хотим импортировать, в фигурных скобках import {...}, например вот так:
```js
import {sayHi, sayBye} from './say.js';

sayHi('John'); // Hello, John!
sayBye('John'); // Bye, John!
Но если импортировать нужно много чего, мы можем импортировать всё сразу в виде объекта, используя import * as <obj>. Например:


import * as say from './say.js';

say.sayHi('John');
say.sayBye('John');
```

### Импорт «как»

Мы также можем использовать as, чтобы импортировать под другими именами.
```js
import {sayHi as hi, sayBye as bye} from './say.js';

hi('John'); // Hello, John!
bye('John'); // Bye, John!
```

### Экспортировать «как»

Аналогичный синтаксис существует и для export.

Давайте экспортируем функции, как hi и bye:
```js
...
export {sayHi as hi, sayBye as bye};
```
Теперь hi и bye – официальные имена для внешнего кода, их нужно использовать при импорте:
```js
import * as say from './say.js';

say.hi('John'); // Hello, John!
say.bye('John'); // Bye, John!
```

### export default
```js
export default class User { // просто добавьте "default"
  constructor(name) {
    this.name = name;
  }
}
```
Заметим, в файле может быть не более одного export default.

…И потом импортируем без фигурных скобок:
```js
import User from './user.js'; // не {User}, просто User

new User('John');
```

### Довод против экспортов по умолчанию

Именованные экспорты «включают в себя» своё имя. Эта информация является частью модуля, говорит нам, что именно экспортируется.

Именованные экспорты вынуждают нас использовать правильное имя при импорте:
```js
import {User} from './user.js';
// import {MyUser} не сработает, должно быть именно имя {User}
…В то время как для экспорта по умолчанию мы выбираем любое имя при импорте:

import User from './user.js'; // сработает
import MyUser from './user.js'; // тоже сработает
// можно импортировать с любым именем, и это будет работать
```
Так что члены команды могут использовать разные имена для импорта одной и той же вещи, и это не очень хорошо.


### Итоги

Вот все варианты export, которые мы разобрали в этой и предыдущей главах.

Вы можете проверить себя, читая их и вспоминая, что они означают:

1. Перед объявлением класса/функции/…:
	- export [default] class/function/variable ...
2. Отдельный экспорт:
	- export {x [as y], ...}.
3. Реэкспорт:
	- export {x [as y], ...} from "module"
	- export * from "module" (не реэкспортирует export default).
	- export {default [as y]} from "module" (реэкспортирует только export default).

Импорт:

1. Именованные экспорты из модуля:
	- import {x [as y], ...} from "module"
2. Импорт по умолчанию:
	- import x from "module"
	- import {default as x} from "module"
3. Всё сразу:
	- import * as obj from "module"
4. Только подключить модуль (его код запустится), но не присваивать его переменной:
	- import "module"

### CommonJS =>
	
https://nodejsdev.ru/api/modules/	
	
  **[⬆ Наверх](#top)** 

136. ### <a name="136"></a> Зная разницу между классом и объектом. Различие между прототипическим и классическим наследованием

`Прототипы` - это механизм, с помощью которого объекты JavaScript наследуют свойства друг от друга.

JavaScript часто описывают как язык прототипного наследования — каждый объект, имеет объект-прототип, который выступает как шаблон, от которого объект наследует методы и свойства. 

Объект-прототип так же может иметь свой прототип и наследовать его свойства и методы и так далее. Это часто называется цепочкой прототипов и объясняет почему одним объектам доступны свойства и методы которые определены в других объектах.		
Javascript использует наследование прототипов, поэтому классов как таковых не существует. Все является объектом; просто некоторые объекты имеют общий родительский объект, методы/переменные которого будут найдены, когда разрешение имен будет искать цепочку прототипов.

Как прототипное наследование, так и классическое наследование являются парадигмами объектно-ориентированного программирования (т. е. они имеют дело с объектами). Объекты — это просто абстракции, которые состоят из свойств сущности из реального мира (т. е. они представляют в программе сущности из реального мира в виде слов ). И это называется абстракция.

### Парадигма классического наследования

В классическом наследовании объекты являются абстракциями «вещей» реального мира, но мы можем ссылаться на объекты только через классы. Классы — в данном случае это обобщение объекта. Другими словами, получается что классы — это абстракция объекта реального мира. При обобщении мы наследуем один класс от другого. И при классическом наследовании процесс наследования должен создавать уровень абстракции. При каждом наследовании, каждый дочерний класс должен повышать уровень абстракции, тем самым повышая уровень обобщения. Вот пример классического наследования:
```js
class Shoe {
    // ...
}
class Boot extends Shoe {
    // ...
}
```
Man hikingBoot = new Boot();
Как вы можете видеть в классических объектно-ориентированных языках программирования классы являются обобщениями и при каждом наследовании у них должен снижаться уровень абстракции.

Объекты в классических объектно-ориентированных языках программирования могут быть созданы только путем создания экземпляров классов.

Следовательно, по мере увеличения уровня абстракции сущности становятся более общими, а по мере снижения уровня абстракции сущности становятся более конкретными. В этом смысле уровень абстракции аналогичен шкале, варьирующейся от более специфических сущностей до более общих сущностей.


### Парадигма прототипного наследования

В отличие от классического наследования, прототипное наследование не имеет дело с увеличивающимися уровнями абстракции. Объект — это либо абстракция реальной вещи, как и раньше, либо прямая копия другого Объекта (другими словами, Прототипа (Prototype)). Объекты могут быть созданы из ничего, или они могут быть созданы из других объектов.
 
Если взять наш прежний пример то вряд ли нам удастся избежать иерархии абстракций. Поэтому он будет выглядеть примерно так:
```js
var shoe = {};
var boot = Object.create(shoe);
var hikingBoot = Object.create(boot);
```
Но в нем есть главное отличие. shoe, boot и hikingBoot это все независимые объекты. Просто одни объекты созданы от других. Это важно! А при классическом наследование обобщения являются абстракциями абстракций… от абстракций … вплоть до самого последнего потомка.

Было бы правильнее в данном случае привести пример из независимых объектов, но для объяснения разницы думаю этого будет достаточно.

Уровень абстракции здесь не обязан быть глубже одного уровня (хотя при желание может и быть).

При использование парадигмы прототипного наследования программист имеет дело только с объектами и при этом у него есть возможность создавать сущности в одном уровне абстракции.

Вы можете комбинировать обе формы наследования для достижения очень гибкой системы повторного использования кода. Что собственно почти всегда и происходит в реальном коде JavaScript. То есть в реальных проектах обычно подсознательно реализуется классическое наследование, через иерархию объектов, хотя это делать не обязательно. Так как реализовать классическое наследование с помощью прототипов очень легко. И да, обратное утверждение будет неверным.

Прототипное наследование позволяет реализовать большинство важных функций, которые вы найдете в классических языках ООП. В JavaScript замыкания и фабричные функции позволяют реализовать приватное состояние, а функциональное наследование можно легко комбинировать с прототипами, что также позволяет использовать миксины.


### Некоторые преимущества прототипного наследования:

`Слабая связь`. Экземпляр никогда не нуждается в прямой ссылке на родительский класс или прототип. Можно сохранить ссылку на прототип объекта, но это не рекомендуется, потому что это будет способствовать тесной связи в иерархии объектов — одна из самых больших ошибок классического наследования.

`Плоские иерархии`. С прототипным наследованием легко поддерживать плоские иерархии наследования — используя конкатенацию (выборочное использование свойств одного объекта для создания другого ) и делегирование (клонирование одного объекта в другой), вы можете иметь один уровень делегирования объекта и один экземпляр без ссылок на родительские классы.

`Тривиальное множественное наследование`. Наследование от нескольких предков так же просто, как объединение свойств из нескольких прототипов с использованием конкатенации для формирования нового объекта или нового делегата для нового объекта.

`Гибкая архитектура`. Поскольку вы можете выборочно наследоваться, вам не нужно беспокоиться о проблеме «неправильного дизайна». Новый класс может наследовать любую комбинацию свойств от любой комбинации исходных объектов. Из-за простоты выравнивания иерархии, изменение в одном месте не обязательно вызывает рябь в длинной цепочке объектов-потомков.


### Заключение

В заключении отвечая на вопрос чем отличается классическое наследование от прототипного, можно сказать, что при следовании парадигме классического наследования нам необходимо создавать иерархию классов от общему к частному создавая тем самым при каждом наследовании дополнительный уровень абстракции. При следовании парадигме прототипного наследования мы не обязаны создавать иерархию от общего к частному, мы можем это делать а можем и не делать. Это оставляет нам свободу выбора (независимо от того понимаем мы это или нет), что и является на мой взгляд главным отличием этих двух парадигм.	

  **[⬆ Наверх](#top)**	

137. ### <a name="137"></a> Что такое функциональное программирование? Основы функционального программирования (функция первого класса, функция высшего порядка, лямбда-функции, неизменяемость данных, ленивое вычисление, рекурсия, чистые функции)

`Функциональное программирование` — это парадигма программирования, в которой процесс вычисления трактуется как вычисление значений функций в математическом понимании последних. Функциональное программирование предполагает обходиться вычислением результатов функций от исходных данных и результатов других функций, и не предполагает явного хранения состояния программы. Соответственно, не предполагает оно и изменяемости этого состояния.

`Функции первого класса`

Если язык программирования имеет функции первого класса, то значит они трактуются как объекты, то есть могут быть переданы другим функциям и их можно вернуть из функций. Так же их можно присваивать переменным.

Пример
```js
/* функция не имеет имени и находится в правой части команды присваивания переменной.*/

var dog = function(num) {
    for (var i = 0; i < num; i++) {
        alert("Woof");
    }
};
dog(3); //Эту функцию можно вызвать через переменную dog.
```
Такое использование ключевого слова function — внутри команды, как в команде присваивания, — называется функциональным выражением. В отличие от объявления, эта функция не имеет имени. Кроме того, результатом этого выражения является значение, которое затем присваивается переменной dog. Что это за значение? Мы присваиваем его переменной dog, а затем вызываем через эту переменную, значит, это есть ссылка на функцию.


`Функции высшего порядка`

Такие функции оперируют другими функциями, принимая их в качестве аргументов или возвращая их. Проще говоря, `Функции высшего порядка` ― это такие функции, которые принимают функцию в качестве аргумента или возвращают функцию в качестве вывода.

Например, эти функции высшего порядка встроены в язык: Array.prototype.map, Array.prototype.filter и Array.prototype.reduce .

`Array.prototype.map`

Метод map() создаёт новый массив, вызывая callback-функцию, указанную в качестве аргумента, для каждого элемента входного массива. Метод map() берёт каждое возвращённое значение от callback-функции и создаёт новый массив, используя эти значения.

Callback-функция, отправленная в метод map(), принимает 3 аргумента: element, index, и array.

Допустим, у нас есть массив из чисел. Мы хотим создать новый массив, который будет содержать удвоенные значения первого. Давайте посмотрим, как мы можем решить эту задачу с помощью функции высшего порядка и без неё.

`Без функции высшего порядка`
```js
const arr1 = [1, 2, 3];
const arr2 = [];
for(let i = 0; i < arr1.length; i++) {
  arr2.push(arr1[i] * 2);
}
// prints [ 2, 4, 6 ]
console.log(arr2);
```

С функцией высшего порядка map
```js
const arr1 = [1, 2, 3];
const arr2 = arr1.map(function(item) {
  return item * 2;
});
console.log(arr2);
```

### Понятие неизменяемости данных

Концепция неизменяемости довольно проста. По сути, неизменное значение — это то, что нельзя изменить. В частности, когда мы разрабатываем наши приложения, мы можем оказаться в некоторых ситуациях, когда мы захотим создать новый объект в нашем коде, содержащий новое свойство или значение, при этом сохраняя исходное значение. Концепция неизменяемости может помочь нам создавать новые объекты, следя за тем, чтобы мы не меняли исходное значение.

В JavaScript у нас есть примитивные типы и ссылочные типы. Примитивные типы включают числа, строки, boolean, null, undefined. И ссылочные типы включают объекты, массивы и функции.

Разница между этими типами заключается в том, что примитивные типы неизменяемы (immutable), а ссылочные типы изменяемы (mutable). Например, тип string неизменяем


### Рекурсия

Рекурсия – это приём программирования, полезный в ситуациях, когда задача может быть естественно разделена на несколько аналогичных, но более простых задач. Или когда задача может быть упрощена до несложных действий плюс простой вариант той же задачи. Или, как мы скоро увидим, для работы с определёнными структурами данных.

Рекурсивный способ: упрощение задачи и вызов функцией самой себя:
```js
function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}

alert( pow(2, 3) ); // 8
```

### Чистые функции

«Чистые» функции - это любые функции, исходные данные которых получены исключительно из их входных данных и не вызывают побочных эффектов в приложении. Математические функции являются примерами «чистых» функций. «Нечистые» функции бывают разных форм и размеров. Вот некоторые примеры:

- функции, вывод которых зависит от внешнего / глобального состояния;
- функции, которые возвращают разные исходные данные при одинаковых входных;
- функции, которые изменяют состояние приложения;
- функции, которые изменяют «внешний мир».
- 
Функциональное программирование основано на использовании «чистых» функций и строгом контроле побочных эффектов. Способность распознавать любой тип функции является ключевым для функционального программирования.

«Чистая» функция - это функция, которая выводит свои данные основываясь исключительно на свои входные данные и не вызывает побочных эффектов в приложении.

Например у нас есть функция, которая получает одно значение x и возвращает в данном случае x + 1:
```js
// function f(x) { return x + 1 }

const f = x => x + 1;
```
Довольно легко понять, что это «чистая» функция. Мы получаем тот же результат при вызове этой функции, с тем же входным значением; плюс у нас нет внешних зависимостей, которые бы вызывали побочные эффекты. Чтобы понять это далее, давай сравним это с несколькими «нечистыми» функциями.

  **[⬆ Наверх](#top)**	

138. ### <a name="138"></a> Живые коллекции

Все методы "getElementsBy*" возвращают живую коллекцию. Такие коллекции всегда отражают текущее состояние документа и автоматически обновляются при его изменении.

В приведённом ниже примере есть два скрипта.

Первый создаёт ссылку на коллекцию <div>. На этот момент её длина равна 1.
Второй скрипт запускается после того, как браузер встречает ещё один <div>, теперь её длина – 2.
```js	
<div>First div</div>

<script>
  let divs = document.getElementsByTagName('div');
  alert(divs.length); // 1
</script>

<div>Second div</div>

<script>
  alert(divs.length); // 2
</script>
```
	
Напротив, querySelectorAll возвращает статическую коллекцию. Это похоже на фиксированный массив элементов.

Если мы будем использовать его в примере выше, то оба скрипта вернут длину коллекции, равную 1:
```js
<div>First div</div>

<script>
  let divs = document.querySelectorAll('div');
  alert(divs.length); // 1
</script>

<div>Second div</div>

<script>
  alert(divs.length); // 1
</script>
```	
Теперь мы легко видим разницу. Длина статической коллекции не изменилась после появления нового div в документе.	
```js
// Живые коллекции

const boxesQuery = document.querySelectorAll('.box');
const boxesGet = document.getElementsByClassName('box');

boxesQuery[0].remove();
boxesGet[0].remove();

console.log(boxesQuery); //неживые коллекции
console.log(boxesGet); // живые коллекции

console.log(Array.from(boxesGet)) // первод в обычный массив	
```
	
### matches
	
Предыдущие методы искали по DOM.

Метод elem.matches(css) ничего не ищет, а проверяет, удовлетворяет ли elem CSS-селектору, и возвращает true или false.

Этот метод удобен, когда мы перебираем элементы (например, в массиве или в чём-то подобном) и пытаемся выбрать те из них, которые нас интересуют.

Например:
```js
<a href="http://example.com/file.zip">...</a>
<a href="http://ya.ru">...</a>

<script>
  // может быть любая коллекция вместо document.body.children
  for (let elem of document.body.children) {
    if (elem.matches('a[href$="zip"]')) {
      alert("Ссылка на архив: " + elem.href );
    }
  }
</script>
```
```js
boxesQuery.forEach(box => {
  if (box.matches('.class')) console.log(box);
})	
```
	
### closest
	
Предки элемента – родитель, родитель родителя, его родитель и так далее. Вместе они образуют цепочку иерархии от элемента до вершины.

Метод elem.closest(css) ищет ближайшего предка, который соответствует CSS-селектору. Сам элемент также включается в поиск.

Другими словами, метод closest поднимается вверх от элемента и проверяет каждого из родителей. Если он соответствует селектору, поиск прекращается. Метод возвращает либо предка, либо null, если такой элемент не найден.

Например:
```js
<h1>Содержание</h1>

<div class="contents">
  <ul class="book">
    <li class="chapter">Глава 1</li>
    <li class="chapter">Глава 2</li>
  </ul>
</div>

<script>
  let chapter = document.querySelector('.chapter'); // LI

  alert(chapter.closest('.book')); // UL
  alert(chapter.closest('.contents')); // DIV

  alert(chapter.closest('h1')); // null (потому что h1 - не предок)
</script>
```	
```js
console.log(boxesQuery[0].closest('.wrapper'));	
```
	
  **[⬆ Наверх](#top)**
	
139. ### <a name="139"></a> Symbol

«Символ» представляет собой уникальный идентификатор.
	
Символ (symbol) – примитивный тип данных, использующийся для создания уникальных идентификаторов.	
	
```js
let id2 = Symbol('id');

const obj = {
  name: 'test',
  [id2]: 2,
  [Symbol('id')]: 3,
  getId: function() {
    return this[id2];
  }
}

let id = Symbol('id');

obj[id] = 1;

console.log(obj[id]);
console.log(obj.getId())
console.log(Object.getOwnPropertySymbols(obj));
console.log(obj[Object.getOwnPropertySymbols(obj)[0]]);
console.log(obj[Object.getOwnPropertySymbols(obj)[2]]);

for (let value in obj) console.log(value);


const myAwesomeDB = {
  movies: [],
  actors: [],
  [Symbol('id')]: 123,
  [Symbol.for('id')]: 123,
}

myAwesomeDB.id = '322323';

console.log(myAwesomeDB['id']);
console.log(myAwesomeDB[Symbol.for('id')]);
console.log(myAwesomeDB);	
```	

  **[⬆ Наверх](#top)**
	
140. ### <a name="140"></a> Дескрипторы свойств и полезные методы объектов

```js
const user = {
  name: 'Alex',
  surname: 'Smith',
  birhday: '20/04/1990',
  showMyPublicData: function() {
    console.log(`${this.name} ${this.surname}`);
  }
}

console.log(Object.getOwnPropertyDescriptor(user, 'name'));

Object.defineProperty(user, 'name', {writable: false});
Object.defineProperty(user, 'gender', {value: 'male'});

console.log(Object.getOwnPropertyDescriptor(user, 'gender'));

// Если мы вручну создаем какой нибудь обьект то у него все флаги будут стоять true, а если при помощи defineProperty создаем и не указываем их то вначале они будут стоять false


const userSecond = {
  name: 'Alex',
  surname: 'Smith',
  birhday: '20/04/1990',
  showMyPublicData: function() {
    console.log(`${this.name} ${this.surname}`);
  }
}

Object.defineProperty(userSecond, 'birhday', {writable: false});

Object.defineProperty(userSecond, 'birhday', {value: prompt('Date?'), enumerable: true, configurable: true});

console.log(Object.getOwnPropertyDescriptor(userSecond, 'birhday'));


Object.defineProperty(userSecond, 'showMyPublicData', {enumerable: false});

console.log(Object.getOwnPropertyDescriptor(Math, 'PI'));


for (let key in userSecond) console.log(key);


// userSecond.birhday = '22/32'


Object.defineProperties(userSecond, {
  name: {writable: false},
  surname: {writable: false}
})

writable – если true, свойство можно изменить, иначе оно только для чтения.
enumerable – если true, свойство перечисляется в циклах, в противном случае циклы его игнорируют.
configurable – если true, свойство можно удалить, а эти атрибуты можно изменять, иначе этого делать нельзя.

Методы обьекта!

Object.is()

Object.keys() - возвращает массив ключей обьекта
Object.values() - возвращает массив свойств обьекта
Object.entries() - возвращает массив масивов которые состоят из свойста и значений	
```	

### Метод Object.defineProperties
	
Существует метод Object.defineProperties(obj, descriptors), который позволяет определять множество свойств сразу.

Его синтаксис:
```js
Object.defineProperties(obj, {
  prop1: descriptor1,
  prop2: descriptor2
  // ...
});
Например:

Object.defineProperties(user, {
  name: { value: "John", writable: false },
  surname: { value: "Smith", writable: false },
  // ...
});
```	
Таким образом, мы можем определить множество свойств одной операцией.

### Object.getOwnPropertyDescriptors
	
Чтобы получить все дескрипторы свойств сразу, можно воспользоваться методом Object.getOwnPropertyDescriptors(obj).

Вместе с Object.defineProperties этот метод можно использовать для клонирования объекта вместе с его флагами:
```js
let clone = Object.defineProperties({}, Object.getOwnPropertyDescriptors(obj));
Обычно при клонировании объекта мы используем присваивание, чтобы скопировать его свойства:

for (let key in user) {
  clone[key] = user[key]
}
…Но это не копирует флаги. Так что если нам нужен клон «получше», предпочтительнее использовать Object.defineProperties.
```
Другое отличие в том, что for..in игнорирует символьные и неперечислимые свойства, а Object.getOwnPropertyDescriptors возвращает дескрипторы всех свойств.

Глобальное запечатывание объекта
Дескрипторы свойств работают на уровне конкретных свойств.

Но ещё есть методы, которые ограничивают доступ ко всему объекту:

- Object.preventExtensions(obj)
Запрещает добавлять новые свойства в объект.
- Object.seal(obj)
Запрещает добавлять/удалять свойства. Устанавливает configurable: false для всех существующих свойств.
- Object.freeze(obj)
Запрещает добавлять/удалять/изменять свойства. Устанавливает configurable: false, writable: false для всех существующих свойств.
	
А также есть методы для их проверки:

- Object.isExtensible(obj)
Возвращает false, если добавление свойств запрещено, иначе true.
- Object.isSealed(obj)
Возвращает true, если добавление/удаление свойств запрещено и для всех существующих свойств установлено configurable: false.
- Object.isFrozen(obj)
Возвращает true, если добавление/удаление/изменение свойств запрещено, и для всех текущих свойств установлено configurable: false, writable: false.	
	
  **[⬆ Наверх](#top)**		
	
141. ### <a name="141"></a> Итерируемые конструкции
	
```js
const userThird = {
  name: 'Alex',
  surname: 'Smith',
  birhday: '20/04/1990',
  showMyPublicData: function() {
    console.log(`${this.name} ${this.surname}`);
  }
}

for (const key in userThird) {
  console.log(userThird[key])
}

const arr = ['b', 'a', 'c'];

for (const key of arr) {
  console.log(key)
}

const str = 'string';

for (const key of str) {
  console.log(key)
}



const salaries = {
  john: 500,
  ivan: 1000,
  anna: 5000,
  sayHello: function() {
    console.log('Hello');
  }
}

salaries[Symbol.iterator] = function() {
  return {
    current: this.john,
    last: this.anna,

    next() {
      if (this.current < this.last) {
        this.current += 500;
        return {done: false, value: this.current}
      } else {
        return {done: true}
      }

    }
  }
}

const iterator = salaries[Symbol.iterator]();

console.log(iterator.next());

for (let res of salaries) {
  console.log(res);
}	
```	
	
  **[⬆ Наверх](#top)**
	
142. ### <a name="142"></a> BigInt

BigInt – это специальный числовой тип, который предоставляет возможность работать с целыми числами произвольной длины.	
	
```js
console.log(Number.MAX_SAFE_INTEGER); // 900719925474099

const bigint = 4325246123543561436801435046450601846084035014851861353n;

const sameBigint = BigInt(4325246123543561436801435046450601846084035014851861353);

console.log(typeof(bigint))

// Нельзя использовать с встореным обьектом Math
// Нельзя смешивать в операциях BigInt и обычные числа

console.log(5n + 3)

console.log(Math.round(5n))

console.log(1n + 2n)

console.log(5n / 2n) // будет возвращать округленный результат

console.log(2n > 1n) // true
console.log(2n > 5) // false
console.log(2n === 2) // false
console.log(2n == 2) // true


let bigint2 = 1n;
let number = 2;

console.log(bigint2 + BigInt(number)) // 3n

console.log(Number(bigint2) + number)	
```	
	
  **[⬆ Наверх](#top)**
	
143. ### <a name="143"></a> 
	
	
  **[⬆ Наверх](#top)**
	
144. ### <a name="144"></a> 
	
	
  **[⬆ Наверх](#top)**
	
145. ### <a name="145"></a> 
	
	
  **[⬆ Наверх](#top)**
	
146. ### <a name="146"></a> 
	
	
  **[⬆ Наверх](#top)**
	
147. ### <a name="147"></a> 
	
	
  **[⬆ Наверх](#top)**
	
148. ### <a name="148"></a> 
	
	
  **[⬆ Наверх](#top)**	
	
201. ### <a name="201"></a> Получение элементов со страницы

```js
const box = document.getElementById('box');

console.log(box);

const btns = document.getElementsByTagName('button')/*[1]*/; // вот тут вот

console.log(btns[1]); // или тут 
console.log(btns);

console.log(btns[1]); // только так мы можем поменять цвет кнопки или размер или тд.


const circles = document.getElementsByClassName('box');

console.log(box);


// querySelectorAll - это исключение, псевдомассив, но у него появляется один метод forEach()

const hearts = document.querySelectorAll('.heart');

hearts.forEach(item => {
  console.log(item);
});

	
// const oneHeart = document.querySelector('.heart'); // позволяет получить первый элемент на странице	

const oneHeart = document.querySelector('div'); // позволяет получить первый элемент 

console.log(oneHeart);	
```	

  **[⬆ Наверх](#top)**
	
202. ### <a name="202"></a> Действия с элементами на странице

```js
const box = document.getElementById('box'),
      btns = document.getElementsByTagName('button'),
      circles = document.getElementsByClassName('circle'),
      hearts = document.querySelectorAll('.heart'),
      oneHeart = document.querySelector('.heart'),
      wrapper = document.querySelector('.wrapper');


// box.style.backgroundColor = 'blue';
// box.style.width = '500px';

// тоже самое
// box.style.cssText = 'background-color: blue; width: 500px';

// box.style.cssText = `background-color: blue; width: ${num}px`;


// btns[1].style.borderRadius = '100%';

// circles[0].style.backgroundColor = 'red';


// for (let i = 0; i < hearts.length; i++) {
//   hearts[i].style.backgroundColor = 'blue';
// }

// но лучше использовать forEach =>

// метод forEach() существует только если мы используем метод document.querySelectorAll

// hearts.forEach(item => {
//   item.style.backgroundColor = 'blue';
// });


// Основные методы для работы с элементами страницы


const div = document.createElement('div');

// const text = document.createTextNode('Hello');

div.classList.add('black');

// document.body.append(div);


// перемещение, удаление, замена

// document.querySelector('.wrapper').append(div);

//рефакторинг кода, если мы используем эту переменную много раз, то мы перемещаем wrapper вверх < = , и дальше мы можем писать вот так =>

wrapper.append(div);

//старый вариант
// wrapper.appendChild(div);


// wrapper.prepend(div);

// hearts[0].before(div);
// hearts[0].after(div);

//старый вариант
// wrapper.insertBefore(div, hearts[0]);



// circles[0].remove();

//старый вариант
// wrapper.removeChild(hearts[1]);



// hearts[0].replaceWith(circles[0]);

// старый вариант
// wrapper.replaceChild(circles[0], hearts[0]);


// редактирование текста, добавить текст в элемент

// div.innerHTML = '<h1>Hello World</h1>';

// div.textContent = 'Hello';

// div.insertAdjacentHTML('beforebegin', '<h2>Hello</h2>');	
```	

  **[⬆ Наверх](#top)**
	
203. ### <a name="203"></a> Навигация по DOM - элементам

```js
console.log(document.body);
console.log(document.head);
console.log(document.documentElement); // html

console.log(document.body.childNodes);

Разницв между DOM Elements и DOM Nodes: каждая сущность которая находится на странице она по факту будет узлом, но не каждый узел будет элементом 

console.log(document.body.firstChild);

console.log(document.body.firstElementChild);

console.log(document.body.lastChild);
console.log(document.body.lastElementChild);



console.log(document.querySelector('#current').parentNode.parentNode);

console.log(document.querySelector('#current').parentElement);


console.log(document.querySelector('[data-current = "3"]').nextSibling);

console.log(document.querySelector('[data-current = "3"]').previousSibling);

console.log(document.querySelector('[data-current = "3"]').nextElementSibling);

console.log(document.querySelector('[data-current = "3"]').previousElementSibling);



// тут псевдомассив, но использовать forEach мы не можем, но мы можем использовать for of

for (let node of document.body.childNodes) {
  if (node.nodeName == '#text') {
    continue;
  }

  console.log(node);
}

коментарий не является тектовой нодой	
```	

  **[⬆ Наверх](#top)**
	
204. ### <a name="204"></a> Способы получения DOM-элементов в JS

```jsx harmony
// Создать div
const div = document.createElement('div');

// Добавить к нему класс wrapper
div.classList.add('wrapper');
// Поместить его внутрь тэга body
const body = document.querySelector('body');

// const body2 = document.body;

console.log(body);
// console.log(body2);

body.appendChild(div);

console.log(div);
// Создать заголовок H1 "DOM (Document Object Model)"
const header = document.createElement('h1');
header.textContent = 'DOM (Document Object Model)';
console.log(header);
// Добавить H1 перед DIV с классом wrapper
div.insertAdjacentElement('beforebegin', header);
// Создать список <ul></ul>
// Добавить в него 3 элемента с текстом "один, два, три"

const ul = `
	<ul>
		<li>один</li>
		<li>два</li>
		<li>три</li>
	</ul>
`;

// Поместить список внутрь элемента с классом wrapper
	div.innerHTML = ul;
// =================================================
// Создать изображение
const img = document.createElement('img');
// Добавить следующие свойства к изображению
// 1. Добавить атрибут source
img.src = 'https://picsum.photos/240';
// 2. Добавить атрибут width со значением 240
img.width = 240;
// 3. Добавить класс super
img.classList.add('super');
// 4. Добавить свойство alt со значением "Super Man"
img.alt = 'superMan';
// Поместить изображение внутрь элемента с классом wrapper
div.appendChild(img);

console.log(img);
// Используя HTML строку, создать DIV с классом 'pDiv' + c 2-мя параграфами
const elemHTML = `
<div class="pDiv">
	<p>1</p>
	<p>2</p>
</div>
`;

// Поместить этот DIV до элемента <ul></ul>
const ulList = div.querySelector('ul');
ulList.insertAdjacentHTML('beforebegin', elemHTML);
// Добавить для 2-го параграфа класс text
const pDiv = document.querySelector('.pDiv');
pDiv.children[1].classList.add('text');
console.log(pDiv.children);
// Удалить 1-й параграф
pDiv.firstElementChild.remove();
// Создать функцию generateAutoCard,
// которая принимает 3 аргумента: brand, color, year

// const generateAutoCard = (brand, color, year) => {
// 	return `
// 		<div class="autoCard">
//   		<h2>BRAND YEAR</h2>
//   		<p>Автомобиль BRAND - YEAR 				года. Возраст авто - 						YEARS лет.</p>
// 		</div>
// 	`;
// }

const generateAutoCard = (brand, color, year) => {
	const curDate = new Date();
	const curYear = curDate.getFullYear();
	return `
		<div class="autoCard">
		<h2>${brand.toUpperCase()} ${year}</h2>
		<p>Автомобиль ${brand.toUpperCase()} - ${year} 				года. Возраст авто - 						${curYear - year} лет.</p>
		<p>Цвет: ${color}</p>
		<button type="button" class="btn">Удалить</button>
		</div>
	`;
}

// Функция должна возвращать разметку HTML:
// <div class="autoCard">
//   <h2>BRAND YEAR</h2>
//   <p>Автомобиль BRAND - YEAR года. Возраст авто - YEARS лет.</p>
// </div>

// Создать новый DIV с классом autos
const carsDiv = document.createElement('div');
carsDiv.classList.add('autos');
// Создать 3 карточки авто, используя функцию generateAutoCard
const carsList = [
	{brand: 'Tesla', year: 2015, color: 'Красный'},
	{brand: 'Lexus', year: 2016, color: 'Серебристый'},
	{brand: 'Nissan', year: 2012, color: 'Черный'},
]

const carsHTML = carsList.map(car => {
	return generateAutoCard(car.brand, car.color, car.year)
}).join('');

// Поместить эти 3 карточки внутрь DIV с классом autos
carsDiv.innerHTML = carsHTML;
// Поместить DIV c классом autos на страницу DOM - до DIV с классом wrapper
console.log(carsDiv);
console.log(carsHTML);

div.insertAdjacentElement('beforebegin', carsDiv);
// Добавить кнопку Удалить на каждую карточку авто

// При клике на кнопку - удалять карточку из структуры DOM
// 1. Выбрать все кнопки
const buttons = document.querySelectorAll('.btn');

// 2. Создать функцию удаления
function handleClick(e) {
	const currentButton = e.currentTarget;
	currentButton.closest('.autoCard').remove();
}
// 3. Использовать цикл - чтобы повесить обработчик события на каждую кнопку

buttons.forEach(button => {
	button.addEventListener('click', handleClick)
})	
```

  **[⬆ Наверх](#top)**
	
205. ### <a name="205"></a> DOM-дерево (устройство, селекторы)

DOM – это объектная модель документа, которую браузер создаёт в памяти компьютера на основании HTML-кода, полученного им от сервера.		
DOM — «объектная модель документа») — это независящий от платформы и языка программный интерфейс, позволяющий программам и скриптам получить доступ к содержимому HTML-, XHTML- и XML-документов, а также изменять содержимое, структуру и оформление таких документов.

Все, что есть в HTML, даже комментарии, является частью DOM.

Даже директива <!DOCTYPE...>, которую мы ставим в начале HTML, тоже является DOM-узлом. Она находится в дереве DOM прямо перед <html>. Мы не будем рассматривать этот узел, мы даже не рисуем его на наших диаграммах, но он существует.

Даже объект document, представляющий весь документ, формально является DOM-узлом.

- document – «входная точка» в DOM.
- узлы-элементы – HTML-теги, основные строительные блоки.
- текстовые узлы – содержат текст.
- комментарии – иногда в них можно включить информацию, которая не будет показана, но доступна в DOM для чтения JS.
 
 У DOM-узлов есть свойства и методы, которые позволяют выбирать любой из элементов, изменять, перемещать их на странице и многое другое. Мы вернёмся к ним в последующих разделах.
 
### Cелекторы:
 
 Основных видов селекторов всего несколько:
`*` – любые элементы.
 
`div` – элементы с таким тегом.
 
`#id` – элемент с данным id.
 
`.class` – элементы с таким классом.
 
`[name="value"]` – селекторы на атрибут (см. далее).
 
`:visited` – «псевдоклассы», остальные разные условия на элемент.
 
 Селекторы можно комбинировать, записывая последовательно, без пробела:
	
`.c1.c2` – элементы одновременно с двумя классами c1 и c2
 
`a#id.c1.c2:visited` – элемент a с данным id, классами c1 и c2, и псевдоклассом visited
 
 Самые известные вы наверняка знаете:
 
`div p` – элементы p, являющиеся потомками div.
 
`div > p` – только непосредственные потомки
 
Есть и два более редких:

`div ~ p` – правые соседи: все p на том же уровне вложенности, которые идут после div.
 
`div + p` – первый правый сосед: p на том же уровне вложенности, который идёт сразу после div.
 
 При выборе элемента можно указать его место среди соседей.
Список псевдоклассов для этого:

`:first-child` – первый потомок своего родителя.

`:last-child` – последний потомок своего родителя.

`:only-child` – единственный потомок своего родителя, соседних элементов нет.

:nth-child(a)` – потомок номер a своего родителя, например :nth-child(2) – второй потомок. Нумерация начинается с 1.

`:nth-child(an+b)` – расширение предыдущего селектора через указание номера потомка формулой, где a,b – константы, а под n подразумевается любое целое число.

Этот псевдокласс будет фильтровать все элементы, которые попадают под формулу при каком-либо n. Например: -:nth-child(2n) даст элементы номер 2, 4, 6…, то есть чётные.

`:nth-child(2n+1)` даст элементы номер 1, 3…, то есть нечётные.
 
`:nth-child(3n+2)` даст элементы номер 2, 5, 8 и так далее.
 
 Другие псевдоклассы
	
`:not(селектор)` – все, кроме подходящих под селектор.

`:focus` – в фокусе.

`:hover` – под мышью.

`:empty` – без детей (даже без текстовых).

`:checked`, `:disabled`, `:enabled` – состояния INPUT.

`:target` – этот фильтр сработает для элемента, ID которого совпадает с анкором #... текущего URL.

Например, если на странице есть элемент с id="intro", то правило :target { color: red } подсветит его в том случае, если текущий URL имеет вид http://...#intro.
 
При помощи псевдоэлементов ::before и ::after можно добавлять содержимое в начало и конец элемента

https://learn.javascript.ru/dom-nodes

https://learn.javascript.ru/css-selectors

  **[⬆ Наверх](#top)**
	
	
206. ### <a name="206"></a> ClassList и делегирование событий

Мы используем classList и className в JavaScript DOM для управления классами из элемента. Эти два свойства DOM имеют разные варианты использования. Посмотрим, в чем основное различие между ними.
	
Для управления классами существуют два DOM-свойства:

- className – строковое значение, удобно для управления всем набором классов.
- classList – объект с методами add/remove/toggle/contains, удобно для управления отдельными классами.

classList
	
Используя classList, вы можете добавить или удалить класс, не затрагивая любые другие классы, которые может иметь элемент.

Так что это полезно для добавления дополнительных классов к элементу, который содержит другие классы.
```js
classListесть несколько удобных методов, таких как toggleи replace.
if (clicked) {
    button.classList.add('clicked');
} else {
    button.classList.remove('clicked');
}
```
Здесь, если была нажата кнопка, он добавит выбранный класс вместе с другими классами, которые может иметь элемент, и удалит только выбранный класс из элемента.

className
	
Если вы используете className, он уничтожит все существующие классы при добавлении нового (или если вы назначите пустую строку, он уничтожит все из них).

Использование classNameможет быть удобным, если вы знаете, что этот элемент не будет использовать какие-либо другие классы.
```js	
if (clicked) {
    button.className = 'clicked';
} else {
    button.className = '';
}
```
В этом случае classNameстираются все классы, которые может иметь элемент, и добавляется к нему класс, по которому щелкнули . Пустая строка ('') сотрет все классы.

Заключение
Я бы рекомендовал использовать, classNameкогда это возможно.

Используйте, classListкогда вам нужны методы classList, такие как переключение, замена 
	
	
Когда-то давно в JavaScript существовало ограничение: зарезервированное слово типа "class" не могло быть свойством объекта. Это ограничение сейчас отсутствует, но в то время было невозможно иметь свойство elem.class.

Поэтому для классов было введено схожее свойство "className": elem.className соответствует атрибуту "class".

Например:
```js
<body class="main page">
  <script>
    alert(document.body.className); // main page
  </script>
</body>
```	
Если мы присваиваем что-то elem.className, то это заменяет всю строку с классами. Иногда это то, что нам нужно, но часто мы хотим добавить/удалить один класс.

Для этого есть другое свойство: elem.classList.

elem.classList – это специальный объект с методами для добавления/удаления одного класса.

Например:
```js
<body class="main page">
  <script>
    // добавление класса
    document.body.classList.add('article');

    alert(document.body.className); // main page article
  </script>
</body>
```	
Так что мы можем работать как со строкой полного класса, используя className, так и с отдельными классами, используя classList. Выбираем тот вариант, который нам удобнее.

Методы classList:

elem.classList.add/remove("class") – добавить/удалить класс.
elem.classList.toggle("class") – добавить класс, если его нет, иначе удалить.
elem.classList.contains("class") – проверка наличия класса, возвращает true/false.
	
Кроме того, classList является перебираемым, поэтому можно перечислить все классы при помощи for..of:
```js
<body class="main page">
  <script>
    for (let name of document.body.classList) {
      alert(name); // main, затем page
    }
  </script>
</body>
```
	
### Example
```js
const btns = document.querySelectorAll('button'),
      wrapper = document.querySelector('.btn-block');

console.log(btns[0].classList.length);
console.log(btns[0].classList.item(1));
console.log(btns[1].classList.add('red', 'fsff'));
console.log(btns[0].classList.remove('blue'));
console.log(btns[0].classList.toggle('blue'));
//toggle - если класс есть на элементе то он будет удален, если нету класса на элементе то он будет добавлен


if (btns[1].classList.contains('red')) {
  console.log('red'); 
}


btns[0].addEventListener('click', () => {
  if (!btns[1].classList.contains('red')) {
    btns[1].classList.add('red');
  } else {
    btns[1].classList.remove('red');
  }

  //тоже работает, но в сложных скриптах не всегда работает

  btns[1].classList.toggle('red');
});


console.log(btns[0].className); // не стоит использовать


// Делигирование событий

wrapper.addEventListener('click', (event) => {
  // console.dir(event.target);
  if (event.target && event.target.tagName == 'BUTTON') {
    console.log('Hello');
  }
});


wrapper.addEventListener('click', (event) => {
  if (event.target && event.target.classList.contains('blue')) {
    console.log('HEllo');
  }
});


wrapper.addEventListener('click', (event) => {
  if (event.target && event.target.tagName == 'BUTTON') {
    console.log('HEllo');
  }
});


wrapper.addEventListener('click', (event) => {
  if (event.target && event.target.matches('button.red')) {
    console.log('HEllo');
  }
});


//ошибка, которую можно допустить =>

btns.forEach(btn => {
  btn.addEventListener('click', () => {
    console.log('Hi-Hi');
  });
});


//Делегирование - вне зависимости когда элемент появился, у него будут такие же свойства как и у остальных

const btn = document.createElement('button');
btn.classList.add('red');
wrapper.append(btn);	
```	
	
  **[⬆ Наверх](#top)**
	
	
207. ### <a name="207"></a> 
	

  **[⬆ Наверх](#top)**
	
	
208. ### <a name="208"></a> Работа с датами

```js
Способы создания даты

const now = new Date();

console.log(now);


const now = new Date('2021-01-15');

console.log(now);


const now = new Date(2021, 1, 15, 20);

console.log(now);


колличество милисекунд отчитывается с начала 1970 года

const now = new Date(0);

console.log(now);



const now = new Date(-9999999999999);

console.log(now);


Получение компонентов даты

const now = new Date();

console.log(now.getFullYear());
console.log(now.getMonth());
console.log(now.getDate());
console.log(now.getHours());
console.log(now.getMinutes());
console.log(now.getSeconds());
console.log(now.getMilliseconds());

нумерация начинается с Воскресенья
console.log(now.getDay());

console.log(now.getUTCHours());

console.log(now.getTime());
console.log(now.getTimezoneOffset());

Что бы обратно превратить число миллисекунд в дату:
const noww = new Date(1610723430634);
console.log(noww);


Установка компонентов
set - такие же команды как и в get

const now = new Date('2021-01-15');
получается тоже самое, только используем метод()
new Date.parse('2021-01-15');

console.log(now.setHours(18));
console.log(now.setHours(18, 40)); // не всегда хорошо, так как тут часы
console.log(now);

console.log(now.setHours(40)); //Автоматически исправляет

	

let start = new Date();

for (let i = 0; i < 100000; i++) {
  let some = i ** 3;
}

let end = new Date();

alert(`Цыкл отработал за ${end - start} миллисекунд`);	
```	

  **[⬆ Наверх](#top)**
	
209. ### <a name="209"></a> 
	
	
  **[⬆ Наверх](#top)**
	
210. ### <a name="210"></a> Параметры документа, окна и работа с ними

document - это обьект который содержит всю нашу html структуру, только в более сложном варианте

window - окно в котором показывается документ 

screen - весь ваш видимый монитор, именно монитор

```js
const box = document.querySelector('.box'),
      btn = document.querySelector('button');

// const width = box.clientWidth;
// const height = box.clientHeight;

// const width = box.offsetWidth;
// const height = box.offsetHeight;

const width = box.scrollWidth;
const height = box.scrollHeight;

console.log(width, height);

btn.addEventListener('click', () => {
  // box.style.height = box.scrollHeight + 'px';

  console.log(box.scrollTop);
});


console.log(box.getBoundingClientRect());


console.log(box.getBoundingClientRect().top);


const style = window.getComputedStyle(box);

console.log(style);
console.log(style.display);


//window.getComputedStyle(box) - эти стили идут с CSS, они изначально появятся у нас на странице

//box.style.height = box.scrollHeight + 'px' - это инлайн стили, которые появляются внутри верстки и прописываются прямо в тэг. По правилам верстки они более приоритетней



// console.log(document.documentElement.clientWidth);

// console.log(document.documentElement.scrollTop);



// пишется в консоли =>

// от текущей позиции
window.scrollBy(0, 400);


// относительно всей страницы а не текущей страницы
window.scrollTo(0, 400);
```	

  **[⬆ Наверх](#top)**
	
211. ### <a name="211"></a> 
	

  **[⬆ Наверх](#top)**
	
212. ### <a name="212"></a> Разница между событиеми load и DOMContentLoaded

Событие `DOMContentLoaded` вызывается, когда исходный HTML-документ полностью загружен и обработан, не дожидаясь окончания загрузки таблиц стилей, изображений и скриптов.

Событие `load` происходит только после загрузки DOM и всех зависимых ресурсов.

  **[⬆ Наверх](#top)**
	
213. ### <a name="213"></a> Создаем табы в новом проекте

```js
window.addEventListener('DOMContentLoaded', () => {

  const tabs = document.querySelectorAll('.tabheader__item'),
        tabsContent = document.querySelectorAll('.tabcontent'),
        tabsParent = document.querySelector('.tabheader__items');

  function hideTabContent() {
    tabsContent.forEach(item => {
      item.classList.add('hide');
      item.classList.remove('show', 'fade');
    });

    tabs.forEach(item => {
      item.classList.remove('tabheader__item_active');
    });

  } 

  function showTabContent(i = 0) {
    tabsContent[i].classList.add('show', 'fade');
    tabsContent[i].classList.remove('hide');
    tabs[i].classList.add('tabheader__item_active');
  }

  hideTabContent();
  showTabContent();

  tabsParent.addEventListener('click', (event) => {
    const target = event.target;

    if (target && target.classList.contains('tabheader__item')) {
      tabs.forEach((item, i) => {
        if (target == item) {
          hideTabContent();
          showTabContent(i);
        }
      });
    }
  });

});	
```
	
  **[⬆ Наверх](#top)**	

214. ### <a name="214"></a> Создаем таймер обратного отсчета на сайте

```js
window.addEventListener('DOMContentLoaded', () => {

  // Timer

  const deadline = '2021-04-27';

  function getTimeRemaining(endtime) {
    const t = Date.parse(endtime) - Date.parse(new Date()),
      days = Math.floor(t / (1000 * 60 * 60 * 24)),
      hours = Math.floor((t / (1000 * 60 * 60)) % 24),
      minutes = Math.floor((t / 1000 / 60) % 60),
      seconds = Math.floor((t / 1000) % 60);

    return {
      total: t,
      days: days,
      hours: hours,
      minutes: minutes,
      seconds: seconds,
    };
  }

  function getZero(num) {
    if (num >= 0 && num < 10) {
      return `0${num}`;
    } else {
      return num;
    }
  }

  function setClock(selector, endtime) {
    const timer = document.querySelector(selector),
      days = timer.querySelector('#days'),
      hours = timer.querySelector('#hours'),
      minutes = timer.querySelector('#minutes'),
      seconds = timer.querySelector('#seconds'),
      timeInterval = setInterval(updateClock, 1000);

    updateClock();

    function updateClock() {
      const t = getTimeRemaining(endtime);

      days.innerHTML = getZero(t.days);
      hours.innerHTML = getZero(t.hours);
      minutes.innerHTML = getZero(t.minutes);
      seconds.innerHTML = getZero(t.seconds);

      if (t.total <= 0) {
        clearInterval(timeInterval);
      }
    }
  }

  setClock('.timer', deadline);
});	
```	

### Если таймер <= time то нужно вывести нули 0
```js
const deadline = '2021-04-27';

  function getTimeRemaining(endtime) {
    let days, hours, minutes, seconds;
    const t = Date.parse(endtime) - Date.parse(new Date());

    if (t <= 0) {
      days = 0;
      hours = 0;
      minutes = 0;
      seconds = 0;
    } else {
      days = Math.floor(t / (1000 * 60 * 60 * 24)),
      hours = Math.floor((t / (1000 * 60 * 60)) % 24),
      minutes = Math.floor((t / 1000 / 60) % 60),
      seconds = Math.floor((t / 1000) % 60);
    }
    
    return {
      total: t,
      days: days,
      hours: hours,
      minutes: minutes,
      seconds: seconds,
    };
  }

  function getZero(num) {
    if (num >= 0 && num < 10) {
      return `0${num}`;
    } else {
      return num;
    }
  }

  function setClock(selector, endtime) {
    const timer = document.querySelector(selector),
      days = timer.querySelector('#days'),
      hours = timer.querySelector('#hours'),
      minutes = timer.querySelector('#minutes'),
      seconds = timer.querySelector('#seconds'),
      timeInterval = setInterval(updateClock, 1000);

    updateClock();

    function updateClock() {
      const t = getTimeRemaining(endtime);

      days.innerHTML = getZero(t.days);
      hours.innerHTML = getZero(t.hours);
      minutes.innerHTML = getZero(t.minutes);
      seconds.innerHTML = getZero(t.seconds);

      if (t.total <= 0) {
        clearInterval(timeInterval);
      }
    }
  }

  setClock('.timer', deadline);		  
```
	
  **[⬆ Наверх](#top)**	

215. ### <a name="215"></a> Создаем модальное окно

### New Modal
```js
    // Modal

    const modalTrigger = document.querySelectorAll('[data-modal]'),
        modal = document.querySelector('.modal');

    modalTrigger.forEach(btn => {
        btn.addEventListener('click', openModal);
    });

    function closeModal() {
        modal.classList.add('hide');
        modal.classList.remove('show');
        document.body.style.overflow = '';
    }

    function openModal() {
        modal.classList.add('show');
        modal.classList.remove('hide');
        document.body.style.overflow = 'hidden';
        clearInterval(modalTimerId);
    }

    modal.addEventListener('click', (e) => {
        if (e.target === modal || e.target.getAttribute('data-close') == "") {
            closeModal();
        }
    });

    document.addEventListener('keydown', (e) => {
        if (e.code === "Escape" && modal.classList.contains('show')) { 
            closeModal();
        }
    });

    const modalTimerId = setTimeout(openModal, 300000);
    // Изменил значение, чтобы не отвлекало

    function showModalByScroll() {
        if (window.pageYOffset + document.documentElement.clientHeight >= document.documentElement.scrollHeight) {
            openModal();
            window.removeEventListener('scroll', showModalByScroll);
        }
    }
    window.addEventListener('scroll', showModalByScroll);	
```	
	
### Old Modal	
```js
window.addEventListener('DOMContentLoaded', () => {

  // Modal, Создание модального окна

  // тригеры - это те элементы которые вызывают последующие действия (кнопка: Связатся с нами)

  const modalTrigger = document.querySelectorAll('[data-modal]'),
        modal = document.querySelector('.modal'),
        modalCloseBtn = document.querySelector('[data-close]');

  modalTrigger.forEach(btn => {
    btn.addEventListener('click', () => {
      modal.classList.add('show');
      modal.classList.remove('hide');
  
      // еще можно toggle проверить
      // modal.classList.toggle('show');
  
      document.body.style.overflow = 'hidden';
    });
  });
  

  function closeModal() {
    modal.classList.add('hide');
    modal.classList.remove('show');
    document.body.style.overflow = '';
  }
  

  modalCloseBtn.addEventListener('click', closeModal);

  // еще можно toggle 
  // modal.classList.toggle('show');


  modal.addEventListener('click', (e) => {
    if (e.target === modal) {
      closeModal();
    }
  });


  document.addEventListener('keydown', (e) => {
    if (e.code === "Escape" && modal.classList.contains('show')) {
      closeModal();
    }
  });
  
});	
```	
Модификация модального окна	
```js
window.addEventListener('DOMContentLoaded', () => {

  // Modal, Создание модального окна


  // тригеры - это те элементы которые вызывают последующие действия

  const modalTrigger = document.querySelectorAll('[data-modal]'),
        modal = document.querySelector('.modal'),
        modalCloseBtn = document.querySelector('[data-close]');


  function openModal() {
    modal.classList.add('show');
    modal.classList.remove('hide');
    document.body.style.overflow = 'hidden';
    clearInterval(modalTimerId);
  }

  modalTrigger.forEach(btn => {
    btn.addEventListener('click', openModal);
  });
  

  function closeModal() {
    modal.classList.add('hide');
    modal.classList.remove('show');
    document.body.style.overflow = '';
  }
  

  modalCloseBtn.addEventListener('click', closeModal);


  // еще можно toggle проверить
  // modal.classList.toggle('show');

  // еще можно toggle 
  // modal.classList.toggle('show');


  modal.addEventListener('click', (e) => {
    if (e.target === modal) {
      closeModal();
    }
  });


  document.addEventListener('keydown', (e) => {
    if (e.code === "Escape" && modal.classList.contains('show')) {
      closeModal();
    }
  });


  const modalTimerId = setTimeout(openModal, 5000);


  function showModalByScroll() {
    if (window.pageYOffset + document.documentElement.clientHeight >= document.documentElement.scrollHeight) {
      openModal();
      window.removeEventListener('scroll', showModalByScroll);
    }
  }


  window.addEventListener('scroll', showModalByScroll);
  
});	
```
	
  **[⬆ Наверх](#top)**
	
216. ### <a name="216"></a> Создаем слайдер на сайте

```js
window.addEventListener('DOMContentLoaded', () => {

// Slider

  const slides = document.querySelectorAll('.offer__slide'),
        prev = document.querySelector('.offer__slider-prev'),
        next = document.querySelector('.offer__slider-next'),
        total = document.querySelector('#total'),
        current = document.querySelector('#current'),
        slidesWrapper = document.querySelector('.offer__slider-wrapper'),
        slidesField = document.querySelector('.offer__slider-inner'),
        width = window.getComputedStyle(slidesWrapper).width;
  
  let slideIndex = 1;
  let offset = 0;

  if (slides.length < 10) {
    total.textContent = `0${slides.length}`;
    current.textContent = `0${slideIndex}`;
  } else {
    total.textContent = slides.length;
    current.textContent = slideIndex;

  }

  slidesField.style.width = 100 * slides.length + '%';

  slidesField.style.display = 'flex';
  slidesField.style.transition = '0.5s all';

  slidesWrapper.style.overflow = 'hidden';


  slides.forEach(slide => {
    slide.style.width = width;
  });

  next.addEventListener('click', () => {  
    if (offset == +width.slice(0, width.length - 2) * (slides.length -1)) {
      offset = 0;
    } else {
      offset += +width.slice(0, width.length - 2);
    }

    slidesField.style.transform = `translateX(-${offset}px)`;

    if (slideIndex == slides.length) {
      slideIndex = 1;
    } else {
      slideIndex++;
    }

    if (slides.length < 10) {
      current.textContent = `0${slideIndex}`;
    } else {
      current.textContent = slideIndex;
    }
  });


  prev.addEventListener('click', () => {  
    if (offset == 0) {
      offset = +width.slice(0, width.length - 2) * (slides.length -1);
    } else {
      offset -= +width.slice(0, width.length - 2);
    }

    slidesField.style.transform = `translateX(-${offset}px)`;

    if (slideIndex == 1) {
      slideIndex = slides.length;
    } else {
      slideIndex--;
    }

    if (slides.length < 10) {
      current.textContent = `0${slideIndex}`;
    } else {
      current.textContent = slideIndex;
    }
  });
```

// Добавляем точки который работают синхронно со слайдером
 
```js
const slides = document.querySelectorAll('.offer__slide'),
        slider = document.querySelector('.offer__slider'),
        prev = document.querySelector('.offer__slider-prev'),
        next = document.querySelector('.offer__slider-next'),
        total = document.querySelector('#total'),
        current = document.querySelector('#current'),
        slidesWrapper = document.querySelector('.offer__slider-wrapper'),
        slidesField = document.querySelector('.offer__slider-inner'),
        width = window.getComputedStyle(slidesWrapper).width;
  
  let slideIndex = 1;
  let offset = 0;

  if (slides.length < 10) {
    total.textContent = `0${slides.length}`;
    current.textContent = `0${slideIndex}`;
  } else {
    total.textContent = slides.length;
    current.textContent = slideIndex;

  }

  slidesField.style.width = 100 * slides.length + '%';

  slidesField.style.display = 'flex';
  slidesField.style.transition = '0.5s all';

  slidesWrapper.style.overflow = 'hidden';


  slides.forEach(slide => {
    slide.style.width = width;
  });

  slider.style.position = 'relative';

  const indicators = document.createElement('ol'),
        dots = [];

  indicators.classList.add('carousel-indicators');
  indicators.style.cssText = `
    position: absolute;
    right: 0;
    bottom: 0;
    left: 0;
    z-index: 15;
    display: flex;
    justify-content: center;
    margin-right: 15%;
    margin-left: 15%;
    list-style: none;
  `;

  slider.append(indicators);

  for (let i = 0; i < slides.length; i++) {
    const dot = document.createElement('li');

    dot.setAttribute('data-slide-to', i + 1);
    dot.style.cssText = `
      box-sizing: content-box;
      flex: 0 1 auto;
      width: 30px;
      height: 6px;
      margin-right: 3px;
      margin-left: 3px;
      cursor: pointer;
      background-color: #fff;
      background-clip: padding-box;
      border-top: 10px solid transparent;
      border-bottom: 10px solid transparent;
      opacity: .5;
      transition: opacity .6s ease;
    `;

    if ( i == 0) {
      dot.style.opacity = 1;
    }

    indicators.append(dot);
    dots.push(dot);
  }

  function deleteNotDigits(str) {
    return +str.replace(/\D/g, '');
  }

  next.addEventListener('click', () => {  
    if (offset == deleteNotDigits(width) * (slides.length -1)) {
      offset = 0;
    } else {
      offset += deleteNotDigits(width);
    }

    slidesField.style.transform = `translateX(-${offset}px)`;

    if (slideIndex == slides.length) {
      slideIndex = 1;
    } else {
      slideIndex++;
    }

    if (slides.length < 10) {
      current.textContent = `0${slideIndex}`;
    } else {
      current.textContent = slideIndex;
    }

    dots.forEach(dot => dot.style.opacity = '.5');
    dots[slideIndex -1].style.opacity = 1;
  });


  prev.addEventListener('click', () => {  
    if (offset == 0) {
      offset = deleteNotDigits(width) * (slides.length -1);
    } else {
      offset -= deleteNotDigits(width);
    }

    slidesField.style.transform = `translateX(-${offset}px)`;

    if (slideIndex == 1) {
      slideIndex = slides.length;
    } else {
      slideIndex--;
    }

    if (slides.length < 10) {
      current.textContent = `0${slideIndex}`;
    } else {
      current.textContent = slideIndex;
    }

    dots.forEach(dot => dot.style.opacity = '.5');
    dots[slideIndex -1].style.opacity = 1;
  });

  dots.forEach(dot => {
    dot.addEventListener('click', (e) => {
      const slideTo = e.target.getAttribute('data-slide-to');

      slideIndex = slideTo;
      offset = deleteNotDigits(width) * (slideTo -1);

      slidesField.style.transform = `translateX(-${offset}px)`;

      if (slides.length < 10) {
        current.textContent = `0${slideIndex}`;
      } else {
        current.textContent = slideIndex;
      }

      dots.forEach(dot => dot.style.opacity = '.5');
      dots[slideIndex -1].style.opacity = 1;
    });
  });
```


// Slider - простой вариант
```js
  showSlides(slideIndex);

  if (slides.length < 10) {
    total.textContent = `0${slides.length}`;
  } else {
    total.textContent = slides.length;
  }

  function showSlides(n) {
    if (n > slides.length) {
      slideIndex = 1;
    }

    if (n < 1) {
      slideIndex = slides.length;
    }

    slides.forEach(item => item.style.display = 'none');

    slides[slideIndex - 1].style.display = 'block';

    if (slides.length < 10) {
      current.textContent = `0${slideIndex}`;
    } else {
      current.textContent = slideIndex;
    }
  }

  function plusSlides(n) {
    showSlides(slideIndex += n);
  }

  prev.addEventListener('click', () => {
    plusSlides(-1);
  });

  next.addEventListener('click', () => {
    plusSlides(1);
  });	
```
	
  **[⬆ Наверх](#top)**
	
217. ### <a name="217"></a> Создаем калькулятор на сайте

```js
window.addEventListener('DOMContentLoaded', function() {

// Calculator

const result = document.querySelector('.calculating__result span');
let sex = 'female',
    height, weight, age,
    ratio = 1.375;

function calcTotal() {
    if (!sex || !height || !weight || !age || !ratio) {
        result.textContent = '____'; // Можете придумать что угодно
        return;
    }
    if (sex === 'female') {
        result.textContent = Math.round((447.6 + (9.2 * weight) + (3.1 * height) - (4.3 * age)) * ratio);
    } else {
        result.textContent = Math.round((88.36 + (13.4 * weight) + (4.8 * height) - (5.7 * age)) * ratio);
    }
}

calcTotal();

function getStaticInformation(parentSelector, activeClass) {
    const elements = document.querySelectorAll(`${parentSelector} div`);

    elements.forEach(elem => {
        elem.addEventListener('click', (e) => {
            if (e.target.getAttribute('data-ratio')) {
                ratio = +e.target.getAttribute('data-ratio');
            } else {
                sex = e.target.getAttribute('id');
            }

            elements.forEach(elem => {
                elem.classList.remove(activeClass);
            });

            e.target.classList.add(activeClass);

            calcTotal();
        });
    });
}

getStaticInformation('#gender', 'calculating__choose-item_active');
getStaticInformation('.calculating__choose_big', 'calculating__choose-item_active');

function getDynamicInformation(selector) {
    const input = document.querySelector(selector);

    input.addEventListener('input', () => {
        switch(input.getAttribute('id')) {
            case "height":
                height = +input.value;
                break;
            case "weight":
                weight = +input.value;
                break;
            case "age":
                age = +input.value;
                break;
        }

        calcTotal();
    });
}

getDynamicInformation('#height');
getDynamicInformation('#weight');
getDynamicInformation('#age');
  
});	
```	

### Улучшаем калькулятор, делаем практичным

```js
const result = document.querySelector('.calculating__result span');
    
    let sex, height, weight, age, ratio;

    if (localStorage.getItem('sex')) {
        sex = localStorage.getItem('sex');
    } else {
        sex = 'female';
        localStorage.setItem('sex', 'female');
    }

    if (localStorage.getItem('ratio')) {
        ratio = localStorage.getItem('ratio');
    } else {
        ratio = 1.375;
        localStorage.setItem('ratio', 1.375);
    }

    function calcTotal() {
        if (!sex || !height || !weight || !age || !ratio) {
            result.textContent = '____';
            return;
        }
        if (sex === 'female') {
            result.textContent = Math.round((447.6 + (9.2 * weight) + (3.1 * height) - (4.3 * age)) * ratio);
        } else {
            result.textContent = Math.round((88.36 + (13.4 * weight) + (4.8 * height) - (5.7 * age)) * ratio);
        }
    }

    calcTotal();

    function initLocalSettings(selector, activeClass) {
        const elements = document.querySelectorAll(selector);

        elements.forEach(elem => {
            elem.classList.remove(activeClass);
            if (elem.getAttribute('id') === localStorage.getItem('sex')) {
                elem.classList.add(activeClass);
            }
            if (elem.getAttribute('data-ratio') === localStorage.getItem('ratio')) {
                elem.classList.add(activeClass);
            }
        });
    }

    initLocalSettings('#gender div', 'calculating__choose-item_active');
    initLocalSettings('.calculating__choose_big div', 'calculating__choose-item_active');

    function getStaticInformation(selector, activeClass) {
        const elements = document.querySelectorAll(selector);

        elements.forEach(elem => {
            elem.addEventListener('click', (e) => {
                if (e.target.getAttribute('data-ratio')) {
                    ratio = +e.target.getAttribute('data-ratio');
                    localStorage.setItem('ratio', +e.target.getAttribute('data-ratio'));
                } else {
                    sex = e.target.getAttribute('id');
                    localStorage.setItem('sex', e.target.getAttribute('id'));
                }
    
                elements.forEach(elem => {
                    elem.classList.remove(activeClass);
                });
    
                e.target.classList.add(activeClass);
    
                calcTotal();
            });
        });
    }

    getStaticInformation('#gender div', 'calculating__choose-item_active');
    getStaticInformation('.calculating__choose_big div', 'calculating__choose-item_active');

    function getDynamicInformation(selector) {
        const input = document.querySelector(selector);

        input.addEventListener('input', () => {
            if (input.value.match(/\D/g)) {
                input.style.border = "1px solid red";
            } else {
                input.style.border = 'none';
            }
            switch(input.getAttribute('id')) {
                case "height":
                    height = +input.value;
                    break;
                case "weight":
                    weight = +input.value;
                    break;
                case "age":
                    age = +input.value;
                    break;
            }

            calcTotal();
        });
    }

    getDynamicInformation('#height');
    getDynamicInformation('#weight');
    getDynamicInformation('#age');
```
	
  **[⬆ Наверх](#top)**
	
218. ### <a name="218"></a> 


	
  **[⬆ Наверх](#top)**
	
219. ### <a name="219"></a> 


	
  **[⬆ Наверх](#top)**
	
220. ### <a name="220"></a> 


	
  **[⬆ Наверх](#top)**
	
221. ### <a name="221"></a> 


	
  **[⬆ Наверх](#top)**
	
222. ### <a name="222"></a> 


	
  **[⬆ Наверх](#top)**	
	
300. ### <a name="300"></a> Функции-конструкторы

`Функции-конструкторы` технически являются обычными функциями. Но есть два соглашения:

- Имя функции-конструктора должно начинаться с большой буквы.
- Функция-конструктор должна выполняться только с помощью оператора "new"	
	
Когда функция вызывается как `new User(...)`, происходит следующее:

- Создаётся новый пустой объект, и он присваивается this.
- Выполняется тело функции. Обычно оно модифицирует this, добавляя туда новые свойства.
- Возвращается значение this.	
	
Конструкторы нам необходимы для создания новых однотипных обьектов(новые пользователи сайта, товары в магазине, ролики на ютубе)	
	
```js
function User(name, id) {
  this.name = name;
  this.id = id;
  this.human = true;
  this.hello = function() {
    console.log(`Hello ${this.name}`);
  };
}

User.prototype.exit = function() {
  console.log(`Пользователь ${this.name} ушел`);
};

const ivan = new User('Ivan', 28);
const alex = new User('Alex', 20);

ivan.exit();

ivan.hello();
alex.hello();

console.log(ivan);
console.log(alex);	
```	

Class example
```js
class User {
  constructor(name, id) {
    this.name = name;
    this.id = id;
    this.human = true;
  }
  hello() {
    console.log(`Hello! ${this.name}`)
  }
  exit() {
     console.log(`Пользователь ${this.name} ушел`)
  }
}

const ivan = new User('Ivan', 28);
const alex = new User('Alex', 20);

console.log(ivan);
console.log(alex);

ivan.hello();
alex.hello();    

ivan.exit();	
```		

https://learn.javascript.ru/constructor-new	
	
  **[⬆ Наверх](#top)**
	
301. ### <a name="301"></a> Контекст вызова. This

1) Обычная функция: this = window, но если use strict - undefined 
2) Контекст у методов обьекта - сам обьект
3) this в конструкторах и классах - это новый экземпляр обьекта
4) Ручная привязка this: call, apply, bind	
	
	
### 1) Обычная функция: this = window, но если use strict - undefined	
```js
function showThis() {
  console.log(this);
}

showThis(); // Window или undefined
```


Даже если у нас используется функция внутри функции то контекст у нее не меняется, он все равно будет Window или undefined
```js
function showThis(a, b) {
  console.log(this); // undefined
  function sum() {
    console.log(this); // undefined

    // return this.a + this.b;

    // или вот вариант c замыканием которая обращается к родительской функции showThis(a, b) которая равняется showThis(4, 5);

    return a + b;
  }

  console.log(sum()); // 9
}

showThis(4, 5);
```

### 2) Контекст у методов обьекта - сам обьект, и если мы используем стрелочную функцию в методе обьекта она будет равнятся самому обьекту	
```js
const obj2 = {
  a: 20,
  b: 15,
  sum: function() {
      console.log(this) // {a: 20, b: 15, sum: ƒ}

    function shout2() {
      console.log(this); // undefined
    }

    const shout = () => {
      console.log(this) // {a: 20, b: 15, sum: ƒ}
    }

    shout2();	
    shout();
  }
};

obj2.sum();
```	
	
### Прмер стрелочной функции в методе обьекта		
```js
const obj = {
  num: 5,
  sayNumber: function() {
    const say = () => {
      console.log(this); // {num: 5, sayNumber: ƒ}
      console.log(this.num) // 5
    };

    say();
  }
};

obj.sayNumber();	
```	

Example
```js
const obj = {
  a: 20,
  b: 15,
  shout() {
    console.log(this); // {a: 20, b: 15, shout: ƒ}
  },
};

obj.shout();	
```
	
Example
```js
const obj = {
  a: 20,
  b: 15,
  shout() {
    console.log(this); // {a: 20, b: 15, shout: ƒ}

    const arrowFunc = () => {
      console.log(this); // {a: 20, b: 15, shout: ƒ}
    }
    arrowFunc();
  },
};

obj.shout();	
```		

### 3) this в конструкторах и классах - это новый экземпляр обьекта
```js	
function User(name, id) {
  this.name = name;
  this.id = id;
  this.human = true;
  this.hello = function() {
    console.log('Hello! ' + this.name);
  }
}
let ivan = new User('Ivan', 23, true);

console.log(ivan.hello())  // Hello! Ivan
console.log(ivan.id) // 23
```

Class example
```js
class User {
  constructor(name, id) {
    this.name = name;
    this.id = id;
    this.human = true;
  }
  hello() {
    console.log(`Hello! ${this.name}`)
  }
  exit() {
     console.log(`Пользователь ${this.name} ушел`)
  }
}

const ivan = new User('Ivan', 28);
const alex = new User('Alex', 20);

console.log(ivan);
console.log(alex);

ivan.hello();
alex.hello();    

ivan.exit();	
```	
	
### 4) Ручная привязка this: call, apply, bind
```js	
function sayName(surname) {
  console.log(this); // {name: 'John'}
  console.log(this.name + surname); // John Smith
}

const user = {
  name: 'John'
};

sayName.call(user, ' Smith');
sayName.apply(user, [' Smith']);
```

```js
function count(num) {
  return this * num;
}

const double = count.bind(2);

console.log(double(3)); // 6
console.log(double(13)); // 26
```


### Пример	
```js
const btn = document.querySelector('button');

btn.addEventListener('click', function() {
  // console.log(this); // <button>click</button>
  this.style.backgroundColor = 'red';
});


// Если же мы используем стрелочную ф-цию - то контекст вызова теряеться, мы уже его использовать не можем. this = undefined(если есть 'use strict') или Window
	
btn.addEventListener('click', () => {
  console.log(this)
  this.style.backgroundColor = 'red';
});


// тоже самое только с обработчиком события вместо this

btn.addEventListener('click', (e) => {
  e.target.style.backgroundColor = 'red';
});
```

Когда у нас обработчик событий который идет как callback функция, написан в классическом режиме (function() {}) в таком случае наш контекст вызова будет сам элемент на котором произошло событие

В обработчиках событий когда мы используем обычный синтаксис через function - мы имеем доступ к this.

	
### Метозы привязки контекста

```jsx harmony
 function hello() {
  console.log('Hello', this)
}

console.log(hello()) //window

const person = {
  name: 'Spacy',
  age: 30,
  sayHello: hello,
  sayHelloWindow: hello.bind(window), // window
  // sayHelloWindow: hello.bind(document) // documtnt
  logInfo: function(job, phone) {
    console.group(`${this.name} info:`);
    console.log(`Name is ${this.name}`);
    console.log(`Age is ${this.age}`);
    console.log(`Job is ${job}`);
    console.log(`Phone is ${phone}`);
    console.groupEnd();
  }
}

const lena = {
  name: 'Elena',
  age: 25,
}

console.log(person) // {name: "Spacy", age: 30, sayHello: ƒ}

console.log(person.sayHello()) // Hello {name: "Spacy", age: 30, sayHello: ƒ}

console.log(person.sayHelloWindow()); // Hello Window {window: Window, self: Window, document: document, name: "", location: Location, …}

console.log(this === window) //true

console.log(person.logInfo())

console.log(person.logInfo('FRFR', '432523'))

console.log(person.logInfo.bind(lena)())


// метод bind()- возвращает нам новую функцию, и ее мы можем вызвать в любое время
person.logInfo.bind(lena, 'Frontend', '073-23-12-421')();

// метод call() - задает определенный контекст функции и какие-то параметры через запятую перечисленные, и вызывает функцию сразу
person.logInfo.call(lena, 'Frontend', '073-23-12-421');

// // метод apply() сразу вызовет эту функцию
person.logInfo.apply(lena, ['Frontend', '073-23-12-421'])
```

### Задача: Прототипы и this
```js
const array = [1, 2, 3, 4, 5]

Array.prototype.multBy = function(n) {
  return this.map(function(i) {
    return i * n
  })
}

console.log(array.multBy(2)) // [2, 4, 6, 8, 10]


const arr2 = [1, 2, 5].multBy(3)
console.log(arr2) // [3, 6, 15]	
```	
 
### Методы привязки контекста 2: bind, call, apply <a name="Metody_privyazki_konteksta_2"></a>

Метод bind() создаёт новую функцию, которая при вызове устанавливает в качестве контекста выполнения this предоставленное значение. В метод также передаётся набор аргументов, которые будут установлены перед переданными в привязанную функцию аргументами при её вызове.

Метод call() вызывает функцию с указанным значением this и индивидуально предоставленными аргументами. Функция call() принимает список аргументов	
	
Метод apply() вызывает функцию с указанным значением this и аргументами, предоставленными в виде массива (либо массивоподобного объекта ). Функция apply() принимает единичный массив аргументов
	
	
```jsx harmony 
 const auto = {
	brand: 'BMW',
	drive() {
		console.log(this) // {brand: "BMW", drive: ƒ}
		return `Заведем наш ${this.brand}`
	}
}

const motorBike = {
	brand: 'Suzuki'
}

console.log(auto.drive()); // Заведем наш BMW

// const autoDrive = auto.drive;

// console.log(autoDrive()) // Заведем наш undefined
```
 
// bind
```jsx harmony
const autoDrive = auto.drive.bind(auto);

console.log(autoDrive()) // Заведем наш BMW


const motorDrive = auto.drive.bind(motorBike)

const motorDrive1 = auto.drive.bind({brand: 'Корабль'});

console.log(motorDrive()); // Заведем наш Suzuki

console.log(motorDrive1()); // Заведем наш Корабль
```
 
// !
```jsx harmony
const $ = document.querySelector.bind(document);

console.log($ === document.querySelector);

const header = $('h2')
console.log(header);
```

// !
```jsx harmony
const bill = {
	tip: 0.1,
	calculate(total) {
		console.log(this);
		return total + total * this.tip;
	}
}

// const pay = bill.calculate(1000);
// console.log(pay); // 1100

const payCount = bill.calculate.bind(bill);

console.log(payCount(1000)); // 1100


const payCount2 = bill.calculate.bind({tip: 0.2}, 1000);

console.log(payCount2()); // 1200
```

// call apply
```jsx harmony
const bill2 = {
	tip: 0.1,
	calculate(total) {
		console.log(this);
		return total + total * this.tip;
	}
}


const payBind = bill2.calculate.bind(bill);

console.log(payBind(1000)); // 1100


const payCountCall = bill2.calculate.call(bill2, 1000);

console.log(payCountCall); // 1100


const payCountApply = bill2.calculate.apply(bill2, [1000]);

console.log(payCountApply); // 1100
```

// контекст привязывается один раз, и мы не можем повторно его привязать


// 
```jsx harmony
const bill3 = {
	tip: 0.1,
	calculate(total) {
		console.log(this);
		return total + total * this.tip;
	},
	detail(dish1, dish2, sum) {
		return `Ваш обед ${dish1}, ${dish2} стоит ${this.calculate((sum))}`
	}
}

const a = bill3.detail('pizza', 'salad', 1000);

const b = bill3.detail.call(bill3, 'pizza', 'salad', 1000);

const c = bill3.detail.apply(bill, ['pizza', 'salad', 1000]);


console.log(a); //Ваш обед pizza, salad стоит 1100
console.log(b); //Ваш обед pizza, salad стоит 1100
console.log(c); //Ваш обед pizza, salad стоит 1100
```

  **[⬆ Наверх](#top)**
	
302. ### <a name="302"></a> Классы (ES6)

```js
class User {

  constructor(name) {
    this.name = name;
  }

  sayHi() {
    alert(this.name);
  }

}

// Использование:
let user = new User("Иван");
user.sayHi();	
```
### Example
```js
class MenuCard {
    constructor(src, alt, title, descr, price, parentSelector, ...classess) {
      this.src = src;
      this.alt = alt;
      this.title = title;
      this.descr = descr;
      this.price = price;
      this.classess = classess;
      this.parent = document.querySelector(parentSelector);
      this.transfer = 27;
      this.changeToUAH();
    }

    changeToUAH() {
      this.price = this.price * this.transfer;
    }

    render() {
      const element = document.createElement('div');
      if (this.classess.length === 0) {
        this.element = 'menu__item';
        element.classList.add(this.element);
      } else {
        this.classess.forEach((className) => element.classList.add(className));
      }

      element.innerHTML = `
          <img src=${this.src} alt=${this.alt}>
          <h3 class="menu__item-subtitle">${this.title}</h3>
          <div class="menu__item-descr">${this.descr}</div>
          <div class="menu__item-divider"></div>
          <div class="menu__item-price">
              <div class="menu__item-cost">Цена:</div>
              <div class="menu__item-total"><span>${this.price}</span> грн/день</div>
          </div>
      `;
      this.parent.append(element);
    }
  }

  new MenuCard(
    'img/tabs/vegy.jpg',
    'vegy',
    'Меню "Фитнес"',
    'Меню "Фитнес" - это новый подход к приготовлению блюд: больше свежих овощей и фруктов. Продукт активных и здоровых людей. Это абсолютно новый продукт с оптимальной ценой и высоким качеством!',
    9,
    '.menu .container'
  ).render();

  new MenuCard(
    'img/tabs/elite.jpg',
    'elite',
    'Меню “Премиум”',
    'В меню “Премиум” мы используем не только красивый дизайн упаковки, но и качественное исполнение блюд. Красная рыба, морепродукты, фрукты - ресторанное меню без похода в ресторан! Спешите и заказывайте в интернете!',
    14,
    '.menu .container'
  ).render();

  new MenuCard(
    'img/tabs/post.jpg',
    'post',
    'Меню "Постное"',
    'Меню “Постное” - это тщательный подбор ингредиентов: полное отсутствие продуктов животного происхождения, молоко из миндаля, овса, кокоса или гречки, правильное количество белков за счет тофу и импортных вегетарианских стейков.',
    21,
    '.menu .container'
  ).render();	
```	
	
Когда вызывается new User("Иван"):

- Создаётся новый объект.
- constructor запускается с заданным аргументом и сохраняет его в this.name.
	
…Затем можно вызывать на объекте методы, такие как user.sayHi()
	

1. Чтобы унаследовать от класса: class Child extends Parent:
	- При этом Child.prototype.__proto__ будет равен Parent.prototype, так что методы будут унаследованы.
2. При переопределении конструктора:
	- Обязателен вызов конструктора родителя super() в конструкторе Child до обращения к this.
3. При переопределении другого метода:
	- Мы можем вызвать super.method() в методе Child для обращения к методу родителя Parent.
4. Внутренние детали:
	- Методы запоминают свой объект во внутреннем свойстве [[HomeObject]]. Благодаря этому работает super, он в его прототипе ищет родительские методы.
	- Поэтому копировать метод, использующий super, между разными объектами небезопасно.	
	
У функций-стрелок нет своего this и super, поэтому они «прозрачно» встраиваются во внешний контекст.

  **[⬆ Наверх](#top)**
	
303. ### <a name="303"></a> Наследование классов. Private, protected свойства

### Наследование классов	
	
```js
class Animal {
  static type = 'ANIMAL;';

  constructor(option) {
    (this.name = option.name),
      (this.age = option.age),
      (this.hasTail = option.hasTail);
  }

  voice() {
    console.log('I am Animal!');
  }
}

// const animal = new Animal({
//   name: 'Animal',
//   age: 5,
//   hasTail: true
// })

// console.log(animal);
// console.log(animal.voice());

// console.log(Animal.type)

class Cat extends Animal {
  static type = 'CAT';

  constructor(options) {
    super(options);
    this.color = options.color;
  }

  voice() {
    super.voice()
    console.log('I am cat!')
  }

  get ageInfo() {
    return this.age * 7
  }

  set ageInfo(newAge) {
    this.age = newAge
  }
}

const cat = new Cat({
  name: 'Cat',
  age: 7,
  hasTail: true,
  color: 'black',
});

console.log(cat);
console.log(cat.age);

console.log(cat.voice());
console.log(Cat.type);

console.log(cat.ageInfo)

console.log(cat.ageInfo = 8)
console.log(cat.ageInfo)
```

### Наследование классов

```js
class Rectangle {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }

  calcArea() {
    return this.height * this.width;
  }
}


class ColoredRectangleWithText extends Rectangle {
  constructor(height, width, text, bgColor) {
    super(height, width);
    this.text = text;
    this.bgColor = bgColor;
  }

  showMyProps() {
    console.log(`Текст: ${this.text}, цвет: ${this.bgColor}`);
  }
}

const div = new ColoredRectangleWithText(25, 10, 'Hello world', 'red');

div.showMyProps();
console.log(div.calcArea());


// const square = new Rectangle(10, 10);
// const long = new Rectangle(20, 100);

// console.log(square.calcArea());
// console.log(long.calcArea());
```	
		
  **[⬆ Наверх](#top)**
	
304. ### <a name="304"></a> setTimeout и setInterval скрипты и время их выполнения

Мы можем вызвать функцию не в данный момент, а позже, через заданный интервал времени. Это называется «планирование вызова».

Для этого существуют два метода:

- setTimeout позволяет вызвать функцию один раз через определённый интервал времени.
- setInterval позволяет вызывать функцию регулярно, повторяя вызов через определённый интервал времени.

### setTimeout
```js
function sayHi() {
  alert('Привет');
}

setTimeout(sayHi, 1000);
```
С аргументами:
```js
function sayHi(phrase, who) {
  alert( phrase + ', ' + who );
}

setTimeout(sayHi, 1000, "Привет", "Джон"); // Привет, Джон
```
Это также будет работать:
```js
setTimeout("alert('Привет')", 1000);
```
Но использование строк не рекомендуется. Вместо этого используйте функции. Например, так:
```js
setTimeout(() => alert('Привет'), 1000);
```

### Отмена setTimeout
```js
let timerId = setTimeout(...);
clearTimeout(timerId);
```
В коде ниже планируем вызов функции и затем отменяем его (просто передумали). В результате ничего не происходит:
```js
let timerId = setTimeout(() => alert("ничего не происходит"), 1000);
alert(timerId); // идентификатор таймера

clearTimeout(timerId);
alert(timerId); // тот же идентификатор (не принимает значение null после отмены)
```

### setInterval
```js
// повторить с интервалом 2 секунды
let timerId = setInterval(() => alert('tick'), 2000);

// остановить вывод через 5 секунд
setTimeout(() => { clearInterval(timerId); alert('stop'); }, 5000);
```
```js
clearInterval(timerId);
```
// Пример
```js
const timerId = setTimeout(function() {
  console.log('Hello');
}, 2000);


const timerId = setTimeout(function(text) {
  console.log(text);
}, 2000, 'Hello');



const timerId = setTimeout(logger, 2000);

function logger() {
  console.log('text');
}


const timerId = setTimeout(logger, 2000);

clearInterval(timerId);

function logger() {
  console.log('text');
}


const btn = document.querySelector('.btn');
let timerId,
    i = 0;

btn.addEventListener('click', () => {
  // const timerId = setTimeout(logger, 2000);

  timerId = setInterval(logger, 500);
});

function logger() {
  if (i === 3) {
    clearInterval(timerId);
  }
  console.log('text');
  i++;
}


// Рекурсивный вызов setTimeout, она будет вызыватся точно через 500мс и после 500мс = 1сек

let id = setTimeout(function log() {
  console.log('Hello');
  id = setTimeout(log, 500);
}, 500);


//банальная анимация

const btn = document.querySelector('.btn');
let timerId,
    i = 0;

function myAnimation() {
  const elem = document.querySelector('.box');
  let pos = 0;

  const id = setInterval(frame, 10);
  function frame() {
    if (pos == 300) {
      clearInterval(id);
    } else {
      pos++;
      elem.style.top = pos + 'px';
      elem.style.left = pos + 'px';
    }
  }
}

btn.addEventListener('click', myAnimation);	
```		
	
  **[⬆ Наверх](#top)**	
	
305. ### <a name="305"></a> JSON

__JSON, JavaScript Object Notation__ — текстовый формат обмена данными, основанный на JavaScript.

JSON представляет собой (в закодированном виде) одну из двух структур:

+ _Набор пар «ключ:значение»_;
+ _Упорядоченный набор значений_.

Ключом может быть только строка (регистрозависимая: имена с буквами в разных регистрах считаются разными).

В качестве значений могут быть использованы:

+ _Объект_ — неупорядоченное множество пар «ключ:значение», заключённое в фигурные скобки `{ }`. Ключ описывается строкой, между ним и значением стоит символ `:`. Пары ключ-значение отделяются друг от друга запятыми;
+ _Массив (одномерный)_ — упорядоченное множество значений. Массив заключается в квадратные скобки `[ ]`. Значения разделяются запятыми.
+ _Число_;
+ _Литералы_ `true`, `false` и `null`;
+ _Строка_ — упорядоченное множество из нуля или более символов Unicode, заключенное в кавычки `" "`. Символы могут быть указаны с использованием escape-последовательностей, начинающихся с обратной косой черты `\`, или записаны шестнадцатеричным кодом в кодировке UTF-8 в виде `\uFFFF`.	
	
JSON (JavaScript Object Notation) – это общий формат для представления значений и объектов.	
	
`JSON.stringify()` для преобразования объектов в JSON.
	
`JSON.parse()` для преобразования JSON обратно в объект.	
	
```js	
const persone = {
  name: 'Alex',
  tel: '+38023343535'
};

console.log(JSON.stringify(persone)); // {"name":"Alex","tel":"+38023343535"}
	
console.log(JSON.parse(JSON.stringify(persone))); // { name: 'Alex', tel: '+38023343535' }
```	
	
  **[⬆ Наверх](#top)**
	
306. ### <a name="306"></a> AJAX и XMLHttpRequest (общение с сервером)

Ajax (асинхронный JavaScript и XML) - это набор методов веб-разработки, использующих множество веб-технологий на стороне клиента для создания асинхронных веб-приложений. С помощью Ajax веб-приложения могут отправлять данные на сервер и получать их с сервера асинхронно (в фоновом режиме), не влияя на отображение и поведение открытой страницы. Отделяя уровень обмена данными от уровня представления, Ajax позволяет веб-страницам и, в частности, веб-приложениям динамически изменять содержимое без необходимости перезагрузки всей страницы. На практике для получения/передачи данных используется формат данных JSON вместо XML из-за того, что JSON основан на JavaScript.

Раньше для асинхронного взаимодействия использовали XMLHttpRequest API, а сейчас принято использовать fetch API.	

__AJAX, Asynchronous Javascript and XML (Асинхронный Javascript и XML)__ — подход к построению интерактивных пользовательских интерфейсов web-приложений, заключающийся в «фоновом» обмене данными браузера и web-сервера. В результате, при обновлении данных web-страница не перезагружается полностью и web-приложения становятся быстрее и удобнее.

При использовании AJAX:

1. Пользователь заходит на web-страницу и взаимодействует с каким-нибудь её элементом.
2. Скрипт на языке JavaScript определяет, какая информация необходима для обновления страницы.
3. Браузер отправляет соответствующий запрос на web-сервер.
4. Web-сервер возвращает только ту часть документа, на которую пришёл запрос.
5. Скрипт вносит изменения с учётом полученной информации (без полной перезагрузки страницы).

AJAX базируется на двух основных принципах:

1. использование технологии динамического обращения к серверу «на лету» (без перезагрузки страницы полностью) через динамическое создание:
    + _дочерних фреймов_;
    + _тега `<script>`_;
    + _тега `<img>`_.
2. использование _DHTML_ для динамического изменения содержания страницы;

AJAX не является самостоятельной технологией, это концепция использования нескольких смежных технологий:

+ _(X)HTML_, _CSS_ для подачи и стилизации информации;
+ _DOM-модель_, операции над которой производятся Javascript на стороне клиента, для обеспечения динамического отображения и взаимодействия с информацией;
+ _XMLHttpRequest_ или другой транспорт (_IFrame_, _SCRIPT-тег_, _..._) для асинхронного обмена данными с web-сервером;
+ _JSON_ или любой другой подходящий формат (_форматированный HTML_, _текст_, _XML_, _..._) для обмена данными.	

Под AJAX подразумевают любое общение с сервером без перезагрузки страницы, организованное при помощи JavaScript.

### Как это работает?
	
Помните, что технология AJAX не является ни единой технологией, ни языком программирования. Как уже говорилось ранее, AJAX — это набор методов веб-разработки. Система обычно состоит из:

HTML/XHTML для основного языка и CSS для презентации.
Объектная модель документа (DOM) для динамического отображения данных и их взаимодействия.
XML для обмена данными и XSLT для их управления. Многие разработчики начали заменять JSON, потому что он ближе по форме к JavaScript.
Объект XMLHttpRequest для асинхронного взаимодействия.
Наконец, язык программирования JavaScript, чтобы объединить все эти технологии.
Вам могут понадобиться некоторые технические знания, чтобы понять это полностью. Однако общая процедура работы AJAX довольно проста. Посмотрите на диаграмму и таблицу ниже для дальнейшего сравнения.	

![2](https://user-images.githubusercontent.com/80325645/137638460-ee4a4f3f-3e08-4987-80d1-24b47e02c490.jpg

Сравнительная таблица:
	
Обычная модель	AJAX модель
	
- HTTP-запрос отправляется с веб-браузера на сервер.
- Сервер получает и впоследствии извлекает данные.
- Сервер отправляет запрошенные данные в веб-браузер.
- Веб-браузер получает данные и перезагружает страницу для отображения данных.
	
Во время этого процесса у пользователей нет выбора, кроме как ждать, пока весь процесс не будет завершён. Это не только отнимает много времени, но и создаёт ненужную нагрузку на сервер.	

	
AJAX это набор методов веб-разработки, которые позволяют веб-приложениям работать асинхронно — обрабатывать любые запросы к серверу в фоновом режиме.		
	
### XMLHttpRequest GET запрос, json 	
```js
window.addEventListener('DOMContentLoaded', () => {

  function req() {

    const request = new XMLHttpRequest();
    request.open('GET', 'http://localhost:3000/people');
    request.setRequestHeader('Content-type', 'application/json; charset=utf-8');
    request.send();
    request.addEventListener('readystatechange', function() {
      if (request.readyState === 4 && request.status == 200) {
        let data = JSON.parse(request.response);
        console.log(data);

        data.forEach(item => {
          let card = document.createElement('div');
    
          card.classList.add('card');
    
          let icon;
    
          if (item.sex === 'male') {
            icon = "icons/mars.png"
          } else {
            icon = "icons/female.png"
          }
    
          card.innerHTML = `
            <img src="${item.photo}" alt="photo">
            <div class="name">${item.name} ${item.surname}</div>
            <div class="sex">
              <img src=${icon} alt="male">
            </div>
            <div class="age">${item.age}</div>
          `;
          document.querySelector('.app').appendChild(card);
        });
        
      } else {
        console.error('Что-то пошло не так...')
      }
    })

    this.remove();
  }

  document.querySelector('button').addEventListener('click', req, {once: true});

});	
```	
	
### Пример XMLHttpRequest GET запрос, json
```js
const inputUah = document.querySelector('#uah'),
      inputUsd = document.querySelector('#usd');

inputUah.addEventListener('input', () => {
  const request = new XMLHttpRequest();

  request.open('GET', 'js/current.json');
  request.setRequestHeader('Content-type', 'application/json; charset = utf-8');
  request.send();

  
  // request.addEventListener('readystatechange', () => {
  //   if (request.readyState === 4 && request.status === 200) {
  //     console.log(request.response);
  //     const data = JSON.parse(request.response);
  //     inputUsd.value = (+inputUah.value / data.current.usd).toFixed(2);
  //   } else {
  //     inputUsd.value = 'Что-то пошло не так';
  //   }

  // });


  request.addEventListener('load', () => {
    if (request.status === 200) {
      const data = JSON.parse(request.response);
      inputUsd.value = (+inputUah.value / data.current.usd).toFixed(2);
    } else {
      inputUsd.value = 'Что-то пошло не так';
    }

  });


  // status - 404, 200
  // statusText - ok, not found
  // response - ответ от сервера
  // readyState - текущее состояние запроса

});	
```		

### Пример XMLHttpRequest POST запрос, json и formData, реализация скрипта отправки данных на сервер	
```js
const forms = document.querySelectorAll('form');
  const message = {
    loading: 'Загрузка...',
    success: 'Спасибо! Скоро мы с вами свяжемся',
    failure: 'Что-то пошло не так...'
  };

  forms.forEach(item => {
    postData(item);
  });

  function postData(form) {
    form.addEventListener('submit', (e) => {
      e.preventDefault();

      let statusMessage = document.createElement('div');
      statusMessage.classList.add('status');
      statusMessage.textContent = message.loading;
      form.appendChild(statusMessage);
  
      const request = new XMLHttpRequest();
      request.open('POST', 'server.php');
      
      // для json =>
	
      request.setRequestHeader('Content-type', 'application/json');

      // когда мы используем связку XMLHttpRequest обьекта + form-data, нам заголовок устанавливать не нужно, он устанавливается автоматически
      
      const formData = new FormData(form);

	// для json =>	
	
      const object = {};
      formData.forEach(function(value, key){
          object[key] = value;
      });
      const json = JSON.stringify(object);

      request.send(json);
	
	// для formData =>
	
      // request.send(formData);		

      request.addEventListener('load', () => {
          if (request.status === 200) {
              console.log(request.response);
              statusMessage.textContent = message.success;
              form.reset();
              setTimeout(() => {
                  statusMessage.remove();
              }, 2000);
          } else {
              statusMessage.textContent = message.failure;
          }
      });
    });
  }	
```	
```js
<?php
$_POST = json_decode( file_get_contents("php://input"), true );
echo var_dump($_POST);

// как на php коде получить json данные и с ними поработать <=	
```	

### XMLHttpRequest с json, POST запрос =>

```js
window.addEventListener('DOMContentLoaded', () => {

  const form = document.querySelector('form');

  function req(e) {

    e.preventDefault();

    let formData = new FormData(form);
    formData.append('id', Math.random());

    let obj = {};
    formData.forEach((value, key) => {
      obj[key] = value;
    });

    let json = JSON.stringify(obj);

    const request = new XMLHttpRequest();
    request.open('POST', 'http://localhost:3000/people');
    request.setRequestHeader('Content-type', 'application/json; charset=utf-8');
    request.send(json);
    request.addEventListener('readystatechange', function() {
      if (request.readyState === 4 && request.status == 200) {
        let data = JSON.parse(request.response);
        console.log(data);
        
      } else {
        console.error('Что-то пошло не так...')
      }
    })
  }

  form.addEventListener('submit', (e) => req(e), {'once': true});
});
```

###  XMLHttpRequest c formData, POST запрос, уже без json
```js
window.addEventListener('DOMContentLoaded', () => {

  const form = document.querySelector('form');

  function req(e) {

    e.preventDefault();

    let formData = new FormData(form);

    // ! XMLHttpRequest formData

    const request = new XMLHttpRequest();
    request.open('POST', './api.php');
    // request.setRequestHeader('Content-Type', 'multipart/form-data'); 
    // когда XMLHttpRequest + formData - setRequestHeader тут не нужен
    request.send(formData);
    request.addEventListener('readystatechange', function() {
      if (request.readyState === 4 && request.status == 200) {
        console.log(request.response);
        
      } else {
        console.error('Что-то пошло не так...')
      }
    })
  }

  form.addEventListener('submit', (e) => req(e), {'once': true});
});
```

https://www.hostinger.com.ua/rukovodstva/chto-takoje-ajax/
https://developer.mozilla.org/ru/docs/Web/Guide/AJAX/Getting_Started	
https://itchief.ru/javascript/ajax-introduction

  **[⬆ Наверх](#top)**
	
307. ### <a name="307"></a> Promise (ES6)

Объект Promise используется для отложенных и асинхронных вычислений.	
	
1) Есть «создающий» код, который делает что-то, что занимает время. Например, загружает данные по сети.
2) Есть «потребляющий» код, который хочет получить результат «создающего» кода, когда он будет готов. Он может быть необходим более чем одной функции. 
3) Promise – это специальный объект в JavaScript, который связывает «создающий» и «потребляющий» коды вместе. «Создающий» код может выполняться сколько потребуется, чтобы получить результат, а промис делает результат доступным для кода, который подписан на него, когда результат готов.
	
```jsx harmony
let promise = new Promise(function(resolve, reject) {
  // эта функция выполнится автоматически, при вызове new Promise

  // через 1 секунду сигнализировать, что задача выполнена с результатом "done"
  setTimeout(() => resolve("done"), 1000);
});
```	

Функция, переданная в конструкцию new Promise, называется исполнитель (executor). Когда Promise создаётся, она запускается автоматически. Она должна содержать «создающий» код, который когда-нибудь создаст результат. В терминах нашей аналогии: исполнитель – это «певец».

Её аргументы resolve и reject – это колбэки, которые предоставляет сам JavaScript. Наш код – только внутри исполнителя.

Когда он получает результат, сейчас или позже – не важно, он должен вызвать один из этих колбэков:

- resolve(value) — если работа завершилась успешно, с результатом value.
- reject(error) — если произошла ошибка, error – объект ошибки.
	
Итак, исполнитель запускается автоматически, он должен выполнить работу, а затем вызвать resolve или reject.

У объекта promise, возвращаемого конструктором new Promise, есть внутренние свойства:

- state («состояние») — вначале "pending" («ожидание»), потом меняется на "fulfilled" («выполнено успешно») при вызове resolve или на "rejected" («выполнено с ошибкой») при вызове reject.
	
- result («результат») — вначале undefined, далее изменяется на value при вызове resolve(value) или на error при вызове reject(error).
	
Так что исполнитель по итогу переводит promise в одно из двух состояний: Resolve, Reject

Объект Promise служит связующим звеном между исполнителем («создающим» кодом) и функциями-потребителями («фанатами»), которые получат либо результат, либо ошибку. Функции-потребители могут быть зарегистрированы с помощью методов .then, .catch и .finally.

### У Promise есть методы: then, catch, finally	
	
.then - Наиболее важный и фундаментальный метод
Первый аргумент метода .then – функция, которая выполняется, когда промис переходит в состояние «выполнен успешно», и получает результат.
	
Второй аргумент .then – функция, которая выполняется, когда промис переходит в состояние «выполнен с ошибкой», и получает ошибку.

.catch(errorHandlingFunction) - обработать ошибку

.finally(f) похож на .then(f, f), в том смысле, что f выполнится в любом случае, когда промис завершится: успешно или с ошибкой.
finally хорошо подходит для очистки, например остановки индикатора загрузки, его ведь нужно остановить вне зависимости от результата.

	

### then
	
Наиболее важный и фундаментальный метод – .then.

Синтаксис:
```jsx harmony
promise.then(
  function(result) { /* обработает успешное выполнение */ },
  function(error) { /* обработает ошибку */ }
);
```	
Первый аргумент метода .then – функция, которая выполняется, когда промис переходит в состояние «выполнен успешно», и получает результат.

Второй аргумент .then – функция, которая выполняется, когда промис переходит в состояние «выполнен с ошибкой», и получает ошибку.

Например, вот реакция на успешно выполненный промис:
```jsx harmony
let promise = new Promise(function(resolve, reject) {
  setTimeout(() => resolve("done!"), 1000);
});

// resolve запустит первую функцию, переданную в .then
promise.then(
  result => alert(result), // выведет "done!" через одну секунду
  error => alert(error) // не будет запущена
);
```	
Выполнилась первая функция.

А в случае ошибки в промисе – выполнится вторая:
```jsx harmony
let promise = new Promise(function(resolve, reject) {
  setTimeout(() => reject(new Error("Whoops!")), 1000);
});

// reject запустит вторую функцию, переданную в .then
promise.then(
  result => alert(result), // не будет запущена
  error => alert(error) // выведет "Error: Whoops!" спустя одну секунду
);
```	
Если мы заинтересованы только в результате успешного выполнения задачи, то в then можно передать только одну функцию:
```jsx harmony
let promise = new Promise(resolve => {
  setTimeout(() => resolve("done!"), 1000);
});

promise.then(alert); // выведет "done!" спустя одну секунду
```
	
### catch
	
Если мы хотели бы только обработать ошибку, то можно использовать null в качестве первого аргумента: .then(null, errorHandlingFunction). Или можно воспользоваться методом .catch(errorHandlingFunction), который сделает тоже самое:
```jsx harmony
let promise = new Promise((resolve, reject) => {
  setTimeout(() => reject(new Error("Ошибка!")), 1000);
});

// .catch(f) это тоже самое, что promise.then(null, f)
promise.catch(alert); // выведет "Error: Ошибка!" спустя одну секунду
```	
Вызов .catch(f) – это сокращённый, «укороченный» вариант .then(null, f).

	
### finally
	
По аналогии с блоком finally из обычного try {...} catch {...}, у промисов также есть метод finally.

Вызов .finally(f) похож на .then(f, f), в том смысле, что f выполнится в любом случае, когда промис завершится: успешно или с ошибкой.

finally хорошо подходит для очистки, например остановки индикатора загрузки, его ведь нужно остановить вне зависимости от результата.

Например:
```jsx harmony
new Promise((resolve, reject) => {
  /* сделать что-то, что займёт время, и после вызвать resolve/reject */
})
  // выполнится, когда промис завершится, независимо от того, успешно или нет
  .finally(() => остановить индикатор загрузки)
  .then(result => показать результат, err => показать ошибку)
```	
Но это не совсем псевдоним then(f,f), как можно было подумать. Существует несколько важных отличий:

Обработчик, вызываемый из finally, не имеет аргументов. В finally мы не знаем, как был завершён промис. И это нормально, потому что обычно наша задача – выполнить «общие» завершающие процедуры.

Обработчик finally «пропускает» результат или ошибку дальше, к последующим обработчикам.

Например, здесь результат проходит через finally к then:
```jsx harmony
new Promise((resolve, reject) => {
  setTimeout(() => resolve("result"), 2000)
})
  .finally(() => alert("Промис завершён"))
  .then(result => alert(result)); // <-- .then обработает результат
```					 
А здесь ошибка из промиса проходит через finally к catch:
```jsx harmony
new Promise((resolve, reject) => {
  throw new Error("error");
})
  .finally(() => alert("Промис завершён"))
  .catch(err => alert(err));  // <-- .catch обработает объект ошибки
```				     
Это очень удобно, потому что finally не предназначен для обработки результата промиса. Так что он просто пропускает его через себя дальше.

				     
Последнее, но не менее значимое: вызов .finally(f) удобнее, чем .then(f, f) – не надо дублировать функции f.
				     
```jsx harmony
new Promise(function(resolve, reject) {

  setTimeout(() => resolve(1), 1000); // (*)

}).then(function(result) { // (**)

  alert(result); // 1
  return result * 2;

}).then(function(result) { // (***)

  alert(result); // 2
  return result * 2;

}).then(function(result) {

  alert(result); // 4
  return result * 2;

});
```	
Идея состоит в том, что результат первого промиса передаётся по цепочке обработчиков .then.

Поток выполнения такой:

Начальный промис успешно выполняется через 1 секунду (*),
Затем вызывается обработчик в .then (**).
Возвращаемое им значение передаётся дальше в следующий обработчик .then (***)
…и так далее.
В итоге результат передаётся по цепочке обработчиков, и мы видим несколько alert подряд, которые выводят: 1 → 2 → 4.			
### Пример полностью
```js
console.log('Request data...')

const p = new Promise(function(resolve, reject) {
  setTimeout(() => {
    console.log('Preparing data...')
    backEndData = {
      server: 'aws',
      port: 2000,
      status: 'working'
    }
    resolve(backEndData)
  }, 2000)
})


p.then(data => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      data.modified = true
      resolve(data)
    }, 2000)
  })

})
  .then(clientData => {
  console.log('Data received', clientData)

  clientData.fromPromise = true
  return clientData
})
.then(data => {
  console.log('Modifed', data)
})
.catch(err => console.error('Error: ', err))
.finally(() => console.log('Finally'))


// фишки

const sleep = ms => {
  return new Promise(resolve => { setTimeout(() => resolve(), ms)
  })
}

sleep(2000).then(() => console.log('After 2 sec'))
sleep(3000).then(() => console.log('After 3 sec'))

// All ->

Promise.all([sleep(2000), sleep(5000)])
  .then(() => {
    console.log('All promises')
})

// Race ->

Promise.race([sleep(2000), sleep(5000)])
  .then(() => {
    console.log('Race promises')
})
```

### Пример
```js
Promise.reject('a')
  .catch(p => p + 'b')
  .catch(p => p + 'c')
  .then(p => p + 'd')
  .finally(p => p + 'e')
  .then(p => console.log(p));
```	
Результат: abd

then(p => p + 'd') - выполняется по очереди

catch - промис реджектится со строкой 'а', дальш попадает все в catch второй catch не будет выполнен, все выполнется в первом

then(p => console.log(p)) -просто выводит 'p' в консоль, но не записывает его в промис поэтому попадает параметр p

finall - мы может отписыватся от собитый и он нечего не возвращает!	

### Пример
```js
Promise.resolve(7)
  .then((n) => Promise.reject(n))
  .catch((n) => Promise.reject(n))
  .catch(() => 5)
  .then(n => console.log(n)) 	
```	
Результат: 7	

### Пример
```js
let a = Promise.resolve(7)
  .then((n) => Promise.reject(n))
  .catch((n) => Promise.reject(n))
  .catch(() => 5)
  .then(n => console.log(n))	
```	
Результат: 5	
	
### Пример
```js
const req = new Promise((resolve, reject) => {
  setTimeout(() => {
    console.log('Подготовка данных...');
  
    const product = {
      name: 'TV',
      price: 2000
    };
    
    resolve(product);

  }, 2000);
});

req.then((product) => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      product.status = 'order';
      resolve(product);
    }, 2000);
  });
}).then(data => {
  data.modify = true;
  return data;
}).then(data => {
  console.log(data);
}).catch(() => {
  console.error('Произошла ошибка');
}).finally(() => {
  console.log('Finally');
});
	
/*
Результат: 
Подготовка данных...
{ name: 'TV', price: 2000, status: 'order', modify: true }
Finally
*/
```		
	
### Promise.all(iterable)
	
Вызов Promise.all(iterable) получает массив (или другой итерируемый объект) промисов и возвращает промис, который ждёт, пока все переданные промисы завершатся, и переходит в состояние «выполнено» с массивом их результатов.
	
```js
Promise.all([
  httpGet('/article/promise/user.json'),
  httpGet('/article/promise/guest.json')
]).then(results => {
  alert(results);
});	
```
	
### Promise.race(iterable)
	
Вызов Promise.race, как и Promise.all, получает итерируемый объект с промисами, которые нужно выполнить, и возвращает новый промис.

Но, в отличие от Promise.all, результатом будет только первый успешно выполнившийся промис из списка. Остальные игнорируются.
	
```js
Promise.race([
  httpGet('/article/promise/user.json'),
  httpGet('/article/promise/guest.json')
]).then(firstResult => {
  firstResult = JSON.parse(firstResult);
  alert( firstResult.name ); // iliakan или guest, смотря что загрузится раньше
});
```
 
### Пример All/Race
```js
const test = time => {
  return new Promise(resolve => {
    setTimeout(() => resolve(), time);
  });
};

// test(1000).then(() => console.log('1000 ms'));
// test(2000).then(() => console.log('2000 ms'));


Promise.all([test(1000), test(2000)]).then(() => {
  console.log('All');
});


Promise.race([test(1000), test(2000)]).then(() => {
  console.log('All');
});
```

### Example -> Что выведет в консоль данный код?
```js
const promise = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve('foo');
    }, 300);
});
  
promise.then((value) => {
    console.log(value);
}); 

// 'foo'
```

### Example -> Какое сообщение будет выведено в консоль при таком коде?
```js
const p1 = new Promise((resolve, reject) => {
  setTimeout(resolve, 1000, "one");
});
const p2 = new Promise((resolve, reject) => {
  setTimeout(resolve, 2000, "two");
});
const p3 = new Promise((resolve, reject) => {
  setTimeout(resolve, 3000, "three");
});
const p4 = new Promise((resolve, reject) => {
  setTimeout(resolve, 4000, "four");
});
const p5 = new Promise((resolve, reject) => {
  reject("reject");
});
 
Promise.all([p1, p2, p3, p4, p5]).then(value => {
  console.log(value);
}, reason => {
  console.log(reason)
});

// "reject"
```

### Example -> Через сколько секунд данный код выведет в консоль сообщение? И что именно будет в консоли?
```js
const promisify = (item, delay) =>
    new Promise(resolve => setTimeout(() => resolve(item), delay));
 
const a = () => promisify('a', 100);
const b = () => promisify('b', 5000);
const c = () => promisify('c', 3000);
 
async function two() {
    const promises = [a(), b(), c()];
    const outpu1 = await Promise.race(promises);
    return `two is done: ${outpu1}`;
}
 
two().then(console.log);

// Через 100мс, two is done: a
```

https://learn.javascript.ru/promise-basics

  **[⬆ Наверх](#top)**
	
	
308. ### <a name="308"></a> Promise

### Введение в Promises

Промисы часто используются, когда мы запрашиваем JSON API и выполняем AJAX запросы.

Промисы - это то, что произойдет между настоящим моментом и концом времени; или другими словами это то, что произойдет в будущем, но, вероятно, не сразу. Чтобы понять это, нам нужно помнить, что JavaScript почти полностью асинхронный.

Промисы - это один из способов работы с асинхронным кодом в JavaScript без написания слишком большого количества обратных вызовов.

Хоть они и существовали годами, со временем были стандартизированы и представлены в ES2015, а теперь заменены в ES2017 асинхронными функциями.

Асинхронные функции используют API промисов в качестве своего строительного блока, поэтому их понимание является основополагающим, так как скорее всего, мы больше будем использовать асинхронные функции вместо промисов.

### Вкратце о том, как работают промисы

Как только промис был вызван, он запускается в состоянии ожидания (pending state). Это означает, что функция, которая вызвала промис, продолжает выполнение, ожидая, пока промис выполнит свою собственную обработку и предоставит функции вызова некоторую обратную связь.

На этом этапе функция вызова ожидает, пока промис не вернется в resolved state (выполнено успешно) или в rejected state (выполнено с ошибкой), и в то же время она продолжает свое выполнение, пока выполняется промис.

### Создание промиса

Promise API предоставляет конструктор Promise, который мы инициализируем с помощью new Promise() и он принимает одну функцию которая передает нам resolve и reject. Идея заключается в том, что промис либо будет resolve (выполнен успешно) - завершен и передаст нам данные. Или он может сам себя reject (отклонить), потому что, возможно, произошла ошибка, или данные были искажены, или по какой-либо другой причине, которая приведет к ошибке. Мы вызываем resolve или reject (когда готовы завершить промис) и передаем в них данные для этого промиса.

Например:
```js
let done = true;

const p = new Promise((resolve, reject) => {
  if (done) {
    resolve("выполнено успешно");
  } else {
    reject("выполнено с ошибкой");
  }
});
```
В этом примере промис проверяет глобальную константу done, и если она равна true - мы возвращаем resolve («выполнено успешно»). В противном случае возвращаем rejected («выполнено с ошибкой»).

С помощью resolve и reject мы можем передать значение. В приведенном выше примере мы просто возвращаем строку, но это может быть и объект.

### Выполнение промиса

```js
const p = new Promise((resolve, reject) => {
  resolve("Alex is cool");
});

p.then(data => {
  console.log(data); // Alex is cool
});
```
При запуске p мы выполняем промис и ожидаем успешного выполнения, используя обратный вызов then(). Так как мы создали промис, а затем сразу же выполнили resolve - передав Alex is cool, мы сразу увидем результат в консоле.

### Если нужно сделать resolve через некоторое время

Если мы хотим выполнить некоторую обработку в фоновом режиме или сделать AJAX-запрос, а затем, когда данные вернутся, сделать resolve. По сути, всё сводится к тому, что «я не хочу останавливать выполнение JavaScript, я просто хочу начать запрос, а затем, когда он вернется, разберусь с этим результатом».

Давай посмотрим, что произойдет, когда мы установим здесь тайм-аут в 1 секунду.

```js
const p = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("Alex is cool");
  }, 1000);
});

p.then(data => {
  console.log(data); // Alex is cool - через 1 секунду
});
```

Через секунду в консоле появится Alex is cool. Точно так же мы можем вызвать reject:
```js
const p = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject("Err Alex is not cool");
  }, 1000);
});

p.then(data => {
  console.log(data);
});
```
В консоле увидим Uncaught (in promise) Err Alex is not cool. Err Alex is not cool - это настоящая ошибка. Почему Uncaught (in promise) (не перехвачено промисом)? Потому что мы не словили и не обработали ошибку в промисе. Для этого нам нужно добавить в нашу цепочку catch(), передать ошибку и вывести ее через console.error.

```js
const p = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject("Err Alex is not cool");
  }, 1000);
});

p.then(data => {
  console.log(data);
}).catch(err => {
  console.error(err);
});
```
Теперь в консоле браузера через 1 секунду будет только реальная ошибка, которую мы передали. В идеале, для более детальной информации, где произошла ошибка, мы должны передать объект Error, а не просто строку. Поэтому мы обернем строку в объект Error, а затем, когда ошибка выведется в консоль, мы увидим, что у нас есть информация о том, где она произошла.
```js
reject(Error("Err Alex is not cool"));
```

### Цепочка промисов

Промис можно вернуть другому промису и таким образом создать цепочку промисов.

Отличным примером цепочки промисов является Fetch API - слой поверх XMLHttpRequest API. Его мы можем использовать для получения данных, создав цепочку промисов. Они будут выполнятся, когда мы получим данные.

Fetch API - это механизм, основанный на промисах, а вызов fetch() - он эквивалентен определению нашего собственного промиса с использованием new Promise().

В этом примере мы вызываем fetch(), чтобы получить данные о моем профиле на github, и создаем цепочку промисов.

```js
const status = response => {
  if (response.status >= 200 && response.status < 300) {
    return Promise.resolve(response);
  }
  return Promise.reject(Error(response.statusText));
};

const json = response => response.json();

fetch("https://api.github.com/users/oleksiimyzgin")
  .then(status)
  .then(json)
  .then(data => {
    console.log("Request succeeded with JSON response", data);
  })
  .catch(error => {
    console.error("Request failed", error);
  });
```

Запуск fetch() возвращает response, который имеет много свойств, из которых мы используем:

- status - числовое значение, предоставляющее код состояния HTTP;
- statusText - сообщение о состоянии, которое OK, если запрос был выполнен успешно.

У response также есть метод json(), который возвращает промис. Выполнив его он содержит нужный нам контент тела, обработанный и преобразованный в JSON.

Таким образом, учитывая эти промисы, вот что происходит: первый промис в цепочке - это определенная нами функция, называемая status(), которая проверяет статус ответа и, если ответ успешный (между 200 и 299), то выполнится resolve, в противном случае reject.

Если выполняется reject, то цепочка промисов пропустит все перечисленные then() и перейдет непосредственно к первому catch() внизу, в котором будет записан текст Request failed (Ошибка запроса) вместе с сообщением об ошибке.

Если операция прошла успешно то выполняется resolve, затем вызывается функция json(), которую мы определили. Поскольку предыдущий промис, в случае успеха, вернул объект response, мы получаем его в качестве входных данных для второго промиса.

В этом случае мы возвращаем данные, обработанные JSON, поэтому третий промис получает JSON напрямую:

```js
.then((data) => {
  console.log('Request succeeded with JSON response', data)
})
```
это мы и выводим в консоль.

### Обработка ошибок

В приведенном примере, в предыдущем разделе, у нас есть catch(), который был добавлен к цепочке промисов. Когда что-либо в цепочке промисов дает сбой и вызывает ошибку или отклоняет промис, управление переходит к ближайшему catch() по цепочке.
```js
new Promise((resolve, reject) => {
  throw new Error("New Error");
})
  .then(res => console.log(res))
  .catch(err => {
    console.error(err); // Error: New Error
  });

// или

new Promise((resolve, reject) => {
  reject(Error("New Error"));
})
  .then(res => console.log(res))
  .catch(err => {
    console.error(err); // Error: New Error
  });
```

### Каскадные ошибки

Если внутри catch() мы вызываем ошибку, то можно добавить второй catch() для её обработки и так далее.
```js
new Promise((resolve, reject) => {
  throw new Error("Error 1");
})
  .catch(err => {
    throw new Error("Error 2");
  })
  .catch(err => {
    console.error(err); // Error: Error 2
  });
```

### Оркестровые промисы

### Promise.all()

Если нам нужно синхронизировать различные промисы, то Promise.all() поможет определить список промисов и выполнить что-то только тогда, когда все они будут выполнены успешно.
```js
const weather = new Promise(resolve => {
  setTimeout(() => {
    resolve({ temp: 25, condition: "Солнечно" });
  }, 2000);
});

const person = new Promise(resolve => {
  setTimeout(() => {
    resolve({ name: "Alex", dev: "Frontend" });
  }, 500);
});

Promise.all([weather, person])
  .then(res => {
    console.log("Array of results", res);
  })
  .catch(err => {
    console.error(err);
  });
```
Синтаксис ES2015 деструктуризации позволяет сделать так:
```js
Promise.all([weather, person]).then(([weatherInfo, personInfo]) => {
  console.log("Results", weatherInfo, personInfo);
});
```
В данном примере мы получим ответ только после 2 секунд, потому что мы ждем, пока каждый промис будет выполнен успешно, прежде чем запустим then. Иными словами, самый медленный response будет решать, через сколько вернутся все промисы.

Это был пример с setTimeouts. Сейчас давай разберем с реальными данными. Нам нужно 2 API, с которых мы получим данные. Берём 2 учетные записи с github.

Так как мы получаем в качестве ответа поток данных, мы должны его преобразовать в читаемый json. Ранее мы делали это с одним ответом через response.json(). Как это сделать если у нас два response? Мы перебираем response с помощью map, который вернет новый массив и на каждом res вызываем второй промис json().

```js
const data1 = fetch("https://api.github.com/users/oleksiimyzgin");
const data2 = fetch("https://api.github.com/users/leoyats");

Promise.all([data1, data2])
  .then(response => {
    return Promise.all(response.map(res => res.json()));
  })
  .then(response => {
    console.log(response);
  });
```
Почему мы должны вызывать res.json?

Причина в том, что существует много разных типов данных, которые могут вернуться. В MDN документации написано что body может вернуться в виде arrayBuffer, blob, json, text или formData. Но не стоит предполагать, что твой API или AJAX запросы всегда будут json, так как это могут быть данные любого типа, которые там есть.

### Promise.race()

Promise.race() возвращает resolve или reject промис, в зависимости от того, с каким результатом завершится первый из переданных ему промисов: со значением или с ошибкой. В данном примере выполнится только самый быстрый промис.
```js
const promiseOne = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("Return after 2 seconds");
  }, 2000);
});
const promiseTwo = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("Return after 1 second");
  }, 1000);
});

Promise.race([promiseOne, promiseTwo]).then(result => {
  console.log(result); // Return after 1 second
});
```

  **[⬆ Наверх](#top)**

309. ### <a name="309"></a> Fetch API

```js
let promise = fetch(url, [options])
````	
- url – URL для отправки запроса.
- options – дополнительные параметры: метод, заголовки и так далее.
	
Без options это простой GET-запрос, скачивающий содержимое по адресу url.

Браузер сразу же начинает запрос и возвращает промис, который внешний код использует для получения результата.

Процесс получения ответа обычно происходит в два этапа.

### Во-первых, promise выполняется с объектом встроенного класса Response в качестве результата, как только сервер пришлёт заголовки ответа.

На этом этапе мы можем проверить статус HTTP-запроса и определить, выполнился ли он успешно, а также посмотреть заголовки, но пока без тела ответа.

Промис завершается с ошибкой, если fetch не смог выполнить HTTP-запрос, например при ошибке сети или если нет такого сайта. HTTP-статусы 404 и 500 не являются ошибкой.

Мы можем увидеть HTTP-статус в свойствах ответа:

- status – код статуса HTTP-запроса, например 200.
- ok – логическое значение: будет true, если код HTTP-статуса в диапазоне 200-299.

Например:
```js
let response = await fetch(url);

if (response.ok) { // если HTTP-статус в диапазоне 200-299
  // получаем тело ответа (см. про этот метод ниже)
  let json = await response.json();
} else {
  alert("Ошибка HTTP: " + response.status);
}
```	
### Во-вторых, для получения тела ответа нам нужно использовать дополнительный вызов метода.

Response предоставляет несколько методов, основанных на промисах, для доступа к телу ответа в различных форматах:

- response.text() – читает ответ и возвращает как обычный текст,
- response.json() – декодирует ответ в формате JSON,
- response.formData() – возвращает ответ как объект FormData (разберём его в следующей главе),
- response.blob() – возвращает объект как Blob (бинарные данные с типом),
- response.arrayBuffer() – возвращает ответ как ArrayBuffer (низкоуровневое представление бинарных данных),
помимо этого, response.body – это объект ReadableStream, с помощью которого можно считывать тело запроса по частям. Мы рассмотрим и такой пример несколько позже.
	
Например, получим JSON-объект с последними коммитами из репозитория на GitHub:
```js
let url = 'https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits';
let response = await fetch(url);

let commits = await response.json(); // читаем ответ в формате JSON

alert(commits[0].author.login);
```	
То же самое без await, с использованием промисов:
```js
fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits')
  .then(response => response.json())
  .then(commits => alert(commits[0].author.login));
```	
Для получения ответа в виде текста используем await response.text() вместо .json():
```js
let response = await fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits');

let text = await response.text(); // прочитать тело ответа как текст

alert(text.slice(0, 80) + '...');
```	
В качестве примера работы с бинарными данными, давайте запросим и выведем на экран логотип спецификации «fetch» (см. главу Blob, чтобы узнать про операции с Blob):
```js
let response = await fetch('/article/fetch/logo-fetch.svg');

let blob = await response.blob(); // скачиваем как Blob-объект

// создаём <img>
let img = document.createElement('img');
img.style = 'position:fixed;top:10px;left:10px;width:100px';
document.body.append(img);

// выводим на экран
img.src = URL.createObjectURL(blob);

setTimeout(() => { // прячем через три секунды
  img.remove();
  URL.revokeObjectURL(img.src);
}, 3000);	
```	
	
Fetch API предоставляет интерфейс JavaScript для работы с запросами и ответами HTTP. Он также предоставляет глобальный метод fetch() (en-US), который позволяет легко и логично получать ресурсы по сети асинхронно. Подобная функциональность ранее достигалась с помощью XMLHttpRequest .
```jsx harmony
let response = await fetch(url);

if (response.ok) { // если HTTP-статус в диапазоне 200-299
  // получаем тело ответа (см. про этот метод ниже)
  let json = await response.json();
} else {
  alert("Ошибка HTTP: " + response.status);
}
```
```jsx harmony
Типичный запрос с помощью fetch состоит из двух операторов await:

let response = await fetch(url, options); // завершается с заголовками ответа
let result = await response.json(); // читать тело ответа в формате JSON

Или, без await:

fetch(url, options)
  .then(response => response.json())
  .then(result => /* обрабатываем результат */)
```

Параметры ответа:
- response.status – HTTP-код ответа,
- response.ok – true, если статус ответа в диапазоне 200-299.
- response.headers – похожий на Map объект с HTTP-заголовками.

Методы для получения тела ответа:
- response.text() – возвращает ответ как обычный текст,
- response.json() – преобразовывает ответ в JSON-объект,
- response.formData() – возвращает ответ как объект FormData (кодировка form/multipart, см. следующую главу),
- response.blob() – возвращает объект как Blob (бинарные данные с типом),
- response.arrayBuffer() – возвращает ответ как ArrayBuffer (низкоуровневые бинарные данные),

Опции fetch, которые мы изучили на данный момент:
- method – HTTP-метод,
- headers – объект с запрашиваемыми заголовками (не все заголовки разрешены),
- body – данные для отправки (тело запроса) в виде текста, FormData, BufferSource, Blob или UrlSearchParams.

https://learn.javascript.ru/fetch

### Пример => GET запрос, json
```js
 fetch('http://localhost:3000/people')
  .then((data) => data.json())
  .then((data) => createCards(data))
  .catch((err) => console.error(err));

// более подробный код =>

window.addEventListener('DOMContentLoaded', () => {
  
  function req() {

    // ! fetch =>

    /* fetch('http://localhost:3000/people')
      .then((data) => data.json())
      .then((data) => createCards(data))
      .catch((err) => console.error(err)); */

    // ! fetch с функцией getResource =>

    getResource('http://localhost:3000/people')
      .then((data) => createCards(data))
      .catch((err) => console.error(err));

    this.remove();
  }

  document
    .querySelector('button')
    .addEventListener('click', req, { once: true });

  // ! fetch функция getResource

  async function getResource(url) {
    const res = await fetch(`${url}`);

    if (!res.ok) {
      throw new Error(`Could not fetch ${url}, status: ${res.status}`);
    }

    return await res.json();
  }

  function createCards(response) {
    response.forEach((item) => {
      let card = document.createElement('div');

      card.classList.add('card');

      let icon;

      if (item.sex === 'male') {
        icon = 'icons/mars.png';
      } else {
        icon = 'icons/female.png';
      }

      card.innerHTML = `
              <img src="${item.photo}" alt="photo">
              <div class="name">${item.name} ${item.surname}</div>
              <div class="sex">
                <img src=${icon} alt="male">
              </div>
              <div class="age">${item.age}</div>
            `;
      document.querySelector('.app').appendChild(card);
    });
  }
});
```

### Пример => POST запрос с json
```js
window.addEventListener('DOMContentLoaded', () => {

  const form = document.querySelector('form');

  function req(e) {

    e.preventDefault();

    let formData = new FormData(form);
    formData.append('id', Math.random());

    let obj = {};
    formData.forEach((value, key) => {
      obj[key] = value;
    });

      // ! fetch с функцией getResource POST =>

      getResource('http://localhost:3000/people', obj)
      .then(data => console.log(data))
      .catch(err => console.error(err));
  }

  form.addEventListener('submit', (e) => req(e), {'once': true});

  // ! fetch функция getResource с POST

  async function getResource(url, data) {
    const res = await fetch(`${url}`, {
      method: "POST",
      headers: {
        'Content-type': 'application/json'
      },
      body: JSON.stringify(data)
    });

    if (!res.ok) {
      throw new Error(`Could not fetch ${url}, status: ${res.status}`);
    }

    return await res.json();
  }
});
```

### Пример => POST запрос с formData
```js
window.addEventListener('DOMContentLoaded', () => {

  const form = document.querySelector('form');

  function req(e) {

    e.preventDefault();

    let formData = new FormData(form); 

      // ! fetch с функцией getResource POST =>

      getResource('./api.php', formData)
      .then(data => console.log(data))
      .catch(err => console.error(err));
  }

  form.addEventListener('submit', (e) => req(e), {once: true});

  async function getResource(url, data) {
    const res = await fetch(`${url}`, {
      method: "POST",
      /* headers: {
        'Content-type': 'multipart/form-data'
      }, */ 
      // звголовок не нужен в этом случае, когда XMLHttpRequest + formData - setRequestHeader тут не нужен
      body: data
    });

    if (!res.ok) {
      throw new Error(`Could not fetch ${url}, status: ${res.status}`);
    }

    return await res.text();
  }
});
```

### Пример
```js
window.addEventListener('DOMContentLoaded', () => { 
  // Forms

  const forms = document.querySelectorAll('form');
  const message = {
    loading: 'img/form/spinner.svg',
    success: 'Спасибо! Скоро мы с вами свяжемся',
    failure: 'Что-то пошло не так...'
  };

  forms.forEach(item => {
    postData(item);
  });

  function postData(form) {
    form.addEventListener('submit', (e) => {
      e.preventDefault();

      let statusMessage = document.createElement('img');
      statusMessage.src = message.loading;
      statusMessage.style.cssText = `
      display: block;
      margin: 0 auto;
      `;
      form.appendChild(statusMessage);
      form.insertAdjacentElement('afterend', statusMessage);
  

      
      // request.setRequestHeader('Content-type', 'application/json; charset=utf-8');

      // когда мы используем связку XMLHttpRequest обьекта + form-data, нам заголовок устанавливать не нужно, он устанавливается автоматически
      
      const formData = new FormData(form);

      const object = {};
      formData.forEach(function(value, key){
          object[key] = value;
      });


      fetch('server.php', {
        method: 'POST',
        headers: {
          'Content-type': 'application/json'
        }, // если formData - закомментировать headers
        body: JSON.stringify(object) // или formData, если работать нужно не с json
      })
      .then(data => data.text())
      .then(data => {
        console.log(data);
        showThanksModal(message.success);
        statusMessage.remove();
      }).catch(() => {
        showThanksModal(message.failure);
      }).finally(() => {
        form.reset();
      });

    });
  }

  function showThanksModal(message) {
    const prevModalDialog = document.querySelector('.modal__dialog');

    prevModalDialog.classList.add('hide');
    openModal();

    const thanksModal = document.createElement('div');
    thanksModal.classList.add('modal__dialog');

  thanksModal.innerHTML = `
    <div class="modal__content">
      <div class="modal__close" data-close>×</div>
      <div class="modal__title">${message}</div>
    </div>
  `;

    document.querySelector('.modal').append(thanksModal);
    setTimeout(() => {
      thanksModal.remove();
      prevModalDialog.classList.add('show');
      prevModalDialog.classList.remove('hide');
      closeModal();

    }, 4000);
  }

  // Fetch

  fetch('https://jsonplaceholder.typicode.com/posts', {
    method: 'POST',
    body: JSON.stringify({name: 'Alex'}),
    headers: {
      'Content-type': 'application/json'
    }
  })
    .then(response => response.json())
    .then(json => console.log(json));

});	
```	

  **[⬆ Наверх](#top)**
 

310. ### <a name="310"></a> Async/Await (ES8)


### Итого

Ключевое слово async перед объявлением функции:

- Обязывает её всегда возвращать промис.
- Позволяет использовать await в теле этой функции.

Ключевое слово await перед промисом заставит JavaScript дождаться его выполнения, после чего:

- Если промис завершается с ошибкой, будет сгенерировано исключение, как если бы на этом месте находилось throw.
- Иначе вернётся результат промиса.

Вместе они предоставляют отличный каркас для написания асинхронного кода. Такой код легко и писать, и читать.

Хотя при работе с async/await можно обходиться без promise.then/catch, иногда всё-таки приходится использовать эти методы (на верхнем уровне вложенности, например). Также await отлично работает в сочетании с Promise.all, если необходимо выполнить несколько задач параллельно.

# async/await

`async/await` - это синтаксический сахар для промисов, позволяющий писать их в привычном синхронном стиле.

Ключевое слово `async` позволяет сделать из обычной функции асинхронную.

Такая функция делает две вещи:

* Оборачивает возвращаемое значение в Promise
* Позволяет использовать ключевое слово `await`

По сути она делает следующее:

```jsx
// обычная функция
function hello() {
    return 'Hello'
}

// асинхронная функция
async function hello() {
    return 'Hello'
}

// эквивалентно
function hello() {
    return new Promise((resolve, reject) => {
        try {
            // здесь может быть более сложный код, который может вернуть значение
            // или выбросить ошибку
            resolve('Hello')
        } catch (error) {
            reject(error)
        }
    })
}
```

Асинхронные функции становятся мощным инструментом при использовании ключевого слова `await`. `await` **работает только в асинхронных функциях.**

Мы можем использовать await перед promise-based функцией, чтобы остановить поток выполнения и дождаться результата её выполнения (результат Promise).

`await` можно использовать с любыми функциями, которые возвращают промис.

Пример:

```jsx
async function hello() {
  return greeting = await Promise.resolve('Hello')
}
```

Для обработки ошибок в `async/await` используется обычный `try/catch`.

## Подводные камни

Если написать несколько `async/await` подряд в случак, когда они независимы, то один промис будет дожидаться выполнения другого. Пример:

```jsx
await queryClient.prefetchQuery(QUERY_KEYS.BANNERS(restaurant?.id), () => getBanners(restaurant?.id))
await queryClient.prefetchQuery(QUERY_KEYS.CATEGORIES(restaurant?.id), () => getCategories(restaurant?.id))
await queryClient.prefetchQuery(QUERY_KEYS.POPULAR_PRODUCTS(restaurant?.id), () => getPopularProducts(restaurant?.id))
await queryClient.prefetchQuery(QUERY_KEYS.PRODUCTS(restaurant?.id), () => getProducts(restaurant?.id))
```

Можно вынести их в переменные или использовать `Promise.all`:

```jsx
const banners = queryClient.prefetchQuery(QUERY_KEYS.BANNERS(restaurant?.id), () => getBanners(restaurant?.id))
const categories queryClient.prefetchQuery(QUERY_KEYS.CATEGORIES(restaurant?.id), () => getCategories(restaurant?.id))
const popularProducts = await queryClient.prefetchQuery(QUERY_KEYS.POPULAR_PRODUCTS(restaurant?.id), () => getPopularProducts(restaurant?.id))
const products = await queryClient.prefetchQuery(QUERY_KEYS.PRODUCTS(restaurant?.id), () => getProducts(restaurant?.id))

await banners
await categories
await popularProducts
await products

// можно и так:

Promise.all([banners, categories, popularProducts, products])
```

Т. к. промисы в таком случае создаются одновременно, а значит и запускается асинхронный код, то один запрос не будет блокировать другой.

Подробнее: [Недостатки async/await (MDN)](https://developer.mozilla.org/ru/docs/Learn/JavaScript/Asynchronous/Promises#%D0%BD%D0%B5%D0%B4%D0%BE%D1%81%D1%82%D0%B0%D1%82%D0%BA%D0%B8\_asyncawait).

https://learn.javascript.ru/async-await

### Пример
```js
const delay = ms => {
  return new Promise(r => setTimeout(() => r(), ms))
}

delay(2000).then(() => console.log('2 sec'))


const url = 'https://jsonplaceholder.typicode.com/todos'


// пример промисы ->

function fetchTodos() {
  console.log('Fetch todo started...')
  return delay(2000)
  .then(() => {
    return fetch(url)
  })
  .then(response => response.json())
}

fetchTodos().then(data => {
  console.log('Data', data)
})
.catch(e => console.error(e))


// пример async await ->

async function fetchAsyncTodos() {
  console.log('Fetch todo started...')
  try {
    await delay(2000)
    const response = await fetch(url)
    const data = await response.json()
    console.log('Data', data)
  } catch(e) {
    console.error(e)
  } finally {
    console.log('Smth...')
  }  
}

fetchAsyncTodos()
```

### Пример
```js
window.addEventListener('DOMContentLoaded', () => {

  // Class, Используем Классы для карточек

  class MenuCard {
    constructor(src, alt, title, descr, price, parentSelector, ...classess ) {
      this.src = src;
      this.alt = alt;
      this.title = title;
      this.descr = descr;
      this.price = price;
      this.classess = classess;
      this.parent = document.querySelector(parentSelector);
      this.transfer = 27;
      this.changeToUAH();
    }

    changeToUAH() {
      this.price = this.price * this.transfer;
    }

    render() {
      const element = document.createElement('div');
      if (this.classess.length === 0) {
        this.element = 'menu__item';
        element.classList.add(this.element);
      } else {
        this.classess.forEach(className => element.classList.add(className));
      }

      element.innerHTML = `
          <img src=${this.src} alt=${this.alt}>
          <h3 class="menu__item-subtitle">${this.title}</h3>
          <div class="menu__item-descr">${this.descr}</div>
          <div class="menu__item-divider"></div>
          <div class="menu__item-price">
              <div class="menu__item-cost">Цена:</div>
              <div class="menu__item-total"><span>${this.price}</span> грн/день</div>
          </div>
      `;
      this.parent.append(element);
    }
  }


  const getResource = async (url) => {
    const res = await fetch(url);
    
    if (!res.ok) {
      throw new Error(`Could not fetch ${url}, status: ${res.status}`);
    }

    return await res.json();
};

  getResource('http://localhost:3000/menu')
  .then(data => {
    data.forEach(({img, altimg, title, descr, price}) => {
      new MenuCard(img, altimg, title, descr, price, '.menu .container').render();
    });
  });


  // Еще один вариант =>

  /* getResource('http://localhost:3000/menu')
  .then(data => createCard(data));

  function createCard(data) {
    data.forEach(({img, altimg, title, descr, price}) => {
      const element = document.createElement('div');

      element.classList.add('menu__item');

      element.innerHTML = `
        <img src=${img} alt=${altimg}>
        <h3 class="menu__item-subtitle">${title}</h3>
        <div class="menu__item-descr">${descr}</div>
        <div class="menu__item-divider"></div>
        <div class="menu__item-price">
            <div class="menu__item-cost">Цена:</div>
            <div class="menu__item-total"><span>${price}</span> грн/день</div>
        </div>
      `;

      document.querySelector('.menu .container').append(element);
    });


  } */

  
  // Forms

  const forms = document.querySelectorAll('form');
  const message = {
    loading: 'img/form/spinner.svg',
    success: 'Спасибо! Скоро мы с вами свяжемся',
    failure: 'Что-то пошло не так...'
  };

  forms.forEach(item => {
    bindPostData(item);
  });


  const postData = async (url, data) => {
    const res = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-type': 'application/json'
      },
      body: data
  });

    return await res.json();
 };


  function bindPostData(form) {
    form.addEventListener('submit', (e) => {
      e.preventDefault();

      let statusMessage = document.createElement('img');
      statusMessage.src = message.loading;
      statusMessage.style.cssText = `
      display: block;
      margin: 0 auto;
      `;
      form.appendChild(statusMessage);
      form.insertAdjacentElement('afterend', statusMessage);
  
      
      const formData = new FormData(form);

      const json = JSON.stringify(Object.fromEntries(formData.entries()));


      postData('http://localhost:3000/requests', json)
      .then(data => {
        console.log(data);
        showThanksModal(message.success);
        statusMessage.remove();
      }).catch(() => {
        showThanksModal(message.failure);
      }).finally(() => {
        form.reset();
      });

    });
  }

  function showThanksModal(message) {
    const prevModalDialog = document.querySelector('.modal__dialog');

    prevModalDialog.classList.add('hide');
    openModal();

    const thanksModal = document.createElement('div');
    thanksModal.classList.add('modal__dialog');

  thanksModal.innerHTML = `
    <div class="modal__content">
      <div class="modal__close" data-close>×</div>
      <div class="modal__title">${message}</div>
    </div>
  `;

    document.querySelector('.modal').append(thanksModal);
    setTimeout(() => {
      thanksModal.remove();
      prevModalDialog.classList.add('show');
      prevModalDialog.classList.remove('hide');
      closeModal();

    }, 4000);
  }

  fetch('http://localhost:3000/menu')
      .then(data => data.json())
      .then(res => console.log(res));

});
```

  **[⬆ Наверх](#top)**
	
311. ### <a name="311"></a> try catch, выдача throw

Конструкция try..catch состоит из двух основных блоков: try, и затем catch:
```js
try {

  // код...

} catch (err) {

  // обработка ошибки

}
```
Работает она так:

1. Сначала выполняется код внутри блока try {...}.
2. Если в нём нет ошибок, то блок catch(err) игнорируется: выполнение доходит до конца try и потом далее, полностью пропуская catch.
3. Если же в нём возникает ошибка, то выполнение try прерывается, и поток управления переходит в начало catch(err). Переменная err (можно использовать любое имя) содержит объект ошибки с подробной информацией о произошедшем.

```js
try {
  lalala; // ошибка, переменная не определена!
} catch(err) {
  alert(err.name); // ReferenceError
  alert(err.message); // lalala is not defined
  alert(err.stack); // ReferenceError: lalala is not defined at (...стек вызовов)

  // Можем также просто вывести ошибку целиком
  // Ошибка приводится к строке вида "name: message"
  alert(err); // ReferenceError: lalala is not defined
}
```
```js
let json = "{ некорректный JSON }";

try {

  let user = JSON.parse(json); // <-- тут возникает ошибка...
  alert( user.name ); // не сработает

} catch (e) {
  // ...выполнение прыгает сюда
  alert( "Извините, в данных ошибка, мы попробуем получить их ещё раз." );
  alert( e.name );
  alert( e.message );
}
```

### выдача throwing

Оператор throw генерирует ошибку.
```js
throw <объект ошибки>
```
Технически в качестве объекта ошибки можно передать что угодно. Это может быть даже примитив, число или строка, но всё же лучше, чтобы это был объект, желательно со свойствами name и message (для совместимости со встроенными ошибками).

```js
let json = '{ "age": 30 }'; // данные неполны

try {

  let user = JSON.parse(json); // <-- выполнится без ошибок

  if (!user.name) {
    throw new SyntaxError("Данные неполны: нет имени"); // (*)
  }

  alert( user.name );

} catch(e) {
  alert( "JSON Error: " + e.message ); // JSON Error: Данные неполны: нет имени
}
```
В строке (*) оператор throw генерирует ошибку SyntaxError с сообщением message. Точно такого же вида, как генерирует сам JavaScript. Выполнение блока try немедленно останавливается, и поток управления прыгает в catch.

```js
try {
  alert( 'try' );
  if (confirm('Сгенерировать ошибку?')) BAD_CODE();
} catch (e) {
  alert( 'catch' );
} finally {
  alert( 'finally' );
}
```
У кода есть два пути выполнения:

Если вы ответите на вопрос «Сгенерировать ошибку?» утвердительно, то try -> catch -> finally.
Если ответите отрицательно, то try -> finally.

### Example
```js
const data = [
  { id: 'box', tag: 'div' },
  { id: '', tag: 'nav' },
  { id: 'circle', tag: 'span' },
];

try {
  data.forEach((block0bj, i) => {
    const block = document.createElement(block0bj.tag);

    if (!block0bj.id) throw new SyntaxError(`B данных под номером ${i + 1} нет id`);

    block.setAttribute('id', block0bj.id);
    document.body.append(block);
  });
} catch(e) {
  console.error(e.name);
  console.log(e.message);
  console.log(e.stack);
}
```


  **[⬆ Наверх](#top)**
	
312. ### <a name="312"></a> Библиотека Axios

Axios — JavaScript-библиотека, основанная на обещаниях, для выполнения HTTP-запросов.

	
GET запросы JSON данных
Типичная задача во frontend'е — получение JSON данных с сервера. Axios для этого требуется 1 действие, fetch - 2 действия: запрос + вызов метода .json() над результатом запроса.
	
Axios
```js
axios.get('https://jsonplaceholder.typicode.com/posts/1')
  .then(response => console.log(response));
```	

Обработка ошибок
	
Axios обрабатывает ошибки логично. Если сервер вернул ответ с HTTP статусом ошибки (например 404 или 500), то обещание будет отвергнуто.
```js
axios.get(url)
  .then(result => console.log('success:', result))
  .catch(error => console.log('error:', error));
```
	
Некоторые люди скажут: «В чем проблема? Вы запросили данные с сервера, и их получили. И если сервер ответил статусом 404, то это ответ сервера и точка.» На мой взгляд, для разработчика приложений, ответ сервера с кодом ошибки считается таким же исключением как сетевой сбой и должно обрабатываться соответствующим образом.

POST запросы
С axios всё просто, а с fetch уже не так: JSON обязан быть преобразован в строку, а заголовок Content-Type должен указывать, что отправляются JSON данные, иначе сервер будет рассматривать их как строку.

Axios
```js
axios.post('/user', {
  firstName: 'Fred',
  lastName: 'Flintstone'
});
```
	
Базовые значения для запросов
Как вы могли заметить, fetch это явный API, вы ничего не получаете, если об этом не просите. Если используется аутентификация, основанная на сохранении сессии пользователя, то надо явно указывать куку. Если сервер расположен на поддомене, то надо явно прописывать CORS. Эти опции надо прописывать для всех вызовов сервера и у fetch нет механизма для установки значений по-умолчанию, а у axios есть.

```js	
axios.defaults.baseURL = 'https://api.example.com';
axios.defaults.headers.common['Accept'] = 'application/json';
axios.defaults.headers.post['Content-Type'] = 'application/json';
```
	
Заключение
Эквивалентный код
	
Axios
```js
function addUser(details) {
  return axios.post('https://api.example.com/user', details);
}
```
### Пример axios GET запрос

```js
window.addEventListener('DOMContentLoaded', () => {

  function req() {
      
    // ! axios =>

    getResource('http://localhost:3000/people')
    .then(data => createCards(data.data))
    .catch(err => console.error(err));

    this.remove();
  }

  document.querySelector('button').addEventListener('click', req, {once: true});

  // ! axios функция getResource =>

  async function getResource(url) {
    const res = await axios(`${url}`);

    if (res.status !== 200) {
      throw new Error(`Could not fetch ${url}, status: ${res.status}`);
    }

    return res;
  }


  function createCards(response) {
    response.forEach(item => {
      let card = document.createElement('div');

      card.classList.add('card');

      let icon;

      if (item.sex === 'male') {
        icon = "icons/mars.png"
      } else {
        icon = "icons/female.png"
      }

      card.innerHTML = `
        <img src="${item.photo}" alt="photo">
        <div class="name">${item.name} ${item.surname}</div>
        <div class="sex">
          <img src=${icon} alt="male">
        </div>
        <div class="age">${item.age}</div>
      `;
      document.querySelector('.app').appendChild(card);
    });
  }
});
``` 

### Пример axios POST запрос с json

```js
window.addEventListener('DOMContentLoaded', () => {

  const form = document.querySelector('form');

  function req(e) {

    e.preventDefault();

    let formData = new FormData(form);
    formData.append('id', Math.random());

    let obj = {};
    formData.forEach((value, key) => {
      obj[key] = value;
    });

      axios.post('http://localhost:3000/people', obj);
  }

  form.addEventListener('submit', (e) => req(e), {'once': true});
});
```

### Пример axios POST запрос с formData
```js
window.addEventListener('DOMContentLoaded', () => {

  const form = document.querySelector('form');

  function req(e) {

    e.preventDefault();

    let formData = new FormData(form);

      axios({
        method: 'post',
        url: './api.php',
        data: formData,
        headers: {'content-type': 'multipart/form-data'} // можно использовать headers, но это по желанию, можно и без него
      })
      .then(data => console.log(data.data))
  }

  form.addEventListener('submit', (e) => req(e), {'once': true});
});
```

### Пример
```js
 window.addEventListener('DOMContentLoaded', () => {

  // Class, Используем Классы для карточек

  class MenuCard {
    constructor(src, alt, title, descr, price, parentSelector, ...classess ) {
      this.src = src;
      this.alt = alt;
      this.title = title;
      this.descr = descr;
      this.price = price;
      this.classess = classess;
      this.parent = document.querySelector(parentSelector);
      this.transfer = 27;
      this.changeToUAH();
    }

    changeToUAH() {
      this.price = this.price * this.transfer;
    }

    render() {
      const element = document.createElement('div');
      if (this.classess.length === 0) {
        this.element = 'menu__item';
        element.classList.add(this.element);
      } else {
        this.classess.forEach(className => element.classList.add(className));
      }

      element.innerHTML = `
          <img src=${this.src} alt=${this.alt}>
          <h3 class="menu__item-subtitle">${this.title}</h3>
          <div class="menu__item-descr">${this.descr}</div>
          <div class="menu__item-divider"></div>
          <div class="menu__item-price">
              <div class="menu__item-cost">Цена:</div>
              <div class="menu__item-total"><span>${this.price}</span> грн/день</div>
          </div>
      `;
      this.parent.append(element);
    }
  }


  const getResource = async (url) => {
    const res = await fetch(url);
    
    if (!res.ok) {
      throw new Error(`Could not fetch ${url}, status: ${res.status}`);
    }

    return await res.json();
};

  // getResource('http://localhost:3000/menu')
  // .then(data => {
  //   data.forEach(({img, altimg, title, descr, price}) => {
  //     new MenuCard(img, altimg, title, descr, price, '.menu .container').render();
  //   });
  // });


  
  // axios.get('http://localhost:3000/menu')
  // .then(data => console.log(data));


  axios.get('http://localhost:3000/menu')
  .then(data => {
    data.data.forEach(({img, altimg, title, descr, price}) => {
      new MenuCard(img, altimg, title, descr, price, '.menu .container').render();
    });
  });



  // Forms

  const forms = document.querySelectorAll('form');
  const message = {
    loading: 'img/form/spinner.svg',
    success: 'Спасибо! Скоро мы с вами свяжемся',
    failure: 'Что-то пошло не так...'
  };

  forms.forEach(item => {
    bindPostData(item);
  });


  const postData = async (url, data) => {
    const res = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-type': 'application/json'
      },
      body: data
  });

    return await res.json();
 };


  function bindPostData(form) {
    form.addEventListener('submit', (e) => {
      e.preventDefault();

      let statusMessage = document.createElement('img');
      statusMessage.src = message.loading;
      statusMessage.style.cssText = `
      display: block;
      margin: 0 auto;
      `;
      form.appendChild(statusMessage);
      form.insertAdjacentElement('afterend', statusMessage);
  

      const formData = new FormData(form);

      const json = JSON.stringify(Object.fromEntries(formData.entries()));


      postData('http://localhost:3000/requests', json)
      .then(data => {
        console.log(data);
        showThanksModal(message.success);
        statusMessage.remove();
      }).catch(() => {
        showThanksModal(message.failure);
      }).finally(() => {
        form.reset();
      });

    });
  }

  function showThanksModal(message) {
    const prevModalDialog = document.querySelector('.modal__dialog');

    prevModalDialog.classList.add('hide');
    openModal();

    const thanksModal = document.createElement('div');
    thanksModal.classList.add('modal__dialog');

  thanksModal.innerHTML = `
    <div class="modal__content">
      <div class="modal__close" data-close>×</div>
      <div class="modal__title">${message}</div>
    </div>
  `;

    document.querySelector('.modal').append(thanksModal);
    setTimeout(() => {
      thanksModal.remove();
      prevModalDialog.classList.add('show');
      prevModalDialog.classList.remove('hide');
      closeModal();

    }, 4000);
  }

});
```

### Axios & Fetch
	
`Объём шаблонного кода`

`Fetch`
```js
fetch('https://jsonplaceholder.typicode.com/todos/1')
  .then(response => response.json())
  .then(json => console.log(json))
// {
//   "userId": 1,
//   "id": 1,
//   "title": "delectus aut autem",
//   "completed": false
// }
```	

`Axios`
```js
axios.get("https://jsonplaceholder.typicode.com/todos/1")
  .then(response => console.log("response", response.data))
// {
//   "userId": 1,
//   "id": 1,
//   "title": "delectus aut autem",
//   "completed": false
// }	
```
	
`Fetch`
```js
fetch("https://jsonplaceholder.typicode.com/posts", {
  method: "POST",
  body: JSON.stringify({
    title: "Title of post",
    body: "Post Body"
  })
})
  .then(res => {
    if (!response.ok) throw Error(response.statusText);
    return response.json();
  })
  .then(data => console.log(data))
  .catch(error => console.log(error));
```
	
`Axios`
```js
axios
  .post("https://jsonplaceholder.typicode.com/posts", {
    title: "Title of post",
    body: "Body of post"
  })
  .then(response => console.log(response.data))
  .catch(error => console.log(error));	
```
	
`Обработка ошибок`

`Fetch`
```js
fetch("https://jsonplaceholder.typicode.com/todos/100000")
  .then(response => {
    if (!response.ok) throw Error(response.statusText);
    return response.json();
  })
  .then(data => console.log("data", data))
  .catch(error => {
    console.log("error", error);
  });
// error Error: Not Found
```
	
`Axios`
```js
axios
  .get("https://jsonplaceholder.typicode.com/todos/100000")
  .then(response => {
    console.log("response", response);
  })
  .catch(error => {
    console.log("error", error);
  });
// error Error: Not Found
```
	
Библиотека Axios выдаёт сведения о сетевых ошибках, а API Fetch — нет. Работая с Fetch всегда нужно проверять свойство response.ok. Для того чтобы упростить решение данной задачи, проверку этой ошибки можно оформить в виде отдельной функции:
```js
const checkForError = response => {
  if (!response.ok) throw Error(response.statusText);
  return response.json();
};
fetch("https://jsonplaceholder.typicode.com/todos/100000")
  .then(checkForError)
  .then(data => console.log("data", data))
  .catch(error => {
    console.log("error", error);
  });	
```	
		
	
### Axios
	
Axios основан на промисах, что дает вам возможность использовать возможности JavaScript async и await для получения более удобочитаемого асинхронного кода.

Axios это один из самых популярных HTTP клиентов для браузеров и node.js, основанный на промисах.

В Axios есть поддержка запросов, получение ответов от сервера, их трансформация и автоматическая конвертация в JSON.
	
### Создание запроса GET
 
Добавьте в компонент следующий код:
```jsx harmony
import React from 'react';

import axios from 'axios';

export default class PersonList extends React.Component {
  state = {
    persons: []
  }

  componentDidMount() {
    axios.get(`https://jsonplaceholder.typicode.com/users`)
      .then(res => {
        const persons = res.data;
        this.setState({ persons });
      })
  }

  render() {
    return (
      <ul>
        { this.state.persons.map(person => <li>{person.name}</li>)}
      </ul>
    )
  }
}	
```
	
### Составление запроса POST
```jsx harmony	
import React from 'react';
import axios from 'axios';

export default class PersonList extends React.Component {
  state = {
    name: '',
  }

  handleChange = event => {
    this.setState({ name: event.target.value });
  }

  handleSubmit = event => {
    event.preventDefault();

    const user = {
      name: this.state.name
    };

    axios.post(`https://jsonplaceholder.typicode.com/users`, { user })
      .then(res => {
        console.log(res);
        console.log(res.data);
      })
  }

  render() {
    return (
      <div>
        <form onSubmit={this.handleSubmit}>
          <label>
            Person Name:
            <input type="text" name="name" onChange={this.handleChange} />
          </label>
          <button type="submit">Add</button>
        </form>
      </div>
    )
  }
}	
```
	
### Создание запроса DELETE
```jsx harmony
import React from 'react';
import axios from 'axios';

export default class PersonList extends React.Component {
  state = {
    id: '',
  }

  handleChange = event => {
    this.setState({ id: event.target.value });
  }

  handleSubmit = event => {
    event.preventDefault();

    axios.delete(`https://jsonplaceholder.typicode.com/users/${this.state.id}`)
      .then(res => {
        console.log(res);
        console.log(res.data);
      })
  }

  render() {
    return (
      <div>
        <form onSubmit={this.handleSubmit}>
          <label>
            Person ID:
            <input type="text" name="id" onChange={this.handleChange} />
          </label>
          <button type="submit">Delete</button>
        </form>
      </div>
    )
  }
}	
```				
https://developer.mozilla.org/ru/docs/Learn/JavaScript/Client-side_web_APIs/Fetching_data	

  **[⬆ Наверх](#top)**
	
313. ### <a name="313"></a> Получение данных с сервера. Async/Await. Создание карточек меню. Forms

https://github.com/yankovalenko94/JS_task_answers/blob/master/JS_step_16/Food/js/script.js

Local server + json server ->

```js
// Используем классы для создание карточек меню

    class MenuCard {
        constructor(src, alt, title, descr, price, parentSelector, ...classes) {
            this.src = src;
            this.alt = alt;
            this.title = title;
            this.descr = descr;
            this.price = price;
            this.classes = classes;
            this.parent = document.querySelector(parentSelector);
            this.transfer = 27;
            this.changeToUAH(); 
        }

        changeToUAH() {
            this.price = this.price * this.transfer; 
        }

        render() {
            const element = document.createElement('div');

            if (this.classes.length === 0) {
                this.classes = "menu__item";
                element.classList.add(this.classes);
            } else {
                this.classes.forEach(className => element.classList.add(className));
            }

            element.innerHTML = `
                <img src=${this.src} alt=${this.alt}>
                <h3 class="menu__item-subtitle">${this.title}</h3>
                <div class="menu__item-descr">${this.descr}</div>
                <div class="menu__item-divider"></div>
                <div class="menu__item-price">
                    <div class="menu__item-cost">Цена:</div>
                    <div class="menu__item-total"><span>${this.price}</span> грн/день</div>
                </div>
            `;
            this.parent.append(element);
        }
    }

    getResource('http://localhost:3000/menu')
        .then(data => {
            data.forEach(({img, altimg, title, descr, price}) => {
                new MenuCard(img, altimg, title, descr, price, ".menu .container").render();
            });
        });

// Создание карточек без шаблона ->

    // getResource('http://localhost:3000/menu')
    //     .then(data => createCard(data));

    // function createCard(data) {
    //     data.forEach(({img, altimg, title, descr, price}) => {
    //         const element = document.createElement('div');

    //         element.classList.add("menu__item");

    //         element.innerHTML = `
    //             <img src=${img} alt=${altimg}>
    //             <h3 class="menu__item-subtitle">${title}</h3>
    //             <div class="menu__item-descr">${descr}</div>
    //             <div class="menu__item-divider"></div>
    //             <div class="menu__item-price">
    //                 <div class="menu__item-cost">Цена:</div>
    //                 <div class="menu__item-total"><span>${price}</span> грн/день</div>
    //             </div>
    //         `;
    //         document.querySelector(".menu .container").append(element);
    //     });
    // }

    // Forms

    const forms = document.querySelectorAll('form');
    const message = {
        loading: 'img/form/spinner.svg',
        success: 'Спасибо! Скоро мы с вами свяжемся',
        failure: 'Что-то пошло не так...'
    };

    forms.forEach(item => {
        bindPostData(item);
    });

    const postData = async (url, data) => {
        let res = await fetch(url, {
            method: "POST",
            headers: {
                'Content-Type': 'application/json'
            },
            body: data
        });
    
        return await res.json();
    };

    async function getResource(url) {
        let res = await fetch(url);
    
        if (!res.ok) {
            throw new Error(`Could not fetch ${url}, status: ${res.status}`);
        }
    
        return await res.json();
    }

    function bindPostData(form) {
        form.addEventListener('submit', (e) => {
            e.preventDefault();

            let statusMessage = document.createElement('img');
            statusMessage.src = message.loading;
            statusMessage.style.cssText = `
                display: block;
                margin: 0 auto;
            `;
            form.insertAdjacentElement('afterend', statusMessage);
        
            const formData = new FormData(form);

            const json = JSON.stringify(Object.fromEntries(formData.entries()));

            postData('http://localhost:3000/requests', json)
            .then(data => {
                console.log(data);
                showThanksModal(message.success);
                statusMessage.remove();
            }).catch(() => {
                showThanksModal(message.failure);
            }).finally(() => {
                form.reset();
            });
        });
    }

    function showThanksModal(message) {
        const prevModalDialog = document.querySelector('.modal__dialog');

        prevModalDialog.classList.add('hide');
        openModal();

        const thanksModal = document.createElement('div');
        thanksModal.classList.add('modal__dialog');
        thanksModal.innerHTML = `
            <div class="modal__content">
                <div class="modal__close" data-close>×</div>
                <div class="modal__title">${message}</div>
            </div>
        `;
        document.querySelector('.modal').append(thanksModal);
        setTimeout(() => {
            thanksModal.remove();
            prevModalDialog.classList.add('show');
            prevModalDialog.classList.remove('hide');
            closeModal();
        }, 4000);
    }
});
```

  **[⬆ Наверх](#top)**

	
314. ### <a name="314"></a> Регулярные выражения RegExp

Регулярные выражения (их еще называют regexp, или regex) — это механизм для поиска и замены текста. В строке, файле, нескольких файлах... Их используют разработчики в коде приложения, тестировщики в автотестах, да просто при работе в командной строке!

«Длинный» синтаксис:

regexp = new RegExp("шаблон", "флаги");

И короткий синтаксис, использующий слеши "/":

- regexp = /шаблон/; // без флагов
- regexp = /шаблон/gmi; // с флагами gmi

Регулярное выражение состоит из шаблона и необязательных флагов: 
- g - С этим флагом поиск ищет все совпадения, без него – только первое, 
- i - С этим флагом поиск не зависит от регистра: нет разницы между A и a, 
- m - Многострочный режим, 
- u - Включает полную поддержку юникода. Флаг разрешает корректную обработку суррогатных пар, 
- s - Включает режим «dotall», при котором точка . может соответствовать символу перевода строки \n, y - Режим поиска на конкретной позиции в тексте.
	
- Без флагов и специальных символов, которые мы изучим позже, поиск по регулярному выражению аналогичен поиску подстроки.
- Метод str.match(regexp) ищет совпадения: все, если есть флаг g, иначе только первое.
- Метод str.replace(regexp, replacement) заменяет совпадения с regexp на replacement: все, если у регулярного выражения есть флаг g, иначе только первое.
- Метод regexp.test(str) возвращает true, если есть хоть одно совпадение, иначе false.

\D - не числа

\W - не буквы


i - если мы хотим что-то найти вне зависимости регистра

g - глобал, это когда мы пытаемся найти сразу несколько вхождений

m - включает многострочный режим


\d - ищем цыфры

\w - ищем все слова, все буквы

\s - ищем все пробелы 

\b - граница слова

\B — не граница слова

^ - начало строки

$ - конец строки

[] - Соответствует символам в скобках

[^ ] - Соответствует символам НЕ в скобках

| - Либо Или

( )     - Группа


Квантификаторы:

* - 0 или больше

+ - 1 или больше

? - 0 или один

{3} - Точный номер

{3,4} - Диапазон номеров (минимум, максимум)


(/\./g) - экранирование - Чтобы использовать специальный символ как обычный, добавьте к нему обратную косую черту: \.. - это называется «экранирование символа

```js
/* 
new RegExp('pattern', 'flags');

/pattern/f


i - если мы хотим что-то найти вне зависимости регистра
g - глобал, это когда мы пытаемся найти сразу несколько вхождений
m - включает многострочный режим

\d - ищем цыфры
\w - ищем все слова, все буквы
\s - ищем все пробелы */


const ans = prompt('Введите ваше имя');

const reg = /n/ig;

console.log(ans.search(reg));
console.log(ans.match(reg));



const pass = prompt('Password');

console.log(pass.replace(/./g, "*"));
"." - означает все символы


(/\./g) - экранирование

console.log(pass.replace(/\./g, "*"));



console.log('12-34-56'.replace(/-/g, ':'));


const ans = prompt('Введите ваше число');

const reg = /\d/g;

console.log(reg.test(ans));

console.log(ans.match(reg));


const str = 'My name is R2D2';

console.log(str.match(/\w\d\w\d/i));



const str = 'My name is R2D2';

console.log(str.match(/\w\d\w\d/i));

console.log(str.match(/\D/ig));



/* 
\D - не числа
\W - не буквы


i - если мы хотим что-то найти вне зависимости регистра
g - глобал, это когда мы пытаемся найти сразу несколько вхождений
m - включает многострочный режим

\d - ищем цыфры
\w - ищем все слова, все буквы
\s - ищем все пробелы  */
```

https://learn.javascript.ru/regexp-introduction

  **[⬆ Наверх](#top)**
	
315. ### <a name="315"></a> Web Animations API

```js
'use strict';

const btnPhone = document.querySelector('#iphone'),
  btnMacbook = document.querySelector('#macbook'),
  images = document.querySelectorAll('img');

let phoneAnimation;

btnPhone.addEventListener('click', () => {
  if (!phoneAnimation) {
    phoneAnimation = images[0].animate(
      [
        { transform: 'translateY(0) rotate(0deg)', filter: 'opacity(100%)' },
        {
          transform: 'translateY(100px) rotate(180deg)',
          filter: 'opacity(50%)',
        },
        {
          transform: 'translateY(-100px) rotate(270deg)',
          filter: 'opacity(75%)',
        },
        { transform: 'translateY(0) rotate(360deg)', filter: 'opacity(100%)' },
      ],
      {
        duration: 3000,
        iterations: Infinity,
      }
    );
  } else if (phoneAnimation.playState === 'paused') {
    phoneAnimation.play();
  } else {
    phoneAnimation.pause();
  }
});
```

https://developer.mozilla.org/ru/docs/Web/API/Animation

  **[⬆ Наверх](#top)**
	
316. ### <a name="316"></a> Геттеры и сеттеры (свойства объектов)

Геттеры - Иногда желательно разрешить доступ к свойству, которое возвращает динамически вычисляемое значение, или вы можете захотеть отражать состояние внутренней переменной без необходимости использования явных вызовов методов. В JavaScript, это можно реализовать при помощи использования геттера.

Невозможно сделать так, чтобы геттер был привязан к свойству и одновременно чтобы это свойство действительно содержало значение, хотя можно использовать геттер и сеттер в сочетании, чтобы создать тип псевдо-свойство.


Сеттер - В JavaScript, сеттер можно использовать для выполнения функции, когда будет попытка изменения указанного свойства. Сеттеры используются чаще всего в сочетании с геттерами для создания одного из видов псевдо-свойства. Невозможно одновременно иметь сеттер для свойства, которое содержит фактическое значение.

```jsx harmony
class User {

  constructor(name) {
    // вызывает сеттер
    this.name = name;
  }

  get name() {
    return this._name;
  }

  set name(value) {
    if (value.length < 4) {
      alert("Имя слишком короткое.");
      return;
    }
    this._name = value;
  }

}

let user = new User("Иван");
alert(user.name); // Иван

user = new User(""); // Имя слишком короткое.
```

свойства Аксцессоры делятся на две группы: getter и setter. 
			 
- getter - позволяют нам получать какое-то значения свойства
- setter - позваоляют устанавливать какое-то значение свойства
			 
```js
const person = {
  name: 'Alex',
  age: 30,

  get userAge() {
    return this.age;
  },

  set userAge(num) {
    this.age = num;
  }
};

console.log(person.userAge);

console.log(person.userAge = 32);
console.log(person.userAge);
```			 

### Object.create(), get & set
```js
const person = Object.create(
  {
    calculateAge() {
      console.log('Age:', new Date().getFullYear() - this.birthYear)
    }
  }, 
  {
  name: {
    value: 'Spacy',
    enumerable: true,
    writable: true,
    configurable: true
  },
  birthYear: {
    value: 1990,
    enumerable: false,
    writable: false,
    configurable: false
  },
  age: {
    get() {
      return new Date().getFullYear() - this.birthYear
    },
    set(value) {
      // document.body.style.background = 'red'
      console.log('Set age', value)
    }
  }
})

console.log(person.age) // 32

person.age = 100
person.age = 'dfasf'

console.log(person.age) // Age: 32

person.name = 'Max'

console.log(person.calculateAge()) // undefined

console.log(person) // { name: 'Max' }

delete person.name
console.log(person.name) // undefined

delete person.birthYear
console.log(person.birthYear) // 1990


for (let key in person) {
  if (person.hasOwnProperty(key)) {
    
    console.log('Key', key, person[key])

  }
}
```    

  **[⬆ Наверх](#top)**

317. ### <a name="317"></a> Инкапсуляция

`Инкапсуляция` - это упаковка данных и функций в один компонент (например, класс) и последующий контроль доступа к этому компоненту, создавая тем самым "чёрный ящик" из объекта. По этой причине, пользователю необходимо знать только интерфейс этого класса (то есть данные и функции, предоставляемые для взаимодействия с классом извне), а не то, как он реализован внутри.

Инкапсуляция означает в ООП -  обьект хранит свое состояние в приватном порядке, и только методы обьекта имеют доступ для его изменений

```js
// Constructor

function User(name, age) {
  this.name = name;
  let userAge = age;


  this.say = function() {
    console.log(`Имя пользлватель: ${this.name}, возраст ${userAge}`);
  };

  this.getAge = function() {
    return userAge;
  };

  this.setAge = function(age) {
    if (typeof age === 'number' && age > 0 && age < 110) {
      userAge = age;
    } else {
      console.log('Недопустимое значение!');
    }
  };
}

const ivan = new User('Ivan', 27);

console.log(ivan.name);
console.log(ivan.getAge());

ivan.setAge(30);
ivan.setAge(300);
console.log(ivan.getAge());

ivan.say();
```

```js
// Class

class User {
  constructor(name, age) {
    this.name = name;
    this._age = age;
  }


  
  say() {
    console.log(`Имя пользлватель: ${this.name}, возраст ${this._age}`);
  }

  get age() {
    return this._age;
  }

  set age(age) {
    if (typeof age === 'number' && age > 0 && age < 110) {
      this._age = age;
    } else {
      console.log('Недопустимое значение!');
    }
  }
}

const ivan = new User('Ivan', 27);

console.log(ivan.age);
ivan.age = 99;
console.log(ivan.age);

ivan.say();
```

```js
// Class #, приватное свойство, еще не внесено в основу

class User {
  constructor(name, age) {
    this.name = name;
    this._age = age;
  }

  #surname = ' Pastuxov';

  
  say = () => {
    console.log(`Имя пользлватель: ${this.name}${this.#surname}, возраст ${this._age}`);
  }

  get age() {
    return this._age;
  }

  set age(age) {
    if (typeof age === 'number' && age > 0 && age < 110) {
      this._age = age;
    } else {
      console.log('Недопустимое значение!');
    }
  }
}

const ivan = new User('Ivan', 27);

console.log(ivan.surname);

ivan.say();
```

  **[⬆ Наверх](#top)**
	
318. ### <a name="318"></a> Функции-генераторы

```js
function* generator() {
  yield 'S';
  yield 'c';
  yield 'r';
  yield 'i';
  yield 'p';
  yield 't';
}

const str = generator();

console.log(str.next());
console.log(str.next());
console.log(str.next());
console.log(str.next());
console.log(str.next());
console.log(str.next());
console.log(str.next());

console.log(str.next().value); // S
```

```js
function* count(n) {
  for (let i = 0; i < n; i++) {
    yield i;
  }
}

const counter = count(7);

console.log(counter.next().value); //0
console.log(counter.next().value); //1
console.log(counter.next().value); //2

for (let k of count(7)) {
  console.log(k);
} // 0, 1, 2, 3, 4, 5, 6
```

https://learn.javascript.ru/generators

  **[⬆ Наверх](#top)**
	
319. ### <a name="319"></a> JS анимации, requestAnimationFrame

```js
const btn = document.querySelector('.btn'),
      elem = document.querySelector('.box');  
let pos = 0;

// function myAnimation() {
//     let pos = 0;

//     const id = setInterval(frame, 10);
//     function frame() {
//         if (pos == 300) {
//             clearInterval(id);
//         } else {
//             pos++;
//             elem.style.top = pos + "px";
//             elem.style.left = pos + 'px';
//         }
//     }
// }


function myAnimation() {
    pos++;
    elem.style.top = pos + "px";
    elem.style.left = pos + 'px';

    if (pos < 300) {
        requestAnimationFrame(myAnimation);
    }
}

btn.addEventListener('click', () => requestAnimationFrame(myAnimation));


let id = requestAnimationFrame(myAnimation);
cancelAnimationFrame(id);	
```	

  **[⬆ Наверх](#top)**
	
320. ### <a name="320"></a> Event loop, подробная работа асинхронных и синхронных операций

Цикл событий - это однопоточный цикл, который контролирует стек вызовов и проверяет, есть ли какая-либо работа, которую необходимо выполнить в очереди задач. Если стек вызовов пуст и в очереди задач есть callback-функции, то функция удаляется из очереди и помещается в стек вызовов для выполнения.

Событийный цикл
	
Есть бесконечный цикл, в котором движок JavaScript ожидает задачи, исполняет их и снова ожидает появления новых.

Общий алгоритм движка:

1. Пока есть задачи:
- выполнить их, начиная с самой старой
2. Бездействовать до появления новой задачи, а затем перейти к пункту 1

Очередность:
 
1 Выбрать и исполнить старейшую задачу из очереди макрозадач (например, «script»).

2 Исполнить все микрозадачи: Пока очередь микрозадач не пуста: - Выбрать из очереди и исполнить старейшую микрозадачу

3 Отрисовать изменения страницы, если они есть.

4 Если очередь макрозадач пуста – подождать, пока появится макрозадача.

5 Перейти к шагу 1.

### Чтобы добавить в очередь новую макрозадачу:

- Используйте setTimeout(f) с нулевой задержкой.
 
Этот способ можно использовать для разбиения больших вычислительных задач на части, чтобы браузер мог реагировать на пользовательские события и показывать прогресс выполнения этих частей.

Также это используется в обработчиках событий для отложенного выполнения действия после того, как событие полностью обработано (всплытие завершено).
 
### Для добавления в очередь новой микрозадачи:

- Используйте queueMicrotask(f).
- Также обработчики промисов выполняются в рамках очереди микрозадач.
- Микрозадачи приходят только из кода. Обычно они создаются промисами: выполнение обработчика .then/catch/finally становится микрозадачей. 
- Микрозадачи также используются «под капотом» await, т.к. это форма обработки промиса.
 
События пользовательского интерфейса и сетевые события в промежутках между микрозадачами не обрабатываются: микрозадачи исполняются непрерывно одна за другой.

Поэтому queueMicrotask можно использовать для асинхронного выполнения функции в том же состоянии окружения.
 

Сразу после каждой макрозадачи движок исполняет все задачи из очереди микрозадач перед тем, как выполнить следующую макрозадачу или отобразить изменения на странице, или сделать что-то ещё.

Все микрозадачи завершаются до обработки каких-либо событий или рендеринга, или перехода к другой макрозадаче.

https://learn.javascript.ru/event-loop

https://medium.com/devschacht/javascript-eventloop-explained-f2dcf84e36ee

https://habr.com/ru/company/ruvds/blog/337662/
 
### Макрозадачи и Микрозадачи:
 
При одном обходе цикла событий будет обработана ровно одна задача из очереди макрозадач (эта очередь просто называется очередью задач в спецификации WHATWG ). После завершения этой макрозадачи все доступные микрозадачи будут обработаны, а именно в рамках одного и того же цикла обхода. Пока эти микрозадачи обрабатываются, они могут ставить в очередь еще больше микрозадач, которые будут выполняться одна за другой, пока очередь микрозадач не будет исчерпана.

Каковы практические последствия этого?
Если микрозадача рекурсивно ставит в очередь другие микрозадачи, может потребоваться много времени, пока не будет обработана следующая макрозадача. Это означает, что вы можете получить заблокированный UI или какой-то завершенный ввод-вывод в вашем приложении.

Однако, по крайней мере, в отношении функции Node.js's process.nextTick (которая ставит в очередь микрозадачи ), существует встроенная защита от такой блокировки с помощью process.maxTickDepth. Это значение по умолчанию равно 1000, что сокращает дальнейшую обработку микрозадач после достижения этого предела, что позволяет обрабатывать следующую макрозадачу )

Так когда же использовать что?
В принципе, используйте микрозадачи , когда вам нужно делать что-то асинхронно синхронно (т. Е. Когда вы сказали бы, что выполните эту (микро -) задачу в самом ближайшем будущем ). В противном случае придерживайтесь макрозадач .

Примеры
- макрозадачи: setTimeout , setInterval , setImmediate , requestAnimationFrame , ввод-вывод , UI
- микрозадачи: process.nextTick , queueMicrotask , MutationObserver	
	

Порядок выполнения событийного цикла:
1. Выполнение Макрозадач
2. После каждой Макрозадачи, выполняется стек Микрозадач.
3. Выполняются все Web Api

	
### WebApi 
Интерфейс прикладного программирования (Application Programming Interfaces, APIs) - это готовые конструкции языка программирования, позволяющие разработчику строить сложную функциональность с меньшими усилиями. Они "скрывают" более сложный код от программиста, обеспечивая простоту использования.	
	
	
Итак, когда использовать что?

В основном, используйте микрозадачи, когда вам нужно делать что-то асинхронно синхронно (то есть когда вы говорите, что выполняете эту (микро) задачу в ближайшем будущем ). В противном случае, придерживайтесь макрозадач .

Примеры
макрозадачи: setTimeout , setInterval , setImmediate , requestAnimationFrame , I / O ,

микрозадачи рендеринга UI: process.nextTick , Promises , queueMicrotask , MutationObserver


Порядок выполнения событийного цыклв
```js
const promise = new Promise((resolve) => {
  resolve('hello');
  console.log('hello');
});
setTimeout(() => console.log('123'), 100);
promise.then((res) => {
  console.log('res', res);
});
console.log('My name is Maxim');
```
=> порядок выполнения =>

1. hello => console.log('hello')
2. My name is Maxim
3. res hello
4. 123


описание

1. console.log('gdsg') попадает в колл стэк и выполняется
2. setTimeout попадает в колл стэк => попадает в Web Api и делается 5 сек(коллбэк)
3. следующий console.log выполняется
4. дальше setTimeout попадает в Callback Queue и дальше попадает в Call Stack и выполняет console.log


Отметим две детали:

Микрозадачи приходят только из кода. Обычно они создаются промисами: выполнение обработчика .then/catch/finally становится микрозадачей. Микрозадачи также используются «под капотом» await, т.к. это форма обработки промиса.

Также есть специальная функция queueMicrotask(func), которая помещает func в очередь микрозадач.

Сразу после каждой макрозадачи движок исполняет все задачи из очереди микрозадач перед тем, как выполнить следующую макрозадачу или отобразить изменения на странице, или сделать что-то ещё.

```js
setTimeout(() => alert("timeout"));

Promise.resolve()
  .then(() => alert("promise"));

alert("code");
```

Какой здесь будет порядок?

1. code появляется первым, т.к. это обычный синхронный вызов.
2. promise появляется вторым, потому что .then проходит через очередь микрозадач и выполняется после текущего синхронного кода.
3. timeout появляется последним, потому что это макрозадача.

### Пример
```jsx harmony
console.log('1');
const p = new Promise((res) => {
    console.log('2');
    if (true) res('name')
})

setTimeout(() => console.log('3'))

p.then(name => {
    console.log(name);
})

console.log('5');

// 1, 2, 5, name, 3
```

### Exsmple
```js
setTimeout(() => console.log('timeout'));

Promise.resolve()
  .then(() => console.log('promise'));

queueMicrotask(() => console.log('queueMicrotask'));

Promise.resolve()
  .then(() => console.log('promise2'));

console.log('code');  

// code, promise, queueMicrotask, promise2, timeout


// makrotask
// microtasks: then/catch/finally/await
// render
// makrotask
// microtasks: then/catch/finally/await
// render
// makrotask
```

Example ->
```js
setTimeout(function timeout() {
  console.log(' 1');
}, 0);

let createPromise = new Promise(function (resolve, reject) {
  console.log('2');
  resolve();
});

createPromise.then(function () {
  console.log(3);
});

console.log(4);

// 2 4 3 1
```

![52](https://user-images.githubusercontent.com/80325645/154839062-6f12e62c-0a01-4fb8-bc3b-76fb60953b15.jpg)

  **[⬆ Наверх](#top)**
	
321. ### <a name="321"></a> Что такое Set, Map, WeakSet и WeakMap?

В ES-2015 появились новые типы коллекций в JavaScript: Set, Map, WeakSet и WeakMap.

`Map` – коллекция для хранения записей вида ключ:значение. В отличие от объектов, в которых ключами могут быть только строки, в Map ключом может быть произвольное значение, например:
```js
'use strict';

let map = new Map();

map.set('1', 'str1');   // ключ-строка
map.set(1, 'num1');     // число
map.set(true, 'bool1'); // булевое значение

// в обычном объекте это было бы одно и то же,
// map сохраняет тип ключа
alert( map.get(1)   ); // 'num1'
alert( map.get('1') ); // 'str1'

alert( map.size ); // 3
```

`Set` – коллекция для хранения множества значений, причём каждое значение может встречаться лишь один раз. Например, к нам приходят посетители, и мы хотели бы сохранять всех, кто пришёл. При этом повторные визиты не должны приводить к дубликатам, то есть каждого посетителя нужно «посчитать» ровно один раз. Set для этого отлично подходит:
```js
'use strict';

let set = new Set();

let vasya = {name: "Вася"};
let petya = {name: "Петя"};
let dasha = {name: "Даша"};

// посещения, некоторые пользователи заходят много раз
set.add(vasya);
set.add(petya);
set.add(dasha);
set.add(vasya);
set.add(petya);

// set сохраняет только уникальные значения
alert( set.size ); // 3

set.forEach( user => alert(user.name ) ); // Вася, Петя, Даша
```

`WeakMap` – это Map-подобная коллекция, позволяющая использовать в качестве ключей только объекты, и автоматически удаляющая их вместе с соответствующими значениями, как только они становятся недостижимыми иными путями.

`WeakSet` – это Set-подобная коллекция, которая хранит только объекты и удаляет их, как только они становятся недостижимыми иными путями.

### WeakMap - Первое его отличие от Map в том, что ключи в WeakMap должны быть объектами, а не примитивными значениями:

`WeakMap` – это Map-подобная коллекция, позволяющая использовать в качестве ключей только объекты, и автоматически удаляющая их вместе с соответствующими значениями, как только они становятся недостижимыми иными путями.

```js
let weakMap = new WeakMap();

let obj = {};

weakMap.set(obj, "ok"); // работает (объект в качестве ключа)

// нельзя использовать строку в качестве ключа
weakMap.set("test", "Whoops"); // Ошибка, потому что "test" не объект
```

Теперь, если мы используем объект в качестве ключа и если больше нет ссылок на этот объект, то он будет удалён из памяти (и из объекта WeakMap) автоматически.

```js
let john = { name: "John" };

let weakMap = new WeakMap();
weakMap.set(john, "...");

john = null; // перезаписываем ссылку на объект

// объект john удалён из памяти!
```

WeakMap не поддерживает перебор и методы keys(), values(), entries(), так что нет способа взять все ключи или значения из неё.

В WeakMap присутствуют только следующие методы:
- weakMap.get(key)
- weakMap.set(key, value)
- weakMap.delete(key)
- weakMap.has(key)

К чему такие ограничения? Из-за особенностей технической реализации. Если объект станет недостижим (как объект john в примере выше), то он будет автоматически удалён сборщиком мусора. Но нет информации, в какой момент произойдёт эта очистка.

Решение о том, когда делать сборку мусора, принимает движок JavaScript. Он может посчитать необходимым как удалить объект прямо сейчас, так и отложить эту операцию, чтобы удалить большее количество объектов за раз позже. Так что технически количество элементов в коллекции WeakMap неизвестно. Движок может произвести очистку сразу или потом, или сделать это частично. По этой причине методы для доступа ко всем сразу ключам/значениям недоступны.

Example
```js
let cache = new WeakMap();

function cahcheUser(user) {
  if (!cache.has(user)) {
    cache.set(user, Date.now());
  }

  return cache.get(user);
}

let lena = { name: 'Elena' };
let alex = { name: 'Alex' };

cahcheUser(lena);
cahcheUser(alex);

lena = null;

console.log(cache.has(lena));
console.log(cache.has(alex));
```

### WeakSet

`WeakSet` – это Set-подобная коллекция, которая хранит только объекты и удаляет их, как только они становятся недостижимыми иными путями.

Коллекция WeakSet ведёт себя похоже:

- Она аналогична Set, но мы можем добавлять в WeakSet только объекты (не примитивные значения).
- Объект присутствует в множестве только до тех пор, пока доступен где-то ещё.
- Как и Set, она поддерживает add, has и delete, но не size, keys() и не является перебираемой.

Будучи «слабой» версией оригинальной структуры данных, она тоже служит в качестве дополнительного хранилища. Но не для произвольных данных, а скорее для значений типа «да/нет». Присутствие во множестве WeakSet может что-то сказать нам об объекте.

Например, мы можем добавлять пользователей в WeakSet для учёта тех, кто посещал наш сайт:

```js
let visitedSet = new WeakSet();

let john = { name: "John" };
let pete = { name: "Pete" };
let mary = { name: "Mary" };

visitedSet.add(john); // John заходил к нам
visitedSet.add(pete); // потом Pete
visitedSet.add(john); // John снова

// visitedSet сейчас содержит двух пользователей

// проверим, заходил ли John?
alert(visitedSet.has(john)); // true

// проверим, заходила ли Mary?
alert(visitedSet.has(mary)); // false

john = null;

// структура данных visitedSet будет очищена автоматически
Наиболее значительным ограничением WeakMap и WeakSet является то, что их нельзя перебрать или взять всё содержимое. Это может доставлять неудобства, но не мешает WeakMap/WeakSet выполнять их главную задачу – быть дополнительным хранилищем данных для объектов, управляемых из каких-то других мест в коде.
```

// Example WeakSet

// add, has, delete
```js
let messages = [
{text: 'Hello', from: 'John'},
{text: 'World', from: 'Alex'},
{text: '....', from: 'M'},
];

let readMessages = new WeakSet();

readMessages.add(messages[0]);
// readMessages.add(messages[1]);

readMessages.add(messages[0]);
messages.shift();

console.log(readMessages.has(messages[0]));
```

  **[⬆ Наверх](#top)**

700. ### <a name="700"></a> Map, Set

### Map

```js
const shops = [
  {rice: 500},
  {oil: 200},
  {bread: 50}
]

const budget = [5000, 15000, 25000];

const map = new Map([
  [{paper: 400}, 8000]
]);

// map.set(shops[0], 5000);
// map.set(shops[1], 15000);
// map.set(shops[2], 25000);

shops.forEach((shop, i) => {
  map.set(shop, budget[i]);
})

console.log(map);
/* Map(3) {
  { rice: 500 } => 5000,
  { oil: 200 } => 15000,
  { bread: 50 } => 25000
} */

console.log(map.get(shops[0]))
console.log(map.has(shops[0]))

map.delete();
map.clear();
map.size();


// map.keys() возвращает итерируемый обьект по ключам

console.log(map.keys())

for (let shop of map.keys()) {
  console.log(shop)
}

const goods = [];

for (let shop of map.keys()) {
  goods.push(Object.keys(shop)[0])
}

console.log(goods)

// map.values() - возвращаем свойства

for (let price of map.values()) {
  console.log(price)
}

// map.entries()

for (let price of map.entries()) {
  console.log(price)
}

for (let [shop, price] of map.entries()) {
  console.log(shop, price)
}


// forEach

map.forEach((value, key, map) => {
  console.log(key, value)
});



const userFour = {
  name: 'Alex',
  surname: 'Smith',
  birhday: '20/04/1990',
  showMyPublicData: function() {
    console.log(`${this.name} ${this.surname}`);
  }
}

const userMap = new Map(Object.entries(userFour))

console.log(userMap);

const newUserFour = Object.fromEntries(userMap)

console.log(userMap);
```

### Set

```js
const array = [1, 1, 2, 2, 4, 5, 6, 5];

const set = new Set(array);

console.log(set) // { 1, 2, 4, 5, 6 }


const array3 = ['Alex', 'Ann', 'Alex', 'Oleg'];

const set2 = new Set(array3);

set2.add('Ivan');
set2.add('Oleg');
set2.add('Vasya');

set2.add('Ivan')
    .add('Kostya')

console.log(set2);


set.delete(value)
set.has(value)
set.clear()
set.size()


for (let value of set2) console.log(value)


set2.forEach((value, valueAgain, set) => {
  console.log(value, valueAgain)
})


console.log(set.values())

console.log(set.keys())

console.log(set.entries())


function unique(array) {
  return Array.from(new Set(array))
}

console.log(unique(array))
```

  **[⬆ Наверх](#top)** 


322. ### <a name="322"></a> Прототипы, цепочка прототипов

`Прототипы` - это механизм, с помощью которого объекты JavaScript наследуют свойства друг от друга.

JavaScript часто описывают как язык прототипного наследования — каждый объект, имеет объект-прототип, который выступает как шаблон, от которого объект наследует методы и свойства. 

Объект-прототип так же может иметь свой прототип и наследовать его свойства и методы и так далее. Это часто называется цепочкой прототипов и объясняет почему одним объектам доступны свойства и методы которые определены в других объектах.

- `__proto__` - это геттер и сеттер для обьекта, установить или получить прототип готового обьекта.
- `[[Prototype]]` - это скрытое свойство, напряму в js оно не доступно, оно доступно через геттер, сеттер, __proto__, setObjectPrototype, getObjectPrototype методы
- `obj.prototype` - это только у функций конструкторов бывает, будет использоваться как: Прототип обьекта который будет создан с помощью нашей функции конструктора

### "__proto__"" and ""prototype"" properties

`__proto__` фактический объект, который используется в цепочке поиска для разрешения методов и т. д. 
`prototype` - это объект, который используется для построения __proto__ при создании объекта с помощью new:
```js
( new Foo ).__proto__ === Foo.prototype;
( new Foo ).prototype === undefined;
```

В JavaScript объекты имеют специальное скрытое свойство [[Prototype]] (так оно названо в спецификации), которое либо равно null, либо ссылается на другой объект. Этот объект называется «прототип»:

Свойство [[Prototype]] является внутренним и скрытым, но есть много способов задать его.

Одним из них является использование __proto__, например так:
```js
let animal = {
  eats: true
};
let rabbit = {
  jumps: true
};

rabbit.__proto__ = animal;
```

Если мы ищем свойство в rabbit, а оно отсутствует, JavaScript автоматически берёт его из animal.
```js
let animal = {
  eats: true
};
let rabbit = {
  jumps: true
};

rabbit.__proto__ = animal; // (*)

// теперь мы можем найти оба свойства в rabbit:
alert( rabbit.eats ); // true (**)
alert( rabbit.jumps ); // true
```
Здесь строка (*) устанавливает animal как прототип для rabbit.

Затем, когда alert пытается прочитать свойство rabbit.eats (**), его нет в rabbit, поэтому JavaScript следует по ссылке [[Prototype]] и находит его в animal

Здесь мы можем сказать, что "animal является прототипом rabbit" или "rabbit прототипно наследует от animal".

Так что если у animal много полезных свойств и методов, то они автоматически становятся доступными у rabbit. Такие свойства называются «унаследованными».

Если у нас есть метод в animal, он может быть вызван на rabbit:
```js
let animal = {
  eats: true,
  walk() {
    alert("Animal walk");
  }
};

let rabbit = {
  jumps: true,
  __proto__: animal
};

// walk взят из прототипа
rabbit.walk(); // Animal walk
```
### Цепочка прототипов может быть длиннее:
```js
let animal = {
  eats: true,
  walk() {
    alert("Animal walk");
  }
};

let rabbit = {
  jumps: true,
  __proto__: animal
};

let longEar = {
  earLength: 10,
  __proto__: rabbit
};

// walk взят из цепочки прототипов
longEar.walk(); // Animal walk
alert(longEar.jumps); // true (из rabbit)
```


### Cоздать объект с прототипом

```js
const person = new Object({
    name: 'Spacy',
    age: 30,
    greet: function() {
      console.log('Greet!')
  }
})

console.log(person)
// console.log(person.name)
// console.log(person.greet())


// console.log(person.sayHello())

// console.log(person.toString())

Object.prototype.sayHallo = function() {
  console.log('Hello!');
}

console.log(person.sayHallo())


const lena = Object.create(person)

console.log(lena)
console.log(lena.greet())
console.log(lena.sayHallo())

console.log(lena.name)

lena.name = 'Elena';
console.log(lena.name)


const str = new String('I am string');

console.log(str)
console.log(str.sayHallo())
```
	
prototype - это определенный обьект который присутствует у обьектов и он вызывается по цепочке сверху-вниз, если мы находим какие-то поля на верхнем уровне или функции - мы обращаемся к ним, если не находим - мы идем вниз по прототипу и ищем либо поля либо функции.

```jsx harmony
const person = {
  name: 'Spacy',
  age: 30,
  greet: function() {
    console.log('Greet')
  }
}

console.log(person)
console.log(person.name)
console.log(person.greet())

console.log(person.sayHello())
console.log(person.toString())

console.log(person)


const person = new Object({
  name: 'Spacy',
  age: 30,
  greet: function() {
    console.log('Greet')
  }
})

// console.log(person)

Object.prototype.sayHello = function() {
  console.log('Hello')
}

console.log(person.sayHello())



const lena = Object.create(person);

console.log(lena)

console.log(lena.greet())
console.log(lena.toString())

console.log(lena.name)

lena.name = 'elena';

console.log(lena)
console.log(lena.name)

console.log(lena.sayHello())


const str = new String('I am string');

console.log(str)                         
```
 
### Пример прототипов
```js
function Cat(name, color) {
  this.name = name
  this.color = color
}

Cat.prototype.voice = function() {
  console.log(`Cat ${this.name} says myay`)
}

const cat = new Cat('Kot', 'white')

console.log(Cat.prototype) // { voice: [Function (anonymous)] }
console.log(cat) // Cat { name: 'Kot', color: 'white' }
console.log(cat.__proto__ === Cat.prototype) // true
console.log(cat.constructor) // [Function: Cat]
cat.voice() // Cat Kot says myay


// ============
function Person() {}
Person.prototype.legs = 2
Person.prototype.skin = 'white'

const person = new Person()
person.name = 'Vladilen'

console.log('skin' in person) // true
console.log(person.legs) // 2
console.log(person.name) // Vladilen

console.log(person.hasOwnProperty('name')) // true
console.log(person.hasOwnProperty('skin')) // false


// Object.create()
var proto = {year: 2019}
const myYear = Object.create(proto)

console.log(myYear.year) // 2019

proto.year = 2200

console.log(myYear.year) // 2200

console.log(myYear.hasOwnProperty('year')) // false
console.log(myYear.__proto__ === proto) // true
```

### Задача: Прототипы и this
```js
const array = [1, 2, 3, 4, 5]

Array.prototype.multBy = function(n) {
  return this.map(function(i) {
    return i * n
  })
}

console.log(array.multBy(2)) // [2, 4, 6, 8, 10]


const arr2 = [1, 2, 5].multBy(3)
console.log(arr2) // [3, 6, 15]	
```

  **[⬆ Наверх](#top)**
	
323. ### <a name="323"></a> Прототипы, Object.create()

Все объекты в JavaScript имеют свойство proto, которое является ссылкой на другой объект. Когда происходит обращение к свойству объекта, и если свойство не найдено в этом объекте, то механизм JavaScript просматривает прототип объекта, затем прототип прототипа и т.д. До тех пор, пока не найдет определенное свойство на одном из прототипов или до тех пор, пока он не достигнет конца цепочки прототипов. Такое поведение имитирует классическое наследование, но на самом деле это скорее делегирование, чем наследование.

В плане наследования JavaScript работает лишь с одной сущностью: **объектами**. Каждый объект имеет внутреннюю ссылку на другой объект, называемый его **прототипом**. У объекта-прототипа также есть свой собственный прототип и так далее до тех пор, пока цепочка не завершится объектом, у которого свойство prototype равно **null**. По определению, null не имеет прототипа и является завершающим звеном в цепочке прототипов.

- `__proto__` - это геттер и сеттер для обьекта, установить или получить прототип готового обьекта.
- `[[Prototype]]` - это скрытое свойство, напряму в js оно не доступно, оно доступно через геттер, сеттер, __proto__, setObjectPrototype, getObjectPrototype методы
- `obj.prototype` - это только у функций конструкторов бывает, будет использоваться как: Прототип обьекта который будет создан с помощью нашей функции конструктора

В JavaScript "конструктор" — это "просто" функция, вызываемая с оператором new.

В ECMAScript 5 представлен новый метод создания объектов: Object.create. Прототип создаваемого объекта указывается в первом аргументе этого метода.

Если необходимо проверить, определено ли свойство у *самого объекта*, а не где-то в его цепочке прототипов, вы можете использовать метод `[hasOwnProperty]`, который все объекты наследуют от `Object.prototype`.

- `[hasOwnProperty]` — единственная существующая в JavaScript возможность работать со свойствами, не затрагивая цепочку прототипов.

Важно:
- Типы определяются в `.prototype`
- Для наследования используется `Object.create()`

- Свойство "`prototype`" функции-конструктора. 

- Свойство `__proto__` — исторически обусловленный геттер/сеттер для `[[Prototype]]`
Обратите внимание, что `__proto__` — не то же самое, что `[[Prototype]]`. Это геттер/сеттер для него.
Он существует по историческим причинам, в современном языке его заменяют функции `Object.getPrototypeOf`/`Object.setPrototypeOf`, которые также получают/устанавливают прототип.

- `Object.create(proto, [descriptors])` – создаёт пустой объект со свойством `[[Prototype]]`, указанным как `proto`, и необязательными дескрипторами свойств `descriptors`.
- `Object.getPrototypeOf(obj)` – возвращает свойство `[[Prototype]]` объекта `obj`.
- `Object.setPrototypeOf(obj, proto)` – устанавливает свойство `[[Prototype]]` объекта `obj` как `proto`.

https://learn.javascript.ru/prototype-inheritance

### Object.create()
```js
const person = Object.create(
  {
    calculateAge() {
      console.log('Age:', new Date().getFullYear() - this.birthYear)
    }
  }, 
  {
  name: {
    value: 'Spacy',
    enumerable: true,
    writable: true,
    configurable: true
  },
  birthYear: {
    value: 1990,
    enumerable: false,
    writable: false,
    configurable: false
  },
  age: {
    get() {
      return new Date().getFullYear() - this.birthYear
    },
    set(value) {
      // document.body.style.background = 'red'
      console.log('Set age', value)
    }
  }
})

console.log(person.age) // 32

person.age = 100
person.age = 'dfasf'

console.log(person.age) // Age: 32

person.name = 'Max'

console.log(person.calculateAge()) // undefined

console.log(person) // { name: 'Max' }

delete person.name
console.log(person.name) // undefined

delete person.birthYear
console.log(person.birthYear) // 1990


for (let key in person) {
  if (person.hasOwnProperty(key)) {
    
    console.log('Key', key, person[key])

  }
}
```

  **[⬆ Наверх](#top)**
	
324. ### <a name="324"></a> Длительный опрос как работает

Длинные опросы – это самый простой способ поддерживать постоянное соединение с сервером, не используя при этом никаких специфических протоколов (типа WebSocket или Server Sent Events).

«Длинные опросы» – гораздо лучший способ взаимодействия с сервером.

Они также очень просты в реализации, и сообщения доставляются без задержек.

Как это происходит:

1. Запрос отправляется на сервер.
2. Сервер не закрывает соединение, пока у него не возникнет сообщение для отсылки.
3. Когда появляется сообщение – сервер отвечает на запрос, посылая его.
4. Браузер немедленно делает новый запрос.

Если соединение будет потеряно, скажем, из-за сетевой ошибки, браузер немедленно посылает новый запрос.

Примерный код клиентской функции subscribe, которая реализует длинные опросы:
```js
async function subscribe() {
  let response = await fetch("/subscribe");

  if (response.status == 502) {
    // Статус 502 - это таймаут соединения;
    // возможен, когда соединение ожидало слишком долго
    // и сервер (или промежуточный прокси) закрыл его
    // давайте восстановим связь
    await subscribe();
  } else if (response.status != 200) {
    // Какая-то ошибка, покажем её
    showMessage(response.statusText);
    // Подключимся снова через секунду.
    await new Promise(resolve => setTimeout(resolve, 1000));
    await subscribe();
  } else {
    // Получим и покажем сообщение
    let message = await response.text();
    showMessage(message);
    // И снова вызовем subscribe() для получения следующего сообщения
    await subscribe();
  }
}

subscribe();
```
Функция subscribe() делает запрос, затем ожидает ответ, обрабатывает его и снова вызывает сама себя.

  **[⬆ Наверх](#top)**
	
325. ### <a name="325"></a> Web Socket

Протокол WebSocket обеспечивает возможность обмена данными между браузером и сервером через постоянное соединение. Данные передаются по нему в обоих направлениях в виде «пакетов», без разрыва соединения и дополнительных HTTP-запросов.

WebSocket особенно хорош для сервисов, которые нуждаются в постоянном обмене данными, например онлайн игры, торговые площадки, работающие в реальном времени, и т.д.

Чтобы открыть веб-сокет-соединение, нам нужно создать объект new WebSocket, указав в url-адресе специальный протокол ws:
```js
let socket = new WebSocket("ws://javascript.info");
```
Также существует протокол wss://, использующий шифрование. Это как HTTPS для веб-сокетов.

Как только объект WebSocket создан, мы должны слушать его события. Их всего 4:
- open – соединение установлено,
- message – получены данные,
- error – ошибка,
- close – соединение закрыто.

```js
let socket = new WebSocket("wss://javascript.info/article/websocket/demo/hello");

socket.onopen = function(e) {
  alert("[open] Соединение установлено");
  alert("Отправляем данные на сервер");
  socket.send("Меня зовут Джон");
};

socket.onmessage = function(event) {
  alert(`[message] Данные получены с сервера: ${event.data}`);
};

socket.onclose = function(event) {
  if (event.wasClean) {
    alert(`[close] Соединение закрыто чисто, код=${event.code} причина=${event.reason}`);
  } else {
    // например, сервер убил процесс или сеть недоступна
    // обычно в этом случае event.code 1006
    alert('[close] Соединение прервано');
  }
};

socket.onerror = function(error) {
  alert(`[error] ${error.message}`);
};
```
### Итого

WebSocket – это современный способ иметь постоянное соединение между браузером и сервером.

- Нет ограничений, связанных с кросс-доменными запросами.
- Имеют хорошую поддержку браузерами.
- Могут отправлять/получать как строки, так и бинарные данные.

API прост.

Методы:
- socket.send(data),
- socket.close([code], [reason]).

События:
- open,
- message,
- error,
- close.

WebSocket сам по себе не содержит такие функции, как переподключение при обрыве соединения, аутентификацию пользователей и другие механизмы высокого уровня. Для этого есть клиентские и серверные библиотеки, а также можно реализовать это вручную.

Иногда, чтобы добавить WebSocket к уже существующему проекту, WebSocket-сервер запускают параллельно с основным сервером. Они совместно использует одну базу данных. Запросы к WebSocket отправляются на wss://ws.site.com – поддомен, который ведёт к WebSocket-серверу, в то время как https://site.com ведёт на основной HTTP-сервер.

  **[⬆ Наверх](#top)**
	
326. ### <a name="326"></a> Способы отправки запроса на сервер

### iFrame
	
`IFrame` — это кадр внутри кадра. Это компонент HTML-элемента, который позволяет встраивать документы, видео и интерактивные медиафайлы на страницу. Сделав это, вы сможете отобразить дополнительную страницу на главной веб-странице.

Элемент iFrame позволяет включать часть содержимого из других источников. Он может интегрировать контент в любом месте на вашей странице, без необходимости включать их в структуру веб-макета, как традиционный элемент.

Однако следует быть осторожными. Чрезмерное использование iFrame может замедлить работу страницы и создать угрозу безопасности, особенно если вы используете контент с подозрительного веб-сайта.	

### src
	
Импортирует файл со скриптами из внешнего файла. Как только внешние инструкции полностью загружаются, браузер обрабатывает их, словно они были внедрены в текущий документ. Файлы со скриптами JavaScript обычно имеют расширение js и могут размещаться в любом доступном месте.

Преимуществ использования внешних файлов несколько. Внешний файл после первого обращения сохраняется в кэше браузера и при последующих вызовах загружается быстрее. Кроме того, вызываемые функции удобно править в одном месте и код проще контролировать. Это особенно актуально, когда множество веб-страниц используют одни и те же скрипты.
	
### jsonp 
	
JSONP — это метод передачи данных JSON, не заботясь о кросс-доменных ограничениях.

В JSONP не используется объект XMLHttpRequest.

Вместо этого JSONP использует тег <script>.

JSONP означает "JSON with padding" (JSON с набивкой) и является дополнением к формату JSON.

Запрос данных с сервера, находящегося в другом домене, может вызвать определенные проблемы из-за политики ограничения домена.

Запрос же внешних скриптов с сервера, находящегося в другом домене, не вызывает таких проблем.

JSONP пользуется этим преимущество, запрашивая файлы при помощи тега <script> вместо объекта XMLHttpRequest.
```js
<script src="//msiter.ru/demo_jsonp.php">
```	

### form
	
Тег <form> устанавливает форму на веб-странице. Форма предназначена для обмена данными между пользователем и сервером. Область применения форм не ограничена отправкой данных на сервер, с помощью клиентских скриптов можно получить доступ к любому элементу формы, изменять его и применять по своему усмотрению.

Документ может содержать любое количество форм, но одновременно на сервер может быть отправлена только одна форма. По этой причине данные форм должны быть независимы друг от друга.

Для отправки формы на сервер используется кнопка Submit, того же можно добиться, если нажать клавишу Enter в пределах формы. Если кнопка Submit отсутствует в форме, клавиша Enter имитирует ее использование.

Когда форма отправляется на сервер, управление данными передается программе, заданной атрибутом action тега <form>. Предварительно браузер подготавливает информацию в виде пары «имя=значение», где имя определяется атрибутом name тега <input>, а значение введено пользователем или установлено в поле формы по умолчанию. Если для отправки данных используется метод GET, то адресная строка может принимать следующий вид.
```js
http://www.htmlbook.ru/cgi-bin/handler.cgi?nick=%C2%E0%ED%FF+%D8%E0%EF%EE%F7%EA%E8%ED&page=5
```
Параметры перечисляются после вопросительного знака, указанного после адреса CGI-программы и разделяются между собой символом амперсанда (&). Нелатинские символы преобразуются в шестнадцатеричное представление (в форме %HH, где HH — шестнадцатеричный код для значения ASCII-символа), пробел заменяется на плюс (+).

Допускается внутрь контейнера <form> помещать другие теги, при этом сама форма никак не отображается на веб-странице, видны только ее элементы и результаты вложенных тегов.
```js
<form action="URL">
  ...
</form>	
```
	
### websocket 
	
Протокол WebSocket обеспечивает возможность обмена данными между браузером и сервером через постоянное соединение. Данные передаются по нему в обоих направлениях в виде «пакетов», без разрыва соединения и дополнительных HTTP-запросов.

WebSocket особенно хорош для сервисов, которые нуждаются в постоянном обмене данными, например онлайн игры, торговые площадки, работающие в реальном времени, и т.д.	
	
Чтобы открыть веб-сокет-соединение, нам нужно создать объект new WebSocket, указав в url-адресе специальный протокол ws:
```js
let socket = new WebSocket("ws://javascript.info");
```	
Также существует протокол wss://, использующий шифрование. Это как HTTPS для веб-сокетов.	

WebSocket – это современный способ иметь постоянное соединение между браузером и сервером.
- Нет ограничений, связанных с кросс-доменными запросами.
- Имеют хорошую поддержку браузерами.
- Могут отправлять/получать как строки, так и бинарные данные.

API прост.
	
Методы:
- socket.send(data),
- socket.close([code], [reason]).

Как только объект WebSocket создан, мы должны слушать его события. Их всего 4:
- open – соединение установлено,
- message – получены данные,
- error – ошибка,
- close – соединение закрыто.	
	
### Пример
```js
let socket = new WebSocket("wss://javascript.info/article/websocket/demo/hello");

socket.onopen = function(e) {
  alert("[open] Соединение установлено");
  alert("Отправляем данные на сервер");
  socket.send("Меня зовут Джон");
};

socket.onmessage = function(event) {
  alert(`[message] Данные получены с сервера: ${event.data}`);
};

socket.onclose = function(event) {
  if (event.wasClean) {
    alert(`[close] Соединение закрыто чисто, код=${event.code} причина=${event.reason}`);
  } else {
    // например, сервер убил процесс или сеть недоступна
    // обычно в этом случае event.code 1006
    alert('[close] Соединение прервано');
  }
};

socket.onerror = function(error) {
  alert(`[error] ${error.message}`);
};	
```	

### Fetch
	
### Пример 1	
```jsx harmony
fetch('http://example.com/movies.json')
  .then((response) => {
    return response.json();
  })
  .then((data) => {
    console.log(data);
  });
```	
Здесь мы забираем JSON файл по сети и выводим его содержимое в консоль. Самый простой способ использования fetch() заключается в вызове этой функии с одним аргументом — строкой, содержащей путь к ресурсу, который вы хотите получить — которая возвращает promise, содержащее ответ (объект Response).	

	
### Пример
```js
fetch('https://jsonplaceholder.typicode.com/posts', {
    method: 'POST',
    body: JSON.stringify({name: 'Alex'}),
    headers: {
      'Content-type': 'application/json'
    }
  })
    .then(response => response.json())
    .then(json => console.log(json));	
```		
		
### Теория
	
Метод fetch() — современный и очень мощный, поэтому начнём с него. Он не поддерживается старыми (можно использовать полифил), но поддерживается всеми современными браузерами.

Базовый синтаксис:
```js
let promise = fetch(url, [options])
```	
- url – URL для отправки запроса.
- options – дополнительные параметры: метод, заголовки и так далее.
	
Без options это простой GET-запрос, скачивающий содержимое по адресу url.

Браузер сразу же начинает запрос и возвращает промис, который внешний код использует для получения результата.

Процесс получения ответа обычно происходит в два этапа.

### Во-первых, promise выполняется с объектом встроенного класса Response в качестве результата, как только сервер пришлёт заголовки ответа.

На этом этапе мы можем проверить статус HTTP-запроса и определить, выполнился ли он успешно, а также посмотреть заголовки, но пока без тела ответа.

Промис завершается с ошибкой, если fetch не смог выполнить HTTP-запрос, например при ошибке сети или если нет такого сайта. HTTP-статусы 404 и 500 не являются ошибкой.

Мы можем увидеть HTTP-статус в свойствах ответа:

- status – код статуса HTTP-запроса, например 200.
- ok – логическое значение: будет true, если код HTTP-статуса в диапазоне 200-299.
	
```js
let response = await fetch(url);

if (response.ok) { // если HTTP-статус в диапазоне 200-299
  // получаем тело ответа (см. про этот метод ниже)
  let json = await response.json();
} else {
  alert("Ошибка HTTP: " + response.status);
}
```
	
### Во-вторых, для получения тела ответа нам нужно использовать дополнительный вызов метода.

Response предоставляет несколько методов, основанных на промисах, для доступа к телу ответа в различных форматах:

- response.text() – читает ответ и возвращает как обычный текст,
- response.json() – декодирует ответ в формате JSON,
- response.formData() – возвращает ответ как объект FormData (разберём его в следующей главе),
- response.blob() – возвращает объект как Blob (бинарные данные с типом),
- response.arrayBuffer() – возвращает ответ как ArrayBuffer (низкоуровневое представление бинарных данных),
помимо этого, response.body – это объект ReadableStream, с помощью которого можно считывать тело запроса по частям. Мы рассмотрим и такой пример несколько позже.
	
Например, получим JSON-объект с последними коммитами из репозитория на GitHub:
```js
let url = 'https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits';
let response = await fetch(url);

let commits = await response.json(); // читаем ответ в формате JSON

alert(commits[0].author.login);
```	
То же самое без await, с использованием промисов:
```js
fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits')
  .then(response => response.json())
  .then(commits => alert(commits[0].author.login));
```	
Для получения ответа в виде текста используем await response.text() вместо .json():
```js
let response = await fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits');

let text = await response.text(); // прочитать тело ответа как текст

alert(text.slice(0, 80) + '...');	
```	
	
Типичный запрос с помощью fetch состоит из двух операторов await:
```js
let response = await fetch(url, options); // завершается с заголовками ответа
let result = await response.json(); // читать тело ответа в формате JSON
```	
Или, без await:
```js
fetch(url, options)
  .then(response => response.json())
  .then(result => /* обрабатываем результат */)
```
	
Параметры ответа:
- response.status – HTTP-код ответа,
- response.ok – true, если статус ответа в диапазоне 200-299.
- response.headers – похожий на Map объект с HTTP-заголовками.
	
Методы для получения тела ответа:
- response.text() – возвращает ответ как обычный текст,
- response.json() – преобразовывает ответ в JSON-объект,
- response.formData() – возвращает ответ как объект FormData (кодировка form/multipart, см. следующую главу),
- response.blob() – возвращает объект как Blob (бинарные данные с типом),
- response.arrayBuffer() – возвращает ответ как ArrayBuffer (низкоуровневые бинарные данные),
	
Опции fetch, которые мы изучили на данный момент:
- method – HTTP-метод,
- headers – объект с запрашиваемыми заголовками (не все заголовки разрешены),
- body – данные для отправки (тело запроса) в виде текста, FormData, BufferSource, Blob или UrlSearchParams.

  **[⬆ Наверх](#top)**
	
327. ### <a name="327"></a> Минификация

Перед выкладыванием JavaScript на «боевую» машину – пропускаем его через минификатор (также говорят «сжиматель»), который удаляет пробелы и по-всякому оптимизирует код, уменьшая его размер.
	
*Что делает минификатор?*
	
Все современные минификаторы работают следующим образом:

1. Разбирают JavaScript-код в синтаксическое дерево.
Также поступает любой интерпретатор JavaScript перед тем, как его выполнять. Но затем, вместо исполнения кода…
2. Бегают по этому дереву, анализируют и оптимизируют его.
3. Записывают из синтаксического дерева получившийся код.

  **[⬆ Наверх](#top)**
	
328. ### <a name="328"></a> Что такое web workers и зачем они нам нужны?

Web Worker-ы предоставляют простое средство для запуска скриптов в фоновом потоке. Поток Worker'а может выполнять задачи без вмешательства в пользовательский интерфейс. К тому же, они могут осуществлять ввод/вывод, используя XMLHttpRequest (хотя атрибуты responseXML и channel всегда будут равны null). Существующий Worker может отсылать сообщения JavaScript коду-создателю через обработчик событий, указанный этим кодом (и наоборот).

	
### Web Workers API
	
Worker - это объект, создаваемый конструктором (например, Worker()) и запускающий именной JavaScript файл — этот файл содержит код, который будет выполнен в потоке Worker'а; объекты же Workers запускаются в другом глобальном контексте, отличающемся от текущего, - window. Поэтому использование переменной window для получения текущего глобального контекста (вместо self) внутри Worker вернёт ошибку.	

*Другие типы worker-ов*
	
В дополнение к выделенным и совместно используемым web worker-ам доступны другие типы worker-ов:

- ServiceWorkers, по сути, действуют как прокси-серверы, которые размещаются между веб-приложениями, браузером и сетью (при наличии). Они предназначены (помимо прочего) для создания эффективного автономного взаимодействия, перехвата сетевых запросов и принятия соответствующих действий в зависимости от того, доступна ли сеть, и обновлены ли ресурсы на сервере. Они также разрешают доступ push-уведомлениям и API фоновой синхронизации.
- Chrome Workers это worker типа Firefox-only, который вы можете использовать, если вы разрабатываете дополнения и хотите использовать worker-ы в расширениях и иметь доступ к js-ctypes в вашем worker-е. Смотрите ChromeWorker для более подробной информации.
- Audio Workers предоставляют возможность прямой обработки звука по сценарию в контексте web worker-а.

  **[⬆ Наверх](#top)**
	
329. ### <a name="329"></a> Typescript или flow

TypeScript — это язык программирования, разработанный в Microsoft. TypeScript является надмножеством JavaScript, имеет статическую систему типов и собственный компилятор. Статическая типизация позволяет отлавливать ошибки и баги во время компиляции, ещё до запуска приложения. Подробнее узнать о совместном использовании TypeScript и React можно здесь.

Чтобы использовать TypeScript, нужно:

- добавить TypeScript в проект как зависимость.
- настроить компилятор.
- использовать правильные расширения файлов.
- установить файлы объявлений для используемых библиотек;


Flow — это библиотека для статической типизации JavaScript, разработанная в Facebook и часто применяемая в связке с React. Flow расширяет возможности JavaScript, добавляя аннотации типов для переменных, функций и React-компонентов. Ознакомиться с основами Flow можно на странице официальной документации.

Чтобы начать пользоваться возможностями Flow необходимо:

- добавить Flow в ваш проект как зависимость.
- убедиться, что аннотации Flow удаляются из кода при его компиляции.
- добавить несколько аннотаций типов и запустить Flow для их проверки;

https://ru.reactjs.org/docs/static-type-checking.html

  **[⬆ Наверх](#top)**
	
330. ### <a name="330"></a> Рекурсия

`Рекурсия` – это термин в программировании, означающий вызов функцией самой себя. Рекурсивные функции могут быть использованы для элегантного решения определённых задач.

Когда функция вызывает саму себя, это называется шагом рекурсии. База рекурсии – это такие аргументы функции, которые делают задачу настолько простой, что решение не требует дальнейших вложенных вызовов.

`База рекурсии` – это случай который приводит сразу к завершению функции. Это такие аргументы функции, которые делают задачу настолько простой, что решение не требует дальнейших вложенных вызовов.
```js
if ( n === 1) {
    return x;
}
```

Когда функция вызывает саму себя, это называется `шагом рекурсии`
```js
pow(x, n - 1)
```

`Глубина рекурсии` равна максимальному числу контекстов, одновременно хранимых в стеке.
```js
n
```

```js
function pow(x, n) {
  if ( n === 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}

pow(2, 1) //2
pow(2, 2) //4
pow(2, 3) //8
```

```js
function factorial(n) {
  if (typeof(n) !== 'number' || !Number.isInteger(n)) {
    return "Ошибка, проверьте данные";
  }

  if (n >= 1) {
    return n * factorial(n - 1);
  } else {
    return 1;
  }

  return n ? n * factorial(n - 1) : 1;
}

console.log(factorial(5));
```

```js
let students = {
  js: [{
    name: 'John',
    progress: 100
  }, {
    name: 'Ivan',
    progress: 60
  }],

  html: {
    basic: [{
      name: 'Peter',
      progress: 20
    }, {
      name: 'Ann',
      progress: 18
    }],

    pro: [{
      name: 'Sam',
      progress: 10
    }],

    // recursion +
    semi: {
      students: [{
        name: 'Test',
        progress: 100
      }]
    }
  }
};

function getTotalProgressByIteration(data) {
  let total = 0;
  let students = 0;

  for (let course of Object.values(data)) {
    if (Array.isArray(course)) {
      students += course.length;

      for (let i = 0; i < course.length; i++) {
        total += course[i].progress;
      }
    } else {
      for (let subCourse of Object.values(course)) {
        students += subCourse.length;

        for (let i = 0; i < subCourse.length; i++) {
          total += subCourse[i].progress;
        }
      }

    }
  }

  return total / students;
}

console.log(getTotalProgressByIteration(students));

// Recursion =>

function getTotalProgressByRecursion(data) {
  if (Array.isArray(data)) {
    let total = 0;

    for (let i = 0; i < data.length; i++) {
      total += data[i].progress;
    }

    return [total, data.length]
  } else {
    let total = [0, 0];

    for (let subData of Object.values(data)) {
      const subDataArr = getTotalProgressByRecursion(subData);
      total[0] += subDataArr[0];
      total[1] += subDataArr[1];

    }

    return total;
  }
}

const result = getTotalProgressByRecursion(students);

console.log(result[0]/result[1]);
```

https://learn.javascript.ru/recursion


  **[⬆ Наверх](#top)**
	
331. ### <a name="331"></a> 



  **[⬆ Наверх](#top)**
	
332. ### <a name="332"></a> 



  **[⬆ Наверх](#top)**
	
333. ### <a name="333"></a> 



  **[⬆ Наверх](#top)**	
	

401. ### <a name="401"></a> Базовая схема HTML-документа

Взглянем на базовую структуру любого HTML-документа:
```html
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Моя первая страница</title>
</head>
<body>

</body>
</html>
```	
Этот набор кажется не очень большим, но браузеру он сообщает множество полезной информации. В этом уроке разберёмся с каждой строчкой этой структуры.	
	
  **[⬆ Наверх](#top)**

402. ### <a name="402"></a> Использование символов HTML

  **[⬆ Наверх](#top)**

403. ### <a name="403"></a> Форматирование текста, абзацы

  **[⬆ Наверх](#top)**

404. ### <a name="404"></a> HTML-ссылки. Link target

  **[⬆ Наверх](#top)**

405. ### <a name="405"></a> Таблицы HTML 

Элемент <table служит контейнером для элементов, определяющих содержимое таблицы. Любая таблица состоит из строк и ячеек, которые задаются с помощью тегов <tr и <td. Внутри <table допустимо использовать следующие элементы: <caption, <col, <colgroup, <tbody, <td, <tfoot, <th, <thead и <tr.

Таблицы с невидимой границей долгое время использовались для верстки веб-страниц, позволяя разделять документ на модульные блоки. Подобный способ применения таблиц нашел воплощение на многих сайтах, пока ему на смену не пришел более современный способ верстки с помощью слоев.

Синтаксис
	
```html	
<table>
  <tr>
    <td>...</td>
  </tr>
</table>
```
	
*Атрибуты*
align - Определяет выравнивание таблицы.
background - Задает фоновый рисунок в таблице.
bgcolor - Цвет фона таблицы.
border - Толщина рамки в пикселах.
bordercolor - Цвет рамки.
cellpadding - Отступ от рамки до содержимого ячейки.
cellspacing - Расстояние между ячейками.
cols - Число колонок в таблице.
frame - Сообщает браузеру, как отображать границы вокруг таблицы.
height - Высота таблицы.
rules - Сообщает браузеру, где отображать границы между ячейками.
summary - Краткое описание таблицы.
width - Ширина таблицы.	
	
  **[⬆ Наверх](#top)**

406. ### <a name="406"></a> Добавление scripts

Тег <script> предназначен для описания скриптов, может содержать ссылку на программу или ее текст на определенном языке. Скрипты могут располагаться во внешнем файле и связываться с любым HTML-документом. Такой подход позволяет использовать одни и те же общие функции на многих веб-страницах и ускоряет их загрузку, т.к. внешний файл кэшируется при первой загрузке, и скрипт вызывается быстрее при последующих вызовах.

<script> может располагаться в заголовке или теле HTML-документа в неограниченном количестве. В большинстве случаев местоположение скрипта никак не сказывается на работу программы. Однако скрипты, которые должны выполняться в первую очередь, обычно помещают в заголовок документа.

Синтаксис
	
- <script type="тип"></script> 
	
- <script type="тип" src="URL"></script>

	
Атрибуты
- async - Загружает скрипт асинхронно.
- defer - Откладывает выполнение скрипта до тех пор, пока вся страница не будет загружена полностью.
- language - Устанавливает язык программирования на котором написан скрипт.
- src - Адрес скрипта из внешнего файла для импорта в текущий документ.
- type - Определяет тип содержимого тега <script>.
	
Закрывающий тег - Обязателен.	
	
  **[⬆ Наверх](#top)**

407. ### <a name="407"></a> Разница между блочными и строчными элементами

### Блочные элементы
	
Блочные элементы являются основой, которая используется для верстки веб-страниц. Такой элемент представляет собой прямоугольник, который по умолчанию занимает всю доступную ширину страницы (если иное значение не указано в CSS), а длина элемента зависит от его содержимого. Такой элемент всегда начинается с новой строки, то есть, располагается под предыдущим элементом. Блочный элемент может содержать в себе другие блочные и строчные элементы.

Примеры блочных элементов: <div, <p, <ul, <ol, <h1 и т. д.
 

### Строчные элементы
	
В отличие от блочного, строчный элемент не переносится на новую строку, а располагается на той же строке, что и предыдущий элемент. Такие элементы, как правило, находятся внутри блочных элементов и их ширина зависит лишь от содержимого и настроек CSS. Еще одно отличие строчного элемента от блочного заключается к том, что в нем может находиться только контент и другие строчные элементы. Блочные элементы в строчные вкладывать нельзя.

Примеры строчных элементов: <a, <span, <strong, <em, <img и т. д.	

	
Разница между блочными и строчными элементами следующая.

- Строчные элементы могут содержать только данные или другие строчные элементы, а в блочные допустимо вкладывать другие блочные элементы, строчные элементы, а также данные. Иными словами, строчные элементы никак не могут хранить блочные элементы.
- Блочные элементы всегда начинаются с новой строки, а строчные таким способом не акцентируются.
- Блочные элементы занимают всю доступную ширину, например, окна браузера, а ширина строчных элементов равна их содержимому плюс значения отступов, полей и границ.	
	
	
  **[⬆ Наверх](#top)**

408. ### <a name="408"></a> Для чего нужен DOCTYPE?

DOCTYPE — это сокращение от DOCument TYPE (тип документа). DOCTYPE всегда связан с DTD — Document Type Definition (определение типа документа).

DTD определяет как должны быть структурированы документы определенного типа (т.е. тег button может содержать в себе тег span, но не div), в то время как DOCTYPE объявляет, к какому DTD предположительно относится документ.

Для веб-страниц объявление DOCTYPE необходимо. Он используется для того, чтобы сообщить пользовательскому агенту, к какой версии спецификаций HTML принадлежит ваш документ. Как только пользовательский агент распознал правильный DOCTYPE, он запустит режим no-quirks, соответствующий этому DOCTYPE, для чтения документа. Если пользовательский агент не распознает правильный DOCTYPE, он активирует режим quirks.

DOCTYPE для стандарта HTML5 определяется как <!DOCTYPE html>
	
  **[⬆ Наверх](#top)**

409. ### <a name="409"></a> Как следует оформлять страницу, содержимое которой может быть на разных языках?

Вопрос немного расплывчатый. Полагаю, что речь о наиболее частом случае: как показывать страницу, где содержимое доступно на нескольких языках, но отображается на одном определенном.

Когда к серверу делается HTTP-запрос, то браузер пользователя обычно отсылает информацию о предпочитаемом языке в заголовке Accept-Language. Сервер может использовать эту информацию, чтобы вернуть версию документа на подходящем языке, если такая возможность есть. В возвращённом HTML-документе обязательно должен быть указан атрибут lang у тега <html>, к примеру <html lang="en">...</html>.

На бэкенде HTML-разметка будет содержать плейсхолдер i18n, а контент для конкретного языка будет храниться в YAML- или JSON-формате. Сервер динамически формирует HTML-страницу с контентом на конкретном языке, чаще всего при помощи бэкенд-фреймворка.
	
  **[⬆ Наверх](#top)**

410. ### <a name="410"></a> На что необходимо обратить внимание при разработке мультиязычных сайтов?

- Используйте атрибут lang в HTML.
- Перенаправляйте пользователей на версию сайта на их языке. Позволяйте быстро и без проблем изменить страну и язык.
- Текст на картинках плохо поддается адаптации. Многие до сих пор помещают текст на картинки чтобы получить хорошо выглядящий несистемный шрифт на любом компьютере. Однако чтобы перевести текст картинкой, нужно иметь подготовленную картинку с каждой строкой текста для каждого языка. При большом количестве текста это быстро выйдет из-под контроля.
- Ограничение длины слов и предложений. Некоторый текст может быть длиннее при написании на другом языке. Будьте внимательны к макету и проверяйте поведение блоков при переполнении. Количество символов важно в таких элементах, как заголовки, лейблы и кнопки. Но не так важно в основном тексте или в блоке комментария.
- Помните о восприятии цветов. В разных языках и культурах цвета имеют разное значение. Дизайн должен учитывать эти особенности.
- Форматируйте даты и валюты. Календарные даты иногда пишутся по-разному. Например, «Май 31, 2012» в США или «31 мая 2012» в странах Европы.
- Не склеивайте переведённые строки. Не пишите что-то вроде "Сегодняшняя дата " + date. Эта фраза будет выглядеть некорректно на языках с другим порядком слов. Вместо этого используйте шаблонную строку с подстановкой параметров для каждого языка. Например, посмотрите на следующие два предложения на русском и китайском соответственно: Я буду путешествовать {% date %} и {% date %} 我会出发. Обратите внимание, что положение переменной отличается из-за грамматических правил языка.
- Разные направления чтения. В русском мы читаем слева направо, сверху вниз. В традиционном японском языке текст читается сверху вниз, справа налево.
	
  **[⬆ Наверх](#top)**

411. ### <a name="411"></a> Для чего нужны data- атрибуты

До того, как JavaScript-фреймворки стали популярны, фронтенд-разработчики использовали data- атрибуты чтобы хранить дополнительные данные прямо в DOM без хаков вроде нестандартных атрибутов или дополнительных свойств в DOM. Атрибуты этого семейства предназначены для хранения частных данных пользователя, для которых не существует более подходящих атрибутов или элементов на странице или в приложении.

На сегодняшний день использование data-атрибутов не поощряется. Одной из причин является то, что пользователь может модифицировать данные в атрибуте, используя инспектор кода в браузере. Данные лучше хранить в самом JavaScript и обновлять DOM при помощи связывания данных через библиотеку или фреймворк.
	
  **[⬆ Наверх](#top)**

412. ### <a name="412"></a> Представьте HTML5 как открытую веб-платформу. Из каких блоков состоит HTML5?

- Семантика. Позволяет более точно описать из чего состоит контент.
- Связанность. Позволяет общаться с сервером новыми и инновационными способами.
- Офлайн и хранилище. Позволяют страницам хранить данные локально на клиентской стороне и более эффективно работать в офлайне.
- Мультимедиа. Ставит создание видео и аудио на первое место в вебе.
- 2D/3D-графика и эффекты. Позволяет расширить возможности презентации.
- Производительность и интеграция. Обеспечивает большую скорость оптимизации и лучшее использование аппаратных средств.
- Доступ к устройствам. Позволяет взаимодействовать с различными устройствами ввода и вывода.
- Стилизация. Позволяет создавать более сложные темы оформления.	

  **[⬆ Наверх](#top)**

413. ### <a name="413"></a> Объясните разницу между cookie, sessionStorage и localStorage

Все вышеупомянутые технологии являются механизмами хранения типа ключ-значение на клиентской стороне. Они могут хранить данные только как строки.

![50](https://user-images.githubusercontent.com/80325645/151212346-bbf5e336-671d-4e48-bffa-18d09816e24b.jpg)
	
  **[⬆ Наверх](#top)**

414. ### <a name="414"></a> Объясните разницу между <script>, <script async> и <script defer>

- <script> - отрисовка HTML блокируется, скрипт извлекается и выполняется немедленно, отрисовка HTML возобновляется после окончания выполнения скрипта.
- <script async> - скрипт будет получен и обработан параллельно с отрисовкой HTML, его выполнение закончится как только это будет возможно (обычно до того, как закончилась отрисовка HTML). Используйте async тогда, когда скрипт не зависит от других скриптов на странице, например для аналитики.
- <script defer> - скрипт будет получен параллельно с отрисовкой HTML, его выполнение произойдет после того, как вся страница будет загружена. Если таких скриптов несколько, то каждый из них будет исполнятся в том порядке, в котором они расположены в документе. Если скрипту нужен полностью распарсеный DOM, то атрибут defer обеспечит уверенность в том, что на момент отработки скрипта весь HTML отрисован. Нет особой разницы со скриптами, расположенными перед тегом <body>. Отложенный скрипт не должен содержать document.write.

Примечание: Атрибуты async и defer игнорируются, если у тега <script> нет атрибута src.
	
  **[⬆ Наверх](#top)**

415. ### <a name="415"></a> Почему хорошей практикой считается располагать <link> для подключения CSS между <head></head>, а <script> для подключения JS ставить перед </body>? Знаете ли вы исключения?

Размещение <link> внутри <head>

Размещение <link> внутри тега <head> необходимо при создании оптимизированного веб-сайта. Когда страница загружается впервые, HTML и CSS анализируются одновременно; HTML создает DOM (объектную модель документа), а CSS создает CSSOM (объектную модель CSS). И то, и другое необходимо для создания визуальных элементов на веб-сайте, что позволяет быстро определить время «первого значимого рисования». Этот прогрессивный рендеринг является категорией оптимизации сайтов, которые измеряются в их показателях эффективности. Размещение таблиц стилей в нижней части документа - это то, что препятствует прогрессивной загрузке страницы во многих браузерах. Некоторые браузеры блокируют рендеринг, чтобы избежать перерисовки элементов страницы, если ее стили изменятся. Все это время пользователь будет пялиться на пустую белую страницу. В других случаях может возникать мерцание нестилизованного содержимого (FOUC), на котором может отображаться веб-страница без применения стилей.

Размещение <script> прямо перед </body>

Теги <script> блокируют отрисовку HTML на то время, пока они скачиваются и исполняются. Размещение скриптов внизу позволяет сперва распарсить и показать пользователю весь HTML.

Исключением является случай, когда в вашем скрипте содержится document.write(). Но на сегодняшний день его использование не считается хорошей практикой. К тому же, расположение скриптов внизу разметки означает, что браузер не может начать их скачивать до тех пор, пока не отрисован весь документ. Единственным рабочим способом, при котором <script> будет расположен внутри <head>, является добавление атрибута defer.
	
  **[⬆ Наверх](#top)**

416. ### <a name="416"></a> Что такое прогрессивный рендеринг

Прогрессивный рендеринг — это название технологий, используемых для ускорения отрисовки страниц (в частности, для уменьшения времени загрузки), чтобы показать пользователю контент как можно скорее.

До того, как широкополосный интернет распространился повсеместно, прогрессивный рендеринг встречался довольно часто. Но этот подход по прежнему полезен в современной разработке, поскольку все более популярным (и ненадежным) становится мобильный доступ в интернет.

Примеры подобных технологий:

- Ленивая загрузка изображений. Изображения на странице не загружаются все разом. JavaScript подгрузит изображения тогда, когда пользователь доскроллит до той части страницы, на которой они расположены.
- Приоритизация видимого контента. Только минимум CSS, контента, скриптов, необходимых для отрисовки той части страницы, которую пользователь увидит первой. Вы можете использовать отложенные скрипты или слушать события DOMContentLoaded или load, чтобы загрузить остальные ресурсы и контент.
- Асинхронные фрагменты HTML. Отправка в браузер частей HTML-страницы, созданной на бэкенде.
	
  **[⬆ Наверх](#top)**

417. ### <a name="417"></a> 

	
  **[⬆ Наверх](#top)**

418. ### <a name="418"></a> Что такое семантика?

`Семантическая вёрстка` — подход к разметке, который опирается не на содержание сайта, а на смысловое предназначение каждого блока и логическую структуру документа. Даже в этой статье есть заголовки разных уровней — это помогает читателю выстроить в голове структуру документа. Так и на странице сайта — только читатели будут немного другими.

`Чтобы сделать сайт доступным.` Зрячие пользователи могут без проблем с первого взгляда понять, где какая часть страницы находится — где заголовок, списки или изображения. Для незрячих или частично незрячих всё сложнее. Основной инструмент для просмотра сайтов не браузер, который отрисовывает страницу, а скринридер, который читает текст со страницы вслух.

Этот инструмент «зачитывает» содержимое страницы, и семантическая структура помогает ему лучше определять, какой сейчас блок, а пользователю понимать, о чём идёт речь. Таким образом семантическая разметка помогает большему количеству пользователей работать с вашим сайтом. Например, наличие заголовков помогает незрячим в навигации по странице. У скринридеров есть функция навигации по заголовкам, что ускоряет знакомство с информацией на сайте.

`Чтобы сайт был выше в поисковиках.` 

`Основные семантические теги HTML`

Тег `i` и тег `em` теги. Внешне ничем не различаются, но семантический смысл разный. Первый тег `i` просто выделяет текст курсивным начертанием, второй же тег em придает тексту, помещенному в него, особый смысл. Текст становится более важным на странице. То есть, если не смотреть внешний результат, то тег `em` дает смысловое выделение, а тег `i` нет. Когда же посмотреть в браузере результат, выглядят они одинаково, но особое значение у текста в теге em. Таким образом, разница между `i` и `em` установлена.

Другой аналогичный пример, теги `b` и `strong`. Здесь даже из названия можно понять, что второй тег гораздо значимый. Действительно, `b` просто выделяет текст жирным начертанием, а `strong` выделяет жирным и придает семантический смысл тексту, помещенного в этот тег. Особенно важно для поисковых систем, текст в `strong` играет большое значение при выдаче.

Среди «старых» тегов из ранних версий HTML тоже есть семантические — например, тег `<p>`, который обозначает параграф. При этом теги `<i>` или `<b>` не семантические, потому что они не добавляют смысла выделенному тексту, а просто определяют его внешний вид.

`<article>`
- Значение: независимая, отделяемая смысловая единица, например комментарий, твит, статья, виджет ВК и так далее.
- Особенности: желателен заголовок внутри.
- Типовые ошибки: путают с тегами `<section>` и `<div>`.

`<section>`
- Значение: смысловой раздел документа. Неотделяемый, в отличие от `<article>`.
- Особенности: желателен заголовок внутри.
- Типовые ошибки: путают с тегами `<article>` и `<div>`.

`<aside>`
- Значение: побочный, косвенный для страницы контент.
- Особенности: может иметь свой заголовок. Может встречаться несколько раз на странице.
- Типовые ошибки: считать `<aside`> тегом для «боковой панели» и размечать этим тегом основной контент, который связан с окружающими его элементами.

`<nav>`
- Значение: навигационный раздел со ссылками на другие страницы или другие части страниц.
- Особенности: используется для основной навигации, а не для всех групп ссылок. Основной является навигация или нет — на усмотрение верстальщика. Например, меню в подвале сайта можно не оборачивать в <nav>. В подвале обычно появляется краткий список ссылок (например, ссылка на главную, копирайт и условия) — это не является основной навигацией, семантически для такой информации предназначен `<footer>` сам по себе.
- Типовые ошибки: многие считают, что в `<nav>` может быть только список навигационных ссылок, но согласно спецификации там может быть навигация в любой форме.

`<header>`
- Значение: вводная часть смыслового раздела или всего сайта, обычно содержит подсказки и навигацию. Чаще всего повторяется на всех страницах сайта.
- Особенности: этих элементов может быть несколько на странице.
- Типовые ошибки: использовать только как шапку сайта.

`<main>`
- Значение: основное, не повторяющееся на других страницах, содержание страницы.
- Особенности: должен быть один на странице, исходя из определения.
- Типовые ошибки: включать в этот тег то, что повторяется на других страницах (навигацию, копирайты и так далее).

`<footer>`
- Значение: заключительная часть смыслового раздела или всего сайта, обычно содержит информацию об авторах, список литературы, копирайт и так далее. Чаще всего повторяется на всех страницах сайта.
- Особенности: этих элементов может быть несколько на странице. Тег `<footer>` не обязан находиться в конце раздела.
- Типовые ошибки: использовать только как подвал сайта.

  **[⬆ Наверх](#top)**

419. ### <a name="419"></a> 

	
  **[⬆ Наверх](#top)**

420. ### <a name="420"></a> 

	
  **[⬆ Наверх](#top)**

421. ### <a name="421"></a> 

	
  **[⬆ Наверх](#top)**

422. ### <a name="422"></a> 

	
  **[⬆ Наверх](#top)**

423. ### <a name="423"></a> 

	
  **[⬆ Наверх](#top)**

499. ### <a name="499"></a> 

	
  **[⬆ Наверх](#top)**

500. ### <a name="500"></a> Варианты добавление CSS стилей на страницу?

- `Подключение CSS через внешний файл стилей тегом link`

Наиболее правильный вариант определения общих стилей для сайта - это подключение внешнего файла CSS с помощью тега <link>.

Чтобы подключить CSS файл, в head области страницы используйте следующую конструкцию:
```js
<link href="URL_адрес_CSS_файла" rel="stylesheet" type="text/css">
```
В атрибуте href необходимо указать URL адрес файла, содержащего набор стилей CSS. Атрибуты rel="stylesheet" и type="text/css" указывают, что указанный файл является таблицей стиля в формате CSS.

Вы можете привязать неограниченное количество файлов CSS к одной странице сайта. Однако подключение большого количества объемных CSS файлов приведет к увеличению веса страницы, и соответственно может привести к увеличению времени загрузки и обработки страницы.

- `Добавление CSS с помощью тега style`

Этот метод подойдет когда нужно вставить (определить) стили для группы уникальных элементов страницы, то есть, набор стилей, которые используются только в пределах одной страницы и не нужны для корректной работы остальных страниц сайта.

В любом месте областей <head> и <body> HTML документа используйте тег <style>, внутри которого поместите необходимые CSS правила.
```js
<style type="text/css">
  /* CSS код */
</style>
```

- `CSS стили для конкретного тега атрибутом style`

Если вам нужно задать стиль для конкретного элемента контента страницы (одного конкретного тега), воспользуйтесь атрибутом style.
```js
<p style="CSS_код">текст</p>
```
Стили, заданные через атрибут style называют inline-стилями. Такие стили имеют приоритет перед стилями, заданными через внешний файл или с помощью тега <style>, но есть исключения.

Inline-стили также обычно используются, когда вы редактируете контент через программы - визуальные редакторы WYSIWYG.

- `Стили CSS через JavaScript`
Практически на каждом современном сайте используются скрипты, написанные на языке JavaScript.

В JavaScript, при использовании библиотеки jQuery, есть много различных функций для управления стилями HTML элементов. Например, функция .css() - задает CSS стиль для элемента, .hide() - добавление элементу CSS свойства display: none; (скрытие элемента) и др.

При использовании этих функций CSS свойства добавляются в style атрибут тега.
	
  **[⬆ Наверх](#top)**

501. ### <a name="501"></a> css modules

`CSS модуль` — это CSS файл, в котором все имена классов и анимаций имеют локальную область видимости по умолчанию.

Ключевая идея здесь — локальная область видимости.

Чтобы проиллюстрировать эту концепцию, давайте создадим JavaScript и CSS файлы компонента.
```js
/* select.css */
.select {}
.loading {}
.item {}
.icon {}
```
```js
/* select.js */
import styles from "./select.css";

console.log(styles.select, styles.loading);
```
 
Зачем нам нужно использовать CSS-модули?

CSS-модули гарантируют, что все стили одного компонента:

Находятся в одном месте
Применяются только к этому компоненту и никакому другому

Кроме того, каждый компонент может иметь настоящие зависимости, например:
```js
import buttons from "./buttons.css";
import padding from "./padding.css";

element.innerHTML = `<div class="${buttons.red} ${padding.large}">`;
```

Этот подход был разработан, что бы решить проблему глобальной области видимости в CSS

Вы когда-нибудь испытывали соблазн в условиях нехватки времени или ресурсов просто писать CSS так быстро, как можете, не думая о последствиях?

Пихали ли в конец таблицы стилей какой-нибудь мусор, собираясь потом его отрефакторить, и так никогда этого и не сделали?

Бывало ли такое, что вы просматривали стили, не до конца понимая что они делают и используются ли они вообще?

Задумывались ли вы, получится ли избавиться от некоторых стилей, ничего при этом не сломав? Не приходилось ли гадать, эти стили работают сами по себе или зависят от других? Случалось ли вам перезаписывать стили?

Это вопросы, которые могут привести к серьезной головной боли, пропущенным дедлайнам и грустным взглядам в окно.

С CSS-модулями и концепцией использования локальной области видимости по умолчанию таких проблем можно избежать. Вам всегда приходится думать о последствиях, когда вы пишите стили.

Например, если вы используете в HTML класс random-gross-class, не обработав его как класс CSS-модуля, стили не применятся, так как CSS-селектор превратится во что-то вроде ._style_random-gross-class_0038089.

`Ключевое слово composes`

Допустим, у нас есть модуль под названием type.css, содержащий стили для текста. В этом файле может быть, например, такое:
```js
.serif-font {
  font-family: Georgia, serif;
}

.display {
  composes: serif-font;
  font-size: 30px;
  line-height: 35px;
}
```
Один из этих классов мы используем в шаблоне:
```js
import type from "./type.css";

element.innerHTML = 
  `<h1 class="${type.display}">
    Пример заголовка
  </h1>`;
```
В результате получится такая разметка:
```js
<h1 class="_type__display_0980340 _type__serif_404840">
  Пример заголовка
</h1>
```
Оба класса связаны с элементом через использование ключевого слова composes, решая таким образом некоторые проблемы, которые есть в похожих решениях, например в @extend Sass.

Так можно даже подставлять данные из отдельного CSS-файла:
```js
.element {
  composes: dark-red from "./colors.css";
  font-size: 30px;
  line-height: 1.2;
}
```

`Нам не нужен БЭМ`, если мы используем CSS-модули. По двум причинам:

- Простота чтения. Код вроде type.display так же понятен для разработчика, как и .font-size__serif--large из БЭМ. Его даже проще читать, чем разросшиеся БЭМ-селекторы.

- Локальная область видимости. Допустим, в одном из модулей у нас есть класс .big и он увеличивает font-size на некоторую величину. В другом модуле у нас есть точно такой же класс .big, который увеличивает padding и font-size на другую величину. И это не имеет никакого значения! Они не будут конфликтовать, так как у стилей различаются области видимости. Даже если модуль импортирует обе таблицы стилей, у классов будет своё уникальное имя, созданное в процессе сборки специально для них.

Другими словами, при использовании CSS-модулей проблемы специфичности селекторов просто исчезают.

  **[⬆ Наверх](#top)**

502. ### <a name="502"></a> Селекторы и их вес

Селектор — это строка, представляющая собой формальное описание структуры, на основе которого выбирается элемент или группа элементов в дереве документа и применяется объявленный блок свойств.

Селекторы бывают самые разные. Существуют простые селекторы, например, состоящие из одной буквы или одного слова, и сложные, состоящие из большого количества слов и различных синтаксических конструкций.
	
Вес селектора — это условные четыре позиции x, x, x, x, которые заполняются нулями и единицами в соответствии с содержимым селектора. Каждая из позиций имеет своё содержимое:

- Инлайн стили
- Идентификаторы
- Классы, атрибуты и псевдоклассы
- Теги и псевдоэлементы	
	
*А что, если вес селекторов одинаковый?*
Допустим, что у вас есть два или несколько селекторов так или иначе указывающих на один и тот же элемент. И вот так сложилось, что вы посчитали или просто взглянули на них, и вес оказался одинаковым. Не стоит отчаиваться, просто блок объявлений последнего селектора в вашем CSS-коде из этой группы и будет применяться к элементу. Как-то так. Мне кажется это логичным. Прямо как в поговорке «кто не успел, тот опоздал», но наоборот: «кто опоздал, тот и успел».	
		
	
  **[⬆ Наверх](#top)**

503. ### <a name="503"></a> Positioning

Устанавливает способ позиционирования элемента относительно окна браузера или других объектов на веб-странице.

Синтаксис
	
position: absolute | fixed | relative | static | inherit
	
Значения
	
- `absolute` - Указывает, что элемент абсолютно позиционирован, при этом другие элементы отображаются на веб-странице словно абсолютно позиционированного элемента и нет. Положение элемента задается свойствами left, top, right и bottom, также на положение влияет значение свойства position родительского элемента. Так, если у родителя значение position установлено как static или родителя нет, то отсчет координат ведется от края окна браузера. Если у родителя значение position задано как fixed, relative или absolute, то отсчет координат ведется от края родительского элемента.
- `fixed` - По своему действию это значение близко к absolute, но в отличие от него привязывается к указанной свойствами left, top, right и bottom точке на экране и не меняет своего положения при прокрутке веб-страницы. Браузер Firefox вообще не отображает полосы прокрутки, если положение элемента задано фиксированным, и оно не помещается целиком в окно браузера. В браузере Opera хотя и показываются полосы прокрутки, но они никак не влияют на позицию элемента.
- `relative` - Положение элемента устанавливается относительно его исходного места. Добавление свойств left, top, right и bottom изменяет позицию элемента и сдвигает его в ту или иную сторону от первоначального расположения.
- `static` - Элементы отображаются как обычно. Использование свойств left, top, right и bottom не приводит к каким-либо результатам.
- `inherit` - Наследует значение родителя.	
	
  **[⬆ Наверх](#top)**

504. ### <a name="504"></a> Margings vs paddings

margin и padding являются наиболее популярными свойствами для расстановки элементов. В то время как margin определяет пространство за пределами (снаружи) элемента, padding определяет пространство внутри элемента.
	
*Блочная модель*
	
Margin, padding и border – это части так называемой Блочной модели. Механизм Блочной модели следующий: Посередине есть зона контента, которую окружает padding, окруженный границей border, которая в свою очередь окружена полями margin. Визуально представление Блочной модели выглядит так:	
	
![box-model-standard-small](https://user-images.githubusercontent.com/80325645/131230563-aadc77ec-a38e-4125-ac9d-29aa64dc0f42.png)
	
	
  **[⬆ Наверх](#top)**

505. ### <a name="505"></a> Добавление шрифтов

Шрифты можно подключать тремя разными спосоами:
	
1. При помощи font-family подключаем лакальный шрифт. Используется редко, так как такие шрифты не используютсяв web. В CSS файле пишем:
```js
html {
	font-family: Roboto, sans-serif;	
}	
```	

2. При помощи удаленных серверов, Google fonts, там есть не все шрифты или они платные
	
Выбираем шрифт, кастомизируем его, выбираем link и вставляем его в html файл до link со стилями. Копируем строку с font-family: 'Roboto', sans-serif и вставляем ее в style.css в тег html {font-family: 'Roboto', sans-serif} и дальше по стилям файла пишем только font-weight: 400 (или любое другое очертание шрифта)	

3. Локальное подключение: если его нету на google fonts то шрифт нужно смотреть на других сайтах, таких как webfonts.pro, находим шрифт, заходим в web и копируем font-face и вставляем его в css файл перед html, редактируем путь до наших локальных шрифтов которые находдятся в этом проекте в папке fonts. Можно добавить font-weight и использовать их по файлу, так лучше и легче
	
	
  **[⬆ Наверх](#top)**

506. ### <a name="506"></a> Видимость элемента. Способы скрыть элемент

Есть свойство, которое позволяет управлять видимостью содержимого элемента.

*visibility* — управляет в CSS, видимостью содержимого элемента.

Значения:
- visible – содержимое отображается.
- hidden — содержимое не отображается.	
- inherit - наследует видимость родительского элемента;
	
		
Следующее свойство, которое позволяет управлять видимостью блока – это display.

*display* — определяет, как будет отображаться элемент

Значения:
- none — элемент не отображается
- block - разбивает строку до и после элемента (т.е. элемент не может находится на одной линии с другими элементами)
- inline - не разбивает строку	
- inline-block - аналогично block;
- list-item - аналогично block, но при этом элемент страницы считается позицией списка.	
	
  **[⬆ Наверх](#top)**

507. ### <a name="507"></a> Z-index

Любые позиционированные элементы на веб-странице могут накладываться друг на друга в определенном порядке, имитируя тем самым третье измерение, перпендикулярное экрану. Каждый элемент может находиться как ниже, так и выше других объектов веб-страницы, их размещением по z-оси и управляет z-index. Это свойство работает только для элементов, у которых значение position задано как absolute, fixed или relative.

Синтаксис
	
z-index: число | auto | inherit

Значения
В качестве значения используются целые числа (положительные, отрицательные и ноль). Чем больше значение, тем выше находится элемент по сравнению с теми элементами, у которых оно меньше. При равном значении z-index, на переднем плане находится тот элемент, который в коде HTML описан ниже. Хотя спецификация и разрешает использовать отрицательные значения z-index, но такие элементы не отображаются в браузере Firefox до версии 2.0 включительно.

Кроме числовых значений применяется auto — порядок элементов в этом случае строится автоматически, исходя из их положения в коде HTML и принадлежности к родителю, поскольку дочерние элементы имеют тот же номер, что их родительский элемент. Значение inherit указывает, что оно наследуется у родителя.	
	
  **[⬆ Наверх](#top)**

508. ### <a name="508"></a> Чем полезны data- атрибуты?

HTML5 спроектирован с возможностью расширения данных ассоциированных с каким-либо элементом, но в то же время не обязательно имеющих определённое значение. data-* атрибуты позволяют хранить дополнительную информацию в стандартных элементах HTML, без хаков вроде нестандартных атрибутов, лишних DOM-свойств или Node.setUserData().

Синтаксис HTML
```html	
<article
	id="electriccars"
	data-columns="3"
	data-index-number="12314"
	data-parent="cars">
</article>
```	
Доступ в JavaScript
```js
var article = document.getElementById('electriccars');
article.dataset.columns // "3"
article.dataset.indexNumber // "12314"
article.dataset.parent // "cars"
```	
Доступ в CSS
```js
article::before {
	content: attr(data-parent);
}
```	
	
  **[⬆ Наверх](#top)**

509. ### <a name="509"></a> Что такое кэш приложения в HTML5?

Доступность в оффлайне становится всё более важной для веб-приложений. Да, все браузеры имеют механизмы кэширования, но они ненадежны и работают не всегда ожидаемо. HTML5 устраняет некоторые из этих неприятностей с помощью интерфейса ApplicationCache.

Использование интерфейса кэша даёт вашему приложению три преимущества:

- автономный просмотр — пользователи могут исследовать ваш сайт целиком, когда они находятся в оффлайне;
- скорость — ресурсы кэшируются локально, поэтому загружаются быстрее;
- снижение нагрузки на сервер — браузер загружает с сервера только изменённые ресурсы.
- Кэш приложения (или AppCache) позволяет разработчику указать, какие файлы браузер должен кэшировать и сделать доступными для оффлайновых пользователей. Ваше приложение будет работать корректно, даже если пользователь нажимает кнопку «Обновить», находясь в автономном режиме.	
	
  **[⬆ Наверх](#top)**

510. ### <a name="510"></a> Объясните разницу между <script>, <script async> и <script defer>

Просто script с src:
- Получить страницу HTML (например, index.html)
- Начните синтаксический анализ HTML
- Парсер встречает тег ```<script>```, ссылающийся на внешний файл script.
- Браузер запрашивает файл script. Между тем, синтаксический анализатор блокирует и останавливает анализ другого HTML на вашей странице.
- Через некоторое время загрузится и затем выполняется script.
- Парсер продолжает анализировать остальную часть HTML-документа.
	
async: Поддерживается всеми браузерами, кроме IE9-. Скрипт выполняется полностью асинхронно. То есть, при обнаружении ```<script async src="...">``` браузер не останавливает обработку страницы, а спокойно работает дальше. Когда скрипт будет загружен – он выполнится.

defer: Поддерживается всеми браузерами, включая самые старые IE. Скрипт также выполняется асинхронно, не заставляет ждать страницу, но есть два отличия от async.

Первое – браузер гарантирует, что относительный порядок скриптов с defer будет сохранён.

Второе отличие – скрипт с defer сработает, когда весь HTML-документ будет обработан браузером.	
	
  **[⬆ Наверх](#top)**

511. ### <a name="511"></a> Дайте пояснения, для какой цели добавленны след. элементы: article, aside, audio, canvas, figcaption, figure, footer, header, hgroup, output, section, video

- article: Тег article задает содержание сайта вроде новости, статьи, записи блога, форума или др. Элемент должен содержать часть самодостаточной информации, которая может быть вырвана из контекста всей страницы без потери смысла.
- aside: Определяет блок сбоку от контента для размещения рубрик, ссылок на архив, меток и другой информации. Такой блок, как правило, называется «сайдбар» или «боковая панель».
- audio: Добавляет, воспроизводит и управляет настройками аудиозаписи на веб-странице. Путь к файлу задается через атрибут src или вложенный тег source. Внутри контейнера audio можно написать текст, который будет выводиться в браузерах, не работающих с этим тегом.
- canvas: Это HTML элемент, использующийся для рисования графики средствами языков программирования (обычно это JavaScript).
- figcaption: Содержит описание для тега figure. Тег figcaption должен быть первым или последним элементом в группе.
- figure: Используется для группирования любых элементов, например, изображений и подписей к ним.
- footer: Тег footer задаёт «подвал» сайта или раздела, в нём может располагаться имя автора, дата документа, контактная и правовая информация.
- header: Тег header задает «шапку» сайта или раздела, в которой обычно располагается заголовок.
- hgroup: Используется для группирования заголовков веб-страницы или раздела. Внутри располагаются теги заголовков от h1 до h6. Данный тег исключён из версии HTML от W3C, но остался в версии WHATWG, будущее элемента пока не определено.
- output: Определяет область в которую выводится информация, преимущественно с помощью скриптов.
- section: Задаёт раздел документа, может применяться для блока новостей, контактной информации, глав текста, вкладок в диалоговом окне и др. Раздел обычно содержит заголовок. Допускается вкладывать один тег section внутрь другого.
- video: Добавляет, воспроизводит и управляет настройками видеоролика на веб-странице. Путь к файлу задается через атрибут src или вложенный тег source.	
	
  **[⬆ Наверх](#top)**

512. ### <a name="512"></a> Чем отличается article от section?

Чтобы не было путаницы, разберём где и когда использовать разные контейнеры:
- div — контейнер общего назначения, не обязательно смысловой. Дивы используются для разметки мелких блоков, создания сетки и декоративных эффектов.
- section — более крупный логический контейнер, объединяющий содержание по смыслу. Например, блок «О компании», список товаров, раздел личной информации в профиле и так далее.
- article — самостоятельный, цельный и независимый раздел документа. Этот раздел можно в неизменном виде использовать в различных местах, в том числе и на других сайтах. Примеры: статья, пост в блоге, сообщение на форуме и так далее.	
	
  **[⬆ Наверх](#top)**

513. ### <a name="513"></a> Можно ли вложить p в другой такой же p? Можно ли вложить div в p?

Синтаксически div и p внутри p является недопустимым во всех стандартах HTML. Более того, при использовании соответствующего парсера HTML невозможно разместить элемент div внутри p в DOM, потому что открывающий тег div автоматически закрывает элемент p.	
	
  **[⬆ Наверх](#top)**

514. ### <a name="514"></a> Чем отличается класс (class) от идентификатора (id) в HTML?

Идентификаторы:
- В коде документа каждый идентификатор уникален и должен быть включён лишь один раз.
- Имя идентификатора чувствительно к регистру.
- Через метод getElementById можно получить доступ к элементу по его идентификатору и изменить свойства элемента.
- Стиль для идентификатора имеет приоритет выше, чем у классов.

Классы:
- Классы могут использоваться в коде неоднократно.
- Имена классов чувствительны к регистру.
- Классы можно комбинировать между собой, добавляя несколько классов к одному тегу.	
	
  **[⬆ Наверх](#top)**

515. ### <a name="515"></a> Что такое прогрессивный рендеринг

Асинхронные фрагменты HTML. Отправка в браузер частей HTML-страницы, созданной на бэкенде. Более подробно про эту технологию можно почитать в этой статье.

Прогрессивный рендеринг — это название технологий, используемых для ускорения отрисовки страниц (в частности, для уменьшения времени загрузки), чтобы показать пользователю контент как можно скорее.

До того, как широкополосный интернет распространился повсеместно, прогрессивный рендеринг встречался довольно часто. Но этот подход по прежнему полезен в современной разработке, поскольку все более популярным (и ненадежным) становится мобильный доступ в интернет.

Примеры подобных технологий:

- Ленивая загрузка изображений. Изображения на странице не загружаются все разом. JavaScript подгрузит изображения тогда, когда пользователь доскроллит до той части страницы, на которой они расположены.
- Приоритизация видимого контента. Только минимум CSS, контента, скриптов, необходимых для отрисовки той части страницы, которую пользователь увидит первой. Вы можете использовать отложенные скрипты или слушать события DOMContentLoaded или load, чтобы загрузить остальные ресурсы и контент.
- Асинхронные фрагменты HTML. Отправка в браузер частей HTML-страницы, созданной на бэкенде.	
	
  **[⬆ Наверх](#top)**

516. ### <a name="516"></a> Почему хорошей практикой считается располагать <link> для подключения CSS между <head></head>, а <script> для подключения JS ставить перед </body>? Знаете ли вы исключения?

### Размещение <link> внутри <head>

Размещение <link> внутри тега <head> необходимо при создании оптимизированного веб-сайта. Когда страница загружается впервые, HTML и CSS анализируются одновременно; HTML создает DOM (объектную модель документа), а CSS создает CSSOM (объектную модель CSS). И то, и другое необходимо для создания визуальных элементов на веб-сайте, что позволяет быстро определить время «первого значимого рисования». Этот прогрессивный рендеринг является категорией оптимизации сайтов, которые измеряются в их показателях эффективности. Размещение таблиц стилей в нижней части документа - это то, что препятствует прогрессивной загрузке страницы во многих браузерах. Некоторые браузеры блокируют рендеринг, чтобы избежать перерисовки элементов страницы, если ее стили изменятся. Все это время пользователь будет пялиться на пустую белую страницу. В других случаях может возникать мерцание нестилизованного содержимого (FOUC), на котором может отображаться веб-страница без применения стилей.

### Размещение <script> прямо перед </body>

Теги <script> блокируют отрисовку HTML на то время, пока они скачиваются и исполняются. Размещение скриптов внизу позволяет сперва распарсить и показать пользователю весь HTML.

Исключением является случай, когда в вашем скрипте содержится document.write(). Но на сегодняшний день его использование не считается хорошей практикой. К тому же, расположение скриптов внизу разметки означает, что браузер не может начать их скачивать до тех пор, пока не отрисован весь документ. Единственным рабочим способом, при котором <script> будет расположен внутри <head>, является добавление атрибута defer.	
	
  **[⬆ Наверх](#top)**

517. ### <a name="517"></a> 

  **[⬆ Наверх](#top)**
	
518. ### <a name="518"></a> Объясните, что такое плавающие элементы (floats) и как они работают?

- Float определяет, по какой стороне будет выравниваться элемент, при этом остальные элементы будут обтекать его с других сторон. Плавающие (обтекающие) элементы сначала выстраиваются в нормальном потоке, затем образуется новый поток, и они сдвигаются либо вправо, либо влево (в зависимости от выбранного значения) в родительском контейнере. Иными словами, они идут по порядку друг за другом. Учитывая, что в родительском контейнере есть достаточно свободного места, эти плавающие элементы не подстраиваются и не выравниваются для распределения пространства между этими самыми элементами.
- Как правило, плавающий элемент обязательно должен иметь фиксированную ширину. Это гарантирует, что float ведет себя так как и ожидалось, избегая проблем в некоторых браузерах.
- Используя свойство clear, вы можете указать пять значений: left, right, both, inherit, и none. Это свойство определяет, по какой стороне будет выравниваться элемент, при этом остальные элементы будут обтекать его с других сторон. Например, если вы укажите «left», элемент задействует отмену обтекания с левого края плавающего элемента. При этом все другие элементы на этой стороне будут опущены вниз, и располагаться под текущим элементом.
- Правило, которое я обнаружил для себя, прекрасно работает для моих float-макетов.В своем HTML коде, я почти всегда сначала создаю плавающие элементы во время разметки, прежде чем добавлять простые элементы, которые могут взаимодействовать с ними. Вы экономите большую часть времени, и это дает желаемый результат.
- Но и тут бывают проблемы, когда вы помещаете в родительский блок плавающие элементы, родительский контейнер не может определить динамически высоту своих дочерних элементов, поэтому родительский контейнер будет иметь высоту равную нулю. Это может поломать вашу верстку. Существует метод, который позволяет родительскому элементу, определить свое пространство с учетом каких-либо плавающих элементов внутри. Можно использовать CSS свойство overflow (переполнение) со значением hidden (скрыть). Обратите внимание, что значение свойства overflow не предназначено для такого рода использования, и может вызывать некоторые проблемы, такие как скрытие нужного контента в данный момент или появление нежелательных полос прокрутки.
- Хак: для очистки плавающих элементов лучше применять ‘overflow:auto’ к родительскому элементу.
- Обратите внимание, что данный трюк не очищает плавающие элементы — он просто растягивает родительский контейнер. Вы можете принудительно очистить float, если вы добавите очищающий элемент после последнего плавающего элемента, или вы можете добавить в любом нужном вам месте, создав тем самым новый поток. Родительский элемент не умеет очищать дочерние плавающие элементы.
	
9 правил:
- Плавающие элементы прижимаются к границам своих контейнеров, но не дальше.
- Любой плавающий элемент будет находится либо рядом, либо ниже предыдущего элемента. Если элементы прижаты влево, второй элемент появится точно справа от первого. Если они прижаты вправо, второй элемент появится слева от первого (reverse).
- Элемент с левым обтеканием, не может быть правее, чем элемент с правым обтеканием.
- Плавающие элементы не могут подняться выше верхнего края родительского контейнера (однако становится еще сложнее, когда задействованы отступы).
- Плавающий элемент не может быть выше своего соседа плавающего элемента.
- Плавающий элемент не может быть выше своего соседа строчного элемента.
- Плавающий элемент совместно со своим таким же соседом элементом, не могут выходить за края родительского контейнера.
- Плавающий элемент должен быть помещен как можно выше.
- Элемент с левым обтеканием должен быть помещен как можно дальше влево, как это возможно, элемент с правым обтеканием должен быть помещен как можно дальше вправо, как это возможно.	
	
  **[⬆ Наверх](#top)**
	
519. ### <a name="519"></a> Что такое flexbox?

- Направлена на предоставление более эффективного способа выравнивания и распределения места между элементами в контейнере (родительском блоке), даже если их размер неизвестен или динамический.
- Основная идея flex-блоков, обладать способностью изменять свою ширина/высота (и другое), чтобы наилучшим образом заполнять свободное место (в основном, для поддержки адаптивности на всех видах устройств и размеров экрана).
- В основном элементы будут распределяться либо вдоль главной оси, либо вдоль поперечной оси контейнера.
- Flex-блоки лучше всего подходят для составных частей приложения и мелкомасштабных компонентов на странице, в то время как grid-блоки больше используется для компонентов на странице большого масштаба.
- Также как существует inline-block, inline-table, существует и inline-flex.	
	
  **[⬆ Наверх](#top)**	

520. ### <a name="520"></a> Как задать flexbox?

Для начала нам нужно выбрать, какие элементы следует выкладывать в виде flex блоков. Для этого мы устанавливаем специальное значение display в родительском элементе тех элементов, которые вы хотите оформить. display: flex;

Примечание: Вы также можете установить значение display inline-flex, если хотите расставить inline элементы как flex блоки.	
	
  **[⬆ Наверх](#top)**
	
521. ### <a name="521"></a> Какие оси есть в flexbox?

- Главная ось (main axis) проходит в том направлении, вдоль которого расположены Flex элемнеты (например, в строку слева направо или вдоль колонок вниз.) Начало и конец этой оси называются main start и main end.
- Поперечная ось (сross axis) проходит перпендикулярно Flex элементам. Начало и конец этой оси называются cross start and cross end.
- Родительский элемент, на который назначено свойство display: flex называется flex container.
- Элементы, размещённые в нём как Flex блоки называются flex items	
	
  **[⬆ Наверх](#top)**
	
522. ### <a name="522"></a> Какое свойство flexbox отвечает за направление flex items?

В Flexbox есть свойство под названием flex-direction, которое определяет направление главной оси (в каком направлении располагаются flexbox дети) — по умолчанию ему присваивается значение row, т.е. располагать дочерние элементы в ряд слева направо (для большинства языков) или справа налево (для арабских языков).

- row | row-reverse | column | column-reverse
- row Основная ось гибкого контейнера определяется так же, как направление текста. Основные начальные и конечные точки совпадают с направлением содержимого.
- row-reverse Ведет себя так же, как строка, но точки начала и конца меняются местами.
- column Главная ось гибкого контейнера такая же, как ось блока. Точки main-start и main-end такие же, как точки до и после режима записи.
- column-reverse Ведет себя так же, как column, но меняет местами main-start и main-end.	
	
  **[⬆ Наверх](#top)**
	
523. ### <a name="523"></a> Какое правило flexbox задает вывод flex items в одну строку или в несколько строк?

Свойство CSS flex-wrap

nowrap | wrap | wrap-reverse	
	
  **[⬆ Наверх](#top)**
	
524. ### <a name="524"></a> Как можно гибко изменять размеры flex элементов?

```js	
article {
  flex: 1 200px;
}

article:nth-of-type(3) {
  flex: 2 200px;
}
```	
Это просто означает, что каждому flex элементу сначала будет дано 200px от свободного места. Потом оставшееся место будет поделено в соответствии с частями пропорций.	
	
  **[⬆ Наверх](#top)**
	
525. ### <a name="525"></a> Расскажите про flex-grow, flex-shrink, flex-basis?

- Свойство CSS flex-grow определяет, какую часть свободного пространства может занять контейнер, в соотношении с другими контейнерами.
- flex-shrink — свойство CSS, которое определяет фактор сжатия flex-элемента. Flex-элементы будут заполнять контейнер в зависимости от значения flex-shrink, когда стандартная ширина flex-элементов шире, чем flex-контейнер.
- flex-basis CSS свойство задает базовые размеры флекс элемента, а именно ширину. Это свойство определяет размер содержимого контента, если оно не было заданно свойством box-sizing.	
	
  **[⬆ Наверх](#top)**
	
526. ### <a name="526"></a> Что такое css grid?

- Значение grid позволяет нам создавать макет сетки. Она направлена на решении проблем со старыми методами компоновки блоков, имеющих float и inline-block, которые в свою очередь имеют недостатки, и действительно не предназначались для макета страницы.
- Основная идея grid-концепции, управлять содержимым, обеспечивая механизм распределения имеющегося пространство блоков в столбцы и строки, с помощью набора заранее установленных размеров.
- Вместе с этим фактом мы можем устранить проблемы, которые появляются при разработке, опираясь на старую технику разработки сайтов, теперь вы тратите меньше усилий.
- Не поддерживается. Только в IE10+.
- Также как существует inline-block, inline-table, inline-flex, существует и inline-grid	
	
  **[⬆ Наверх](#top)**
	
527. ### <a name="527"></a> Можно ли использовать css grid и flexbox вместе?

Flexbox и Grid это не два противоборствующих свойства, они наоборот дополняют друг друга.

Grid - инструмент позиционирования основных блоков страницы.

Flexbox - инструмент позиционирования элементов внутри блоков, спозиционированных с помощью Grid.	
	
  **[⬆ Наверх](#top)**
	
528. ### <a name="528"></a> Объясните, как браузер определяет, на какие элементы накладывать CSS стили?

CSSOM (объектная модель CSS) — это объект, представляющий стили, связанные с DOM. Он выглядит так же как DOM, но с соответствующими стилями для каждого узла. Не имеет значения были ли стили объявлены явно или наследуются.	
	
  **[⬆ Наверх](#top)**
	
529. ### <a name="529"></a> Объясните, что такое псевдоэлементы и для чего они нужны.

Псевдоэлемент - это ключевое слово, добавляемое к селектору, которое позводяет стилизовать определенную часть выбранного элемента. Они могут использоваться для украшения (:first-line, :first-letter) или для добавления элементов к разметке (вместе c content: ...) без изменения HTML.	
	
  **[⬆ Наверх](#top)**
	
530. ### <a name="530"></a> Что делает * { box-sizing: border-box; }? В чём его преимущества?

По умолчанию все элементы имеют box-sizing: content-box. Размеры блока рассчитываются из размеров контента.

box-sizing: border-box меняет то, как расчитываются width и height. Border и padding включаются в расчёт. Высота будет состоять из: высота контента + вертикальные padding'и + ширина вертикальных border. Ширина будет состоять из: ширина контента + горизонтальные padding'и + ширина горизонтальных border.	
	
  **[⬆ Наверх](#top)**
	
531. ### <a name="531"></a> В чём разница между строчным и блочно-строчным элементом?

Для лучшего сравнения я добавил блочный элемент.

block

- Начинается с новой строки родительского элемента и занимает всю строку.
- Можно задавать ширину и высоту.
- Можно выровнять с помощью vertical-align.
- Margins и paddings работают со всех сторон.
	
inline-block

- Размер зависит от контента.
- Можно задавать ширину и высоту.
- Можно выровнять с помощью vertical-align.
- Margins и paddings работают со всех сторон.
	
inline

- Размер зависит от контента.
- Ширину и высоту задавать нельзя.
- Можно выровнять только по горизонтали. Место, которое занимает элемент по вертикали, зависит от line-height.
- Ведёт себя как блочный элемент, если задать вертикальные margins и paddings.	
	
  **[⬆ Наверх](#top)**
	
532. ### <a name="532"></a> Можете ли вы объяснить разницу между отзывчивым (responsive) сайтом и сайтом, сделанным по принципу mobile-first?

Отзывчивая и mobile-first верстки служат для того, чтобы пользователь мог пользоваться сайтом с разных устройств. Верстка подстраивается под различные размеры экрана, разрешения, контекст использования, механизмы контроля и т.д.

Отзывчивая верстка начинается с верстки десктопной версии сайта. Затем она адаптируется для меньших экранов.

Mobile-first начинается с верстки версии сайта для мобильных устройств.	
	
  **[⬆ Наверх](#top)**
	
533. ### <a name="533"></a> Свойства display - основные значения и как они работают

None, Block, Inline, Inline-block, Flex, Grid

Inline - элеменнты в одну строку и их размер завист от содержимого

Block - размеры определяются размерами самого блока задаными в стилях, но сам блок занимает всю свободную ширину экрана

Inline-block - элементы расположены в одну строку, но мы можем им задавать размер

Flex - можем управлять как угодно, это display flex

Grid - большая тема, смотрю видео

  **[⬆ Наверх](#top)**
	
534. ### <a name="534"></a> Keyframes для чего нужно и как использовать?

`Keyframes` - определяет ключевые кадры по которым будет работать анимация, указывается начальная точка и конечная, так же эти точки можно указывать в %. Ключевое слова animation.

  **[⬆ Наверх](#top)**
	
535. ### <a name="535"></a> 

  **[⬆ Наверх](#top)**
	
536. ### <a name="536"></a> 

  **[⬆ Наверх](#top)**	
