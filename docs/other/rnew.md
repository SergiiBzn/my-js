
<a name="top"></a>

[На главную](../README.md)

## Вопросы

[Перейти к вопросам](#questions)

| №. | Вопрос |
| --- | --------- |
|1 | [Ключевые концепции React, как React работает и преимущества и ограничения](#1) |
|2 | [Почему мы импортируем React, если не используем его?](#2) |
|3 | [React Fragments?](#3) |
|4 | ["Fiber" в библиотеке React?](#4) |
|5 | [VirtualDOM, в чем его профит?](#5) |
|6 | [Способы обновления компонента](#6) |
|7 | [Приоритезация в React.](#7) |
|8 | [Рекурсия по дочерним элементам](#8) |
|9 | [В чем разница между элементом, компонентом и экземпляром компонента?](#9) |
|10 | [Что такое `JSX` и как он помогает разрабатывать приложения?](#10) |
|11 | [Что такое `ReactDOM`? Разница между `ReactDOM` и `React`?](#11) |
|12 | [В чем разница между классовыми и функциональными компонентами?](#12) |
|13 | [](#13) |
|14 | [](#14) |
|15 | [](#15) |
|16 | [](#16) |
|17 | [](#17) |
|18 | [](#18) |
|19 | [](#19) |
|     | Core |
|51 | [](#51) |
|52 | [Для чего нужны props. Разница Props и State](#52)
|53 | [Props доступны только для чтения](#53) |
|54 | [Обратный поток данных](#54) |
|55 | [Props, пример кода](#55) |
|56 | [State в Классовых и Функциональных компонентах](#56) |
|57 | [state и setState, пример кода](#57) |
|58 | [Как работает setState](#58) |
|59 | [Методов жизненного цикла](#59) |
|60 | [Стадии жизненного цикла компонента](#60) |
|61 | [Устаревшие методы жизненного цикла](#61) |
|62 | [Статическая типизация в React](#62) |
|63 | [default Props](#63) |
|64 | [Prop types](#64) |
|65 | [React.memo, PureComponent, Component & shouldComponentUpdate](#65) |
|66 | [Зачем нужен ref](#66) |
|67 | [React.Context](#67) |
|68 | [Порталы в React](#68) |
|69 | [Условный рендеринг](#69) |
|70 | [Собственными обработчиками и Обработчиками в React](#70) |
|71 | [Потеря контекста](#71) |
|72 | [SyntheticEvent. Типы событий в React](#72) |
|73 | [События в React](#73) |
|74 | [Контролируемымие и Неконтролируемымие компоненты](#74) |
|75 | [Иммутабельность состояния и собственные события. Пример кода](#75) |
|76 | [Подъём состояния. Пример кода](#76) |
|77 | [Реализуем поиск и фильтры. Пример кода](#77) |
|78 | [Реализация кастомных форм](#78) |
|79 | [Всплытие событий](#79) |
|80 | [props.children](#80) |
|81 | [Hoisting - Поднятие](#81) |
|82 | [Context и useContext пример](#82) |
|83 | [Передать данные между компонентами React](#83) |
|84 | [Сетевые запросы](#84) |
|85 | [Pure component. Что такое "чистый" компонент?](#85) |
|86 | [](#86) |
|87 | [](#87) |
|88 | [](#88) |
|89 | [](#89) |
|90 | [](#90) |
|91 | [](#91) |
|     | Разное |
|150 | [Reselect и Recompose](#150) |
|151 | [Виртуализация](#151) |
|152 | [Параллельный режим](#152) |
|153 | [Динамический импорт](#153) |
|154 | [Tree shaking](#154) |  
|155 | [Service workers](#155) |
|156 | [ReactDOMServer](#156) |
|157 | [Гидратация](#157) |
|158 | [jest и enzyme](#158) |
|159 | [Тестировании shapshot](#159) |
|160 | [Тесты e2e. Отличие от юнит, интеграционные тесты](#160) |
|161 | [lazy imports, Suspense](#161) |
|162 | [Axios, Fetch](#162) |
|163 | [mock server](#163) |
|164 | [Websocket, Соединение через websocket в приложении.](#164) |
|165 | [Работа с запросами, AJAX](#165) |
|166 | [Предохранители, Error Boundary](#166) |
|167 | [SEO оптимизация, Helmet](#167) |
|168 | [Что такое batching](#168) |
|169 | [Принцип конечного автомата, FSM, Finite-state machine](#169) |
|170 | [](#170) |
|     | Core |
|250 | [Рекурсия для дочерних компонентов](#250) |
|251 | [Что такое предохранители (error boundaries)?](#251) |
|252 | [keys в React. Метод жизненного цикла shouldComponentUpdate](#252) |
|253 | [react-router v5](#253) |
|254 | [Route, Switch, Link v5](#254) |
|255 | [react-router v6](#255) |
|256 | [](#256) |
|257 | [React / redux Dev Tools](#257) |
|258 | [HOC - Компонент высшего порядка](#258) |
|259 | [React Transition Group](#259) |
|260 | [Formik, Yup - работа с формами](#260) |
|261 | [](#261) |
|     | Хуки |
|300 | [Хуки в React](#300) |
|301 | [Методы жизненного цикла может заменить Хуки](#301) |
|302 | [Хуки](#302) |
|303 | [Хуки практика](#303) |
|304 | [Создание собственных хуков](#304) |
|305 | [Практика создание собственных хуков](#305) |
|306 | [](#306) |
|307 | [](#307) |
|308 | [](#308) |
|309 | [](#309) |
|310 | [](#310) |
|320 | [](#320) |
|321 | [](#321) |
|322 | [](#322) |
|323 | [](#323) |
|324 | [](#324) |
|325 | [configureStore(), createReducer(), createAction(), createSlice(), createAsyncThunk(), createEntityAdapter()](#325) |
|326 | [](#326) |
|327 | [](#327) |
|328 | [](#328) |
|329 | [](#329) |
|     | Redux Toolkit |
|330 | [Redux Toolkit: configureStore()](#330) |
|331 | [Redux Toolkit: createAction()](#331) |
|332 | [Redux Toolkit: createReducer()](#332) |
|333 | [Redux Toolkit: createSlice()](#333) |
|334 | [Redux Toolkit: createAsyncThunk()](#334) |
|335 | [Redux Toolkit: createEntityAdapter()](#335) |
|336 | [Redux Toolkit: RTK Query](#336) |
|337 | [](#337) |
|338 | [Redux Toolkit пример](#338) |
|339 | [Redux Toolkit пример 2](#339) |
|340 | [Redux Toolkit createAsyncThunk](#340) |
|341 | [RTK Query](#341) |
|342 | [](#342) |
|343 | [](#343) |
|344 | [](#344) |
|345 | [](#345) |
|346 | [](#346) |
|347 | [](#347) |
|     | Redux |
|350 | [Redux](#350) |
|351 | [connect. HOC](#351) |
|352 | [actions](#352) |
|353 | [reducer](#353) |
|354 | [middleware](#354) |
|355 | [Redux, Actions, Reducer, Store - примеры](#355) |
|356 | [redux-forms в экосистеме React + Redux](#356) |
|357 | [Redux пример](#357) |
|358 | [Соединяем React и Redux при помощи connect и хуков](#358) |
|359 | [combineReducers и reducers](#359) |
|360 | [createSelector from 'reselect'](#360) |
|361 | [enhancer](#361) |
|362 | [applyMiddleware](#362) |
|363 | [ReduxThunk](#363) |
|364 | [](#364) |
|365 | [](#365) |
|377 | [](#377) |
|378 | [](#378) |
|379 | [](#379) |
|380 | [](#380) |
|381 | [](#381) |



<a name="questions"></a> 

## Ключевые концепции React

1. ### <a name="1"></a> Ключевые концепции React, как React работает и преимущества и ограничения

`React` это открытая (с открытым исходным кодом) JavaScript-библиотека для фронтенда, предназначенная для создания пользовательских интерфейсов, особенно, если речь идет о создании одностраничного приложения.

`React` - это `JavaScript-библиотека`, предназначенная для создания быстрых и интерактивных пользовательских интерфейсов (user interfaces, UI) для веб- и мобильных приложений. Это открытая (с открытым исходным кодом), основанная на компонентах, библиотека для фронтенда, отвечающая только за слой представления (view) приложения.

Основная задача `React` - разработка быстрых пользовательских интерфейсов. В нем используется виртуальная объектная модель документа (virtual document object model (DOM) - программный интерфейс приложения (application programming interface (API)), для `HTML` и `XML-документов`. Он определяет логическую структуру документа, способы доступа к документу и управления им. Виртуальный `DOM` - это `JavaScript-объект`, что повышает производительность приложения. Виртуальный `DOM` быстрее обычного (браузерного, реального или настоящего). Мы можем использовать `React` как на стороне клиента, так и на стороне сервера, а также вместе с другими фреймворками. В нем используются компоненты и различные паттерны проектирования для работы с данными, что улучшает читаемость кода и облегчает поддержку больших приложений.

## Как `React` работает?

Разрабатывая клиентские приложения, команда разработчиков `Facebook` осознала, что `DOM` является медленным. Для того, чтобы сделать его быстрее, `React` использует виртуальный `DOM`, который, по сути, является представлением `DOM-дерева` в `JavaScript`. Когда возникает необходимость чтения или записи в `DOM`, используется данное представление. Затем виртуальный `DOM` пытается определить наиболее эффективный способ обновления реального `DOM`.

В отличие от `DOM-элементов` браузера, создание элементов в `React` обходится гораздо дешевле (с точки зрения производительности). Виртуальный `DOM` заботится об обновлении настоящего для полного совпадения с `React-элементами`. Это объясняется тем, что `JavaScript` очень быстрый, и хранение `DOM-дерева` в виде объекта ускоряет модификацию последнего.

## Основными особенностями React является следующее:

1. Использование *VirtualDOM* (виртуальной объектной модели документа) вместо *RealDOM* (настоящий или реальный DOM), поскольку манипуляции с *RealDOM* являются дорогостоящими с точки зрения производительности
2. Поддержка *рендеринга на стороне сервера* (Server Side Rendering, SSR)
3. Следование принципу *однонаправленного* потока или связывания данных
4. Использование *переиспользуемых/компонуемых* компонентов пользовательского интерфейса (User Interface, UI) для формирования слоя представления

Мы используем библиотеку React DOM в главном файле, index.js мы импортируем библиотеку React DOM и для того что бы запустить все приложение я обращаюсь к библиотеке React DOM и вызываю у нее метод render(), где рендерится компонент <App />, и дальше складывает его в тот div с id='root' который находится в нашем html файле.
    
```jsx harmony    
import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';

ReactDOM.render(<App />, document.getElementById('root'));    
```

## Назовите преимущества и ограничения `React`

![React Features](./assets/img2/react-features.png)

_Преимущества_

- Использование виртуального `DOM` для определения того, какие части `UI` подверглись изменениям, и повторный рендеринг только этих частей в реальном `DOM` существенно повышают производительность приложения.
- `JSX` (`JavaScript` и `XML`) делает код компонентов/блоков более читаемым. Он отчетливо показывает, как компоненты связаны (скомбинированы) между собой.
- Связывание данных в `React` предоставляет хорошие условия для создания динамичных приложений.
- Быстрый рендеринг. Использование встроенных методов для минимизации количества операций с `DOM` помогает оптимизировать и ускорить процесс обновления компонентов.
- Тестируемость. `React` предоставляет отличные встроенные инструменты для тестирования и отладки кода.
- Дружелюбность по отношению к `SEO` (search engine optimization - поисковая оптимизация). `React` предоставляет возможность рендеринга страниц на стороне сервера и регистрации обработчиков событий на стороне клиента:
  _ `React.renderToString()` вызывается на сервере;
  _ `React.render()` вызывается на клиенте;
  _ `React` сохраняет разметку, сгенерированную на сервере, и добавляет к ней обработчики событий.

_Ограничения_

- Кривая обучения. Будучи библиотекой, а не полноценным фреймворком, `React` требует глубоких знаний по внедрению `UI` во фреймворки `MVC` (Model-View-Controller - Модель-Представление-Контроллер).
- Одним из недостатков `React` также является ориентированность на слой представления. Для решения проблем "Представления" требуется поиск подходящей "Модели" и "Контроллера".
- Разработка приложения без использования изоморфного подхода приводит к проблемам с индексацией приложения поисковыми роботами (речь идет о том, что одностраничные приложения (`SPA`) индексируются хуже статических).

  **[⬆ Наверх](#top)**

2. ### <a name="2"></a> Почему мы импортируем React, и не используем его?	
	
Без этого импорта компоненты не будут работать, на этапе сборки оно нам понадобится в случае если будем использовать JSX в данном файле.
	
Для того что бы Babel смиог перевести JSX в обычный JavaScript ему всегда необходим React. Именно для этого мы подключаем каждый раз эту библиотеку.
	
Нам нужен React для того что бы понять JSX, там где есть хоть одна строка JSX - необходимо импортировать React.
    
*JSX* (JavaScript и XML) - это XML-подобный синтаксис, расширяющий возможности ECMAScript. По сути, он является синтаксическим сахаром для функции `React.createElement()`, совмещая выразительность JavaScript с HTML-подобным синтаксисом разметки.

В приведенном ниже примере, текст внутри тега `h1` в методе `render()` возвращается в виде JavaScript-функции:

```jsx harmony
    class App extends React.Component {
      render() {
        return (
          <div>
            <h1>{'Добро пожаловать в мир React!'}</h1>
          </div>
        )
      }
    }
```    

  **[⬆ Наверх](#top)**

3. ### <a name="3"></a> React Fragments

Это распространенный паттерн в React, который используется в компонентах, возвращающих несколько элементов. *Fragments* позволяют группировать дочерние элементы без создания лишних DOM-узлов:

```jsx harmony
    render() {
      return (
        <React.Fragment>
          <ChildA />
          <ChildB />
          <ChildC />
        </React.Fragment>
      )
    }
```

Также существует *сокращенный синтаксис*, но он не поддерживается в некоторых инструментах:

```jsx harmony
    render() {
      return (
        <>
          <ChildA />
          <ChildB />
          <ChildC />
        </>
      )
    }
```

  **[⬆ Наверх](#top)**

4. ### <a name="4"></a> "Fiber" в библиотеке React

`React Fiber` (волокно) - это новый **алгоритм согласования**. `Согласование` - это процесс сравнения старого и нового деревьев элементов для определения различий между ними. В старом алгоритме (который теперь называют **стековым согласованием (stack reconciler)**) сравнение проводилось синхронно, поэтому основной поток выполнения программы был недоступен для других частей UI, таких как анимация, формирование макета страницы и обработка жестов. Fiber Reconciler преследует такие цели, как:

* Возможность разделения операций на части
* Возможность задавать приоритеты, перемещать и повторно запускать операции в ходе их выполнения
* Возможность переключаться между предками и потомками в интересах "макетирования"
* Возможность возвращать несколько React-элементов из `ReactDOM.render()`.

Волокно - это JavaScript-объект, содержащий информацию о компоненте, его входных и выходных данных. Экземпляр компонента имеет два связанных с ним волокна: текущее и формирующееся. Волокно может определяться в виде единичной операции.

*React Fiber* — прогрессивная реализация ключевого алгоритма React. Это кульминационное достижение двухгодичных исследований команды разработчиков React.

Цель Fiber в увеличении производительности при разработке таких задач как анимация, организация элементов на странице и движение элементов. Ее главная особенность это инкрементный рендеринг: способность разделять работу рендера на единицы и распределять их между множественными фреймами.
	
Что такое сверка (reconciliation)?

`Сверка` — это алгоритм React, используемый для того, чтобы отличить одно дерево елементов от другого для определения частей, которые нужно будет заменить.

`Апдейт` — это изменение в данных, которые используются для отрисовки React приложения. Обычно это результат вызова метода setState; конечный результат отрисовки компонента.

Ключевая идея React API — мыслить об апдейтах так, если бы они могли привести к полной отрисовке приложения. Это позволяет разработчику действовать декларативно, а не переживать о том насколько рациональным будет переход приложения из одного состояния в другое (от А до B, B до С, С до A и тд.).

В целом, отрисовка всего приложения на каждое изменение работает только в наиболее традиционных приложениях. В реальном мире это негативно сказывается на производительности. Реакт влючает в себя оптимизации, которые создают представление полной отрисовки, не затрагивая огромную долю производительности. Большую часть этих оптимизаций и включает в себя процесс, называемый сверка.

`Сверка` — это алгоритм, за которым стоит то, что мы привыкли называть «Virtual DOM». Определение звучит как-то так: когда вы рендерите React приложение, дерево елементов, которое описывает приложение генерируется в зарезервированной памяти. Это дерево потом включается в рендеринг окружение — на примере браузерного приложения, оно переводится в набор DOM операций. Когда состояние приложения обновляется (обычно вызовом setState), новое дерево генерируется. Новое дерево сравнивается с предыдущим, чтоб просчитать и включить именно те операции, которые нужны для перерисовки обновленного приложения.
		
	
*Fiber* (волокно) - это новый движок *согласования*, изменение основного алгоритма в React 16. Основной задачей React Fiber является повышения производительности в таких областях, как анимация, создание макета страницы, обработка жестов, возможность приостанавливать, прерывать или повторно запускать выполнение операций, предоставление приоритета определенным типам обновлений, а также новые примитивы параллелизма.
    
Цель *React Fiber* - повышение производительности в таких областях, как анимация, создание макета страницы и обработка жестов. Основной его особенностью является *incremental rendering* (инкрементальный рендеринг, используется Angular): возможность разделения процесса рендеринга на части и их объединение через различные фреймы.

Основная цель которого сделать рендеринг виртуального DOM инкрементным.      

  **[⬆ Наверх](#top)**
  
5. ### <a name="5"></a> Virtual DOM, в чем его профит?

## Виртуальный `DOM` является более эффективным, чем "грязная" проверка?

_Виртуальный `DOM`_

В `React` при каждом обновлении `DOM` или изменении данных, используемых страницей, создается новое объектное представление пользовательского интерфейса. Это всего лишь легковесная копия `DOM`.

Виртуальный `DOM` имеет почти такие же свойства, что и настоящий `DOM`, но он не может напрямую модифицировать содержимое (контент) страницы. Манипуляции с виртуальным `DOM` быстрее, поскольку он ничего не обновляет на экране. Простыми словами, работа с виртуальным `DOM` - это работа с копией реального `DOM`, не более того.

Обновление виртуального `DOM` быстрее благодаря следующему:

1. Использованию эффективного алгоритма определения различий (DOM diffing).
2. Совмещению (группировке, объединению) операций по обновлению.
3. Оптимизированному обновлению поддеревьев.
4. Использованию наблюдаемых (`observable`) объектов для определения изменений вместо "грязной" проверки (dirty check).

_Как работает виртуальный `DOM`_

При рендеринге `JSX-элемента` обновляется виртуальный `DOM`. Это происходит очень быстро. После обновления новая версия виртуального `DOM` сравнивается со старой (снимком (snapshot), выполненным перед обновлением). После этого, `React` определяет отличия между двумя объектами. Данный процесс называется _diffing_ (определение различий).

Затем `React` обновляет только те части настоящего `DOM`, которые подверглись изменениям. За счет этого `React` очень сильно выигрывает в производительности.

Если кратко, то вот что происходит при обновлении `DOM` в `React`:

1. Обновляется виртуальный `DOM`.
2. Обновленный виртуальный `DOM` сравнивается с предыдущим.
3. Определяются различия между версиями виртуального `DOM`.
4. Обновляются только изменившиеся элементы реального `DOM`.
5. Изменения отображаются на экране.


## smt

В React для каждого объекта настоящего DOM (далее — RDOM) существует соответствующий объект VDOM. VDOM — это объектное представление RDOM, его легковесная копия. VDOM содержит те же свойства, что и RDOM, но не может напрямую влиять на то, что отображается на экране.

Виртуальный DOM (VDOM) — это концепция программирования, в которой идеальное или «виртуальное» представление пользовательского интерфейса хранится в памяти и синхронизируется с «настоящим» DOM при помощи библиотеки, такой как ReactDOM. Этот процесс называется согласованием.

Такой подход и делает API React декларативным: вы указываете, в каком состоянии должен находиться пользовательский интерфейс, а React добивается, чтобы DOM соответствовал этому состоянию. Это абстрагирует манипуляции с атрибутами, обработку событий и ручное обновление DOM, которые в противном случае пришлось бы использовать при разработке приложения.

Поскольку «виртуальный DOM» — это скорее паттерн, чем конкретная технология, этим термином иногда обозначают разные понятия. В мире React «виртуальный DOM» обычно ассоциируется с React-элементами , поскольку они являются объектами, представляющими пользовательский интерфейс. Тем не менее, React также использует внутренние объекты, называемые «волокнами» (fibers), чтобы хранить дополнительную информацию о дереве компонентов. Их также можно считать частью реализации «виртуального DOM» в React. 
 
 
Как React использует VDOM?

1. React использует паттерн проектирования «Наблюдатель» (observer) и реагирует на изменения состояния

В React каждая часть UI является компонентом и почти каждый компонент имеет состояние (state). При изменении состояния компонента, React обновляет VDOM. После обновления VDOM, React сравнивает его текущую версию с предыдущей. Этот процесс называется «поиском различий» (diffing).

После обнаружения объектов, изменившихся в VDOM, React обновляет соответствующие объекты в RDOM. Это существенно повышает производительность по сравнению с прямыми манипуляциями DOM. Именно это делает React высокопроизводительной библиотекой JavaScript.

2. React использует механизм пакетного (batch) обновления RDOM

Это также положительно влияет на производительность. Названный механизм предполагает отправку обновлений в виде пакетов (набора, серии) вместо отправки отдельного обновления при каждом изменении состояния.

Повторная отрисовка UI — самая затратная часть, React обеспечивает точечную и групповую перерисовку RDOM.

3. React использует эффективный алгоритм поиска различий

React использует эвристический O(n) (линейный) алгоритм, основываясь на двух предположениях:

Два элемента разных типов приводят к построению разных деревьев

Разработчик может обеспечить стабильность элементов между рендерингами посредством пропа key (ключ)

На практике эти предположения являются верными почти во всех случаях.

При сравнении двух деревьев, React начинает с корневых элементов. Дальнейшие операции зависят от типов этих элементов.

Элементы разных типов

Если корневые элементы имеют разные типы, React уничтожает старое дерево и строит новое с нуля

Вместе со старым деревом уничтожаются все старые узлы DOM. Экземпляры компонента получают componentWillUnmount(). При построении нового дерева, новые узлы DOM встраиваются в DOM. Экземпляры компонента получают сначала UNSAFE_componentWillMount(), затем componentDidMount(). Любое состояние, связанное со старым деревом, утрачивается

Любые компоненты, являющиеся дочерними по отношению к корневому, размонтируются, их состояние уничтожается. Например, при сравнении:
```js
<div>

 <Counter />

</div>

<span>

 <Counter />

</span>
```

Старый Counter будет уничтожен и создан заново.


4. Элементы одинакового типа

При сравнении двух элементов одинакового типа, React «смотрит» на атрибуты этих элементов. Узлы DOM сохраняются, изменяются только их атрибуты. Например:

```js
<div className="before" title="stuff" />

<div className="after" title="stuff" />
```

После сравнения этих элементов будет обновлен только атрибут className.

После обработки узла DOM, React рекурсивно перебирает всех его потомков.


5. Рекурсивный перебор дочерних элементов

По умолчанию React перебирает два списка дочерних элементов DOM-узла и генерирует мутацию при обнаружении различий.

Например, при добавлении элемента в конец списка дочерних элементов, преобразование одного дерева в другое работает хорошо:
```jsx harmony
<ul>

 <li>первый</li>

 <li>второй</li>

</ul>

<ul>

 <li>первый</li>

 <li>второй</li>

 <li>третий</li>

</ul>
```

React "видит", что в обоих деревьях имеются <li первый</li и <li второй</li, пропускает их и вставляет в конец <li третий</li.


Обычно, вставка элемента в начало списка плохо влияет на производительность. Например, преобразование одного дерева в другое в данном случае будет работать плохо:

```jsx harmony
<ul>

 <li>первый</li>

 <li>второй</li>

</ul>
<ul>

 <li>нулевой</li>

 <li>первый</li>

 <li>второй</li>

</ul>
```
React не сможет понять, что <li первый</li и <li второй</li  остались прежними и мутирует каждый элемент.


6. Использование ключей

Для решения данной проблемы React предоставляет атрибут (проп) key. Когда дочерние элементы имеют ключи, React использует их для сравнения потомков текущего и предыдущего узлов. Например, добавление ключей к элементам из последнего примера сделает преобразование деревьев намного более эффективным:

```jsx harmony
<ul>

 <li key="1">первый</li>

 <li key="2">второй</li>

</ul>
<ul>

 <li key="0">нулевой</li>

 <li key="1">первый</li>

 <li key="2">второй</li>

</ul>
```
Теперь React знает, что элемент с ключом 0 является новым, а элементы с ключами 1 и 2 старыми.


На практике в качестве ключей, как правило, используются идентификаторы:

```jsx harmony
<li key={item.id}>{item.name}</li>
```

При отсутствии идентификаторов, их всегда можно добавить в модель данных или создать хэш на основе какой-либо части данных. Ключи должны быть уникальными среди соседних элементов, а не глобально.

В крайнем случае, в качестве ключей можно использовать индексы массива. Это работает хорошо только в том случае, если порядок элементов остается неизменным. Изменение порядка элементов будет медленным.

Изменение порядка элементов при использовании индексов в качестве ключей также может привести к проблемам с состоянием элементов. Экземпляры компонента обновляются и повторно используются на основе ключей. Если ключом является индекс, перемещение элемента приведет к изменению ключа. Как результат, состояние компонента для таких вещей, как неуправляемое поле для ввода данных, может смешаться и обновиться неожиданным образом.
 
  **[⬆ Наверх](#top)**
 
6. ### <a name="6"></a> Способы обновления компонента 

###  Повторный рендеринг родителя, который может повлечь за собой новые пропсы


### setState
```jsx harmony 
setState(updater, [callback])
```
setState() добавляет в очередь изменения в состоянии компонента. Также он указывает React, что компонент и его дочерние элементы должны быть повторно отрендерены с обновлённым состоянием. Этот метод используется для обновления интерфейса в ответ на обработчики событий и ответы сервера.

Думайте о setState(), как о запросе, а не как о команде немедленного обновления компонента. Для увеличения производительности React может задержать его выполнение, а затем обновить несколько компонентов за один проход. React не гарантирует моментальное применение изменений в состоянии.

Метод setState() не всегда обновляет компонент сразу. Он может группировать или откладывать обновление до следующего раза. Это делает чтение this.state сразу после вызова setState() потенциальной ловушкой. Вместо этого используйте componentDidUpdate() или колбэк setState() (setState(updater, callback)), каждый из которых гарантированно вызывается после того как было применено обновление. Если вам нужно обновить состояние на основе предыдущего, используйте аргумент updater, описанный ниже.

setState() всегда приводит к повторному рендеру, если только shouldComponentUpdate() не возвращает false. Если используются мутабельные объекты, и условие рендеринга не может быть реализовано в shouldComponentUpdate(), вызывайте setState() только при разнице следующего и предыдущего состояния. Это предотвратит ненужные повторные рендеры.

Первым аргументом передаётся функция updater, которая имеет следующий вид:

(state, props) => stateChange
state — ссылка на состояние компонента при изменении. Объект состояния не должен мутировать. Изменения должны проявляться в виде нового объекта на основе входных данных из state и props. Предположим, что мы хотели бы увеличить значение состояния с помощью props.step:

this.setState((state, props) => {
  return {counter: state.counter + props.step};
});
Как state, так и props, полученные функцией обновления, гарантированно будут обновлены. Результат функции поверхностно объединяется с state.

Второй параметр в setState() — необязательный колбэк, вызываемый после выполнения setState и повторного рендера компонента. Вместо этого в большинстве случаев для такой логики мы рекомендуем использовать componentDidUpdate(). 

### forceUpdate()
```jsx harmony
component.forceUpdate(callback)
```
По умолчанию при изменении состояния компонента или пропсов, происходит повторный рендер. Если ваш метод render() зависит от некоторых других данных, вы можете указать React необходимость в повторном рендере, вызвав forceUpdate().

Вызов forceUpdate() приведёт к выполнению метода render() в компоненте, пропуская shouldComponentUpdate(). Это вызовет обычные методы жизненного цикла для дочерних компонентов, включая shouldComponentUpdate() каждого дочернего компонента. React по-прежнему будет обновлять DOM только в случае изменения разметки.

Чаще всего, forceUpdate() не используется. Вместо этого используются в render() данные из this.props и this.state.

  **[⬆ Наверх](#top)** 
 
 
7. ### <a name="7"></a> Приоритезация в React

Мы хотим что бы приложение не лагало, ожидая 60 кадров в секунду, для плавной картинки, а ждя этого нужно обновлять кадры каждые 16 мс, теперь представте что пользователь внес обновления интерфейса на 240 мс, что бы это все не начало лагать команда React core решила разбить обновление интерфейса на более мелкие операции, так называемые юниты и и приоритезировала их, ведб hover анимация кнопки кажется более приоритетной задачей чем обновление данных в блоке который даже не во вьюпорте находится в данный момент. Поэтому React отсортировал задач за нас и в первых кадрах показал анимацию а в ближайшее свободное время занялся данными которые были ни к спеху.
    
Для реализации этой логики команда React использует две функции: 

- window.requestAnimationFrame(callback); - для более приоритетных задач, которые уже нужно выполнять буквально на следующем кадре а так же: 
- window.requestIdleCallback(callback[, options]); - для низкоприоритетных задач, которые можно выполннить во время простоя приложения
    
 Основная сложность это расстаавить приоритеты этим мелким Dom операциям, есть приоритеты от 0 до 5, низкий, нормальный, высокий... - такого рода задачи выполняются во время простоя сайта, все это позволяет определить порядок выполнения DOM оперций 
 
    
  **[⬆ Наверх](#top)**

8. ### <a name="8"></a> Рекурсия по дочерним элементам

По умолчанию при рекурсивном обходе дочерних элементов DOM-узла React проходит по обоим спискам потомков одновременно и создаёт мутацию, когда находит отличие.

Например, при добавлении элемента в конец дочерних элементов, преобразование между этими деревьями работает отлично:
```jsx harmony
<ul>
  <li>первый</li>
  <li>второй</li>
</ul>

<ul>
  <li>первый</li>
  <li>второй</li>
  <li>третий</li>
</ul>
```    
React сравнит два дерева первый, сравнит два дерева второй, а затем вставит дерево третий.

Если попробовать реализовать это наивно, вставив элемент в начало, то пострадает производительность. Например, преобразование между этими деревьями работает плохо:
```jsx harmony
<ul>
  <li>Санкт-Петербург</li>
  <li>Москва</li>
</ul>

<ul>
  <li>Ростов-на-Дону</li>
  <li>Санкт-Петербург</li>
  <li>Москва</li>
</ul>
```    
React будет мутировать каждого потомка, вместо того чтобы оставить Санкт-Петербург  и Москва нетронутыми. Эта неэффективность может стать проблемой.

`Ключи`
    
Для решения этой проблемы React поддерживает атрибут key. Когда у дочерних элементов есть ключи, React использует их, чтобы сопоставить потомков исходного дерева с потомками последующего дерева. Например, если добавить key к неэффективному примеру выше, преобразование дерева станет эффективным:
```jsx harmony
<ul>
  <li key="2015">Санкт-Петербург</li>
  <li key="2016">Москва</li>
</ul>

<ul>
  <li key="2014">Ростов-на-Дону</li>
  <li key="2015">Санкт-Петербург</li>
  <li key="2016">Москва</li>
</ul>
```    
Теперь React знает, что элемент с ключом '2014' — новый, а элементы с ключами '2015' и '2016' только что переместились.

На практике найти ключ обычно несложно. Элемент, который вы хотите отобразить, уже может иметь уникальный идентификатор, и ключ может быть взят из ваших данных:
```jsx harmony
<li key={item.id}>{item.name}</li>
```	
Когда уникальное значение отсутствует, вы можете добавить новое свойство идентификатора в вашу модель или прохешировать данные, чтобы сгенерировать ключ. Ключ должен быть уникальным только среди его соседей, а не глобально.

В крайнем случае вы можете передать индекс элемента массива в качестве ключа. Это работает хорошо в случае, если элементы никогда не меняют порядок. Перестановки элементов вызывают замедление.

  **[⬆ Наверх](#top)**

9. ### <a name="9"></a> В чем разница между элементом, компонентом и экземпляром компонента?

В чем разница между элементом, компонентом и экземпляром компонента?***

Компонент - это шаблон. Проект или схема (blueprint). Глобальное определение. Он может быть функцией или классом (с методом рендеринга).

Элемент - это то, что возвращается из компонента. Это объект, описывающий виртуальное представление определенного узла DOM, содержащегося в компоненте. В случае с функциональными компонентами, указанный объект возвращается функцией. В классовых компонентах объект возвращается методом `render()`. Элементы React - это не то, что мы видим в браузере. Это всего лишь объекты, хранящиеся в памяти, мы не можем их изменять.

*Пример*

```js
import React from 'react'
import ReactDOM from 'react-dom'
import './index.css'

class MyComponent extends React.Component {
  constructor(props) {
    super(props)
    console.log('Это экземпляр компонента:', this)
  }

  render() {
    const another_element = <div>Привет, народ!</div>
    console.log('Это элемент:', another_element)
    return another_element
  }
}

console.log('Это компонент:', MyComponent)

const element = <MyComponent/>

console.log('Это элемент:', element)

ReactDOM.render(
  element,
  document.getElementById('root')
)
```

**Элементы React**

Элемент - это обычный JavaScript-объект с определенными методами. Он имеет 4 свойства:

* `type` - строковое представление HTML-тега или ссылка на React-компонент
* `key` - строка-идентификатор React-элемента
* `ref` - ссылка на нижележащий узел DOM или экземпляр компонента React
* `props` - объект со свойствами

Элемент - это не экземпляр React-компонента. Это всего лишь упрощенное "описание" того, как должен выглядеть экземпляр компонента (или тег HTML).

Элемент, описывающий компонент, "не знает", в каком DOM-узле он будет отрендерен - эта связь абстрагирована и определяется в процессе рендеринга.

Элементы могут иметь потомков. Это предоставляет возможность формирования деревьев элементов, представляющих виртуальное деверо DOM.

**React-компоненты и их экземпляры**

Пользовательские компоненты создаются с помощью `React.createClass()` или путем расширения `React.Component` (ES2015). В процессе инстанцирования компонент ожидает получить объект со свойствами и возвращает экземпляр.

Компонент может иметь *состояние*, ему доступны *методы жизненного цикла*. Он обязательно должен иметь метод `render()`, возвращающий элемент React (дерево элементов). Обратите внимание, что вы никогда не создаете экземпляры самостоятельно, это делает React.

  **[⬆ Наверх](#top)**

10. ### <a name="10"></a> Что такое `JSX` и как он помогает разрабатывать приложения?

`JSX` позволяет создавать `HTML-элементы` прямо в `JavaScript` и помещать их в `DOM` без использования таких методов, как `createElement` или `appendChild`. `JSX` преобразует `HTML-теги` в элементы `React`. `React` использует `JSX` для шаблонизации вместо обычного `JavaScript`. Использовать `JSX` не обязательно, однако он предоставляет несколько преимуществ:

- Он быстрее благодаря оптимизации во время компиляции кода в `JavaScript`.
- Он также является "типобезопасным", большинство ошибок перехватываются во время компиляции.
- Он позволяет легче и быстрее создавать шаблоны.

```jsx
import React from 'react'

class App extends React.Component {
   render() {
      return (
        <div>
          Привет, народ!
        </div>
      )
   }
}
export default App
```

`JSX` - это выражения `JavaScript`. `JSX-выражения` являются валидными `JavaScript-выражениями`. После компиляции, они становятся обычными объектами. Например, такой код:

```jsx
const hello = <h1 className = "greet"> Привет, народ!</h1>
```

Компилируется в такой:

```jsx
const hello = React.createElement {
  type: "h1",
  props: {
    className: "greet",
    children: "Привет, народ!"
  }
}
```

Поскольку `JSX` компилируется в объекты, он может использоваться наравне с обычными выражениями `JavaScript`.

  **[⬆ Наверх](#top)**

11. ### <a name="11"></a> Что такое `ReactDOM`? Разница между `ReactDOM` и `React`?

`ReactDOM` - это пакет (package), предоставляющий специфичные для браузера методы, которые могут быть использованы на верхнем уровне приложения для эффективного управления `DOM-элементами`, имеющимися на странице. `ReactDOM` предоставляет в распоряжение разработчиков следующие методы:

- `render`.
- `findDOMNode`.
- `unmountComponentAtNode`.
- `hydrate`.
- `createPortal` и др.

До версии `0.14` `ReactDOM` был частью `React`. Одной из главных причин разделения `React` и `ReactDOM` было появление `React Native`. `React` содержит функционал, используемый в веб- и мобильных приложениях. Функционал `ReactDOM` используется только в веб-приложениях.

`ReactDOM` использует наблюдаемые (`observables`) объекты, которые предоставляют эффективный способ работы с `DOM`. `ReactDOM` может использоваться как на стороне клиента, так и на стороне сервера.

```jsx
// index.js
import React from 'react'
import ReactDOM from 'react-dom'
import App from './App/App'

ReactDOM.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
  document.getElementById('root')
)
```

Для того, чтобы иметь возможность использовать `ReactDOM` в веб-приложении, написанном на `React`, мы, прежде всего, должны его импортировать из  `react-dom`:

```jsx
import ReactDOM from 'react-dom'
```

`ReactDOM.render()`

Эта функция используется для рендеринга отдельного компонента `React` или нескольких компонентов, обернутых в другой компонент, фрагмент (fragment) или контейнер `div`. Данная функция использует эффективные методы `React` для обновления `DOM`, имея возможность обновлять только те части `DOM`, которые подверглись изменениям. Функция возвращает ссылку на компонент или `null`, если был отрендерен компонент без состояния.

`ReactDOM.render()` удаляет всех потомков переданного контейнера, если таковые имеются. Он использует высокоэффективный алгоритм сравнения и способен модифицировать любое поддерево `DOM`:

```jsx
ReactDOM.render(element, container, callback)
```

- _element_: `JSX-выражение` или `React-элемент` (компонент), который должен быть отрендерен;
- _container_: контейнер (`HTML-элемент`), в котором должен быть отрисован компонент;
- _callback_: опциональный параметр - функция, вызываемая после завершения рендеринга.

`findDOMNode()`

Эта функция, обычно, используется для получения узла `DOM`, в котором был отрендерен некоторый компонент. Данный метод используется редко, поскольку тоже самое можно сделать с помощью атрибута `ref` (ссылка, реф), добавленного к компоненту.

`findDOMNode()` может быть реализован только в отношении смонтированных компонентов, поэтому функциональные компоненты не могут его использовать:

```jsx
ReactDOM.findDOMNode(component)
```

Данный метод принимает один параметр - компонент, поиск которого осуществляется в `DOM`. Функция возвращает `DOM-узел`, в котором был отрисован компонент (в случае успеха) или `null`.

`unmountComponentAtNode()`

Эта функция используется для размонтирования и удаления `React-компонента`, который был отрендерен в определенном контейнере:

```jsx
ReactDOM.unmountComponentAtNode(container)
```

Данный метод принимает единственный параметр - узел `DOM`, из которого должен быть удален компонент. Функция возвращает `true` в случае успеха, или `false` в противном случае.

`hydrate()`

Эта функция эквивалентна методу `render`, но используется при рендеринге на стороне сервера:

```jsx
ReactDOM.hydrate(element, container, callback)
```

- _element_: `JSX-выражение` или компонент `React`, который должен быть отрендерен;
- _container_: контейнер (`HTML-элемент`), в котором должен быть отрисован компонент;
- _callback_: опциональный параметр - функция, вызываемая после завершения рендеринга.

Данная функция пытается зарегистрировать обработчики событий для существующей разметки и возвращает ссылку на компонент или `null` в случае рендеринга компонента без состояния.

`createPortal()`

Обычно, когда элемент возвращается из метода `render` компонента, он монтируется в `DOM` как потомок ближайшего родительского узла, что в некоторых случаях является нежелательным. Порталы (portals) позволяют  рендерить компонент в узле `DOM`, который находится за пределами текущего дерева `DOM` родительского компонента:

```jsx
ReactDOM.createPortal(child, container)
```

- _child_: `JSX-выражение` или `React-компонент` для рендеринга;
- _container_: контейнер (`HTML-элемент`), в котором должен быть отрисован компонент. 


## В чем разница между `ReactDOM` и `React`?

```jsx
import React from 'react'
import ReactDOM from 'react-dom'

class MyComponent extends React.Component {
  render() {
    return <div>Привет, народ!</div>
  }
})

ReactDOM.render(<MyComponent />, someDomNode)
```

Пакет `React` содержит такие методы, как `React.createElement`, `React.createClass`, `React.Component`, `React.Children` и т.д.

Пакет `ReactDOM` содержит такие методы, как `ReactDOM.render`, `ReactDOM.unmountComponentAtNode`, `ReactDOM.findDOMNode`, а также `react-dom/server`, включающий методы `ReactDOMServer.renderToString` и `ReactDOMServer.renderToStaticMarkup`.

Модуль `ReactDOM` содержит специфичные для `DOM` методы, в то время как `React` включает основные инструменты для разных платформ (например, `React Native`).
    
  **[⬆ Наверх](#top)**
  
 12. ### <a name="12"></a> В чем разница между классовыми и функциональными компонентами?

_Функциональные компоненты_

- Функциональные компоненты - это обычные функции `JavaScript`. Чаще всего, они представлены в форме стрелочных функций, но их вполне можно создавать и с помощью ключевого слова `function`.
- Их часто называют компонентами _без состояния_, которые просто принимают данные и отображают их в некоторой форме, поэтому они, в основном, отвечают за рендеринг `UI` (так было до появления хуков).
- В них нельзя использовать методы жизненного цикла, например, `componentDidMount` (в настоящее время хуки предоставляют альтернативы почти всем методам жизненного цикла).
- У них нет метода `render`.
- Как правило, они отвечают за `UI` и форму представления данных (например, компонент кнопки).
- Принимают и используют пропы.
- Им следует отдавать предпочтение в случаях, когда не требуется работать с состоянием (так было до появления хуков).

```jsx
const ClockUsingHooks = props => {
    const [time, setTime] = useState(new Date())

    useEffect(() => {
      const tick = setInterval(() => {
        setTime(new Date())
      }, 1000)
      return () => { clearInterval(tick) }
    }, [])

    return (
      <div className="clock">
        <h1>Привет! Это часы, созданные с помощью функционального компонента</h1>
        <h2>Сейчас {time.toLocaleTimeString()}</h2>
      </div>
    )
}

export default ClockUsingHooks
```

_Классовые компоненты_

- Для создания классовых компонентов используются классы `ES6`, расширяющие класс `React.Component`.
- Их часто называют компонентами _с состоянием_, поскольку в них реализуется логика поведения на основе некоторого состояния.
- Внутри классов могут использоваться методы жизненного цикла, например, `componentDidMount`.
- Принимают `props` и имеют к ним доступ через `this.props`.
- Могут содержать `refs` (ссылки, рефы) на нижележащие `DOM-узлы`.
- Могут использовать такие техники улучшения производительности, как `shouldComponentUpdate()` и `PureComponent`

```jsx
class ClockUsingClass extends React.Component {
  constructor(props) {
    super(props)
    this.state = { date: new Date() }
  }

  componentDidMount() {
    this.time = setInterval(() => {
      this.changeTime()
    }, 1000)
  }

  componentWillUnmount() {
    clearInterval(this.time)
  }

  changeTime() {
    this.setState({ date: new Date() })
  }

  render() {
    return (
      <div className="clock">
        <h1>Привет! Это часы, созданные с помощью классового компонента</h1>
        <h2>Сейчас {this.state.date.toLocaleTimeString()}</h2>
      </div>
    )
  }
}

export default ClockUsingClass
``` 
    
  **[⬆ Наверх](#top)**
  
 13. ### <a name="13"></a> 

 
    
  **[⬆ Наверх](#top)**
  
 14. ### <a name="14"></a> 

 
    
  **[⬆ Наверх](#top)**
  
 15. ### <a name="15"></a> 

 
    
  **[⬆ Наверх](#top)**
  
 16. ### <a name="16"></a> 

 
    
  **[⬆ Наверх](#top)**
  
 17. ### <a name="17"></a> 

 
    
  **[⬆ Наверх](#top)**
  
 18. ### <a name="18"></a> 

 
    
  **[⬆ Наверх](#top)** 

51. ### <a name="51"></a> 

 
    
  **[⬆ Наверх](#top)**
  
52. ### <a name="52"></a> Для чего нужны props. Разница Props и State

 `Props` - это входные данные для компонента. Это простые значения (примитивы) или объект, содержащий несколько значений, которые передаются компонентам при их создании с помощью синтаксиса, похожего на атрибуты HTML-тегов.

Основное назначение пропов в React заключается в предоставлении компоненту следующего функционала:

1. Передача данных компоненту
2. Вызов изменения состояния
3. Использование через `this.props.reactProp` внутри метода `render()` компонента

Создадим элемент со свойством `reactProp`:

```jsx harmony
    <Element reactProp={'1'} />
```

Этот `reactProp` добавляется в качестве свойства ко встроенному объекту *props*, который присутствет во всех компонентах, созданных с помощью React.

```jsx harmony
  props.reactProp
```
	
### В чем разница между состоянием и пропами?
	
И props, и state являются обычными JavaScript-объектами. Несмотря на то, что они оба содержат информацию, которая используется при рендеринге компонента, функционал у них разный. Пропы передаются компоненту подобно аргументам, передаваемым функции, а состояние управляется компонентом как переменные, объявленные внутри функции.

_Состояние_ (state) - это данные, содержащиеся внутри компонента. Состояние является локальным (принадлежащем определенному компоненту). Компонент может обновлять состояние с помощью метода `setState`:

```jsx
class Employee extends React.Component {
  constructor() {
    this.state = {
      id: 1,
      name: "Иван"
    }
  }

  render() {
    return (
      <div>
        <p>{this.state.id}</p>
        <p>{this.state.name}</p>
      </div>
    )
  }
}

export default Employee
```

_Пропы_ (props) - это данные, передаваемые дочернему компоненту от родительского. `props` являются доступными только для чтения в получающем их потомке. Тем не менее, передаваемая функция обратного вызова, может быть использована в потомке для обновления его состояния:

```jsx
class ParentComponent extends Component {
  render() {
    return (
      <ChildComponent name="Потомок" />
    )
  }
}

const ChildComponent = (props) => {
  return <p>{props.name}</p>
}
```

**Разница между состоянием и пропами**

|Пропы                             |Состояние                             |
|----------------------------------|----------------------------------|
|Доступны только для чтения              |Состояние обновляется асинхронно |
|Являются иммутабельными              |Является изменямым, но не напрямую                 |
|Позволяют передавать данные от одного компонента другому в виде аргумента |Содержит информацию о компоненте |
|Доступны для дочерних компонентов |Недоступно для дочерних компонентов |
|Используются для взаимодействия между компонентами |Используются для рендеринга динамических изменений компонента |
|Компонент без состояния может иметь пропы |Компонент без состояния не может иметь пропов |
|Могут сделать компонент переиспользуемым |Не может сделать компонент преиспользуемым |
|Являются внешними и управляются родительским компонентом |Является внутренним и управляется самим компонентом |
    
  **[⬆ Наверх](#top)**
  
53. ### <a name="53"></a> Props доступны только для чтения

 `props` (пропсы) — это входные данные React-компонентов, передаваемые от родительского компонента дочернему компоненту.

Помните, props предназначены только для чтения. Ни в каком случае их не следует изменять:
```
// Неправильно!
   
props.number = 42;
```    
Если вам нужно поменять значение в ответ на пользовательский ввод или ответ сервера, используйте state (состояние).

    
Они читаются только в контексте компонента, то есть вы не можете присвоить им новое значение.

Но родитель, который передает реквизит ребенку, может передавать различные реквизиты, основанные на некотором условии. В этом случае ребенок получает визуализацию с другим реквизитом.

Пример:

```jsx harmony
class Parent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      value: 0,
    };
  }
  render() {
    return (
      <div>
        <Child prop1={this.state.value} />
        <button onClick={() => this.setState({ value: this.state.value + 1 })}>Click me</button>
      </div>
    );
  }
}
```    
В моем примере каждый щелчок по родительской кнопке изменяет ее состояние, поэтому React повторно визуализирует ее, а затем этот родитель передает новое значение дочернему компоненту.
    
  **[⬆ Наверх](#top)** 
  
54. ### <a name="54"></a> Обратный поток данных

### Без свойств (props):
    
Я создал новый компонент TodoList и експортирую его, и теперь его нужно подключить к главному компоненту App, и что бы это сделать нужно добавить его в компонент App:
- в компоненте App импортируем TodoList
- И теперь для того что бы добавить компонент TodoList в общий шаблон нам нужно TodoList превратить в html тег.
- мы просто оборачиваем его в треугольный кавычки и пишем название <TodoList />
- в браузере мы увидим тот функционал который добовляли
    
 В этом и заключается вся логика компонентов 
    
```jsx harmony    
import React from 'react';
import TodoList from './Todo/TodoList';

function App() {
  return(
    <div className='wrapper'>
      <h1>Some idea</h1>
      
      <TodoList />
    </div>
  )
}

export default App;
``` 
    
### Со свойствами (props):
    
1. Создаем новый компонент TodoItem, експортируем его, и пишем в нем:
    
```jsx harmony    
impoer React from 'react';

export default function TodoItem() {
  return <li>todo</li>;
}
```
    
2. Теперь этот компонент нужно определить в компоненте выше TodoList:
    - мы импортируем наш компонент TodoItem
    - вместо того что бы выводить элементы <li> я просто перобразовываю TodoItem в компонент
    - если мы посмотрим в браузере то увидим три раза написано todo потому что мы указали статический текст.
  
```jsx harmony   
import React from 'react';
import TodoItem from './Todo/TodoItem';

export default function TodoList() {
  return (
    <ul>
      <TodoItem />
      <TodoItem />
      <TodoItem />
    </ul>
  )
}        
```
3. Добавим динамикки, для этого в компоненте App.js в функции перед возвратом всего нашего приложения я создам масив todoses, где каждый элемент массива будет представлен в виде обьекта.  
    - мы создали массив где динамиски написли название, индекс ...
    - нам необходимо данный масив отобразить в компоненте TodoList
    - для этого необходимо в компоненте TodoList оьозначить какие свойства мы будем принимать для того что бы передать в него даный масив
    - в TodoList мы можем придумать название того свойства который будет принимать компонент TodoList и в качестве значения в фигурных скобках указываем какой нибудь JavaScript, в моем случае это масив todos
    
```jsx harmony
import React from 'react';
import TodoList from './Todo/TodoList';

function App() {

  const todos = [
    {id: 1, completed: true, title: 'Выучить React'},
    {id: 2, completed: true, title: 'Выучить JavaScript'},
    {id: 3, completed: false, title: 'Сходить за хлебом'}
  ]

  return(
    <div className='wrapper'>
      <h1>Some idea</h1>

      <TodoList todoses={todos} />
    </div>
  )
}

export default App;        
```
    
4. Двльше необходимо их принять, и для этого там где мы определяем функцию:
    
    function(props) {}  
    
мы принимаем некоторые props.
    
- props - это обьект у которого есть ключ который соответствует todos   
- теперь в шаблоне нужно вывести динамически наши элементы, мы не знаем сколько у нас элементов и поэтому будем выводить с помощью цыкла (map)
- и в компонент <TodoItem /> нужно добавить свойства  <TodoItem todo={todo} />  

```jsx harmony
import React from 'react';
import TodoItem from './Todo/TodoItem';

export default function TodoList(props) {
  return (
    <ul>
      {props.todoses.map(todo => {
        return <TodoItem todo={todo} />
      })}
    </ul>
  )
}        
```    

5. Дальше в компоненте TodoItem принимаем обьект props, но учитывая что мы знаем название параметра мы можем в фигурных скобках написать {todo}
    
   - в return вместо статического текста буду указывать динамически {todo.title} 
    
```jsx harmony    
impoer React from 'react';

export default function TodoItem({todo}) {
  return <li>{todo.title}</li>;
}   
```
    
6. В консоле есть ошибка key, нужно в компонент TodoList добавить атрибут key куда я должен передать некоторое уникальное значение.
key нужен что бы React более ефективно рендерил нам шаблон   
    
```jsx harmony    
import React from 'react';
import TodoItem from './Todo/TodoItem';

export default function TodoList(props) {
  return (
    <ul>
      {props.todoses.map(todo => {
        return <TodoItem todo={todo} key={todo.id} />
      })}
    </ul>
  )
}       
``` 
    
7. Предположим мы хотим выводить индекс для кажлого елемента todo
    - компонент TodoList в методе map мы можем обернуть в круглые скобки парамент todo и принимать сюда второй параметр index
    - и дальше как отдельное свойство передаем его в компонент index={index}
    
```jsx harmony
import React from 'react';
import TodoItem from './Todo/TodoItem';

export default function TodoList(props) {
  return (
    <ul>
      {props.todoses.map((todo, index) => {
        return <TodoItem todo={todo} key={todo.id} index={index} />
      })}
    </ul>
  )
}        
```    
    
8. Теперь в TodoItem помимо того что мы принимаем обьект todo мы так же принимаем число index
    - допустим будем его выводить в теге strong где в фигурных скобказ будем выводить index
    - что бы индекс показывался с 1, мы добавим единицу
    
```jsx harmony
impoer React from 'react';

export default function TodoItem({todo, index}) {
  return (
  	<li>
        <strong>{index + 1}</strong>
        {todo.title}
  	</li>
	)
}    
```
    
  **[⬆ Наверх](#top)**
  
55. ### <a name="55"></a> Props, пример кода

- [Easy function props](#easy)
- [Hard function props](#hard)
- [Easy class props](#classProps)
- [code props](#code_props)
- [Hard function props](#example)


### Easy function props <a name="easy"></a>
```jsx harmony
function WhoAmI({name, surname, link}) {
  return (
    <div>
      <h1>My name is {name.firstName}, surname - {surname}</h1>
      <a href={link}>My Profile</a>
    </div>
  )
}

function App() {
  return (
    <div className="App">

      <WhoAmI name='Spacy' surname='Motion' link='reactjs.ru' />

      <WhoAmI name={{firstName: 'Max'}} surname='Motion' link='reactjs.ru' />

    </div>
  );
}

export default App;
```

**[⬆ 55](#55)**


### Hard function props <a name="hard"></a>

App.js
```jsx harmony
import AppInfo from '../app-info/app-info';
import SearchPanel from '../search-panel/search-panel';
import AppFilter from '../app-filter/app-filter';
import EmployersList from '../employers-list/employers-list';
import EmployersAddForm from '../employers-add-form/employers.add-form';

import './app.css';


function App() {

const data = [
	{name: 'Spacy', salary: 800, increase: true, id: 1},
	{name: 'John', salary: 1000, increase: false, id: 2},
	{name: 'Mary', salary: 1350, increase: false, id: 3}
];

   return (
	<div className='app'>
		<AppInfo />

		<div className="search-panel">
			<SearchPanel />
			<AppFilter />
		</div>

		<EmployersList data={data} />
		<EmployersAddForm />
	</div>
   );
}

export default App;
```

EmployersList.js
```jsx harmony
import EmployersListItem from '../employers-list-item/employers-list-item';

import './employers-list.css';

const EmployersList = ({data}) => {

   const elements = data.map(item => {
   
   	const {id, ...itemProps} = item;
	
	return (
	   // <EmployersListItem name={item.name} salary={item.salary} />

	   <EmployersListItem key={id} {...itemProps}/>
	)
     })

   	return (
	    <ul className="app-list list-group">
		 {elements}
	    </ul>
   )
}

export default EmployersList;
```

EmployersListItem.js
```jsx harmony
import './employers-list-item.css'

const EmployersListItem = ({name, salary, increase}) => {

	let classNames = 'list-group-item d-flex justify-content-between';
	if (increase) {
		classNames += ' increase'
	}

   return (
	<li className={classNames}>
		<span className='list-group-item-label'>{name}</span>
		<input type="text" className='list-group-item-input' defaultValue={salary + '$'}/>
		<div className='d-flex justify-content align-items-center'>
			<button type='button'
				className='btn-cookie btn-sm'>
				<i className='fas fa-cookie'></i>
			</button>
			<button type='button'
				className='btn-trash btn-sm'>
				<i className='fas fa-trash'></i>
			</button>
			<i className='fas fa-star'></i>
		</div>
	</li>
   )
}

export default EmployersListItem;
```

**[⬆ 55](#55)**


### Easy class props <a name="classProps"></a>

```jsx harmony
import {Component} from 'react';
import './App.css';


class WhoAmI extends Component {
  constructor(props) {
    super(props);
  }
  render() {
    const {name, surname, link} = this.props;

    return (
      <div>
        <h1>My name is {name}, surname - {surname}</h1>
        <a href={link}>My Profile</a>
      </div>
    )
  }
}

function App() {
  return (
    <div className="App">

      <WhoAmI name='Spacy' surname='Motion' link='reactjs.ru' />

      <WhoAmI name='Max' surname='Motion' link='reactjs.ru' />

    </div>
  );
}

export default App;

```
**[⬆ 55](#55)**


### Example <a name="example"></a>

![1](https://user-images.githubusercontent.com/80325645/127764908-759787ff-d330-48ed-9e5b-e52342718e60.png)
![2](https://user-images.githubusercontent.com/80325645/127764910-f7864e91-73d7-4c3c-bc9a-100d781448e4.png)
![3](https://user-images.githubusercontent.com/80325645/127764911-5d1c3523-bb61-4ab0-a791-b22c48b78f36.png)
![4](https://user-images.githubusercontent.com/80325645/127764912-0a77afbe-48b8-4f2e-ba8a-1ccf9ad8d92f.png)
![5](https://user-images.githubusercontent.com/80325645/127764918-55803cc4-b49b-4657-ba28-f3da50ec03de.png)
![6](https://user-images.githubusercontent.com/80325645/127764921-44a8f4f0-22ad-483e-8ad4-16b0c5293ea9.png)
![7](https://user-images.githubusercontent.com/80325645/127764922-c3c9792c-307c-4839-a701-055aebc8ba84.png)
![8](https://user-images.githubusercontent.com/80325645/127764927-69d528a4-0b18-4e68-b112-8f45ff0a7b42.png)

**[⬆ 55](#55)**


### App <a name="code_props"></a>

```jsx harmony
import React from 'react';

import AppHeader from '../app-header';
import SearchPanel from '../search-panel';
import PostStatusFilter from '../post-status-filter';
import PostList from '../post-list';
import PostAddForm from '../post-add-form';

import './app.css';

const App = () => {

    const data = [
        {label: 'Going to learn React', important: true, id: 1},
        {label: 'That is so good', important: false, id: 2},
        {label: 'I need a break...', important: false, id: 3}
    ]
    return (
       <div className="app">
            <AppHeader/>
            <div className="search-panel d-flex">
                <SearchPanel/>
                <PostStatusFilter/>
            </div>
            <PostList posts={data}/>
            <PostAddForm/>
       </div>
    )
}

export default App;
```

### PostList

```jsx harmony
import React from 'react';

import PostListItem from '../post-list-item';
import './post-list.css'

const PostList = ({posts}) => {

    const elements = posts.map( (item) => {
        // Простой способ проверки на объект + содержится ли в нем информация
        if ( typeof item === 'object' && isEmpty(item) ){ 
            const {id, ...itemProps} = item;
            return (
                <li key = {id} className='list-group-item'>
                    <PostListItem {...itemProps}/>
                </li>
            )
        }
    })

    function isEmpty(obj) {
        for(let key in obj)
        {
            return true;
        }
        return false;
    }

    return (
        <ul className="app-list list-group">
           {elements}
        </ul>
    )
}

export default PostList;
```

### PostListItem

```jsx harmony
import React, {Component} from 'react';

import './post-list-item.css';

export default class PostListItem extends Component {
    constructor(props) {
        super(props);
        this.state = {
            important: false,
            like: false
        }
        this.onImportant = this.onImportant.bind(this); // Или используем другой способ - мы их будем еще применять в следующих проектах
        this.onLike = this.onLike.bind(this); 
    }

    onImportant() {
        this.setState(({important}) => ({
            important: !important
        }))
    }

    onLike() {
        this.setState(({like}) => ({
            like: !like
        }))
    }

    render() {
        const {label} = this.props;
        const {important, like} = this.state;

        let classNames = "app-list-item d-flex justify-content-between";
        if (important) {
            classNames += ' important';
        }
        if (like) {
            classNames += ' like';
        }
    return (
        <div className={classNames}>
            <span 
                className="app-list-item-label"
                onClick={this.onLike}>
                {label}
            </span>
            <div className="d-flex justify-content-center align-items-center">
                <button 
                type="button" 
                className="btn-star btn-sm"
                onClick={this.onImportant}>
                    <i className="fa fa-star"></i>
                </button>
                <button 
                type="button" 
                className="btn-trash btn-sm">
                    <i className="fa fa-trash-o"></i>
                </button>
                <i className="fa fa-heart"></i>
            </div>
        </div>
        )
    }
}
```
**[⬆ 55](#55)**
    
  **[⬆ Наверх](#top)**
  
56. ### <a name="56"></a> State в Классовых и Функциональных компонентах

 `Состояние` - это объект, содержащий некоторую информацию, которая может измениться в течение жизненного цикла компонента. Мы всегда должны стараться делать состояние настолько простым, насколько это возможно, и минимизировать количество компонентов без состояния.
 
 
 ### Добавим внутреннее состояние в класс
    
Переместим date из пропсов в состояние в три этапа:

1. Заменим this.props.date на this.state.date в методе render():
	
```jsx harmony    
class Clock extends React.Component {
  render() {
    return (
      <div>
        <h1>Привет, мир!</h1>
        <h2>Сейчас {this.state.date.toLocaleTimeString()}.</h2>
      </div>
    );
  }
}
```
    
2. Добавим конструктор класса, в котором укажем начальное состояние в переменной this.state:
	
```jsx harmony    
class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {date: new Date()};
  }

  render() {
    return (
      <div>
        <h1>Привет, мир!</h1>
        <h2>Сейчас {this.state.date.toLocaleTimeString()}.</h2>
      </div>
    );
  }
}
```
    
Обратите внимание, что мы передаём props базовому (родительскому) конструктору:
	
```jsx harmony
  constructor(props) {
    super(props);
    this.state = {date: new Date()};
  }
```
    
Классовые компоненты всегда должны вызывать базовый конструктор с аргументом props.

3. Удалим проп date из элемента <Clock />:
	
```jsx harmony    
ReactDOM.render(
  <Clock />,
  document.getElementById('root')
);
```
    
Позже мы вернём код таймера обратно и на этот раз поместим его в сам компонент.

Результат выглядит следующим образом:
	
```jsx harmony
class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {date: new Date()};
  }

  render() {
    return (
      <div>
        <h1>Привет, мир!</h1>
        <h2>Сейчас {this.state.date.toLocaleTimeString()}.</h2>
      </div>
    );
  }
}

ReactDOM.render(
  <Clock />,
  document.getElementById('root')
);
```
	
### Как правильно использовать состояние
	
Важно знать три детали о правильном применении setState().

*Не изменяйте состояние напрямую*
	
В следующем примере повторного рендера не происходит:
```jsx harmony
// Неправильно
this.state.comment = 'Привет';
```	
Вместо этого используйте setState():
```jsx harmony
// Правильно
this.setState({comment: 'Привет'});
```	
Конструктор — это единственное место, где вы можете присвоить значение this.state напрямую.

*Обновления состояния могут быть асинхронными*
	
React может сгруппировать несколько вызовов setState() в одно обновление для улучшения производительности.

Поскольку this.props и this.state могут обновляться асинхронно, вы не должны полагаться на их текущее значение для вычисления следующего состояния.

Например, следующий код может не обновить счётчик:
```jsx harmony
// Неправильно
this.setState({
  counter: this.state.counter + this.props.increment,
});
```	
Правильно будет использовать второй вариант вызова setState(), который принимает функцию, а не объект. Эта функция получит предыдущее состояние в качестве первого аргумента и значения пропсов непосредственно во время обновления в качестве второго аргумента:
```jsx harmony
// Правильно
this.setState((state, props) => ({
  counter: state.counter + props.increment
}));
```	
В данном примере мы использовали стрелочную функцию, но можно использовать и обычные функции:
```jsx harmony
// Правильно
this.setState(function(state, props) {
  return {
    counter: state.counter + props.increment
  };
});
```	
*Обновления состояния объединяются*
	
Когда мы вызываем setState(), React объединит аргумент (новое состояние) c текущим состоянием.

Например, состояние может состоять из нескольких независимых полей:
```jsx harmony
  constructor(props) {
    super(props);
    this.state = {
      posts: [],
      comments: []
    };
  }
```	
Их можно обновлять по отдельности с помощью отдельных вызовов setState():
```jsx harmony
  componentDidMount() {
    fetchPosts().then(response => {
      this.setState({
        posts: response.posts
      });
    });

    fetchComments().then(response => {
      this.setState({
        comments: response.comments
      });
    });
  }
```	
Состояния объединяются поверхностно, поэтому вызов this.setState({comments}) оставляет this.state.posts нетронутым, но полностью заменяет this.state.comments.	


### Функциональные компоненты

**Функциональные компоненты:** это простейший способ создания компонента. Эти функции являются "чистыми", принимают объект с пропами в качестве аргумента и возвращают элемент(ы):

```jsx harmony
        function Greeting({ message }) {
          return <h1>{`Привет, ${message}`}</h1>

        }
```    

- Функции проще, вам не нужно создавать класс, использовать extends и конструктор. Основная проблема была в том, что многие люди использовали классы неправильно. 
- С чистыми функциями сложнее написать плохой код
- У вас нет необходимости использовать контект. То есть не нужно биндить this, чтобы он был правильный и код выходит чище
- С помощью чистых функций создаются компоненты без внутреннего состояния. И у вас никогда не будет возможности выбрать хотите ли вы хранить данные в локальном стейте или в нормальном сторе. Вы просто не сможете по лени или незнанию использовать локальный стейт, а значит все ваши данные вы вынуждены будете хранить нормально.
- Описание компонентов с помощью чистых функций создает меньше кода, а значит его легче поддерживать.
- Чистые функции намного проще тестировать. Вы просто передаете props на вход и ожидаете какую то разметку.
В будущем чистые функции будут выигрывать по скорости работы в сравнении с классами из-за отсутствия методов жизненного цикла	
	
Если компонент нуждается в состоянии или методах жизненного цикла, тогда используйте классовый компонент, иначе, используйте функциональный компонент.

Обратите внимание: в React 16.8 были представлены хуки, позволяющие использовать состояние, методы жизненного цикла и другие возможности классовых компонентов в функциях.

### State in Function

Обратите внимание: в React 16.8 были представлены хуки, позволяющие использовать состояние, методы жизненного цикла и другие возможности классовых компонентов в функциях.
	
Хуки — нововведение в React 16.8, которое позволяет использовать состояние и другие возможности React без написания классов.

На странице введения в хуки мы познакомились с ними на этом примере:
	
```jsx harmony
import React, { useState } from 'react';

function Example() {
  // Объявление новой переменной состояния «count»
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Вы кликнули {count} раз(а)</p>
      <button onClick={() => setCount(count + 1)}>
        Нажми на меня
      </button>
    </div>
  );
}	
```
 
	
### Создадим компонент `User` с состоянием `message`:

```jsx harmony
    class User extends React.Component {
      constructor(props) {
        super(props)

        this.state = {
          message: 'Добро пожаловать в мир React!'
        }
      }

      render() {
        return (
          <div>
            <h1>{this.state.message}</h1>
          </div>
        )
      }
    }
```

![state](../assets/img/state.jpg)

Состояние похоже на проп, но оно является приватным (замкнуто в своей области видимости) и полностью контролируется компонентом, т.е. оно недоступно для других компонентов, кроме того, которому оно принадлежит и которое его определяет.

### Состояние у Функционального компонента	
    
Хуки — нововведение в React 16.8, которое позволяет использовать состояние и другие возможности React без написания классов.
	
1. Используем хук useState
2. Функция useState всегда возвращает массив, состоящий из двух элементов: 
- первый элемент массива это состояние, оно будет равно дефолтному значению	
- второй элемент это функция позволяющая изменять данное состоние для того что бы реает видел эти изменения	
	

На странице введения в хуки мы познакомились с ними на этом примере:
```jsx harmony
import React, {useState} from 'react';
import "./styles.css";

export default function Example() {
  // Объявление новой переменной состояния «count»
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Вы кликнули {count} раз(а)</p>
      <button onClick={() => setCount(count + 1)}>
        + 
      </button>
      <button onClick={() => setCount(count - 1)}>
        -
      </button>
    </div>
  );
}
```
	
В функциональном компоненте нам недоступен this, поэтому мы не можем задать или считать состояние через this.state. Вместо этого мы вызываем хук useState напрямую изнутри нашего компонента.
```jsx harmony
import React, { useState } from 'react';

function Example() {
  // Объявление новой переменной состояния «count»
  const [count, setCount] = useState(0);
```	
Что делает вызов useState? Он объявляет «переменную состояния». Мы называли переменную count, но могли дать ей любое имя, хоть банан. Таким образом мы можем «сохранить» некоторые значения между вызовами функции. useState — это новый способ использовать те же возможности, что даёт this.state в классах. Обычно переменные «исчезают» при выходе из функции. К переменным состояния это не относится, потому что их сохраняет React.

Какие аргументы передавать useState? Единственный аргумент useState — это исходное состояние. В отличие от случая с классами, состояние может быть и не объектом, а строкой или числом, если нам так удобно. Поскольку в нашем примере отслеживается количество сделанных пользователем кликов, мы передаём 0 в качестве исходного значения переменной. (Если нам нужно было бы хранить два разных значения в состоянии, то пришлось бы вызвать useState() дважды.)

Что возвращается из useState? Вызов useState вернёт пару значений: текущее состояние и функцию, обновляющую состояние. Поэтому мы пишем const [count, setCount] = useState(). Это похоже на this.state.count и this.setState в классах, с той лишь разницей, что сейчас мы принимаем их сразу в паре. Если вам незнаком использованный синтаксис, мы вернёмся к нему ближе к концу страницы.

Теперь мы знаем, что делает useState, и пример должен быть ясен:
```jsx harmony
import React, { useState } from 'react';

function Example() {
  // Объявление новой переменной состояния «count»
  const [count, setCount] = useState(0);
```	
Мы объявляем переменную состояния count и устанавливаем ей значение 0. React будет помнить текущее (наиболее свежее) значение между рендерингами и передавать его нашей функции. Если мы захотим изменить count, мы вызовем setCount.
    
  **[⬆ Наверх](#top)**
  
57. ### <a name="57"></a> state и setState, пример кода

- [setState function component](#setFunction)
- [Class easy setState](#classEasy)
- [First function setState](#first_function_setState)
- [First class setState](#first_class_setState)
- [Second code setState](#second_code_setState)
- [pictures state&setState](#pictures_state&setState)
- [code state & setState](#code_state_&_setState)


### setState function component <a name="setFunction"></a>

```jsx harmony
const App = (props) => {
  const [counter, setCounter] = React.useState(props.counter);
  
  const incCounter = () => {
    if (counter < 50) {
      setCounter(counter => counter + 1)
    }
  }
  
  const decCounter = () => {
    if (counter > -50) {
      setCounter(counter => counter - 1)
    }
  }
  
  const rndCounter = () => {
    setCounter(+(Math.random() * (50 - -50) + -50).toFixed(0))
  }
  
  const resetCounter = () => {
    setCounter(props.counter)
  }
  
  return (
    <div className="app">
      <div className="counter">{counter}</div>
      <div className="controls">
        <button onClick={incCounter}>INC</button>
        <button onClick={decCounter}>DEC</button>
        <button onClick={rndCounter}>RND</button>
        <button onClick={resetCounter}>RESET</button>
      </div>
    </div>
  )
}

ReactDOM.render(<App counter={0}/>, document.getElementById('app'));
```

### Class easy setState <a name="classEasy"></a>

```jsx harmony
class App extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      counter: this.props.counter
    }
  }
  
  incCounter = () => {
    if (this.state.counter < 50) {
      this.setState(state => ({
        counter: state.counter + 1
      }))
    }
  }
  
  decCounter = () => {
    if (this.state.counter > -50) {
      this.setState(state => ({
        counter: state.counter - 1
      }))
    }
  }
  
  rndCounter = () => {
    this.setState({
      counter: +(Math.random() * (50 - -50) + -50).toFixed(0)
    })
  }
  
  resetCounter = () => {
    this.setState({
      counter: this.props.counter
    })
  }
  
  render() {
    const {counter} = this.state;
    
    return (
      <div class="app">
        <div class="counter">{counter}</div>
        <div class="controls">
          <button onClick={this.incCounter}>INC</button>
          <button onClick={this.decCounter}>DEC</button>
          <button onClick={this.rndCounter}>RND</button>
          <button onClick={this.resetCounter}>RESET</button>
        </div>
      </div>
    )
  }
}

ReactDOM.render(<App counter={0}/>, document.getElementById('app'));
```


### First function setState <a name="first_function_setState"></a>
```jsx harmony
import React, {useState} from 'react';
import "./styles.css";

export default function Example() {
  // Объявление новой переменной состояния «count»
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Вы кликнули {count} раз(а)</p>
      <button onClick={() => setCount(count + 1)}>
        + 
      </button>
      <button onClick={() => setCount(count - 1)}>
        -
      </button>
    </div>
  );
}
```

### First class setState <a name="first_class_setState"></a>

```jsx harmony
import React, {Component} from 'react';

export default class Greetings extends Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0
    }
    this.onAdd = this.onAdd.bind(this);
    this.onMinus = this.onMinus.bind(this);
  }

  onAdd() {
    this.setState(({count}) => ({
      count: count + 1
    }))
  }

  onMinus() {
    this.setState(({count}) => ({
      count: count - 1
    }))
  }

  render() {
    const {count} = this.state;
    return(
      <div>
        <p>{count}</p>
        <button onClick={this.onAdd}>++</button>
        <button onClick={this.onMinus}>--</button>
      </div>
    )
  }
}
```
**[⬆ 57](#57)**


### Second code setState <a name="second_code_setState"></a>

```jsx harmony
class WhoAmI extends Component {
  constructor(props) {
    super(props);
    this.state = {
      years: 26,
    };
    this.nextYear = this.nextYear.bind(this);

 nextYear() {
    this.setState((state) => ({
      years: ++state.years,
    })); //1
  }
	
 render() {
    const { name, surname, link } = this.props;
    const { years } = this.state;

    return (
      <>
        <button onClick={this.nextYear}>++</button>
        <h1>
          My name is {name}, surname - {surname}, years - {years}
        </h1>
        <a href={link}>My profile</a>
      </>
    );
  }
}		
```	
**[⬆ 57](#57)**

### pictures state&setState <a name="pictures_state&setState"></a>
	
![10](https://user-images.githubusercontent.com/80325645/127764966-37a9ba60-25db-4281-8bca-7da1b89ddbb9.png)
![11](https://user-images.githubusercontent.com/80325645/127764968-61ee3280-ed4e-4f2c-b34a-15843c2c1c5a.png)
![12](https://user-images.githubusercontent.com/80325645/127764969-0220693e-86d5-4e2d-bf81-56fa6ef56deb.png)
![13](https://user-images.githubusercontent.com/80325645/127764973-719929e9-1f7c-4015-9d7a-0fb5c20353a2.png)
![14](https://user-images.githubusercontent.com/80325645/127764975-b957cb8d-bb31-4fc1-b171-04a29f1c1183.png)
![15](https://user-images.githubusercontent.com/80325645/127764978-40f194f6-21c7-4db4-95a4-8b8e67dda7f1.png)	

**[⬆ 57](#57)**


### App <a name="code_state_&_setState"></a>

```jsx harmony
import React from 'react';

import AppHeader from '../app-header';
import SearchPanel from '../search-panel';
import PostStatusFilter from '../post-status-filter';
import PostList from '../post-list';
import PostAddForm from '../post-add-form';

import './app.css';

const App = () => {

    const data = [
        {label: 'Going to learn React', important: true, id: 1},
        {label: 'That is so good', important: false, id: 2},
        {label: 'I need a break...', important: false, id: 3}
    ]
    return (
       <div className="app">
            <AppHeader/>
            <div className="search-panel d-flex">
                <SearchPanel/>
                <PostStatusFilter/>
            </div>
            <PostList posts={data}/>
            <PostAddForm/>
       </div>
    )
}

export default App;
```

### PostList

```jsx harmony
import React from 'react';

import PostListItem from '../post-list-item';
import './post-list.css'

const PostList = ({posts}) => {

    const elements = posts.map( (item) => {
        // Простой способ проверки на объект + содержится ли в нем информация
        if ( typeof item === 'object' && isEmpty(item) ){ 
            const {id, ...itemProps} = item;
            return (
                <li key = {id} className='list-group-item'>
                    <PostListItem {...itemProps}/>
                </li>
            )
        }
    })

    function isEmpty(obj) {
        for(let key in obj)
        {
            return true;
        }
        return false;
    }

    return (
        <ul className="app-list list-group">
           {elements}
        </ul>
    )
}

export default PostList;
```

### PostListItem

```jsx harmony
import React, {Component} from 'react';

import './post-list-item.css';

export default class PostListItem extends Component {
    constructor(props) {
        super(props);
        this.state = {
            important: false,
            like: false
        }
        this.onImportant = this.onImportant.bind(this); // Или используем другой способ - мы их будем еще применять в следующих проектах
        this.onLike = this.onLike.bind(this); 
    }

    onImportant() {
        this.setState(({important}) => ({
            important: !important
        }))
    }

    onLike() {
        this.setState(({like}) => ({
            like: !like
        }))
    }

    render() {
        const {label} = this.props;
        const {important, like} = this.state;

        let classNames = "app-list-item d-flex justify-content-between";
        if (important) {
            classNames += ' important';
        }
        if (like) {
            classNames += ' like';
        }
    return (
        <div className={classNames}>
            <span 
                className="app-list-item-label"
                onClick={this.onLike}>
                {label}
            </span>
            <div className="d-flex justify-content-center align-items-center">
                <button 
                type="button" 
                className="btn-star btn-sm"
                onClick={this.onImportant}>
                    <i className="fa fa-star"></i>
                </button>
                <button 
                type="button" 
                className="btn-trash btn-sm">
                    <i className="fa fa-trash-o"></i>
                </button>
                <i className="fa fa-heart"></i>
            </div>
        </div>
        )
    }
}
```
**[⬆ 57](#57)**
    
  **[⬆ Наверх](#top)**
  
58. ### <a name="58"></a> Как работает setState

`setState()` не изменяет `state` сразу, но создает запрос на изменение состояния (планирует или откладывает обновление). Поэтому после обновления `state` теоретически может иметь старое значение. Несколько операций обновления могут объединяться `React` в одну в целях повышения производительности.

Это связано с тем, что `setState()` изменяет состояние компонента, что приводит к его повторному рендерингу. Если операция обновления состояние будет синхронной и при этом дорогой с точки зрения производительности, то браузер пользователя лишится интерактивности (перестанет отвечать на действия пользователя до завершения операции). Поэтому такие операции являются асинхронными и группируются для обеспечения лучшего пользовательского опыта и повышения производительности.

Метод setState() планирует изменение объекта состояния (state) компонента. Когда состояние меняется, компонент рендерится повторно.
```jsx harmony
setState(updater, [callback])
```	
`setState()` - добавляет в очередь изменения в состоянии компонента. Также он указывает React, что компонент и его дочерние элементы должны быть повторно отрендерены с обновлённым состоянием. Этот метод используется для обновления интерфейса в ответ на обработчики событий и ответы сервера.

Думайте о setState(), как о запросе, а не как о команде немедленного обновления компонента. Для увеличения производительности React может задержать его выполнение, а затем обновить несколько компонентов за один проход. React не гарантирует моментальное применение изменений в состоянии.

Метод setState() не всегда обновляет компонент сразу. Он может группировать или откладывать обновление до следующего раза. Это делает чтение this.state сразу после вызова setState() потенциальной ловушкой. Вместо этого используйте componentDidUpdate() или колбэк setState() (setState(updater, callback)), каждый из которых гарантированно вызывается после того как было применено обновление. Если вам нужно обновить состояние на основе предыдущего, используйте аргумент updater, описанный ниже.

### Первым аргументом передаётся функция updater, которая имеет следующий вид:
```jsx harmony
(state, props) => stateChange
```	
`state` — ссылка на состояние компонента при изменении. Объект состояния не должен мутировать. Изменения должны проявляться в виде нового объекта на основе входных данных из state и props. Предположим, что мы хотели бы увеличить значение состояния с помощью props.step:
```jsx harmony
this.setState((state, props) => {
  return {counter: state.counter + props.step};
});
```	
Как state, так и props, полученные функцией обновления, гарантированно будут обновлены. Результат функции поверхностно объединяется с state.

### Второй аргумент setState - нужен для того что бы словить только что изменившееся состояние, и сделать какое-то действие

Второй параметр в setState() — необязательный колбэк, вызываемый после выполнения setState и повторного рендера компонента. Вместо этого в большинстве случаев для такой логики мы рекомендуем использовать componentDidUpdate().

В качестве первого аргумента setState(), вместо функции, вы можете передать объект:
```jsx harmony
setState(stateChange[, callback])
```	
В нём образуется новое состояние после поверхностного объединения с stateChange. Например, установим количество товаров в корзине:
```jsx harmony
this.setState({quantity: 2})	
```    
Последующие вызовы будут переопределять значения из предыдущих вызовов того же цикла. Из-за этого количество увеличится только один раз. В случае, если следующее состояние зависит от текущего, мы рекомендуем использовать форму функции обновления:
```jsx harmony
this.setState((state) => {
  return {quantity: state.quantity + 1};
});
```

Поскольку this.props и this.state могут обновляться асинхронно, вы не должны полагаться на их текущее значение для вычисления следующего состояния.

Например, следующий код может не обновить счётчик:
```jsx harmony
// Неправильно
this.setState({
  counter: this.state.counter + this.props.increment,
});
```

Правильно будет использовать второй вариант вызова setState(), который принимает функцию, а не объект. Эта функция получит предыдущее состояние в качестве первого аргумента и значения пропсов непосредственно во время обновления в качестве второго аргумента:
```jsx harmony
// Правильно
this.setState((state, props) => ({
  counter: state.counter + props.increment
}));
```

В данном примере мы использовали стрелочную функцию, но можно использовать и обычные функции:
```jsx harmony
// Правильно
this.setState(function(state, props) {
  return {
    counter: state.counter + props.increment
  };
});
```
    
  **[⬆ Наверх](#top)**
  
59. ### <a name="59"></a> Методов жизненного цикла

 ### componentDidMount()
```jsx harmony
componentDidMount()
```
componentDidMount() вызывается сразу после монтирования (то есть, вставки компонента в DOM). В этом методе должны происходить действия, которые требуют наличия DOM-узлов. Это хорошее место для создания сетевых запросов.

Этот метод подходит для настройки подписок. Но не забудьте отписаться от них в componentWillUnmount().

Вы можете сразу вызвать setState() в componentDidMount(). Это вызовет дополнительный рендер перед тем, как браузер обновит экран. Гарантируется, что пользователь не увидит промежуточное состояние, даже если render() будет вызываться дважды. Используйте этот подход с осторожностью, он может вызвать проблемы с производительностью. В большинстве случаев начальное состояние лучше объявить в constructor(). Однако, это может быть необходимо для случаев, когда нужно измерить размер или положение DOM-узла, на основе которого происходит рендер. Например, для модальных окон или всплывающих подсказок.

### componentDidUpdate()
```jsx harmony
componentDidUpdate(prevProps, prevState, snapshot)
```
componentDidUpdate() вызывается сразу после обновления. Не вызывается при первом рендере.

Метод позволяет работать с DOM при обновлении компонента. Также он подходит для выполнения таких сетевых запросов, которые выполняются на основании результата сравнения текущих пропсов с предыдущими. Если пропсы не изменились, новый запрос может и не требоваться.
```jsx harmony
componentDidUpdate(prevProps) {
  // Популярный пример (не забудьте сравнить пропсы):
  if (this.props.userID !== prevProps.userID) {
    this.fetchData(this.props.userID);
  }
}
```
В componentDidUpdate() можно вызывать setState(), однако его необходимо обернуть в условие, как в примере выше, чтобы не возник бесконечный цикл. Вызов setState() влечет за собой дополнительный рендер, который незаметен для пользователя, но может повлиять на производительность компонента. Вместо «отражения» пропсов в состоянии рекомендуется использовать пропсы напрямую. Подробнее о том, почему копирование пропсов в состояние вызывает баги.

В тех редких случаях когда реализован метод жизненного цикла getSnapshotBeforeUpdate(), его результат передаётся componentDidUpdate() в качестве третьего параметра snapshot.

### componentWillUnmount()
```jsx harmony
componentWillUnmount()
```
componentWillUnmount() вызывается непосредственно перед размонтированием и удалением компонента. В этом методе выполняется необходимый сброс: отмена таймеров, сетевых запросов и подписок, созданных в componentDidMount().

Не используйте setState() в componentWillUnmount(), так как компонент никогда не рендерится повторно. После того, как экземпляр компонента будет размонтирован, он никогда не будет примонтирован снова.

### shouldComponentUpdate()
```jsx harmony
shouldComponentUpdate(nextProps, nextState)
```
Используйте shouldComponentUpdate(), чтобы указать необходимость следующего рендера на основе изменений состояния и пропсов. По умолчанию происходит повторный рендер при любом изменении состояния. В большинстве случаев вы должны полагаться на это поведение.

shouldComponentUpdate() вызывается перед рендером, когда получает новые пропсы или состояние. Значение по умолчанию равно true. Этот метод не вызывается при первом рендере или когда используется forceUpdate().

Этот метод нужен только для повышения производительности. Но не опирайтесь на его возможность «предотвратить» рендер, это может привести к багам. Вместо этого используйте PureComponent, который позволяет не описывать поведение shouldComponentUpdate() вручную. PureComponent поверхностно сравнивает пропсы и состояние и позволяет не пропустить необходимое обновление.

Мы не рекомендуем делать глубокое сравнение или использовать JSON.stringify() в shouldComponentUpdate(). Это неэффективно и плохо влияет на производительность.

### static getDerivedStateFromProps()
```jsx harmony
static getDerivedStateFromProps(props, state)
```

getDerivedStateFromProps вызывается непосредственно перед вызовом метода render, как при начальном монтировании, так и при последующих обновлениях. Он должен вернуть объект для обновления состояния или null, чтобы ничего не обновлять.

Этот метод существует для редких случаев, когда состояние зависит от изменений в пропсах. Например, это подойдёт для реализации компонента <Transition>, который сравнивает свои предыдущие и следующие дочерние компоненты, чтобы решить, какой из них нужно анимировать.

### static getDerivedStateFromError()
```jsx harmony
static getDerivedStateFromError(error)
```
Этот метод жизненного цикла вызывается после возникновения ошибки у компонента-потомка. Он получает ошибку в качестве параметра и возвращает значение для обновления состояния.

```jsx harmony
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    // Обновите состояние так, чтобы следующий рендер показал запасной интерфейс.
    return { hasError: true };
  }

  render() {
    if (this.state.hasError) {
      // Здесь можно рендерить запасной интерфейс
      return <h1>Что-то пошло не так.</h1>;
    }

    return this.props.children;
  }
}
```
	
### getSnapshotBeforeUpdate()
	
```jsx harmony	
getSnapshotBeforeUpdate(prevProps, prevState)
```
	
getSnapshotBeforeUpdate() вызывается прямо перед этапом «фиксирования» (например, перед добавлением в DOM). Он позволяет вашему компоненту брать некоторую информацию из DOM (например, положение прокрутки) перед её возможным изменением. Любое значение, возвращаемое этим методом жизненного цикла, будет передано как параметр componentDidUpdate().

Это применяется редко, но может быть полезно в таких интерфейсах, как цепочка сообщений в чатах, в которых позиция прокрутки обрабатывается особым образом.

Значение снимка (или null) должно быть возвращено.

```jsx harmony
class ScrollingList extends React.Component {
  constructor(props) {
    super(props);
    this.listRef = React.createRef();
  }

  getSnapshotBeforeUpdate(prevProps, prevState) {
    // Добавляются ли в список новые элементы?
    // Запоминаем значение прокрутки, чтобы использовать его позже.
    if (prevProps.list.length < this.props.list.length) {
      const list = this.listRef.current;
      return list.scrollHeight - list.scrollTop;
    }
    return null;
  }

  componentDidUpdate(prevProps, prevState, snapshot) {
    // Если снимок (snapshot) передан, значит элементы добавлены.
    // Выравниваем прокрутку так, чтобы новые элементы не выталкивали старые.
    // (снимок – значение, переданное из getSnapshotBeforeUpdate)
    if (snapshot !== null) {
      const list = this.listRef.current;
      list.scrollTop = list.scrollHeight - snapshot;
    }
  }

  render() {
    return (
      <div ref={this.listRef}>{/* ...contents... */}</div>
    );
  }
}
```
В примерах выше важно получить значение свойства scrollHeight в getSnapshotBeforeUpdate из-за того, что могут возникать задержки между этапами жизненного цикла «рендер» (например, render) и «фиксирование» (например, getSnapshotBeforeUpdate и componentDidUpdate).	
	
### static getDerivedStateFromError()

```jsx harmony
static getDerivedStateFromError(error)
```

Этот метод жизненного цикла вызывается после возникновения ошибки у компонента-потомка. Он получает ошибку в качестве параметра и возвращает значение для обновления состояния.

```jsx harmony
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    // Обновите состояние так, чтобы следующий рендер показал запасной интерфейс.
    return { hasError: true };
  }

  render() {
    if (this.state.hasError) {
      // Здесь можно рендерить запасной интерфейс
      return <h1>Что-то пошло не так.</h1>;
    }

    return this.props.children;
  }
}
```
	
### componentDidCatch()

componentDidCatch(error, info)
Этот метод жизненного цикла вызывается после возникновения ошибки у компонента-потомка. Он получает два параметра:

1. error — перехваченная ошибка
2. info — объект с ключом componentStack, содержащий информацию о компоненте, в котором произошла ошибка.

componentDidCatch() вызывается во время этапа «фиксации», поэтому здесь можно использовать побочные эффекты. Метод можно использовать для логирования ошибок.
```jsx harmony
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    // Обновите состояние так, чтобы следующий рендер показал запасной интерфейс.
    return { hasError: true };
  }

  componentDidCatch(error, info) {
    // Пример "componentStack":
    //   in ComponentThatThrows (created by App)
    //   in ErrorBoundary (created by App)
    //   in div (created by App)
    //   in App
    logComponentStackToMyService(info.componentStack);
  }

  render() {
    if (this.state.hasError) {
      // Здесь можно рендерить запасной интерфейс
      return <h1>Что-то пошло не так.</h1>;
    }

    return this.props.children;
  }
}
```
    
  **[⬆ Наверх](#top)**
  
60. ### <a name="60"></a> Стадии жизненного цикла компонента

 Каждый компонент имеет несколько «методов жизненного цикла». Переопределение такого метода позволяет выполнять код на конкретном этапе этого процесса. Вы можете использовать эту диаграмму жизненного цикла как шпаргалку. Далее на странице полужирным шрифтом выделены самые распространённые методы жизненного цикла.

### Монтирование

При создании экземпляра компонента и его вставке в DOM, следующие методы вызываются в установленном порядке:

- constructor()
- static getDerivedStateFromProps()
- render()
- componentDidMount()


### Обновление

Обновление происходит при изменении пропсов или состояния. Следующие методы вызываются в установленном порядке при повторном рендере компонента:

- static getDerivedStateFromProps()
- shouldComponentUpdate()
- render()
- getSnapshotBeforeUpdate()
- componentDidUpdate()


### Размонтирование

Этот метод вызывается при удалении компонента из DOM:

- componentWillUnmount()


### Обработка ошибок

Следующие методы вызываются, если произошла ошибка в процессе рендеринга, методе жизненного цикла или конструкторе любого дочернего компонента.

- static getDerivedStateFromError()
- componentDidCatch()


Стадии в React 16.3+ (или интерактивная версия)

![47](https://user-images.githubusercontent.com/80325645/128733631-7a12eca1-51e7-471f-8087-5397287ea633.jpg)

До React 16.3:

![48](https://user-images.githubusercontent.com/80325645/128733701-a9d26935-e488-4138-bd9d-2424ada3d22a.png)
    
  **[⬆ Наверх](#top)**
  
61. ### <a name="61"></a> Устаревшие методы жизненного цикла

 ### UNSAFE_componentWillMount()

```jsx harmony
UNSAFE_componentWillMount()
```

UNSAFE_componentWillMount() вызывается непосредственно перед монтированием. Он вызывается перед render(), поэтому синхронный вызов setState() в этом методе не вызовет дополнительный рендер. Для инициализации состояния мы рекомендуем использовать constructor().

Избегайте добавления каких-либо побочных эффектов или подписок в этом методе. Вместо этого используйте componentDidMount().

Это единственный метод жизненного цикла, вызываемый при серверном рендеринге.

### UNSAFE_componentWillReceiveProps()
```jsx harmony
UNSAFE_componentWillReceiveProps(nextProps)
```

UNSAFE_componentWillReceiveProps() вызывается до того, как смонтированный компонент получит новые пропсы. Чтобы обновить состояние в ответ на изменение пропсов (например, для его сброса), можно сравнить this.props с nextProps и обновить состояние в этом методе с помощью this.setState().

Обратите внимание, если родительский компонент заставляет ваш компонент повторно рендериться, метод будет вызываться, даже если пропсы не изменились. Убедитесь, что сравниваете текущие и следующие значения, если вы хотите обрабатывать изменения.

Во время монтирования React не вызывает UNSAFE_componentWillReceiveProps() с начальными значениями пропсов. Этот метод вызывается, если некоторые пропсы компонента могут обновиться. Вызов this.setState() обычно не вызывает UNSAFE_componentWillReceiveProps().


### UNSAFE_componentWillUpdate()

```jsx harmony
UNSAFE_componentWillUpdate(nextProps, nextState)
```

UNSAFE_componentWillUpdate() вызывается непосредственно перед рендером при получении новых пропсов или состояния. В этом методе можно выполнить некоторую подготовку перед обновлением. Этот метод не вызывается при первом рендере.

Внутри этого метода нельзя вызвать this.setState(), а также делать какие-либо действия, которые влияют на обновление компонента перед возвратом UNSAFE_componentWillUpdate() (например, отправка действия Redux).

Обычно этот метод можно заменить на componentDidUpdate(). Вы можете использовать getSnapshotBeforeUpdate() для работы с DOM (например, запоминать положение прокрутки страницы).
    
  **[⬆ Наверх](#top)**
  
62. ### <a name="62"></a> Статическая типизация в React

 Инструменты для статической типизации, такие как Flow или TypeScript, позволяют отлавливать большую часть ошибок ещё до исполнения кода. Кроме того, они существенно улучшают процессы разработки, добавляя автодополнение и другие возможности. Для приложений с большой кодовой базой мы рекомендуем использовать Flow или TypeScript вместо PropTypes.

### Flow

Flow — это библиотека для статической типизации JavaScript, разработанная в Facebook и часто применяемая в связке с React. Flow расширяет возможности JavaScript, добавляя аннотации типов для переменных, функций и React-компонентов. Ознакомиться с основами Flow можно на странице официальной документации.

Чтобы начать пользоваться возможностями Flow необходимо:

- добавить Flow в ваш проект как зависимость.
- убедиться, что аннотации Flow удаляются из кода при его компиляции.
- добавить несколько аннотаций типов и запустить Flow для их проверки;

Рассмотрим подробнее каждый из этих шагов.

### Добавление Flow в проект

Убедитесь, что вы находитесь в директории проекта, после чего запустите одну из следующих команд:

Если вы используете Yarn:
```jsx harmony
yarn add --dev flow-bin
```
Если вы используете npm:
```jsx harmony
npm install --save-dev flow-bin
```
Эти команды добавят последнюю версию Flow в ваш проект.

Далее нужно добавить flow в секцию "scripts" файла package.json:
```jsx harmony
{
  // ...
  "scripts": {
    "flow": "flow",
    // ...
  },
  // ...
}
```
Теперь можно запустить скрипт, прописав в терминале:
```jsx harmony
yarn run flow init
```
Или npm:
```jsx harmony
npm run flow init
```
Эти команды создадут файл с исходной конфигурацией Flow, который обязательно нужно закоммитить.

### Запуск Flow

Если всё было сделано правильно, можно попробовать запустить процесс Flow:
```jsx harmony
yarn flow
```
Или npm:
```jsx harmony
npm run flow
```

### Typescript

TypeScript — это язык программирования, разработанный в Microsoft. TypeScript является надмножеством JavaScript, имеет статическую систему типов и собственный компилятор. Статическая типизация позволяет отлавливать ошибки и баги во время компиляции, ещё до запуска приложения. Подробнее узнать о совместном использовании TypeScript и React можно здесь.

Чтобы использовать TypeScript, нужно:

- добавить TypeScript в проект как зависимость.
- настроить компилятор.
- использовать правильные расширения файлов.
- установить файлы объявлений для используемых библиотек;

Остановимся подробнее на каждом из этих моментов.

### Использование TypeScript вместе с Create React App

Create React App поддерживает TypeScript по умолчанию.

Чтобы создать новый проект с поддержкой TypeScript, используйте следующую команду:
```jsx harmony
npx create-react-app my-app --template typescript
```
Можно добавить поддержку TypeScript в уже существующий проект, как показано здесь.

Примечание:

Дальше описывается ручная настройка TypeScript. Если вы используете Create React App, можете пропустить этот раздел.

### Добавление TypeScript в проект

Всё начинается с одной единственной команды в терминале:
```jsx harmony
yarn add --dev typescript
```
Или npm:
```jsx harmony
npm install --save-dev typescript
```
Ура! Вы установили последнюю версию TypeScript. Теперь в вашем распоряжении новая команда — tsc. Но прежде, чем праздновать, давайте добавим соответствующий скрипт в файл package.json:
```jsx harmony
{
  // ...
  "scripts": {
    "build": "tsc",
    // ...
  },
  // ...
}
```
    
  **[⬆ Наверх](#top)**
  
63. ### <a name="63"></a> default Props

 Мы можем определить для свойств значения по умолчанию на тот случай, если их значения не передаются извне.

Если мы применяем классы, то для установки значений применяется статическое свойство defaultProps:
```jsx harmony	
class Hello extends React.Component {
             
    render() {
        return <div>
            <p>Имя: {this.props.name}</p>
            <p>Возраст: {this.props.age}</p>
        </div>;
    }
}
Hello.defaultProps = {name: "Tom", age: 22};
```
При функциональном определении компонента также применяется свойство defaultProps:
```jsx harmony
function Hello(props) {
    return <div>
        <p>Имя: {props.name}</p>
        <p>Возраст: {props.age}</p>
    </div>;
}
Hello.defaultProps = {name: "Tom", age: 22};
```
И в любом из этих случаев, если мы не определим какие-то свойства для компонента, то они будут брать значения из значений по умолчанию:

```jsx harmony
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>METANIT.COM</title>
</head>
<body>
    <div id="app"></div>
       
    <script crossorigin src="https://unpkg.com/react@17/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@17/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script type="text/babel">
        class Hello extends React.Component {
              
            render() {
                return <div>
                    <p>Имя: {this.props.name}</p>
                    <p>Возраст: {this.props.age}</p>
                </div>;
            }
        }
        Hello.defaultProps = {name: "Tom", age: 22};
        ReactDOM.render(
            <Hello name="Bob" />,
            document.getElementById("app")
        )
    </script>
</body>
```
    
  **[⬆ Наверх](#top)**
  
64. ### <a name="64"></a> Prop types

 React предоставляет встроенные возможности для проверки типов. Для запуска этой проверки на пропсах компонента вам нужно использовать специальное свойство propTypes:
	
```jsx harmony
import PropTypes from 'prop-types';

class Greeting extends React.Component {
  render() {
    return (
      <h1>Привет, {this.props.name}</h1>
    );
  }
}

Greeting.propTypes = {
  name: PropTypes.string
};
```	
	
В данном примере проверка типа показана на классовом компоненте, но она же может быть применена и к функциональным компонентам, или к компонентам, созданным с помощью React.memo или React.forwardRef.

PropTypes предоставляет ряд валидаторов, которые могут использоваться для проверки, что получаемые данные корректны. В примере мы использовали PropTypes.string. Когда какой-то проп имеет некорректное значение, в консоли будет выведено предупреждение. По соображениям производительности propTypes проверяются только в режиме разработки.  
	
	
Функциональные компоненты
	
К функциональным компонентам можно также применять PropTypes.

Допустим, есть такой компонент:
	
```jsx harmony
export default function HelloWorldComponent({ name }) {
  return (
    <div>Hello, {name}</div>
  )
}
```	
Для добавления PropTypes нужно объявить компонент в отдельной функции, которую затем экспортировать:
```jsx harmony
function HelloWorldComponent({ name }) {
  return (
    <div>Hello, {name}</div>
  )
}

export default HelloWorldComponent
```	
А затем добавить PropTypes напрямую к компоненту HelloWorldComponent:
```jsx harmony
import PropTypes from 'prop-types'

function HelloWorldComponent({ name }) {
  return (
    <div>Hello, {name}</div>
  )
}

HelloWorldComponent.propTypes = {
  name: PropTypes.string
}

export default HelloWorldComponent
```
    
  **[⬆ Наверх](#top)**
  
65. ### <a name="65"></a> React.memo, PureComponent, Component & shouldComponentUpdate

 ### React.Component

React.Component — это базовый класс для компонентов React, объявленных как ES6-классы:
```jsx harmony
class Greeting extends React.Component {
  render() {
    return <h1>Привет, {this.props.name}</h1>;
  }
}
```
Со списком методов и свойств базового класса React.Component можно ознакомиться в API-справочнике по React.Component.

### React.Component пример
```jsx harmony
import {useState, Component} from 'react';
import {Container} from 'react-bootstrap';
import './App.css';

class Form extends Component {

	shouldComponentUpdate(nextProps) {
		if (this.props.mail.name === nextProps.mail.name) {
			return false
		} return true;
	}

	render() {

	console.log('render')

	return (
		<Container>
			<form className="w-50 border mt-5 p-3 m-auto">
				<div className="mb-3">
					<label htmlFor="exampleFormControlInput1" className="form-label mt-3">Email address</label>
					<input value={this.props.mail.name} type="email" className='form-control' id="exampleFormControlInput1" placeholder="name@example.com"/>
				</div>
				<div className="mb-3">
					<label htmlFor="exampleFormControlTextarea1" className="form-label">Example textarea</label>
					<textarea value={this.props.text} className="form-control" id="exampleFormControlTextarea1" rows="3"></textarea>
				</div>
			</form>
		</Container>
		)
	}
}

function App() {
    const [data, setData] = useState({
        mail: {
        	name: "name@example.com"
				},
        text: 'some text'
    });

    return (
        <>
            <Form mail={data.mail} text={data.text}/>
            <button
                onClick={() => setData({
			mail: {
				name: "name@example.com"
			},
                    	text: 'some text'
                })}>
                Click me
            </button>
        </>
    );
}

export default App;
```

### React.PureComponent

React.PureComponent похож на React.Component. Отличие заключается в том, что React.Component не реализует shouldComponentUpdate(), а React.PureComponent реализует его поверхностным сравнением пропсов и состояния.

Если метод render() вашего React-компонента всегда рендерит одинаковый результат при одних и тех же пропсах и состояниях, для повышения производительности в некоторых случаях вы можете использовать React.PureComponent.	

### React.PureComponent пример
```jsx harmony
import {useState, PureComponent} from 'react';
import {Container} from 'react-bootstrap';
import './App.css';

class Form extends PureComponent {

	render() {

	console.log('render')

	return (
		<Container>
			<form className="w-50 border mt-5 p-3 m-auto">
				<div className="mb-3">
					<label htmlFor="exampleFormControlInput1" className="form-label mt-3">Email address</label>
					<input value={this.props.mail} type="email" className='form-control' id="exampleFormControlInput1" placeholder="name@example.com"/>
				</div>
				<div className="mb-3">
					<label htmlFor="exampleFormControlTextarea1" className="form-label">Example textarea</label>
					<textarea value={this.props.text} className="form-control" id="exampleFormControlTextarea1" rows="3"></textarea>
				</div>
			</form>
		</Container>
		)
	}
}

function App() {
    const [data, setData] = useState({
        mail: "name@example.com",
        text: 'some text'
    });

    return (
        <>
            <Form mail={data.mail} text={data.text} onLog={onLog}/>
            <button
                onClick={() => setData({
			mail: "name@example.com",
                    	text: 'some text'
                })}>
                Click me
            </button>
        </>
    );
}

export default App;
```

### React.memo
```jsx harmony
const MyComponent = React.memo(function MyComponent(props) {
  /* рендер с использованием пропсов */
});
```
React.memo — это компонент высшего порядка.

Если ваш компонент всегда рендерит одно и то же при неменяющихся пропсах, вы можете обернуть его в вызов React.memo для повышения производительности в некоторых случаях, мемоизируя тем самым результат. Это значит, что React будет использовать результат последнего рендера, избегая повторного рендеринга.

React.memo затрагивает только изменения пропсов. Если функциональный компонент обёрнут в React.memo и использует useState, useReducer или useContext, он будет повторно рендериться при изменении состояния или контекста.

По умолчанию он поверхностно сравнивает вложенные объекты в объекте props. Если вы хотите контролировать сравнение, вы можете передать свою функцию сравнения в качестве второго аргумента.
```jsx harmony
function MyComponent(props) {
  /* рендер с использованием пропсов */
}
function areEqual(prevProps, nextProps) {
  /*
  возвращает true, если nextProps рендерит
  тот же результат что и prevProps,
  иначе возвращает false
  */
}
export default React.memo(MyComponent, areEqual);
```
Этот метод предназначен только для оптимизации производительности. Не полагайтесь на него, чтобы «предотвратить» рендер, так как это может привести к ошибкам.

### Пример React.memo()
```jsx harmony
import {useState, memo} from 'react';
import {Container} from 'react-bootstrap';
import './App.css';

const Form = memo((props) => {

  console.log('render')

  return (
    <Container>
      <form className="w-50 border mt-5 p-3 m-auto">
        <div className="mb-3">
          <label htmlFor="exampleFormControlInput1" className="form-label mt-3">Email address</label>
          <input value={props.mail} type="email" className='form-control' id="exampleFormControlInput1" placeholder="name@example.com"/>
        </div>
        <div className="mb-3">
          <label htmlFor="exampleFormControlTextarea1" className="form-label">Example textarea</label>
          <textarea value={props.text} className="form-control" id="exampleFormControlTextarea1" rows="3"></textarea>
        </div>
      </form>
    </Container>
  )
});

function App() {
    const [data, setData] = useState({
        mail: "name@example.com",
        text: 'some text'
    });

    return (
        <>
            <Form mail={data.mail} text={data.text} onLog={onLog}/>
            <button
                onClick={() => setData({
			mail: "name@example.com",
                    	text: 'some text'
                })}>
                Click me
            </button>
        </>
    );
}

export default App;
```
### Пример React.memo()
```jsx harmony
import {useState, memo} from 'react';
import {Container} from 'react-bootstrap';
import './App.css';

function propsCompare(prevProps, nextProps) {
  return prevProps.mail.name === nextProps.mail.name && prevProps.text === nextProps.text;
}

const Form = memo((props) => {

  console.log('render')

  return (
    <Container>
      <form className="w-50 border mt-5 p-3 m-auto">
        <div className="mb-3">
          <label htmlFor="exampleFormControlInput1" className="form-label mt-3">Email address</label>
          <input value={props.mail.name} type="email" className='form-control' id="exampleFormControlInput1" placeholder="name@example.com"/>
        </div>
        <div className="mb-3">
          <label htmlFor="exampleFormControlTextarea1" className="form-label">Example textarea</label>
          <textarea value={props.text} className="form-control" id="exampleFormControlTextarea1" rows="3"></textarea>
        </div>
      </form>
    </Container>
  )
}, propsCompare);

function App() {
    const [data, setData] = useState({
        mail: {
        	name: "name@example.com"
				},
        text: 'some text'
    });

    return (
        <>
            <Form mail={data.mail} text={data.text} onLog={onLog}/>
            <button
                onClick={() => setData({
			mail: {
				name: "name@example.com"
			},
                    	text: 'some text'
                })}>
                Click me
            </button>
        </>
    );
}

export default App;
```

  **[⬆ Наверх](#top)**
  
66. ### <a name="66"></a> Зачем нужен ref

 ref — это атрибут компонента, значением которого должен быть объект, созданный в конструкторе через функцию React. createRef() . Этот объект, в отличие от остальных данных, которые находятся в props или state , хранится как обычное свойство объекта. Имя свойства можно выбрать произвольно.

Рефы дают возможность получить доступ к DOM-узлам или React-элементам, созданным в рендер-методе.

### Когда использовать рефы

Ситуации, в которых использование рефов является оправданным:

- Управление фокусом, выделение текста или воспроизведение медиа.
- Императивный вызов анимаций.
- Интеграция со сторонними DOM-библиотеками.

Избегайте использования рефов в ситуациях, когда задачу можно решить декларативным способом.

Например, вместо того чтобы определять методы open() и close() в компоненте Dialog, лучше передавать ему проп isOpen.

### Не злоупотребляйте рефами

Возможно, с первого взгляда вам показалось, что рефы применяются, когда нужно решить какую-то задачу в вашем приложении «во что бы то ни стало». Если у вас сложилось такое впечатление, сделайте паузу и обдумайте, где должно храниться конкретное состояние в иерархии компонентов. Часто становится очевидно, что правильным местом для хранения состояния является верхний уровень в иерархии.

### Создание рефов

Рефы создаются с помощью React.createRef() и прикрепляются к React-элементам через ref атрибут. Обычно рефы присваиваются свойству экземпляра класса в конструкторе, чтобы на них можно было ссылаться из любой части компонента.
```jsx harmony
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.myRef = React.createRef();
  }
  render() {
    return <div ref={this.myRef} />;
  }
}
```

### Доступ к рефам

Когда реф передаётся элементу в методе render, ссылка на данный узел доступна через свойство рефа current.
```jsx harmony
const node = this.myRef.current;
```
Значение рефа отличается в зависимости от типа узла:

- Когда атрибут ref используется с HTML-элементом, свойство current созданного рефа в конструкторе с помощью React.createRef() получает соответствующий DOM-элемент.
- Когда атрибут ref используется с классовым компонентом, свойство current объекта-рефа получает экземпляр смонтированного компонента.
- Нельзя использовать ref атрибут с функциональными компонентами, потому что для них не создаётся экземпляров.

Представленные ниже примеры демонстрируют отличия в зависимости от типа узла.

### Добавление рефа к DOM-элементу

В представленном ниже примере ref используется для хранения ссылки на DOM-элемент.
```jsx harmony
class CustomTextInput extends React.Component {
  constructor(props) {
    super(props);
    // создадим реф в поле `textInput` для хранения DOM-элемента
    this.textInput = React.createRef();
    this.focusTextInput = this.focusTextInput.bind(this);
  }

  focusTextInput() {
    // Установим фокус на текстовое поле с помощью чистого DOM API
    // Примечание: обращаемся к "current", чтобы получить DOM-узел
    this.textInput.current.focus();
  }

  render() {
    // описываем, что мы хотим связать реф <input>
    // с `textInput` созданным в конструкторе
    return (
      <div>
        <input
          type="text"
          ref={this.textInput} />
        <input
          type="button"
          value="Фокус на текстовом поле"
          onClick={this.focusTextInput}
        />
      </div>
    );
  }
}
```
React присвоит DOM-элемент свойству current при монтировании компонента и присвоит обратно значение null при размонтировании. Обновление свойства ref происходит перед вызовом методов componentDidMount и componentDidUpdate.

### Добавление рефа к классовому компоненту

Для того чтобы произвести имитацию клика по CustomTextInput из прошлого примера сразу же после монтирования, можно использовать реф, чтобы получить доступ к пользовательскому <input> и явно вызвать его метод focusTextInput:
```jsx harmony
class AutoFocusTextInput extends React.Component {
  constructor(props) {
    super(props);
    this.textInput = React.createRef();
  }

  componentDidMount() {
    this.textInput.current.focusTextInput();
  }

  render() {
    return (
      <CustomTextInput ref={this.textInput} />
    );
  }
}
```
Обратите внимание, что это сработает только в том случае, если CustomTextInput объявлен как классовый компонент:
```jsx harmony
class CustomTextInput extends React.Component {
  // ...
}
```
### Рефы и функциональные компоненты

По умолчанию нельзя использовать атрибут ref с функциональными компонентами, потому что для них не создаётся экземпляров:
```jsx harmony
function MyFunctionComponent() {
  return <input />;
}

class Parent extends React.Component {
  constructor(props) {
    super(props);
    this.textInput = React.createRef();
  }
  render() {
    // Данный код *не будет* работать!
    return (
      <MyFunctionComponent ref={this.textInput} />
    );
  }
}
```
Если вам нужен реф на функциональный компонент, можете воспользоваться forwardRef (возможно вместе с useImperativeHandle), либо превратить его в классовый компонент.

Тем не менее, можно использовать атрибут ref внутри функционального компонента при условии, что он ссылается на DOM-элемент или классовый компонент:
```jsx harmony
function CustomTextInput(props) {
  // textInput должна быть объявлена здесь, чтобы реф мог иметь к ней доступ
  const textInput = useRef(null);

  function handleClick() {
    textInput.current.focus();
  }

  return (
    <div>
      <input
        type="text"
        ref={textInput} />
      <input
        type="button"
        value="Фокус на поле для ввода текста"
        onClick={handleClick}
      />
    </div>
  );
}
```
    
  **[⬆ Наверх](#top)**
  
67. ### <a name="67"></a> React.Context

 В типичном React-приложении данные передаются сверху вниз (от родителя к дочернему компоненту) с помощью пропсов. Однако, подобный способ использования может быть чересчур громоздким для некоторых типов пропсов (например, выбранный язык, UI-тема), которые необходимо передавать во многие компоненты в приложении. Контекст предоставляет способ делиться такими данными между компонентами без необходимости явно передавать пропсы через каждый уровень дерева.

Когда использовать контекст

Контекст разработан для передачи данных, которые можно назвать «глобальными» для всего дерева React-компонентов (например, текущий аутентифицированный пользователь, UI-тема или выбранный язык). В примере ниже мы вручную передаём проп theme, чтобы стилизовать компонент Button:
```jsx harmony
class App extends React.Component {
  render() {
    return <Toolbar theme="dark" />;
  }
}

function Toolbar(props) {
  // Компонент Toolbar должен передать проп "theme" ниже,
  // фактически не используя его. Учитывая, что у вас в приложении
  // могут быть десятки компонентов, использующих UI-тему,
  // вам придётся передавать проп "theme" через все компоненты.
  // И в какой-то момент это станет большой проблемой.
  return (
    <div>
      <ThemedButton theme={props.theme} />
    </div>
  );
}

class ThemedButton extends React.Component {
  render() {
    return <Button theme={this.props.theme} />;
  }
}
```
Контекст позволяет избежать передачи пропсов в промежуточные компоненты:

### useContect хук
```jsx harmony
const themes = {
  light: {
    foreground: "#000000",
    background: "#eeeeee"
  },
  dark: {
    foreground: "#ffffff",
    background: "#222222"
  }
};

const ThemeContext = React.createContext(themes.light);

function App() {
  return (
    <ThemeContext.Provider value={themes.dark}>
      <Toolbar />
    </ThemeContext.Provider>
  );
}

function Toolbar(props) {
  return (
    <div>
      <ThemedButton />
    </div>
  );
}

function ThemedButton() {
  const theme = useContext(ThemeContext);
  return (
    <button style={{ background: theme.background, color: theme.foreground }}>
      Я стилизован темой из контекста!
    </button>
  );
}
```

### Context
```jsx harmony
// Контекст позволяет передавать значение глубоко
// в дерево компонентов без явной передачи пропсов
// на каждом уровне. Создадим контекст для текущей
// UI-темы (со значением "light" по умолчанию).
const ThemeContext = React.createContext('light');

class App extends React.Component {
  render() {
    // Компонент Provider используется для передачи текущей
    // UI-темы вниз по дереву. Любой компонент может использовать
    // этот контекст и не важно, как глубоко он находится.
    // В этом примере мы передаём "dark" в качестве значения контекста.
    return (
      <ThemeContext.Provider value="dark">
        <Toolbar />
      </ThemeContext.Provider>
    );
  }
}

// Компонент, который находится в середине,
// больше не должен явно передавать тему вниз.
function Toolbar() {
  return (
    <div>
      <ThemedButton />
    </div>
  );
}

class ThemedButton extends React.Component {
  // Определяем contextType, чтобы получить значение контекста.
  // React найдёт (выше по дереву) ближайший Provider-компонент,
  // предоставляющий этот контекст, и использует его значение.
  // В этом примере значение UI-темы будет "dark".
  static contextType = ThemeContext;
  render() {
    return <Button theme={this.context} />;
  }
}
```
 
### Пример

Context
```jsx harmony
import {createContext} from 'react';

const dataContext = createContext({
	mail: "name@example.com",
	text: 'some text'
});

export default dataContext;
```
 
Input 
```jsx harmony
import {useContext} from 'react';
import dataContext from './ConContext';

const {Consumer} = dataContext;

class InputComponent extends Component {

  // static contextType = dataContext;

  render() {
    return (
      <Consumer>
        {
          value => {
            return (
              <input
                  value={value.mail}
                  type="email"
                  className='form-control'
                  placeholder='name@example.com' />

            )
          }
        }
      </Consumer>

// Вариант который сейчас раскомментирован

// или input + static

// или input + contextType

      // <input
      //   value={this.context.mail}
      //   type="email"
      //   className='form-control'
      //   placeholder='name@example.com' />

    )
  }
}

// InputComponent.contextType = dataContext;

export default InputComponent;
```
 
Form
```jsx harmony
import {Container} from 'react-bootstrap';
import InputComponent from './ConInput';

const Form = (props) => {

	console.log('update')

	return (
		<Container>
			<form className="w-50 border mt-5 p-3 m-auto">
				<div className="mb-3">
					<label htmlFor="exampleFormControlInput1" className="form-label mt-3">Email address</label>
					<InputComponent />
				</div>
				<div className="mb-3">
					<label htmlFor="exampleFormControlTextarea1" className="form-label">Example textarea</label>
					<textarea value={props.text} className="form-control" id="exampleFormControlTextarea1" rows="3"></textarea>
				</div>
			</form>
		</Container>
	)
}

export default Form;
```

App
```jsx harmony
import { useState } from 'react';
import './App.css';
import Form from './ConForm';
import dataContext from './ConContext';

const {Provider} = dataContext;


function App() {
    const [data, setData] = useState({
        mail: "name@example.com",
        text: 'some text'
    });

    return (
        <Provider value={data}>
            <Form text={data.text}/>
            <button 
                onClick={() => setData({
                    mail: "second@example.com",
                    text: 'another text'
                })}>
                Click me
            </button>
        </Provider>
    );
}

export default App;
```

  **[⬆ Наверх](#top)**
  
68. ### <a name="68"></a> Порталы в React

 Первый аргумент (child) — это любой React-компонент, который может быть отрендерен, такой как элемент, строка или фрагмент. Следующий аргумент (container) — это DOM-элемент.

```jsx harmony
ReactDOM.createPortal(child, container)
```
Порталы позволяют рендерить дочерние элементы в DOM-узел, который находится вне DOM-иерархии родительского компонента.

### Применение

Обычно, когда вы возвращаете элемент из рендер-метода компонента, он монтируется в DOM как дочерний элемент ближайшего родительского узла:
```jsx harmony
render() {
  // React монтирует новый div и рендерит в него дочерние элементы
  return (
    <div>
      {this.props.children}
    </div>
  );
}
```
Но иногда требуется поместить потомка в другое место в DOM:
```jsx harmony
render() {
  // React *не* создаёт новый div. Он рендерит дочерние элементы в `domNode`.
  // `domNode` — это любой валидный DOM-узел, находящийся в любом месте в DOM.
  return ReactDOM.createPortal(
    this.props.children,
    domNode
  );
}
```
Типовой случай применения порталов — когда в родительском компоненте заданы стили overflow: hidden или z-index, но вам нужно чтобы дочерний элемент визуально выходил за рамки своего контейнера. Например, диалоги, всплывающие карточки и всплывающие подсказки.
    
  **[⬆ Наверх](#top)**
  
69. ### <a name="69"></a> Условный рендеринг

### &&
```jsx harmony
const [open, setOpen] = useState(false);
  
{open && (
<div className='sort__popup'>
  <ul>
    {list.map((obj, i) => (
      <li
	key={i}
	onClick={() => onClickListItem(obj)}
	className={
	  sort.sortProperty === obj.sortProperty ? 'active' : ''
	}
      >
	{obj.name}
      </li>
    ))}
```

или так вот ->

### тернарный оператор
```jsx harmony
const [open, setOpen] = useState(false);
  
{open ? (
<div className='sort__popup'>
  <ul>
    <li className='active'>популярности</li>
    <li>цене</li>
    <li>алфавиту</li>
  </ul>
</div>
) : (
'Попап скрыт'
)}  
```


 React позволяет разделить логику на независимые компоненты. Эти компоненты можно показывать или прятать в зависимости от текущего состояния.

Условный рендеринг в React работает так же, как условные выражения работают в JavaScript. Бывает нужно объяснить React, как состояние влияет на то, какие компоненты требуется скрыть, а какие — отрендерить, и как именно. В таких ситуациях используйте условный оператор JavaScript или выражения подобные if.

Рассмотрим два компонента:
```jsx harmony
function UserGreeting(props) {
  return <h1>С возвращением!</h1>;
}

function GuestGreeting(props) {
  return <h1>Войдите, пожалуйста.</h1>;
}
```

Можно создать компонент Greeting, который отражает один из этих компонентов в зависимости от того, выполнен ли вход на сайт:
```jsx harmony
function Greeting(props) {
  const isLoggedIn = props.isLoggedIn;
  if (isLoggedIn) {
    return <UserGreeting />;
  }
  return <GuestGreeting />;
}

ReactDOM.render(
  // Попробуйте заменить на isLoggedIn={true} и посмотрите на эффект.
  <Greeting isLoggedIn={false} />,
  document.getElementById('root')
);
```

В этом примере рендерится различное приветствие в зависимости от значения пропа isLoggedIn.

### Переменные-элементы

Элементы React можно сохранять в переменных. Это может быть удобно, когда какое-то условие определяет, надо ли рендерить одну часть компонента или нет, а другая часть компонента остаётся неизменной.

Рассмотрим ещё два компонента, представляющих кнопки Войти (Login) и Выйти (Logout).
```jsx harmony
function LoginButton(props) {
  return (
    <button onClick={props.onClick}>
      Войти
    </button>
  );
}
```
```jsx harmony
function LogoutButton(props) {
  return (
    <button onClick={props.onClick}>
      Выйти
    </button>
  );
}
```

В следующем примере мы создадим компонент с состоянием и назовём его LoginControl.

Он будет рендерить либо <LoginButton />, либо <LogoutButton /> в зависимости от текущего состояния. А ещё он будет всегда рендерить <Greeting /> из предыдущего примера.
```jsx harmony
class LoginControl extends React.Component {
  constructor(props) {
    super(props);
    this.handleLoginClick = this.handleLoginClick.bind(this);
    this.handleLogoutClick = this.handleLogoutClick.bind(this);
    this.state = {isLoggedIn: false};
  }

  handleLoginClick() {
    this.setState({isLoggedIn: true});
  }

  handleLogoutClick() {
    this.setState({isLoggedIn: false});
  }

  render() {
    const isLoggedIn = this.state.isLoggedIn;
    let button;
    if (isLoggedIn) {
      button = <LogoutButton onClick={this.handleLogoutClick} />;
    } else {
      button = <LoginButton onClick={this.handleLoginClick} />;
    }

    return (
      <div>
        <Greeting isLoggedIn={isLoggedIn} />
        {button}
      </div>
    );
  }
}

ReactDOM.render(
  <LoginControl />,
  document.getElementById('root')
);
```

Нет ничего плохого в том, чтобы объявить переменную и условно рендерить компонент if-выражением. Но иногда хочется синтаксис покороче. Давайте посмотрим на несколько других способов писать условия прямо в JSX.

### Встроенные условия if с логическим оператором &&

Вы можете внедрить любое выражение в JSX, заключив его в фигурные скобки. Это правило распространяется и на логический оператор && языка JavaScript, которым можно удобно вставить элемент в зависимости от условия:
```jsx harmony
function Mailbox(props) {
  const unreadMessages = props.unreadMessages;
  return (
    <div>
      <h1>Здравствуйте!</h1>
      {unreadMessages.length > 0 &&
        <h2>
          У вас {unreadMessages.length} непрочитанных сообщений.
        </h2>
      }
    </div>
  );
}

const messages = ['React', 'Re: React', 'Re:Re: React'];
ReactDOM.render(
  <Mailbox unreadMessages={messages} />,
  document.getElementById('root')
);
```

Приведённый выше вариант работает корректно, потому что в JavaScript выражение true && expression всегда вычисляется как expression, а выражение false && expression — как false.

То есть, если условие истинно (true), то элемент, идущий непосредственно за &&, будет передан на вывод. Если же оно ложно (false), то React проигнорирует и пропустит его.

Обратите внимание, что ложное выражение, как ожидается, пропустит элемент после &&, но при этом выведет результат этого выражения. В примере ниже метод render вернёт <div>0</div>.
```jsx harmony
render() {
  const count = 0;
  return (
    <div>
      { count && <h1>Количество сообщений: {count}</h1>}
    </div>
  );
}
```

### Встроенные условия if-else с тернарным оператором

Есть ещё один способ писать условия прямо в JSX. Вы можете воспользоваться тернарным оператором condition ? true : false.

Вот как этот метод можно использовать, чтобы отрендерить кусочек текста.
```jsx harmony
render() {
  const isLoggedIn = this.state.isLoggedIn;
  return (
    <div>
      Пользователь <b>{isLoggedIn ? 'сейчас' : 'не'}</b> на сайте.
    </div>
  );
}
```
Этот метод можно использовать и с выражениями покрупнее, но это может сделать код менее очевидным:
```jsx harmony
render() {
  const isLoggedIn = this.state.isLoggedIn;
  return (
    <div>
      {isLoggedIn
        ? <LogoutButton onClick={this.handleLogoutClick} />
        : <LoginButton onClick={this.handleLoginClick} />
      }
    </div>
  );
}
```
Как в JavaScript, так и в React выбор синтаксиса зависит от ваших предпочтений и принятого в команде стиля. Не забывайте, что если какое-то условие выглядит очень сложным, возможно пришло время извлечь часть кода в отдельный компонент.

Предотвращение рендеринга компонента
В редких случаях может потребоваться позволить компоненту спрятать себя, хотя он уже и отрендерен другим компонентом. Чтобы этого добиться, верните null вместо того, что обычно возвращается на рендеринг.

Например, будет ли содержимое <WarningBanner /> отрендерено, зависит от значения пропа под именем warn. Если значение false, компонент ничего не рендерит:
```jsx harmony
function WarningBanner(props) {
  if (!props.warn) {
    return null;
  }

  return (
    <div className="warning">
      Предупреждение!
    </div>
  );
}

class Page extends React.Component {
  constructor(props) {
    super(props);
    this.state = {showWarning: true};
    this.handleToggleClick = this.handleToggleClick.bind(this);
  }

  handleToggleClick() {
    this.setState(state => ({
      showWarning: !state.showWarning
    }));
  }

  render() {
    return (
      <div>
        <WarningBanner warn={this.state.showWarning} />
        <button onClick={this.handleToggleClick}>
          {this.state.showWarning ? 'Спрятать' : 'Показать'}
        </button>
      </div>
    );
  }
}

ReactDOM.render(
  <Page />,
  document.getElementById('root')
);
```

Сам факт возврата null из метода render компонента никак не влияет на срабатывание методов жизненного цикла компонента. Например, componentDidUpdate будет всё равно вызван.


  **[⬆ Наверх](#top)**
  
70. ### <a name="70"></a> Собственными обработчиками и Обработчиками в React

 
    
  **[⬆ Наверх](#top)**
  
71. ### <a name="71"></a> Потеря контекста

 ### Как передать обработчик события (например, onClick) компоненту?

Передавайте обработчики событий и другие функции через пропсы дочерним компонентам:
```jsx harmony
<button onClick={this.handleClick}>
```
Если вы хотите иметь доступ к компоненту-родителю через обработчик, вам нужно привязать функцию к экземпляру компонента (см. ниже).

### Как привязать функцию к экземпляру компонента?

В зависимости от того, какой синтаксис и подход к созданию компонентов вы используете, существует несколько способов удостовериться, что функции имеют доступ к таким атрибутам компонента, как this.props и this.state.

Привязка в конструкторе (ES2015)
```jsx harmony
class Foo extends Component {
  constructor(props) {
    super(props);
    this.handleClick = this.handleClick.bind(this);
  }
  handleClick() {
    console.log('По кнопке кликнули');
  }
  render() {
    return <button onClick={this.handleClick}>Нажми на меня</button>;
  }
}
```

### Привязка в свойствах класса (предложение-кандидат)
```jsx harmony
class Foo extends Component {
  // Примечание: данный синтаксис находится на стадии разработки и ещё не стандартизирован.
  handleClick = () => {
    console.log('По кнопке кликнули');
  }
  render() {
    return <button onClick={this.handleClick}>Нажми на меня</button>;
  }
}
```

### Привязка в методе render()
```jsx harmony
class Foo extends Component {
  handleClick() {
    console.log('По кнопке кликнули');
  }
  render() {
    return <button onClick={this.handleClick.bind(this)}>Нажми на меня</button>;
  }
}
```
Примечание:
Использование Function.prototype.bind в render() создаёт новую функцию при каждом рендере компонента, что может повлиять на производительность (см. ниже).

### Стрелочная функция в render()
```jsx harmony
class Foo extends Component {
  handleClick() {
    console.log('По кнопке кликнули');
  }
  render() {
    return <button onClick={() => this.handleClick()}>Нажми на меня</button>;
  }
}
```
Примечание:
Использование стрелочной функции в render() создаёт новую функцию при каждой отрисовке компонента, что может нарушать оптимизации, использующие строгое сравнение для определения идентичности.

Можно ли использовать стрелочные функции в методе render()?
В целом, да. Зачастую это самый простой способ передать параметры через колбэки.

Если же у вас возникли проблемы с производительностью — оптимизируйте!

Зачем вообще нужна привязка?
В JavaScript эти два фрагмента кода не равнозначны:
```jsx harmony
obj.method();
var method = obj.method;
method();
```
Привязка гарантирует, что второй фрагмент будет работать так же, как и первый.

В React, как правило, привязывать нужно только те методы, которые вы хотите передать другим компонентам. Например, <button onClick={this.handleClick}> передаёт this.handleClick, поэтому его нужно привязать. Впрочем, метод render и методы жизненного цикла привязывать не обязательно, так как мы не передаём их в другие компоненты.

### Привязка стрелочной функции	
	
Ниже приведен пример синтаксиса стрелочной функции. Здесь нет необходимости писать дополнительный код в конструкторе, чтобы связать this.
```jsx harmony
class Button extends Component {
  constructor(props) {
    super(props);
    this.state = { clicked: false };
  }
  
  handleClick = () => this.setState({clicked: true });
  render() {
    return <button onClick={this.handleClick}>Click me!</button>;
  );
}	
```
    
  **[⬆ Наверх](#top)**
  
72. ### <a name="72"></a> SyntheticEvent. Типы событий в React

 Ваши обработчики событий получают экземпляр `SyntheticEvent`, это кроссбраузерная обёртка над нативным экземпляром события. У неё такой же интерфейс, как и у нативного события, включая методы stopPropagation() и preventDefault(). Эта обёртка помогает событиям работать одинаково во всех браузерах.	

- [События буфера обмена](#Sobytiya_bufera_obmena)
- [Композиционные события](#Kompozicionnye_sobytiya)
- [События клавиатуры](#Sobytiya_klaviatury)
- [События фокуса](#Sobytiya_fokusa)
- [События формы](#Sobytiya_formy)
- [Общие события](#Obshchie_sobytiya)
- [События мыши](#Sobytiya_myshi)
- [События курсора](#Sobytiya_kursora)
- [События выбора](#Sobytiya_vybora)
- [Сенсорные события](#Sensornye_sobytiya)
- [События UI](#Sobytiya_UI)
- [События колёсика мыши](#Sobytiya_kolyosika_myshi)
- [События медиа-элементов](#Sobytiya_media-elementov)
- [События изображений](#Sobytiya_izobrazhenij)
- [События анимаций](#Sobytiya_animacij)
- [События переходов](#Sobytiya_perekhodov)
- [Другие события](#Drugie_sobytiya)
	
	
### События буфера обмена <a name="Sobytiya_bufera_obmena"></a>
	
Названия событий:
```jsx harmony	
onCopy onCut onPaste
```	
Свойства:
```jsx harmony
DOMDataTransfer clipboardData
```
**[⬆ 72](#72)**	
	
### Композиционные события <a name="Kompozicionnye_sobytiya"></a>
	
Названия событий:
```jsx harmony
onCompositionEnd onCompositionStart onCompositionUpdate
```	
Свойства:
```jsx harmony
string data	
```	
**[⬆ 72](#72)**
	
### События клавиатуры обмена <a name="Sobytiya_klaviatury"></a>
	
Названия событий:
```jsx harmony
onKeyDown onKeyPress onKeyUp
```	
Свойства:
```jsx harmony
boolean altKey
number charCode
boolean ctrlKey
boolean getModifierState(key)
string key
number keyCode
string locale
number location
boolean metaKey
boolean repeat
boolean shiftKey
number which	
```
**[⬆ 72](#72)**
	
### События фокуса <a name="Sobytiya_fokusa"></a>
	
Названия событий:
```jsx harmony
onFocus onBlur
```	
Эти события фокуса работают не только на элементах формы, но и на всех остальных элементах в React DOM.

Свойства:
```jsx harmony
DOMEventTarget relatedTarget
```
	
*onFocus*
	
Событие onFocus вызывается при перемещении фокуса на элемент (включая дочерние элементы внутри него). Например, это событие запустится, если пользователь кликнет на текстовое поле ввода.
```jsx harmony
function Example() {
  return (
    <input
      onFocus={(e) => {
        console.log('Получен фокус на поле ввода');
      }}
      placeholder="onFocus выполнится при нажатии на это поле ввода."
    />
  )
}
```
	
*onBlur*
	
Событие onBlur вызывается при пропадании фокуса с элемента (включая дочерние элементы внутри него). Например, это событие запустится, если пользователь кликнет за пределы текстового поля ввода, находящегося в фокусе.
```jsx harmony
function Example() {
  return (
    <input
      onBlur={(e) => {
        console.log('Пропал фокус с поля ввода');
      }}
      placeholder="onBlur выполнится в случае изменения фокуса с этого поля ввода на любой другой элемент."
    />
  )
}
```
	
*Отслеживание получения и перемещения фокуса*
	
Можно использовать свойства currentTarget и relatedTarget, чтобы определить, когда наступили события появления или исчезновения фокуса за пределами родительского элемента. Ниже приводится пример для выполнения в песочнице, который показывает, как можно поймать состояние фокуса на родительском и дочернем элементах, а также отследить фокус на всём поддереве элементов.
```jsx harmony
function Example() {
  return (
    <div
      tabIndex={1}
      onFocus={(e) => {
        if (e.currentTarget === e.target) {
          console.log('фокус на родительском элементе установлен');
        } else {
          console.log('фокус на дочернем элементе установлен', e.target);
        }
        if (!e.currentTarget.contains(e.relatedTarget)) {
          // Не срабатывает при перемещении фокуса между дочерними элементами
          console.log('фокус находится внутри родительского элемента');
        }
      }}
      onBlur={(e) => {
        if (e.currentTarget === e.target) {
          console.log('фокус на родительском элементе снят');
        } else {
          console.log('фокус на дочернем элементе снят', e.target);
        }
        if (!e.currentTarget.contains(e.relatedTarget)) {
          // Не срабатывает при перемещении фокуса между дочерними элементами
          console.log('фокус потерян изнутри родительского элемента');
        }
      }}
    >
      <input id="1" />
      <input id="2" />
    </div>
  );
}	
```
**[⬆ 72](#72)**
	
### События формы <a name="Sobytiya_formy"></a>
	
Названия событий:
```jsx harmony
onChange onInput onInvalid onReset onSubmit	
```
**[⬆ 72](#72)**
	
### Общие события <a name="Obshchie_sobytiya"></a>
	
Названия событий:
```jsx harmony
onError onLoad	
```
**[⬆ 72](#72)**
	
### События мыши <a name="Sobytiya_myshi"></a>
	
Названия событий:
```jsx harmony
onClick onContextMenu onDoubleClick onDrag onDragEnd onDragEnter onDragExit
onDragLeave onDragOver onDragStart onDrop onMouseDown onMouseEnter onMouseLeave
onMouseMove onMouseOut onMouseOver onMouseUp
```	
События onMouseEnter и onMouseLeave всплывают с покинутого элемента к наведённому, вместо обычного процесса всплытия и не имеют фазы перехвата.

Свойства:
```jsx harmony
boolean altKey
number button
number buttons
number clientX
number clientY
boolean ctrlKey
boolean getModifierState(key)
boolean metaKey
number pageX
number pageY
DOMEventTarget relatedTarget
number screenX
number screenY
boolean shiftKey	
```
**[⬆ 72](#72)**
	
### События курсора <a name="Sobytiya_kursora"></a>
	
Названия событий:
```jsx harmony
onPointerDown onPointerMove onPointerUp onPointerCancel onGotPointerCapture
onLostPointerCapture onPointerEnter onPointerLeave onPointerOver onPointerOut
```	
События onPointerEnter и onPointerLeave всплывают с покинутого элемента к наведённому, вместо обычного процесса всплытия и не имеют фазы перехвата.

Свойства:

По определению из спецификации W3, события курсора наследуют события мыши со следующими свойствами:
```jsx harmony
number pointerId
number width
number height
number pressure
number tangentialPressure
number tiltX
number tiltY
number twist
string pointerType
boolean isPrimary
```	
На заметку по поводу кроссбраузерности:

События указателя ещё не поддерживаются во всех браузерах (на момент написания этой страницы есть поддержка в Chrome, Firefox, Edge и Internet Explorer). React сознательно не добавляет полифил для поддержки в других браузерах, потому что это значительно бы увеличило размер пакета react-dom.

Если вашему приложению нужны события указателя, мы рекомендуем использовать сторонний полифил.	
	
**[⬆ 72](#72)**
	
### События выбора <a name="Sobytiya_vybora"></a>
	
Названия событий:
```jsx harmony
onSelect	
```
**[⬆ 72](#72)**
	
### Сенсорные события <a name="Sensornye_sobytiya"></a>
	
Названия событий:
```jsx harmony
onTouchCancel onTouchEnd onTouchMove onTouchStart
```	
Свойства:
```jsx harmony
boolean altKey
DOMTouchList changedTouches
boolean ctrlKey
boolean getModifierState(key)
boolean metaKey
boolean shiftKey
DOMTouchList targetTouches
DOMTouchList touches	
```
**[⬆ 72](#72)**
	
### События UI <a name="Sobytiya_UI"></a>
	
Названия событий:
```jsx harmony
onScroll	
```
**[⬆ 72](#72)**
	
### События колёсика мыши <a name="Sobytiya_kolyosika_myshi"></a>
	
Названия событий:
```jsx harmony
onWheel
```	
Свойства:
```jsx harmony
number deltaMode
number deltaX
number deltaY
number deltaZ	
```
**[⬆ 72](#72)**
	
### События медиа-элементов <a name="Sobytiya_media-elementov"></a>
	
Названия событий:
```jsx harmony
onAbort onCanPlay onCanPlayThrough onDurationChange onEmptied onEncrypted
onEnded onError onLoadedData onLoadedMetadata onLoadStart onPause onPlay
onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend
onTimeUpdate onVolumeChange onWaiting
```
**[⬆ 72](#72)**
	
### События изображений <a name="Sobytiya_izobrazhenij"></a>
	
Названия событий:

onLoad onError	
	
**[⬆ 72](#72)**
	
### События анимаций <a name="Sobytiya_animacij"></a>
	
Названия событий:
```jsx harmony
onAnimationStart onAnimationEnd onAnimationIteration
```	
Свойства:
```jsx harmony
string animationName
string pseudoElement
float elapsedTime	
```
**[⬆ 72](#72)**
	
### События переходов <a name="Sobytiya_perekhodov"></a>
	
Названия событий:
```jsx harmony
onTransitionEnd
```	
Свойства:
```jsx harmony
string propertyName
string pseudoElement
float elapsedTime	
```
**[⬆ 72](#72)**
	
### Другие события <a name="Drugie_sobytiya"></a>
	
Названия событий:
```jsx harmony
onToggle	
```  
	
https://ru.reactjs.org/docs/events.html
    
  **[⬆ Наверх](#top)**
	
73. ### <a name="73"></a> События в React

### setState function component

```jsx harmony
const App = (props) => {
  const [counter, setCounter] = React.useState(props.counter);
  
  const incCounter = () => {
    if (counter < 50) {
      setCounter(counter => counter + 1)
    }
  }
  
  const decCounter = () => {
    if (counter > -50) {
      setCounter(counter => counter - 1)
    }
  }
  
  const rndCounter = () => {
    setCounter(+(Math.random() * (50 - -50) + -50).toFixed(0))
  }
  
  const resetCounter = () => {
    setCounter(props.counter)
  }
  
  return (
    <div className="app">
      <div className="counter">{counter}</div>
      <div className="controls">
        <button onClick={incCounter}>INC</button>
        <button onClick={decCounter}>DEC</button>
        <button onClick={rndCounter}>RND</button>
        <button onClick={resetCounter}>RESET</button>
      </div>
    </div>
  )
}

ReactDOM.render(<App counter={0}/>, document.getElementById('app'));
```	
	
### Пример 1
	
```jsx harmony
import React, {useState} from 'react';
import "./styles.css";

export default function Example() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Вы кликнули {count} раз(а)</p>
      <button onClick={() => setCount(count + 1)}>
        + 
      </button>
      <button onClick={() => setCount(count - 1)}>
        -
      </button>
    </div>
  );
}	
```		

### Пример 2
	
```jsx harmony
import {Component} from 'react';
import './App.css';


class WhoAmI extends Component {
	constructor(props) {
		super(props);
		this.state = {
			years: 27,
			text: '+++',
			position: ''
		}
	}

	nextYear = () => {
		this.setState(state => ({
			years: state.years + 1
		}))
	}

	commitInputChanges = (e) => {
		this.setState({
			position: e.target.value
		})
	}

	render() {
		const {name, surname, link} = this.props;
		const {position, years, text} = this.state;

		return (
			<div>
				<button onClick={this.nextYear}>{text}</button>
				<h1>My name is {name}, surname - {surname}, age - {years}, position={position}</h1>
				<a href={link}>My Profile</a>
				<form>
					<span>Введите должность</span>
					<input type="text" onChange={this.commitInputChanges}/>
				</form>
			</div>
		)
	}
}

function App() {
	return (
		<div className="App">
			<WhoAmI name='Spacy' surname='Motion' link='reactjs.ru'/>
			<WhoAmI name='Max' surname='Motion' link='reactjs.ru'/>
		</div>
	);
}

export default App;	
```	
	
	
### Пример 3

```jsx harmony
class WhoAmI extends Component {
  constructor(props) {
    super(props);
    this.state = {
      years: 26,
    };
    this.nextYear = this.nextYear.bind(this); //1

  nextYear() {
    this.setState((state) => ({
      years: ++state.years,
    })); //1
  }
  render() {
    const { name, surname, link } = this.props;
    const { years } = this.state;

    return (
      <>
        <button onClick={this.nextYear}>++</button>
        <h1>
          My name is {name}, surname - {surname}, years - {years}
        </h1>
        <a href={link}>My profile</a>
      </>
    );
  }
}
```

### Пример 4
	
```jsx harmony
class Toggle extends React.Component {
  constructor(props) {
    super(props);
    this.state = {isToggleOn: true};

    // Эта привязка обязательна для работы `this` в колбэке.
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    this.setState(prevState => ({
      isToggleOn: !prevState.isToggleOn
    }));
  }

  render() {
    return (
      <button onClick={this.handleClick}>
        {this.state.isToggleOn ? 'Включено' : 'Выключено'}
      </button>
    );
  }
}

ReactDOM.render(
  <Toggle />,
  document.getElementById('root')
);
```

### Пример 5, если нужно принимать аргументы в обработчики соботий

```jsx harmony
import {Component} from 'react';
import './App.css';


class WhoAmI extends Component {
	constructor(props) {
		super(props);
		this.state = {
			years: 27,
			text: '+++',
			position: ''
		}
	}

	nextYear = () => {
		this.setState(state => ({
			years: state.years + 1
		}))
	}

	commitInputChanges = (e, color) => {
		console.log(color)
		this.setState({
			position: e.target.value
		})
	}

	render() {
		const {name, surname, link} = this.props;
		const {position, years, text} = this.state;

		return (
			<div>
				<button onClick={this.nextYear}>{text}</button>
				<h1>My name is {name}, surname - {surname}, age - {years}, position={position}</h1>
				<a href={link}>My Profile</a>
				<form>
					<span>Введите должность</span>
					<input type="text" onChange={(e) => this.commitInputChanges(e, 'some color')}/>
				</form>
			</div>
		)
	}
}

function App() {
	return (
		<div className="App">

			<WhoAmI name='Spacy' surname='Motion' link='reactjs.ru'/>

			<WhoAmI name='Max' surname='Motion' link='reactjs.ru'/>

		</div>
	);
}

export default App;
```


### Пример 6, используется довольно редко

```jsx harmony
import {Component} from 'react';
import './App.css';


class WhoAmI extends Component {
	constructor(props) {
		super(props);
		this.state = {
			years: 27,
			text: '+++',
			position: ''
		}
	}

	// обработчик событий 3 способ => nextYear

	nextYear() {
		this.setState(state => ({
			years: state.years + 1
		}))
	}

	commitInputChanges = (e) => {
		this.setState({
			position: e.target.value
		})
	}

	render() {
		const {name, surname, link} = this.props;
		const {position, years, text} = this.state;

		return (
			// nextYear обработчик событий 3 способ
			
			<div>
				<button onClick={() => this.nextYear()}>{text}</button> 
				<h1>My name is {name}, surname - {surname}, age - {years}, position={position}</h1>
				<a href={link}>My Profile</a>
				<form>
					<span>Введите должность</span>
					<input type="text" onChange={this.commitInputChanges}/>
				</form>
			</div>
		)
	}
}

function App() {
	return (
		<div className="App">

			<WhoAmI name='Spacy' surname='Motion' link='reactjs.ru'/>

			<WhoAmI name='Max' surname='Motion' link='reactjs.ru'/>

		</div>
	);
}

export default App;
```


### Пример 7
App
```jsx harmony
import React, {Component} from 'react';

import AppHeader from '../app-header';
import SearchPanel from '../search-panel';
import PostStatusFilter from '../post-status-filter';
import PostList from '../post-list';
import PostAddForm from '../post-add-form';

import './app.css';

export default class App extends Component {

    constructor(props) {
        super(props);
        this.state = {
            data : [
                {label: 'Going to learn React', important: true, id: 1},
                {label: 'That is so good', important: false, id: 2},
                {label: 'I need a break...', important: false, id: 3}
            ]
        };
        this.deleteItem = this.deleteItem.bind(this);
        this.addItem = this.addItem.bind(this);

        this.maxId = 4;
    }

    deleteItem(id) {
        this.setState(({data}) => {
            const index = data.findIndex((elem) => elem.id === id);

            const before = data.slice(0, index);
            const after = data.slice(index + 1);

            const newArr = [...before, ...after];
            return {
                data: newArr
            }
        });
    }

    addItem(body) {
        const newItem = {
            label: body,
            important: false,
            id: this.maxId++
        }

        this.setState(({data}) => {
            const newArr = [...data, newItem];
            return {
                data: newArr
            }
        });
    }

    render() {
        return (
            <div className="app">
                 <AppHeader/>
                 <div className="search-panel d-flex">
                    <SearchPanel/>
                    <PostStatusFilter/>
                 </div>
                 <PostList 
                    posts={this.state.data} 
                    onDelete={ this.deleteItem}/>
                 <PostAddForm
                    onAdd={this.addItem}/>
            </div>
         )
    }
}
```

PostList
```jsx harmony
import React from 'react';

import PostListItem from '../post-list-item';
import './post-list.css'

const PostList = ({posts, onDelete}) => {

    const elements = posts.map((item) => {
        const {id, ...itemProps} = item;
        return (
            <li key={id} className='list-group-item'>
                <PostListItem 
                {...itemProps}
                onDelete={() => onDelete(id)}/>
            </li>
        )
    });

    return (
        <ul className="app-list list-group">
            {elements}
        </ul>
    )
}

export default PostList;
```
PostListItem
```jsx harmony
import React, {Component} from 'react';

import './post-list-item.css'

export default class PostListItem extends Component {
    constructor(props) {
        super(props);
        this.state = {
            important: false,
            like: false
        };
        this.onImportant = this.onImportant.bind(this);
        this.onLike = this.onLike.bind(this);
    }

    onImportant() {
        this.setState(({important}) => ({
            important: !important
        }))
    }

    onLike() {
        this.setState(({like}) => ({
            like: !like
        }))
    }

    render() {
        const {label, onDelete} = this.props;
        const {important, like} = this.state;
        let classNames = 'app-list-item d-flex justify-content-between';

        if (important) {
            classNames +=' important';
        }

        if (like) {
            classNames +=' like';
        }

        return (
            <div className={classNames}>
                <span 
                className="app-list-item-label"
                onClick={this.onLike}>
                    {label}
                </span>
                <div className="d-flex justify-content-center align-items-center">
                    <button 
                    type="button" 
                    className="btn-star btn-sm"
                    onClick={this.onImportant}>
                        <i className="fa fa-star"></i>
                    </button>
                    <button 
                        type="button" 
                        className="btn-trash btn-sm"
                        onClick={onDelete}>
                        <i className="fa fa-trash-o"></i>
                    </button>
                    <i className="fa fa-heart"></i>
                </div>
            </div>
        )
        }
}
```
PostAddForm
```jsx harmony
import React, {Component} from 'react';

import './post-add-form.css'

export default class PostAddForm extends Component {
    render() {
        return (
            <div className="bottom-panel d-flex">
                <input
                    type="text"
                    placeholder="О чем вы думаете сейчас?"
                    className="form-control new-post-label"
                />
                <button
                    type="submit"
                    className="btn btn-outline-secondary"
                    onClick={() => this.props.onAdd('Hello')}>
                    Добавить</button>
            </div>
        )
    }
}
```
    
  **[⬆ Наверх](#top)**
	
74. ### <a name="74"></a> Контролируемымие и Неконтролируемымие компоненты

 Рекомендуется использовать контролируемые компоненты для реализации форм. В контролируемом компоненте данные формы обрабатываются компонентом React. Альтернативой являются неконтролируемые компоненты, где данные формы обрабатываются самим DOM.

### Контролируемые компоненты

В контролируемом компоненте данные формы обрабатываются состоянием внутри компонента. Состояние внутри компонента служит «единственным источником правды» для элементов ввода, которые отображаются компонентом.

```jsx harmony
import React, { useState } from 'react'
import './Controlled.css'

export function Controlled() {
  const [name, setName] = useState('')
  const [notes, setNotes] = useState('')
  const [framework, setFramework] = useState('')

  function handleNameChange(event) {
    setName(event.target.value)
  }

  function handleNotesChange(event) {
    setNotes(event.target.value)
  }

  function handleFrameworkChange(event) {
    setFramework(event.target.value)
  }

  function handleSubmit(event) {
    console.log('Controlled', {
      name,
      notes,
      framework,
    })
    event.preventDefault()
  }

  return (
    <form onSubmit={handleSubmit} className="controlled__form-container">
      <h1>Controlled</h1>
      <label>
        Name:
        <input type="text" value={name} onChange={handleNameChange} />
      </label>
      <label>
        Notes:
        <textarea value={notes} onChange={handleNotesChange} />
      </label>
      <label>
        Your favorite framework:
        <select value={framework} onChange={handleFrameworkChange}>
          <option value="" disabled></option>
          <option value="react">React</option>
          <option value="angular">Angular</option>
          <option value="vue">Vue</option>
          <option value="svelte">Svelte</option>
        </select>
      </label>
      <input type="submit" value="Submit" />
    </form>
  )
}
```


`input classes простая реализация`

```jsx harmony
import {Component} from 'react';
import "./styles.css";

export default class NameForm extends Component {
  constructor(props) {
    super(props);
    this.state = {value: ''};

    this.handleChange = this.handleChange.bind(this);
  }

  handleChange(event) {
    this.setState({value: event.target.value});
  }

  render() {
    return (
      <form>
        <label>
          <input type="text" value={this.state.value} onChange={this.handleChange} />
        </label>
        <input type="button" value="Отправить" />
        {this.state.value}
      </form>
    );
  }
}
```

`input`

```jsx harmony
class NameForm extends React.Component {
  constructor(props) {
    super(props);
    this.state = {value: ''};

    this.handleChange = this.handleChange.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
  }

  handleChange(event) {
    this.setState({value: event.target.value});
  }

  handleSubmit(event) {
    alert('Отправленное имя: ' + this.state.value);
    event.preventDefault();
  }

  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <label>
          Имя:
          <input type="text" value={this.state.value} onChange={this.handleChange} />
        </label>
        <input type="submit" value="Отправить" />
      </form>
    );
  }
}
```

Поскольку атрибут value установлен в нашем элементе формы, отображаемое значение всегда будет находится в this.state.value, что делает состояние React источником данных (истины). Поскольку handleChange выполняется при каждом нажатии клавиши, что приводит к обновлению состояния React, то отображаемое значение будет обновляться по мере ввода данных пользователем.

В контролируемом компоненте каждое изменение состояния будет связано с функцией-обработчиком. Это упрощает изменение или проверку входных данных пользователя. Например, если мы хотим, чтобы входные имена записывались заглавными буквами, мы могли бы написать handleChange таким образом:
```js
handleChange(event) {
  this.setState({value: event.target.value.toUpperCase()});
}
```

`textarea`

В React `<textarea>` использует атрибут value. Таким образом, форму с <textarea> можно написать почти тем же способом, что и форму с однострочным <input>:
	
```jsx harmony
class EssayForm extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      value: 'Пожалуйста, напишите эссе о своём любимом DOM-элементе.'
    };

    this.handleChange = this.handleChange.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
  }

  handleChange(event) {
    this.setState({value: event.target.value});
  }

  handleSubmit(event) {
    alert('Отправленное эссе: ' + this.state.value);
    event.preventDefault();
  }

  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <label>
          Эссе:
          <textarea value={this.state.value} onChange={this.handleChange} />
        </label>
        <input type="submit" value="Отправить" />
      </form>
    );
  }
}
```

	
`select`
	
Пункт списка «Кокос» выбран по умолчанию из-за установленного атрибута selected. React вместо этого атрибута использует value в корневом теге select. В управляемом компоненте так удобнее, потому что обновлять значение нужно только в одном месте (state). Пример:
	
```jsx harmony
class FlavorForm extends React.Component {
  constructor(props) {
    super(props);
    this.state = {value: 'coconut'};

    this.handleChange = this.handleChange.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
  }

  handleChange(event) {
    this.setState({value: event.target.value});
  }

  handleSubmit(event) {
    alert('Ваш любимый вкус: ' + this.state.value);
    event.preventDefault();
  }

  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <label>
          Выберите ваш любимый вкус:
          <select value={this.state.value} onChange={this.handleChange}>
            <option value="grapefruit">Грейпфрут</option>
            <option value="lime">Лайм</option>
            <option value="coconut">Кокос</option>
            <option value="mango">Манго</option>
          </select>
        </label>
        <input type="submit" value="Отправить" />
      </form>
    );
  }
}	
```	

	
`Обработка нескольких элементов input`
	
Когда вам нужно обрабатывать несколько контролируемых элементов input, вы можете добавить атрибут name на каждый элемент и позволить функции-обработчику выбрать, что делать, исходя из значения event.target.name

```jsx harmony	
class Reservation extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      isGoing: true,
      numberOfGuests: 2
    };

    this.handleInputChange = this.handleInputChange.bind(this);
  }

  handleInputChange(event) {
    const target = event.target;
    const value = target.type === 'checkbox' ? target.checked : target.value;
    const name = target.name;

    this.setState({
      [name]: value
    });
  }

  render() {
    return (
      <form>
        <label>
          Я собираюсь пойти:
          <input
            name="isGoing"
            type="checkbox"
            checked={this.state.isGoing}
            onChange={this.handleInputChange} />
        </label>
        <br />
        <label>
          Количество гостей:
          <input
            name="numberOfGuests"
            type="number"
            value={this.state.numberOfGuests}
            onChange={this.handleInputChange} />
        </label>
      </form>
    );
  }
}	
```
	

### Неконтролируемые компоненты

Неконтролируемые компоненты действуют больше как традиционные элементы формы HTML. Данные для каждого элемента ввода хранятся в DOM, а не в компоненте. Вместо того, чтобы писать обработчик событий для всех ваших обновлений состояния, вы используете ref для получения значений из DOM.

Что такое ref из документации React :

Ссылки предоставляют способ доступа к узлам DOM или элементам React, созданным в методе рендеринга.

```jsx harmony
import React, { useRef } from 'react'
import './Uncontrolled.css'

export function Uncontrolled() {
  const nameInput = useRef()
  const notesTextarea = useRef()
  const frameworkSelect = useRef()

  function handleSubmit(event) {
    console.log('Uncontrolled', {
      name: nameInput.current.value,
      notes: notesTextarea.current.value,
      framework: frameworkSelect.current.value,
    })
    event.preventDefault()
  }

  return (
    <form onSubmit={handleSubmit} className="uncontrolled__form-container">
      <h1>Uncontrolled</h1>
      <label>
        Name:
        <input type="text" ref={nameInput} defaultValue="" />
      </label>
      <label>
        Notes:
        <textarea ref={notesTextarea} defaultValue="" />
      </label>
      <label>
        Your favorite framework:
        <select ref={frameworkSelect} defaultValue="">
          <option value="" disabled></option>
          <option value="react">React</option>
          <option value="angular">Angular</option>
          <option value="vue">Vue</option>
          <option value="svelte">Svelte</option>
        </select>
      </label>
      <input type="submit" value="Submit" />
    </form>
  )
}	
```	
	
	
```jsx harmony
import React, {Component} from 'react';

export default class NameForm extends Component {
  constructor(props) {
    super(props);

    this.input = React.createRef();
  }

  handleSubmit = (event) => {
    console.log('Отправленное имя: ' + this.input.current.value);
    event.preventDefault();
  }

  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <label>
          Имя:
          <input type="text" ref={this.input} />
        </label>
        <input type="submit" value="Отправить" />
      </form>
    );
  }
}	
```		

Если мы изменим контролируемый компонент, с которым мы работали выше, чтобы он стал неуправляемым компонентом, вот что мы получаем:
```jsx harmony
class NameForm extends React.Component {
  constructor(props) {
    super(props);
    this.handleSubmit = this.handleSubmit.bind(this);
    this.input = React.createRef();
  }

  handleSubmit(event) {
    alert('Отправленное имя: ' + this.input.current.value);
    event.preventDefault();
  }

  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <label>
          Имя:
          <input type="text" ref={this.input} />
        </label>
        <input type="submit" value="Отправить" />
      </form>
    );
  }
}
```
Вы можете видеть, что мы добавили конструктор в строке 4 и в нем мы создаем обработчик событий и создаем ref в this.input.

Мы снова ссылаемся на this.input в строке 19, где мы устанавливаем его как атрибут ref для элемента input. С этими частями, каждый раз, когда мы вводим текстовое поле, значение выводится в консоли.

	
Вместо того, чтобы писать обработчик события для каждого обновления состояния, вы можете использовать неуправляемый компонент и читать значения из DOM через реф.

Вот так, к примеру, обработчик неуправляемого компонента может получить имя от элемента input:
	
```jsx harmony
class NameForm extends React.Component {
  constructor(props) {
    super(props);
    this.handleSubmit = this.handleSubmit.bind(this);
    this.input = React.createRef();
  }

  handleSubmit(event) {
    alert('Отправленное имя: ' + this.input.current.value);
    event.preventDefault();
  }

  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <label>
          Имя:
          <input type="text" ref={this.input} />
        </label>
        <input type="submit" value="Отправить" />
      </form>
    );
  }
}	
```

### Тег поля загрузки файла
	
HTML-тег <input type="file"> позволяет пользователю выбрать один или несколько файлов из дискового устройства, чтобы загрузить их на сервер, либо управлять ими с помощью JavaScript через File API.
	
```jsx harmony
<input type="file" />
```
В React <input type="file"> всегда является неуправляемым компонентом, потому что его значение может быть установлено только пользователем, а не программным путём.

Для взаимодействия с файлами следует использовать File API. В следующем примере показано, как создать реф на DOM-узел, чтобы затем получить доступ к файлам в обработчике отправки формы:
	
```jsx harmony
class FileInput extends React.Component {
  constructor(props) {
    super(props);
    this.handleSubmit = this.handleSubmit.bind(this);
    this.fileInput = React.createRef();
  }
  handleSubmit(event) {
    event.preventDefault();
    alert(
      `Selected file - ${this.fileInput.current.files[0].name}`
    );
  }

  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <label>
          Upload file:
          <input type="file" ref={this.fileInput} />
        </label>
        <br />
        <button type="submit">Submit</button>
      </form>
    );
  }
}

ReactDOM.render(
  <FileInput />,
  document.getElementById('root')
);
```	
	
	
Несколько ключевых моментов относительно ссылок:

1. Ссылки создаются с использованием React.createRef().
2. Ссылки прикрепляются к элементам ввода с помощью атрибута ref соответствующего элемента.
3. Ссылки часто используются в качестве свойств экземпляра для компонента. Ссылка устанавливается в конструкторе (как показано выше), и значение доступно во всем компоненте.
4. Вы не можете использовать ссылки в функциональных компонентах, потому что экземпляр не создан.


Есть несколько хороших вариантов использования ссылок:

- Управление фокусом, выделением текста или воспроизведением мультимедиа.
- Запуск императивных анимаций.
- Интеграция со сторонними библиотеками DOM.
- Избегайте использования ссылок для всего, что может быть сделано декларативно.

	
### Ключевые моменты

1. По возможности используйте контролируемые компоненты.
2. Контролируемые компоненты не требуют элемента формы, чтобы считаться контролируемым компонентом.
3. Если у компонента есть входной элемент, имеющий атрибут value, связанный с состоянием, и обработчик события для обновления указанного состояния, он является контролируемым компонентом.
4. Для страниц с большим количеством элементов ввода работа с контролируемыми компонентами может быть обременительной.
5. Поток данных является однонаправленным в контролируемых компонентах, причем состояние внутри компонента выступает в качестве единственного источника правды.
6. Все изменения состояния в контролируемом компоненте должны выполняться через функцию setState.
7. Неконтролируемые компоненты хранят свои данные в DOM как традиционный элемент ввода HTML.
8. React.createRef() используется для создания переменных экземпляра внутри неконтролируемых конструкторов компонентов. Эти переменные затем связываются с элементами ввода через атрибут ref.
9. Ссылки не могут быть созданы и использованы на функциональных компонентах.
    
  **[⬆ Наверх](#top)**
	
75. ### <a name="75"></a> Иммутабельность состояния и собственные события. Пример кода

 App -> 	EmployersList -> EmployersListItem 
	
App -> 	EmployersAddForm
	
	
App.js
```jsx harmony
import {Component} from 'react';
import AppInfo from '../app-info/app-info';
import SearchPanel from '../search-panel/search-panel';
import AppFilter from '../app-filter/app-filter';
import EmployersList from '../employers-list/employers-list';
import EmployersAddForm from '../employers-add-form/employers.add-form';

import './app.css';


class App extends Component {
	constructor(props) {
		super(props);
		this.state = {
			data: [
				{name: 'Spacy', salary: 800, increase: true, id: 1},
				{name: 'John', salary: 1000, increase: false, id: 2},
				{name: 'Mary', salary: 1350, increase: false, id: 3}
			]
		}
		this.maxId = 4;
	}

	deleteItem = (id) => {
		this.setState(({data}) => {
			const index = data.findIndex(elem => elem.id === id);

			// const before = data.slice(0, index);
			// const after = data.slice(index + 1);
			//
			// const newArr = [...before, ...after];

			// или вот так =>

			const newArr = data.filter(item => item.id !== id)

			return {
				data: newArr
			}
		})
	}

	addItem = (name, salary) => {
		const newItem = {
			name,
			salary,
			increase: false,
			id: this.maxId++
		}
		this.setState(({data}) => {
			const newArr = [...data, newItem];
			return {
				data: newArr
			}
		})
	}

	render() {

		return (
			<div className='app'>
				<AppInfo/>

				<div className="search-panel">
					<SearchPanel/>
					<AppFilter/>
				</div>

				<EmployersList data={this.state.data} onDelete={this.deleteItem}/>
				<EmployersAddForm onAdd={this.addItem}/>
			</div>
		);
	}
}

export default App;	
```	

EmployersList.js	
```jsx harmony
import EmployersListItem from '../employers-list-item/employers-list-item';

import './employers-list.css';

const EmployersList = ({data, onDelete}) => {

	const elements = data.map(item => {
		const {id, ...itemProps} = item;
		return (
			<EmployersListItem key={id} {...itemProps} onDelete={() => onDelete(id)}/>
		)
	})

	return (
		<ul className="app-list list-group">
			{elements}
		</ul>
	)
}

export default EmployersList;	
```	
	
EmployersListItem.js				
```jsx harmony

import './employers-list-item.css'
import {Component} from 'react';

class EmployersListItem extends Component {
	constructor(props) {
		super(props);
		this.state = {
			increase: false
		}
	}

	onIncrease = () => {
		this.setState(({increase}) => ({
			increase: !increase
		}))
	}

	onRise = () => {
		this.setState(({rise}) => ({
			rise: !rise
		}))
	}

	render() {
		const {name, salary, onDelete} = this.props;
		const {increase, rise} = this.state;

		let classNames = 'list-group-item d-flex justify-content-between'
		if (increase) {
			classNames += ' increase';
		}
		if (rise) {
			classNames += ' like'
		}

		return (
			<li className={classNames}>
				<span className='list-group-item-label' onClick={this.onRise}>{name}</span>
				<input type="text" className='list-group-item-input' defaultValue={salary + '$'}/>
				<div className='d-flex justify-content align-items-center'>
					<button type='button'
									className='btn-cookie btn-sm' onClick={this.onIncrease}>
						<i className='fas fa-cookie'></i>
					</button>
					<button type='button'
									className='btn-trash btn-sm'
					onClick={onDelete}>
						<i className='fas fa-trash'></i>
					</button>
					<i className='fas fa-star'></i>
				</div>
			</li>
		)
	}
}

export default EmployersListItem;				
```				
				
EmployersAddForm.js
```jsx harmony
import {Component} from 'react';
import './employers-add-form.css';

class EmployersAddForm extends Component {
	constructor(props) {
		super(props);
		this.state = {
			name: '',
			salary: ''
		}
	}

	onValueChange = (e) => {
		this.setState({
			[e.target.name] : e.target.value
		})
	}

	onSubmit = (e) => {
		e.preventDefault();
		this.props.onAdd(this.state.name, this.state.salary);
		this.setState({
			name: '',
			salary: ''
		})
	}

	render() {
		const {name, salary} = this.state;

		return (
			<div className="app-add-form">
				<h3>Добавьте нового сотрудника</h3>
				<form
					className="add-form d-flex"
					onSubmit={this.onSubmit}>
					<input type="text"
								 className="form-control new-post-label"
								 placeholder="Как его зовут?"
								 name='name'
								 value={name}
					onChange={this.onValueChange}/>
					<input type="number"
								 className="form-control new-post-label"
								 placeholder="З/П в $?"
								 name='salary'
								 value={salary}
					onChange={this.onValueChange}/>

					<button type="submit"
									className="btn btn-outline-light">Добавить
					</button>
				</form>
			</div>
		)
	}
}

export default EmployersAddForm;				
```
    
  **[⬆ Наверх](#top)**
	
76. ### <a name="76"></a> Подъём состояния. Пример кода

 App -> EmployersList -> EmployersListItem 
	
App -> EmployersAddForm
				
App ->	AppInfo

				
App
```jsx harmony
import {Component} from 'react';
import AppInfo from '../app-info/app-info';
import SearchPanel from '../search-panel/search-panel';
import AppFilter from '../app-filter/app-filter';
import EmployersList from '../employers-list/employers-list';
import EmployersAddForm from '../employers-add-form/employers.add-form';

import './app.css';


class App extends Component {
	constructor(props) {
		super(props);

		this.state = {
			data: [
				{name: 'Spacy', salary: 800, increase: true, rise: true, id: 1},
				{name: 'John', salary: 1000, increase: false, rise: false, id: 2},
				{name: 'Mary', salary: 1350, increase: false, rise: false, id: 3}
			]
		}
		this.maxId = 4;
	}

	deleteItem = (id) => {
		this.setState(({data}) => {
			const index = data.findIndex(elem => elem.id === id);

			// const before = data.slice(0, index);
			// const after = data.slice(index + 1);
			//
			// const newArr = [...before, ...after];

			// или вот так =>

			const newArr = data.filter(item => item.id !== id)

			return {
				data: newArr
			}
		})
	}

	addItem = (name, salary) => {
		const newItem = {
			name,
			salary,
			increase: false,
			rise: false,
			id: this.maxId++
		}
		this.setState(({data}) => {
			const newArr = [...data, newItem];
			return {
				data: newArr
			}
		})
	}

	onToggleIncrease = (id) => {
		// this.setState(({data}) => {
		// 	const index = data.findIndex(elem => elem.id === id);
		//
		// 	const old = data[index];
		// 	const newItem = {...old, increase: !old.increase};
		// 	const newArr = [...data.slice(0, index), newItem, ...data.slice(index + 1)];
		//
		// 	return {
		// 		data: newArr
		// 	}
		// })

		// другой вариант

		this.setState(({data}) => ({
			data: data.map(item => {
				if (item.id === id) {
					return {...item, increase: !item.increase}
				}
				return item;
			})
		}))
	}

	onToggleRise = (id) => {
		this.setState(({data}) => ({
			data: data.map(item => {
				if (item.id === id) {
					return {...item, rise: !item.rise}
				}
				return item;
			})
		}))
	}

	render() {
		const employers = this.state.data.length;
		const increased = this.state.data.filter(item => item.increase).length;

		return (
			<div className='app'>
				<AppInfo employers={employers} increased={increased}/>

				<div className="search-panel">
					<SearchPanel/>
					<AppFilter/>
				</div>

				<EmployersList
					data={this.state.data}
					onDelete={this.deleteItem}
					onToggleIncrease={this.onToggleIncrease}
					onToggleRise={this.onToggleRise}
				/>
				<EmployersAddForm onAdd={this.addItem}/>
			</div>
		);
	}
}

export default App;                
```                

EmployersList
```jsx harmony
 import EmployersListItem from '../employers-list-item/employers-list-item';

import './employers-list.css';

const EmployersList = ({data, onDelete, onToggleIncrease, onToggleRise}) => {

	const elements = data.map(item => {
		const {id, ...itemProps} = item;
		return (
			<EmployersListItem
				key={id}
				{...itemProps}
				onDelete={() => onDelete(id)}
				onToggleIncrease={() => onToggleIncrease(id)}
				onToggleRise={() => onToggleRise(id)}
			/>
		)
	})

	return (
		<ul className="app-list list-group">
			{elements}
		</ul>
	)
}

export default EmployersList;               
```                

EmployersListItem
```jsx harmony
 import './employers-list-item.css'

const EmployersListItem = (props) => {

	const {name, salary, onDelete, onToggleIncrease, onToggleRise, increase, rise} = props;

	let classNames = 'list-group-item d-flex justify-content-between'
	if (increase) {
		classNames += ' increase';
	}
	if (rise) {
		classNames += ' like'
	}

	return (
		<li className={classNames}>
			<span className='list-group-item-label' onClick={onToggleRise}>{name}</span>
			<input type="text" className='list-group-item-input' defaultValue={salary + '$'}/>
			<div className='d-flex justify-content align-items-center'>
				<button type='button'
								className='btn-cookie btn-sm' onClick={onToggleIncrease}>
					<i className='fas fa-cookie'></i>
				</button>
				<button type='button'
								className='btn-trash btn-sm'
								onClick={onDelete}>
					<i className='fas fa-trash'></i>
				</button>
				<i className='fas fa-star'></i>
			</div>
		</li>
	)
}

export default EmployersListItem;               
```                

EmployersAddForm
```jsx harmony
import {Component} from 'react';
import './employers-add-form.css';

class EmployersAddForm extends Component {
	constructor(props) {
		super(props);
		this.state = {
			name: '',
			salary: ''
		}
	}

	onValueChange = (e) => {
		this.setState({
			[e.target.name] : e.target.value
		})
	}

	onSubmit = (e) => {
		e.preventDefault();
		if (this.state.name.length < 3 || !this.state.salary) return;
		this.props.onAdd(this.state.name, this.state.salary);
		this.setState({
			name: '',
			salary: ''
		})
	}

	render() {
		const {name, salary} = this.state;

		return (
			<div className="app-add-form">
				<h3>Добавьте нового сотрудника</h3>
				<form
					className="add-form d-flex"
					onSubmit={this.onSubmit}>
					<input type="text"
								 className="form-control new-post-label"
								 placeholder="Как его зовут?"
								 name='name'
								 value={name}
								 onChange={this.onValueChange}/>
					<input type="number"
								 className="form-control new-post-label"
								 placeholder="З/П в $?"
								 name='salary'
								 value={salary}
								 onChange={this.onValueChange}/>

					<button type="submit"
									className="btn btn-outline-light">Добавить
					</button>
				</form>
			</div>
		)
	}
}

export default EmployersAddForm;                
```                

AppInfo
```jsx harmony
import './app-info.css';

const AppInfo = ({increased, employers}) => {
	return (
		<div className='app-info'>
			<h1>Учет сотрудников в компании Nill</h1>
			<h2>Общее число сотрудников: {employers}</h2>
			<h2>Премию получат: {increased}</h2>
		</div>
	)
}

export default AppInfo;                
```
    
  **[⬆ Наверх](#top)**
	
77. ### <a name="77"></a> Реализуем поиск и фильтры. Пример кода

 App -> SearchPanel
                
App -> AppFilter
 
App                
```jsx
import { Component } from 'react';

import AppInfo from '../app-info/app-info';
import SearchPanel from '../search-panel/search-panel';
import AppFilter from '../app-filter/app-filter';
import EmployeesList from '../employees-list/employees-list';
import EmployeesAddForm from '../employees-add-form/employees-add-form';

import './app.css';

class App extends Component {
    constructor(props) {
        super(props);
        this.state = {
            data: [
                {name: 'John C.', salary: 800, increase: false, rise: true, id: 1},
                {name: 'Alex M.', salary: 3000, increase: true, rise: false, id: 2},
                {name: 'Carl W.', salary: 5000, increase: false, rise: false, id: 3}
            ],
            term: '', 
            filter: 'all'
        }
        this.maxId = 4;
    }

    deleteItem = (id) => {
        this.setState(({data}) => {
            return {
                data: data.filter(item => item.id !== id)
            }
        })
    }

    // Да, пока могут добавляться пустые пользователи. Мы это еще исправим
    addItem = (name, salary) => {
        const newItem = {
            name, 
            salary,
            increase: false,
            rise: false,
            id: this.maxId++
        }
        this.setState(({data}) => {
            const newArr = [...data, newItem];
            return {
                data: newArr
            }
        });
    }

    onToggleProp = (id, prop) => {
        this.setState(({data}) => ({
            data: data.map(item => {
                if (item.id === id) {
                    return {...item, [prop]: !item[prop]}
                }
                return item;
            })
        }))
    }

    searchEmp = (items, term) => {
        if (term.length === 0) {
            return items;
        }

        return items.filter(item => {
            return item.name.indexOf(term) > -1
        })
    }

    onUpdateSearch = (term) => {
        this.setState({term});
    }

    filterPost = (items, filter) => {
        switch (filter) {
            case 'rise':
                return items.filter(item => item.rise);
            case 'moreThen1000':
                return items.filter(item => item.salary > 1000);
            default:
                return items
        }
    }

    onFilterSelect = (filter) => {
        this.setState({filter});
    }

    render() {
        const {data, term, filter} = this.state;
        const employees = this.state.data.length;
        const increased = this.state.data.filter(item => item.increase).length;
        const visibleData = this.filterPost(this.searchEmp(data, term), filter);

        return (
            <div className="app">
                <AppInfo employees={employees} increased={increased}/>
    
                <div className="search-panel">
                    <SearchPanel onUpdateSearch={this.onUpdateSearch}/>
                    <AppFilter filter={filter} onFilterSelect={this.onFilterSelect}/>
                </div>
                
                <EmployeesList 
                    data={visibleData}
                    onDelete={this.deleteItem}
                    onToggleProp={this.onToggleProp}/>
                <EmployeesAddForm onAdd={this.addItem}/>
            </div>
        );
    }
}

export default App;                
```                
 
SearchPanel
```jsx
import { Component } from 'react';
import './search-panel.css';

class SearchPanel extends Component {
    constructor(props) {
        super(props);
        this.state = {
            term: ''
        }
    }

    onUpdateSearch = (e) => {
        const term = e.target.value;
        this.setState({term});
        this.props.onUpdateSearch(term)
    }

    render() {
        return (
            <input type="text"
                    className="form-control search-input"
                    placeholder="Найти сотрудника"
                    value={this.state.term}
                    onChange={this.onUpdateSearch}/>
        )
    }
}

export default SearchPanel;              
```                

AppFilter
```jsx
import "./app-filter.css";

const AppFilter = (props) => {
    const buttonsData = [
        {name: 'all', label: 'Все сотрудники'},
        {name: 'rise', label: 'На повышение'},
        {name: 'moreThen1000', label: 'З/П больше 1000$'}
    ];

    const buttons = buttonsData.map(({name, label}) => {
        const active = props.filter === name;
        const clazz = active ? 'btn-light' : 'btn-outline-light';
        return (
            <button type="button"
                    className={`btn ${clazz}`}
                    key={name}
                    onClick={() => props.onFilterSelect(name)}>
                    {label}
            </button>
        )
    })

    return (
        <div className="btn-group">
            {buttons}
        </div>
    )
}

export default AppFilter;                
```
    
  **[⬆ Наверх](#top)**
	
78. ### <a name="78"></a> Реализация кастомных форм

 
    
  **[⬆ Наверх](#top)**
	
79. ### <a name="79"></a> Всплытие событий

Когда на элементе происходит событие, обработчики сначала срабатывают на нём, потом на его родителе, затем выше и так далее, вверх по цепочке предков.

Например, есть 3 вложенных элемента FORM > DIV > P с обработчиком на каждом:
```js
<form onclick="alert('form')">FORM
  <div onclick="alert('div')">DIV
    <p onclick="alert('p')">P</p>
  </div>
</form>

Клик по внутреннему <p> вызовет обработчик onclick:
1. Сначала на самом <p>.
2. Потом на внешнем <div>.
3. Затем на внешнем <form>.
4. И так далее вверх по цепочке до самого document.				
```
				
Когда событие срабатывает на элементе DOM, оно попытается обработать событие (если привязан обработчик), затем событие всплывет вверх к своему родителю и это повторится снова. Подобное всплытие проходит по всем предкам элемента вплоть до document. Всплытие событий является механизмом, на котором основано делегирование событий.		
				
- Фаза погружения (capturing phase) – событие сначала идёт сверху вниз.
- Фаза цели (target phase) – событие достигло целевого(исходного) элемента.
- Фаза всплытия (bubbling stage) – событие начинает всплывать.

При наступлении события – самый глубоко вложенный элемент, на котором оно произошло, помечается как «целевой» (event.target).

- Затем событие сначала двигается вниз от корня документа к event.target, по пути вызывая обработчики, поставленные через addEventListener(...., true), где true – это сокращение для {capture: true}.
- Далее обработчики вызываются на целевом элементе.
- Далее событие двигается от event.target вверх к корню документа, по пути вызывая обработчики, поставленные через on<event> и addEventListener без третьего аргумента или с третьим аргументом равным false.
	
Каждый обработчик имеет доступ к свойствам события event:
	
- event.target – самый глубокий элемент, на котором произошло событие.
- event.currentTarget (=this) – элемент, на котором в данный момент сработал обработчик (тот, на котором «висит» конкретный обработчик)
- event.eventPhase – на какой фазе он сработал (погружение=1, фаза цели=2, всплытие=3).
	
Любой обработчик может остановить событие вызовом event.stopPropagation(), но делать это не рекомендуется, так как в дальнейшем это событие может понадобиться, иногда для самых неожиданных вещей.

В современной разработке стадия погружения используется очень редко, обычно события обрабатываются во время всплытия. И в этом есть логика.
    
  **[⬆ Наверх](#top)**
	
80. ### <a name="80"></a> props.children

Некоторые компоненты не знают своих потомков заранее. Это особенно характерно для таких компонентов, как Sidebar или Dialog, которые представляют из себя как бы «коробку», в которую можно что-то положить.

Для таких компонентов мы рекомендуем использовать специальный проп children, который передаст дочерние элементы сразу на вывод:
```jsx harmony
function FancyBorder(props) {
  return (
    <div className={'FancyBorder FancyBorder-' + props.color}>
      {props.children}
    </div>
  );
}

function WelcomeDialog() {
  return (
    <FancyBorder color="blue">
      <h1 className="Dialog-title">
        Welcome
      </h1>
      <p className="Dialog-message">
        Thank you for visiting our spacecraft!
      </p>
    </FancyBorder>
  );
}

ReactDOM.render(
  <WelcomeDialog />,
  document.getElementById('root')
);        
``` 
				
Всё, что находится внутри JSX-тега <FancyBorder>, передаётся в компонент FancyBorder через проп children. Поскольку FancyBorder рендерит {props.children} внутри <div>, все переданные элементы отображаются в конечном выводе.

Иногда в компоненте необходимо иметь несколько мест для вставки. В таком случае можно придумать свой формат, а не использовать children:
				
```jsx harmony
function Contacts() {
  return <div className="Contacts" />;
}

function Chat() {
  return <div className="Chat" />;
}

function SplitPane(props) {
  return (
    <div className="SplitPane">
      <div className="SplitPane-left">
        {props.left}
      </div>
      <div className="SplitPane-right">
        {props.right}
      </div>
    </div>
  );
}

function App() {
  return (
    <SplitPane
      left={
        <Contacts />
      }
      right={
        <Chat />
      } />
  );
}

ReactDOM.render(
  <App />,
  document.getElementById('root')
);				
```								
    
  **[⬆ Наверх](#top)**
	
81. ### <a name="81"></a> Hoisting - Поднятие

 Поднятие (hoisting) - это термин, используемый для объяснения поведения объявлений переменных в вашем коде. Переменные, объявленные или инициализированные при помощи ключевого слова var, будут перемещены в верхнюю часть текущей области, что мы называем "поднятием". Однако, "поднимается" только объявление переменной, присвоение значения (если оно имеется) останется на прежнем месте.

Обратите внимание, что объявление фактически не перемещается - движок JavaScript анализирует объявления во время компиляции и узнает о объявлениях и их областях видимости. Просто легче понять подобное поведение, представляя объявления как перемещение наверх своей области видимости. Давайте рассмотрим несколько примеров.

```js	
// объявления переменных через var поднимаются.
console.log(foo); // undefined
var foo = 1;
console.log(foo); // 1

// объявления переменных через let/const НЕ поднимаются.
console.log(bar); // ReferenceError: bar is not defined
let bar = 2;
console.log(bar); // 2
```
	
При объявлении функции ее тело поднимается наверх, в то время как у функциональных выражений (когда переменной присваивается функция) поднимается только переменная.
```js
// Объявление функции
console.log(foo); // [Function: foo]
foo(); // 'FOOOOO'
function foo() {
  console.log('FOOOOO');
}
console.log(foo); // [Function: foo]

// Функциональное выражение
console.log(bar); // undefined
bar(); // Uncaught TypeError: bar is not a function
var bar = function () {
  console.log('BARRRR');
};
console.log(bar); // [Function: bar]	
```
	
Поднятие или hoisting — это механизм в JavaScript, в котором переменные и объявления функций, передвигаются вверх своей области видимости перед тем, как код будет выполнен.

Стоит отметить то, что механизм “поднятия” передвигает только объявления функции или переменной. Назначения переменным остаются на своих местах.

Как следствие, это означает то, что совершенно неважно где были объявлены функция или переменные, все они передвигаются вверх своей области видимости, вне зависимости от того локальная она или же глобальная.

Запомните: поднимаются только функциональные выражения и переменные, объявленные с помощью ключевого слова «var». Обычные функции и стрелочные функции, а также переменные, объявленные с помощью ключевых слов «let» и «const» не поднимаются.

```jsx harmony
console.log(y)
y = 1
console.log(y)
console.log(greet('Mark'))

function greet(name) {
    return 'Hello ' + name + '!'
}

var y
```
Получаем undefined, 1 и 'Hello Mark!'.

Вот как выглядит фаза компиляции:
```jsx harmony
function greet(name) {
    return 'Hello ' + name + '!'
}

var y // присваивается undefined

// ожидается завершение фазы компиляции

// затем начинается фаза выполнения
/*
console.log(y)
y = 1
console.log(y)
console.log(greet('Mark'))
*/
```
    
  **[⬆ Наверх](#top)**
	
82. ### <a name="82"></a> Context и useContext пример

### Example useContext =>

App.jsx				
```jsx harmony
import React from 'react';
import { useState } from 'react';
import { Routes, Route } from 'react-router-dom';

import Header from './components/Header';
import Home from './pages/Home';
import Cart from './pages/Cart';
import NotFound from './pages/NotFound';

import './scss/app.scss';

export const SearchContext = React.createContext('');

function App() {
  const [searchValue, setSearchValue] = useState('');

  return (
    <div className='wrapper'>
      <SearchContext.Provider value={{ searchValue, setSearchValue }}>
        <Header />
        <div className='content'>
          <Routes>
            <Route path='/' element={<Home />} />
            <Route path='/cart' element={<Cart />} />
            <Route path='*' element={<NotFound />} />
          </Routes>
        </div>
      </SearchContext.Provider>
    </div>
  );
}

export default App;				
```				

Home.jsx
```jsx harmony
import React from 'react';
import { useState, useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { setCategoryId } from '../redux/slices/filterSlice';

import Categories from '../components/Categories';
import Sort from '../components/Sort';
import PizzaBlock from '../components/PizzaBlock/PizzaBlock';
import Skeleton from '../components/PizzaBlock/Skeleton';
import Pagination from '../components/Pagination/Pagination';
import { SearchContext } from '../App';

const Home = () => {
  const categoryId = useSelector((state) => state.filter.categoryId);
  const sortType = useSelector((state) => state.filter.sort.sortProperty);
  const dispatch = useDispatch();

  const { searchValue } = React.useContext(SearchContext);
  const [items, setItems] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const [currentPage, setCurrentPage] = useState(1);

  const onChangeCategory = (id) => {
    dispatch(setCategoryId(id));
  };

  useEffect(() => {
    setIsLoading(true);

    const sortBy = sortType.replace('-', '');
    const order = sortType.includes('-') ? 'asc' : 'desc';
    const category = categoryId > 0 ? `category=${categoryId}` : '';
    const search = searchValue ? `&search=${searchValue}` : '';

    fetch(
      `https://62becee20bc9b125615fbcbe.mockapi.io/items?page=${currentPage}&limit=4&${category}&sortBy=${sortBy}&order=${order}${search}`
    )
      .then((res) => res.json())
      .then((json) => {
        setItems(json);
        setIsLoading(false);
      });
    window.scrollTo(0, 0);
  }, [categoryId, sortType, searchValue, currentPage]);

  // Вариант фильтрации когда даныые приходят с бэка

  const pizzas = items.map((pizzaObj) => (
    <PizzaBlock key={pizzaObj.id} {...pizzaObj} />
  ));

  const skeletons = [...new Array(6)].map((_, index) => (
    <Skeleton key={index} />
  ));

  return (
    <div className='container'>
      <div className='content__top'>
        <Categories value={categoryId} onChangeCategory={onChangeCategory} />
        <Sort  />
      </div>
      <h2 className='content__title'>Все пиццы</h2>
      <div className='content__items'>{isLoading ? skeletons : pizzas}</div>
      <Pagination onChangePage={(number) => setCurrentPage(number)} />
    </div>
  );
};

export default Home;				
```
				
Search.jsx
```jsx harmony
import React from 'react';
import { SearchContext } from '../../App';

import styles from './Search.module.scss';

const Search = () => {
  const {searchValue, setSearchValue} = React.useContext(SearchContext);

  return (
    <div className={styles.root}>
      <svg
        className={styles.icon}
        height='512px'
        id='Layer_1'
        version='1.1'
        viewBox='0 0 512 512'
        width='512px'
        xmlns='http://www.w3.org/2000/svg'
      >
        <path d='M448.3,424.7L335,311.3c20.8-26,33.3-59.1,33.3-95.1c0-84.1-68.1-152.2-152-152.2c-84,0-152,68.2-152,152.2  s68.1,152.2,152,152.2c36.2,0,69.4-12.7,95.5-33.8L425,448L448.3,424.7z M120.1,312.6c-25.7-25.7-39.8-59.9-39.8-96.3  s14.2-70.6,39.8-96.3S180,80,216.3,80c36.3,0,70.5,14.2,96.2,39.9s39.8,59.9,39.8,96.3s-14.2,70.6-39.8,96.3  c-25.7,25.7-59.9,39.9-96.2,39.9C180,352.5,145.8,338.3,120.1,312.6z' />
      </svg>
      <input
        value={searchValue}
        onChange={(e) => setSearchValue(e.target.value)}
        className={styles.input}
        placeholder='Поиск пиццы...'
      />
      {searchValue && (
        <svg
          onClick={() => setSearchValue('')}
          className={styles.clearIcon}
          height='48'
          viewBox='0 0 48 48'
          width='48'
          xmlns='http://www.w3.org/2000/svg'
        >
          <path d='M38 12.83l-2.83-2.83-11.17 11.17-11.17-11.17-2.83 2.83 11.17 11.17-11.17 11.17 2.83 2.83 11.17-11.17 11.17 11.17 2.83-2.83-11.17-11.17z' />
          <path d='M0 0h48v48h-48z' fill='none' />
        </svg>
      )}
    </div>
  );
};

export default Search;				
```				
				
				
### Example Context =>				
				
dataContext.js				
```jsx harmony
import {createContext} from 'react';

const dataContext = createContext({
	mail: "name@example.com",
	text: 'some text',
	forceChangeMail: () => {}
});

export default dataContext;				
```
InputComponent.js				
```jsx harmony
import {useContext} from 'react';
import dataContext from './ConContext';

const InputComponent = () => {

	const context = useContext(dataContext);

	return (
		<input
			value={context.mail}
			type="email"
			className='form-control'
			placeholder='name@example.com'
			onFocus={context.forceChangeMail}
		/>
	)
}

export default InputComponent;


/* class InputComponent extends Component {

  static contextType = dataContext;

  render() {
    return (
      <Consumer>
        {
          value => {
            return (
              <input
                  value={value.mail}
                  type="email"
                  className='form-control'
                  placeholder='name@example.com' />

            )
          }
        }
      </Consumer>


      // <input
      //   value={this.context.mail}
      //   type="email"
      //   className='form-control'
      //   placeholder='name@example.com' />

    )
  }
} */

// InputComponent.contextType = dataContext;				
```	
Form.js				
```jsx harmone
import {Container} from 'react-bootstrap';
import InputComponent from './ConInput';

const Form = (props) => {

	console.log('update')

	return (
		<Container>
			<form className="w-50 border mt-5 p-3 m-auto">
				<div className="mb-3">
					<label htmlFor="exampleFormControlInput1" className="form-label mt-3">Email address</label>
					<InputComponent />
				</div>
				<div className="mb-3">
					<label htmlFor="exampleFormControlTextarea1" className="form-label">Example textarea</label>
					<textarea value={props.text} className="form-control" id="exampleFormControlTextarea1" rows="3"></textarea>
				</div>
			</form>
		</Container>
	)
}

export default Form;				
```
App.js				
```jsx harmony
import { useState } from 'react';
import './App.css';
import Form from './ConForm';
import dataContext from './ConContext';

const {Provider, Consumer} = dataContext;


function App() {
    const [data, setData] = useState({
        mail: "name@example.com",
        text: 'some text',
        forceChangeMail: forceChangeMail
    });

    function forceChangeMail() {
      setData({...data, mail: 'test@gmail.com'})
    }

    return (
        <Provider value={data}>
            <Form text={data.text}/>
            <button 
                onClick={() => setData({
                    mail: "second@example.com",
                    text: 'another text',
                    forceChangeMail: forceChangeMail
                })}>
                Click me
            </button>
        </Provider>
    );
}

export default App;				
```				
				
  **[⬆ Наверх](#top)**
				
83. ### <a name="83"></a> Передать данные между компонентами React

### parent -> child

parent				
```jsx harmony
import { useState } from 'react'
import Form from 'react-bootstrap/Form'

import Child from '../Child'
import './Parent.css'

export const Parent = () => {
  const [name, setName] = useState('')

  const handleNameChange = (event) => {
    setName(event.target.value)
  }

  return (
    <div className="parent__main-container">
      <p>
        <i>Parent component</i>
      </p>
      <Form>
        <Form.Group>
          <Form.Label>Name</Form.Label>
          <Form.Control
            type="text"
            placeholder="Enter name"
            onChange={handleNameChange}
          />
        </Form.Group>
      </Form>

      <Child name={name} />
    </div>
  )
}				
```				

child				
```jsx harmony
import './Child.css'

export const Child = ({ name }) => {
  return (
    <div className="child__main-container">
      <p>
        <i>Child component</i>
      </p>
      <span>Name is: {name || '<Not set>'}</span>
    </div>
  )
}				
```				

### child -> parent
	    
child
```jsx harmony
import Form from 'react-bootstrap/Form'
import './Child.css'

export const Child = ({ onChange }) => {
  const handleNameChange = (event) => {
    onChange(event.target.value)
  }

  return (
    <div className="child__main-container">
      <p>
        <i>Child component</i>
      </p>

      <Form>
        <Form.Group>
          <Form.Label>Name</Form.Label>
          <Form.Control
            type="text"
            placeholder="Enter name"
            onChange={handleNameChange}
          />
        </Form.Group>
      </Form>
    </div>
  )
}	    
```	    

parent
```jsx harmony
import { useState } from 'react'
import Child from '../Child'
import './Parent.css'

export const Parent = () => {
  const [name, setName] = useState('')

  const handleChange = (value) => {
    setName(value)
  }

  return (
    <div className="parent__main-container">
      <p>
        <i>Parent component</i>
      </p>
      <span>Name is: {name || '<Not set>'}</span>

      <Child onChange={handleChange} />
    </div>
  )
}	    
```	    

### sibling -> sibling   

Sibling 2
```jsx harmony
import './Sibling2.css'

export const Sibling2 = ({ name }) => {
  return (
    <div className="sibling2__main-container">
      <p>
        <i>Sibling 2</i>
      </p>

      <span>Name is: {name || '<Not set>'}</span>
    </div>
  )
}	    
```	    

Sibling 1
```jsx harmony
import Form from 'react-bootstrap/Form'
import './Sibling1.css'

export const Sibling1 = ({ onChange }) => {
  const handleNameChange = (event) => {
    onChange(event.target.value)
  }

  return (
    <div className="sibling1__main-container">
      <p>
        <i>Sibling 1</i>
      </p>

      <Form>
        <Form.Group>
          <Form.Label>Name</Form.Label>
          <Form.Control
            type="text"
            placeholder="Enter name"
            onChange={handleNameChange}
          />
        </Form.Group>
      </Form>
    </div>
  )
}	    
```	    

Parent
```jsx harmony
import { useState } from 'react'

import Sibling1 from '../Sibling1'
import Sibling2 from '../Sibling2'
import './Parent.css'

export const Parent = () => {
  const [name, setName] = useState('')

  const handleNameChange = (value) => {
    setName(value)
  }

  return (
    <div className="parent__main-container">
      <p>
        <i>Parent component</i>
      </p>

      <Sibling1 onChange={handleNameChange} />
      <Sibling2 name={name} />
    </div>
  )
}	    
```	    

### parent -> child -> grandchild
	    
parent
```jsx harmony
import { useState } from 'react'
import Form from 'react-bootstrap/Form'

import Child from '../Child'
import './Parent.css'

export const Parent = () => {
  const { name, setName } = useState('')

  const handleNameChange = (event) => {
    setName(event.target.value)
  }

  return (
    <div className="parent__main-container">
      <p>
        <i>Parent Component</i>
      </p>

      <Form>
        <Form.Group>
          <Form.Label>Name</Form.Label>
          <Form.Control
            type="text"
            placeholder="Enter name"
            onChange={handleNameChange}
          />
        </Form.Group>
      </Form>

      <Child name={name}/>
    </div>
  )
}	    
```	    

child
```jsx harmony
import Grandchild from '../Grandchild'
import './Child.css'

export const Child = ({name}) => {
  return (
    <div className="child__main-container">
      <p>
        <i>Child Component</i>
      </p>

      <Grandchild name={name} />
    </div>
  )
}	    
```	    

Grandchild
```jsx harmony
import './Grandchild.css'

export const Grandchild = ({name}) => {

  return (
    <div className="grandchild__main-container">
      <p>
        <i>Grand child Component</i>
      </p>

      <span>Name is: {name}</span>
    </div>
  )
}	    
```	    

### parent -> child -> grandchild + Context

Component	    
```jsx harmony
import { Context } from './context'
import { useState } from 'react'

import Parent from './Parent'

export const Component = () => {
  const [name, setName] = useState()

  return (
    <Context.Provider value={{ name, setName }}>
      <Parent />
    </Context.Provider>
  )
}	    
```	    

context
```jsx harmony
import { createContext } from 'react'

export const Context = createContext()	    
```	    

Parent
```jsx harmony
import { useContext } from 'react'
import Form from 'react-bootstrap/Form'

import { Context } from '../context'
import Child from '../Child'
import './Parent.css'

export const Parent = () => {
  const { setName } = useContext(Context)

  const handleNameChange = (event) => {
    setName(event.target.value)
  }

  return (
    <div className="parent__main-container">
      <p>
        <i>Parent Component</i>
      </p>

      <Form>
        <Form.Group>
          <Form.Label>Name</Form.Label>
          <Form.Control
            type="text"
            placeholder="Enter name"
            onChange={handleNameChange}
          />
        </Form.Group>
      </Form>

      <Child />
    </div>
  )
}	    
```	    

Child
```jsx harmony
import Grandchild from '../Grandchild'
import './Child.css'

export const Child = () => {
  return (
    <div className="child__main-container">
      <p>
        <i>Child Component</i>
      </p>

      <Grandchild />
    </div>
  )
}	    
```	    

Grandchild
```jsx harmony
import { useContext } from 'react'
import { Context } from '../context'

import './Grandchild.css'

export const Grandchild = () => {
  const { name } = useContext(Context)

  return (
    <div className="grandchild__main-container">
      <p>
        <i>Grand child Component</i>
      </p>

      <span>Name is: {name || '<Not set>'}</span>
    </div>
  )
}	    
```	    	    	    
				
 ![54](https://user-images.githubusercontent.com/80325645/155340652-3b2db06f-6cd1-488b-9dfe-7b0c3f3ef77a.jpg)			
    
  **[⬆ Наверх](#top)**
				
84. ### <a name="84"></a> Сетевые запросы

js	    
```jsx harmony
const postData = async (url, data) => {
    let res = await fetch(url, {
        method: "POST",
        headers: {
            'Content-Type': 'application/json'
        },
        body: data
    });

    return await res.json();
};

async function getResource(url) {
    let res = await fetch(url);

    if (!res.ok) {
        throw new Error(`Could not fetch ${url}, status: ${res.status}`);
    }

    return await res.json();
}

export {postData};
export {getResource};	    
```
	    
react js
```jsx harmony
class MarvelService {
    _apiBase = 'https://gateway.marvel.com:443/v1/public/';
    // ЗДЕСЬ БУДЕТ ВАШ КЛЮЧ, ЭТОТ КЛЮЧ МОЖЕТ НЕ РАБОТАТЬ
    _apiKey = 'apikey=c5d6fc8b83116d92ed468ce36bac6c62';
    _baseOffset = 210;

    getResource = async (url) => {
        let res = await fetch(url);
    
        if (!res.ok) {
            throw new Error(`Could not fetch ${url}, status: ${res.status}`);
        }
    
        return await res.json();
    }

    getAllCharacters = async (offset = this._baseOffset) => {
        const res = await this.getResource(`${this._apiBase}characters?limit=9&offset=${offset}&${this._apiKey}`);
        return res.data.results.map(this._transformCharacter);
    }

    getCharacter = async (id) => {
        const res = await this.getResource(`${this._apiBase}characters/${id}?${this._apiKey}`);
        return this._transformCharacter(res.data.results[0]);
    }

    _transformCharacter = (char) => {
        return {
            id: char.id,
            name: char.name,
            description: char.description ? `${char.description.slice(0, 210)}...` : 'There is no description for this character',
            thumbnail: char.thumbnail.path + '.' + char.thumbnail.extension,
            homepage: char.urls[0].url,
            wiki: char.urls[1].url,
            comics: char.comics.items
        }
    }
}

export default MarvelService;	    
```	    
  
react js
```jsx harmony
export default class InstaService {
  constructor() {
    this._apiBase = 'http://localhost:3000';
  }

  getResource = async (url) => {
    const res = await fetch(`${this._apiBase}${url}`);

    if (!res.ok) {
      throw new Error(`Could not fetch ${url}; received ${res.status}`);
    }

    return await res.json();
  };

  getAllPosts = async () => {
    const res = await this.getResource('/posts/');
    return res;
  };

  getAllPhotos = async () => {
    const res = await this.getResource('/posts/');
    return res.map(this._transformPosts);
  };

  _transformPosts = (post) => {
    return {
      src: post.src,
      alt: post.alt,
    };
  };
}	    
```	    

react js
```jsx harmony

export default class GotService {
    constructor() {
        this._apiBase = 'https://www.anapioficeandfire.com/api';
    }

    getResource = async (url) => {
        const res = await fetch(`${this._apiBase}${url}`);
    
        if (!res.ok) {
          throw new Error(`Could not fetch ${url}` +
            `, received ${res.status}`);
        }
        return await res.json();
    }

    getAllBooks = async () => {
        const res = await this.getResource(`/books/`);
        return res.map(this._transformBook);
    }
    
    getBook = async (id) => {
        const book = await this.getResource(`/books/${id}/`);
        return this._transformBook(book);
    }
    
    getAllCharacters = async () => {
        const res = await this.getResource(`/characters?page=5&pageSize=10`);
        return res.map(this._transformCharacter);
    }
    
    getCharacter = async (id) => {
        const character = await this.getResource(`/characters/${id}`);
        return this._transformCharacter(character);
    }
    
    getAllHouses = async () => {
        const res = await this.getResource(`/houses/`);
        return res.map(this._transformHouse);
    }
    
    getHouse = async (id) => {
        const house = await this.getResource(`/houses/${id}/`);
        return this._transformHouse(house);
    }

    isSet(data) {
        if (data) {
            return data
        } else {
            return 'no data :('
        }
    }

    _extractId = (item) => {
        const idRegExp = /\/([0-9]*)$/;
        return item.url.match(idRegExp)[1];
    }

    _transformCharacter = (char) => {
        return {
            id: this._extractId(char),
            name: this.isSet(char.name),
            gender: this.isSet(char.gender),
            born: this.isSet(char.born),
            died: this.isSet(char.died), 
            culture: this.isSet(char.culture)
        };
    }

    _transformHouse = (house) => {
        return {
            id: this._extractId(house),
            name: this.isSet(house.name),
            region: this.isSet(house.region),
            words: this.isSet(house.words),
            titles: this.isSet(house.titles),
            ancestralWeapons: this.isSet(house.ancestralWeapons)
        };
    }
    
    _transformBook = (book) => {
        return {
            id: this._extractId(book),
            name: this.isSet(book.name),
            numberOfPages: this.isSet(book.numberOfPages),
            publisher: this.isSet(book.publisher),
            released: this.isSet(book.released)
        };
    }
}	    
```
	    
react js
```jsx harmony
export default class RestoService{
    _apiBase = 'http://localhost:3000';

    async getResource(url) {
        const res = await fetch(`${this._apiBase}${url}`);
        if (!res.ok) {
            throw new Error(`Could not fetch ${url}` + 
                `, received ${res.status}`);
        }
        return await res.json();
    }

    async getMenuItems () {
        return await this.getResource('/menu/');
    }

    async getItem(id) {
        const res = await this.getResource('/menu/');
        console.log(res);
        const item = res.find( (el) => {
            console.log(`el.id: ${el.id}, id: ${id}`);
            return el.id === +id;
        }) 
        console.log(item);
        return item;
    }

    async setOrder(order) {
        const number = await this.getOrderNumber();
        const newOrder = {
            id: number,
            order: order
        }
        const response = await fetch(`${this._apiBase}/orders`, {
            method: 'POST', 
            headers: {
                'Content-Type': 'application/json;charset=utf-8'
            },
            body: JSON.stringify(newOrder)
        });
        if (!response.ok){
            throw new Error('json error'); 
        }
    }

    async getOrderNumber(){
        const res = await this.getResource('/orders/');
        const orderNumber = res.length+1;

        return orderNumber
    }
}	    
```	    
	    
  **[⬆ Наверх](#top)**
				
85. ### <a name="85"></a> Pure component. Что такое "чистый" компонент?

## Что такое "чистый" компонент?

_Чистые компоненты_ (pure components) - это компоненты, которые не рендерятся повторно при обновлении их состояния или пропов одними и теми же значениями. Если значение предыдущего и нового состояния и пропов равны, компонент не повторно отрисовывается. Чистые компоненты ограничивают повторный рендеринг, обеспечивая повышение производительности приложения.

_Особенности чистых компонентов_

- Предотвращают повторный рендеринг компонента, если его состояние и пропы остались прежними.
- Неявно реализуют метод `shouldComponentUpdate`.
- `state` и `props` сравниваются поверхностно (shallow).
- В ряде случаев такие компоненты являются более производительными, чем обычные.

По аналогии с чистыми функциями в `JavaScript`, `React-компонент` считается чистым, если он возвращает (рендерит) одинаковый результат для одних и тех же значений пропов и состояния. Для создания таких компонентов `React` предоставляет базовый класс `PureComponent`. Классовый компонент, расширяющий `React.PureComponent`, обрабатывается как чистый компонент.

Чистые компоненты похожи на обычные, за исключением того, что они неявно реализуют метод `shouldComponentUpdate`, проводя _поверхностное сравнение_ состояния и пропов. Если текущие и следующие состояние и пропы являются одинаковыми, повторный рендеринг компонента не выполняется.

`React-компоненты` перерисовываются в следующих случаях:

1. В компоненте вызывается `setState()`.
2. Обновляются значения `props`.
3. Вызывается `forceUpdate()`.

Чистые компоненты не перерисовываются вслепую, без оценки значений `state` и `props`. Если обновленные значения аналогичны предыдущим, повторный рендеринг не запускается.

_Компонент без состояния_

```jsx
import { pure } from 'recompose'

export default pure ((props) => <p>Компонент без состояния</p>)
```

_Компонент с состоянием_

```jsx
import React, { PureComponent } from 'react'

export default class Test extends PureComponent{
   render() {
      return <p>Компонент с состоянием</p>
   }
}
```

_Пример_

```jsx
class Test extends React.PureComponent {
   constructor(props) {
      super(props)
      this.state = {
        taskList: [
          { title: 'Изучить React'},
          { title: 'Изучить TypeScript'},
          { title: 'Изучить Node.js'},
        ]
      }
   }

   componentDidMount() {
      setInterval(() => {
        this.setState((oldState) =>
          ({ taskList: [...oldState.taskList] })
        )
      }, 1000)
   }

   render() {
      console.log("Запущен рендеринг списка задач")

      return (
        <div>
         {this.state.taskList.map((task, i) =>
            <Task
              key={i}
              title={task.title}
            />
          )}
        </div>
      )
   }
}

class Task extends React.Component {
   render() {
      console.log("Задача добавлена в список")

      return (
        <h2>
          {this.props.title}
        </h2>
      )
   }
}
ReactDOM.render(<Test />, document.getElementById('app'))
```

## Зачем использовать "чистые" компоненты? Когда следует использовать "чистые" компоненты вместо обычных?

Компоненты имеют один недостаток: они всегда повторно рендерятся вслед за родительским компонентом, даже если их пропы остались прежними.

Компоненты также всегда перерисовываются при обновлении их состояния, даже если новое значение состояние идентично предыдущему. При обновлении родительского компонента перерисовываются все его потомки, потомки потомков и т.д.

Такое поведение может привести к большому количеству лишних перерисовок. Действительно, если компонент зависит только от пропов и состояния, тогда он должен обновляться только при их изменении независимо от того, что происходит с его родительским компонентом.

Это как раз то, для чего предназначены "чистые" компоненты (pure components) - они останавливают "порочный круг" рендеринга. "Чистые" компоненты не перерисовываются до тех пор, пока не изменятся их пропы и состояние.

_Случаи использования чистых компонентов:_

- В целях предотвращения повторного рендеринга компонента, чьи состояние и пропы остались прежними.
- Состояние и пропы компонента являются иммутабельными.
- Мы не планируем реализовывать собственный метод жизненного цикла `shouldComponentUpdate`.

С другой стороны, мы не должны использовать `PureComponent` в случаях, когда:

- Состояние или пропы являются изменяемыми.
- Мы планируем реализовать собственный метод `shouldComponentUpdate`. 
    
  **[⬆ Наверх](#top)**
	    
86. ### <a name="86"></a> 

 
    
  **[⬆ Наверх](#top)**
	    
87. ### <a name="87"></a> 

 
    
  **[⬆ Наверх](#top)**
	    
88. ### <a name="88"></a> 

 
    
  **[⬆ Наверх](#top)**
	    
89. ### <a name="89"></a> 

 
    
  **[⬆ Наверх](#top)**
	    
90. ### <a name="90"></a> 

 
    
  **[⬆ Наверх](#top)**
	    
91. ### <a name="91"></a> 

 
    
  **[⬆ Наверх](#top)**
	    
92. ### <a name="92"></a> 

 
    
  **[⬆ Наверх](#top)**	    
	
150. ### <a name="150"></a> Reselect и Recompose

Reselect - это библиотека селекторов (для Redux), которая использует концепцию мемоизации. Изначально она создавалась для вычисления производных данных из состояния Redux-подобных приложений, но может применяться и к другой архитектуре или библиотеке.

Reselect сохраняет копию входных/выходных данных последнего вызова и производит повторные вычисления только при изменении этих данных. Если передаются одни и те же данные, reselect возвращает результат из кэша. Мемоизация и кэширование являются полностью настраиваемыми.

Т.к. state — это просто вложенный объект, то несложно осуществлять навигацию по нему через точку: state.todos[42].title. Его также несложно покрыть типами, от чего подобная навигация станет только надёжней. Однако, удобно закрывать прямой доступ к стейту. Непосредственно сам доступ осуществляется через специальные функции, которые в терминах redux принято называть селекторами.

reselect — это библиотека, которая примечательна тремя вещами. Во-первых, readme этой библиотеки в два десятка раз больше по объему, чем её код. Во-вторых, reselect предоставляет удобный способ создавать и комбинировать селекторы. В-третьих, эта библиотека позволяет оптимизировать количество вычислений (как следствие, скорость приложения) за счёт кеширования.

### Recompose

Recompose — это библиотека с уже готовыми компонентами высшего порядка. Идея в том, чтобы писать stateless-компоненты и разделять код на логические части. Пользуясь готовыми HOC-ами, вы можете отделять методы жизненного цикла, выносить бизнес логику и навешивать обработчики событий не внутри компонента, а снаружи. При этом повторно использовать всё то, чем вы пользовались, и создавать свои собственные компоненты на основе базовых.
    
  **[⬆ Наверх](#top)**
				
151. ### <a name="151"></a> Виртуализация

 Если ваше приложение рендерит длинные списки данных (сотни или тысячи строк), мы рекомендуем использовать метод известный как «оконный доступ». Этот метод рендерит только небольшое подмножество строк в данный момент времени и может значительно сократить время, необходимое для повторного рендера компонентов, а также количество создаваемых DOM-узлов.

react-window и react-virtualized — это популярные библиотеки для оконного доступа. Они предоставляют несколько повторно используемых компонентов для отображения списков, сеток и табличных данных. Если вы хотите использовать что-то более специфическое для вашего конкретного случая, то вы можете создать собственный компонент с оконным доступом, как это сделано в Twitter.
    
  **[⬆ Наверх](#top)**
				
152. ### <a name="152"></a> Параллельный режим

 Параллельный режим Это способ структурировать программу, разбив ее на части, выполнение которых будет проходить независимо друг от друга. Именно так мы сможем выйти за границы одного потока и улучшить производительность нашего приложения.

### Главная задача — оптимизация пользовательского опыта

Поток UI браузера отвечает за отображение всех изменений, инициируемых CSS, пользовательским вводом и самим JavaScript на экране. Предполагается, что для оптимизации пользовательского опыта современный компьютер должен отображать 60 кадров в секунду. В связи с этим выполнение кода при каждом цикле рендеринга должно занимать не более 16.67 миллисекунд, а в реальности и того меньше — что-то около 10 миллисекунд (так как, учитывая вышесказанное, браузер занимается реализацией других задач UI).

https://medium.com/nuances-of-programming/%D0%BF%D0%B0%D1%80%D0%B0%D0%BB%D0%BB%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9-%D1%80%D0%B5%D0%B6%D0%B8%D0%BC-react-%D0%B2%D0%B7%D0%B3%D0%BB%D1%8F%D0%B4-%D0%B2-%D0%B1%D1%83%D0%B4%D1%83%D1%89%D0%B5%D0%B5-a9e8e9edcbe9
    
  **[⬆ Наверх](#top)**
				
153. ### <a name="153"></a> Динамический импорт

Лучший способ внедрить разделение кода в приложение — использовать синтаксис динамического импорта: import().

До:
```jsx harmony
import { add } from './math';

console.log(add(16, 26));
```
	    
После:
```jsx harmony
import("./math").then(math => {
  console.log(math.add(16, 26));
});
```
	    
Когда Webpack сталкивается с таким синтаксисом, он автоматически начинает разделять код вашего приложения. Если вы используете Create React App, то всё уже настроено и вы можете сразу начать использовать синтаксис динамического импорта. Он также поддерживается «из коробки» в Next.js.
    
  **[⬆ Наверх](#top)**
				
154. ### <a name="154"></a> Tree shaking

 ### Что такое Tree shaking? 
 
Когда JS-приложения достигает определенных размеров, целесообразно разделить его код на модули. Минус такого подхода в том, что можно импортировать код, который на самом деле не используется. На помощь приходит Tree shaking - метод оптимизации пакетов вашего кода. Его суть: изъять неиспользуемый код из конечного файла.

Представьте, что у нас есть файл с некоторыми полезными математическими операциями, которые мы, возможно, захотим использовать в основном скрипте.
```jsx harmony
export function add(a, b) {
 console.log("add");
 return a + b;
}

export function minus(a, b) {
 console.log("minus");
 return a - b;
}

export function multiply(a, b) {
 console.log("multiply");
 return a * b;
}

export function divide(a, b) {
 console.log("divide");
 return a / b;
}
```
Предположим, что в основном скрипте мы импортируем и применяем из перечисленных только функцию add() .
```jsx harmony
import { add } from "./mathUtils";

add(1, 2);
```
Если для сборки мы используем такой инструмент, как Webpack, то все функции из файла mathUtils.js окажутся в конечном пакете (даже если мы импортировали только add()).

С Tree shaking в конечный пакет попадет только тот код, что действительно использовался или был импортирован.

### Как работает Tree shaking?

Хотя концепция Tree shaking существует с 90-х годов, в Javascript она проявила себя только с появлением модулей ES6. Все потому, что tree shaking может работать только если модули «статические».

До появления ES6 были CommonJS модули, которые использовали синтаксис require(). Они были «динамическими», то есть мы могли импортировать новые модули в условных выражениях.
```jsx harmony
var myDynamicModule;

if (condition) {
 myDynamicModule = require("foo");
} else {
 myDynamicModule = require("bar");
}
```
Именно «динамическая» природа CommonJS модулей препятствовала применению tree shaking, потому что невозможно было определить нужный модуль к запуску кода.

В ES6 был представлен новый, полностью статический синтаксис модулей. С importмы больше не можем импортировать модуль динамично.

То есть такой код не будет работать:
```jsx harmony
if (condition) {
 import foo from "foo";
} else {
 import bar from "bar";
}
```
### Что «стряхивает» tree shaking?

Реализация tree shaking в Webpack позволяет максимально избавиться неиспользованного кода. Например, код, который мы импортировали из import, но не использовали, изымается.
```jsx harmony
import { add, multiply } from "./mathUtils";

add(1, 2);
```
В примере выше функция multiply() никогда не используется, поэтому она будет удалена из конечного пакета.

Даже отдельные свойства импортируемых объектов удаляются, если к ним не обращались.

файл myInfo.js:
```jsx harmony
export const myInfo = {
 name: "Ire Aderinokun",
 birthday: "2 March"
}
```
файл index.js:

import { myInfo } from "./myInfo.js";

console.log(myInfo.name);

В приведенном примере свойство birthday не попадет в конечный пакет, потому что никогда не используется.

Однако, tree shaking вы не избавитесь всего ненужного кода. В статье мы не будем касаться этих подробностей. Стоит только помнить, что использование tree shaking не решает проблему лишнего кода полностью.

### Как насчет "побочных эффектов"?

Побочным эффектом (side effect) называют код, который выполняет некоторые действия при импорте, не обязательно связанные с экспортом. Хорошим примером побочного эффекта является полифил. Как правило, полифилы не предусматривают экспорт в основном скрипте, а скорее о проекте в целом.

Tree shaking не может определить какие скрипты являются побочными эффектами автоматически, поэтому важно определить их вручную. Продемонстрируем это ниже.

### Как использовать tree shaking?

Как правило, tree shaking реализуется через Бандлер кода. Например, если вы используете Webpack, вы легко можете указать mode как production в файле webpack.config.js. Наряду с другими оптимизациями, вы активируете tree shaking.
```jsx harmony
module.exports = {
 ...,
 mode: "production",
 ...,
};
```jsx harmony
Чтобы обозначить конкретные файлы как побочные эффекты,  необходим файл package.json.
```jsx harmony
{
 ...,
 "sideEffects": [
 "./src/polyfill.js"
 ],
 ...,
}
```
    
  **[⬆ Наверх](#top)**
				
155. ### <a name="155"></a> Service workers

 Service Workers — это сценарий, который запускается браузером в фоновом режиме. Он никак не связан с веб-страницей или DOM и предоставляет функции “из коробки”, такие как обработка сетевых запросов, push-уведомления и фоновая синхронизация. Service workers обеспечивают возможность работы offline.

Service worker — посредник между клиентом и сервером, пропускающий через себя все запросы к серверу. С его помощью можно перехватывать все запросы “на лету”.

Service workers подобны Javascript workers. Они не связаны с DOM или веб-страницами. Они работают на другом потоке и получают доступ к DOM с помощью API postMessage. При разработке прогрессивных веб-приложений (PWA) стоит обратить внимание на service workers и стратегии кэширования.
    
  **[⬆ Наверх](#top)**
				
156. ### <a name="156"></a> ReactDOMServer

 `ReactDOMServer` - это объект, позволяющий рендерить компоненты в виде статической разметки (обычно, используется на node-серверах). Данный объект в основном используется при *рендеринге на стороне сервера*. Следующие методы могут быть использованы как на сервере, так и в браузерном окружении:

1. `renderToString()`
2. `renderToStaticMarkup()`

Например, вы запускаете основанный на Node веб-сервер, такой как Express, Koa или Happi, и вызываете `renderToString()` для рендеринга корневого элемента в виде строки, которую сервер отправляет в ответ на запрос:

```javascript
// используем Express
import { renderToString } from 'react-dom/server'
import MyPage from './MyPage'

app.get('/', (req, res) => {
res.write('<!DOCTYPE html><html><head><title>My Page</title></head><body>')
res.write('<div id="content">')
res.write(renderToString(<MyPage/>))
res.write('</div></body></html>')
res.end()
})
```
    
  **[⬆ Наверх](#top)**
				
157. ### <a name="157"></a> Гидратация

 hydrate()

```jsx harmony	
ReactDOM.hydrate(element, container[, callback])
```	
То же, что и render(), но используется для гидратации контейнера, HTML-содержимое которого было отрендерено с помощью ReactDOMServer. React попытается присоединить обработчики событий к уже существующей разметке.

React ожидает, что отрендеренное содержимое идентично на сервере, и на клиенте. Текстовые различия в контенте могут быть переписаны поверх, но вам следует рассматривать такие нестыковки как ошибки и исправлять их. В режиме разработки React предупреждает о несоответствиях во время гидратации. Нет никаких гарантий, что различия атрибутов будут исправлены в случае несовпадений. Это важно по соображениям производительности, поскольку в большинстве приложений несоответствия встречаются редко, и поэтому проверка всей разметки будет непомерно дорогой.

Если атрибут отдельного элемента или текстовое содержимое неизбежно отличается на сервере и клиенте (например, отметка времени), вы можете отключить предупреждение, добавив к элементу suppressHydrationWarning={true}. Он работает только на один уровень в глубину, и задумана как лазейка. Не злоупотребляйте ею. Если это не текстовый контент, React по-прежнему не будет пытаться его исправить, поэтому он может оставаться несовместимым c обновлённым в будущем вариантом.

Если вам нужно намеренно отрендерить что-то другое на сервере и клиенте, вы можете выполнить двухпроходный рендеринг. Компоненты, которые рендерят что-то другое на клиенте, могут читать переменную состояния, такую как this.state.isClient, которую вы можете установить в true в componentDidMount(). Таким образом, начальный этап рендеринга будет отображать тот же контент, что и сервер, избегая несовпадений, но дополнительный этап будет происходить синхронно сразу после гидратации. Обратите внимание, что этот подход замедлит ваши компоненты, потому что они должны рендерится дважды, поэтому используйте его с осторожностью.

Не забывайте про работу с вашим приложением при медленных соединениях. JavaScript-код может загружаться значительно позже исходного HTML-рендеринга, поэтому, если вы рендерите что-то другое только для клиента, переход может вызвать раздражение. Тем не менее, при правильном выполнении может оказаться полезным отобразить «оболочку» приложения на сервере и показать только некоторые дополнительные виджеты на клиенте. Чтобы узнать, как это сделать без проблем с разметкой, обратитесь к объяснению в предыдущем абзаце.
    
  **[⬆ Наверх](#top)**
				
158. ### <a name="158"></a> jest и enzyme

 `Jest` — исполнитель тестов на JavaScript, который позволяет взаимодействовать с DOM через jsdom. Несмотря на то, что jsdom только приблизительно реализует работу браузера, в большинстве случаев этого достаточно для тестирования React-компонентов. Jest предлагает отличную скорость итераций вместе с мощными возможностями, например фиктивные модули и таймеры, которые дают больше контроля над исполнением кода.

`Enzyme` — это библиотека, которая сильно упрощает тестирование React-приложений, предоставляя удобные функции рендеринга компонентов. Enzyme разработан в Airbnb.

Enzyme позволяет рендерить компоненты в коде. Для этого есть несколько удобных функций, которые выполняют разные варианты рендеринга:

- полный рендеринг (как в браузере, full DOM rendering);
- упрощенный рендеринг (shallow rendering);
- статический рендеринг (static rendering).
    
  **[⬆ Наверх](#top)**
				
159. ### <a name="159"></a> Тестировании shapshot

 `Snapshot-тестирование` — это относительная новая возможность в Jest. Смысл заключается в том, что с помощью специальной проверочной функции мы просим Jest сохранить снимок нашей структуры данных на диск, а при последующих выполнениях теста сравнивать новые снимки с ранее сохраненным.

Снимок в данном случае не что иное, как просто текстовое представление данных. Например, вот так будет выглядеть снимок какого-нибудь объекта (ключ массива тут является названием теста):
```jsx harmony
exports[`some test name`] = `
Object {
    "Hello": "world"
}
`;
```
Вот так выглядит проверочная функция Jest, которая выполняет сравнение снимков (параметры необязательные):
```jsx harmony
expect(value).toMatchSnapshot(propertyMatchers, snapshotName)
```
В качестве value может выступать любая сериализуемая структура данных. В первый раз функция toMatchSnapshot() просто запишет снимок на диск, в последующие разы она уже будет выполнять сравнение.

Чаще всего такая технология тестирования используется именно для тестирования React-компонентов, а еще более точно, для тестирования правильности рендеринга React-компонентов. Для этого в качестве value нужно передавать компонент после рендеринга.


### Тестирование с использованием снимков в Jest#

Похожий подход может быть использован, когда дело доходит до тестирования React компонентов. Вместо отображения графического пользовательского интерфейса, что потребует сборки всего приложения, разработчик может использовать специализированный модуль для генерации сериализуемого значения для конкретного React дерева. Consider this example test for a Link component:
```jsx harmony
import React from 'react';
import renderer from 'react-test-renderer';
import Link from '../Link.react';

it('renders correctly', () => {
  const tree = renderer
    .create(<Link page="http://www.facebook.com">Facebook</Link>)
    .toJSON();
  expect(tree).toMatchSnapshot();
});
```
При первом запуске теста, Jest создает файл со снимком, который выглядит следующим образом:
```jsx harmony
exports[`отображается корректно 1`] = `
<a
  className="normal"
  href="http://www.facebook.com"
  onMouseEnter={[Function]}
  onMouseLeave={[Function]}
>
  Facebook
</a>
`;
```
    
  **[⬆ Наверх](#top)**
				
160. ### <a name="160"></a> Тесты e2e. Отличие от юнит, интеграционные тесты

 ### e2e

Сквозное тестирование, оно же End-to-end или E2E, — это процесс тестирования, при котором происходит подробная эмуляция пользовательской среды. То есть при данном тестировании имитируют:

- щелчки мышью, 
- нажатия на кнопки, 
- заполнение форм, 
- переходы по страницам и ссылкам,
- и другие поведенческие факторы. 

Суть этого тестирования — посмотреть, так ли работает программа для конечного клиента, как рассчитывалось изначально? При этом нужно учитывать, что пользователю все равно, функционирует ли программа «как надо», ему главное, чтобы программа функционировала и оправдывала ожидания, поэтому основной упор делается на корректное функционирование.

Е2Е-процесс — это конечный этап тестирования, после него никакого тестирования не проводят. Он самый трудозатратный и дорогой, именно поэтому находится на вершине пирамиды тестирования.
 
### Е2Е-процесс — что это?

Е2Е-процесс происходит при помощи сложных программ для тестирования, написанных специально для тестирования или «вручную», от этого данный процесс требует много времени и затрат. Поэтому до его применения обычно проводят более дешевые и нетребовательные виды тестирования. 

К примеру, компания Гугл при разработке своих продуктов следует правилу «70-20-10», цифры которого показывают процентное соотношение от общего количества тестов, то есть:

70% занимают юнит-тесты;

20% занимают интеграционные тесты;

10% занимают Е2Е-тесты.

Конечно, такая комбинация тестов не является эталонной. Для каждого проекта она будет своя. Но идея в том, что количество Е2Е-тестов должно быть куда меньше, чем остальных тестов. В некоторых проектах сквозного тестирования вообще может не быть, так как unit-тесты и интеграционные тесты покрывают все процессы программы. А иногда просто их нецелесообразно проводить из-за того, что проект небольшой и тестируемый функционал может быть еще много раз переписан. Поэтому можно сказать, что E2E — это процесс больших и сложных проектов.

 
### Какие бывают Е2Е-тесты

Нет единого алгоритма сквозного тестирования, так как многое будет зависеть от сложности самого проекта и что конкретно нужно тестировать. Е2Е — это лишь название процесса тестирования, а не его метод или алгоритм. Но при этом выделяют два основных типа сквозного тестирования, на которых мы немного остановимся.

Типы Е2Е-тестирования:

1. Метод «черного ящика». Это специальный E2E-процесс тестирования, при котором само тестирование проводится только с интерфейсом пользователя. «Черным ящиком» называется, потому что тестировщика интересуют только проблемы интерфейса: работоспособность функций, ошибки при взаимодействии, ошибки при определенном поведении пользователей и т. д., и его абсолютно не интересует, как это все работает внутри программы. В большинстве случаев тестировщик даже не понимает, как с помощью кода получается тот или иной функционал. Такой тип тестирования считается самым распространенным.

2. Метод «белого ящика». В этом типе тестирования тестировщику известна «внутренняя кухня» программы. А это значит, что ему известно, как себя должна повести программа при определенном действии пользователя. Он анализирует, совпадает ли задуманный результат поведения с реально происходящим, и понимает, где нужно вносить необходимые корректировки.

Любой сквозной тест — это:
- в первую очередь тестирование UI;
- тяжелый и медленный тест;
- применение метода «черного ящика» и найм сторонних тестировщиков, никак не связанных с разработкой программы;
- тяжелый «отлов» найденной проблемы;
- тестирование всех модулей и всех систем целиком, поэтому требуется сложный и эффективный софт или работа «руками»;
- гарантия, что программа работает так, как задумано, или нет.

### Заключение

Е2Е — это дорогой и сложный процесс тестирования, к которому нужно подготавливаться основательно. Давайте проведем аналогию с мостом. Мост через реку — это тестируемая программа. Так вот Е2Е-тестирование — это не просто проехать по мосту груженными КАМАЗами и смотреть издалека: выдержит или не выдержит. Е2Е — это куча всевозможных датчиков, расставленных по всему мосту, которые сигнализируют о каждом шаге и готовы фиксировать любой сценарий развития на «мосту»:

- перегруз;
- колебания;
- микротрещены;
- нагрузку на каждый трос или балку;
- поведение моста при наводнении, землетрясении, пожаре или аварии на нем;


### Unit vs E2E

Между модульными тестами и сквозными много отличий и часто возникает вопрос какие тесты использовать. Ответ очевиден использовать и оба вида тестов в соответствии с пирамидой тестирования. Все же стоит уточнить разницу между этими видами.

Модульные тесты:
- хороши для api тестов и тестирования отдельных методов;
- они сами по себе маленькие и быстрые;
- подход тестирования используется белого ящика;
- тесты изолированы от остальных модулей;
- быстро отлаживается, понятно где проблема;
- маленькая гарантия, что приложение работает(соответствует требованиям).

Сквозные тесты:
- тестируют UI;
- тяжелые и медленные;
- используют подход черного ящика;
- включают все модули всех систем вместе;
- проблему отловить тяжелее, так как она может возникнуть не перманентно;
- большая гарантия, что приложение соответствует требованиям.


### Интеграционное

Интеграционное тестирование (Integration testing) = проверка связи между модулями (компонентами) кода, а также взаимодействия с различными частями системы (операционной системой, оборудованием либо связи между различными системами). Если проводить аналогии, например с тестированием авиадвигателя, то юнит-тесты - это тестирование отдельных деталей, клапанов, заслонок, а интеграционное тестирование - это запуск собранного двигателя на стенде.
Выполняется разработчиками, зачастую методом автоматического тестирования.
    
  **[⬆ Наверх](#top)**
				
161. ### <a name="161"></a> lazy imports, Suspense

 Функция React.lazy позволяет рендерить динамический импорт как обычный компонент.

До:
```jsx harmony
import OtherComponent from './OtherComponent';
```	
После:
```jsx harmony
const OtherComponent = React.lazy(() => import('./OtherComponent'));
```	
Она автоматически загрузит бандл, содержащий OtherComponent, когда этот компонент будет впервые отрендерен.

React.lazy принимает функцию, которая должна вызвать динамический import(). Результатом возвращённого Promise является модуль, который экспортирует по умолчанию React-компонент (export default).

### Задержка
	
Компонент с ленивой загрузкой должен рендериться внутри компонента Suspense, который позволяет нам показать запасное содержимое (например, индикатор загрузки) пока происходит загрузка ленивого компонента.
```jsx harmony
import React, { Suspense } from 'react';

const OtherComponent = React.lazy(() => import('./OtherComponent'));

function MyComponent() {
  return (
    <div>
      <Suspense fallback={<div>Загрузка...</div>}>
        <OtherComponent />
      </Suspense>
    </div>
  );
}
```	
Проп fallback принимает любой React-элемент, который вы хотите показать, пока происходит загрузка компонента. Компонент Suspense можно разместить в любом месте над ленивым компонентом. Кроме того, можно обернуть несколько ленивых компонентов одним компонентом Suspense.
```jsx harmony
import React, { Suspense } from 'react';

const OtherComponent = React.lazy(() => import('./OtherComponent'));
const AnotherComponent = React.lazy(() => import('./AnotherComponent'));

function MyComponent() {
  return (
    <div>
      <Suspense fallback={<div>Загрузка...</div>}>
        <section>
          <OtherComponent />
          <AnotherComponent />
        </section>
      </Suspense>
    </div>
  );
}
```

`React.Suspense` позволяет показать индикатор загрузки в случае, если некоторые компоненты в дереве под ним ещё не готовы к рендеру. Сегодня ленивая загрузка компонентов — это единственный вариант использования, поддерживаемый <React.Suspense>:

```jsx harmony        
// Этот компонент загружается динамически
const OtherComponent = React.lazy(() => import('./OtherComponent'));

function MyComponent() {
  return (
    // Отобразится <Spinner> до тех пор, пока не загрузится <OtherComponent />
    <React.Suspense fallback={<Spinner />}>
      <div>
        <OtherComponent />
      </div>
    </React.Suspense>
  );
}
```        
Это задокументировано в нашем руководстве по разделению кода. Обратите внимание, что lazy компоненты могут быть глубоко внутри дерева Suspense — не нужно оборачивать каждый из них. Считается хорошей практикой использовать <Suspense> для индикации загрузки, а lazy() — для разделения кода.        
        
  **[⬆ Наверх](#top)**
				
162. ### <a name="162"></a> Axios, Fetch

 ### Axios & Fetch
	
`Объём шаблонного кода`

`Fetch`
```js
fetch('https://jsonplaceholder.typicode.com/todos/1')
  .then(response => response.json())
  .then(json => console.log(json))
// {
//   "userId": 1,
//   "id": 1,
//   "title": "delectus aut autem",
//   "completed": false
// }
```	

`Axios`
```js
axios.get("https://jsonplaceholder.typicode.com/todos/1")
  .then(response => console.log("response", response.data))
// {
//   "userId": 1,
//   "id": 1,
//   "title": "delectus aut autem",
//   "completed": false
// }	
```
	
`Fetch`
```js
fetch("https://jsonplaceholder.typicode.com/posts", {
  method: "POST",
  body: JSON.stringify({
    title: "Title of post",
    body: "Post Body"
  })
})
  .then(res => {
    if (!response.ok) throw Error(response.statusText);
    return response.json();
  })
  .then(data => console.log(data))
  .catch(error => console.log(error));
```
	
`Axios`
```js
axios
  .post("https://jsonplaceholder.typicode.com/posts", {
    title: "Title of post",
    body: "Body of post"
  })
  .then(response => console.log(response.data))
  .catch(error => console.log(error));	
```
	
`Обработка ошибок`

`Fetch`
```js
fetch("https://jsonplaceholder.typicode.com/todos/100000")
  .then(response => {
    if (!response.ok) throw Error(response.statusText);
    return response.json();
  })
  .then(data => console.log("data", data))
  .catch(error => {
    console.log("error", error);
  });
// error Error: Not Found
```
	
`Axios`
```js
axios
  .get("https://jsonplaceholder.typicode.com/todos/100000")
  .then(response => {
    console.log("response", response);
  })
  .catch(error => {
    console.log("error", error);
  });
// error Error: Not Found
```
	
Библиотека Axios выдаёт сведения о сетевых ошибках, а API Fetch — нет. Работая с Fetch всегда нужно проверять свойство response.ok. Для того чтобы упростить решение данной задачи, проверку этой ошибки можно оформить в виде отдельной функции:
```js
const checkForError = response => {
  if (!response.ok) throw Error(response.statusText);
  return response.json();
};
fetch("https://jsonplaceholder.typicode.com/todos/100000")
  .then(checkForError)
  .then(data => console.log("data", data))
  .catch(error => {
    console.log("error", error);
  });	
```	

### В чем заключаются преимущества использования Axios перед Fetch API для отправки HTTP-запросов?***

**Fetch**: данный API предоставляет метод `fetch()`, свойство глобального объекта `Window`. Он также предоставляет интерфейс для доступа и управления HTTP-запросами и ответами. Метод `fetch()` принимает URL запрашиваемого ресурса в качестве параметра. Данный метод возвращает промис, разрешающийся ответом на запрос.

*Пример*

```js
fetch('path-to-the-resource-to-be-fetched')
  .then((response) => {
    // успех
  })
  .catch((error) => {
    // провал
  });
```

**Axios**: клиент-серверная библиотека для отправки HTTP-запросов, основанная на промисах. Она позволяет перехватывать запросы и обеспечивать защиту клиента от XSRF. Также она позволяет отменять запросы.

*Пример*

```js
axios.get('url')
  .then((response) => {
    // успех
  })
  .catch((error) => {
    // провал
  });
```

**Разница между Axios и Fetch**

|Axios |Fetch |
|---|---|
|Имеет свойство `url` в объекте запроса | Не имеет свойства `url` в объекте запроса |
|Является сторонней библиотекой | Является нативным инструментом |
|Имеет встроенную защиту от XSRF | Не имеет встроенной защиты от XSRF |
|Использует свойство `data`    | Использует свойство `body` |
|`data` принимает объект с данными  | данные в `body` должны быть сериализованы с помощью метода `JSON.stringify()` |
|Успешный запрос возвращает статус 200 и текст 'OK' | Успешный запрос возвращает свойство `ok` с логическим значением |
|Выполняет автоматическое преобразование данных в формат JSON и обратно | Преобразование данных в формат JSON и обратно выполняется вручную (`JSON.stringify` и `.json()`, соответственно) |
|Позволяет отменять запросы по истечении "таймаута" | Не позволяет отменять запросы |
|Позволяет перехватывать запросы | По умолчанию не позволяет перехватывать запросы |
|Имеет встроенную поддержку для индикации процесса получения данных |Не имеет встроенной поддержки для отображения процесса получения данных |	
	
	
### Axios
	
Axios основан на промисах, что дает вам возможность использовать возможности JavaScript async и await для получения более удобочитаемого асинхронного кода.

Axios это один из самых популярных HTTP клиентов для браузеров и node.js, основанный на промисах.

В Axios есть поддержка запросов, получение ответов от сервера, их трансформация и автоматическая конвертация в JSON.
	
### Создание запроса GET
 
Добавьте в компонент следующий код:
```jsx harmony
import React from 'react';

import axios from 'axios';

export default class PersonList extends React.Component {
  state = {
    persons: []
  }

  componentDidMount() {
    axios.get(`https://jsonplaceholder.typicode.com/users`)
      .then(res => {
        const persons = res.data;
        this.setState({ persons });
      })
  }

  render() {
    return (
      <ul>
        { this.state.persons.map(person => <li>{person.name}</li>)}
      </ul>
    )
  }
}	
```
	
### Составление запроса POST
```jsx harmony	
import React from 'react';
import axios from 'axios';

export default class PersonList extends React.Component {
  state = {
    name: '',
  }

  handleChange = event => {
    this.setState({ name: event.target.value });
  }

  handleSubmit = event => {
    event.preventDefault();

    const user = {
      name: this.state.name
    };

    axios.post(`https://jsonplaceholder.typicode.com/users`, { user })
      .then(res => {
        console.log(res);
        console.log(res.data);
      })
  }

  render() {
    return (
      <div>
        <form onSubmit={this.handleSubmit}>
          <label>
            Person Name:
            <input type="text" name="name" onChange={this.handleChange} />
          </label>
          <button type="submit">Add</button>
        </form>
      </div>
    )
  }
}	
```
	
### Создание запроса DELETE
```jsx harmony
import React from 'react';
import axios from 'axios';

export default class PersonList extends React.Component {
  state = {
    id: '',
  }

  handleChange = event => {
    this.setState({ id: event.target.value });
  }

  handleSubmit = event => {
    event.preventDefault();

    axios.delete(`https://jsonplaceholder.typicode.com/users/${this.state.id}`)
      .then(res => {
        console.log(res);
        console.log(res.data);
      })
  }

  render() {
    return (
      <div>
        <form onSubmit={this.handleSubmit}>
          <label>
            Person ID:
            <input type="text" name="id" onChange={this.handleChange} />
          </label>
          <button type="submit">Delete</button>
        </form>
      </div>
    )
  }
}	
```		
	
### Fetch
	
### Пример 1	
```jsx harmony
fetch('http://example.com/movies.json')
  .then((response) => {
    return response.json();
  })
  .then((data) => {
    console.log(data);
  });
```	
Здесь мы забираем JSON файл по сети и выводим его содержимое в консоль. Самый простой способ использования fetch() заключается в вызове этой функии с одним аргументом — строкой, содержащей путь к ресурсу, который вы хотите получить — которая возвращает promise, содержащее ответ (объект Response).	

### Пример 2
```jsx harmony
	
```	
	
		
### Теория
	
Типичный запрос с помощью fetch состоит из двух операторов await:
```js
let response = await fetch(url, options); // завершается с заголовками ответа
let result = await response.json(); // читать тело ответа в формате JSON
```	
Или, без await:
```js
fetch(url, options)
  .then(response => response.json())
  .then(result => /* обрабатываем результат */)
```
	
Параметры ответа:
- response.status – HTTP-код ответа,
- response.ok – true, если статус ответа в диапазоне 200-299.
- response.headers – похожий на Map объект с HTTP-заголовками.
	
Методы для получения тела ответа:
- response.text() – возвращает ответ как обычный текст,
- response.json() – преобразовывает ответ в JSON-объект,
- response.formData() – возвращает ответ как объект FormData (кодировка form/multipart, см. следующую главу),
- response.blob() – возвращает объект как Blob (бинарные данные с типом),
- response.arrayBuffer() – возвращает ответ как ArrayBuffer (низкоуровневые бинарные данные),
	
Опции fetch, которые мы изучили на данный момент:
- method – HTTP-метод,
- headers – объект с запрашиваемыми заголовками (не все заголовки разрешены),
- body – данные для отправки (тело запроса) в виде текста, FormData, BufferSource, Blob или UrlSearchParams.
    
  **[⬆ Наверх](#top)**
  
163. ### <a name="163"></a> mock server

 ### Что такое MockServer
	
Для любой системы, с которой вы интегрируетесь через HTTP или HTTPS, MockServer можно использовать как:

- макет , выполненный с возможностью возврата определенных ответов для различных запросов
- прокси записи и , при необходимости модификации запросов и ответов
- как прокси для одних запросов, так и макет для других запросов одновременно
	
Когда MockServer получает запрос, он сопоставляет запрос с активными ожиданиями , которые были настроены, если совпадений не обнаружено, он проксирует запрос, если это необходимо, в противном случае возвращается 404.

Для каждого полученного запроса выполняются следующие шаги:
1. найти подходящее ожидание и выполнить действие
2. если запрос прокси-сервера не соответствует ожиданиям
3. если не запрос прокси, возврат 404
	
Ожидания определяет действие , которое принято, например, ответ может быть возвращен.

MockServer поддерживает следующие действия :

- возвращать "фиктивный" ответ, когда запрос соответствует ожиданиям
Ожидание ответного действия
- пересылать запрос, когда запрос соответствует ожидаемому (например, прокси-сервер с динамической переадресацией портов)  
- выполнять обратный вызов, когда запрос соответствует ожиданиям , позволяя динамически создавать ответ
- вернуть неверный ответ или закрыть соединение, если запрос соответствует ожиданиям
- запросы проверки были отправлены (например, в качестве тестового утверждения)
- получать журналы , запросы или ожидания, чтобы помочь отладить	
	
	
### Зачем использовать MockServer
	
MockServer позволяет имитировать любой сервер или службу через HTTP или HTTPS, например службу REST или RPC.

Это полезно в следующих случаях:

1. тестирование
	- легко воссоздавать все типы ответов для зависимостей HTTP, таких как службы REST или RPC, для простого и эффективного тестирования приложений
	- изолировать тестируемую систему, чтобы тесты выполнялись надежно и завершались ошибкой только при наличии подлинной ошибки. Важно, чтобы тестировалась только тестируемая система, а не ее зависимости, чтобы избежать сбоев тестов из-за несущественных внешних изменений, таких как сбой сети или перезагрузка / повторное развертывание сервера.
	- легко настраивать фиктивные ответы независимо для каждого теста, чтобы гарантировать инкапсуляцию тестовых данных с каждым тестом. Избегайте обмена данными между тестами, которыми сложно управлять и поддерживать, и не допускайте заражения тестами друг друга.
	- создавать тестовые утверждения, которые проверяют запросы, отправленные тестируемой системой
2. развитие разъединения
	- начать работу с сервисным API до того, как сервис станет доступен. Если API или сервис еще не полностью разработан, MockServer может имитировать API, позволяя любой команде, использующей сервис, начать работу без задержек.
	- изолировать группы разработчиков на начальных этапах разработки, когда API / сервисы могут быть крайне нестабильными и нестабильными. Использование MockServer позволяет продолжить разработку даже в случае сбоя внешней службы.
3. изолировать одну службу
	- во время развертывания и отладки полезно запускать отдельное приложение или службу или обрабатывать подмножество запросов на локальном компьютере в режиме отладки. Используя MockServer, легко выборочно пересылать запросы локальному процессу, работающему в режиме отладки, все остальные запросы могут быть перенаправлены в реальные службы, например, работающие в среде QA или UAT.
    
  **[⬆ Наверх](#top)**
  
164. ### <a name="164"></a> Websocket, Соединение через websocket в приложении

 Протокол WebSocket («веб-сокет»), описанный в спецификации RFC 6455, обеспечивает возможность обмена данными между браузером и сервером через постоянное соединение. Данные передаются по нему в обоих направлениях в виде «пакетов», без разрыва соединения и дополнительных HTTP-запросов.

WebSocket особенно хорош для сервисов, которые нуждаются в постоянном обмене данными, например онлайн игры, торговые площадки, работающие в реальном времени, и т.д.
	
Чтобы открыть веб-сокет-соединение, нам нужно создать объект new WebSocket, указав в url-адресе специальный протокол ws:
```js
let socket = new WebSocket("ws://javascript.info");
```	
Также существует протокол wss://, использующий шифрование. Это как HTTPS для веб-сокетов.
	
WebSocket – это современный способ иметь постоянное соединение между браузером и сервером.

- Нет ограничений, связанных с кросс-доменными запросами.
- Имеют хорошую поддержку браузерами.
- Могут отправлять/получать как строки, так и бинарные данные.
	
API прост.

Методы:
- socket.send(data),
- socket.close([code], [reason]).
	
События:
- open,
- message,
- error,
- close.
	
WebSocket сам по себе не содержит такие функции, как переподключение при обрыве соединения, аутентификацию пользователей и другие механизмы высокого уровня. Для этого есть клиентские и серверные библиотеки, а также можно реализовать это вручную.

Иногда, чтобы добавить WebSocket к уже существующему проекту, WebSocket-сервер запускают параллельно с основным сервером. Они совместно использует одну базу данных. Запросы к WebSocket отправляются на wss://ws.site.com – поддомен, который ведёт к WebSocket-серверу, в то время как https://site.com ведёт на основной HTTP-сервер.

### Функции
- Обрабатывает логику повторного подключения
- Несколько компонентов могут (необязательно) использовать один WebSocket, который закрывается и очищается, когда все подписанные компоненты отписаны / размонтированы.
- Написано на TypeScript
- Поддержка Socket.io
- Больше не нужно ждать открытия WebSocket перед отправкой сообщений. Сообщения перед подключением ставятся в очередь и отправляются при подключении
- Предоставляет прямой доступ к неразделенным веб-сокетам при проксировании общих веб-сокетов. Прокси-серверы WebSockets предоставляют подписчикам контролируемый доступ к базовому (общему) WebSocket, не допуская небезопасного поведения
- Безупречно работает с событиями, отправленными сервером, и API EventSource.	
	
	
### пример в javascript	
```jsx harmony
let socket = new WebSocket("wss://javascript.info/article/websocket/demo/hello");

socket.onopen = function(e) {
  alert("[open] Соединение установлено");
  alert("Отправляем данные на сервер");
  socket.send("Меня зовут Джон");
};

socket.onmessage = function(event) {
  alert(`[message] Данные получены с сервера: ${event.data}`);
};

socket.onclose = function(event) {
  if (event.wasClean) {
    alert(`[close] Соединение закрыто чисто, код=${event.code} причина=${event.reason}`);
  } else {
    // например, сервер убил процесс или сеть недоступна
    // обычно в этом случае event.code 1006
    alert('[close] Соединение прервано');
  }
};

socket.onerror = function(error) {
  alert(`[error] ${error.message}`);
};	
```
	
### пример в React
```jsx harmony
import React, { useState, useCallback, useMemo, useRef } from 'react';
import useWebSocket, { ReadyState } from 'react-use-websocket';

export const WebSocketDemo = () => {
  //Public API that will echo messages sent to it back to the client
  const [socketUrl, setSocketUrl] = useState('wss://echo.websocket.org');
  const messageHistory = useRef([]);

  const {
    sendMessage,
    lastMessage,
    readyState,
  } = useWebSocket(socketUrl);

  messageHistory.current = useMemo(() =>
    messageHistory.current.concat(lastMessage),[lastMessage]);

  const handleClickChangeSocketUrl = useCallback(() =>
    setSocketUrl('wss://demos.kaazing.com/echo'), []);

  const handleClickSendMessage = useCallback(() =>
    sendMessage('Hello'), []);

  const connectionStatus = {
    [ReadyState.CONNECTING]: 'Connecting',
    [ReadyState.OPEN]: 'Open',
    [ReadyState.CLOSING]: 'Closing',
    [ReadyState.CLOSED]: 'Closed',
    [ReadyState.UNINSTANTIATED]: 'Uninstantiated',
  }[readyState];

  return (
    <div>
      <button
        onClick={handleClickChangeSocketUrl}
      >
        Click Me to change Socket Url
      </button>
      <button
        onClick={handleClickSendMessage}
        disabled={readyState !== ReadyState.OPEN}
      >
        Click Me to send 'Hello'
      </button>
      <span>The WebSocket is currently {connectionStatus}</span>
      {lastMessage ? <span>Last message: {lastMessage.data}</span> : null}
      <ul>
        {messageHistory.current
          .map((message, idx) => <span key={idx}>{message.data}</span>)}
      </ul>
    </div>
  );
};	
```
    
  **[⬆ Наверх](#top)**
  
165. ### <a name="165"></a> 

 
    
  **[⬆ Наверх](#top)**
  
166. ### <a name="166"></a> Предохранители, Error Boundary

 `Предохранители` — это компоненты React, которые отлавливают ошибки JavaScript в любом месте деревьев их дочерних компонентов, сохраняют их в журнале ошибок и выводят запасной UI вместо рухнувшего дерева компонентов.
 
```jsx harmony
 class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { error: null, errorInfo: null };
  }
  
  componentDidCatch(error, errorInfo) {
    // Catch errors in any components below and re-render with error message
    this.setState({
      error: error,
      errorInfo: errorInfo
    })
    // You can also log error messages to an error reporting service here
  }
  
  render() {
    if (this.state.errorInfo) {
      // Error path
      return (
        <div>
          <h2>Something went wrong.</h2>
          <details style={{ whiteSpace: 'pre-wrap' }}>
            {this.state.error && this.state.error.toString()}
            <br />
            {this.state.errorInfo.componentStack}
          </details>
        </div>
      );
    }
    // Normally, just render children
    return this.props.children;
  }  
}

class BuggyCounter extends React.Component {
  constructor(props) {
    super(props);
    this.state = { counter: 0 };
    this.handleClick = this.handleClick.bind(this);
  }
  
  handleClick() {
    this.setState(({counter}) => ({
      counter: counter + 1
    }));
  }
  
  render() {
    if (this.state.counter === 5) {
      // Simulate a JS error
      throw new Error('I crashed!');
    }
    return <h1 onClick={this.handleClick}>{this.state.counter}</h1>;
  }
}

function App() {
  return (
    <div>
      <p>
        <b>
          This is an example of error boundaries in React 16.
          <br /><br />
          Click on the numbers to increase the counters.
          <br />
          The counter is programmed to throw when it reaches 5. This simulates a JavaScript error in a component.
        </b>
      </p>
      <hr />
      <ErrorBoundary>
        <p>These two counters are inside the same error boundary. If one crashes, the error boundary will replace both of them.</p>
        <BuggyCounter />
        <BuggyCounter />
      </ErrorBoundary>
      <hr />
      <p>These two counters are each inside of their own error boundary. So if one crashes, the other is not affected.</p>
      <ErrorBoundary><BuggyCounter /></ErrorBoundary>
      <ErrorBoundary><BuggyCounter /></ErrorBoundary>
    </div>
  );
}



ReactDOM.render(
  <App />,
  document.getElementById('root')
);
```
    
  **[⬆ Наверх](#top)**
  
167. ### <a name="167"></a> SEO оптимизация, Helmet

```jsx harmone
import { Helmet } from "react-helmet";

import ComicsList from "../comicsList/ComicsList";
import AppBanner from "../appBanner/AppBanner";

const ComicsPage = () => {
    return (
        <>
            <Helmet>
                <meta
                    name="description"
                    content="Page with list of our comics"
                />
                <title>Comics page</title>
            </Helmet>
            <AppBanner/>
            <ComicsList/>
        </>
    )
}

export default ComicsPage;				
```				
```jsx harmony
import { Link } from 'react-router-dom';
import { Helmet } from "react-helmet";

import './singleComicLayout.scss';

const SingleComicLayout = ({data}) => {

    const {title, description, pageCount, thumbnail, language, price} = data;

    return (
        <div className="single-comic">
            <Helmet>
                <meta
                    name="description"
                    content={`${title} comics book`}
                />
                <title>{title}</title>
            </Helmet>
            <img src={thumbnail} alt={title} className="single-comic__img"/>
            <div className="single-comic__info">
                <h2 className="single-comic__name">{title}</h2>
                <p className="single-comic__descr">{description}</p>
                <p className="single-comic__descr">{pageCount}</p>
                <p className="single-comic__descr">Language: {language}</p>
                <div className="single-comic__price">{price}</div>
            </div>
            <Link to="/comics" className="single-comic__back">Back to all</Link>
        </div>
    )
}

export default SingleComicLayout;				
```				
				
  **[⬆ Наверх](#top)**
  
168. ### <a name="168"></a> Что такое batching

`Batching` - это когда React обьединяет несколько изменений состояний в одну операцию для улучшения производительности.

В этом случае будем всего один вызов(render), они групирируются.				
```jsx harmony
function App() {
  const [count, setCount] = useState(0);
  const [flag, setFlag] = useState(false);

  function handleClick() {
    setCount(c => c + 1); // Does not re-render yet
    setFlag(f => !f); // Does not re-render yet
    // React will only re-render once at the end (that's batching!)
  }
				
  console.log('render);			

  return (
    <div>
      <button onClick={handleClick}>Next</button>
      <h1 style={{ color: flag ? "blue" : "black" }}>{count}</h1>
    </div>
  );
}				
```				

В таком случае будет два рендера каждый раз, но если мы обновим React и ReactDOM до 18 версии то Batching теперь тоже будет работать и обьединяет несколько изменений состояний в одну операцию.				
```jsx harmony
function App() {
  const [count, setCount] = useState(0);
  const [flag, setFlag] = useState(false);

  function handleClick() {
	setTimeout(() => {
		setCount(c => c + 1);
    		setFlag(f => !f);		
	}, 100)				
  }
				
  console.log('render);			

  return (
    <div>
      <button onClick={handleClick}>Next</button>
      <h1 style={{ color: flag ? "blue" : "black" }}>{count}</h1>
    </div>
  );
}				
```								
				
  **[⬆ Наверх](#top)**
  
169. ### <a name="169"></a> Принцип конечного автомата, FSM, Finite-state machine

`Конечный автомат (state machine)` — это конечный набор состояний, которые могут детерминированно переходить друг в друга из-за событий.				
				
### src/utils/setContent.js
```jsx harmony
import Spinner from '../components/spinner/Spinner';
import ErrorMessage from '../components/errorMessage/ErrorMessage';
import Skeleton from '../components/skeleton/Skeleton';

const setContent = (process, Component, data) => {
    switch (process) {
        case 'waiting':
            return <Skeleton/>;
        case 'loading':
            return <Spinner/>;
        case 'confirmed':
            return <Component data={data}/>;
        case 'error':
            return <ErrorMessage/>;
        default:
            throw new Error('Unexpected process state');
    }
}

export default setContent;				
```

### src/hooks/http.hook.js
```jsx harmony
import { useState, useCallback } from "react";

export const useHttp = () => {
    const [process, setProcess] = useState('waiting');

    const request = useCallback(async (url, method = 'GET', body = null, headers = {'Content-Type': 'application/json'}) => {

        setProcess('loading');

        try {
            const response = await fetch(url, {method, body, headers});

            if (!response.ok) {
                throw new Error(`Could not fetch ${url}, status: ${response.status}`);
            }

            const data = await response.json();

            return data;
        } catch(e) {
            setProcess('error');
            throw e;
        }
    }, []);

    const clearError = useCallback(() => {
        setProcess('loading');
    }, []);

    return {request, clearError, process, setProcess}
}				
```				

### src/services/MarvelService.js
```jsx harmony
import {useHttp} from '../hooks/http.hook';

const useMarvelService = () => {
    const {request, clearError, process, setProcess} = useHttp();

    const _apiBase = 'https://gateway.marvel.com:443/v1/public/';
    // ЗДЕСЬ БУДЕТ ВАШ КЛЮЧ, ЭТОТ КЛЮЧ МОЖЕТ НЕ РАБОТАТЬ
    const _apiKey = 'apikey=c5d6fc8b83116d92ed468ce36bac6c62';
    const _baseOffset = 210;



    const getAllCharacters = async (offset = _baseOffset) => {
        const res = await request(`${_apiBase}characters?limit=9&offset=${offset}&${_apiKey}`);
        return res.data.results.map(_transformCharacter);
    }

    // Вариант модификации готового метода для поиска по имени. 
    // Вызывать его можно вот так: getAllCharacters(null, name)

    // const getAllCharacters = async (offset = _baseOffset, name = '') => {
    //     const res = await request(`${_apiBase}characters?limit=9&offset=${offset}${name ? `&name=${name}` : '' }&${_apiKey}`);
    //     return res.data.results.map(_transformCharacter);
    // }

    // Или можно создать отдельный метод для поиска по имени

    const getCharacterByName = async (name) => {
        const res = await request(`${_apiBase}characters?name=${name}&${_apiKey}`);
        return res.data.results.map(_transformCharacter);
    }

    const getCharacter = async (id) => {
        const res = await request(`${_apiBase}characters/${id}?${_apiKey}`);
        return _transformCharacter(res.data.results[0]);
    }

    const getAllComics = async (offset = 0) => {
        const res = await request(`${_apiBase}comics?orderBy=issueNumber&limit=8&offset=${offset}&${_apiKey}`);
        return res.data.results.map(_transformComics);
    }

    const getComic = async (id) => {
        const res = await request(`${_apiBase}comics/${id}?${_apiKey}`);
        return _transformComics(res.data.results[0]);
    }

    const _transformCharacter = (char) => {
        return {
            id: char.id,
            name: char.name,
            description: char.description ? `${char.description.slice(0, 210)}...` : 'There is no description for this character',
            thumbnail: char.thumbnail.path + '.' + char.thumbnail.extension,
            homepage: char.urls[0].url,
            wiki: char.urls[1].url,
            comics: char.comics.items
        }
    }

    const _transformComics = (comics) => {
        return {
            id: comics.id,
            title: comics.title,
            description: comics.description || 'There is no description',
            pageCount: comics.pageCount ? `${comics.pageCount} p.` : 'No information about the number of pages',
            thumbnail: comics.thumbnail.path + '.' + comics.thumbnail.extension,
            language: comics.textObjects.language || 'en-us',
            price: comics.prices[0].price ? `${comics.prices[0].price}$` : 'not available'
        }
    }

    return {
            clearError, 
            process, 
            setProcess,
            getAllCharacters, 
            getCharacterByName, 
            getCharacter, 
            getAllComics, 
            getComic}
}

export default useMarvelService;				
```				

### src/components/charInfo/CharInfo.js 
```jsx harmony
import { useState, useEffect } from 'react';
import PropTypes from 'prop-types';

import useMarvelService from '../../services/MarvelService';
import setContent from '../../utils/setContent';

import './charInfo.scss';

const CharInfo = (props) => {

    const [char, setChar] = useState(null);

    const {getCharacter, clearError, process, setProcess} = useMarvelService();

    useEffect(() => {
        updateChar()
        // eslint-disable-next-line
    }, [props.charId])

    const updateChar = () => {
        const {charId} = props;
        if (!charId) {
            return;
        }

        clearError();
        getCharacter(charId)
            .then(onCharLoaded)
            .then(() => setProcess('confirmed'))
    }

    const onCharLoaded = (char) => {
        setChar(char);
    }

    return (
        <div className="char__info">
            {setContent(process, View, char)}
        </div>
    )
}

const View = ({data}) => {
    const {name, description, thumbnail, homepage, wiki, comics} = data;

    let imgStyle = {'objectFit' : 'cover'};
    if (thumbnail === 'http://i.annihil.us/u/prod/marvel/i/mg/b/40/image_not_available.jpg') {
        imgStyle = {'objectFit' : 'contain'};
    }

    return (
        <>
            <div className="char__basics">
                <img src={thumbnail} alt={name} style={imgStyle}/>
                <div>
                    <div className="char__info-name">{name}</div>
                    <div className="char__btns">
                        <a href={homepage} className="button button__main">
                            <div className="inner">homepage</div>
                        </a>
                        <a href={wiki} className="button button__secondary">
                            <div className="inner">Wiki</div>
                        </a>
                    </div>
                </div>
            </div>
            <div className="char__descr">
                {description}
            </div>
            <div className="char__comics">Comics:</div>
            <ul className="char__comics-list">
                {comics.length > 0 ? null : 'There is no comics with this character'}
                {
                    comics.map((item, i) => {
                        // eslint-disable-next-line
                        if (i > 9) return;
                        return (
                            <li key={i} className="char__comics-item">
                                {item.name}
                            </li>
                        )
                    })
                }                
            </ul>
        </>
    )
}

CharInfo.propTypes = {
    charId: PropTypes.number
}

export default CharInfo;				
```				

### src/components/charList/CharList.js
```jsx harmony
import {useState, useEffect, useRef, useMemo} from 'react';
import PropTypes from 'prop-types';
import {CSSTransition, TransitionGroup} from 'react-transition-group';

import useMarvelService from '../../services/MarvelService';
import Spinner from '../spinner/Spinner';
import ErrorMessage from '../errorMessage/ErrorMessage';

import './charList.scss';

const setContent = (process, Component, newItemLoading) => {
    switch (process) {
        case 'waiting':
            return <Spinner/>;
        case 'loading':
            return newItemLoading ? <Component/> : <Spinner/>;
        case 'confirmed':
            return <Component/>;
        case 'error':
            return <ErrorMessage/>;
        default:
            throw new Error('Unexpected process state');
    }
}

const CharList = (props) => {

    const [charList, setCharList] = useState([]);
    const [newItemLoading, setnewItemLoading] = useState(false);
    const [offset, setOffset] = useState(210);
    const [charEnded, setCharEnded] = useState(false);
    
    const {getAllCharacters, process, setProcess} = useMarvelService();

    useEffect(() => {
        onRequest(offset, true);
        // eslint-disable-next-line
    }, [])

    const onRequest = (offset, initial) => {
        initial ? setnewItemLoading(false) : setnewItemLoading(true);
        getAllCharacters(offset)
            .then(onCharListLoaded)
            .then(() => setProcess('confirmed'));
    }

    const onCharListLoaded = async(newCharList) => {
        let ended = false;
        if (newCharList.length < 9) {
            ended = true;
        }
        setCharList([...charList, ...newCharList]);
        setnewItemLoading(false);
        setOffset(offset + 9);
        setCharEnded(ended);
    }

    const itemRefs = useRef([]);

    const focusOnItem = (id) => {
        itemRefs.current.forEach(item => item.classList.remove('char__item_selected'));
        itemRefs.current[id].classList.add('char__item_selected');
        itemRefs.current[id].focus();
    }

    const renderItems = arr => {
        const items =  arr.map((item, i) => {
            let imgStyle = {'objectFit' : 'cover'};
            if (item.thumbnail === 'http://i.annihil.us/u/prod/marvel/i/mg/b/40/image_not_available.jpg') {
                imgStyle = {'objectFit' : 'unset'};
            }
            
            return (
                <CSSTransition key={item.id} timeout={500} classNames="char__item">
                    <li 
                        className="char__item"
                        tabIndex={0}
                        ref={el => itemRefs.current[i] = el}
                        onClick={() => {
                            props.onCharSelected(item.id);
                            focusOnItem(i);
                        }}
                        onKeyPress={(e) => {
                            if (e.key === ' ' || e.key === "Enter") {
                                props.onCharSelected(item.id);
                                focusOnItem(i);
                            }
                        }}>
                            <img src={item.thumbnail} alt={item.name} style={imgStyle}/>
                            <div className="char__name">{item.name}</div>
                    </li>
                </CSSTransition>
            )
        });

        return (
            <ul className="char__grid">
                <TransitionGroup component={null}>
                    {items}
                </TransitionGroup>
            </ul>
        )
    }

    const elements = useMemo(() => {
        return setContent(process, () => renderItems(charList), newItemLoading);
        // eslint-disable-next-line
    }, [process])

    // TransitionGroup работать не будет за счет постоянного пересоздания компонента
    // разбор в следующем уроке
    return (
        <div className="char__list">
            {elements}
            <button 
                disabled={newItemLoading} 
                style={{'display' : charEnded ? 'none' : 'block'}}
                className="button button__main button__long"
                onClick={() => onRequest(offset)}>
                <div className="inner">load more</div>
            </button>
        </div>
    )
}

CharList.propTypes = {
    onCharSelected: PropTypes.func.isRequired
}

export default CharList;				
```				

### src/components/charSearchForm/CharSearchForm.js
```jsx harmony
import {useState} from 'react';
import { Formik, Form, Field, ErrorMessage as FormikErrorMessage } from 'formik';
import * as Yup from 'yup';
import {Link} from 'react-router-dom';

import useMarvelService from '../../services/MarvelService';
import ErrorMessage from '../errorMessage/ErrorMessage';

import './charSearchForm.scss';

const CharSearchForm = () => {
    const [char, setChar] = useState(null);
    const {getCharacterByName, clearError, process, setProcess} = useMarvelService();

    const onCharLoaded = (char) => {
        setChar(char);
    }

    const updateChar = (name) => {
        clearError();

        getCharacterByName(name)
            .then(onCharLoaded)
            .then(() => setProcess('confirmed'));
    }

    const errorMessage = process === 'error' ? <div className="char__search-critical-error"><ErrorMessage /></div> : null;
    const results = !char ? null : char.length > 0 ?
                    <div className="char__search-wrapper">
                        <div className="char__search-success">There is! Visit {char[0].name} page?</div>
                        <Link to={`/characters/${char[0].id}`} className="button button__secondary">
                            <div className="inner">To page</div>
                        </Link>
                    </div> : 
                    <div className="char__search-error">
                        The character was not found. Check the name and try again
                    </div>;

    return (
        <div className="char__search-form">
            <Formik
                initialValues = {{
                    charName: ''
                }}
                validationSchema = {Yup.object({
                    charName: Yup.string().required('This field is required')
                })}
                onSubmit = { ({charName}) => {
                    updateChar(charName);
                }}
            >
                <Form>
                    <label className="char__search-label" htmlFor="charName">Or find a character by name:</label>
                    <div className="char__search-wrapper">
                        <Field 
                            id="charName" 
                            name='charName' 
                            type='text' 
                            placeholder="Enter name"/>
                        <button 
                            type='submit' 
                            className="button button__main"
                            disabled={process === 'loading'}>
                            <div className="inner">find</div>
                        </button>
                    </div>
                    <FormikErrorMessage component="div" className="char__search-error" name="charName" />
                </Form>
            </Formik>
            {results}
            {errorMessage}
        </div>
    )
}

export default CharSearchForm;				
```				

### src/components/comicsList/ComicsList.js
```jsx harmony
import {useState, useEffect} from 'react';
import { Link } from 'react-router-dom';

import useMarvelService from '../../services/MarvelService';
import Spinner from '../spinner/Spinner';
import ErrorMessage from '../errorMessage/ErrorMessage';

import './comicsList.scss';

const setContent = (process, Component, newItemLoading) => {
    switch (process) {
        case 'waiting':
            return <Spinner/>;
        case 'loading':
            return newItemLoading ? <Component/> : <Spinner/>;
        case 'confirmed':
            return <Component/>;
        case 'error':
            return <ErrorMessage/>;
        default:
            throw new Error('Unexpected process state');
    }
}

const ComicsList = () => {

    const [comicsList, setComicsList] = useState([]);
    const [newItemLoading, setnewItemLoading] = useState(false);
    const [offset, setOffset] = useState(0);
    const [comicsEnded, setComicsEnded] = useState(false);

    const {getAllComics, process, setProcess} = useMarvelService();

    useEffect(() => {
        onRequest(offset, true);
        // eslint-disable-next-line
    }, [])

    const onRequest = (offset, initial) => {
        initial ? setnewItemLoading(false) : setnewItemLoading(true);
        getAllComics(offset)
            .then(onComicsListLoaded)
            .then(() => setProcess('confirmed'));
    }

    const onComicsListLoaded = (newComicsList) => {
        let ended = false;
        if (newComicsList.length < 8) {
            ended = true;
        }
        setComicsList([...comicsList, ...newComicsList]);
        setnewItemLoading(false);
        setOffset(offset + 8);
        setComicsEnded(ended);
    }

    function renderItems (arr) {
        const items = arr.map((item, i) => {
            return (
                <li className="comics__item" key={i}>
                    <Link to={`/comics/${item.id}`}>
                        <img src={item.thumbnail} alt={item.title} className="comics__item-img"/>
                        <div className="comics__item-name">{item.title}</div>
                        <div className="comics__item-price">{item.price}</div>
                    </Link>
                </li>
            )
        })

        return (
            <ul className="comics__grid">
                {items}
            </ul>
        )
    }

    return (
        <div className="comics__list">
            {setContent(process, () => renderItems(comicsList), newItemLoading)}
            <button 
                disabled={newItemLoading} 
                style={{'display' : comicsEnded ? 'none' : 'block'}}
                className="button button__main button__long"
                onClick={() => onRequest(offset)}>
                <div className="inner">load more</div>
            </button>
        </div>
    )
}

export default ComicsList;				
```				

### src/components/randomChar/RandomChar.js
```jsx harmony
import {useState, useEffect} from 'react';
import useMarvelService from '../../services/MarvelService';
import setContent from '../../utils/setContent';

import './randomChar.scss';
import mjolnir from '../../resources/img/mjolnir.png';

const RandomChar = () => {

    const [char, setChar] = useState(null);
    const {getCharacter, clearError, process, setProcess} = useMarvelService();

    useEffect(() => {
        updateChar();
        const timerId = setInterval(updateChar, 60000);

        return () => {
            clearInterval(timerId)
        }
        // eslint-disable-next-line
    }, [])

    const onCharLoaded = (char) => {
        setChar(char);
    }

    const updateChar = () => {
        clearError();
        const id = Math.floor(Math.random() * (1011400 - 1011000)) + 1011000;
        getCharacter(id)
            .then(onCharLoaded)
            .then(() => setProcess('confirmed'));
    }

    return (
        <div className="randomchar">
            {setContent(process, View, char)}
            <div className="randomchar__static">
                <p className="randomchar__title">
                    Random character for today!<br/>
                    Do you want to get to know him better?
                </p>
                <p className="randomchar__title">
                    Or choose another one
                </p>
                <button onClick={updateChar} className="button button__main">
                    <div className="inner">try it</div>
                </button>
                <img src={mjolnir} alt="mjolnir" className="randomchar__decoration"/>
            </div>
        </div>
    )
}

const View = ({data}) => {
    const {name, description, thumbnail, homepage, wiki} = data;
    let imgStyle = {'objectFit' : 'cover'};
    if (thumbnail === 'http://i.annihil.us/u/prod/marvel/i/mg/b/40/image_not_available.jpg') {
        imgStyle = {'objectFit' : 'contain'};
    }

    return (
        <div className="randomchar__block">
            <img src={thumbnail} alt="Random character" className="randomchar__img" style={imgStyle}/>
            <div className="randomchar__info">
                <p className="randomchar__name">{name}</p>
                <p className="randomchar__descr">
                    {description}
                </p>
                <div className="randomchar__btns">
                    <a href={homepage} className="button button__main">
                        <div className="inner">homepage</div>
                    </a>
                    <a href={wiki} className="button button__secondary">
                        <div className="inner">Wiki</div>
                    </a>
                </div>
            </div>
        </div>
    )
}

export default RandomChar;				
```				

### src/components/pages/SinglePage.js
```jsx harmony
import { useParams } from 'react-router-dom';
import { useState, useEffect } from 'react';

import useMarvelService from '../../services/MarvelService';
import AppBanner from "../appBanner/AppBanner";
import setContent from '../../utils/setContent';

const SinglePage = ({Component, dataType}) => {
        const {id} = useParams();
        const [data, setData] = useState(null);
        const {getComic, getCharacter, clearError, process, setProcess} = useMarvelService();

        useEffect(() => {
            updateData();
            // eslint-disable-next-line
        }, [id])

        const updateData = () => {
            clearError();

            switch (dataType) {
                case 'comic':
                    getComic(id).then(onDataLoaded).then(() => setProcess('confirmed'));
                    break;
                case 'character':
                    getCharacter(id).then(onDataLoaded).then(() => setProcess('confirmed'));
                    break;
                default:
                    return;
            }
        }

        const onDataLoaded = (data) => {
            setData(data);
        }

        return (
            <>
                <AppBanner/>
                {setContent(process, Component, data)}
            </>
        )
}

export default SinglePage;				
```								
				
  **[⬆ Наверх](#top)**
 
170. ### <a name="170"></a> 

 
    
  **[⬆ Наверх](#top)**
  
171. ### <a name="171"></a> 

 
    
  **[⬆ Наверх](#top)**
  
172. ### <a name="172"></a> 

 
    
  **[⬆ Наверх](#top)**
  
173. ### <a name="173"></a> 

 
    
  **[⬆ Наверх](#top)**
  
250. ### <a name="250"></a> Рекурсия для дочерних компонентов

 Рекурсия по дочерним элементам
По умолчанию при рекурсивном обходе дочерних элементов DOM-узла React проходит по обоим спискам потомков одновременно и создаёт мутацию, когда находит отличие.

Например, при добавлении элемента в конец дочерних элементов, преобразование между этими деревьями работает отлично:
```jsx harmony
<ul>
  <li>первый</li>
  <li>второй</li>
</ul>

<ul>
  <li>первый</li>
  <li>второй</li>
  <li>третий</li>
</ul>
```
React сравнит два дерева <li первый</li, сравнит два дерева <li второй</li, а затем вставит дерево <li третий</li.

Если попробовать реализовать это наивно, вставив элемент в начало, то пострадает производительность. Например, преобразование между этими деревьями работает плохо:
```jsx harmony
<ul>
  <li>Санкт-Петербург</li>
  <li>Москва</li>
</ul>

<ul>
  <li>Ростов-на-Дону</li>
  <li>Санкт-Петербург</li>
  <li>Москва</li>
</ul>
```
React будет мутировать каждого потомка, вместо того чтобы оставить <li Санкт-Петербург</li>  и <li Москва</li> нетронутыми. Эта неэффективность может стать проблемой.

### Ключи

Для решения этой проблемы React поддерживает атрибут key. Когда у дочерних элементов есть ключи, React использует их, чтобы сопоставить потомков исходного дерева с потомками последующего дерева. Например, если добавить key к неэффективному примеру выше, преобразование дерева станет эффективным:
```jsx harmony
<ul>
  <li key="2015">Санкт-Петербург</li>
  <li key="2016">Москва</li>
</ul>

<ul>
  <li key="2014">Ростов-на-Дону</li>
  <li key="2015">Санкт-Петербург</li>
  <li key="2016">Москва</li>
</ul>
```
Теперь React знает, что элемент с ключом '2014' — новый, а элементы с ключами '2015' и '2016' только что переместились.

На практике найти ключ обычно несложно. Элемент, который вы хотите отобразить, уже может иметь уникальный идентификатор, и ключ может быть взят из ваших данных:
```jsx harmony
<li key={item.id}>{item.name}</li>
```
Когда уникальное значение отсутствует, вы можете добавить новое свойство идентификатора в вашу модель или прохешировать данные, чтобы сгенерировать ключ. Ключ должен быть уникальным только среди его соседей, а не глобально.
    
  **[⬆ Наверх](#top)**
  
251. ### <a name="251"></a> Что такое предохранители (error boundaries)

 `Error boundaries` - это React-компоненты, которые перехватывают любые ошибки, возникающие в дереве потомков, выводят сообщения об ошибках в консоль и отображают резервный UI вместо "сломанного". Предохранители перехватывают ошибки во время рендеринга, в методах жизненного цикла и в конструкторах любых дочерних компонентов.

Классовый компонент становится предохранителем, когда в нем определяются методы жизненного цикла `static getDerivedStateFromError()` или `componentDidCatch()` (один или оба). `static getDerivedStateFromError()` используется для рендеринга запасного UI после возникновения ошибки. `componentDidCatch()` используется для вывода сообщения об ошибке в консоль.

*Пример*

```js
import React, { Component } from 'react'

class ErrorBoundary extends Component {
   state = {
      isErrorOccured: false,
      errorMessage: ''
   }
   componentDidCatch = (error, info) => {
      this.setState({
        isErrorOccured: true,
        errorMessage: error
      })
   }
   render() {
      if(this.state.isErrorOccured) {
         return <p>Что-то пошло не так</p>
      } else {
         return <div>{this.props.children}</div>
      }
   }
}

export default ErrorBoundary
```

Здесь у нас имеется объект состояния с двумя свойствами - `isErrorOccured` и `errorMessage`, которые будут обновлены при возникновении ошибки. Для обновления состояния мы используем метод `componentDidCatch()`, принимающий два аргумента - `error` и `info`.

**Как использовать предохранитель?**

```js
<ErrorBoundary>
   <User/>
</ErrorBoundary>
```

**Предохранители не перехватывают ошибки в:**

* Обработчиках событий
* Асинхронном коде (например, в `setTimeout()`)
* При серверном рендеринге
* При выбрасывании исключения в самом предохранителе
    
  **[⬆ Наверх](#top)**
  
252. ### <a name="252"></a> keys в React. Метод жизненного цикла shouldComponentUpdate

 ### Ключи

Ключи помогают React определять, какие элементы были изменены, добавлены или удалены. Их необходимо указывать, чтобы React мог сопоставлять элементы массива с течением времени:
```jsx harmony
const numbers = [1, 2, 3, 4, 5];
const listItems = numbers.map((number) =>
  <li key={number.toString()}>
    {number}
  </li>
);
```
Лучший способ выбрать ключ — это использовать строку, которая будет явно отличать элемент списка от его соседей. Чаще всего вы будете использовать ID из ваших данных как ключи:
```jsx harmony
const todoItems = todos.map((todo) =>
  <li key={todo.id}>
    {todo.text}
  </li>
);
```
Когда у вас нет заданных ID для списка, то в крайнем случае можно использовать индекс элемента как ключ:
```jsx harmony
const todoItems = todos.map((todo, index) =>
  // Делайте так, только если у элементов массива нет заданного ID
  <li key={index}>
    {todo.text}
  </li>
);
```
Мы не рекомендуем использовать индексы как ключи, если порядок элементов может поменяться. Это негативно скажется на производительности и может вызвать проблемы с состоянием компонента. Почитайте статью Робина Покорни (Robin Pokorny), которая объясняет, почему индексы-ключи приводят к проблемам. Если вы опустите ключ для элемента в списке, то React по умолчанию будет использовать индексы как ключи.

### shouldComponentUpdate

shouldComponentUpdate(nextProps, nextState)

Используйте shouldComponentUpdate(), чтобы указать необходимость следующего рендера на основе изменений состояния и пропсов. По умолчанию происходит повторный рендер при любом изменении состояния. В большинстве случаев вы должны полагаться на это поведение.

shouldComponentUpdate() вызывается перед рендером, когда получает новые пропсы или состояние. Значение по умолчанию равно true. Этот метод не вызывается при первом рендере или когда используется forceUpdate().

Этот метод нужен только для повышения производительности. Но не опирайтесь на его возможность «предотвратить» рендер, это может привести к багам. Вместо этого используйте PureComponent, который позволяет не описывать поведение shouldComponentUpdate() вручную. PureComponent поверхностно сравнивает пропсы и состояние и позволяет не пропустить необходимое обновление.

Если вы уверены, что хотите написать его вручную, вы можете сравнить this.props с nextProps, а this.state с nextState. Верните false чтобы пропустить обновление React. Возврат false не предотвращает повторный рендер дочерних компонентов при изменении их состояния.

Мы не рекомендуем делать глубокое сравнение или использовать JSON.stringify() в shouldComponentUpdate(). Это неэффективно и плохо влияет на производительность.

В настоящее время, если shouldComponentUpdate() возвращает false, то UNSAFE_componentWillUpdate(), render() и componentDidUpdate() не будут вызваны. В будущем React может рассматривать shouldComponentUpdate() как подсказку, а не строгое указание. В таком случае возврат false сможет привести к повторному рендеру компонента.
    
  **[⬆ Наверх](#top)**
  
253. ### <a name="253"></a> react-router v5

 React Router это стандартная библиотека маршрутизации (routing) в React. Он хранит интерфейс приложения синхронизированным с URL на браузере. React Router позволяет вам маршрутизировать "поток данных" (data flow) в вашем приложении понятным способом.

### 1. Основная маршрутизация

В приведенном ниже примере у нас имеется 3 страницы, обрабатываемые роутером: главная (home), контакты (about) и страница с пользователями (users). При клике по <Link> (ссылке) роутер рендерит соответствующий <Route> (маршрут, путь).

Обратите внимание: за сценой <Link> рендерит <a> с настоящим href, так что люди, использующие клавиатуру для навигации или экранные считываюющие устройства (screen readers), смогут без проблем пользоваться приложением.
```jsx harmony
import React from 'react'
import {
  BrowserRouter as Router,
  Switch,
  Route,
  Link
} from 'react-router-dom'

export const App = () => (
  <Router>
      <header>
        <nav>
          <ul>
            <li>
              <Link to="/">Главная</Link>
            </li>
            <li>
              <Link to="/about">Контакты</Link>
            </li>
            <li>
              <Link to="/users">Пользователи</Link>
            </li>
          </ul>
        </nav>
      </header>

      <main>
        {/* <Switch> рендерит первый <Route>, совпавший с URL */}
        <Switch>
          <Route path="/about">
            <About />
          </Route>
          <Route path="/users">
            <Users />
          </Route>
          <Route path="/">
            <Home />
          </Route>
        </Switch>
      </main>
  </Router>
)

const Home = () => <h2>Главная</h2>

const About = () => <h2>Контакты</h2>

const Users = () => <h2>Пользователи</h2>
```	      
	      
### 2. Вложенный роутинг
	      
Ниже приводится пример вложенного роутинга. Маршрут /topics загружает компонент Topics, который, в свою очередь, рендерит дальнейшие <Route> на основе значения :id.
```jsx harmony
import React from "react"
import {
  BrowserRouter as Router,
  Switch,
  Route,
  Link,
  useRouteMatch,
  useParams
} from "react-router-dom"

export const App = () => (
  <Router>
    <header>
      <nav>
        <ul>
          <li>
            <Link to="/">Главная</Link>
          </li>
          <li>
            <Link to="/about">Контакты</Link>
          </li>
          <li>
            <Link to="/topics">Темы</Link>
          </li>
        </ul>
      </nav>
    </header>

    <main>
      <Switch>
        <Route path="/about">
          <About />
        </Route>
        <Route path="/topics">
          <Topics />
        </Route>
        <Route path="/">
          <Home />
        </Route>
      </Switch>
    </main>
  </Router>
)

const Home = () => <h2>Главная</h2>

const About = () => <h2>Контакты</h2>

function Topics() {
  const match = useRouteMatch()

  return (
    <>
      <h2>Темы</h2>

      <nav>
        <ul>
          <li>
            <Link to={`${match.url}/components`}>Компоненты</Link>
          </li>
          <li>
            <Link to={`${match.url}/props-vs-state`}>Пропы против состояния</Link>
          </li>
        </ul>
      </nav>

      {/* Страница Topics имеет собственный <Switch> с маршрутами,
          основанными на URL /topics. Вы можете думать о втором
          <Route> как о странице для остальных тем
          или как о странице, отображаемой,
          когда ни одна из тем не выбрана */}
      <div>
        <Switch>
          <Route path={`${match.path}/:topicId`}>
            <Topic />
          </Route>
          <Route path={match.path}>
            <h3>Пожалуйста, выберите тему.</h3>
          </Route>
        </Switch>
      </div>
    </>
  )
}

function Topic() {
  const { topicId } = useParams()
  return <h3>Идентификатор выбранной темы: {topicId}</h3>
}
```
	      
### Основные компоненты
	      
В React Router существует 3 категории компонентов:

- роутеры (routers), например, <BrowserRouter> или <HashRouter>
- маршруты (route matchers), например, <Route> или <Switch>
- и навигация (navigation), например, <Link>, <NavLink> или <Redirect>
	      
Все компоненты, используемые в веб-приложении, должны быть импортированы из react-router-dom.

### Роутеры
	      
Любая маршрутизация начинается с роутера. Для веб-проектов react-router-dom предоставляет <BrowserRouter> и <HashRouter>. Основное отличие между ними состоит в способе хранения URL и взаимодействия с сервером.

<BrowserRouter> использует обычные URL. В этом случае URL выглядят как обычно, но требуется определенная настройка сервера. В частности, сервер должен обслуживать все страницы, используемые на клиенте. Create React App поддерживает это из коробки в режиме разработки и содержит инструкции для правильной настройки сервера.
<HashRouter> хранить текущую локацию в хэш-части URL (после символа "#"), поэтому URL выглядит примерно так: http://example.com/#/your/page. Поскольку хэш не отправляется серверу, его специальная настройка не требуется.
	
Для использования роутера необходимо обернуть в него компонент верхнего уровня:
	
```jsx harmony
import React from "react"
import ReactDOM from "react-dom"
import { BrowserRouter } from "react-router-dom"

const App = () => <h1>Привет, React Router</h1>

ReactDOM.render(
  <BrowserRouter>
    <App />
  </BrowserRouter>,
  document.getElementById("root")
)	      
```	      

### Маршруты
	
Существует 2 вида компонентов для поиска совпадений с URL: Switch и Route. При рендеринге <Switch> определяет <Route>, соответствующий текущему URL. При обнаружении такого маршрута, он рендерится, остальные маршруты игнорируются. Это означает, что вы должны помещать более специфические маршруты перед менее специфическими.

Если совпадения не найдено, <Switch> ничего не рендерит (точнее, рендерит null).
```jsx harmony
import React from "react"
import ReactDOM from "react-dom"
import {
  BrowserRouter as Router,
  Switch,
  Route
} from "react-router-dom"

const App = () => (
  <main>
    <Switch>
      {/* Если текущим URL является /about, рандерится данный маршрут,
          остальные игнорируются */}
      <Route path="/about">
        <About />
      </Route>

      {/* Обратите внимание на порядок расположения этих двух маршрутов.
          Более специфический path="/contact/:id" находится перед path="/contact" */}
      <Route path="/contact/:id">
        <Contact />
      </Route>
      <Route path="/contact">
        <AllContacts />
      </Route>

      {/* Если ни один из предыдущих роутеров не совпал,
          рендерится данный маршрут (он является резервным).

          Важно: маршрут с path="/" всегда будет совпадать с
          URL, поскольку все URL начинаются с /. Поэтому
          мы поместили его последним */}
      <Route path="/">
        <Home />
      </Route>
    </Switch>
  </main>
)

ReactDOM.render(
  <Router>
    <App />
  </Router>,
  document.getElementById("root")
)
```	
	
Обратите внимание, что <Route path> ищет совпадение с началом, а не со всем URL. Поэтому <Route path="/"> всегда будет совпадать с URL. Поэтому в <Switch> мы, обычно, помещаем его последним. Другим возможным решением является использование атрибута exact: <Route exact path="/">, который заставляет роутер искать полное совпадение.

### Навигация
	
React Router предоставляет компонент <Link> для создания ссылок в приложении. При использовании <Link> в HTML рендерится <a>.
	
```jsx harmony
<Link to="/">Главная</Link>
// <a href="/">Главная</a>
```	
	
<NavLink> - это специальный тип <Link>, позволяющий определять стили для активного состояния ссылки.
```jsx harmony
<NavLink to="/react" activeClassName="hurray">
  React
</NavLink>

// Когда URL является /react, рендерится это:
// <a href="/react" className="hurray">React</a>

// Когда URL является другим:
// <a href="/react">React</a>
```	
Для принудительной навигации используется <Redirect>. При рендеринге <Redirect> выполняется перенаправление.
```jsx harmony
<Redirect to="/login">	
```	

## Пример с проекта
	
### App.js	
```jsx harmony
import {BrowserRouter as Router, Route, Switch} from 'react-router-dom';

import {MainPage, ComicsPage} from '../pages';
import AppHeader from "../appHeader/AppHeader";

const App = () => {
    
    return (
        <Router>
            <div className="app">
                <AppHeader/>
                <main>
                    <Switch>
                        <Route exact path="/">
                            <MainPage/>
                        </Route>
                        <Route exact path="/comics">
                            <ComicsPage/>
                        </Route>
                    </Switch>
                </main>
            </div>
        </Router>
    )
}

export default App;	
```	
### MainPage.js
```jsx harmony
import { useState } from "react";

import RandomChar from "../randomChar/RandomChar";
import CharList from "../charList/CharList";
import CharInfo from "../charInfo/CharInfo";
import ErrorBoundary from "../errorBoundary/ErrorBoundary";

import decoration from '../../resources/img/vision.png';

const MainPage = () => {

    const [selectedChar, setChar] = useState(null);

    const onCharSelected = (id) => {
        setChar(id);
    }

    return (
        <>
            <ErrorBoundary>
                <RandomChar/>
            </ErrorBoundary>
            <div className="char__content">
                <ErrorBoundary>
                    <CharList onCharSelected={onCharSelected}/>
                </ErrorBoundary>
                <ErrorBoundary>
                    <CharInfo charId={selectedChar}/>
                </ErrorBoundary>
            </div>
            <img className="bg-decoration" src={decoration} alt="vision"/>
        </>
    )
}

export default MainPage;	
```
### ComicsPage.js
```jsx harmony
import ComicsList from "../comicsList/ComicsList";
import AppBanner from "../appBanner/AppBanner";

const ComicsPage = () => {
    return (
        <>
            <AppBanner/>
            <ComicsList/>
        </>
    )
}

export default ComicsPage;	
```	
	
https://github.com/harryheman/React-Total/blob/main/md/react-router.md#%D1%81%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B0%D0%BD%D0%B8%D0%B5
    
  **[⬆ Наверх](#top)**
  
254. ### <a name="254"></a> Route, Switch, Link v6

 ### <a name="router"></a> `<Router>`

Общий низкоуровневый интерфейс для компонентов роутера. Обычно, используется один из следующих роутеров:

- [&lt;BrowserRouter>](#browser)
- [&lt;HashRouter>](#hash)
- [&lt;MemoryRouter>](#memory)
- [&lt;StaticRouter>](#static)
- `<NativeRouter>`

- [Route](#route)		
- [Switch](#switch)	
- [Link](#link)	
- [NavLink](#nav)
- [Redirect](#redirect)
	
	
Одним из случаев использования низкоуровневого `<Router>` является синхронизация пользовательской истории с такими библиотеками для управления состоянием приложения, как `Redux` или `MobX`. *Обратите внимание*, что делать этого не рекомендуется.

#### Пропы

- `history`: object - атрибут, используемый для навигации
- `children`: node - дочерний элемент

	
### <a name="browser"></a> `<BrowserRouter>`

`<Router>`, использующий `HTML5 history API` (события "pushState", "replaceState" и "popState") для синхронизации UI с URL.

```js
<BrowserRouter
  basename={optionalString}
  forceRefresh={optionalBool}
  getUserConfirmation={optionalFunc}
  keyLength={optionalNumber}
>
  <App />
</BrowserRouter>
```

#### Пропы

- `basename`: string - базовый URL для всех локаций. Если приложение обслуживается из поддиректории на сервере, базовый URL должен иметь значение данной поддиректории

```js
<BrowserRouter basename="/calendar">
    <Link to="/today"/> // рендерится как <a href="/calendar/today">
    <Link to="/tomorrow"/> // рендерится как <a href="/calendar/tomorrow">
    ...
</BrowserRouter>
```

- `getUserConfirmation`: func - функция для подтверждения перехода на другую страницу (по умолчанию используется `window.confirm`)

```js
<BrowserRouter
  getUserConfirmation={(message, callback) => {
    // поведение по умолчанию
    const allowTransition = window.confirm(message)
    callback(allowTransition)
  }}
/>
```

- `forceRefresh`: bool - если `true`, выполняется полное обновление страницы. Используется для имитации поведения сервера при переключении страниц
- `keyLength`: number - длина `location.key` (по умолчанию равняется 6)
- `children`: node - дочерние элементы

**[⬆ 254](#254)**	

	
### <a name="hash"></a> `<HashRouter>`

`<Router>`, использующий хэш-часть URL (т.е. `window.location.hash`) для синхронизации UI с URL.

*Обратите внимание*, что хэш-история не поддерживает `location.key` или `location.state`.

```js
<HashRouter
  basename={optionalString}
  getUserConfirmation={optionalFunc}
  hashType={optionalString}
>
  <App />
</HashRouter>
```

#### Пропы

- `basename`: string - базовый URL для всех локаций

```js
<HashRouter basename="/calendar"/>
<Link to="/today"/> // рендерится как <a href="#/calendar/today">
```

- `getUserConfirmation`: func - функция для подтверждения перехода на другую страницу (по умолчанию используется `window.confirm`)
- `hashType`: string - тип кодировки для `window.location.hash`. Доступные значения:
  - `slash` - `#/` и `#/sunshine/lollipops` (значение по умолчанию)
  - `noslash` - `#` и `#sunshine/lollipops`
  - `hashbang` - `#!/` и `#!/sunshine/lollipops` (признан устаревшим в Chrome)
- `children`: node - дочерний элемент

**[⬆ 254](#254)**
	
	
### <a name="memory"></a> `<MemoryRouter>`

`<Router>`, хранящий историю URL в памяти (не читает и не пишет в адресную строку). Используется для тестирования и вне браузера (например, в `React Native`).

```js
<MemoryRouter
  initialEntries={optionalArray}
  initialIndex={optionalNumber}
  getUserConfirmation={optionalFunc}
  keyLength={optionalNumber}
>
  <App />
</MemoryRouter>
```

#### Пропы

- `initialEntries`: array - массив локаций в стеке истории. Локации могут быть полноценными объектами с `{ pathname, search, hash, state }` или строками

```js
<MemoryRouter
  initialEntries={["/one", "/two", { pathname: "/three" }]}
  initialIndex={1}
>
  <App />
</MemoryRouter>
```

- `initialIndex`: number - индекс начальной локации в массиве `initialEntries`
- `getUserConfirmation`: func - функция для подтверждения перехода на другую страницу (по умолчанию используется `window.confirm`)
- `keyLength`: number - длина `location.key` (по умолчанию - 6)
- `children`: node - дочерние элементы

**[⬆ 254](#254)**
	
	
### <a name="static"></a> `<StaticRouter>`

`<Router>`, не изменяющий локацию. Используется в сценариях рендеринга на стороне сервера и для тестирования результатов рендеринга при подключении определенной локации.

Пример node-сервера, отправляющего статус-код 302 для `<Redirect>` и обычный HTML в ответ на другие запросы:

```js
import http from "http"
import React from "react"
import ReactDOMServer from "react-dom/server"
import { StaticRouter } from "react-router"

http
  .createServer((req, res) => {
    // Данный объект контекста содержит результаты рендеринга
    const context = {}

    const html = ReactDOMServer.renderToString(
      <StaticRouter location={req.url} context={context}>
        <App />
      </StaticRouter>
    )

    // context.url будет содержать URL для перенаправления при использовании <Redirect>
    if (context.url) {
      res.writeHead(302, {
        Location: context.url
      })
      res.end()
    } else {
      res.write(html)
      res.end()
    }
  })
  .listen(3000)
```

#### Пропы

- `basename`: string - базовый URL для всех локаций
- `location`: string - URL, принимаемый сервером (`req.url`)
- `location`: object - объект локации вида `{ pathname, search, hash, state }`
- `context`: object - обычный JS-объект. В процессе рендеринга компоненты могут добавлять свойства к этому объекту для хранения информации о рендеринге

```js
const context = {}
<StaticRouter context={context}>
  <App />
</StaticRouter>
```

При совпадении, `<Route>` передает компоненту, подлежащему рендерингу, объект контекста как проп `staticContext`. После рендеринга, эти свойства могут использоваться для настройки ответа сервера:

```js
if (context.status === "404") {
  // ...
}
```

- `children`: node - дочерние элементы


**[⬆ 254](#254)**

	
### Route <a name="route"></a>			

Данный компонент является ключевым в `React Router`. Поэтому важно хорошо знать, как он работает. В основном, он отвечает за рендеринг определенного UI при совпадении значения его пропа `path` с текущим URL.

Рассмотрим следующий код:

```js
import React from "react"
import ReactDOM from "react-dom"
import { BrowserRouter as Router, Route } from "react-router-dom"

ReactDOM.render(
  <Router>
    <div>
      <Route exact path="/">
        <Home />
      </Route>
      <Route path="/news">
        <NewsFeed />
      </Route>
    </div>
  </Router>,
  node
)
```

Если локацией приложения будет `/`, то иерархия UI будет выглядеть так:

```js
<div>
  <Home />
  <!-- react-empty: 2 -->
</div>
```

А для локации `/news` так:

```js
<div>
  <!-- react-empty: 1 -->
  <NewsFeed />
</div>
```

Комментарии "react-empty" - это детали реализации нулевого рендеринга. Технически, маршрут рендерится всегда: при совпадении с текущей локацией рендерится компонент, при несовпадении - `null`. Если один и тот же компонент является потомком нескольких `<Route>`, `React` будет рассматривать его как один и тот же экземпляр и состояние компонента будет автономным, т.е. компонент не будет перерисовываться при изменении локации. Во избежание этого к каждому `<Route>` добавляется проп `key` с уникальным значением.

#### Методы рендеринга маршрута

Рекомендуемым способом рендеринга является использование дочерних элементов как в приведенном выше примере. Тем не менее, существует и другие способы:

- `<Route component>`
- `<Route render>`
- `<Route children>`

Следует придерживаться одного стиля.

#### Пропы маршрута

Все 3 метода рендеринга принимают следующие пропы:

- `match`
- `location`
- `history`

#### component

Компонент, подлежащий рендерингу при совпадении с локацией. Данному компоненту доступны все пропы маршрута:

```js
import React from "react"
import ReactDOM from "react-dom"
import { BrowserRouter as Router, Route } from "react-router-dom"

// Все пропы маршрута (match, location и history) доступны для User
const User = (props) => <h1>Привет, {props.match.params.username}!</h1>

ReactDOM.render(
  <Router>
    <Route path="/user/:username" component={User} />
  </Router>,
  node
)
```

При использовании `component` (вместо `render` или `children`), маршрут использует `React.createElement` для создания нового React-элемента. Это означает, что при передаче встроенной функции в качестве пропа компонента, при каждом рендеринге будет создаваться новый компонент. Это приводит к размонтированию/монтированию нового компонента вместо обновления существующего. Поэтому при необходимости передачи встроенной функции следует использовать `render` или `children`.

#### render: func

Это позволяет реализовать встроенный рендеринг без нежелательного перемонтирования.

Вместо создания нового элемента с помощью пропа `component`, можно передать функцию, вызываемую при совпадении с локацией. Данная функция имеет доступ ко всем пропам маршрута:

```js
import React from "react"
import ReactDOM from "react-dom"
import { BrowserRouter as Router, Route } from "react-router-dom"

// встроенный рендеринг
ReactDOM.render(
  <Router>
    <Route path="/home" render={() => <div>Главная</div>} />
  </Router>,
  node
)

// композиция
// Вы можете распаковать routeProps, чтобы сделать их доступными для Component
const FadingRoute = ({ component: Component, ...rest }) => (
  <Route
    {...rest}
    render={routeProps => (
      <FadeIn>
        <Component {...routeProps} />
      </FadeIn>
    )}
  />
)

ReactDOM.render(
  <Router>
    <FadingRoute path="/cool" component={Something} />
  </Router>,
  node
)
```

#### children: func

Порой нам требуется условный рендеринг. В этом случае можно использовать функцию в качестве значения пропа `children`. Она работает как `render`, за исключением того, что вызывается в зависимости от совпадения с локацией.

Данный проп принимает те же пропы маршрута. При несовпадении маршрута, проп `match` будет иметь значение `null`. Это позволяет динамически обновлять UI. В приведенном ниже примере мы динамически добавляем класс `active`:

```js
import React from "react"
import ReactDOM from "react-dom"
import {
  BrowserRouter as Router,
  Link,
  Route
} from "react-router-dom"

const ListItemLink = ({ to, ...rest }) => (
  <Route
    path={to}
    children={({ match }) => (
      <li className={match ? "active" : ""}>
        <Link to={to} {...rest} />
      </li>
    )}
  />
)

ReactDOM.render(
  <Router>
    <ul>
      <ListItemLink to="/somewhere" />
      <ListItemLink to="/somewhere-else" />
    </ul>
  </Router>,
  node
)
```

Это также может использоваться для анимации:

```js
<Route
  children={({ match, ...rest }) => (
    {/* Animate будет рендерится всегда, поэтому можно использовать жизненный цикл
        для анимации монтирования/размонтирования его потомков */}
    <Animate>
      {match && <Something {...rest}/>}
    </Animate>
  )}
/>
```

#### Пропы

- `path`: string, string[] - любой валидный URL или массив таких URL (маршрут без `path` совпадает с любой локацией)

```js
<Route path="/users/:id">
  <User />
</Route>
<Route path={["/users/:id", "/profile/:id"]}>
  <User />
</Route>
```

- `exact`: bool - если `true`, осуществляется поиск точного совпадения с `location.pathname`

```js
<Route exact path="/one">
  <About />
</Route>
```

- `strict`: bool - если `true`, при поиске совпадения учитывается замыкающий слэш
- `location`: object - используется для поиска совпадения с указанной локацией вместо текущей
- `sensitive`: bool - если `true`, при поиске совпадения учитывается регистр

**[⬆ 254](#254)**	
	
	
### Switch <a name="switch"></a>		

Рендерит первый дочерний `<Route>` или `<Redirect>` при совпадении с текущей локацией (URL).

**В чем состоит особенность `<Switch>`?**

Особенность `<Switch>` состоит в том, что он рендерит только один маршрут из набора. Без `<Switch>` рендерится каждый маршрут, совпавший с локацией.

```js
import { Route } from "react-router"

const routes = (
  <div>
    <Route path="/about">
      <About />
    </Route>
    <Route path="/:user">
      <User />
    </Route>
    <Route>
      <NoMatch />
    </Route>
  </div>
)
```

В приведенном примере при значении URL, равном `/about`, все 3 компонента будут совпадать с локацией и отрендерятся. Это позволяет выстраивать композицию компонентов ("сайдбары" - sidebars, "хлебные крошки" - breadcrumbs, "табы" - tabs и т.д.).

Тем не менее, обычно, мы хотим рендерить только один `<Route>`. Если мы находимся в `/about`, то едва ли мы хотим рендерить компонент `<User />` или страницу ошибки 404. Вот как добиться этого с помощью `<Switch>`:

```js
import { Route, Switch } from "react-router"

const routes = (
  <Switch>
    <Route exact path="/">
      <Home />
    </Route>
    <Route path="/about">
      <About />
    </Route>
    <Route path="/:user">
      <User />
    </Route>
    <Route>
      <NoMatch />
    </Route>
  </Switch>
)
```

Это также может быть полезным для выполнения анимированных переходов, поскольку новый маршрут рендерится на той же позиции, что и предыдущий.

#### Пропы

- `location`: object - используется для поиска совпадения вместо текущего объекта локации (текущего браузерного URL)
- `children`: node - потомки `<Switch>` должны быть элементами `<Route>` или `<Redirect>`. `<Route>` совпадает по пропу `path`, `<Redirect>` - по пропу `from`. Указанные элементы без соответствующих пропов всегда совпадают. При включении `<Redirect>` в `<Switch>`, в последнем могут использоваться все пропы `<Route>` (`path`, `exact` и `strict`). Проп `from` - это синоним пропа `path`. Если в `<Switch>` передан проп `location`, значение `location` совпавшего потомка будет перезаписано.

```js
import { Redirect, Route, Switch } from "react-router"

let routes = (
  <Switch>
    <Route exact path="/">
      <Home />
    </Route>

    <Route path="/users">
      <Users />
    </Route>
    <Redirect from="/accounts" to="/users" />

    <Route>
      <NoMatch />
    </Route>
  </Switch>
)
```
	
**[⬆ 254](#254)**

	
### Link <a name="link"></a>	

- [&lt;NavLink>](#nav)

Обеспечивает декларативный и доступный способ навигации в приложении.

```js
<Link to="/about">Контакты</Link>
```

#### Пропы

- `to`: string - строковое представление локации, создаваемое посредством объединения свойств "pathname", "search" и "hash"

```js
<Link to="/courses?sort=name" />
```
- `to`: object - объект, который может иметь следующие свойства:
  - `pathname`: string - название пути
  - `search`: string - параметры строки запроса
  - `hash`: string - хэш-часть URL
  - `state`: object - состояние локации

```js
<Link
  to={{
    pathname: "/courses",
    search: "?sort=name",
    hash: "#the-hash",
    state: { fromDashboard: true }
  }}
/>
```

- `to`: func - функция, которой в качестве аргумента передается текущая локация и которая должна вернуть представление локации в виде строки или объекта

```js
<Link to={location => ({ ...location, pathname: "/courses" })} />
<Link to={location => `${location.pathname}?sort=name`} />
```

- `replace`: bool - если `true`, тогда новая локация заменяет текущую в стеке истории, а не добавляется к ней

```js
<Link to="/courses" replace />
```

- `component`: React.Component - для реализации собственного компонента навигации достаточно передать данный проп

```js
const FancyLink = React.forwardRef((props, ref) => (
  <a ref={ref} {...props}>💅 {props.children}</a>
))

<Link to="/" component={FancyLink} />
```

- другие - `title`, `id`, `className` и т.д.

**[⬆ 254](#254)**	
	
	
### NavLink <a name="nav"></a>		

Специальная версия `<Link>`, предназначенная для добавления стилей к элементу, совпадающему с текущим URL (активному элементу).

```js
<NavLink to="/about">About</NavLink>
```

#### Пропы

- `activeClassName`: string - класс активного элемента. Значением по умолчанию является `active`. Объединяется с пропом `className`

```js
<NavLink to="/faq" activeClassName="selected">
  Часто задаваемые вопросы
</NavLink>
```

- `activeStyle`: object - стили, применяемые к активному элементу

```js
<NavLink
  to="/faq"
  activeStyle={{
    fontWeight: "bold",
    color: "red"
  }}
>
  Часто задаваемые вопросы
</NavLink>
```

- `exact`: bool - если `true`, тогда активный класс/стили применяются только при точном совпадении
- `strict`: bool - если `true`, тогда при определении совпадения учитывается замыкающий (последний) слэш
- `isActive`: func - дополнительная логика для определения активности ссылки

```js
<NavLink
  to="/events/123"
  isActive={(match, location) => {
    if (!match) {
      return false
    }

    // событие считается активным только при условии, что его идентификатор является нечетным числом
    const eventID = parseInt(match.params.eventID)
    return !isNaN(eventID) && eventID % 2 === 1
  }}
>
  Событие 123
</NavLink>
```

- `location`: object - используется для сравнения с другой локацией
- `aria-current`: string - значение атрибута `aria-current` активной ссылки. Возможные значения: `page` (значение по умолчанию), `step`, `location`, `date`, `time`, `true`, `false`.

**[⬆ 254](#254)**	
	

### Redirect <a name="redirect"></a>	

Рендеринг `<Redirect>` приводит к перемещению в новую локацию. Новая локация перезаписывает текущую в стеке истории, как при серверном перенаправлении (HTTP 3xx).

```js
<Route exact path="/">
  {loggedIn ? <Redirect to="/dashboard" /> : <PublicHomePage />}
</Route>
```

#### Пропы

- `to`: string - любой валидный URL
- `to`: object - объект локации для перенаправления

```js
<Redirect
  to={{
    pathname: "/login",
    search: "?utm=your+face",
    state: { referrer: currentLocation }
  }}
/>
```

В компоненте `Login` объект `state` доступен через `props.location.state`, а ключ `referrer` - через `props.state.referrer`.

- `push`: bool - если `true`, новая локация добавляется в стек истории, а не заменяет текущую
- `from`: string - любой валидный URL. Может использоваться только при включении в `<Switch>`

```js
<Switch>
  <Redirect from="/old-path" to="/new-path" />
  <Route path="/new-path">
    <Place />
  </Route>
</Switch>

// Перенаправление с совпавшими параметрами
<Switch>
  <Redirect from="/users/:id" to="/users/profile/:id" />
  <Route path="/users/profile/:id">
    <Profile />
  </Route>
</Switch>
```

- `exact`: bool - точное совпадение, аналог `Route.exact`. Может использоваться только совместно с `from`
- `strict`: bool - учет замыкающего слэша, аналог `Route.strict`. Может использоваться только совместно с `from`
- `sensitive`: bool - учет регистра, аналог `Route.sensitive`

**[⬆ 254](#254)**
    
  **[⬆ Наверх](#top)**
  
255. ### <a name="255"></a> react-router v6

```jsx harmony
import * as React from "react";
import { Routes, Route, Outlet, Link } from "react-router-dom";

export default function App() {
  return (
    <div>
      <h1>Basic Example</h1>

      <p>
        This example demonstrates some of the core features of React Router
        including nested <code>&lt;Route&gt;</code>s,{" "}
        <code>&lt;Outlet&gt;</code>s, <code>&lt;Link&gt;</code>s, and using a
        "*" route (aka "splat route") to render a "not found" page when someone
        visits an unrecognized URL.
      </p>

      {/* Routes nest inside one another. Nested route paths build upon
            parent route paths, and nested route elements render inside
            parent route elements. See the note about <Outlet> below. */}
      <Routes>
        <Route path="/" element={<Layout />}>
          <Route index element={<Home />} />
          <Route path="about" element={<About />} />
          <Route path="dashboard" element={<Dashboard />} />

          {/* Using path="*"" means "match anything", so this route
                acts like a catch-all for URLs that we don't have explicit
                routes for. */}
          <Route path="*" element={<NoMatch />} />
        </Route>
      </Routes>
    </div>
  );
}

function Layout() {
  return (
    <div>
      {/* A "layout route" is a good place to put markup you want to
          share across all the pages on your site, like navigation. */}
      <nav>
        <ul>
          <li>
            <Link to="/">Home</Link>
          </li>
          <li>
            <Link to="/about">About</Link>
          </li>
          <li>
            <Link to="/dashboard">Dashboard</Link>
          </li>
          <li>
            <Link to="/nothing-here">Nothing Here</Link>
          </li>
        </ul>
      </nav>

      <hr />

      {/* An <Outlet> renders whatever child route is currently active,
          so you can think about this <Outlet> as a placeholder for
          the child routes we defined above. */}
      <Outlet />
    </div>
  );
}

function Home() {
  return (
    <div>
      <h2>Home</h2>
    </div>
  );
}

function About() {
  return (
    <div>
      <h2>About</h2>
    </div>
  );
}

function Dashboard() {
  return (
    <div>
      <h2>Dashboard</h2>
    </div>
  );
}

function NoMatch() {
  return (
    <div>
      <h2>Nothing to see here!</h2>
      <p>
        <Link to="/">Go to the home page</Link>
      </p>
    </div>
  );
}  
```  
  
https://github.com/remix-run/react-router/blob/main/docs/upgrading/v5.md#upgrade-to-react-router-v6      
      
  **[⬆ Наверх](#top)**
  
256. ### <a name="256"></a> 

 
    
  **[⬆ Наверх](#top)**
  
257. ### <a name="257"></a> React / redux Dev Tools

React Developer Tools позволяют инспектировать иерархию компонентов, включая их состояние и пропы. Они существуют как в виде расширения для браузера (Chrome и Firefox), так и в виде самостоятельного приложения (работают с другими окружениями, такими как Safari, IE и React Native).

Вот некоторые из основных возможностей Redux DevTools:
	
1. Позволяют инспектировать каждое состояние и полезную нагрузку операции
2. Позволяют возвращаться назад, "отменяя" выполнение операций
3. При изменении кода редуктора осуществляется повторное вычисление каждой "зафиксированной" операции
4. Если редуктор выбросил исключение, вы сможете увидеть, в процессе выполнения какой операции это произошло, и в чем заключается ошибка
5. С помощью метода `persistState()` можно сохранить сессию отладки между перезагрузками страницы
    
  **[⬆ Наверх](#top)**
  
258. ### <a name="258"></a> HOC - Компонент высшего порядка

`Компонент высшего порядка` (Higher-Order Component, HOC) — это один из продвинутых способов для повторного использования логики. HOC не являются частью API React, но часто применяются из-за композиционной природы компонентов.

## Как создать компонент высшего порядка?

![Higher Order Components](./assets/img2/Higher-Order-Components.jpg)

Компонент высшего порядка (Higher Order Component, HOC) - это функция, принимающая компонент и возвращающая новый компонент. Это продвинутая техника, позволяющая повторно использовать логику компонента. `HOC` не являются частью `React API`. `HOC` является паттерном, производным от композиционной природы `React`. Компонент преобразует пропы в `UI`, а `HOC` трансформирует один компонент в другой. Примерами популярных `HOC` являются методы `connect` в `Redux` и `createContainer` в `Relay`.

```jsx
// HOC.js
import React, { Component } from 'react'

export default function Hoc(WrappedComponent) {
  return class extends Component {
    render() {
      return (
        <div>
          <WrappedComponent></WrappedComponent>
        </div>
      )
    }
  }
}
```

```jsx
// App.js
import React, { Component } from 'react'
import Hoc from './HOC'

class App extends Component {
  render() {
    return (
      <div>
        Компонента высшего порядка
      </div>
    )
  }
}

App = Hoc(App)

export default App
```

_Обратите внимание:_

- Мы не модифицируем компоненты, а создаем новые.
- `HOC` используются для композиции компонентов в целях обеспечения возможности повторного использования кода.
- `HOC` являются "чистыми" (pure) функциями. Они не имеют побочных эффектов (side effects) и всегда возвращают одинаковые результаты для одних и тех же аргументов.	    

	    
`Компонент высшего порядка` — это функция, которая принимает компонент и возвращает новый компонент.	    
	    
```jsx harmony
import {useState, useEffect} from 'react';
import {Container} from 'react-bootstrap';
import './App.css';

const withSlider = (BaseComponent, getData) => {
    return (props) => {
        const [slide, setSlide] = useState(0);
        const [autoplay, setAutoplay] = useState(false)

        useEffect(() => {
            setSlide(getData);
        }, [])

        function changeSlide(i) {
            setSlide(slide => slide + i);
        }

        return <BaseComponent
                            {...props}
                            slide={slide}
                            autoplay={autoplay}
                            changeSlide={changeSlide}
                            setAutoplay={setAutoplay} />
    }
}

const getDataFromFirstFetch = () => {return 10};
const getDataFromSecondFetch = () => {return 20};

const SliderFirst = (props) => {

    return (
        <Container>
            <div className="slider w-50 m-auto">
                <img className="d-block w-100" src="https://www.planetware.com/wpimages/2020/02/france-in-pictures-beautiful-places-to-photograph-eiffel-tower.jpg" alt="slide" />
                <div className="text-center mt-5">Active slide {props.slide}</div>
                <div className="buttons mt-3">
                    <button 
                        className="btn btn-primary me-2"
                        onClick={() => props.changeSlide(-1)}>-1</button>
                    <button 
                        className="btn btn-primary me-2"
                        onClick={() => props.changeSlide(1)}>+1</button>
                </div>
            </div>
        </Container>
    )
}

const SliderSecond = (props) => {

    return (
        <Container>
            <div className="slider w-50 m-auto">
                <img className="d-block w-100" src="https://www.planetware.com/wpimages/2020/02/france-in-pictures-beautiful-places-to-photograph-eiffel-tower.jpg" alt="slide" />
                <div className="text-center mt-5">Active slide {props.slide} <br/>{props.autoplay ? 'auto' : null} </div>
                <div className="buttons mt-3">
                    <button 
                        className="btn btn-primary me-2"
                        onClick={() => props.changeSlide(-1)}>-1</button>
                    <button 
                        className="btn btn-primary me-2"
                        onClick={() => props.changeSlide(1)}>+1</button>
                    <button 
                        className="btn btn-primary me-2"
                        onClick={() => props.setAutoplay(autoplay => !props.autoplay)}>toggle autoplay</button>
                </div>
            </div>
        </Container>
    )
}

const SliderWithFirstFetch = withSlider(SliderFirst, getDataFromFirstFetch());
const SliderWithSecondFetch = withSlider(SliderSecond, getDataFromSecondFetch());

const withLogger = WrappedComponent => props => {
    useEffect(() => {
        console.log('first render!')
    }, [])

    return <WrappedComponent {...props} />
}

const Hello = () => {
    return (
      <h1>Hello!</h1>
    )
}

const HelloWithLogger = withLogger(Hello);

function App() {
    return (
        <>
            <HelloWithLogger />
            <SliderWithFirstFetch />
            <SliderWithSecondFetch />
        </>
    );
}

export default App;	    
```	    
 
### Пример с  документации
	    
```jsx harmony
class CommentList extends React.Component {
  constructor(props) {
    super(props);
    this.handleChange = this.handleChange.bind(this);
    this.state = {
      // "DataSource" -- произвольный глобальный источник данных
      comments: DataSource.getComments()
    };
  }

  componentDidMount() {
    // Подписаться на оповещения
    DataSource.addChangeListener(this.handleChange);
  }

  componentWillUnmount() {
    // Отписаться от оповещений
    DataSource.removeChangeListener(this.handleChange);
  }

  handleChange() {
    // Сохранить комментарии из внешнего источника в локальном состоянии
    this.setState({
      comments: DataSource.getComments()
    });
  }

  render() {
    return (
      <div>
        {this.state.comments.map((comment) => (
          <Comment comment={comment} key={comment.id} />
        ))}
      </div>
    );
  }
}
```	
	
Теперь мы решили реализовать новый компонент, который отслеживает изменения конкретной публикации и повторяет уже знакомый нам шаблон:
	
```jsx harmony
class BlogPost extends React.Component {
  constructor(props) {
    super(props);
    this.handleChange = this.handleChange.bind(this);
    this.state = {
      blogPost: DataSource.getBlogPost(props.id)
    };
  }

  componentDidMount() {
    DataSource.addChangeListener(this.handleChange);
  }

  componentWillUnmount() {
    DataSource.removeChangeListener(this.handleChange);
  }

  handleChange() {
    this.setState({
      blogPost: DataSource.getBlogPost(this.props.id)
    });
  }

  render() {
    return <TextBlock text={this.state.blogPost} />;
  }
}
```	
	
Разница между CommentList и BlogPost в том, что они вызывают разные методы DataSource и рендерят разный вывод. Однако в большинстве своём они похожи:

- Оба компонента подписываются на оповещения от DataSource при монтировании.
- Оба меняют внутреннее состояние при изменении DataSource.
- Оба отписываются от DataSource при размонтировании.
	
Можете представить, что в больших приложениях связка «подписаться на DataSource, затем вызвать setState» повторяется очень часто. Было бы здорово абстрагировать эту функциональность и использовать её в других компонентах.

Давайте реализуем функцию withSubscription — она будет создавать компоненты и подписывать их на обновления DataSource (наподобие CommentList и BlogPost). Функция будет принимать оборачиваемый компонент и через пропсы передавать ему новые данные:

```jsx harmony	
const CommentListWithSubscription = withSubscription(
  CommentList,
  (DataSource) => DataSource.getComments()
);

const BlogPostWithSubscription = withSubscription(
  BlogPost,
  (DataSource, props) => DataSource.getBlogPost(props.id)
);
```
	
Первый параметр — это оборачиваемый компонент. Второй — функция, которая извлекает нужные нам данные, она получает DataSource и текущие пропсы.

Когда CommentListWithSubscription и BlogPostWithSubscription рендерятся, они передают в CommentList и BlogPost обновлённые данные DataSource через проп data:

```jsx harmony	
// Эта функция принимает компонент...
function withSubscription(WrappedComponent, selectData) {
  // ...и возвращает другой компонент...
  return class extends React.Component {
    constructor(props) {
      super(props);
      this.handleChange = this.handleChange.bind(this);
      this.state = {
        data: selectData(DataSource, props)
      };
    }

    componentDidMount() {
      // ...который подписывается на оповещения...
      DataSource.addChangeListener(this.handleChange);
    }

    componentWillUnmount() {
      DataSource.removeChangeListener(this.handleChange);
    }

    handleChange() {
      this.setState({
        data: selectData(DataSource, this.props)
      });
    }

    render() {
      // ... и рендерит оборачиваемый компонент со свежими данными!
      // Обратите внимание, что мы передаём остальные пропсы
      return <WrappedComponent data={this.state.data} {...this.props} />;
    }
  };
}	    
```	    
	    
  **[⬆ Наверх](#top)**
  
259. ### <a name="259"></a> React Transition Group

https://github.com/harryheman/my-js/blob/master/docs/guide/react-transition-group.md	
	
http://reactcommunity.org/react-transition-group/	
	
```jsx harmony
import { useState } from 'react';
import { Container } from 'react-bootstrap';
import { CSSTransition } from 'react-transition-group';
import './App.css';

const Modal = (props) => {
  const duration = 300;

  // const defaultStyle = {
  //     transition: `all ${duration}ms ease-in-out`,
  //     opacity: 0,
  //     visibility: 'hidden'
  // }
  //
  // const transitionStyles = {
  //     entering: { opacity: 1, visibility: 'visible' },
  //     entered:  { opacity: 1, visibility: 'visible' },
  //     exiting:  { opacity: 0, visibility: 'hidden' },
  //     exited:  { opacity: 0, visibility: 'hidden' },
  // };

  return (
    <CSSTransition
      in={props.show}
      timeout={duration}
      onEnter={() => props.setShowTrigger(false)}
      onExited={() => props.setShowTrigger(true)}
      classNames='modal'
      mountOnEnter
      unmountOnExit
    >
      <div className='modal mt-5 d-block'>
        <div className='modal-dialog'>
          <div className='modal-content'>
            <div className='modal-header'>
              <h5 className='modal-title'>Typical modal window</h5>
              <button
                onClick={() => props.onClose(false)}
                type='button'
                className='btn-close'
                aria-label='Close'
              ></button>
            </div>
            <div className='modal-body'>
              <p>Modal body content</p>
            </div>
            <div className='modal-footer'>
              <button
                onClick={() => props.onClose(false)}
                type='button'
                className='btn btn-secondary'
              >
                Close
              </button>
              <button
                onClick={() => props.onClose(false)}
                type='button'
                className='btn btn-primary'
              >
                Save changes
              </button>
            </div>
          </div>
        </div>
      </div>
    </CSSTransition>
  );
};

function App() {
  const [showModal, setShowModal] = useState(false);
  const [showTrigger, setShowTrigger] = useState(true);

  return (
    <Container>
      <Modal
        show={showModal}
        onClose={setShowModal}
        setShowTrigger={setShowTrigger}
      />
      {showTrigger ? (
        <button
          type='button'
          className='btn btn-warning mt-5'
          onClick={() => setShowModal(true)}
        >
          Open Modal
        </button>
      ) : null}
    </Container>
  );
}

export default App;	
```	
    
  **[⬆ Наверх](#top)**
	
260. ### <a name="260"></a> Formik, Yup - работа с формами

### хук useFormik	
```jsx harmony
import {useFormik} from 'formik';
import * as Yup from 'yup';

const Form = () => {

	const formik = useFormik({
		initialValues: {
			name: '',
			email: '',
			amount: 0,
			currency: '',
			text: '',
			terms: false
		},
		validationSchema: Yup.object({
			name: Yup.string()
				.min(2, 'Минимум 2 символа')
				.required('Обязательное поле'),
			email: Yup.string()
				.email('Неправильный email адрес')
				.required('Обязательное поле'),
			amount: Yup.number()
				.min(5, 'Не менее 5')
				.required('Обязательное поле'),
			currency: Yup.string().required('Выберите валюту'),
			text: Yup.string()
				.min(10, 'Не менее 10 символов'),
			terms: Yup.boolean()
				.required('Необходимо согласие!')
				.oneOf([true], 'Необходимо согласие!')
		}),
		onSubmit: values => console.log(JSON.stringify(values, null, 2))
	})

	return (
		<form className="form" onSubmit={formik.handleSubmit}>
			<h2>Отправить пожертвование</h2>
			<label htmlFor="name">Ваше имя</label>
			<input
				id="name"
				name="name"
				type="text"
				value={formik.values.name}
				onChange={formik.handleChange}
				onBlur={formik.handleBlur}
			/>
			{formik.errors.name && formik.touched.name ? <div className='error'>{formik.errors.name}</div> : null}
			<label htmlFor="email">Ваша почта</label>
			<input
				id="email"
				name="email"
				type="email"
				value={formik.values.email}
				onChange={formik.handleChange}
				onBlur={formik.handleBlur}
			/>
			{formik.errors.email && formik.touched.email ? <div className='error'>{formik.errors.email}</div> : null}
			<label htmlFor="amount">Количество</label>
			<input
				id="amount"
				name="amount"
				type="number"
				value={formik.values.amount}
				onChange={formik.handleChange}
				onBlur={formik.handleBlur}
			/>
			{formik.errors.amount && formik.touched.amount ? <div className='error'>{formik.errors.amount}</div> : null}
			<label htmlFor="currency">Валюта</label>
			<select
				id="currency"
				name="currency"
				value={formik.values.currency}
				onChange={formik.handleChange}
				onBlur={formik.handleBlur}>
				<option value="">Выберите валюту</option>
				<option value="USD">USD</option>
				<option value="UAH">UAH</option>
				<option value="RUB">RUB</option>
			</select>
			{formik.errors.currency && formik.touched.currency ? <div className='error'>{formik.errors.currency}</div> : null}
			<label htmlFor="text">Ваше сообщение</label>
			<textarea
				id="text"
				name="text"
				value={formik.values.text}
				onChange={formik.handleChange}
				onBlur={formik.handleBlur}
			/>
			{formik.errors.text && formik.touched.text ? <div className='error'>{formik.errors.text}</div> : null}
			<label className="checkbox">
				<input
					name="terms"
					type="checkbox"
					value={formik.values.terms}
					onChange={formik.handleChange}
					onBlur={formik.handleBlur}
				/>
				Соглашаетесь с политикой конфиденциальности?
			</label>
			{formik.errors.terms && formik.touched.terms ? <div className='error'>{formik.errors.terms}</div> : null}
			<button type="submit">Отправить</button>
		</form>
	)
}

export default Form;	
```	

### Formik, Form, Field, ErrorMessage
```jsx harmony
import { Formik, Form, Field, ErrorMessage } from 'formik';
import * as Yup from 'yup';

const CustomForm = () => {

	return (
		<Formik
			initialValues = {{
				name: '',
				email: '',
				amount: 0,
				currency: '',
				text: '',
				terms: false
			}}
			validationSchema = {Yup.object({
				name: Yup.string()
					.min(2, 'Минимум 2 символа')
					.required('Обязательное поле'),
				email: Yup.string()
					.email('Неправильный email адрес')
					.required('Обязательное поле'),
				amount: Yup.number()
					.min(5, 'Не менее 5')
					.required('Обязательное поле'),
				currency: Yup.string().required('Выберите валюту'),
				text: Yup.string()
					.min(10, 'Не менее 10 символов'),
				terms: Yup.boolean()
					.required('Необходимо согласие!')
					.oneOf([true], 'Необходимо согласие!')
			})}
			onSubmit = {values => console.log(JSON.stringify(values, null, 2))}
		>
			<Form className="form">
				<h2>Отправить пожертвование</h2>
				<label htmlFor="name">Ваше имя</label>
				<Field
					id="name"
					name="name"
					type="text"
				/>
				<ErrorMessage className='error' name='name' component='div' />
				<label htmlFor="email">Ваша почта</label>
				<Field
					id="email"
					name="email"
					type="email"
				/>
				<ErrorMessage className='error' name='email' component='div' />
				<label htmlFor="amount">Количество</label>
				<Field
					id="amount"
					name="amount"
					type="number"
				/>
				<ErrorMessage className='error' name='amount' component='div' />
				<label htmlFor="currency">Валюта</label>
				<Field
					id="currency"
					name="currency"
					as='select'>
					<option value="">Выберите валюту</option>
					<option value="USD">USD</option>
					<option value="UAH">UAH</option>
					<option value="RUB">RUB</option>
				</Field>
				<ErrorMessage className='error' name='currency' component='div' />
				<label htmlFor="text">Ваше сообщение</label>
				<Field
					id="text"
					name="text"
					as='textarea'
				/>
				<ErrorMessage className='error' name='text' component='div' />
				<label className="checkbox">
					<Field
						name="terms"
						type="checkbox"
					/>
					Соглашаетесь с политикой конфиденциальности?
				</label>
				<ErrorMessage className='error' name='terms' component='div' />
				<button type="submit">Отправить</button>
			</Form>
		</Formik>
	)
}

export default CustomForm;	
```	

### useField
```jsx harmony
import { Formik, Form, Field, ErrorMessage, useField } from 'formik';
import * as Yup from 'yup';

const MyTextInput = ({label, ...props}) => {
	const [field, meta] = useField(props);

	return (
		<>
			<label htmlFor={props.name}>{label}</label>
			<input {...props} {...field} />
			{meta.touched && meta.error ? (
				<div className='error'>{meta.error}</div>
			) : null}
		</>
	)
};

const MyCheckbox = ({children, ...props}) => {
	const [field, meta] = useField({...props, type: 'checkbox'});

	return (
		<>
			<label className='checkbox'>
				<input type='checkbox' {...props} {...field} />
				{children}
			</label>

			{meta.touched && meta.error ? (
				<div className='error'>{meta.error}</div>
			) : null}
		</>
	)
};

const CustomForm = () => {

	return (
		<Formik
			initialValues = {{
				name: '',
				email: '',
				amount: 0,
				currency: '',
				text: '',
				terms: false
			}}
			validationSchema = {Yup.object({
		name: Yup.string()
			.min(2, 'Минимум 2 символа')
			.required('Обязательное поле'),
			email: Yup.string()
			.email('Неправильный email адрес')
			.required('Обязательное поле'),
			amount: Yup.number()
			.min(5, 'Не менее 5')
			.required('Обязательное поле'),
			currency: Yup.string().required('Выберите валюту'),
			text: Yup.string()
			.min(10, 'Не менее 10 символов'),
			terms: Yup.boolean()
			.required('Необходимо согласие!')
			.oneOf([true], 'Необходимо согласие!')
	})}
			onSubmit = {values => console.log(JSON.stringify(values, null, 2))}
		>
			<Form className="form">
				<h2>Отправить пожертвование</h2>				
				<MyTextInput
					label='Ваше имя'
					id="name"
					name="name"
					type="text"
				/>
				<MyTextInput
					label='Ваша почта'
					id="email"
					name="email"
					type="email"
				/>
				<label htmlFor="amount">Количество</label>
				<Field
					id="amount"
					name="amount"
					type="number"
				/>
				<ErrorMessage className='error' name='amount' component='div' />
				<label htmlFor="currency">Валюта</label>
				<Field
					id="currency"
					name="currency"
					as='select'>
					<option value="">Выберите валюту</option>
					<option value="USD">USD</option>
					<option value="UAH">UAH</option>
					<option value="RUB">RUB</option>
				</Field>
				<ErrorMessage className='error' name='currency' component='div' />
				<label htmlFor="text">Ваше сообщение</label>
				<Field
					id="text"
					name="text"
					as='textarea'
				/>
				<ErrorMessage className='error' name='text' component='div' />
				<MyCheckbox
					name='terms'>
					Соглашаетесь с политикой конфиденциальности?
				</MyCheckbox>
				<button type="submit">Отправить</button>
			</Form>
		</Formik>
	)
}

export default CustomForm;	
```	

### Валидация без Yup
```jsx harmony
const validate = values => {
	const errors = {};

	if (!values.name) {
		errors.name = 'Обязательное поле!';
	} else if (values.name.length < 2) {
		errors.name = 'Миниммум 2 символа';
	}

	if (values.email) {
		errors.email = 'Обязательное поле!';
	} else if (!/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i.test(values.email)
	) {
		errors.email = 'Неправильный email адрес'
	}

	return errors;
}	
```	
	
  **[⬆ Наверх](#top)**
	
261. ### <a name="261"></a> 

 
    
  **[⬆ Наверх](#top)**	
  
300. ### <a name="300"></a> Хуки в React

 `Хуки` — это функции, с помощью которых вы можете «подцепиться» к состоянию и методам жизненного цикла React из функциональных компонентов. Хуки не работают внутри классов — они дают вам возможность использовать React без классов.
	
```jsx harmony
import React, { useState } from 'react';

function Example() {
  // Объявление переменной состояния, которую мы назовём "count"
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Вы кликнули {count} раз</p>
      <button onClick={() => setCount(count + 1)}>
        Нажми на меня
      </button>
    </div>
  );
}
```	

### Преимущества хуков	
- Хуки дают новый мощный способ повторного использования кода в компонентах.	
- Хуки позволяют нам организовать логику внутри компонента в многоразовые изолированные блоки
- С помощью хуков написание кода намного проще, и я считаю, что чтение функциональных компонентов с помощью хуков требует меньшего переключения контекста, поскольку ты не прыгаешь по файлу, чтобы определить, в каком методе жизненного цикла, по твоему мнению, что-то произошло.
- Хуки позволяют вам повторно использовать логику состояния, не затрагивая дерево компонентов
- Хуки позволяют разбить один компонент на маленькие функции по их назначению (например, подписке или загрузке данных)	
- Хуки позволяют использовать больше возможностей React без написания классов
    
  **[⬆ Наверх](#top)**
	
301. ### <a name="301"></a> Методы жизненного цикла может заменить Хуки

 ### Как методы жизненного цикла соответствуют хукам?	
- constructor: Функциональному компоненту не нужен конструктор. Вы можете инициализировать состояние, используя вызов useState. Если вычисления состояния затратны, вы можете передать функцию в useState.
- getDerivedStateFromProps: Запланировать обновление при рендере.
- shouldComponentUpdate: Смотрите объяснение React.memo ниже.
- render: Это тело функционального компонента.
- componentDidMount, componentDidUpdate, componentWillUnmount: Хук useEffect заменяет все их комбинации (включая более редкие случаи).
- getSnapshotBeforeUpdate, componentDidCatch и getDerivedStateFromError: В данный момент не существует хуков-аналогов для этих методов, но они будут скоро добавлены.
    
  **[⬆ Наверх](#top)**
	
302. ### <a name="302"></a> Хуки

 `Хуки` — это функции, с помощью которых вы можете «подцепиться» к состоянию и методам жизненного цикла React из функциональных компонентов. Хуки не работают внутри классов — они дают вам возможность использовать React без классов.	
	
`Хуки` — нововведение в React 16.8, которое позволяет использовать состояние и другие возможности React без написания классов.	
	
- [useState](#useState)
- [useEffect](#useEffect)	
- [useContext](#useContext)	
- [useReducer](#useReducer)	
- [useCallback](#useCallback)	
- [useMemo](#useMemo)	
- [useRef](#useRef)
- [useImperativeHandle](#useImperativeHandle)
- [useLayoutEffect](#useLayoutEffect)
- [useDebugValue](#useDebugValue)
- [useDeferredValue](#useDeferredValue)
- [useTransition](#useTransition)	
- [useId](#useId)	
	
### useState <a name="useState"></a>
	
```jsx harmony	
const [state, setState] = useState(initialState);
```	
Возвращает значение с состоянием и функцию для его обновления.

Во время первоначального рендеринга возвращаемое состояние (state) совпадает со значением, переданным в качестве первого аргумента (initialState).

Функция setState используется для обновления состояния. Она принимает новое значение состояния и ставит в очередь повторный рендер компонента.
```jsx harmony
setState(newState);
```	
Во время последующих повторных рендеров первое значение, возвращаемое useState, всегда будет самым последним состоянием после применения обновлений.

`Функциональные обновления`
	
Если новое состояние вычисляется с использованием предыдущего состояния, вы можете передать функцию в setState. Функция получит предыдущее значение и вернёт обновлённое значение. Вот пример компонента счётчик, который использует обе формы setState:
```jsx harmony
function Counter({initialCount}) {
  const [count, setCount] = useState(initialCount);
  return (
    <>
      Счёт: {count}
      <button onClick={() => setCount(initialCount)}>Сбросить</button>
      <button onClick={() => setCount(prevCount => prevCount - 1)}>-</button>
      <button onClick={() => setCount(prevCount => prevCount + 1)}>+</button>
    </>
  );
}
```	
Кнопки «+» и «-» используют функциональную форму, потому что обновлённое значение основано на предыдущем значении. Но кнопка «Сбросить» использует обычную форму, потому что она всегда устанавливает счётчик обратно в 0.

	
### Пример
	
```jsx harmony
import React, {useState} from 'react'

function computeInitialCounter() {
  console.log('Some calculations...')
  return Math.trunc(Math.random() * 20)
}

function App() {
  // const [counter, setCounter] = useState(0)
  // const [counter, setCounter] = useState(computeInitialCounter())
  const [counter, setCounter] = useState(() => {
    return computeInitialCounter()
  })

  const [state, setState] = useState({
    title: 'Счетчик',
    date: Date.now()
  })

  function increment() {
    // setCounter(counter + 1)
    // setCounter(counter + 1)
    setCounter((prevCounter) => {
      return prevCounter + 1
    })
    // setCounter(prev => prev + 1)
  }

  function decrement() {
    setCounter(counter - 1)
  }

  function updateTitle() {
    setState(prev => {
      return {
        ...prev,
        title: 'Новое название'
      }
    })
  }

  return (
    <div>
      <h1>Счетчик: {counter}</h1>
      <button onClick={increment} className="btn btn-success">Добавить</button>
      <button onClick={decrement} className="btn btn-danger">Убрать</button>
      <button onClick={updateTitle} className="btn btn-default">Изменить название</button>

      <pre>{JSON.stringify(state, null, 2)}</pre>
    </div>
  )
}

export default App	
```	
	
	
**[⬆ 302](#302)**
	
	
### useEffect <a name="useEffect"></a>	
	
```jsx harmony	
useEffect(didUpdate);
```	
Принимает функцию, которая содержит императивный код, возможно, с эффектами.

Мутации, подписки, таймеры, логирование и другие побочные эффекты не допускаются внутри основного тела функционального компонента (называемого этапом рендеринга React). Это приведёт к запутанным ошибкам и несоответствиям в пользовательском интерфейсе.

Вместо этого используйте useEffect. Функция, переданная в useEffect, будет запущена после того, как рендер будет зафиксирован на экране. Думайте об эффектах как о лазейке из чисто функционального мира React в мир императивов.

По умолчанию эффекты запускаются после каждого завершённого рендеринга, но вы можете решить запускать их только при изменении определённых значений.

`Очистка эффекта`
	
Часто эффекты создают ресурсы, которые необходимо очистить (или сбросить) перед тем, как компонент покидает экран, например подписку или идентификатор таймера. Чтобы сделать это, функция переданная в useEffect, может вернуть функцию очистки. Например, чтобы создать подписку:
```jsx harmony
useEffect(() => {
  const subscription = props.source.subscribe();
  return () => {
    // Очистить подписку
    subscription.unsubscribe();
  };
});
```	
Функция очистки запускается до удаления компонента из пользовательского интерфейса, чтобы предотвратить утечки памяти. Кроме того, если компонент рендерится несколько раз (как обычно происходит), предыдущий эффект очищается перед выполнением следующего эффекта. В нашем примере это означает, что новая подписка создаётся при каждом обновлении. Чтобы избежать воздействия на каждое обновление, обратитесь к следующему разделу.

`Порядок срабатывания эффектов`
	
В отличие от componentDidMount и componentDidUpdate, функция, переданная в useEffect, запускается во время отложенного события после разметки и отрисовки. Это делает хук подходящим для многих распространённых побочных эффектов, таких как настройка подписок и обработчиков событий, потому что большинство типов работы не должны блокировать обновление экрана браузером.

Однако не все эффекты могут быть отложены. Например, изменение DOM, которое видно пользователю, должно запускаться синхронно до следующей отрисовки, чтобы пользователь не замечал визуального несоответствия. (Различие концептуально схоже с пассивным и активным слушателями событий.) Для этих типов эффектов React предоставляет один дополнительный хук, называемый useLayoutEffect. Он имеет ту же сигнатуру, что и useEffect, и отличается только в его запуске.

Хотя useEffect откладывается до тех пор, пока браузер не выполнит отрисовку, он гарантированно срабатывает перед любыми новыми рендерами. React всегда полностью применяет эффекты предыдущего рендера перед началом нового обновления.

`Условное срабатывание эффекта`
	
По умолчанию эффекты запускаются после каждого завершённого рендера. Таким образом, эффект всегда пересоздаётся, если значение какой-то из зависимости изменилось.

Однако в некоторых случаях это может быть излишним, например, в примере подписки из предыдущего раздела. Нам не нужно создавать новую подписку на каждое обновление, а только если изменился проп source.

Чтобы реализовать это, передайте второй аргумент в useEffect, который является массивом значений, от которых зависит эффект. Наш обновлённый пример теперь выглядит так:
```jsx harmony
useEffect(
  () => {
    const subscription = props.source.subscribe();
    return () => {
      subscription.unsubscribe();
    };
  },
  [props.source],
);	
```

```jsx harmony
import React, { useState, useEffect } from 'react';

function FriendStatus(props) {
  const [isOnline, setIsOnline] = useState(null);

  useEffect(() => {
    function handleStatusChange(status) {
      setIsOnline(status.isOnline);
    }
    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    // Указываем, как сбросить этот эффект:
    return function cleanup() {
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
  });

  if (isOnline === null) {
    return 'Загрузка...';
  }
  return isOnline ? 'В сети' : 'Не в сети';
}	
```
	
### Пример
	
```jsx harmony
import React, {useState, useEffect} from 'react'

function App() {
  const [type, setType] = useState('users')
  const [data, setData] = useState([])
  const [pos, setPos] = useState({
    x: 0, y: 0
  })

  // useEffect(() => {
  //   console.log('render')
  // })

  useEffect(() => {
    fetch(`https://jsonplaceholder.typicode.com/${type}`)
      .then(response => response.json())
      .then(json => setData(json))

    return () => {
      console.log('clean type')
    }
  }, [type])

  const mouseMoveHandler = event => {
    setPos({
      x: event.clientX,
      y: event.clientY
    })
  }

  useEffect(() => {
    console.log('ComponentDidMount')

    window.addEventListener('mousemove', mouseMoveHandler)

    return () => {
      window.removeEventListener('mousemove', mouseMoveHandler)
    }
  }, [])

  return (
    <div>
      <h1>Ресурс: {type}</h1>

      <button onClick={() => setType('users')}>Пользователи</button>
      <button onClick={() => setType('todos')}>Todos</button>
      <button onClick={() => setType('posts')}>Посты</button>

      {/*<pre>{JSON.stringify(data, null, 2)}</pre>*/}
      <pre>{JSON.stringify(pos, null, 2)}</pre>
    </div>
  )
}

export default App	
```	
	
	
**[⬆ 302](#302)**
	
	
### useContext <a name="useContext"></a>	
	
```jsx harmony	
const value = useContext(MyContext);
```	
Принимает объект контекста (значение, возвращённое из React.createContext) и возвращает текущее значение контекста для этого контекста. Текущее значение контекста определяется пропом value ближайшего <MyContext.Provider> над вызывающим компонентом в дереве.

Когда ближайший <MyContext.Provider> над компонентом обновляется, этот хук вызовет повторный рендер с последним значением контекста, переданным этому провайдеру MyContext. Даже если родительский компонент использует React.memo или реализует shouldComponentUpdate, то повторный рендер будет выполняться, начиная c компонента, использующего useContext.

Запомните, аргументом для useContext должен быть непосредственно сам объект контекста:

- Правильно: useContext(MyContext)
- Неправильно: useContext(MyContext.Consumer)
- Неправильно: useContext(MyContext.Provider)
	
Компонент, вызывающий useContext, всегда будет перерендериваться при изменении значения контекста. Если повторный рендер компонента затратен, вы можете оптимизировать его с помощью мемоизации.

useContext(MyContext) позволяет только читать контекст и подписываться на его изменения. Вам всё ещё нужен <MyContext.Provider> выше в дереве, чтобы предоставить значение для этого контекста.

`Соединим все вместе с Context.Provider`
```jsx harmony
const themes = {
  light: {
    foreground: "#000000",
    background: "#eeeeee"
  },
  dark: {
    foreground: "#ffffff",
    background: "#222222"
  }
};

const ThemeContext = React.createContext(themes.light);

function App() {
  return (
    <ThemeContext.Provider value={themes.dark}>
      <Toolbar />
    </ThemeContext.Provider>
  );
}

function Toolbar(props) {
  return (
    <div>
      <ThemedButton />
    </div>
  );
}

function ThemedButton() {
  const theme = useContext(ThemeContext);
  return (
    <button style={{ background: theme.background, color: theme.foreground }}>
      Я стилизован темой из контекста!
    </button>
  );
}	
```

**[⬆ 302](#302)**
	
	
### useReducer <a name="useReducer"></a>	
	
```jsx harmony	
const [state, dispatch] = useReducer(reducer, initialArg, init);
```	
Альтернатива для useState. Принимает редюсер типа (state, action) => newState и возвращает текущее состояние в паре с методом dispatch. (Если вы знакомы с Redux, вы уже знаете, как это работает.)

Хук useReducer обычно предпочтительнее useState, когда у вас сложная логика состояния, которая включает в себя несколько значений, или когда следующее состояние зависит от предыдущего. useReducer также позволяет оптимизировать производительность компонентов, которые запускают глубокие обновления, поскольку вы можете передавать dispatch вместо колбэков.

Вот пример счётчика из раздела useState, переписанный для использования редюсера:
```jsx harmony
const initialState = {count: 0};

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return {count: state.count + 1};
    case 'decrement':
      return {count: state.count - 1};
    default:
      throw new Error();
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, initialState);
  return (
    <>
      Count: {state.count}
      <button onClick={() => dispatch({type: 'decrement'})}>-</button>
      <button onClick={() => dispatch({type: 'increment'})}>+</button>
    </>
  );
}
```	

`Указание начального состояния`
	
Существует два разных способа инициализации состояния useReducer. Вы можете выбрать любой из них в зависимости от ситуации. Самый простой способ — передать начальное состояние в качестве второго аргумента:
```jsx harmony
  const [state, dispatch] = useReducer(
    reducer,
    {count: initialCount}
  );
```	

`Ленивая инициализация`
Вы также можете создать начальное состояние лениво. Для этого вы можете передать функцию init в качестве третьего аргумента. Начальное состояние будет установлено равным результату вызова init(initialArg).

Это позволяет извлечь логику для расчёта начального состояния за пределы редюсера. Это также удобно для сброса состояния позже в ответ на действие:
```jsx harmony
function init(initialCount) {
  return {count: initialCount};
}

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return {count: state.count + 1};
    case 'decrement':
      return {count: state.count - 1};
    case 'reset':
      return init(action.payload);
    default:
      throw new Error();
  }
}

function Counter({initialCount}) {
  const [state, dispatch] = useReducer(reducer, initialCount, init);
  return (
    <>
      Count: {state.count}
      <button
        onClick={() => dispatch({type: 'reset', payload: initialCount})}>
        Reset
      </button>
      <button onClick={() => dispatch({type: 'decrement'})}>-</button>
      <button onClick={() => dispatch({type: 'increment'})}>+</button>
    </>
  );
}
```	

**[⬆ 302](#302)**
	
	
### useCallback <a name="useCallback"></a>	
	
```jsx harmony	
const memoizedCallback = useCallback(
  () => {
    doSomething(a, b);
  },
  [a, b],
);
```	
Возвращает мемоизированный колбэк.

Передайте встроенный колбэк и массив зависимостей. Хук useCallback вернёт мемоизированную версию колбэка, который изменяется только, если изменяются значения одной из зависимостей. Это полезно при передаче колбэков оптимизированным дочерним компонентам, которые полагаются на равенство ссылок для предотвращения ненужных рендеров (например, shouldComponentUpdate).

useCallback(fn, deps) — это эквивалент useMemo(() => fn, deps).

### Пример
	
```jsx harmony
import React, {useState, useCallback} from 'react'
import ItemsList from './ItemsList'

function App() {
  const [colored, setColored] = useState(false)
  const [count, setCount] = useState(1)

  const styles = {
    color: colored ? 'darkred' : 'black'
  }

  const generateItemsFromAPI = useCallback((indexNumber) => {
    return new Array(count).fill('').map((_, i) => `Элемент ${i + indexNumber}`)
  }, [count])

  return (
    <>
      <h1 style={styles}>Количество элементов: {count}</h1>
      <button className={'btn btn-success'} onClick={() => setCount(prev => prev + 1)}>Добавить</button>
      <button className={'btn btn-warning'} onClick={() => setColored(prev => !prev)}>Изменить</button>

      <ItemsList getItems={generateItemsFromAPI} />
    </>
  )
}

export default App	
```	
	
	
**[⬆ 302](#302)**
	
	
### useMemo <a name="useMemo"></a>	

```jsx harmony	
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```	
Возвращает мемоизированное значение.

Передайте «создающую» функцию и массив зависимостей. useMemo будет повторно вычислять мемоизированное значение только тогда, когда значение какой-либо из зависимостей изменилось. Эта оптимизация помогает избежать дорогостоящих вычислений при каждом рендере.

Помните, что функция, переданная useMemo, запускается во время рендеринга. Не делайте там ничего, что вы обычно не делаете во время рендеринга. Например, побочные эффекты принадлежат useEffect, а не useMemo.

Если массив не был передан, новое значение будет вычисляться при каждом рендере.

Вы можете использовать useMemo как оптимизацию производительности, а не как семантическую гарантию. В будущем React может решить «забыть» некоторые ранее мемоизированные значения и пересчитать их при следующем рендере, например, чтобы освободить память для компонентов вне области видимости экрана. Напишите свой код, чтобы он по-прежнему работал без useMemo, а затем добавьте его для оптимизации производительности.	

### Пример
	
```jsx harmony
import React, {useState, useMemo, useEffect} from 'react'

function complexCompute(num) {
  console.log('complexCompute')
  let i = 0
  while (i < 1000000000) i++
  return num * 2
}

function App() {
  const [number, setNumber] = useState(42)
  const [colored, setColored] = useState(false)

  const styles = useMemo(() => ({
    color: colored ? 'darkred' : 'black'
  }), [colored])

  const computed = useMemo(() => {
    return complexCompute(number)
  }, [number])

  useEffect(() => {
    console.log('Styles changed')
  }, [styles])

  return (
    <>
      <h1 style={styles}>Вычисляемое свойство: {computed}</h1>
      <button className={'btn btn-success'} onClick={() => setNumber(prev => prev + 1)}>Добавить</button>
      <button className={'btn btn-danger'} onClick={() => setNumber(prev => prev - 1)}>Убрать</button>
      <button className={'btn btn-warning'} onClick={() => setColored(prev => !prev)}>Изменить</button>
    </>
  )
}

export default App	
```		
	
**[⬆ 302](#302)**
	
	
### useRef <a name="useRef"></a>
	
```jsx harmony	
const refContainer = useRef(initialValue);
```	
useRef возвращает изменяемый ref-объект, свойство .current которого инициализируется переданным аргументом (initialValue). Возвращённый объект будет сохраняться в течение всего времени жизни компонента.

Обычный случай использования — это доступ к потомку в императивном стиле:
```jsx harmony
function TextInputWithFocusButton() {
  const inputEl = useRef(null);
  const onButtonClick = () => {
    // `current` указывает на смонтированный элемент `input`
    inputEl.current.focus();
  };
  return (
    <>
      <input ref={inputEl} type="text" />
      <button onClick={onButtonClick}>Установить фокус на поле ввода</button>
    </>
  );
}
```	
По сути, useRef похож на «коробку», которая может содержать изменяемое значение в своём свойстве .current.

Возможно, вы знакомы с рефами в основном как со способом получить доступ к DOM. Если вы передадите React объект рефа с помощью подобного выражения <div ref={myRef}/>, React установит собственное свойство .current на соответствующий DOM-узел при каждом его изменении.

Но хук useRef() полезен не только установкой атрибута с рефом. Он удобен для сохранения любого мутируемого значения, по аналогии с тем, как вы используете поля экземпляра в классах.

Это возможно, поскольку useRef() создаёт обычный JavaScript-объект. Единственная разница между useRef() и просто созданием самого объекта {current: ...} — это то, что хук useRef даст один и тот же объект с рефом при каждом рендере.

Имейте в виду, что useRef не уведомляет вас, когда изменяется его содержимое. Мутирование свойства .current не вызывает повторный рендер. Если вы хотите запустить некоторый код, когда React присоединяет или отсоединяет реф к узлу DOM, вы можете использовать колбэк-реф вместо этого.

	
### Пример
	
```jsx harmony
import React, {useState, useEffect, useRef} from 'react'

function App() {
  // const [renderCount, setRenderCount] = useState(1)
  const [value, setValue] = useState('initial')
  const renderCount = useRef(1)
  const inputRef = useRef(null)
  const prevValue = useRef('')

  useEffect(() => {
    renderCount.current++
  })

  useEffect(() => {
    prevValue.current = value
  }, [value])

  const focus = () => inputRef.current.focus()

  return (
    <div>
      <h1>Количество рендеров: {renderCount.current}</h1>
      <h2>Прошлое состояние: {prevValue.current}</h2>
      <input ref={inputRef} type="text" onChange={e => setValue(e.target.value)} value={value} />
      <button className="btn btn-success" onClick={focus}>Фокус</button>
    </div>
  )
}

export default App	
```	
	
	
**[⬆ 302](#302)**
	

### useImperativeHandle <a name="useImperativeHandle"></a>
	
```jsx harmony	
useImperativeHandle(ref, createHandle, [deps])
```	
useImperativeHandle настраивает значение экземпляра, которое предоставляется родительским компонентам при использовании ref. Как всегда, в большинстве случаев следует избегать императивного кода, использующего ссылки. useImperativeHandle должен использоваться с forwardRef:
```jsx harmony
function FancyInput(props, ref) {
  const inputRef = useRef();
  useImperativeHandle(ref, () => ({
    focus: () => {
      inputRef.current.focus();
    }
  }));
  return <input ref={inputRef} ... />;
}
FancyInput = forwardRef(FancyInput);
```	
В этом примере родительский компонент, который отображает <FancyInput ref={inputRef} />, сможет вызывать inputRef.current.focus().

**[⬆ 302](#302)**
	
	
### useLayoutEffect <a name="useLayoutEffect"></a>
	
Сигнатура идентична useEffect, но этот хук запускается синхронно после всех изменений DOM. Используйте его для чтения макета из DOM и синхронного повторного рендеринга. Обновления, запланированные внутри useLayoutEffect, будут полностью применены синхронно перед тем, как браузер получит шанс осуществить отрисовку.

Предпочитайте стандартный useEffect, когда это возможно, чтобы избежать блокировки визуальных обновлений.	

**[⬆ 302](#302)**
	

### useDebugValue <a name="useDebugValue"></a>	
```jsx harmony	
useDebugValue(value)
```	
useDebugValue может использоваться для отображения метки для пользовательских хуков в React DevTools.

Например, рассмотрим пользовательский хук useFriendStatus, описанный в разделе «Создание собственных хуков»:
```jsx harmony
function useFriendStatus(friendID) {
  const [isOnline, setIsOnline] = useState(null);

  // ...

  // Показывать ярлык в DevTools рядом с этим хуком
  // например, «Статус друга: В сети»
  useDebugValue(isOnline ? 'В сети' : 'Не в сети');

  return isOnline;
}	
```
**[⬆ 302](#302)**
	
	
### useDeferredValue <a name="useDeferredValue"></a>
	
```jsx harmony	
const deferredValue = useDeferredValue(value);
```	
useDeferredValue accepts a value and returns a new copy of the value that will defer to more urgent updates. If the current render is the result of an urgent update, like user input, React will return the previous value and then render the new value after the urgent render has completed.

This hook is similar to user-space hooks which use debouncing or throttling to defer updates. The benefits to using useDeferredValue is that React will work on the update as soon as other work finishes (instead of waiting for an arbitrary amount of time), and like startTransition, deferred values can suspend without triggering an unexpected fallback for existing content.

Memoizing deferred children
useDeferredValue only defers the value that you pass to it. If you want to prevent a child component from re-rendering during an urgent update, you must also memoize that component with React.memo or React.useMemo:

```jsx harmony	
function Typeahead() {
  const query = useSearchQuery('');
  const deferredQuery = useDeferredValue(query);

  // Memoizing tells React to only re-render when deferredQuery changes,
  // not when query changes.
  const suggestions = useMemo(() =>
    <SearchSuggestions query={deferredQuery} />,
    [deferredQuery]
  );

  return (
    <>
      <SearchInput query={query} />
      <Suspense fallback="Loading results...">
        {suggestions}
      </Suspense>
    </>
  );
}
```	
**[⬆ 302](#302)**
	
	
### useTransition <a name="useTransition"></a>
	
```jsx harmony	
const [isPending, startTransition] = useTransition();
```	
Returns a stateful value for the pending state of the transition, and a function to start it.

startTransition lets you mark updates in the provided callback as transitions:

```jsx harmony	
startTransition(() => {
  setCount(count + 1);
})
```
	
isPending indicates when a transition is active to show a pending state:
```jsx harmony	
function App() {
  const [isPending, startTransition] = useTransition();
  const [count, setCount] = useState(0);
  
  function handleClick() {
    startTransition(() => {
      setCount(c => c + 1);
    })
  }

  return (
    <div>
      {isPending && <Spinner />}
      <button onClick={handleClick}>{count}</button>
    </div>
  );
}
```	
**[⬆ 302](#302)**
	
	
### useId
	
```jsx harmony	
const id = useId();
```	
useId is a hook for generating unique IDs that are stable across the server and client, while avoiding hydration mismatches.

useId is not for generating keys in a list. Keys should be generated from your data.

For a basic example, pass the id directly to the elements that need it:
```jsx harmony
function Checkbox() {
  const id = useId();
  return (
    <>
      <label htmlFor={id}>Do you like React?</label>
      <input id={id} type="checkbox" name="react"/>
    </>
  );
};
```	
	
For multiple IDs in the same component, append a suffix using the same id:
```jsx harmony
function NameFields() {
  const id = useId();
  return (
    <div>
      <label htmlFor={id + '-firstName'}>First Name</label>
      <div>
        <input id={id + '-firstName'} type="text" />
      </div>
      <label htmlFor={id + '-lastName'}>Last Name</label>
      <div>
        <input id={id + '-lastName'} type="text" />
      </div>
    </div>
  );
}
```	
	
**[⬆ 302](#302)**
    
  **[⬆ Наверх](#top)**

	
	
303. ### <a name="303"></a> Хуки пример

### useState	
```jsx harmony
import { useState } from 'react';
import {Container} from 'react-bootstrap';
import './App.css';

const Slider = (props) => {

	const [slide, setSlide] = useState(0);
	const [autoplay, setAutoplay] = useState(false);

	function changeSlide(i) {
		setSlide(slide => slide + i)
	}

	const toggleAutoplay = () => {
		setAutoplay(autoplay => !autoplay)
	}

	return (
		<Container>
			<div className="slider w-50 m-auto">
				<div className="text-center mt-5">Active slide {slide}
					<br/>{autoplay ? 'auto' : null}
				</div>
				<div className="buttons mt-3">
					<button
						className="btn btn-primary me-2"
						onClick={() => changeSlide(-1)}>-1
					</button>
					<button
						className="btn btn-primary me-2"
						onClick={() => changeSlide(1)}>+1
					</button>
					<button
						className="btn btn-primary me-2"
						onClick={toggleAutoplay}>toggle autoplay
					</button>
				</div>
			</div>
		</Container>
	)
}

function App() {
	const [slider, setSlider] = useState(true);

	return (
		<>
			<button onClick={() => setSlider(false)}>Click</button>
			{slider ? <Slider/> : null}
		</>
	);
}

export default App;	
```	
	
	
### useEffect	
```jsx harmony
import { useState, useEffect } from 'react';
import {Container} from 'react-bootstrap';
import './App.css';

const Slider = (props) => {

	const [slide, setSlide] = useState(0);
	const [autoplay, setAutoplay] = useState(false);

	function logging() {
		console.log('log!')
	}

	useEffect(() => {
		console.log('effect')
		document.title = `Slide: ${slide}`;

		window.addEventListener('click', logging);
		
		return () => {
			window.removeEventListener('click', logging);
		}

	}, [slide]);

	useEffect(() => {
		console.log('autoplay');
	}, [autoplay])

	function changeSlide(i) {
		setSlide(slide => slide + i)
	}

	const toggleAutoplay = () => {
		setAutoplay(autoplay => !autoplay)
	}

	return (
		<Container>
			<div className="slider w-50 m-auto">

				<Slide getSomeImages={getSomeImages} />

				<div className="text-center mt-5">Active slide {slide}
					<br/>{autoplay ? 'auto' : null}
				</div>
				<div className="buttons mt-3">
					<button
						className="btn btn-primary me-2"
						onClick={() => changeSlide(-1)}>-1
					</button>
					<button
						className="btn btn-primary me-2"
						onClick={() => changeSlide(1)}>+1
					</button>
					<button
						className="btn btn-primary me-2"
						onClick={toggleAutoplay}>toggle autoplay
					</button>
				</div>
			</div>
		</Container>
	)
}

function App() {
	const [slider, setSlider] = useState(true);

	return (
		<>
			<button onClick={() => setSlider(false)}>Click</button>
			{slider ? <Slider/> : null}
		</>
	);
}

export default App;	
```	
 
### useCallback	
```jsx harmony
import { useState, useEffect, useCallback } from 'react';
import {Container} from 'react-bootstrap';
import './App.css';

const Slider = (props) => {

	const [slide, setSlide] = useState(0);
	const [autoplay, setAutoplay] = useState(false);

	const getSomeImages = useCallback(() => {
		console.log('fetching');
		return [
			'https://data.pixiz.com/output/user/frame/preview/400x400/0/8/1/5/3445180_4e787.jpg',
			'http://anekdotov.net/pic/photo/0221155646p.jpg'
		]
	}, [slide]);


	function logging() {
		console.log('log!')
	}

	useEffect(() => {
		console.log('effect')
		document.title = `Slide: ${slide}`;

		window.addEventListener('click', logging);
		
		return () => {
			window.removeEventListener('click', logging);
		}

	}, [slide]);

	useEffect(() => {
		console.log('autoplay');
	}, [autoplay])

	function changeSlide(i) {
		setSlide(slide => slide + i)
	}

	const toggleAutoplay = () => {
		setAutoplay(autoplay => !autoplay)
	}

	return (
		<Container>
			<div className="slider w-50 m-auto">
				
				<Slide getSomeImages={getSomeImages} />
				
				<div className="text-center mt-5">Active slide {slide}
					<br/>{autoplay ? 'auto' : null}
				</div>
				<div className="buttons mt-3">
					<button
						className="btn btn-primary me-2"
						onClick={() => changeSlide(-1)}>-1
					</button>
					<button
						className="btn btn-primary me-2"
						onClick={() => changeSlide(1)}>+1
					</button>
					<button
						className="btn btn-primary me-2"
						onClick={toggleAutoplay}>toggle autoplay
					</button>
				</div>
			</div>
		</Container>
	)
}

const Slide = ({getSomeImages}) => {
	const [images, setImages] = useState([]);

	useEffect(() => {
		setImages(getSomeImages())
	}, [getSomeImages])

	return (
		<>
			{images.map((url, i) => <img key={i} className="d-block w-100"
																	 src={url}
																	 alt="slide"/>)}
		</>
	)
}

function App() {
	const [slider, setSlider] = useState(true);
	
	return (
		<>
			<button onClick={() => setSlider(false)}>Click</button>
			{slider ? <Slider/> : null}
		</>
	);
}

export default App;	
```	

### useMemo	
```jsx harmony
import { useState, useEffect, useCallback, useMemo} from 'react';
import {Container} from 'react-bootstrap';
import './App.css';

const countTotal = (num) => {
	console.log('counting...')
	return num + 10
}

const Slider = (props) => {

	const [slide, setSlide] = useState(0);
	const [autoplay, setAutoplay] = useState(false);

	const getSomeImages = useCallback(() => {
		console.log('fetching');
		return [
			'https://data.pixiz.com/output/user/frame/preview/400x400/0/8/1/5/3445180_4e787.jpg',
			'http://anekdotov.net/pic/photo/0221155646p.jpg'
		]
	}, [slide]);

	
	function logging() {
		console.log('log!')
	}

	useEffect(() => {
		console.log('effect')
		document.title = `Slide: ${slide}`;

		window.addEventListener('click', logging);
		
		return () => {
		 	window.removeEventListener('click', logging);
		}

	}, [slide]);

	useEffect(() => {
		console.log('autoplay');
	}, [autoplay])

	function changeSlide(i) {
		setSlide(slide => slide + i)
	}

	const toggleAutoplay = () => {
		setAutoplay(autoplay => !autoplay)
	}

	const total = useMemo(() => {
		return countTotal(slide)
	}, [slide]);

	const style = useMemo(() => ({
		color: slide > 4 ? 'red' : 'black'
	}), [slide])

	useEffect(() => {
		console.log('styles!')
	}, [style]);

	return (
		<Container>
			<div className="slider w-50 m-auto">

				<Slide getSomeImages={getSomeImages} />

				<div className="text-center mt-5">Active slide {slide}
					<br/>{autoplay ? 'auto' : null}
				</div>
				<div style={style} className="text-center mt-5">Total slides: {total}</div>
				<div className="buttons mt-3">
					<button
						className="btn btn-primary me-2"
						onClick={() => changeSlide(-1)}>-1
					</button>
					<button
						className="btn btn-primary me-2"
						onClick={() => changeSlide(1)}>+1
					</button>
					<button
						className="btn btn-primary me-2"
						onClick={toggleAutoplay}>toggle autoplay
					</button>
				</div>
			</div>
		</Container>
	)
}

const Slide = ({getSomeImages}) => {
	const [images, setImages] = useState([]);

	useEffect(() => {
		setImages(getSomeImages())
	}, [getSomeImages])

	return (
		<>
			{images.map((url, i) => <img key={i} className="d-block w-100"
																	 src={url}
																	 alt="slide"/>)}
		</>
	)
}

function App() {
	const [slider, setSlider] = useState(true);


	return (
		<>
			<button onClick={() => setSlider(false)}>Click</button>
			{slider ? <Slider/> : null}
		</>
	);
}

export default App;	
```
	
### useRef	
```jsx harmony
import {useRef, useState} from 'react';
import {Container} from 'react-bootstrap';
import './App.css';

const Form = () => {
    const [text, setTetx] = useState('');

    const myRef = useRef(1);

    return (
        <Container>
            <form className="w-50 border mt-5 p-3 m-auto">
                <div className="mb-3">
                    <label htmlFor="exampleFormControlInput1" className="form-label">Email address</label>
                    <input onChange={(e) => setTetx(e.target.value)} type="email" className="form-control" id="exampleFormControlInput1" placeholder="name@example.com"/>
                    </div>
                    <div className="mb-3">
                    <label htmlFor="exampleFormControlTextarea1" className="form-label">Example textarea</label>
                    <textarea onClick={() => myRef.current++} className="form-control" id="exampleFormControlTextarea1" rows="3"></textarea>
                </div>
            </form>
        </Container>
    )
}

function App() {
    return (
        <Form/>
    );
}

export default App;	
```		

### useContextt

Content	
```jsx harmony
import {createContext} from 'react';

const dataContext = createContext({
	mail: "name@example.com",
	text: 'some text',
	forceChangeMail: () => {}
});

export default dataContext;	
```	

Input	
```jsx harmony
import {useContext} from 'react';
import dataContext from './ConContext';

const InputComponent = () => {

	const context = useContext(dataContext);

	return (
		<input
			value={context.mail}
			type="email"
			className='form-control'
			placeholder='name@example.com'
			onFocus={context.forceChangeMail}
		/>
	)
}

export default InputComponent;	
```
	
Form
```jsx harmony
import {Container} from 'react-bootstrap';
import InputComponent from './ConInput';

const Form = (props) => {

	console.log('update')

	return (
		<Container>
			<form className="w-50 border mt-5 p-3 m-auto">
				<div className="mb-3">
					<label htmlFor="exampleFormControlInput1" className="form-label mt-3">Email address</label>
					<InputComponent />
				</div>
				<div className="mb-3">
					<label htmlFor="exampleFormControlTextarea1" className="form-label">Example textarea</label>
					<textarea value={props.text} className="form-control" id="exampleFormControlTextarea1" rows="3"></textarea>
				</div>
			</form>
		</Container>
	)
}

export default Form;	
```	

App	
```jsx harmony
import { useState } from 'react';
import './App.css';
import Form from './ConForm';
import dataContext from './ConContext';

const {Provider} = dataContext;


function App() {
    const [data, setData] = useState({
        mail: "name@example.com",
        text: 'some text',
        forceChangeMail: forceChangeMail
    });

    function forceChangeMail() {
      setData({...data, mail: 'test@gmail.com'})
    }

    return (
        <Provider value={data}>
            <Form text={data.text}/>
            <button 
                onClick={() => setData({
                    mail: "second@example.com",
                    text: 'another text',
                    forceChangeMail: forceChangeMail
                })}>
                Click me
            </button>
        </Provider>
    );
}

export default App;	
```
	
### useReducer
```jsx harmony
import {useState, useReducer} from 'react';
import {Container} from 'react-bootstrap';
import './App.css';

function reducer (state, action) {
    switch (action.type) {
        case 'toggle':
          return {autoplay: !state.autoplay}
        case 'slow':
            return {autoplay: 300}
        case 'fast':
            return {autoplay: 700}
        case 'custom':
            return {autoplay: action.payload}
        default:
            throw new Error();
    }
}

function init(initial) {
    return {autoplay: initial}
}

const Slider = ({initial}) => {
    const [slide, setSlide] = useState(0);
    const [autoplay, dispatch] = useReducer(reducer, initial, init);
    // const [autoplay, dispatch] = useReducer(reducer, {autoplay: false});

    function changeSlide(i) {
        setSlide(slide => slide + i);
    }

    return (
        <Container>
            <div className="slider w-50 m-auto">
                <img className="d-block w-100" src="https://www.planetware.com/wpimages/2020/02/france-in-pictures-beautiful-places-to-photograph-eiffel-tower.jpg" alt="slide" />
                <div className="text-center mt-5">Active slide {slide} <br/>{autoplay.autoplay ? 'auto' : null} </div>
                <div className="buttons mt-3">
                    <button 
                        className="btn btn-primary me-2"
                        onClick={() => changeSlide(-1)}>-1</button>
                    <button 
                        className="btn btn-primary me-2"
                        onClick={() => changeSlide(1)}>+1</button>
                    <button 
                        className="btn btn-primary me-2"
                        onClick={() => dispatch({type: 'toggle'})}>toggle autoplay</button>
                    <button
                      className="btn btn-primary me-2"
                      onClick={() => dispatch({type: 'slow'})}>slow autoplay</button>
                    <button
                      className="btn btn-primary me-2"
                      onClick={() => dispatch({type: 'fast'})}>fast autoplay</button>
                    <button
                      className="btn btn-primary me-2"
                      onClick={(e) => dispatch({type: 'custom', payload: +e.target.textContent})}>1000</button>
                </div>
            </div>
        </Container>
    )
}

function App() {
    return (
        <Slider initial={false}/>
    );
}

export default App;	
```	

### useDeferredValue

useDeferredValue оптимизирует работу приложения, если у вас большой список или сложная верстка или когда есть динамический списко данных, подсказок, табов. Стоит применять там где можно выполнить рендер отложенно.	
	
```jsx harmony
import data from './data';
import { useState, useMemo, useDeferredValue } from 'react';

function App() {
  const [text, setText] = useState('');
  const [posts, setPosts] = useState(data);
  const deferedValue = useDeferredValue(text);

  const filteredPosts = useMemo(() => {
    return posts.filter((item) =>
      item.name.toLowerCase().includes(deferedValue)
    );
  }, [deferedValue]);

  const onValueChange = (e) => {
    setText(e.target.value);
  };

  return (
    <>
      <input value={text} type='text' onChange={onValueChange} />

      <hr />

      <div>
        {filteredPosts.map((post) => (
          <div key={post._id}>
            <h4>{post.name}</h4>
          </div>
        ))}
      </div>
    </>
  );
}

export default App;	
```
	
### useTransition
	
useTransition оптимизирует работу приложения, если у вас большой список или сложная верстка или когда есть динамический списко данных, подсказок, табов. Стоит применять там где можно выполнить рендер отложенно.	
	
```jsx harmony
import data from './data';
import { useState, useMemo, useTransition } from 'react';

function App() {
  const [text, setText] = useState('');
  const [posts, setPosts] = useState(data);
  const [isPending, startTransition] = useTransition();

  const filteredPosts = useMemo(() => {
    return posts.filter((item) =>
      item.name.toLowerCase().includes(text)
    );
  }, [text]);

  const onValueChange = (e) => {
    startTransition(() => {
      setText(e.target.value);
    });
  };

  return (
    <>
      <input value={text} type='text' onChange={onValueChange} />

      <hr />

      <div>
        {isPending ? (
          <h3>Loading</h3>
        ) : (
          filteredPosts.map((post) => (
            <div key={post._id}>
              <h4>{post.name}</h4>
            </div>
          ))
        )}
      </div>
    </>
  );
}

export default App;	
```	

### useId
	  
```jsx harmony	  
const id = useId();
```	  
useId is a hook for generating unique IDs that are stable across the server and client, while avoiding hydration mismatches.

useId is not for generating keys in a list. Keys should be generated from your data.

For a basic example, pass the id directly to the elements that need it:
```jsx harmony
function Checkbox() {
  const id = useId();
  return (
    <>
      <label htmlFor={id}>Do you like React?</label>
      <input id={id} type="checkbox" name="react"/>
    </>
  );
};
```	  
	  
For multiple IDs in the same component, append a suffix using the same id:
```jsx harmony
function NameFields() {
  const id = useId();
  return (
    <div>
      <label htmlFor={id + '-firstName'}>First Name</label>
      <div>
        <input id={id + '-firstName'} type="text" />
      </div>
      <label htmlFor={id + '-lastName'}>Last Name</label>
      <div>
        <input id={id + '-lastName'} type="text" />
      </div>
    </div>
  );
}
```	
	  
  **[⬆ Наверх](#top)**
	
304. ### <a name="304"></a> Создание собственных хуков

Создание пользовательских хуков позволяет вам перенести логику компонентов в функции, которые можно повторно использовать.		
	
```jsx harmony
 function useCounter(initial) {
    const [counter, setCounter] = React.useState(initial);
  
    // Это вариант с запросом, чтобы он нормально работал после активации - уберите все props,
    // которые приходят в компонент + аргумент initial поменяйте на 0 или null
  
    // React.useEffect(() => {
    //     fetch('https://www.random.org/integers/?num=1&min=-50&max=50&col=1&base=10&format=plain&rnd=new')
    //         .then(res => res.text())
    //         .then(res => setCounter(res))
    //         .catch(err => console.log(err))
    // }, [])
  
    const incCounter = () => {
      if (counter < 50) {
        setCounter(counter => counter + 1)
      }
    } 

    const decCounter = () => {
      if (counter > -50) {
        setCounter(counter => counter - 1)
      }
    }

    const rndCounter = () => {
      setCounter(+(Math.random() * (50 - -50) + -50).toFixed(0))
    }

    const resetCounter = () => {
      setCounter(initial)
    }
    
    return {
      counter,
      incCounter,
      decCounter,
      rndCounter,
      resetCounter
    }
}

const Counter = (props) => {
    const {counter, incCounter, decCounter, rndCounter, resetCounter} = useCounter(props.counter);

    return (
      <div className="component">
        <div className="counter">{counter}</div>
        <div className="controls">
          <button onClick={incCounter}>INC</button>
          <button onClick={decCounter}>DEC</button>
          <button onClick={rndCounter}>RND</button>
          <button onClick={resetCounter}>RESET</button>
        </div>
      </div>
    )
}

const RndCounter = (props) => {
    const {counter, rndCounter, resetCounter} = useCounter(props.counter);

    return (
      <div className="component">
        <div className="counter">{counter}</div>
        <div className="controls">
          <button onClick={rndCounter}>RND</button>
          <button onClick={resetCounter}>RESET</button>
        </div>
      </div>
    )
}

const App = () => {
    return (
        <>
            <Counter counter={0}/>
            <RndCounter counter={5}/>
        </>
    )
}

ReactDOM.render(<App />, document.getElementById('app')); 
``` 
 
```jsx harmony
import {useState, useEffect} from 'react';
import {Container} from 'react-bootstrap';
import './App.css';

function useInputWithValidate(initialValue) {
	const [value, setValue] = useState(initialValue);

	const onChange = event => {
		setValue(event.target.value);
	}

	const validateInput = () => {
		return value.search(/\d/) >= 0
	}

	return {value, onChange, validateInput}
}

const Form = () => {

	const input = useInputWithValidate('');
	const textArea = useInputWithValidate('');

	const color = input.validateInput() ? 'text-danger' : null;

	return (
		<Container>
			<form className="w-50 border mt-5 p-3 m-auto">
				<div className="mb-3">
					<input value={`${input.value} / ${textArea.value}`} type="text" className="form-control" readOnly/>
					<label htmlFor="exampleFormControlInput1" className="form-label mt-3">Email address</label>
					<input onChange={input.onChange} type="email" value={input.value} className={`form-control ${color}`}
								 id="exampleFormControlInput1" placeholder="name@example.com"/>
				</div>
				<div className="mb-3">
					<label htmlFor="exampleFormControlTextarea1" className="form-label">Example textarea</label>
					<textarea onChange={textArea.onChange} value={textArea.value} className="form-control" id="exampleFormControlTextarea1" rows="3"></textarea>
				</div>
			</form>
		</Container>
	)
}

function App() {
	return (
		<Form/>
	);
}

export default App;	
```	
	
  **[⬆ Наверх](#top)**
	
305. ### <a name="305"></a> Практика создание собственных хуков

### http.hook.js	  
```jsx harmony
import { useState, useCallback } from "react";

export const useHttp = () => {
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState(null);

    const request = useCallback(async (url, method = 'GET', body = null, headers = {'Content-Type': 'application/json'}) => {

        setLoading(true);

        try {
            const response = await fetch(url, {method, body, headers});

            if (!response.ok) {
                throw new Error(`Could not fetch ${url}, status: ${response.status}`);
            }

            const data = await response.json();

            setLoading(false);
            return data;
        } catch(e) {
            setLoading(false);
            setError(e.message);
            throw e;
        }
    }, []);

    const clearError = useCallback(() => setError(null), []);

    return {loading, request, error, clearError}
}	  
```
	  
### MarvelService.js 
```jsx harmony
import {useHttp} from '../hooks/http.hook';

const useMarvelService = () => {
    const {loading, request, error, clearError} = useHttp();

    const _apiBase = 'https://gateway.marvel.com:443/v1/public/';
    // ЗДЕСЬ БУДЕТ ВАШ КЛЮЧ, ЭТОТ КЛЮЧ МОЖЕТ НЕ РАБОТАТЬ
    const _apiKey = 'apikey=c5d6fc8b83116d92ed468ce36bac6c62';
    const _baseOffset = 210;

    const getAllCharacters = async (offset = _baseOffset) => {
        const res = await request(`${_apiBase}characters?limit=9&offset=${offset}&${_apiKey}`);
        return res.data.results.map(_transformCharacter);
    }

    const getCharacter = async (id) => {
        const res = await request(`${_apiBase}characters/${id}?${_apiKey}`);
        return _transformCharacter(res.data.results[0]);
    }

    const getAllComics = async (offset = 0) => {
        const res = await request(`${_apiBase}comics?orderBy=issueNumber&limit=8&offset=${offset}&${_apiKey}`);
        return res.data.results.map(_transformComics);
    }

    const getComics = async (id) => {
        const res = await request(`${_apiBase}comics/${id}?${_apiKey}`);
        return _transformComics(res.data.results[0]);
    }

    const _transformCharacter = (char) => {
        return {
            id: char.id,
            name: char.name,
            description: char.description ? `${char.description.slice(0, 210)}...` : 'There is no description for this character',
            thumbnail: char.thumbnail.path + '.' + char.thumbnail.extension,
            homepage: char.urls[0].url,
            wiki: char.urls[1].url,
            comics: char.comics.items
        }
    }

    const _transformComics = (comics) => {
        return {
            id: comics.id,
            title: comics.title,
            description: comics.description || 'There is no description',
            pageCount: comics.pageCount ? `${comics.pageCount} p.` : 'No information about the number of pages',
            thumbnail: comics.thumbnail.path + '.' + comics.thumbnail.extension,
            language: comics.textObjects.language || 'en-us',
            price: comics.prices.price ? `${comics.prices.price}$` : 'not available'
        }
    }

    return {loading, error, clearError, getAllCharacters, getCharacter, getAllComics, getComics}
}

export default useMarvelService;	  
```
	  
### RandomChar.js
```jsx harmony
import {useState, useEffect} from 'react';
import Spinner from '../spinner/Spinner';
import ErrorMessage from '../errorMessage/ErrorMessage';
import useMarvelService from '../../services/MarvelService';

import './randomChar.scss';
import mjolnir from '../../resources/img/mjolnir.png';

const RandomChar = () => {

    const [char, setChar] = useState(null);
    const {loading, error, getCharacter, clearError} = useMarvelService();

    useEffect(() => {
        updateChar();
        const timerId = setInterval(updateChar, 60000);

        return () => {
            clearInterval(timerId)
        }
    }, [])

    const onCharLoaded = (char) => {
        setChar(char);
    }

    const updateChar = () => {
        clearError();
        const id = Math.floor(Math.random() * (1011400 - 1011000)) + 1011000;
        getCharacter(id)
            .then(onCharLoaded);
    }

    const errorMessage = error ? <ErrorMessage/> : null;
    const spinner = loading ? <Spinner/> : null;
    const content = !(loading || error || !char) ? <View char={char} /> : null;

    return (
        <div className="randomchar">
            {errorMessage}
            {spinner}
            {content}
            <div className="randomchar__static">
                <p className="randomchar__title">
                    Random character for today!<br/>
                    Do you want to get to know him better?
                </p>
                <p className="randomchar__title">
                    Or choose another one
                </p>
                <button onClick={updateChar} className="button button__main">
                    <div className="inner">try it</div>
                </button>
                <img src={mjolnir} alt="mjolnir" className="randomchar__decoration"/>
            </div>
        </div>
    )
}

const View = ({char}) => {
    const {name, description, thumbnail, homepage, wiki} = char;
    let imgStyle = {'objectFit' : 'cover'};
    if (thumbnail === 'http://i.annihil.us/u/prod/marvel/i/mg/b/40/image_not_available.jpg') {
        imgStyle = {'objectFit' : 'contain'};
    }

    return (
        <div className="randomchar__block">
            <img src={thumbnail} alt="Random character" className="randomchar__img" style={imgStyle}/>
            <div className="randomchar__info">
                <p className="randomchar__name">{name}</p>
                <p className="randomchar__descr">
                    {description}
                </p>
                <div className="randomchar__btns">
                    <a href={homepage} className="button button__main">
                        <div className="inner">homepage</div>
                    </a>
                    <a href={wiki} className="button button__secondary">
                        <div className="inner">Wiki</div>
                    </a>
                </div>
            </div>
        </div>
    )
}

export default RandomChar;	  
```
	  
### CharList.js
```jsx harmony
import {useState, useEffect, useRef} from 'react';
import PropTypes from 'prop-types';

import Spinner from '../spinner/Spinner';
import ErrorMessage from '../errorMessage/ErrorMessage';
import useMarvelService from '../../services/MarvelService';
import './charList.scss';

const CharList = (props) => {

    const [charList, setCharList] = useState([]);
    const [newItemLoading, setNewItemLoading] = useState(false);
    const [offset, setOffset] = useState(210);
    const [charEnded, setCharEnded] = useState(false);

    const {loading, error, getAllCharacters} = useMarvelService();

    useEffect(() => {
        onRequest(offset, true);
    }, [])

    const onRequest = (offset, initial) => {
        initial ? setNewItemLoading(false) : setNewItemLoading(true);
        getAllCharacters(offset)
            .then(onCharListLoaded)
    }

    const onCharListLoaded = (newCharList) => {
        let ended = false;
        if (newCharList.length < 9) {
            ended = true;
        }

        setCharList(charList => [...charList, ...newCharList]);
        setNewItemLoading(newItemLoading => false);
        setOffset(offset => offset + 9);
        setCharEnded(charEnded => ended);
    }

    const itemRefs = useRef([]);

    const focusOnItem = (id) => {
        // Я реализовал вариант чуть сложнее, и с классом и с фокусом
        // Но в теории можно оставить только фокус, и его в стилях использовать вместо класса
        // На самом деле, решение с css-классом можно сделать, вынеся персонажа
        // в отдельный компонент. Но кода будет больше, появится новое состояние
        // и не факт, что мы выиграем по оптимизации за счет бОльшего кол-ва элементов

        // По возможности, не злоупотребляйте рефами, только в крайних случаях
        itemRefs.current.forEach(item => item.classList.remove('char__item_selected'));
        itemRefs.current[id].classList.add('char__item_selected');
        itemRefs.current[id].focus();
    }

    // Этот метод создан для оптимизации, 
    // чтобы не помещать такую конструкцию в метод render
    function renderItems(arr) {
        const items =  arr.map((item, i) => {
            let imgStyle = {'objectFit' : 'cover'};
            if (item.thumbnail === 'http://i.annihil.us/u/prod/marvel/i/mg/b/40/image_not_available.jpg') {
                imgStyle = {'objectFit' : 'unset'};
            }
            
            return (
                <li 
                    className="char__item"
                    tabIndex={0}
                    ref={el => itemRefs.current[i] = el}
                    key={item.id}
                    onClick={() => {
                        props.onCharSelected(item.id);
                        focusOnItem(i);
                    }}
                    onKeyPress={(e) => {
                        if (e.key === ' ' || e.key === "Enter") {
                            props.onCharSelected(item.id);
                            focusOnItem(i);
                        }
                    }}>
                        <img src={item.thumbnail} alt={item.name} style={imgStyle}/>
                        <div className="char__name">{item.name}</div>
                </li>
            )
        });
        // А эта конструкция вынесена для центровки спиннера/ошибки
        return (
            <ul className="char__grid">
                {items}
            </ul>
        )
    }
    
    const items = renderItems(charList);

    const errorMessage = error ? <ErrorMessage/> : null;
    const spinner = loading && !newItemLoading ? <Spinner/> : null;

    return (
        <div className="char__list">
            {errorMessage}
            {spinner}
            {items}
            <button 
                className="button button__main button__long"
                disabled={newItemLoading}
                style={{'display': charEnded ? 'none' : 'block'}}
                onClick={() => onRequest(offset)}>
                <div className="inner">load more</div>
            </button>
        </div>
    )
}

CharList.propTypes = {
    onCharSelected: PropTypes.func.isRequired
}

export default CharList;	  
```
	  
### CharInfo.js
```jsx harmony
import { useState, useEffect } from 'react';
import PropTypes from 'prop-types';

import useMarvelService from '../../services/MarvelService';
import Spinner from '../spinner/Spinner';
import ErrorMessage from '../errorMessage/ErrorMessage';
import Skeleton from '../skeleton/Skeleton';

import './charInfo.scss';

const CharInfo = (props) => {

    const [char, setChar] = useState(null);

    const {loading, error, getCharacter, clearError} = useMarvelService();

    useEffect(() => {
        updateChar()
    }, [props.charId])

    const updateChar = () => {
        const {charId} = props;
        if (!charId) {
            return;
        }

        clearError();
        getCharacter(charId)
            .then(onCharLoaded)
    }

    const onCharLoaded = (char) => {
        setChar(char);
    }

    const skeleton = char || loading || error ? null : <Skeleton/>;
    const errorMessage = error ? <ErrorMessage/> : null;
    const spinner = loading ? <Spinner/> : null;
    const content = !(loading || error || !char) ? <View char={char}/> : null;

    return (
        <div className="char__info">
            {skeleton}
            {errorMessage}
            {spinner}
            {content}
        </div>
    )
}

const View = ({char}) => {
    const {name, description, thumbnail, homepage, wiki, comics} = char;

    let imgStyle = {'objectFit' : 'cover'};
    if (thumbnail === 'http://i.annihil.us/u/prod/marvel/i/mg/b/40/image_not_available.jpg') {
        imgStyle = {'objectFit' : 'contain'};
    }

    return (
        <>
            <div className="char__basics">
                <img src={thumbnail} alt={name} style={imgStyle}/>
                <div>
                    <div className="char__info-name">{name}</div>
                    <div className="char__btns">
                        <a href={homepage} className="button button__main">
                            <div className="inner">homepage</div>
                        </a>
                        <a href={wiki} className="button button__secondary">
                            <div className="inner">Wiki</div>
                        </a>
                    </div>
                </div>
            </div>
            <div className="char__descr">
                {description}
            </div>
            <div className="char__comics">Comics:</div>
            <ul className="char__comics-list">
                {comics.length > 0 ? null : 'There is no comics with this character'}
                {
                    comics.map((item, i) => {
                        // eslint-disable-next-line
                        if (i > 9) return;
                        return (
                            <li key={i} className="char__comics-item">
                                {item.name}
                            </li>
                        )
                    })
                }                
            </ul>
        </>
    )
}

CharInfo.propTypes = {
    charId: PropTypes.number
}

export default CharInfo;	  
```
	  
### ComicsList.js
```jsx harmone
import {useState, useEffect} from 'react';
import useMarvelService from '../../services/MarvelService';
import Spinner from '../spinner/Spinner';
import ErrorMessage from '../errorMessage/ErrorMessage';

import './comicsList.scss';

const ComicsList = () => {

    const [comicsList, setComicsList] = useState([]);
    const [newItemLoading, setnewItemLoading] = useState(false);
    const [offset, setOffset] = useState(0);
    const [comicsEnded, setComicsEnded] = useState(false);

    const {loading, error, getAllComics} = useMarvelService();

    useEffect(() => {
        onRequest(offset, true);
    }, [])

    const onRequest = (offset, initial) => {
        initial ? setnewItemLoading(false) : setnewItemLoading(true);
        getAllComics(offset)
            .then(onComicsListLoaded)
    }

    const onComicsListLoaded = (newComicsList) => {
        let ended = false;
        if (newComicsList.length < 8) {
            ended = true;
        }
        setComicsList([...comicsList, ...newComicsList]);
        setnewItemLoading(false);
        setOffset(offset + 8);
        setComicsEnded(ended);
    }

    function renderItems (arr) {
        const items = arr.map((item, i) => {
            return (
                <li className="comics__item" key={i}>
                    <a href="#">
                        <img src={item.thumbnail} alt={item.title} className="comics__item-img"/>
                        <div className="comics__item-name">{item.title}</div>
                        <div className="comics__item-price">{item.price}</div>
                    </a>
                </li>
            )
        })

        return (
            <ul className="comics__grid">
                {items}
            </ul>
        )
    }

    const items = renderItems(comicsList);

    const errorMessage = error ? <ErrorMessage/> : null;
    const spinner = loading && !newItemLoading ? <Spinner/> : null;

    return (
        <div className="comics__list">
            {errorMessage}
            {spinner}
            {items}
            <button 
                disabled={newItemLoading} 
                style={{'display' : comicsEnded ? 'none' : 'block'}}
                className="button button__main button__long"
                onClick={() => onRequest(offset)}>
                <div className="inner">load more</div>
            </button>
        </div>
    )
}

export default ComicsList;	  
```	  	  
	  
  **[⬆ Наверх](#top)**
	
306. ### <a name="306"></a> 

 
    
  **[⬆ Наверх](#top)**
	
307. ### <a name="307"></a> 

 
    
  **[⬆ Наверх](#top)**
	
308. ### <a name="308"></a> 

 
    
  **[⬆ Наверх](#top)**
	
309. ### <a name="309"></a> 

 
    
  **[⬆ Наверх](#top)**
	
310. ### <a name="310"></a> 

 
    
  **[⬆ Наверх](#top)**

325. ### <a name="325"></a> configureStore(), createReducer(), createAction(), createSlice(), createAsyncThunk(), createEntityAdapter()

- [configureStore()](#configureStore)
- [createReducer()](#createReducer)
- [createAction()](#createAction)
- [createSlice()](#createSlice)
- [createAsyncThunk()](#createAsyncThunk)
- [createEntityAdapter()](#createEntityAdapter)	

	
`Redux Toolkit` предоставляет инструменты для настройки хранилища и выполнения наиболее распространенных операций, а также содержит полезные утилиты, позволяющие упростить код.	
	
### configureStore() <a name="configureStore"></a>

`configureStore()` помогает решить названные проблемы следующим образом:
- Принимает объект с "именованными" параметрами, что облегчает изучение кода
- Позволяет передавать массив middlewares и enhancers, автоматически вызывая applyMiddleware() и compose()
- автоматически включает расширение Redux DevTools
	
Кроме того, configureStore() автоматически добавляет следующих посредников:
- redux-thunk - наиболее часто используемый промежуточный слой для работы с синхронной и асинхронной логикой за пределами компонентов
- в режиме разработки, промежуточный слой для обнаружения распространенных ошибок, вроде мутирования состояния или использования несериализуемых значений
	
Простейшим способом создания и настройки хранилища является передача в configureStore() корневого редуктора в качестве аргумента reducer:
	
```jsx harmony
import { configureStore } from '@reduxjs/toolkit'
import rootReducer from './reducers'

const store = configureStore({
  reducer: rootReducer
})

export default store
```	
	
Также допускается передавать объект с частичными редукторами, в этом случае configureStore() автоматически вызывает combineReducers():
	
```jsx harmony
import usersReducer from './usersReducer'
import postsReducer from './postsReducer'

const store = configureStore({
  reducer: {
    users: usersReducer,
    posts: postsReducer
  }
})
```
	
Обратите внимание, что это работает только для одного уровня вложенности. Если требуются вложенные редукторы, придется вызывать combineReducers() самостоятельно.	
	
**[⬆ 325](#325)**

	
### createReducer() <a name="createReducer"></a>

Функция `createReducer()` похожа на функцию создания поисковой таблицы из документации по Redux. В ней используется библиотека immer, что позволяет писать "мутирующий" код, обновляющий состояние иммутабельно. Это защищает от непреднамеренного мутирования состояния в редукторе.	

```jsx harmony
const todosReducer = createReducer([], builder => {
  builder
    .addCase('ADD_TODO', (state, action) => {
      // "мутируем" массив, вызывая push()
      state.push(action.payload)
    })
    .addCase('TOGGLE_TODO', (state, action) => {
      const todo = state[action.payload.index]
      // "мутируем" объект, перезаписывая его поле `completed`
      todo.completed = !todo.completed
    })
    .addCase('REMOVE_TODO', (state,action) => {
      // мы по-прежнему можем использовать иммутабельную логику обновления состояния
      return state.filter((todo,i) => i !== action.payload.index)
    })
})	
```	

Функция createReducer() может быть очень полезной, но следует помнить о том, что:

"Мутирующий" код правильно работает только внутри createReducer()
Immer не позволяет смешивать "мутирование" черновика (draft) состояния и возвращение нового состояния	
	
	
**[⬆ 325](#325)**

	
### createAction() <a name="createAction"></a>
	
Написание создателей операции вручную может быть утомительным. Redux Toolkit предоставляет функцию createAction(), которая генерирует создателя операции с указанным типом операции и преобразует переданные аргументы в поле payload:

```jsx harmony	
const addTodo = createAction('ADD_TODO')
addTodo({ text: 'Buy milk' })
// { type : "ADD_TODO", payload : {text : "Buy milk"}} )
```
	
createAction() также принимает аргумент-колбек prepare, позволяющий кастомизировать результирующее поле payload и добавлять поле meta, при необходимости.
	
```jsx harmony
const actionCreator = createAction('SOME_ACTION_TYPE')

console.log(actionCreator.toString())
// SOME_ACTION_TYPE

console.log(actionCreator.type)
// SOME_ACTION_TYPE

const reducer = createReducer({}, builder => {
  // Здесь будет автоматически вызван `actionCreator.toString()`
  // Кроме того, при использовании TypeScript, будет правильно предложен (предположен) тип операции
  builder.addCase(actionCreator, (state, action) => {})

  // Или вы можете указать поле `type`
  // В этому случае, при использовании TypeScript, тип операции предложен не будет
  builder.addCase(actionCreator.type, (state, action) => {})
})	
```	
	
**[⬆ 325](#325)**
	
	
### createSlice() <a name="createSlice"></a>
	
`createSlice()` автоматически генерирует типы и создателей операции на основе переданного названия редуктора:

```jsx harmony	
const postsSlice = createSlice({
  name: 'posts',
  initialState: [],
  reducers: {
    createPost(state, action) {},
    updatePost(state, action) {},
    deletePost(state, action) {}
  }
})

console.log(postsSlice)
/*
{
  name: 'posts',
  actions : {
      createPost,
      updatePost,
      deletePost,
  },
  reducer
}
*/

const { createPost } = postsSlice.actions

console.log(createPost({ id: 123, title: 'Привет, народ!' }))
// { type : 'posts/createPost', payload : { id : 123, title : 'Привет, народ!' } }
```
	
`createSlice()` анализирует функции, определенные в поле reducers, создает редуктор для каждого случая и генерирует создателя, использующего название редуктора в качестве типа операции. Таким образом, редуктор createPost становится типом операции posts/createPost, а создатель createPost() возвращает операцию с этим типом.

Экспорт и использование частей состояния
	
Обычно, мы определяем часть и экспортируем создателей и редукторы:

```jsx harmony	
const postsSlice = createSlice({
  name: 'posts',
  initialState: [],
  reducers: {
    createPost(state, action) {},
    updatePost(state, action) {},
    deletePost(state, action) {}
  }
})

// Извлекаем объект с создателями и редуктор
const { actions, reducer } = postsSlice
// Извлекаем и экспортируем каждого создателя по названию
export const { createPost, updatePost, deletePost } = actions
// Экпортируем редуктор по умолчанию или по названию
export default reducer
```	
	
**[⬆ 325](#325)**

	
### createAsyncThunk() <a name="createAsyncThunk"></a>
	
`createAsyncThunk()` упрощает процесс выполнения асинхронных запросов - мы передаем ему строку для префикса типа операции и колбек создателя полезной нагрузки (payload), выполняющего реальную асинхронную логику и возвращающего промис с результатом. `createAsyncThunk()` возвращает преобразователя, который заботится об отправке правильных операций на основе возвращенного промиса, и типы операции, которые можно обработать в редукторах:

```jsx harmony	
import { createAsyncThunk, createSlice } from '@redux/toolkit'
import { userAPI } from './userAPI'

// Создаем преобразователя
const fetchUserById = createAsyncThunk(
  'user/fetchByIdStatus',
  async (userId, thunkAPI) => {
    const response = await userAPI.fetchById(userId)
    return response.data
  }
)

// Обрабатываем операции в редукторах
const usersSlice = createSlice({
  name: 'users',
  initialState: {entries: [], loading: 'idle'},
  reducers: {
    // стандартная логика редуктора с авто-генерируемыми типами операции для каждого редуктора
  },
  extraReducers: {
    [fetchUserById.fullfilled]: (state, action) => {
      // Добавляем пользователя в массив состояния
      state.entries.push(action.payload)
    }
  }
})

// Позже, отправляем `thunk`
dispatch(fetchUserById(123))
```	
	
**[⬆ 325](#325)**
	
	
### createEntityAdapter() <a name="createEntityAdapter"></a>
	
`createEntityAdapter()` предоставляет стандартизированный способ хранения данных путем преобразования коллекции в форму { ids: [], entities: {} }. Кроме предопределения формы состояния, эта функция генерирует набор редукторов и селекторов, которые знают, как работать с такими данными.
	
```jsx harmony
import {
  createSlice,
  createAsyncThunk,
  createEntityAdapter
} from '@reduxjs/toolkit'
import userAPI from './userAPI'

export const fetchUsers = createAsyncThunk('users/fetchAll', async () => {
  const response = await userAPI.fetchAll()
  // В данном случае `response.data` будет выглядеть так:
  // [{id: 1, first_name: 'Example', last_name: 'User'}]
  return response.data
})

export const updateUser = createAsyncThunk('users/updateOne', async arg => {
  const response = await userAPI.updateUser(arg)
  // В данном случае `response.data` будет выглядеть так:
  // { id: 1, first_name: 'Example', last_name: 'UpdatedLastName'}
  return response.data
})

export const usersAdapter = createEntityAdapter()

// По умолчанию `createEntityAdapter()` возвращает `{ ids: [], entities: {} }`
// Для отслеживания 'loading' или других ключей, их необходимо инициализировать:
// `getInitialState({ loading: false, activeRequestId: null })`
const initialState = usersAdapter.getInitialState()

export const slice = createSlice({
  name: 'users',
  initialState,
  reducers: {
    removeUser: usersAdapter.removeOne
  },
  extraReducers: builder => {
    builder.addCase(fetchUsers.fulfilled, usersAdapter.upsertMany)
    builder.addCase(updateUser.fulfilled, (state, { payload }) => {
      const { id, ...changes } = payload
      usersAdapter.updateOne(state, { id, changes })
    })
  }
})

const reducer = slice.reducer
export default reducer

export const { removeUser } = slice.actions
```	
	
**[⬆ 325](#325)**
    
  **[⬆ Наверх](#top)**
		

326. ### <a name="326"></a> 

 
    
  **[⬆ Наверх](#top)**
	
327. ### <a name="327"></a> 

 
    
  **[⬆ Наверх](#top)**
	
328. ### <a name="328"></a> 

 
    
  **[⬆ Наверх](#top)**
	
329. ### <a name="329"></a> 

 
    
  **[⬆ Наверх](#top)**	
	
330. ### <a name="330"></a> Redux Toolkit: configureStore()

```jsx harmony
import { configureStore } from '@reduxjs/toolkit';
import heroes from '../reducers/heroes';
import filters from '../reducers/filters';

const stringMiddleware = () => (next) => (action) => {
    if (typeof action === 'string') {
        return next({
            type: action
        })
    }
    return next(action)
};

const store = configureStore({
    reducer: {heroes, filters},
    middleware: getDefaultMiddleware => getDefaultMiddleware().concat(stringMiddleware),
    devTools: process.env.NODE_ENV !== 'production',
})

export default store;			
```			
    
  **[⬆ Наверх](#top)**
	  
331. ### <a name="331"></a> Redux Toolkit: createAction()

```jsx harmony
import { createAction } from "@reduxjs/toolkit";

export const fetchHeroes = (request) => (dispatch) => {
    dispatch(heroesFetching());
    request("http://localhost:3001/heroes")
        .then(data => dispatch(heroesFetched(data)))
        .catch(() => dispatch(heroesFetchingError()))
}

export const fetchFilters = (request) => (dispatch) => {
    dispatch(filtersFetching());
    request("http://localhost:3001/filters")
        .then(data => dispatch(filtersFetched(data)))
        .catch(() => dispatch(filtersFetchingError()))
}

// export const heroesFetching = () => {
//     return {
//         type: 'HEROES_FETCHING'
//     }
// }

export const heroesFetching = createAction('HEROES_FETCHING');

// export const heroesFetched = (heroes) => {
//     return {
//         type: 'HEROES_FETCHED',
//         payload: heroes
//     }
// }

export const heroesFetched = createAction('HEROES_FETCHED');

// export const heroesFetchingError = () => {
//     return {
//         type: 'HEROES_FETCHING_ERROR'
//     }
// }

export const heroesFetchingError = createAction('HEROES_FETCHING_ERROR');

export const filtersFetching = () => {
    return {
        type: 'FILTERS_FETCHING'
    }
}

export const filtersFetched = (filters) => {
    return {
        type: 'FILTERS_FETCHED',
        payload: filters
    }
}

export const filtersFetchingError = () => {
    return {
        type: 'FILTERS_FETCHING_ERROR'
    }
}

export const activeFilterChanged = (filter) => {
    return {
        type: 'ACTIVE_FILTER_CHANGED',
        payload: filter
    }
}

// export const heroCreated = (hero) => {
//     return {
//         type: 'HERO_CREATED',
//         payload: hero
//     }
// }

export const heroCreated = createAction('HERO_CREATED');

// export const heroDeleted = (id) => {
//     return {
//         type: 'HERO_DELETED',
//         payload: id
//     }
// }

export const heroDeleted = createAction('HERO_DELETED');			
```			
    
  **[⬆ Наверх](#top)**	  

332. ### <a name="332"></a> Redux Toolkit: createReducer()

```jsx harmony
import { createReducer } from "@reduxjs/toolkit";

import {
    heroesFetching,
    heroesFetched,
    heroesFetchingError,
    heroCreated,
    heroDeleted
} from '../actions';

const initialState = {
    heroes: [],
    heroesLoadingStatus: 'idle'
}

const heroes = createReducer(initialState, {
    [heroesFetching]: state => {state.heroesLoadingStatus = 'loading'},
    [heroesFetched]: (state, action) => {
                    state.heroesLoadingStatus = 'idle';
                    state.heroes = action.payload;
                },
    [heroesFetchingError]: state => {
                    state.heroesLoadingStatus = 'error';
                },
    [heroCreated]: (state, action) => {
                    state.heroes.push(action.payload);
                },
    [heroDeleted]: (state, action) => {
                    state.heroes = state.heroes.filter(item => item.id !== action.payload);
                }
        },
    [],
    state => state
)

// или вот так ->			
			
const heroes = createReducer(initialState, builder => {
     builder
         .addCase(heroesFetching, state => {
             state.heroesLoadingStatus = 'loading';
         })
         .addCase(heroesFetched, (state, action) => {
             state.heroesLoadingStatus = 'idle';
             state.heroes = action.payload;
         })
         .addCase(heroesFetchingError, state => {
             state.heroesLoadingStatus = 'error';
         })
         .addCase(heroCreated, (state, action) => {
             state.heroes.push(action.payload);
         })
         .addCase(heroDeleted, (state, action) => {
             state.heroes = state.heroes.filter(item => item.id !== action.payload);
         })
         .addDefaultCase(() => {});
})

export default heroes;			
```			
    
  **[⬆ Наверх](#top)**
			
333. ### <a name="333"></a> Redux Toolkit: createSlice()

### heroesSlice			
```jsx harmony
import { createSlice } from "@reduxjs/toolkit";

const initialState = {
    heroes: [],
    heroesLoadingStatus: 'idle'
}

const heroesSlice = createSlice({
    name: 'heroes',
    initialState,
    reducers: {
        heroesFetching: state => {state.heroesLoadingStatus = 'loading'},
        heroesFetched: (state, action) => {
            state.heroesLoadingStatus = 'idle';
            state.heroes = action.payload;
        },
        heroesFetchingError: state => {
            state.heroesLoadingStatus = 'error';
        },
        heroCreated: (state, action) => {
            state.heroes.push(action.payload);
        },
        heroDeleted: (state, action) => {
            state.heroes = state.heroes.filter(item => item.id !== action.payload);
        }
    }
});

const {actions, reducer} = heroesSlice;

export default reducer;
export const {
    heroesFetching,
    heroesFetched,
    heroesFetchingError,
    heroCreated,
    heroDeleted
} = actions;			
```			

### filtersSlice
```jsx harmony
import { createSlice } from "@reduxjs/toolkit";

const initialState = {
    filters: [],
    filtersLoadingStatus: 'idle',
    activeFilter: 'all'
}

const filtersSlice = createSlice({
    name: 'filters',
    initialState,
    reducers: {
        filtersFetching: state => {state.filtersLoadingStatus = 'loading'},
        filtersFetched: (state, action) => {
            state.filtersLoadingStatus = 'idle';
            state.filters = action.payload;
        },
        filtersFetchingError: state => {
            state.filtersLoadingStatus = 'error';
        },
        filtersChanged: (state, action) => {
            state.activeFilter = action.payload;
        }
    }
});

const {actions, reducer} = filtersSlice;

export default reducer;
export const {
    filtersFetching,
    filtersFetched,
    filtersFetchingError,
    filtersChanged
} = actions;			
```						
			
  **[⬆ Наверх](#top)**			

334. ### <a name="334"></a> Redux Toolkit: createAsyncThunk()

### heroesSlice.js
```jsx harmony
import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";
import {useHttp} from '../../hooks/http.hook';

const initialState = {
    heroes: [],
    heroesLoadingStatus: 'idle'
}

export const fetchHeroes = createAsyncThunk(
    'heroes/fetchHeroes',
    async () => {
        const {request} = useHttp();
        return await request("http://localhost:3001/heroes");
    }
);

const heroesSlice = createSlice({
    name: 'heroes',
    initialState,
    reducers: {
        heroCreated: (state, action) => {
            state.heroes.push(action.payload);
        },
        heroDeleted: (state, action) => {
            state.heroes = state.heroes.filter(item => item.id !== action.payload);
        }
    },
    extraReducers: (builder) => {
        builder
            .addCase(fetchHeroes.pending, state => {state.heroesLoadingStatus = 'loading'})
            .addCase(fetchHeroes.fulfilled, (state, action) => {
                state.heroesLoadingStatus = 'idle';
                state.heroes = action.payload;
            })
            .addCase(fetchHeroes.rejected, state => {
                state.heroesLoadingStatus = 'error';
            })
            .addDefaultCase(() => {})
    }
});

const {actions, reducer} = heroesSlice;

export default reducer;
export const {
    heroesFetching,
    heroesFetched,
    heroesFetchingError,
    heroCreated,
    heroDeleted
} = actions;			
```			

### filtersSlice.js
```jsx harmony
import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";
import {useHttp} from '../../hooks/http.hook';

const initialState = {
    filters: [],
    filtersLoadingStatus: 'idle',
    activeFilter: 'all'
}

export const fetchFilters = createAsyncThunk(
    'filters/fetchFilters',
    async () => {
        const {request} = useHttp();
        return await request("http://localhost:3001/filters");
    }
);

const filtersSlice = createSlice({
    name: 'filters',
    initialState,
    reducers: {
        filtersChanged: (state, action) => {
            state.activeFilter = action.payload;
        }
    },
    extraReducers: (builder) => {
        builder
            .addCase(fetchFilters.pending, state => {state.filtersLoadingStatus = 'loading'})
            .addCase(fetchFilters.fulfilled, (state, action) => {
                state.filtersLoadingStatus = 'idle';
                state.filters = action.payload;
            })
            .addCase(fetchFilters.rejected, state => {
                state.filtersLoadingStatus = 'error';
            })
            .addDefaultCase(() => {})
    }
});

const {actions, reducer} = filtersSlice;

export default reducer;
export const {
    filtersFetching,
    filtersFetched,
    filtersFetchingError,
    filtersChanged
} = actions;			
```			

### http.hook.js
```jsx harmony
export const useHttp = () => {

    const request = async (url, method = 'GET', body = null, headers = {'Content-Type': 'application/json'}) => {

        try {
            const response = await fetch(url, {method, body, headers});

            if (!response.ok) {
                throw new Error(`Could not fetch ${url}, status: ${response.status}`);
            }

            const data = await response.json();

            return data;
        } catch(e) {
            throw e;
        }
    };

    return {request}
}			
```			

### HeroesList.js
```jsx harmony
import {useHttp} from '../../hooks/http.hook';
import { useEffect, useCallback } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { CSSTransition, TransitionGroup} from 'react-transition-group';
import { createSelector } from '@reduxjs/toolkit';

import { heroDeleted, fetchHeroes } from './heroesSlice';

import HeroesListItem from "../heroesListItem/HeroesListItem";
import Spinner from '../spinner/Spinner';

import './heroesList.scss';

const HeroesList = () => {

    const filteredHeroesSelector = createSelector(
        (state) => state.filters.activeFilter,
        (state) => state.heroes.heroes,
        (filter, heroes) => {
            if (filter === 'all') {
                return heroes;
            } else {
                return heroes.filter(item => item.element === filter);
            }
        }
    );

    const filteredHeroes = useSelector(filteredHeroesSelector);
    const heroesLoadingStatus = useSelector(state => state.heroes.heroesLoadingStatus);
    const dispatch = useDispatch();
    const {request} = useHttp();

    useEffect(() => {
        dispatch(fetchHeroes());
        // eslint-disable-next-line
    }, []);

    const onDelete = useCallback((id) => {
        request(`http://localhost:3001/heroes/${id}`, "DELETE")
            .then(data => console.log(data, 'Deleted'))
            .then(dispatch(heroDeleted(id)))
            .catch(err => console.log(err));
        // eslint-disable-next-line  
    }, [request]);

    if (heroesLoadingStatus === "loading") {
        return <Spinner/>;
    } else if (heroesLoadingStatus === "error") {
        return <h5 className="text-center mt-5">Ошибка загрузки</h5>
    }

    const renderHeroesList = (arr) => {
        if (arr.length === 0) {
            return (
                <CSSTransition
                    timeout={0}
                    classNames="hero">
                    <h5 className="text-center mt-5">Героев пока нет</h5>
                </CSSTransition>
            )
        }

        return arr.map(({id, ...props}) => {
            return (
                <CSSTransition 
                    key={id}
                    timeout={500}
                    classNames="hero">
                    <HeroesListItem  {...props} onDelete={() => onDelete(id)}/>
                </CSSTransition>
            )
        })
    }

    const elements = renderHeroesList(filteredHeroes);
    return (
        <TransitionGroup component="ul">
            {elements}
        </TransitionGroup>
    )
}

export default HeroesList;			
```			

### HeroesFilters.js
```jsx harmony
import {useHttp} from '../../hooks/http.hook';
import { useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import classNames from 'classnames';

import { filtersChanged, fetchFilters } from './filtersSlice';
import Spinner from '../spinner/Spinner';

const HeroesFilters = () => {

    const {filters, filtersLoadingStatus, activeFilter} = useSelector(state => state.filters);
    const dispatch = useDispatch();
    const {request} = useHttp();

    useEffect(() => {
        dispatch(fetchFilters(request));

        // eslint-disable-next-line
    }, []);

    if (filtersLoadingStatus === "loading") {
        return <Spinner/>;
    } else if (filtersLoadingStatus === "error") {
        return <h5 className="text-center mt-5">Ошибка загрузки</h5>
    }

    const renderFilters = (arr) => {
        if (arr.length === 0) {
            return <h5 className="text-center mt-5">Фильтры не найдены</h5>
        }

        return arr.map(({name, className, label}) => {

            const btnClass = classNames('btn', className, {
                'active': name === activeFilter
            });
            
            return <button 
                        key={name} 
                        id={name} 
                        className={btnClass}
                        onClick={() => dispatch(filtersChanged(name))}
                        >{label}</button>
        })
    }

    const elements = renderFilters(filters);

    return (
        <div className="card shadow-lg mt-4">
            <div className="card-body">
                <p className="card-text">Отфильтруйте героев по элементам</p>
                <div className="btn-group">
                    {elements}
                </div>
            </div>
        </div>
    )
}

export default HeroesFilters;
```			
			
  **[⬆ Наверх](#top)**			

335. ### <a name="335"></a> Redux Toolkit: createEntityAdapter()

### heroesSlice.js
```jsx harmony
import { createSlice, createAsyncThunk, createEntityAdapter, createSelector } from "@reduxjs/toolkit";
import {useHttp} from '../../hooks/http.hook';

const heroesAdapter = createEntityAdapter();

const initialState = heroesAdapter.getInitialState({
    heroesLoadingStatus: 'idle'
});

export const fetchHeroes = createAsyncThunk(
    'heroes/fetchHeroes',
    async () => {
        const {request} = useHttp();
        return await request("http://localhost:3001/heroes");
    }
);

const heroesSlice = createSlice({
    name: 'heroes',
    initialState,
    reducers: {
        heroCreated: (state, action) => {
            heroesAdapter.addOne(state, action.payload);
        },
        heroDeleted: (state, action) => {
            heroesAdapter.removeOne(state, action.payload);
        }
    },
    extraReducers: (builder) => {
        builder
            .addCase(fetchHeroes.pending, state => {state.heroesLoadingStatus = 'loading'})
            .addCase(fetchHeroes.fulfilled, (state, action) => {
                state.heroesLoadingStatus = 'idle';
                heroesAdapter.setAll(state, action.payload);
            })
            .addCase(fetchHeroes.rejected, state => {
                state.heroesLoadingStatus = 'error';
            })
            .addDefaultCase(() => {})
    }
});

const {actions, reducer} = heroesSlice;

export default reducer;

const {selectAll} = heroesAdapter.getSelectors(state => state.heroes);

export const filteredHeroesSelector = createSelector(
    (state) => state.filters.activeFilter,
    selectAll,
    (filter, heroes) => {
        if (filter === 'all') {
            return heroes;
        } else {
            return heroes.filter(item => item.element === filter);
        }
    }
);

export const {
    heroesFetching,
    heroesFetched,
    heroesFetchingError,
    heroCreated,
    heroDeleted
} = actions;			
```			

### filtersSlice.js
```jsx harmony
import { createSlice, createAsyncThunk, createEntityAdapter } from "@reduxjs/toolkit";
import {useHttp} from '../../hooks/http.hook';

const filtersAdapter = createEntityAdapter();

const initialState = filtersAdapter.getInitialState({
    filtersLoadingStatus: 'idle',
    activeFilter: 'all'
});

export const fetchFilters = createAsyncThunk(
    'filters/fetchFilters',
    async () => {
        const {request} = useHttp();
        return await request("http://localhost:3001/filters");
    }
);

const filtersSlice = createSlice({
    name: 'filters',
    initialState,
    reducers: {
        filtersChanged: (state, action) => {
            state.activeFilter = action.payload;
        }
    },
    extraReducers: (builder) => {
        builder
            .addCase(fetchFilters.pending, state => {state.filtersLoadingStatus = 'loading'})
            .addCase(fetchFilters.fulfilled, (state, action) => {
                state.filtersLoadingStatus = 'idle';
                filtersAdapter.setAll(state, action.payload);
            })
            .addCase(fetchFilters.rejected, state => {
                state.filtersLoadingStatus = 'error';
            })
            .addDefaultCase(() => {})
    }
});

const {actions, reducer} = filtersSlice;

export default reducer;

export const {selectAll} = filtersAdapter.getSelectors(state => state.filters);

export const {
    filtersFetching,
    filtersFetched,
    filtersFetchingError,
    filtersChanged
} = actions;			
```			
		
### HeroesList.js
```jsx harmony
import {useHttp} from '../../hooks/http.hook';
import { useEffect, useCallback } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { CSSTransition, TransitionGroup} from 'react-transition-group';

import { heroDeleted, fetchHeroes, filteredHeroesSelector } from './heroesSlice';

import HeroesListItem from "../heroesListItem/HeroesListItem";
import Spinner from '../spinner/Spinner';

import './heroesList.scss';

const HeroesList = () => {
    const filteredHeroes = useSelector(filteredHeroesSelector);
    const heroesLoadingStatus = useSelector(state => state.heroes.heroesLoadingStatus);
    const dispatch = useDispatch();
    const {request} = useHttp();

    useEffect(() => {
        dispatch(fetchHeroes());
        // eslint-disable-next-line
    }, []);

    const onDelete = useCallback((id) => {
        request(`http://localhost:3001/heroes/${id}`, "DELETE")
            .then(data => console.log(data, 'Deleted'))
            .then(dispatch(heroDeleted(id)))
            .catch(err => console.log(err));
        // eslint-disable-next-line  
    }, [request]);

    if (heroesLoadingStatus === "loading") {
        return <Spinner/>;
    } else if (heroesLoadingStatus === "error") {
        return <h5 className="text-center mt-5">Ошибка загрузки</h5>
    }

    const renderHeroesList = (arr) => {
        if (arr.length === 0) {
            return (
                <CSSTransition
                    timeout={0}
                    classNames="hero">
                    <h5 className="text-center mt-5">Героев пока нет</h5>
                </CSSTransition>
            )
        }

        return arr.map(({id, ...props}) => {
            return (
                <CSSTransition 
                    key={id}
                    timeout={500}
                    classNames="hero">
                    <HeroesListItem  {...props} onDelete={() => onDelete(id)}/>
                </CSSTransition>
            )
        })
    }

    const elements = renderHeroesList(filteredHeroes);
    return (
        <TransitionGroup component="ul">
            {elements}
        </TransitionGroup>
    )
}

export default HeroesList;			
```			
			
### HeroesFilters.js
```jsx harmony
import {useHttp} from '../../hooks/http.hook';
import { useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import classNames from 'classnames';
import store from '../../store';

import { filtersChanged, fetchFilters, selectAll } from './filtersSlice';
import Spinner from '../spinner/Spinner';

const HeroesFilters = () => {

    const {filtersLoadingStatus, activeFilter} = useSelector(state => state.filters);
    const filters = selectAll(store.getState());
    const dispatch = useDispatch();
    const {request} = useHttp();

    useEffect(() => {
        dispatch(fetchFilters(request));

        // eslint-disable-next-line
    }, []);

    if (filtersLoadingStatus === "loading") {
        return <Spinner/>;
    } else if (filtersLoadingStatus === "error") {
        return <h5 className="text-center mt-5">Ошибка загрузки</h5>
    }

    const renderFilters = (arr) => {
        if (arr.length === 0) {
            return <h5 className="text-center mt-5">Фильтры не найдены</h5>
        }

        return arr.map(({name, className, label}) => {

            const btnClass = classNames('btn', className, {
                'active': name === activeFilter
            });
            
            return <button 
                        key={name} 
                        id={name} 
                        className={btnClass}
                        onClick={() => dispatch(filtersChanged(name))}
                        >{label}</button>
        })
    }

    const elements = renderFilters(filters);

    return (
        <div className="card shadow-lg mt-4">
            <div className="card-body">
                <p className="card-text">Отфильтруйте героев по элементам</p>
                <div className="btn-group">
                    {elements}
                </div>
            </div>
        </div>
    )
}

export default HeroesFilters;			
```						

### HeroesAddForm.js
```jsx harmony
import {useHttp} from '../../hooks/http.hook';
import { useState } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { v4 as uuidv4 } from 'uuid';
import store from '../../store';

import { selectAll } from '../heroesFilters/filtersSlice';
import { heroCreated } from '../heroesList/heroesSlice';

const HeroesAddForm = () => {
    const [heroName, setHeroName] = useState('');
    const [heroDescr, setHeroDescr] = useState('');
    const [heroElement, setHeroElement] = useState('');

    const {filtersLoadingStatus} = useSelector(state => state.filters);
    const filters = selectAll(store.getState());
    const dispatch = useDispatch();
    const {request} = useHttp();

    const onSubmitHandler = (e) => {
        e.preventDefault();
        const newHero = {
            id: uuidv4(),
            name: heroName,
            description: heroDescr,
            element: heroElement
        }

        request("http://localhost:3001/heroes", "POST", JSON.stringify(newHero))
            .then(res => console.log(res, 'Отправка успешна'))
            .then(dispatch(heroCreated(newHero)))
            .catch(err => console.log(err));

        setHeroName('');
        setHeroDescr('');
        setHeroElement('');
    }

    const renderFilters = (filters, status) => {
        if (status === "loading") {
            return <option>Загрузка элементов</option>
        } else if (status === "error") {
            return <option>Ошибка загрузки</option>
        }
        
        if (filters && filters.length > 0 ) {
            return filters.map(({name, label}) => {
                // eslint-disable-next-line
                if (name === 'all')  return;

                return <option key={name} value={name}>{label}</option>
            })
        }
    }

    return (
        <form className="border p-4 shadow-lg rounded" onSubmit={onSubmitHandler}>
            <div className="mb-3">
                <label htmlFor="name" className="form-label fs-4">Имя нового героя</label>
                <input 
                    required
                    type="text" 
                    name="name" 
                    className="form-control" 
                    id="name" 
                    placeholder="Как меня зовут?"
                    value={heroName}
                    onChange={(e) => setHeroName(e.target.value)}/>
            </div>

            <div className="mb-3">
                <label htmlFor="text" className="form-label fs-4">Описание</label>
                <textarea
                    required
                    name="text" 
                    className="form-control" 
                    id="text" 
                    placeholder="Что я умею?"
                    style={{"height": '130px'}}
                    value={heroDescr}
                    onChange={(e) => setHeroDescr(e.target.value)}/>
            </div>

            <div className="mb-3">
                <label htmlFor="element" className="form-label">Выбрать элемент героя</label>
                <select 
                    required
                    className="form-select" 
                    id="element" 
                    name="element"
                    value={heroElement}
                    onChange={(e) => setHeroElement(e.target.value)}>
                    <option value="">Я владею элементом...</option>
                    {renderFilters(filters, filtersLoadingStatus)}
                </select>
            </div>

            <button type="submit" className="btn btn-primary">Создать</button>
        </form>
    )
}

export default HeroesAddForm;			
```						
			
  **[⬆ Наверх](#top)**			

336. ### <a name="336"></a> Redux Toolkit: RTK Query

apiSlice.js		
```jsx harmony
import {createApi, fetchBaseQuery} from '@reduxjs/toolkit/query/react';

export const apiSlice = createApi({
    reducerPath: 'api',
    baseQuery: fetchBaseQuery({baseUrl: 'http://localhost:3001'}),
    tagTypes: ['Heroes'],
    endpoints: builder => ({
        getHeroes: builder.query({
            query: () => '/heroes',
            providesTags: ['Heroes']
        }),
        createHero: builder.mutation({
            query: hero => ({
                url: '/heroes',
                method: 'POST',
                body: hero
            }),
            invalidatesTags: ['Heroes']
        }),
        deleteHero: builder.mutation({
            query: id => ({
                url: `/heroes/${id}`,
                method: 'DELETE'
            }),
            invalidatesTags: ['Heroes']
        })
    })
});

export const {useGetHeroesQuery, useCreateHeroMutation, useDeleteHeroMutation} = apiSlice;		
```		

store/index.js		
```jsx harmony
import { configureStore } from '@reduxjs/toolkit';
import filters from '../components/heroesFilters/filtersSlice';
import { apiSlice } from '../api/apiSlice'; 

const stringMiddleware = () => (next) => (action) => {
    if (typeof action === 'string') {
        return next({
            type: action
        })
    }
    return next(action)
};

const store = configureStore({
    reducer: {  filters, 
                [apiSlice.reducerPath]: apiSlice.reducer},
    middleware: getDefaultMiddleware => getDefaultMiddleware().concat(stringMiddleware, apiSlice.middleware),
    devTools: process.env.NODE_ENV !== 'production'
})

export default store;		
```		

HeroesList.js
```jsx harmony
import { useCallback, useMemo } from 'react';
import { useSelector } from 'react-redux';
import { CSSTransition, TransitionGroup} from 'react-transition-group';

import { useGetHeroesQuery, useDeleteHeroMutation } from '../../api/apiSlice';

import HeroesListItem from "../heroesListItem/HeroesListItem";
import Spinner from '../spinner/Spinner';

import './heroesList.scss';

const HeroesList = () => {
    const {
        data: heroes = [],
        isLoading,
        isError,
    } = useGetHeroesQuery();

    const [deleteHero] = useDeleteHeroMutation();

    const activeFilter = useSelector(state => state.filters.activeFilter);

    const filteredHeroes = useMemo(() => {
        const filteredHeroes = heroes.slice();

        if (activeFilter === 'all') {
            return filteredHeroes;
        } else {
            return filteredHeroes.filter(item => item.element === activeFilter);
        }
    }, [heroes, activeFilter]);

    const onDelete = useCallback((id) => {
        deleteHero(id);
        // eslint-disable-next-line  
    }, []);

    if (isLoading) {
        return <Spinner/>;
    } else if (isError) {
        return <h5 className="text-center mt-5">Ошибка загрузки</h5>
    }

    const renderHeroesList = (arr) => {
        if (arr.length === 0) {
            return (
                <CSSTransition
                    timeout={0}
                    classNames="hero">
                    <h5 className="text-center mt-5">Героев пока нет</h5>
                </CSSTransition>
            )
        }

        return arr.map(({id, ...props}) => {
            return (
                <CSSTransition 
                    key={id}
                    timeout={500}
                    classNames="hero">
                    <HeroesListItem  {...props} onDelete={() => onDelete(id)}/>
                </CSSTransition>
            )
        })
    }

    const elements = renderHeroesList(filteredHeroes);
    return (
        <TransitionGroup component="ul">
            {elements}
        </TransitionGroup>
    )
}

export default HeroesList;		
```		

HeroesAddForm.js
```jsx harmony
import { useState } from 'react';
import { useSelector } from 'react-redux';
import { v4 as uuidv4 } from 'uuid';
import store from '../../store';

import { selectAll } from '../heroesFilters/filtersSlice';
import { useCreateHeroMutation } from '../../api/apiSlice';

const HeroesAddForm = () => {
    const [heroName, setHeroName] = useState('');
    const [heroDescr, setHeroDescr] = useState('');
    const [heroElement, setHeroElement] = useState('');

    const [createHero] = useCreateHeroMutation();

    const {filtersLoadingStatus} = useSelector(state => state.filters);
    const filters = selectAll(store.getState());

    const onSubmitHandler = (e) => {
        e.preventDefault();
        const newHero = {
            id: uuidv4(),
            name: heroName,
            description: heroDescr,
            element: heroElement
        }

        createHero(newHero).unwrap();

        setHeroName('');
        setHeroDescr('');
        setHeroElement('');
    }

    const renderFilters = (filters, status) => {
        if (status === "loading") {
            return <option>Загрузка элементов</option>
        } else if (status === "error") {
            return <option>Ошибка загрузки</option>
        }
        
        if (filters && filters.length > 0 ) {
            return filters.map(({name, label}) => {
                // eslint-disable-next-line
                if (name === 'all')  return;

                return <option key={name} value={name}>{label}</option>
            })
        }
    }

    return (
        <form className="border p-4 shadow-lg rounded" onSubmit={onSubmitHandler}>
            <div className="mb-3">
                <label htmlFor="name" className="form-label fs-4">Имя нового героя</label>
                <input 
                    required
                    type="text" 
                    name="name" 
                    className="form-control" 
                    id="name" 
                    placeholder="Как меня зовут?"
                    value={heroName}
                    onChange={(e) => setHeroName(e.target.value)}/>
            </div>

            <div className="mb-3">
                <label htmlFor="text" className="form-label fs-4">Описание</label>
                <textarea
                    required
                    name="text" 
                    className="form-control" 
                    id="text" 
                    placeholder="Что я умею?"
                    style={{"height": '130px'}}
                    value={heroDescr}
                    onChange={(e) => setHeroDescr(e.target.value)}/>
            </div>

            <div className="mb-3">
                <label htmlFor="element" className="form-label">Выбрать элемент героя</label>
                <select 
                    required
                    className="form-select" 
                    id="element" 
                    name="element"
                    value={heroElement}
                    onChange={(e) => setHeroElement(e.target.value)}>
                    <option value="">Я владею элементом...</option>
                    {renderFilters(filters, filtersLoadingStatus)}
                </select>
            </div>

            <button type="submit" className="btn btn-primary">Создать</button>
        </form>
    )
}

export default HeroesAddForm;			
```						
		
  **[⬆ Наверх](#top)**			

337. ### <a name="337"></a> 

 
    
  **[⬆ Наверх](#top)**			

338. ### <a name="338"></a> Redux Toolkit пример приложения

### index.js		
```jsx harmony
import React from 'react';
import ReactDOM from 'react-dom';
import { Provider } from 'react-redux';
import store from './store';
import './index.css';
import App from './App';

ReactDOM.render(
  <React.StrictMode>
    <Provider store={store}>
      <App />
    </Provider>
  </React.StrictMode>,
  document.getElementById('root')
);		
```
		
### store/index.js
```jsx harmony
import { configureStore } from '@reduxjs/toolkit';
import todoReducer from './todoSlice';

export default configureStore({
  reducer: {
    todos: todoReducer,
  },
});		
```
		
### todoSlice.js
```jsx harmony
import { createSlice } from '@reduxjs/toolkit';

const todoSlice = createSlice({
    name: 'todos',
    initialState: {
        todos: [],
    },
    reducers: {
        addTodo(state, action) {
            state.todos.push({
              id: new Date().toISOString(),
              text: action.payload.text,
              completed: false,
            });
        },
        toggleComplete(state, action) {
            const toggledTodo = state.todos.find(todo => todo.id === action.payload.id);
            toggledTodo.completed = !toggledTodo.completed;
        },
        removeTodo(state, action) {
            state.todos = state.todos.filter(todo => todo.id !== action.payload.id);
        }
    },
});

export const {addTodo, toggleComplete, removeTodo} = todoSlice.actions;

export default todoSlice.reducer;		
```		

### App.jsx
```jsx harmony
import {useState} from 'react';
import { useDispatch } from 'react-redux';

import { addTodo } from './store/todoSlice';
import NewTodoForm from './components/NewTodoForm';
import TodoList from './components/TodoList';

import './App.css';


function App() {
  const [text, setText] = useState('');
  const dispatch = useDispatch();

  const handleAction = () => {
    if(text.trim().length) {
      dispatch(addTodo({text}));
      setText('');
    }
  }

  return (
    <div className='App'>
      <NewTodoForm
        value={text}
        updateText={setText}
        handleAction={handleAction}
      />
      <TodoList />
    </div>
  );
}

export default App;		
```		

### TodoList.jsx
```jsx harmony
import { useSelector } from 'react-redux';
import TodoItem from './TodoItem';

const TodoList = () => {
    const todos = useSelector(state => state.todos.todos);

  return (
    <ul>
      {todos.map((todo) => (
        <TodoItem
          key={todo.id}
          {...todo}
        />
      ))}
    </ul>
  );
};

export default TodoList;		
```		

### TodoItem.jsx
```jsx harmony
import { useDispatch } from 'react-redux';
import {toggleComplete, removeTodo} from '../store/todoSlice';

const TodoItem = ({ id, text, completed }) => {
  const dispatch = useDispatch();

  return (
    <li>
      <input
        type='checkbox'
        checked={completed}
        onChange={() => dispatch(toggleComplete({ id }))}
      />
      <span>{text}</span>
      <span onClick={() => dispatch(removeTodo({id}))}>&times;</span>
    </li>
  );
};

export default TodoItem;		
```		

### NewTodoForm.jsx
```jsx harmony
const NewTodoForm = ({ value, updateText, handleAction }) => {
  return (
    <label>
      <input
        placeholer='new todo'
        value={value}
        onChange={(e) => updateText(e.target.value)}
      />
      <button onClick={handleAction}>Add todo</button>
    </label>
  );
};

export default NewTodoForm;		
```			

## Typescript + Redux Toolkit
		
### index.tsx
```jsx harmony
import ReactDOM from 'react-dom/client';
import {Provider} from 'react-redux';
import store from './store';
import './index.css';
import App from './App';

const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement
);
root.render(
  <Provider store={store}>
    <App />
  </Provider>
);		
```		

### store/index.ts
```jsx harmony
import { configureStore } from '@reduxjs/toolkit';
import todoReducer from './todoSlice';

const store = configureStore({
  reducer: {
    todos: todoReducer,
  },
});

export default store;

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;		
```		

### hooks.ts
```jsx harmony
import {useDispatch, useSelector, TypedUseSelectorHook} from 'react-redux';
import type {RootState, AppDispatch} from './store';

export const useAppDispatch = () => useDispatch<AppDispatch>();
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;		
```		

### todoSlice.ts
```jsx harmony
import { createSlice, PayloadAction } from '@reduxjs/toolkit';

type Todo = {
  id: string;
  title: string;
  completed: boolean;
}

type TodosState = {
  list: Todo[];
}

const initialState: TodosState = {
  list: [],
}

const todoSlice = createSlice({
  name: 'todos',
  initialState,
  reducers: {
    addTodo(state, action: PayloadAction<string>) {
      state.list.push({
        id: new Date().toISOString(),
        title: action.payload,
        completed: false,
      });
    },
    toggleComplete(state, action: PayloadAction<string>) {
      const toggledTodo = state.list.find(todo => todo.id === action.payload);
      if (toggledTodo) {
        toggledTodo.completed = !toggledTodo.completed;
      }
    },
    removeTodo(state, action: PayloadAction<string>) {
      state.list = state.list.filter(todo => todo.id !== action.payload);
    }
  },
});

export const { addTodo, toggleComplete, removeTodo } = todoSlice.actions;

export default todoSlice.reducer;		
```		

### App.tsx
```jsx harmony
import { useState } from 'react';
import { useAppDispatch } from './hook';
import { addTodo } from './store/todoSlice';
import NewTodoForm from './components/NewTodoForm';
import TodoList from './components/TodoList';

import './App.css';


function App() {
  const [text, setText] = useState('');
  const dispatch = useAppDispatch();

  const handleAction = () => {
    if (text.trim().length) {
      dispatch(addTodo(text));
      setText('');
    }
  }

  return (
    <div className='App'>
      <NewTodoForm
        value={text}
        updateText={setText}
        handleAction={handleAction}
      />
      <TodoList />
    </div>
  );
}

export default App;		
```		

### TodoList.tsx
```jsx harmony
import { useAppSelector } from '../hook';
import TodoItem from './TodoItem';

const TodoList: React.FC = () => {
  const todos = useAppSelector(state => state.todos.list);

  return (
    <ul>
      {todos.map((todo) => (
        <TodoItem
          key={todo.id}
          {...todo}
        />
      ))}
    </ul>
  );
};

export default TodoList;		
```		

### TodoItem.tsx
```jsx harmony
import { useAppDispatch } from '../hook';
import { toggleComplete, removeTodo } from '../store/todoSlice';

interface TodoItemProps {
  id: string,
  title: string,
  completed: boolean,
}

const TodoItem: React.FC<TodoItemProps> = ({ id, title, completed }) => {
  const dispatch = useAppDispatch();

  return (
    <li>
      <input
        type='checkbox'
        checked={completed}
        onChange={() => dispatch(toggleComplete(id))}
      />
      <span>{title}</span>
      <span onClick={() => dispatch(removeTodo(id))}>&times;</span>
    </li>
  );
};

export default TodoItem;		
```
		
### NewTodoForm.tsx
```jsx harmony
interface NewTodoFormProps {
  value: string,
  updateText: (str: string) => void,
  handleAction: () => void,
}

const NewTodoForm: React.FC<NewTodoFormProps> = ({ value, updateText, handleAction }) => {
  return (
    <label>
      <input
        placeholder='new todo'
        value={value}
        onChange={(e) => updateText(e.target.value)}
      />
      <button onClick={handleAction}>Add todo</button>
    </label>
  );
};

export default NewTodoForm;		
```				
		
  **[⬆ Наверх](#top)**			

339. ### <a name="339"></a> Redux Toolkit пример 2

### index.js
```jsx harmony
import React from 'react';
import ReactDOM from 'react-dom';
import { store } from './store/store';
import { Provider } from 'react-redux';
import './index.css';
import App from './App';

ReactDOM.render(
  <React.StrictMode>
    <Provider store={store}>
      <App />
    </Provider>
  </React.StrictMode>,
  document.getElementById('root')
);		
```		

### store.js
```jsx harmony
import { configureStore } from '@reduxjs/toolkit';
import userSlice from '../features/user/userSlice';
import todoSlice from '../features/todo/todoSlice';
import postSlice from '../features/post/postSlice';

export const store = configureStore({
  reducer: {
    user: userSlice,
    todo: todoSlice,
    post: postSlice,
  },
});		
```		

### App.js
```jsx harmony
import React from 'react';
import Form from './components/Form';
import TodoItem from './components/TodoItem';
import User from './components/User';
import Posts from './components/Posts';
import { useSelector } from 'react-redux';

function App() {
  return (
    <div className='min-h-screen h-full w-screen bg-indigo-400'>
      <div className='container mx-auto px-4'>
        <header className='flex gap-20 '>
          <div className='w-1/3'>
            <h1 className='font-bold my-5'>Redux Toolkit State Change</h1>
            <User />
          </div>
          <div className='w-1/3'>
            <h1 className='font-bold my-5'>Redux Toolkit Todo App</h1>
            <Form />

            {todos.map((todo) => (
              <TodoItem key={todo.id} todo={todo} />
            ))}
          </div>
          <div className='w-1/3'>
            <h1 className='font-bold my-5'>Redux Toolkit Async Thunk</h1>
            <Posts />
          </div>
        </header>
      </div>
    </div>
  );
}

export default App;		
```

## Приложение 1	
		
### userSlice.js		
```jsx harmony
import { createSlice } from '@reduxjs/toolkit';

const initialState = {
  firstName: '',
  lastName: '',
};

export const userSlice = createSlice({
  name: 'user',
  initialState,
  reducers: {
    setFirstName: (state, action) => {
      state.firstName = action.payload;
    },
    setLastName: (state, action) => {
      state.lastName = action.payload;
    },
  },
});

export const { setFirstName, setLastName } = userSlice.actions;

export default userSlice.reducer;		
```		

### User.js
```jsx harmony
import React from 'react';
import FirstName from './FirstName';
import LastName from './LastName';
import { useDispatch } from 'react-redux';
import { setFirstName, setLastName } from '../features/user/userSlice';

const User = () => {
  const dispatch = useDispatch();

  return (
    <div className='flex flex-col'>
      <input
        type='text'
        placeholder='First Name'
        onChange={(e) => {
          dispatch(setFirstName(e.target.value));
        }}
        className='w-full p-1 mb-2 focus:outline-none focus:border-lime-500 focus: border-2 placeholder:text-sm'
      />
      <input
        type='text'
        placeholder='Second Name'
        onChange={(e) => {
          dispatch(setLastName(e.target.value));
        }}
        className='w-full p-1 mb-2 focus:outline-none focus:border-lime-500 focus: border-2 placeholder:text-sm'
      />
      <div className='flex gap-20 py-5'>
        <div className='flex flex-col'>
          <div className='flex font-light'>First Name:</div>
          <div className='flex'>
            <FirstName />
          </div>
        </div>

        <div className='flex flex-col'>
          <div className='flex font-light'>Last Name:</div>
          <div className='flex'>
            <LastName />
          </div>
        </div>
      </div>
    </div>
  );
};

export default User;		
```		

### FirstName.js
```jsx harmony
import React from 'react';
import { useSelector } from 'react-redux';

const FirstName = () => {
  const name = useSelector((state) => state.user.firstName);

  return <div className='font-bold'>{name}</div>;
};

export default FirstName;		
```

### LastName
```jsx harmony
import React from 'react';
import { useSelector } from 'react-redux';

const LastName = () => {
  const lastname = useSelector((state) => state.user.lastName);

  return <div className='font-bold'>{lastname}</div>;
};

export default LastName;		
```					

## Приложение 2

### App.js
```jsx harmony
import React from 'react';
import Form from './components/Form';
import TodoItem from './components/TodoItem';
import User from './components/User';
import Posts from './components/Posts';
import { useSelector } from 'react-redux';

function App() {
  const todos = useSelector((state) => state.todo.todos);
		
  return (
    <div className='min-h-screen h-full w-screen bg-indigo-400'>
      <div className='container mx-auto px-4'>
        <header className='flex gap-20 '>
          <div className='w-1/3'>
            <h1 className='font-bold my-5'>Redux Toolkit State Change</h1>
            <User />
          </div>
          <div className='w-1/3'>
            <h1 className='font-bold my-5'>Redux Toolkit Todo App</h1>
            <Form />

            {todos?.map((todo) => (
              <TodoItem key={todo.id} todo={todo} />
            ))}
          </div>
          <div className='w-1/3'>
            <h1 className='font-bold my-5'>Redux Toolkit Async Thunk</h1>
            <Posts />
          </div>
        </header>
      </div>
    </div>
  );
}

export default App;		
```		
		
### todoSlice.js
```jsx harmony
import { createSlice } from '@reduxjs/toolkit';

const initialState = {
  todos: [],
};

export const todoSlice = createSlice({
  name: 'todos',
  initialState,
  reducers: {
    addTodo: (state, action) => {
      state.todos.push(action.payload);
    },
    toggleCompletedTodo: (state, action) => {
      const toggleTodo = state.todos.find((todo) => todo.id === action.payload);
      toggleTodo.completed = !toggleTodo.completed;
    },
    removeTodo: (state, action) => {
      state.todos = state.todos.filter((todo) => todo.id !== action.payload);
    },
  },
});

export const { addTodo, toggleCompletedTodo, removeTodo } = todoSlice.actions;
export default todoSlice.reducer;		
```		

### Form.js
```jsx harmony
import React from 'react';
import { useDispatch } from 'react-redux';
import { addTodo } from '../features/todo/todoSlice';
import { v4 } from 'uuid';

const Form = () => {
  const dispatch = useDispatch();
  const [todoValue, setTodoValue] = React.useState('');

  const addTodoHandler = () => {
    const todo = {
      id: v4(),
      text: todoValue,
      completed: false,
    };

    dispatch(addTodo(todo))
    setTodoValue('')
  };

  return (
    <form className='w-full flex' onSubmit={(e) => e.preventDefault()}>
      <input
        type='text'
        value={todoValue}
        placeholder='Type something...'
        onChange={(e) => setTodoValue(e.target.value)}
        className='w-full p-1 focus:outline-none focus:border-lime-500 focus: border-2 placeholder:text-sm'
      />
      <button
        type='submit'
        className='shrink-0 bg-lime-300  hover:bg-lime-400 transition-all px-3 text-sm'
        onClick={() => addTodoHandler()}
      >
        Submit
      </button>
    </form>
  );
};

export default Form;		
```		

### TodoItem.js
```jsx harmony
import React from 'react';
import { useDispatch } from 'react-redux';
import { toggleCompletedTodo, removeTodo } from '../features/todo/todoSlice';

const TodoItem = ({ todo }) => {
  const dispatch = useDispatch();

  const toggleTodoHandler = (id) => {
    dispatch(toggleCompletedTodo(id));
  };

  const removeTodoHandler = (id) => {
    dispatch(removeTodo(id));
  };

  return (
    <div className='flex justify-between items-center my-2'>
      <div
        onClick={() => toggleTodoHandler(todo.id)}
        className='text-sm px-4 py-2 cursor-pointer bg-lime-300 hover:bg-lime-400'
      >
        Complete
      </div>
      <div
        className={`text-sm ${
          todo.completed ? 'line-through font-medium text-lime-400' : ''
        }`}
      >
        {todo.text}
      </div>
      <div
        onClick={() => removeTodoHandler(todo.id)}
        className='text-sm px-4 py-2 flex bg-red-400 hover:bg-red-500 transition-all text-white cursor-pointer'
      >
        Delete
      </div>
    </div>
  );
};

export default TodoItem;		
```		

## Приложение 3

### postSlice.js
```jsx harmony
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import axios from 'axios';

const initialState = {
  posts: [],
};

export const getPosts = createAsyncThunk(
  'posts/getPosts',
  async (_, { rejectWithValue, dispatch }) => {
    const res = await axios.get('https://jsonplaceholder.typicode.com/posts');
    dispatch(setPosts(res.data));
  }
);

export const deletePostById = createAsyncThunk(
  'posts/deletePostById',
  async (id, { rejectWithValue, dispatch }) => {
    await axios.delete(`https://jsonplaceholder.typicode.com/posts/${id}`);
    dispatch(deletePost(id));
  }
);

export const postSlice = createSlice({
  name: 'posts',
  initialState,
  reducers: {
    setPosts: (state, action) => {
      state.posts = action.payload;
    },
    deletePost: (state, action) => {
      state.posts = state.posts.filter((post) => post.id !== action.payload);
    },
  },
  extraReducers: {
    [getPosts.fulfilled]: () => console.log('getPosts: fullfiled'),
    [getPosts.pending]: () => console.log('getPosts: pending'),
    [getPosts.rejected]: () => console.log('getPosts: rejected'),
    [deletePostById.fulfilled]: () => console.log('deletePostById: fullfiled'),
    [deletePostById.pending]: () => console.log('deletePostById: pending'),
    [deletePostById.rejected]: () => console.log('deletePostById: rejected'),
  },
});

export const { setPosts, deletePost } = postSlice.actions;

export default postSlice.reducer;		
```		

### Posts.js
```jsx harmony
import React from 'react';
import PostItem from './PostItem';
import { useDispatch, useSelector } from 'react-redux';
import { getPosts } from '../features/post/postSlice';

const Posts = () => {
  const dispatch = useDispatch();
  const posts = useSelector((state) => state.post.posts);

  return (
    <div>
      <button
        onClick={() => dispatch(getPosts())}
        type='submit'
        className='bg-lime-300  hover:bg-lime-400 transition-all p-2 text-sm'
      >
        Get posts
      </button>

      {posts?.map((post) => (
        <PostItem key={post.title} post={post} />
      ))}
    </div>
  );
};

export default Posts;		
```		

### PostItem.js
```jsx harmony
import React from 'react';
import { deletePostById } from '../features/post/postSlice';
import { useDispatch } from 'react-redux';

const PostItem = ({ post }) => {
  const dispatch = useDispatch();

  return (
    <div
      onClick={() => dispatch(deletePostById(post.id))}
      className='flex w-full bg-indigo-500 hover:bg-indigo-300 transition-all py-1 px-2 text-white rounded-sm cursor-pointer mt-4'
    >
      {post.title}
    </div>
  );
};

export default PostItem;		
```					
		
  **[⬆ Наверх](#top)**			

340. ### <a name="340"></a> Redux Toolkit createAsyncThunk

### index.js
```jsx harmony
import React from 'react';
import ReactDOM from 'react-dom';
import { Provider } from 'react-redux';
import store from './store';
import './index.css';
import App from './App';

ReactDOM.render(
  <React.StrictMode>
    <Provider store={store}>
      <App />
    </Provider>
  </React.StrictMode>,
  document.getElementById('root')
);		
```		
 
### store/index.js
```jsx harmony
import { configureStore } from '@reduxjs/toolkit';
import todoReducer from './todoSlice';

export default configureStore({
  reducer: {
    todos: todoReducer,
  },
});		
```		

### todoSlice.js
```jsx harmony
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';

export const fetchTodos = createAsyncThunk(
    'todos/fetchTodos',
    async function(_, {rejectWithValue}) {
        try {
            const response = await fetch('https://jsonplaceholder.typicode.com/todos?_limit=10');
            
            if (!response.ok) {
                throw new Error('Server Error!');
            }
    
            const data = await response.json();
    
            return data;
        } catch (error) {
            return rejectWithValue(error.message);
        }
    }
);

export const deleteTodo = createAsyncThunk(
    'todos/deleteTodo',
    async function(id, {rejectWithValue, dispatch}) {
        try {
            const response = await fetch(`https://jsonplaceholder.typicode.com/todos/${id}`, {
                method: 'DELETE',
            })

            if (!response.ok) {
                throw new Error('Can\'t delete task. Server error.');
            }

            dispatch(removeTodo({id}));

        } catch (error) {
            return rejectWithValue(error.message);
        }
    }
);

export const toggleStatus = createAsyncThunk(
    'todos/toggleStatus',
    async function (id, {rejectWithValue, dispatch, getState}) {
        const todo = getState().todos.todos.find(todo => todo.id === id);

        try {
            const response = await fetch(`https://jsonplaceholder.typicode.com/todos/${id}`, {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    completed: !todo.completed,
                })
            });

            if (!response.ok) {
                throw new Error('Can\'t toggle status. Server error.');
            }

            dispatch(toggleComplete({id}));

        } catch (error) {
            return rejectWithValue(error.message)
        }
    }
);

export const addNewTodo = createAsyncThunk(
    'todos/addNewTodo',
    async function (text, {rejectWithValue, dispatch}) {
        try {
            const todo = {
                title: text,
                userId: 1,
                completed: false,
            };

            const response = await fetch('https://jsonplaceholder.typicode.com/todos', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(todo)
            });

            if (!response.ok) {
                throw new Error('Can\'t add task. Server error.');
            }

            const data = await response.json();
            dispatch(addTodo(data));

        } catch (error) {
            return rejectWithValue(error.message);
        }
    }
);

const setError = (state, action) => {
    state.status = 'rejected';
    state.error = action.payload;
}

const todoSlice = createSlice({
    name: 'todos',
    initialState: {
        todos: [],
        status: null,
        error: null,
    },
    reducers: {
        addTodo(state, action) {
            state.todos.push(action.payload);
        },
        toggleComplete(state, action) {
            const toggledTodo = state.todos.find(todo => todo.id === action.payload.id);
            toggledTodo.completed = !toggledTodo.completed;
        },
        removeTodo(state, action) {
            state.todos = state.todos.filter(todo => todo.id !== action.payload.id);
        }
    },
    extraReducers: {
        [fetchTodos.pending]: (state) => {
            state.status = 'loading';
            state.error = null;
        },
        [fetchTodos.fulfilled]: (state, action) => {
            state.status = 'resolved';
            state.todos = action.payload;
        },
        [fetchTodos.rejected]: setError,
        [deleteTodo.rejected]: setError,
        [toggleStatus.rejected]: setError,
    },
});

const {addTodo, toggleComplete, removeTodo} = todoSlice.actions;

export default todoSlice.reducer;		
```		

### App.js
```jsx harmony
import {useState, useEffect} from 'react';
import { useDispatch, useSelector } from 'react-redux';

import { addNewTodo, fetchTodos } from './store/todoSlice';
import NewTodoForm from './components/NewTodoForm';
import TodoList from './components/TodoList';

import './App.css';


function App() {
  const [text, setText] = useState('');
  const {status, error} = useSelector(state => state.todos);
  const dispatch = useDispatch();

  const handleAction = () => {
    if(text.trim().length) {
      dispatch(addNewTodo(text));
      setText('');
    }
  }

  useEffect(() => {
    dispatch(fetchTodos());
  }, [dispatch]);

  return (
    <div className='App'>
      <NewTodoForm
        value={text}
        updateText={setText}
        handleAction={handleAction}
      />

      {status === 'loading' && <h2>Loading...</h2>}
      {error &&  <h2>An error occured: {error}</h2>}

      <TodoList />
    </div>
  );
}

export default App;		
```		

### TodoList.js
```jsx harmony
import { useSelector } from 'react-redux';
import TodoItem from './TodoItem';

const TodoList = () => {
    const todos = useSelector(state => state.todos.todos);

  return (
    <ul>
      {todos.map((todo) => (
        <TodoItem
          key={todo.id}
          {...todo}
        />
      ))}
    </ul>
  );
};

export default TodoList;		
```		

### TodoItem.js
```jsx harmony
import { useDispatch } from 'react-redux';
import {toggleStatus, deleteTodo} from '../store/todoSlice';

const TodoItem = ({ id, title, completed }) => {
  const dispatch = useDispatch();

  return (
    <li>
      <input
        type='checkbox'
        checked={completed}
        onChange={() => dispatch(toggleStatus(id))}
      />
      <span>{title}</span>
      <span onClick={() => dispatch(deleteTodo(id))}>&times;</span>
    </li>
  );
};

export default TodoItem;		
```

### NewTodoForm.js
```jsx harmony
const NewTodoForm = ({ value, updateText, handleAction }) => {
  return (
    <label>
      <input
        placeholer='new todo'
        value={value}
        onChange={(e) => updateText(e.target.value)}
      />
      <button onClick={handleAction}>Add todo</button>
    </label>
  );
};

export default NewTodoForm;		
```		

## Typescript + Redux Toolkit
		
### index.tsx
```jsx harmony
import ReactDOM from 'react-dom/client';
import {Provider} from 'react-redux';
import store from './store';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';

const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement
);
root.render(
  <Provider store={store}>
    <App />
  </Provider>
);		
```		

### store/index.ts
```jsx harmony
import { configureStore } from '@reduxjs/toolkit';
import todoReducer from './todoSlice';

const store = configureStore({
  reducer: {
    todos: todoReducer,
  },
});

export default store;

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;		
```		

### hooks.ts
```jsx harmony
import {useDispatch, useSelector, TypedUseSelectorHook} from 'react-redux';
import type {RootState, AppDispatch} from './store';

export const useAppDispatch = () => useDispatch<AppDispatch>();
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;		
```		

### todoSlice.ts
```jsx harmony
import { createSlice, PayloadAction, createAsyncThunk, AnyAction } from '@reduxjs/toolkit';

type Todo = {
  id: string;
  title: string;
  completed: boolean;
}

type TodosState = {
  list: Todo[];
  loading: boolean;
  error: string | null;
}
export const fetchTodos = createAsyncThunk<Todo[], undefined, {rejectValue: string}>(
    'todos/fetchTodos',
    async function (_, { rejectWithValue }) {
      const response = await fetch('https://jsonplaceholder.typicode.com/todos?_limit=10');

      if (!response.ok) {
        return rejectWithValue('Server Error!');
      }

      const data = await response.json();

      return data;
    }
);

export const addNewTodo = createAsyncThunk<Todo, string, { rejectValue: string }>(
  'todos/addNewTodo',
  async function (text, { rejectWithValue }) {
      const todo = {
        title: text,
        userId: 1,
        completed: false,
      };

      const response = await fetch('https://jsonplaceholder.typicode.com/todos', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(todo)
      });

      if (!response.ok) {
        return rejectWithValue('Can\'t add task. Server error.');
      }

      return (await response.json()) as Todo;
  }
);

export const toggleStatus = createAsyncThunk<Todo, string, { rejectValue: string, state: { todos: TodosState} }>(
  'todos/toggleStatus',
  async function (id, { rejectWithValue, getState }) {
    const todo = getState().todos.list.find(todo => todo.id === id);

    if (todo) {
      const response = await fetch(`https://jsonplaceholder.typicode.com/todos/${id}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          completed: !todo.completed,
        })
      });
  
      if (!response.ok) {
        return rejectWithValue('Can\'t toggle status. Server error.');
      }
  
      return (await response.json()) as Todo; 
    }

    return rejectWithValue('No such todo in the list!')
  }
);

export const deleteTodo = createAsyncThunk<string, string, { rejectValue: string }>(
  'todos/deleteTodo',
  async function (id, { rejectWithValue }) {
    const response = await fetch(`https://jsonplaceholder.typicode.com/todos/${id}`, {
      method: 'DELETE',
    })

    if (!response.ok) {
      return rejectWithValue('Can\'t delete task. Server error.');
    }

    return id;
  }
);

const initialState: TodosState = {
  list: [],
  loading: false,
  error: null,
}

const todoSlice = createSlice({
  name: 'todos',
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchTodos.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchTodos.fulfilled, (state, action) => {
        state.list = action.payload;
        state.loading = false;
      })
      .addCase(addNewTodo.pending, (state) => {
        state.error = null;
      })
      .addCase(addNewTodo.fulfilled, (state, action) => {
        state.list.push(action.payload);
      })
      .addCase(toggleStatus.fulfilled, (state, action) => {
        const toggledTodo = state.list.find(todo => todo.id === action.payload.id);
        if (toggledTodo) {
          toggledTodo.completed = !toggledTodo.completed;
        }
      })
      .addCase(deleteTodo.fulfilled, (state, action) => {
        state.list = state.list.filter(todo => todo.id !== action.payload);
      })
      .addMatcher(isError, (state, action: PayloadAction<string>) => {
        state.error = action.payload;
        state.loading = false;
      });
  }
});

// export const { addTodo, toggleComplete, removeTodo } = todoSlice.actions;

export default todoSlice.reducer;

function isError(action: AnyAction) {
  return action.type.endsWith('rejected');
}		
```		

### App.tsx
```jsx harmony
import { useState, useEffect } from 'react';
import { useAppDispatch, useAppSelector } from './hook';
import { fetchTodos, addNewTodo } from './store/todoSlice';
import NewTodoForm from './components/NewTodoForm';
import TodoList from './components/TodoList';

import './App.css';


function App() {
  const [text, setText] = useState('')
  const { loading, error } = useAppSelector(state => state.todos);;
  const dispatch = useAppDispatch();

  const handleAction = () => {
    if (text.trim().length) {
      dispatch(addNewTodo(text));
      setText('');
    }
  }

  useEffect(() => {
    dispatch(fetchTodos());
  }, [dispatch]);

  return (
    <div className='App'>
      <NewTodoForm
        value={text}
        updateText={setText}
        handleAction={handleAction}
      />

      {loading && <h2>Loading...</h2>}
      {error && <h2>An error occured: {error}</h2>}
      <TodoList />
    </div>
  );
}

export default App;		
```		

### TodoList.tsx
```jsx harmony
import { useAppSelector } from '../hook';
import TodoItem from './TodoItem';

const TodoList: React.FC = () => {
  const todos = useAppSelector(state => state.todos.list);

  return (
    <ul>
      {todos.map((todo) => (
        <TodoItem
          key={todo.id}
          {...todo}
        />
      ))}
    </ul>
  );
};

export default TodoList;		
```		

### TodoItem.tsx
```jsx harmony
import { useAppDispatch } from '../hook';
import { toggleStatus, deleteTodo } from '../store/todoSlice';

interface TodoItemProps {
  id: string,
  title: string,
  completed: boolean,
}

const TodoItem: React.FC<TodoItemProps> = ({ id, title, completed }) => {
  const dispatch = useAppDispatch();

  return (
    <li>
      <input
        type='checkbox'
        checked={completed}
        onChange={() => dispatch(toggleStatus(id))}
      />
      <span>{title}</span>
      <span onClick={() => dispatch(deleteTodo(id))}>&times;</span>
    </li>
  );
};

export default TodoItem;		
```		

### NewTodoForm.tsx
```jsx harmony
interface NewTodoFormProps {
  value: string,
  updateText: (str: string) => void,
  handleAction: () => void,
}

const NewTodoForm: React.FC<NewTodoFormProps> = ({ value, updateText, handleAction }) => {
  return (
    <label>
      <input
        placeholder='new todo'
        value={value}
        onChange={(e) => updateText(e.target.value)}
      />
      <button onClick={handleAction}>Add todo</button>
    </label>
  );
};

export default NewTodoForm;		
```				
		
  **[⬆ Наверх](#top)**			

341. ### <a name="341"></a> RTK Query

### index.js
```jsx harmony
import React from 'react';
import ReactDOM from 'react-dom';
import { Provider } from 'react-redux';
import './index.css';
import App from './App';
import { store } from './redux';

ReactDOM.render(
  <Provider store={store}>
    <App />
  </Provider>,
  document.getElementById('root')
);		
```		

### db.json
```jsx harmony
{
  "goods": [
    {
      "id": 1,
      "name": "Milk"
    },
    {
      "id": 2,
      "name": "bananas"
    },
    {
      "id": 3,
      "name": "icecream"
    }
  ]
}		
```		

### redux/index.js
```jsx harmony
export * from './store';
export * from './goodsApi';		
```		

### redux/goodsApi.js
```jsx harmony
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';

export const goodsApi = createApi({
    reducerPath: 'goodsApi',
    tagTypes: ['Products'],
    baseQuery: fetchBaseQuery({baseUrl: 'http://localhost:3001/'}),
    endpoints: (build) => ({
        getGoods: build.query({
            query: (limit = '') => `goods?${limit && `_limit=${limit}`}`,
            providesTags: (result) => result
              ? [
                  ...result.map(({ id }) => ({ type: 'Products', id })),
                  { type: 'Products', id: 'LIST' },
                ]
              : [{ type: 'Products', id: 'LIST' }],
        }),
        addProduct: build.mutation({
            query: (body) => ({
                url: 'goods',
                method: 'POST',
                body,
            }),
            invalidatesTags: [{type: 'Products', id: 'LIST'}]
        }),
        deleteProduct: build.mutation({
            query: (id) => ({
                url: `goods/${id}`,
                method: 'DELETE',
            }),
            invalidatesTags: [{type: 'Products', id: 'LIST'}]
        })
    })
});

export const {useGetGoodsQuery, useAddProductMutation, useDeleteProductMutation} = goodsApi;		
```		
		
### redux/store.js
```jsx harmony
import { configureStore } from '@reduxjs/toolkit';
import { goodsApi } from './goodsApi';

export const store = configureStore({
    reducer: {
        [goodsApi.reducerPath]: goodsApi.reducer,
    },
    middleware: (getDefaultMiddlware) => getDefaultMiddlware().concat(goodsApi.middleware)
});		
```		

### App.js
```jsx harmony
import { useState } from 'react';
import { useGetGoodsQuery, useAddProductMutation, useDeleteProductMutation } from './redux';

function App() {
  const [count, setCount] = useState('');
  const [newProduct, setNewProduct] = useState('');
  const {data = [], isLoading} = useGetGoodsQuery(count);
  const [addProduct, {isError}] = useAddProductMutation();
  const [deleteProduct] = useDeleteProductMutation();

  const handleAddProduct = async () => {
    if(newProduct) {
      await addProduct({name: newProduct}).unwrap();
      setNewProduct('');
    }
  }

  const handleDeleteProduct = async (id) => {
    await deleteProduct(id).unwrap();
  }

  if (isLoading) return <h1>Loading...</h1>

  return (
    <div>
      <div>
        <input
          type="text"
          value={newProduct}
          onChange={(e) => setNewProduct(e.target.value)}
        />
        <button onClick={handleAddProduct}>Add product</button>
      </div>
      <div>
        <select value={count} onChange={(e) => setCount(e.target.value)}>
          <option value="">all</option>
          <option value="1">1</option>
          <option value="2">2</option>
          <option value="3">3</option>
        </select>
      </div>
      <ul>
        {data.map(item => (
          <li key={item.id} onClick={() => handleDeleteProduct(item.id)}>
            {item.name}
          </li>
        ))}
      </ul>
    </div>
  );
}

export default App;		
```		
		
  **[⬆ Наверх](#top)**		

342. ### <a name="342"></a> 
		
		
  **[⬆ Наверх](#top)**		
		
343. ### <a name="343"></a> 
		
		
  **[⬆ Наверх](#top)**	
		
344. ### <a name="344"></a> 
		
		
  **[⬆ Наверх](#top)**	
		
345. ### <a name="345"></a> 
		
		
  **[⬆ Наверх](#top)**	
		
346. ### <a name="346"></a> 
		
		
  **[⬆ Наверх](#top)**	
		
347. ### <a name="347"></a> 
		
		
  **[⬆ Наверх](#top)**			
		
350. ### <a name="350"></a> Redux

 Redux - это ценный инструмент для управления вашим состоянием, но вы также должны учитывать, подходит ли он для вашей ситуации. Не используйте Redux только потому, что кто-то сказал, что вам нужно - потратьте некоторое время, чтобы понять потенциальные выгоды и компромиссы с его использованием.
	
*Redux* - это стабильный (предсказуемый) контейнер для хранения состояния JavaScript-приложений, основанный на паттерне проектирования Flux. Redux может использоваться с React и любой другой библиотекой. Он легкий (около 2 Кб) и не имеет зависимостей.	

![2](https://user-images.githubusercontent.com/80325645/152787114-911ae428-304e-49c9-bafd-63a93d54466a.jpg)  
	  
### Redux следует трем фундаментальным принципам:

1. Единственный источник истины: состояние всего приложения хранится в древовидном объекта - в одном хранилище. Единственное состояние-дерево облегчает наблюдение за изменениями и отладку или инспектирование приложения
2. Состояние доступно только для чтения: единственный способ изменить состояние заключается в запуске операции - объекте, описывающем произошедшее. Это позволяет гарантировать, что ни представления, ни сетевые коллбеки не буду иметь возможности изменять состояние напрямую
3. Изменения производятся с помощью "чистых" функций: для определения того, как изменяется состояние в зависимости от операции, создаются редукторы (reducers). Редукторы - это "чистые" функции, принимающие предыдущее состояние в качестве аргумента и возвращающие новое


### В чем заключаются преимущества и недостатки Redux?***

**Преимущества**

* Хранилище позволяет любому компоненту получать состояние без передачи пропов
* Состояние сохраняется даже при размонтировании компонента
* Предотвращает ненужные повторные рендеринги благодаря поверхностному сравнению нового и старого состояния
* Разделение UI и управления данными облегчает тестирование
* Сохраняется история изменения состояния, что позволяет легко повторять или отменять операции

**Недостатки**

* Отсутствует инкапсуляция. Любой компонент имеет доступ к данным, что может привести к проблемам с безопасностью
* Много шаблонного кода. Ограниченный дизайн
* Поскольку состояние является иммутабельным, редуктор обновляет его, каждый раз возвращая новое состояние, что влечет дополнительные расходы памяти	
	
	
*Redux может быть описан тремя фундаментальными принципами:*

### Единственный источник правды
	
Состояние всего вашего приложения сохранено в дереве объектов внутри одного стора.

Это облегчает создание универсальных приложений. Состояние на сервере может быть сериализировано и отправлено на клиент без дополнительных усилий. Это упрощает отладку приложения, когда мы имеем дело с единственным деревом состояния. Вы также можете сохранять состояние вашего приложения для ускорения процесса разработки. И с единственным деревом состояния вы получаете функциональность типа Undo/Redo из коробки.
```jsx harmony
console.log(store.getState())

{
  visibilityFilter: 'SHOW_ALL',
  todos: [
    {
      text: 'Consider using Redux',
      completed: true,
    },
    {
      text: 'Keep all state in a single tree',
      completed: false
    }
  ]
}
```
	
### Состояние только для чтения
	
Единственный способ изменить состояние — это применить экшен — объект, который описывает, что случится.

Это гарантирует, что представления или функции, реагирующие на события сети (network callbacks), никогда не изменят состояние напрямую. Поскольку все изменения централизованы и применяются последовательно в строгом порядке, поэтому нет необходимости следить за "гонкой состояний". Экшены — это всего лишь простые объекты, поэтому они могут быть залогированы, сериализированы, сохранены и затем воспроизведены для отладки или тестирования.
```jsx harmony
store.dispatch({
  type: 'COMPLETE_TODO',
  index: 1
})

store.dispatch({
  type: 'SET_VISIBILITY_FILTER',
  filter: 'SHOW_COMPLETED'
})
```
	
### Мутации написаны, как чистые функции
	
Для определения того, как дерево состояния будет трансформировано экшенами, вы пишете чистые редьюсеры.

Редьюсеры — это просто чистые функции, которые берут предыдущее состояние и экшен и возвращают новое состояние. Не забывайте возвращать новый объект состояния вместо того, чтобы изменять предыдущее. Вы можете начать с одного редьюсера, но в дальнейшем, когда ваше приложение разрастется, вы можете разделить его на более маленькие редьюсеры, которые управляют отдельными частями дерева состояния. Поскольку редьюсеры — это просто функции, вы можете контролировать порядок, в котором они вызываются, отправлять дополнительные данные или даже писать переиспользуемые редьюсеры для общих задач, например, для пагинации.
```jsx harmony
function visibilityFilter(state = 'SHOW_ALL', action) {
  switch (action.type) {
    case 'SET_VISIBILITY_FILTER':
      return action.filter
    default:
      return state
  }
}

function todos(state = [], action) {
  switch (action.type) {
    case 'ADD_TODO':
      return [
        ...state,
        {
          text: action.text,
          completed: false
        }
      ]
    case 'COMPLETE_TODO':
      return state.map((todo, index) => {
        if (index === action.index) {
          return Object.assign({}, todo, {
            completed: true
          })
        }
        return todo
      })
    default:
      return state
  }
}

import { combineReducers, createStore } from 'redux'
let reducer = combineReducers({ visibilityFilter, todos })
let store = createStore(reducer)	
```

	
### Сущности в React:
- Actions
- Reducers
- Store
- Dispatch	
	
	
	
*Flux* - это *парадигма проектирования приложений*, являющаяся альтернативой более традиционному паттерну MVC. Это не фреймворк или библиотека, а новый вид архитектуры, разработанный специально для React с учетом концепции однонаправленного потока данных. Facebook использует данный паттерн в своих внутренних проектах.	
	
### Отличия между Redux и Flux можно свести к следующему:

1. Недопустимость мутаций: во Flux состояние может быть изменяемым, а Redux требует, чтобы состояние было иммутабельным, и многие библиотеки для Redux исходят из предположения, что вы никогда не будете менять состояние напрямую. Вы можете обеспечить иммутабельность состояния с помощью таких пакетов, как `redux-immutable-state-invariant`, `Immutable.js` или условившись с другими членами команды о написании иммутабельного кода
2. Осторожность в выборе библиотек: Flux не пытается решать такие проблемы, как повторное выполнение/отмена выполнения, стабильность (постоянство) кода или проблемы, связанные с обработкой форм, явно, а Redux имеет возможность к расширению с помощью промежуточного программного обеспечения (middleware) и предохранителей хранилища, что породило богатую экосистему
3. Отсутствие интеграции с Flow: Flux позволяет осуществлять очень выразительную статическую проверку типов, а Redux пока не поддерживает такой возможности
    
  **[⬆ Наверх](#top)**
	
351. ### <a name="351"></a> connect. HOC

 ### Понимание того, что такое connect.
	
Для того, чтобы иметь возможность использовать хранилище в контейнере, необходимо выполнить следующие шаги:

1. **Использовать метод `mapStateToProps()`:** он передает переменные состояния из хранилища в определенные вами пропы
2. **Подключить пропы к контейнеру:** объект, возвращенный `mapStateToProps()` подключается к контейнеру. Вы можете импортировать `connect()` из `react-redux`:

 ```jsx harmony
 import React from 'react'
 import { connect } from 'react-redux'

 class App extends React.Component {
   render() {
     return <div>{this.props.containerData}</div>
   }
 }

 function mapStateToProps(state) {
   return { containerData: state.data }
 }

 export default connect(mapStateToProps)(App)
 ```	

Лучшим способом получить хранилище в компоненте является использование функции `connect()`, которая создает новый компонент, оборачивающий существующий. Этот паттерн называется *компоненты высшего порядка*, он является предпочтительным способом расширения функциональности компонента в React. Это позволяет передавать в компонент состояние и "создателей операций" (action creators), в том числе, при обновлении хранилища.

Создадим компонент `FilterLink` с помощью `connect()`:

```javascript
import { connect } from 'react-redux'
import { setVisibilityFilter } from '../actions'
import Link from '../components/Link'

const mapStateToProps = (state, ownProps) => ({
active: ownProps.filter === state.visibilityFilter
})

const mapDispatchToProps = (dispatch, ownProps) => ({
onClick: () => dispatch(setVisibilityFilter(ownProps.filter))
})

const FilterLink = connect(
mapStateToProps,
mapDispatchToProps
)(Link)

export default FilterLink
```

Поскольку такой вариант имеет несколько оптимизаций производительности и, как правило, меньше подвержен "багам", разработчики Redux почти всегда рекомендуют использовать `connect()` вместо прямого доступа к хранилищу (с помощью API контекста).

```javascript
     class MyComponent {
       someMethod() {
         doSomethingWith(this.context.store)
       }
     }
```	
	
	
### HOC
	
Higher-order component (HOC) - это функция, принимающая компонент и возвращающая новый компонент. Это паттерн, производный от композиционной природы React.

Мы называем такие компоненты *чистыми*, поскольку они могут принимать и динамически предоставлять дочерние компоненты, но не меняют и не копируют их поведение.

```javascript
const EnhancedComponent = higherOrderComponent(WrappedComponent)
```

HOC, обычно, используются для:

1. Обеспечения возможности переиспользования кода, логики, а также для абстрагирования шаблонов
2. Отложенного рендеринга
3. Абстрагирования и манипулирования состоянием
4. Манипулирования пропами	

	
HOC не являются частью React API. HOC является паттерном, производным от композиционной природы React. Компонент преобразует пропы в UI, а HOC трансформирует один компонент в другой. Примерами популярных HOC являются методы `connect()` в Redux и `createContainer()` в Relay.

```js
// HOC.js
import React, { Component } from 'react'

export default function Hoc(HocComponent){
    return class extends Component{
        render(){
            return (
                <div>
                  <HocComponent></HocComponent>
                </div>

            )
        }
    }
}
```

```js
// App.js
import React, { Component } from 'react'
import Hoc from './HOC'

class App extends Component {
  render() {
    return (
      <div>
        Пример компонента высшего порядка!
      </div>
    )
  }
}
App = Hoc(App)
export default App
```

**Обратите внимание:**

* Мы не модифицируем компоненты, а создаем новые
* HOC используются для композиции компонентов для обеспечения возможности повторного использования кода
* HOC являются "чистыми" функциями. Они не имеют побочных эффектов (side effects) и всегда возвращают одинаковые результаты для одних и тех же аргументов
    
  **[⬆ Наверх](#top)**
	
352. ### <a name="352"></a> actions

 *Actions* - это обычные JavaScript-объекты, содержащие данные приложения, которые отправляются в хранилище. Операции должны иметь свойство `type`, указывающее какой тип операции необходимо выполнить. Операции также могут содержать полезную нагрузку (payload) - данные для обновления состояния.

Вот как может выглядеть операция по добавлению новой задачи в список:

```jsx harmony
// здесь используется константа
{
type: ADD_TODO,
text: 'Добавление задачи в список'
}
```
	
Экшены — это структуры, которые передают данные из вашего приложения в стор. Они являются единственными источниками информации для стора. Вы отправляете их в стор, используя метод store.dispatch().

Например, вот экшен, которое представляет добавление нового пункта в список дел:
```jsx harmony
const ADD_TODO = 'ADD_TODO'
```
```jsx harmony	
{
  type: ADD_TODO,
  text: 'Build my first Redux app'
}
```	
Экшены — это обычные JavaScript-объекты. Экшены должны иметь поле type, которое указывает на тип исполняемого экшена. Типы должны быть, как правило, заданы, как строковые константы. После того, как ваше приложение разрастется, вы можете захотеть переместить их в отдельный модуль.
```jsx harmony
import { ADD_TODO, REMOVE_TODO } from '../actionTypes'
```	

Мы добавим еще один тип экшена, который будет отмечать задачу, как выполненную. Мы обращаемся к конкретному todo по index, потому что мы храним их в виде массива. В реальном приложении разумнее генерировать уникальный ID каждый раз, когда что-то новое создается.
```jsx harmony
{
  type: TOGGLE_TODO,
  index: 5
}
```	
Это хорошая идея, передавать как можно меньше данных в каждом экшене. Например, лучше отправить index, чем весь объект todo.

Наконец, мы добавим еще один тип экшена для изменения видимых, в данный момент, задач.
```jsx harmony
{
  type: SET_VISIBILITY_FILTER,
  filter: SHOW_COMPLETED
}
```
	
### Генераторы экшенов (Action Creators)
	
Генераторы экшенов (Action Creators) — не что иное, как функции, которые создают экшены. Довольно просто путать термины “action” и “action creator,” поэтому постарайтесь использовать правильный термин.

В Redux генераторы экшенов (action creators) просто возвращают action:
```jsx harmony
function addTodo(text) {
  return {
    type: ADD_TODO,
    text
  }
}
```	
Это делает их более переносимыми и легкими для тестирования.

В традиционной реализации Flux, генераторы экшенов (action creators) при выполнении часто вызывают dispatch, примерно так:
```jsx harmony
function addTodoWithDispatch(text) {
  const action = {
    type: ADD_TODO,
    text
  }
  dispatch(action)
}
```	
В Redux это не так. Вместо того чтобы на самом деле начать отправку, передайте результат в функцию dispatch():
```jsx harmony
dispatch(addTodo(text))
dispatch(completeTodo(index))
```	
Кроме того, вы можете создать связанный генератор экшена (bound action creator), который автоматически запускает отправку экшена:
```jsx harmony
const boundAddTodo = (text) => dispatch(addTodo(text))
const boundCompleteTodo = (index) => dispatch(completeTodo(index))
```	
Теперь вы можете вызвать его напрямую:
```jsx harmony
boundAddTodo(text)
boundCompleteTodo(index)
```	
Доступ к функции dispatch() может быть получен непосредственно из стора (store) store.dispatch(), но, что более вероятно, вы будете получать доступ к ней при помощи чего-то типа connect() из react-redux. Вы можете использовать функцию bindActionCreators() для автоматического привязывания большого количества генераторов экшенов (action creators) к функции dispatch().

Генератор экшены так же могут быть асинхронными и иметь сайд-эффекты. Вы можете почитать про асинхронные экшены в расширенном руководстве, чтобы узнать, как обрабатывать ответы AJAX и создавать генераторы действий в асинхронном потоке управления. Не переходите к асинхронным экшенам до тех пор, пока вы не завершите базовое руководство, так как оно охватывает другие важные концепции, которые необходимы для продвинутого руководства и асинхронных экшенов.

### Исходный код
	
**actions.js**
	
```jsx harmony	
/*
 * типы экшенов
 */

export const ADD_TODO = 'ADD_TODO'
export const TOGGLE_TODO = 'TOGGLE_TODO'
export const SET_VISIBILITY_FILTER = 'SET_VISIBILITY_FILTER'

/*
 * другие константы
 */

export const VisibilityFilters = {
  SHOW_ALL: 'SHOW_ALL',
  SHOW_COMPLETED: 'SHOW_COMPLETED',
  SHOW_ACTIVE: 'SHOW_ACTIVE'
}

/*
 * генераторы экшенов
 */

export function addTodo(text) {
  return { type: ADD_TODO, text }
}

export function toggleTodo(index) {
  return { type: TOGGLE_TODO, index }
}

export function setVisibilityFilter(filter) {
  return { type: SET_VISIBILITY_FILTER, filter }
}	
```
    
  **[⬆ Наверх](#top)**
	
353. ### <a name="353"></a> reducer

 ### Редьюсеры (Reducers)
	
Редьюсеры определяют, как состояние приложения изменяется в ответ на экшены, отправленные в стор. Помните, что экшены только описывают, _что произошло, но не описывают, как изменяется состояние приложения.

### Проектирование структуры состояния (State)
	
В Redux все состояние приложения хранится в виде единственного объекта. Подумать о его структуре перед написанием кода — довольно неплохая идея. Каково минимальное представление состояния Вашего приложения в виде объекта?

Для нашего todo-приложения, мы хотим хранить две разные сущности:
- Состояние фильтра видимости;
- Актуальный список todo-задач.
	
Часто вы будете понимать, что вам нужно хранить некоторые данные, а также некоторые состояния пользовательского интерфейса в дереве состояний. Это нормально, только старайтесь такие данные не смешивать с данными, которые описывают состояние UI.
```jsx harmony
{
  visibilityFilter: 'SHOW_ALL',
  todos: [
    {
      text: 'Consider using Redux',
      completed: true,
    },
    {
      text: 'Keep all state in a single tree',
      completed: false
    }
  ]
}
```	

### Обработка экшенов
	
Теперь, когда мы определились с тем, как должны выглядеть наши объекты состояния (state objects), мы готовы написать редьюсер для них.
	
`Редьюсер` (reducer) — это чистая функция, которая принимает предыдущее состояние и экшен (state и action) и возвращает следующее состояние (новую версию предыдущего).
```jsx harmony
(previousState, action) => newState
```	
Функция называется редьюсером (reducer) потому, что ее можно передать в Array.prototype.reduce(reducer, ?initialValue). Очень важно, чтобы редьюсеры оставались чистыми функциями. Вот список того, чего никогда нельзя делать в редьюсере:
- Непосредственно изменять то, что пришло в аргументах функции;
- Выполнять какие-либо сайд-эффекты: обращаться к API или осуществлять переход по роутам;
- Вызывать не чистые функции, например Date.now() или Math.random().
	
Мы рассмотрим способы выполнения сайд-эффектов в продвинутом руководстве. На данный момент просто запомните, что редьюсер должен быть чистым. Получая аргументы одного типа, редьюсер должен вычислять новую версию состояния и возвращать ее. Никаких сюрпризов. Никаких сайд-эффектов. Никаких обращений к стороннему API. Никаких изменений (mutations). Только вычисление новой версии состояния.

Исходя из вышенаписанных принципов, давайте начнем писать редьюсер, постепенно обучая его понимать экшены (actions), которые мы описали чуть раньше.

Мы начнем с определения начального состояния (initial state). В первый раз Redux вызовет редьюсер с неопределенным состоянием(state === undefined). Это наш шанс инициализировать начальное состояние приложения:
```jsx harmony
import { VisibilityFilters } from './actions'

const initialState = {
  visibilityFilter: VisibilityFilters.SHOW_ALL,
  todos: []
}

function todoApp(state, action) {
  if (typeof state === 'undefined') {
    return initialState
  }

  // Пока не обрабатываем никаких экшенов
  // и просто возвращаем состояние, которое приняли в качестве параметра
  return state
}
```	
Использование синтаксиса аргументов по умолчанию из ES6 для более компактного написания — просто аккуратный трюк:
```jsx harmony
function todoApp(state = initialState, action) {
  // Пока не обрабатываем никаких экшенов
  // и просто возвращаем состояние, которое приняли в качестве параметра
  return state
}
```	
Теперь давайте начнем обрабатывать экшен SET_VISIBILITY_FILTER. Все, что нужно сделать — это изменить visibilityFilter в состоянии приложения. Это просто:
```jsx harmony
import {
  SET_VISIBILITY_FILTER,
  VisibilityFilters
} from './actions'

...

function todoApp(state = initialState, action) {
  switch (action.type) {
    case SET_VISIBILITY_FILTER:
      return Object.assign({}, state, {
        visibilityFilter: action.filter
      })
    default:
      return state
  }
}
```	
Обратите внимание:
- Мы не изменяем state. Мы создаем копию с помощью Object.assign(). Object.assign(state, { visibilityFilter: action.filter }) тоже неверный вариант: в этом случае первый аргумент будет изменен. Вы должны передать первым аргументом пустой объект. Вы также можете подключить object spread operator proposal, чтобы вместо этого писать { ...state, ...newState } .

- Мы возвращаем предыдущую версию состояния (state) в default ветке. Очень важно возвращать предыдущую версию состояния (state) для любого неизвестного/необрабатываемого экшена (action).


### Обрабатываем больше экшенов
	
У нас есть еще два экшена, которые должны быть обработаны! Так же, как мы сделали с SET_VISIBILITY_FILTER мы имортируем ADD_TODO и TOGGLE_TODO экшены и затем допишем наш редьюсер для обработки ADD_TODO.
```jsx harmony
import {
  ADD_TODO,
  TOGGLE_TODO,
  SET_VISIBILITY_FILTER,
  VisibilityFilters
} from './actions'

...

function todoApp(state = initialState, action) {
  switch (action.type) {
    case SET_VISIBILITY_FILTER:
      return Object.assign({}, state, {
        visibilityFilter: action.filter
      })
    case ADD_TODO:
      return Object.assign({}, state, {
        todos: [
          ...state.todos,
          {
            text: action.text,
            completed: false
          }
        ]
      })
    default:
      return state
  }
}
```	
Как и раньше, мы никогда не изменяем непосредственно state или его поля. Вместо этого мы возвращаем новый объект. Новый todos равен старому todos, в конец которого добавлен новый элемент todo. Свежий tod был создан с использованием информации, полученной из action.

Ну и наконец, имплементация обработчика для экшена TOGGLE_TODO не должна стать для Вас большим сюрпризом:
```jsx harmony
case TOGGLE_TODO:
  return Object.assign({}, state, {
    todos: state.todos.map((todo, index) => {
      if (index === action.index) {
        return Object.assign({}, todo, {
          completed: !todo.completed
        })
      }
      return todo
    })
  })
```	
Поскольку мы хотим обновить конкретный элемент в массиве, не прибегая к мутациям, мы должны создать новый массив с теми же элементами, за исключением элемента по индексу. Если вы часто пишете такие операции, рекомендуется использовать хэлперы, такие как [immutability-helper] (https://github.com/kolodny/immutability-helper), [updeep] (https://github.com/essential/updeep) или даже такую библиотеку, как [Immutable] (http://facebook.github.io/immutable-js/), которая имеет встроенную поддержку для глубоких обновлений. Просто запомните, что нельзя присваивать ничего внутри state, пока вы его не склонировали.

### Разделение редьюсеров
	
Вот так выглядит наш код на данный момент. Выглядит излишне многословным:
```jsx harmony
function todoApp(state = initialState, action) {
  switch (action.type) {
    case SET_VISIBILITY_FILTER:
      return Object.assign({}, state, {
        visibilityFilter: action.filter
      })
    case ADD_TODO:
      return Object.assign({}, state, {
        todos: [
          ...state.todos,
          {
            text: action.text,
            completed: false
          }
        ]
      })
    case TOGGLE_TODO:
      return Object.assign({}, state, {
        todos: state.todos.map((todo, index) => {
          if (index === action.index) {
            return Object.assign({}, todo, {
              completed: !todo.completed
            })
          }
          return todo
        })
      })
    default:
      return state
  }
}
```	
Есть ли способ облегчить понимание? Кажется, что todos и visibilityFilter обновляются совершенно независимо. Иногда поля состояния (state fields) зависят от других полей и требуется большая связанность, но в нашем случаем мы безболезненно можем вынести обновление todos в отдельную функцию:
```jsx harmony
function todos(state = [], action) {
  switch (action.type) {
    case ADD_TODO:
      return [
        ...state,
        {
          text: action.text,
          completed: false
        }
      ]
    case TOGGLE_TODO:
      return state.map((todo, index) => {
        if (index === action.index) {
          return Object.assign({}, todo, {
            completed: !todo.completed
          })
        }
        return todo
      })
    default:
      return state
  }
}

function todoApp(state = initialState, action) {
  switch (action.type) {
    case SET_VISIBILITY_FILTER:
      return Object.assign({}, state, {
        visibilityFilter: action.filter
      })
    case ADD_TODO:
      return Object.assign({}, state, {
        todos: todos(state.todos, action)
      })
    case TOGGLE_TODO:
      return Object.assign({}, state, {
        todos: todos(state.todos, action)
      })
    default:
      return state
  }
}
```	
Обратите внимание, что функция todos также принимает state, но state — это массив! Теперь todoApp просто передает срез состояния в функцию todos, которая, свою очередь, точно знает, как обновить именно этот кусок состояния. Это называется композицией редьюсеров и является фундаментальным шаблоном построения Redux-приложений.

Давайте рассмотрим композицию редьюсеров подробнее. Можем ли мы извлечь редьюсер, который будет управлять только visibilityFilter? Конечно можем:

Ниже нашего импорта давайте использовать ES6 Object Destructuring, чтобы объявить SHOW_ALL:
```jsx harmony
const { SHOW_ALL } = VisibilityFilters
```	
Затем:
```jsx harmony
function visibilityFilter(state = SHOW_ALL, action) {
  switch (action.type) {
    case SET_VISIBILITY_FILTER:
      return action.filter
    default:
      return state
  }
}
```	
Теперь мы можем переписать наш главный редьюсер в виде функции, которая вызывает другие редьюсеры, обрабатывающие части состояния и собирает отдельно обработанные части состояния в один цельный объект. Также главному редьюсеру больше нет необходимости знать полное начальное состояние. Достаточно того, что каждый дочерний редьюсер возвращает свое начальное состояние, если при первом вызове получает undefined вместо state.
```jsx harmony
function todos(state = [], action) {
  switch (action.type) {
    case ADD_TODO:
      return [
        ...state,
        {
          text: action.text,
          completed: false
        }
      ]
    case TOGGLE_TODO:
      return state.map((todo, index) => {
        if (index === action.index) {
          return Object.assign({}, todo, {
            completed: !todo.completed
          })
        }
        return todo
      })
    default:
      return state
  }
}

function visibilityFilter(state = SHOW_ALL, action) {
  switch (action.type) {
    case SET_VISIBILITY_FILTER:
      return action.filter
    default:
      return state
  }
}

function todoApp(state = {}, action) {
  return {
    visibilityFilter: visibilityFilter(state.visibilityFilter, action),
    todos: todos(state.todos, action)
  }
}
```	
Обратите внимание на то, что каждый из этих дочерних редьюсеров управляет только какой-то одной частью глобального состояния. Параметр state разный для каждого отдельного дочернего редьюсера и соответствует той части глобального состояния, которой управляет этот дочерний редьюсер.

Уже выглядит лучше! Когда приложение разрастается, мы можем выносить редьюсеры в отдельные файлы и поддерживать их совершенно независимыми, что дает нам возможность управлять различными разделами наших данных.

Наконец, Redux предоставляет утилиту, называемую combineReducers(), которая реализует точно такой же логический шаблон, который мы только что реализовали в todoApp. С ее помощью мы можем переписать todoApp следующим образом:
```jsx harmony
import { combineReducers } from 'redux'

const todoApp = combineReducers({
  visibilityFilter,
  todos
})

export default todoApp
```	
Обратите внимание, что это полностью эквивалентно такому коду:
```jsx harmony
export default function todoApp(state = {}, action) {
  return {
    visibilityFilter: visibilityFilter(state.visibilityFilter, action),
    todos: todos(state.todos, action)
  }
}
```	
Вы также можете назначать им разные ключи или вызывать функции по-разному. Есть два совершенно равноценных способа писать комбинированные редьюсеры:
```jsx harmony
const reducer = combineReducers({
  a: doSomethingWithA,
  b: processB,
  c: c
})
```
```jsx harmony	
function reducer(state = {}, action) {
  return {
    a: doSomethingWithA(state.a, action),
    b: processB(state.b, action),
    c: c(state.c, action)
  }
}
```	
Все, что делает combineReducers() — это генерирует функцию, которая вызывает ваши редьюсеры c частью глобального состояния, которая выбирается в соответствии с их ключами, и затем снова собирает результаты всех вызовов в один объект. Тут нет никакой магии. И, как и другие редьюсеры, combineReducers() не создает новый объект, если все предоставленные ему редьюсеры не изменяют состояние.

Заметка для сообразительных пользователей синтаксиса ES6
Т.к. combineReducers ожидает на входе объект, мы можем поместить все редьюсеры верхнего уровня в разные файлы, экспортировать каждую функцию-редьюсер и использовать import * as reducers для получения их в формате объекта, ключами которого будут имена экспортируемых функций.
```jsx harmony
import { combineReducers } from 'redux'
import * as reducers from './reducers'

const todoApp = combineReducers(reducers)
```	
Поскольку import * — это все еще новый синтаксис, мы не используем его нигде в документации во избежание путаницы, но вы можете случайно наткнуться на него в каких-нибудь примерах кода из сообщества.

### Исходный код
	
**reducers.js**
```jsx harmony	
import { combineReducers } from 'redux'
import {
  ADD_TODO,
  TOGGLE_TODO,
  SET_VISIBILITY_FILTER,
  VisibilityFilters
} from './actions'
const { SHOW_ALL } = VisibilityFilters

function visibilityFilter(state = SHOW_ALL, action) {
  switch (action.type) {
    case SET_VISIBILITY_FILTER:
      return action.filter
    default:
      return state
  }
}

function todos(state = [], action) {
  switch (action.type) {
    case ADD_TODO:
      return [
        ...state,
        {
          text: action.text,
          completed: false
        }
      ]
    case TOGGLE_TODO:
      return state.map((todo, index) => {
        if (index === action.index) {
          return Object.assign({}, todo, {
            completed: !todo.completed
          })
        }
        return todo
      })
    default:
      return state
  }
}

const todoApp = combineReducers({
  visibilityFilter,
  todos
})

export default todoApp
```
    
  **[⬆ Наверх](#top)**
	
354. ### <a name="354"></a> middleware

 ### Mидлвар (Middleware)
	
Вы видели мидлвары в действии в примере асинхронных экшенов. Если вы когда-либо использовали такие серверные библиотеки, как Express и Koa, то, вероятно, вы уже хорошо знакомы с концепцией мидлвар. В этих фреймворках мидлвары — это части кода, которые вы можете поместить между фреймворком, принимающим запрос и фреймворком, генерирующим ответ. Например, мидлвары из Express или Koa могут добавлять CORS-заголовки, логирование, сжатие и т.д. Лучшая особенность мидлваров заключается в том, что их можно соединять в цепочки/последовательности. Вы можете использовать множество независимых сторонних мидлваров в одном проекте.

Redux-мидлвары, в отличие от мидлваров Express или Koa, решают немного другие проблемы, но концептуально схожим способом. Они предоставляют стороннюю точку расширения, между отправкой экшена и моментом, когда этот экшен достигает редьюсера. Люди используют Redux-мидлвары для логирования, сообщения об ошибках, общения с асинхронным API, роутинга и т.д.

Эта статья разделена на углубленное введение, которое поможет вам хорошо разобраться в концепции, и пару практических примеров в самом конце, которые покажут вам всю силу мидлваров. Вам может показаться полезным периодическое переключение между этими частями, так же, как между скукой и вдохновением.

Понимание мидлваров
Т.к. мидлвары могут использоваться для различных задач, в том числе и для асинхронных обращений к API, то очень важно, чтобы вы понимали, откуда они пришли. Мы покажем вам ход мыслей, шаг за шагом ведущий к мидлварам, используя логирование и сообщения об ошибках в качестве примера.

Проблема: логирование
Одно из достоинств Redux — он делает изменения состояния приложения предсказуемыми и прозрачными. Каждый раз, когда посылается экшен, новое состояние вычисляется и сохраняется. Состояние не может измениться самостоятельно, оно может меняться только, как последовательность определенных экшенов.

Разве не было бы хорошо, если бы мы записывали каждое действие, которое происходило в приложении, вместе с состоянием, которое было вычислено после этого действия? Когда что-то идет не так, мы можем просмотреть наш лог и понять, какой именно экшен испортил наше состояние.
	
<img width="556" alt="687474703a2f2f692e696d6775722e636f6d2f426a47426c45532e706e67" src="https://user-images.githubusercontent.com/80325645/129259099-f288d0bb-cd34-44a4-a6ec-86414b08df47.png">

*Попытка #1*: Логируем вручную
Простейшее решение - самостоятельно записывать экшен и состояние каждый раз, когда вы вызываете store.dispatch(action). На самом деле это не слишком хорошее решение, это просто первый шаг на пути к пониманию проблемы.

Обратите внимание
Если вы используете react-redux или похожий биндинг, у вас, скорее всего, не будет прямого доступа к экземпляру стора в ваших компонентах. Для следующих нескольких параграфов представьте, что вы передаете состояние явно.

Например, вы вызываете такой код, когда создаете todo-элемент:
```jsx harmony
store.dispatch(addTodo('Use Redux'))
```	
Для того чтобы логировать экшен и состояние, вы можете изменить код примерно так:
```jsx harmony
let action = addTodo('Use Redux')

console.log('dispatching', action)
store.dispatch(action)
console.log('next state', store.getState())
```	
Это даст желаемый эффект, но вы бы не хотели делать так каждый раз.

*Попытка #2*: Оборачиваем Dispatch
Вы можете вынести логирование в функцию:
```jsx harmony
function dispatchAndLog(store, action) {
  console.log('dispatching', action)
  store.dispatch(action)
  console.log('next state', store.getState())
}
```	
Вы можете использовать ее везде вместо обычного store.dispatch():
```jsx harmony
dispatchAndLog(store, addTodo('Use Redux'))
```	
Мы бы могли закончить на этом, но не очень удобно импортировать специальную функцию каждый раз.

*Попытка #3*: Monkeypatching для Dispatch
	
Что, если мы просто заменим функцию dispatch в экземпляре стора? Redux стор — это простой объект с парой методов, а мы пишем на JavaScript, следовательно, мы можем применить технику monkeypatch для реализации dispatch:
```jsx harmony
const next = store.dispatch
store.dispatch = function dispatchAndLog(action) {
  console.log('dispatching', action)
  let result = next(action)
  console.log('next state', store.getState())
  return result
}
```	
Это уже ближе к тому, что нам нужно! Не важно, откуда мы посылаем экшен, он гарантированно будет залогирован. Monkeypatching никогда не покажется правильным ходом, но пока мы можем с этим жить.

### Проблема: Сообщения об ошибках.
	
Что, если мы захотим применить больше одного такого преобразования к dispatch?

Другое такое изменение, которое приходит мне в голову, это сообщения о JavaScript-ошибках в продакшене. Глобальное событие window.onerror не надежно потому, что оно в некоторых старых браузерах не предоставляет информацию о стеке вызовов, которая важна для понимания того, почему же произошла ошибка.

Разве не было бы полезно, если бы каждый раз, когда ошибка выбрасывалась, как результат отправки какого-либо экшена, мы могли бы отправить ее (ошибку), вместе со стеком вызовов, экшеном, который вызвал ошибку и актуальным состоянием в сервис сообщения об ошибках, такой как Sentry. В таком случае гораздо легче воспроизвести ошибку в разработке.

Однако важно, чтобы мы держали логирование и сообщения об ошибках раздельно. В идеальном случае, мы хотим получить их, как разные модули из разных пакетов. В противном случае, мы не сможем иметь экосистему из такого рода утилит. (Подсказка: мы медленно подходим к тому, что такое мидлвары!)

Если логирование и сообщения об ошибках являются отдельными утилитами, то они могут выглядеть так:
```jsx harmony
function patchStoreToAddLogging(store) {
  const next = store.dispatch
  store.dispatch = function dispatchAndLog(action) {
    console.log('dispatching', action)
    let result = next(action)
    console.log('next state', store.getState())
    return result
  }
}

function patchStoreToAddCrashReporting(store) {
  const next = store.dispatch
  store.dispatch = function dispatchAndReportErrors(action) {
    try {
      return next(action)
    } catch (err) {
      console.error('Caught an exception!', err)
      Raven.captureException(err, {
        extra: {
          action,
          state: store.getState()
        }
      })
      throw err
    }
  }
}
```	
Если эти функции опубликованы, как отдельные модули, то позже мы можем использовать их для изменения нашего стора:
```jsx harmony
patchStoreToAddLogging(store)
patchStoreToAddCrashReporting(store)
```	
Но это все еще не очень хорошо.

*Попытка #4*: Прячем Monkeypatching
	
Monkeypatching — это хак. "Замените любой метод, который хотите" — что это за вид API? Давайте разберемся в его сути. Ранее наши функции заменяли store.dispatch. Что если бы они вместо этого возвращали новую функцию dispatch?
```jsx harmony
function logger(store) {
  let next = store.dispatch

  // ранее было так:
  // store.dispatch = function dispatchAndLog(action) {

  return function dispatchAndLog(action) {
    console.log('dispatching', action)
    let result = next(action)
    console.log('next state', store.getState())
    return result
  }
}
```	
Мы могли бы предоставить функцию-помощник внутри Redux, которая могла бы применять актуальный monkeypatching, как часть имплементации:
```jsx harmony
function applyMiddlewareByMonkeypatching(store, middlewares) {
  middlewares = middlewares.slice()
  middlewares.reverse()

  // Изменяем функцию dispatch каждым мидлваром.
  middlewares.forEach(middleware =>
    store.dispatch = middleware(store)
  )
}
```	
Мы можем использовать такой подход для применения нескольких мидлваров:
```jsx harmony
applyMiddlewareByMonkeypatching(store, [ logger, crashReporter ])
```	
Тем не менее - это все еще monkeypatching. Факт того, что мы прячем его внутри библиотеки, не отменяет использования monkeypatching.

*Попытка #5*: Убираем Monkeypatching
	
Зачем мы перезаписываем dispatch? Конечно же для того, чтобы иметь возможность потом его вызвать. Но есть еще и другая причина: каждый мидлвар имеет доступ (и возможность вызвать) ранее обернутый store.dispatch:
```jsx harmony
function logger(store) {
  // Обязательно нужно закешировать функцию, которую вернул предыдущий мидлвар:
  let next = store.dispatch

  return function dispatchAndLog(action) {
    console.log('dispatching', action)
    let result = next(action)
    console.log('next state', store.getState())
    return result
  }
}
```	
Это важно для возможности объединять мидлвары в цепочки!

Если applyMiddlewareByMonkeypatching не сохранит store.dispatch сразу после обработки первого мидлвара, store.dispatch будет продолжать ссылаться на оригинальную функцию dispatch. Следовательно второй мидлвар тоже будет связан с оригинальной функцией dispatch.

Но есть еще другой метод реализации объединения мидлваров в цепочки (chaining). Мидлвар мог бы принимать функцию отправки экшена next() в параметрах вместо того, чтобы читать ее из экземпляра стора.
```jsx harmony
function logger(store) {
  return function wrapDispatchToAddLogging(next) {
    return function dispatchAndLog(action) {
      console.log('dispatching', action)
      let result = next(action)
      console.log('next state', store.getState())
      return result
    }
  }
}
```	
Это тот момент, когда “we need to go deeper”, так что имеет смысл потратить некоторе время на это. Каскад функций выглядит пугающим. Стрелочные функции из ES6 делают это каррирование чуть более простым для глаз:
```jsx harmony
const logger = store => next => action => {
  console.log('dispatching', action)
  let result = next(action)
  console.log('next state', store.getState())
  return result
}

const crashReporter = store => next => action => {
  try {
    return next(action)
  } catch (err) {
    console.error('Caught an exception!', err)
    Raven.captureException(err, {
      extra: {
        action,
        state: store.getState()
      }
    })
    throw err
  }
}
```	
Именно так выглядят мидлвары в Redux.

Теперь мидлвар принимает функцию отправки экшена next() и возвращает другую функцию отправки экшена, которая, в свою очередь, является функцией отправки экшена next() для мидлвара слева. Все еще полезно иметь доступ к некоторым методам стора, например к getState(), следовательно, store остается доступен, как аргумент самого верхнего уровня.

*Попытка #6*: Простейшее применение мидлваров
Вместо applyMiddlewareByMonkeypatching() мы могли бы написать функцию applyMiddleware(), которая сначала получает финальную, полностью обернутую функцию dispatch() и возвращает копию стора, которая использует эту функцию:
```jsx harmony
// Осторожно: Простейшая имплементация!
// Это *не* Redux API.
function applyMiddleware(store, middlewares) {
  middlewares = middlewares.slice()
  middlewares.reverse()
  let dispatch = store.dispatch
  middlewares.forEach(middleware => (dispatch = middleware(store)(dispatch)))
  return Object.assign({}, store, { dispatch })
}
```	
Реализация applyMiddleware(), которая поставляется с Redux, похожа на эту, но отличается тремя важными аспектами:

Она предоставляет мидлвару только подмножество API стора: методы dispatch(action) и getState().

Она использует некоторые хитрости для того, чтобы убедиться, что, экшен снова пройдет через всю цепочку мидлваров, включая текущий, если вы вызываете store.dispatch(action) из вашего мидлвара вместо next(action). Это полезно для асинхронных мидлваров, как мы ранее видели.

Для того чтобы гарантировать, что вы можете применить мидлвар только один раз, она работает с createStore(), а не с самим store. Вместо (store, middlewares) => store, ее сигнатурой является (...middlewares) => (createStore) => createStore.

Предостережение: отправка во время установки
Пока applyMiddleware выполняет и настраивает ваши мидлвари, функция store.dispatch будет указывать на оригинальную версию, предоставляемую createStore. Отправка приведет к тому, что никакой другой мидлвар не будет применен. Если вы ожидаете взаимодействия с другим мидлваром во время настройки, вы, вероятно, будете разочарованы. Из-за этого неожиданного поведения applyMiddleware выдаст ошибку, если вы попытаетесь отправить экшен до завершения установки. Вместо этого вам следует, либо напрямую связываться с этим другим мидлваром через общий объект (для мидлвара, вызывающего API, это может быть ваш клиентский объект API), либо ждать, пока мидлвар не будет создан с колбэком.

Финальный подход
Дан мидлвар который мы только что написали:
```jsx harmony
const logger = store => next => action => {
  console.log('dispatching', action)
  let result = next(action)
  console.log('next state', store.getState())
  return result
}

const crashReporter = store => next => action => {
  try {
    return next(action)
  } catch (err) {
    console.error('Caught an exception!', err)
    Raven.captureException(err, {
      extra: {
        action,
        state: store.getState()
      }
    })
    throw err
  }
}
```	
Вот так можно его применить к Redux стору:
```jsx harmony
import { createStore, combineReducers, applyMiddleware } from 'redux'

const todoApp = combineReducers(reducers)
const store = createStore(
  todoApp,
  // applyMiddleware() tells createStore() how to handle middleware
  applyMiddleware(logger, crashReporter)
)
```	
Вот и все! Теперь любые экшены, отправленные в экземпляр стора, будут проходить через logger и crashReporter:
```jsx harmony
// будет проходить через `logger` и `crashReporter`!
store.dispatch(addTodo('Use Redux'))
```
	
*Семь примеров*
	
Если ваша голова вскипела от прочтения предыдущего раздела, представьте, каково было написать это. Этот раздел предназначен для расслабления меня и вас и поможет запустить ваши шестеренки.

Каждая из функций, приведенных ниже, является валидным Redux-мидлваром. Они не являются в равной степени полезными, но, по крайней мере, они в равной степени забавны.
```jsx harmony
/**
 * Логирует все экшены и состояния после того, как они будут отправлены.
 */
const logger = store => next => action => {
  console.group(action.type)
  console.info('dispatching', action)
  let result = next(action)
  console.log('next state', store.getState())
  console.groupEnd(action.type)
  return result
}

/**
 * Отправляет отчеты об ошибках когда обновляется состояние и уведомляются слушатели.
 */
const crashReporter = store => next => action => {
  try {
    return next(action)
  } catch (err) {
    console.error('Caught an exception!', err)
    Raven.captureException(err, {
      extra: {
        action,
        state: store.getState()
      }
    })
    throw err
  }
}

/**
 * Планирует экшены с { meta: { delay: N } }, которые будут отложены на N миллисекунд.
 * Создает `dispatch`, возвращающий функцию, для отмены таймаута.
 */
const timeoutScheduler = store => next => action => {
  if (!action.meta || !action.meta.delay) {
    return next(action)
  }

  let timeoutId = setTimeout(
    () => next(action),
    action.meta.delay
  )

  return function cancel() {
    clearTimeout(timeoutId)
  }
}

/**
 * Планирует экшены с { meta: { raf: true } }, которые будут отправлены внутри 
 * фрейма rAF цикла. Создает  `dispatch`, который возвращает функцию для удаления 
 * экшена из очереди.
 */
const rafScheduler = store => next => {
  const queuedActions = []
  let frame = null

  function loop() {
    frame = null
    try {
      if (queuedActions.length) {
        next(queuedActions.shift())
      }
    } finally {
      maybeRaf()
    }
  }

  function maybeRaf() {
    if (queuedActions.length && !frame) {
      frame = requestAnimationFrame(loop)
    }
  }

  return action => {
    if (!action.meta || !action.meta.raf) {
      return next(action)
    }

    queuedActions.push(action)
    maybeRaf()

    return function cancel() {
      queuedActions = queuedActions.filter(a => a !== action)
    }
  }
}

/**
 * Позволяет вам отправлять промисы в дополнение к экшенам.
 * Если промис зарезолвен, его результат будет отправлен как экшен.
 * Промис возвращается из `dispatch`, т.о. вызывающая функция может 
 * обрабатывать отказ (rejection) промиса.
 */
const vanillaPromise = store => next => action => {
  if (typeof action.then !== 'function') {
    return next(action)
  }

  return Promise.resolve(action).then(store.dispatch)
}

/**
 * Позволяет вам отправлять специальные экшены с полем { promise }.
 * Этот мидлвар превратит их в единственный экшен в начале,
 * и в единственный успешный (или неудачный) экшен, когда `promise` будет зарезолвен.
 *
 * Для удобства `dispatch` будет возвращать промис, т.е. вызывающая функция 
 * может ожидать разрешения этого промиса.
 */
const readyStatePromise = store => next => action => {
  if (!action.promise) {
    return next(action)
  }

  function makeAction(ready, data) {
    const newAction = Object.assign({}, action, { ready }, data)
    delete newAction.promise
    return newAction
  }

  next(makeAction(false))
  return action.promise.then(
    result => next(makeAction(true, { result })),
    error => next(makeAction(true, { error }))
  )
}

/**
 * Позволяет вам отправлять функцию вместо экшена.
 * Функция будет принимать `dispatch` и `getState` в качестве аргументов.
 *
 * Полезно для раннего выхода (условия над `getState()`), а также для 
 * асинхронного потока управления (может `dispatch()` что-то другое)
 * 
 * `dispatch` будет возвращать значение отправляемой функции.
 */
const thunk = store => next => action =>
  typeof action === 'function' ?
    action(store.dispatch, store.getState) :
    next(action)

// Вы можете использовать их все! (Это не значит, что вы должны.)
const todoApp = combineReducers(reducers)
const store = createStore(
  todoApp,
  applyMiddleware(
    rafScheduler,
    timeoutScheduler,
    thunk,
    vanillaPromise,
    readyStatePromise,
    logger,
    crashReporter
  )
)	
```
    
  **[⬆ Наверх](#top)**
	
355. ### <a name="355"></a> Redux, Actions, Reducer, Store - примеры

 `Пример`	
	
```jsx
const ON_CLICK = 'ON_CLICK'

const increaseCounter = () => ({
	type: ON_CLICK
})

const reducer = (state = 0, action) => {
	if (action.type === ON_CLICK) {
		return state++;
	}

	return state;
}

const Status = () => {
	const count = useSelector((state) => state);

	return (<span>{count}</span>)
}

const Changer = () => {
	const dispatch = useDispatch();

	const onClick = () => dispatch(increaseCounter());

	return (<button onClick={onClick}>Change</button>)
}

class ClassComponentWithStore extends Component {
	constructor(props) {
		super(props);
	}


	render() {
		const { onClick, count } = this.props

		return (
			<div>
				<span>{count}</span>
				<button onClick={onClick}>Change</button>
			</div>
		)
	}
}

const ClassComponent = connect(
	(state) => ({
		count: state
	}),
	(dispatch) => ({
		onClick: () => dispatch(increaseCounter)
	})
)(ClassComponentWithStore)

const store = createStore(reducer)

const App = () => {
	return (
		<Provider store={store}>
			<Status />
			<Changer />
			<ClassComponent />
		</Provider>
	)
}


ReactDOM.render(<App />, document.getElementById('root'))	
```	

### Назовите ключевые концепции Redux***

<p align="center">
  <img src="../assets/img-v2/redux-components.jpg" alt="Redux Components" width="400px" />
</p>

**1. Операция (action)**

Операция - это статическая информация о событии, инициализирующем изменение состояния. Обновление состояния в Redux всегда начинается с операции. Операции - это объекты, содержащие обязательное свойство `type` и опциональное свойство `payload`. Операции вызываются с помощью метода `store.dispatch()`. Операция создается с помощью "создателя операций" (`action creator`).

**Создатели операций** - функции, помогающие создавать операции. Создатель операции возвращает объект операции, который передается редуктору.

*Пример*

```js
const setLoginStatus = (name, password) => {
  return {
    type: "LOGIN",
    payload: {
      username: "foo",
      password: "bar"
    }
  }
}
```

**2. Редуктор (reducer)**

Редукторы - это "чистые" функции, принимающие текущее состояние приложения, выполняющие над ним операцию и возвращающие новое состояние. Новое состояние - объект, описывающий изменения состояния, произошедшие в ответ на вызванную операцию.

Это похоже на функцию `reduce()` в JavaScript, когда значение вычисляется на основе нескольких значений после выполнения коллбека.

```js
const LoginComponent = (state = initialState, action) => {
    switch (action.type) {

      // данный редуктор обрабатывает операции с типом "LOGIN"
      case "LOGIN":
          return state.map(user => {
              if (user.username !== action.username) {
                  return user
              }

              if (user.password == action.password) {
                  return {
                      ...user,
                      login_status: "LOGGED IN"
                  }
              }
          });
      default:
          return state;
      }
}
```

**Комбинация нескольких редукторов**: вспомогательная функция `combineReducers()` преобразует объект с несколькими редукторами в один редуктор для передачи в `createStore()`.

*Синтаксис*

```js
const rootReducert = combineReducer(reducer1, reducer2)
```

**3. Состояние (state)**

Состояние - это объект, содержащий состояние приложения. При обновлении состояния, обновляются все подписанные на него компоненты. Хранилище отвечает за запись, чтение и обновление состояния.

*Пример*

```js
import React from 'react'
import { render } from 'react-dom'
import { Provider } from 'react-redux'
import { createStore } from 'redux'
import rootReducer from './reducers'
import App from './components/App'

const store = createStore(rootReducer)
 render (
   <provider store="{store}">
     <app>
   </app></provider>,
   document.getElementById('root')
 )
```

При использовании Redux с React состояние не требует подъема. Это также облегчает идентификацию операции, которая вызвала изменение состояния.

**4. Отправка (dispatch)**

Отправка - это передача операции с типом и полезной нагрузкой редуктору.

```js
store.dispatch()
```

**5. Подписка (subscribe)**

Подписка - это метод, испольуземый для подписки на данные/состояние хранилища.

```js
store.subscribe()
```

**6. Провайдер (provider)**

Провайдер - это компонент, содержащий ссылку на хранилище и передающий данные из хранилища дочерним компонентам.

**7. Подключение (connect)**

Подключение - это функция, взаимодействующая с провайдером.

**8. Промежуточное программное обеспечение, промежуточный слой, посредник (middleware)**

Посредник - это способ расширения Redux дополнительным функционалом. Посредники используются для отправки асинхронных операций. Они настраиваются в момент создания хранилища.

*Синтаксис*

```js
const store = createStore(reducers, initialState, middleware);
```	
	
	
### Объясните назначение редуктора?

Редуктор - это функция, определяющая изменения состояния приложения. Она использует операции для определения характера изменений. Redux управляет состоянием приложения с помощью единственного хранилища, так что они действуют согласованно. Redux во многом зависит от редукторов, которые принимают предыдущее состояние и операцию для производства нового состояния.

**1. Состояние**

Изменение состояния зависит от действий пользователя или сетевых запросов. Если состояние приложения управляется Redux, изменения происходят в редукторе - это единственное место, в котором происходит изменение состояния. Редуктор использует текущее состояние приложение и операцию для определения нового состояния.

*Синтаксис*

```js
const contactReducer = (state = initialState, action) => {
  // ...
}
```

**2. Параметр `state`**

Параметр `state`, передаваемый в редуктор, должен быть текущим состоянием приложения. В данном случае, мы передаем редуктору `initialState`, т.е. начальное состояние, которому ничего не предшествовало.

```js
contactReducer(initialState, action)
```

*Пример*

Предположим, что начальным состоянием нашего приложения является пустой массив для списка контактов, а операцией - добавление нового контакта в этот список.

```js
const initialState = {
  contacts: []
}
```

**3. Параметр `action`**

`action` - это объект, содержащий две пары ключ/значение. Обновление состояния, происходящее в редукторе, зависит от значения свойства `action.type`.

```js
const action = {
  type: 'NEW_CONTACT',
  payload: {
    name: 'Иван Петров',
    location: 'Москва',
    email: 'mail@example.com'
  }
}
```

Обычно, также имеется свойство `payload`, содержащее данные, отправленные пользователем, используемые для обновления состояния. Следует отметить, что `action.type` является обязательным, а `action.payload` опциональным.

**4. Обновление состояния**

Состояние должно быть иммутабельным. Это означает, что его нельзя изменять напрямую. Для обновления состояния можно использовать `Object.assign()` или *spread-оператор*.

*Пример*

```js
const contactReducer = (state, action) => {
  switch (action.type) {
    case 'NEW_CONTACT':
    return {
        ...state, contacts:
        [...state.contacts, action.payload]
    }
    default:
      return state
  }
}
```

Это позволяет обеспечить сохранность текущего состояния при добавлении нового элемента.

```js
const initialState = {
  contacts: [{
    name: 'Иван Петров',
    age: 30
  }]
}

const contactReducer = (state = initialState, action) => {
  switch (action.type) {
    case "NEW_CONTACT":
      return Object.assign({}, state, {
        contacts: [...state.contacts, action.payload]
      });
    default:
      return state
  }
}

class App extends React.Component {
  constructor(props) {
    super(props)
    this.name = React.createRef()
    this.age = React.createRef()
    this.state = initialState
  }

  handleSubmit = e => {
    e.preventDefault()
    const action = {
      type: "NEW_CONTACT",
      payload: {
        name: this.name.current.value,
        age: this.age.current.value
      }
    }
    const newState = contactReducer(this.state, action)
    this.setState(newState)
  }

  render() {
    const { contacts } = this.state
    return (
      <div className="box">
        <div className="content">
          <pre>{JSON.stringify(this.state, null, 2)}</pre>
        </div>

        <div className="field">
          <form onSubmit={this.handleSubmit}>
            <div className="control">
              <input className="input" placeholder="Имя" type="text" ref={this.name} />
            </div>
            <div className="control">
              <input className="input" placeholder="Возраст" type="number" ref={this.age} />
            </div>
            <div>
              <button type="submit" className="button">Отправить</button>
            </div>
          </form>
        </div>
      </div>
    )
  }
}

ReactDOM.render(
  <App />,
  document.getElementById('root')
)
```	

### Как реализовать "создателя операции" (action creator)?

**Тип операции**

*Action type* - это строка, описывающая тип операции. Обычно, типы определяются в виде констант или перечислений (enumerations).

*Пример*

```js
export const Actions = {
  GET_USER_DETAILS_REQUEST: 'GET_USER_DETAILS_REQUEST',
  GET_USER_DETAILS_SUCCESS: 'GET_USER_DETAILS_SUCCESS',
  GET_USER_DETAILS_FAILURE: 'GET_USER_DETAILS_FAILURE',
  ...
}
```

**Операция**

Операция похожа на сообщение, отправляемое (dispatch) в хранилище. Теоретически, она может выглядеть как угодно. Однако, лучше придерживаться следующего соглашения (определение типа с помощью TypeScript):

```ts
type Action = {
  type: string;    // операция ДОЛЖНА иметь тип
  payload?: any;   // операция МОЖЕТ иметь полезную нагрузку
  meta?: any;      // операция МОЖЕТ иметь мета (дополнительную) информацию
  error?: boolean; // операция МОЖЕТ иметь поле для ошибки
                    // при истинном значении данного поля, полезная нагрузка ДОЛЖНА включать Error
}
```

Операция получения пользователя по имени "Иван" может выглядеть так:

```js
{
    type: 'GET_USER_DETAILS_REQUEST',
    payload: 'Иван'
}
```

**Создатель операции**

```js
export const getUserDetailsRequest = id => ({
  type: Actions.GET_USER_DETAILS_REQUEST,
  payload: id,
})
```

В простых случаях создатель операции возвращает операцию. После этого она отправляется в хранилище:

```js
store.dispatch(getUserDetailsRequest('Иван'))
```

На практике это, как правило, реализуется через свойство `dispatch()`, передаваемое в React-компонент:

```js
export const mapDispatchToProps = dispatch => ({
  onClick: () => dispatch(getUserDetailsRequest('Alex'))
})
```	

### Как установить начальное состояние?

**1. Инициализация состояния**

В Redux состояние всего приложения находится в хранилище, которое является древовидным объектом. Единственным способом изменить состояние является отправка операции.

Операции - это объекты, содержащие свойства "тип" и "полезная нагрузка". Они создаются и отправляются специальными функциями, которые называются "создателями операций".

*Пример*

Создаем хранилище:

```js
import { createStore } from 'redux'

function todosReducer(state = [], action) {
  switch (action.type) {
    case 'ADD_TODO':
      return state.concat([action.payload])
    default:
      return state
  }
}

const store = createStore(todosReducer)
```

Обновляем состояние:

```js
const ADD_TODO = 'ADD_TODO'; // создаем тип операции
const newTodo = ["Написать статью"];
function todoActionCreator (newTodo) {
  const action = {
    type: ADD_TODO,
    payload: newTodo
  }
  dispatch(action)
}
```

После создания хранилища, Redux отправляет операцию в редуктор для записи в хранилище начального состояния.

**2. `createStore()`**

Метод `createStore()` может принимать опциональное значение `preloadedState` в качестве второго аргумента. В нашем примере мы не используем данный параметр. Когда такое значение передается, оно становится начальным состоянием.

```js
const initialState = ["питаться", "кодить", "спать"];
const store = createStore(todosReducer, initialState)
```

**3. Редуктор**

Редукторы также могут определять начальное состояние в случае, когда значением передаваемого им аргумента `state` является `undefined`:

```js
function todosReducer(state = [], action) {
  switch (action.type) {
    case 'ADD_TODO':
      return state.concat([action.payload])
    default:
      return state
  }
}
/**
* начальное состояние равняется []. Будет использовано только при неопределенном значении начального состояния,
* т.е. когда оно не было передано в `createStore()`
**/
```

Как правило, `preloadedState` имеет более высокий приоритет, чем состояние, определенное в `reducer`. Это позволяет редукторам определять данные в качестве аргументов по умолчанию, а также загружать существующие данные (полностью или частично) при гидратации хранилища из некоторого постоянного хранилища или сервера.	

	
### Что такое `mapStateToProps()` и `mapDispatchToProps()`?

Библиотека `react-redux` предоставляет 3 функции: `connect()`, `mapStapteToProps()` и `mapDispatchToProps()`. `connect()` - это функция высшего порядка, принимающая `mapStateToProps()` и `mapDispatchToProps()` в качестве параметров.

**1. `mapStateToProps()`**

Функция `mapStatetoProps()` извлекает состояние определенного редуктора из глобального хранилища и сопоставляет его с пропами компонента. Данная функция вызывается при каждом обновлении хранилища.

**2. `mapDispatchToProps()`**

Функция `mapDispatchToProp()` принимает функции отправки в компоненте и выполняет их в соответствующих редукторах. Данная функция позволяет отправлять изменения состояния в хранилище.

Говоря проще,

**mapStateToProps**: подключает состояние Redux к пропам React-компонента
**mapDispatchToProps**: подключает операции Redux к пропам React-компонента

*Пример*

```js
const { createStore } = Redux
const { connect, Provider } = ReactRedux
const initialState = { collection: ["prima", "altera", "triera"] }

function reducer(state = initialState, action) {
    if (action.type === "REVERSE") {
      return Object.assign({}, state, {
         Collection: state.collection.slice().reverse()
      })
    }
    return state
}

const store = createStore(reducer)

function mapStateToProps(state) {
  return state
}

const PresentationalComponent = React.createClass({
    render: function() {
        return (
          <div>
            <h2>Состояние хранилища (в виде пропа)</h2>
            <pre> {JSON.stringify(this.props.collection)}</pre>
            <StateChangerUI />
          </div>
          )
    }
})

// изменение состояния UI
const StateChangerUI = React.createClass({
  // отправка операции
  handleClick: function() {
     store.dispatch({
         type: 'REVERSE'
      })
  },
  render: function() {
    return (
      <button type="button" className="btn btn-success" onClick={this.handleClick}>Инвертировать</button>
    )
  }
})

PresentationalComponent = connect(mapStateToProps)(PresentationalComponent)

ReactDOM.render(
  <Provider store={store}>
    <PresentationalComponent />
  </Provider>,
  document.getElementById('App')
)
```		

### Что такое "чистые" функции и почему редуктор должен быть такой функцией?

**"Чистая" функция**

Функция, которая не изменяет входные данные и не зависит от внешних данных (например, базы данных, DOM или глобальных переменных) и возвращает одинаковый результат для одних и тех же аргументов, является "чистой".

Таким образом, функция является "чистой", если она удовлетворяет следующим условиям:

* Возвращает одинаковый результат для одних и тех же аргументов
* Оценивается без побочных эффектов, т.е. не изменяет входные данные
* Не изменяет локальные или глобальные переменные
* Не зависит от внешних данных

*Пример*

Приведенная ниже функция `add()` не изменяет параметры `a` и `b`, не зависит от внешних данных, и всегда возвращает одинаковый результат для одних и тех же аргументов:

```js
const add = (a, b) => a + b // "чистая" функция
```

**Почему редуктор должен быть "чистой" функцией?**

Redux берет текущее состояние (объект) и передает его каждому редуктору в цепочке (при комбинации редукторов). Редуктор должен вернуть новый объект в случае изменения состояния. При отсутствии изменений редуктор должен вернуть старый объект.

Redux проверяет, отличаются ли старый и новый объекты, сравнивая их места в памяти. Поэтому, если мы изменим старый объект в редукторе, старое и новое состояния будут ссылаться на один и тот же объект. Redux сделает вывод о том, что ничего не изменилось, и логика приложения будет нарушена.
    
  **[⬆ Наверх](#top)**
	
356. ### <a name="356"></a> redux-forms в экосистеме React + Redux

*Redux Form* работает с React и Redux, позволяя формам в React хранить состояние в Redux. Redux Form может использоваться с обычными HTML5-инпутами, а также с популярными UI-фреймворками, такими как Material UI, React Widgets и React Bootstrap.
	
Вот некоторые из основных особенностей Redux Form:

1. Значения полей записываются в хранилище Redux
2. Синхронная/асинхронная валидация полей и отправка формы
3. Форматирование, разбор и нормализация значений полей
    
  **[⬆ Наверх](#top)**
	
357. ### <a name="357"></a> Redux пример

### Пример простого кода	  
```jsx harmony
import React from 'react';
import ReactDOM from 'react-dom';
import { createStore } from 'redux';

const initialState = {value: 0};

const reducer = (state = initialState, action) => {
    switch (action.type) {
        case "INC":
            return {
                ...state,
                value: state.value + 1
            };
        case "DEC":
            return {
                ...state,
                value: state.value - 1
            };
        case "RND":
            return {
                ...state,
                value: state.value * action.payload
            };
        default:
            return state;
    }
}

const store = createStore(reducer);

const update = () => {
    document.getElementById('counter').textContent = store.getState().value;
}

store.subscribe(update);

const inc = () => ({type: 'INC'});
const dec = () => ({type: 'DEC'});
const rnd = (value) => ({type: 'RND', payload: value});

document.getElementById('inc').addEventListener('click', () => {
    store.dispatch(inc());
});

document.getElementById('dec').addEventListener('click', () => {
    store.dispatch(dec());
});

document.getElementById('rnd').addEventListener('click', () => {
    const value = Math.floor(Math.random() * 10);
    store.dispatch(rnd(value));
});

ReactDOM.render(
  <React.StrictMode>
    <>
    
    </>
  </React.StrictMode>,
  document.getElementById('root')
);	  
```	  

### Пример 

### index.js	  
```jsx harmony
import React from 'react';
import ReactDOM from 'react-dom';
import {createStore} from 'redux';
import reducer from './reducer';
import {Provider} from 'react-redux';

import App from './components/App';

const store = createStore(reducer);

ReactDOM.render(
  <React.StrictMode>
    <Provider store={store}>
      <App />
    </Provider>
  </React.StrictMode>,
  document.getElementById('root')
);	  
```	  

### reducer.js
```jsx harmony
const initialState = {counter: 0};

const reducer = (state = initialState, action) => {
	switch (action.type) {
		case 'INC':
			return {
				...state,
				counter: state.counter + 1
			};
		case 'DEC':
			return {
				...state,
				counter: state.counter - 1
			};
		case 'RND':
			return {
				...state,
				counter: state.counter * action.payload
			};
		default:
			return state;
	}
}

export default reducer;	  
```	  

### actions.js
```jsx harmony
export const inc = () => ({type: 'INC'})
export const dec = () => ({type: 'DEC'})
export const rnd = () => ({type: 'RND', payload: Math.floor(Math.random() * 10)})	  
```	  

### App.js
```jsx harmony
import Counter from './Counter';

const App = () => {
	return <Counter />
}

export default App;	  
```	  

### Counter.js
```jsx harmony
import {inc, dec, rnd} from '../actions';
import {useSelector, useDispatch} from 'react-redux';

const Counter = () => {

	const counter = useSelector(state => state.counter);

	const dispatch = useDispatch();

	return (
		<div className="jumbotron">
			<h1>{counter}</h1>
			<button onClick={() => dispatch(dec())} className="btn btn-primary">DEC</button>
			<button onClick={() => dispatch(inc())} className="btn btn-primary">INC</button>
			<button onClick={() => dispatch(rnd())} className="btn btn-primary">RND</button>
		</div>
	)
}

export default Counter;	  
```	  
	  
  **[⬆ Наверх](#top)**
	
358. ### <a name="358"></a> Соединяем React и Redux при помощи connect и хуков

### При помощи connect	  
```jsx harmony
import { Component } from "react";
import { connect } from "react-redux";
import * as actions from '../actions';

// const Counter = ({counter, inc, dec, rnd}) => {
//     return (
//         <div className="jumbotron">
//             <h1>{counter}</h1>
//             <button onClick={dec} className="btn btn-primary">DEC</button>
//             <button onClick={inc} className="btn btn-primary">INC</button>
//             <button onClick={rnd} className="btn btn-primary">RND</button>
//         </div>
//     )
// }

class Counter extends Component {
    render() {
        const {counter, inc, dec, rnd} = this.props;
        return (
            <div className="jumbotron">
                <h1>{counter}</h1>
                <button onClick={dec} className="btn btn-primary">DEC</button>
                <button onClick={inc} className="btn btn-primary">INC</button>
                <button onClick={rnd} className="btn btn-primary">RND</button>
            </div>
        )
    }
}

const mapStateToProps = (state) => {
    return {
        counter: state.value
    }
}
	  
// const mapDispatchToProps = (dispatch) => {
// 	return bindActionCreators(actions, dispatch)
// }	  

export default connect(mapStateToProps, actions)(Counter);	  
```	  

### При помощи хуков
	  
```jsx harmony
import {inc, dec, rnd} from '../actions';
import { useSelector, useDispatch } from "react-redux";

const Counter = () => {

    const counter = useSelector(state => state.counter);
    const dispatch = useDispatch();
    
    return (
        <div className="jumbotron">
            <h1>{counter}</h1>
            <button onClick={() => dispatch(dec())} className="btn btn-primary">DEC</button>
            <button onClick={() => dispatch(inc())} className="btn btn-primary">INC</button>
            <button onClick={() => dispatch(rnd())} className="btn btn-primary">RND</button>
        </div>
    )
}

export default Counter;	  
```	  
	  
  **[⬆ Наверх](#top)**
	
359. ### <a name="359"></a> combineReducers и reducers

```jsx harmony
import { createStore, combineReducers } from 'redux';
import heroes from '../reducers/heroes';
import filters from '../reducers/filters';

const store = createStore( combineReducers({heroes, filters}),
    window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());

export default store;	  
```	  

```jsx harmony
const initialState = {
    filters: [],
    filtersLoadingStatus: 'idle',
    activeFilter: 'all'
}

const filters = (state = initialState, action) => {
    switch (action.type) {
        case 'FILTERS_FETCHING':
            return {
                ...state,
                filtersLoadingStatus: 'loading'
            }
        case 'FILTERS_FETCHED':
            return {
                ...state,
                filters: action.payload,
                filtersLoadingStatus: 'idle'
            }
        case 'FILTERS_FETCHING_ERROR':
            return {
                ...state,
                filtersLoadingStatus: 'error'
            }
        case 'ACTIVE_FILTER_CHANGED':
            return {
                ...state,
                activeFilter: action.payload
            }
        default: return state
    }
}

export default filters;	  
```	  

```jsx harmony
const initialState = {
    heroes: [],
    heroesLoadingStatus: 'idle'
}

const heroes = (state = initialState, action) => {
    switch (action.type) {
        case 'HEROES_FETCHING':
            return {
                ...state,
                heroesLoadingStatus: 'loading'
            }
        case 'HEROES_FETCHED':
            return {
                ...state,
                heroes: action.payload,
                heroesLoadingStatus: 'idle'
            }
        case 'HEROES_FETCHING_ERROR':
            return {
                ...state,
                heroesLoadingStatus: 'error'
            }
        case 'HERO_CREATED':
            return {
                ...state,
                heroes: [...state.heroes, action.payload]
            }
        case 'HERO_DELETED': 
            return {
                ...state,
                heroes: state.heroes.filter(item => item.id !== action.payload)
            }
        default: return state
    }
}

export default heroes;	  
```	  
	  
  **[⬆ Наверх](#top)**
	
360. ### <a name="360"></a> createSelector from 'reselect'

```jsx harmony
import {useHttp} from '../../hooks/http.hook';
import { useEffect, useCallback } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { CSSTransition, TransitionGroup} from 'react-transition-group';
import { createSelector } from 'reselect';

import { heroesFetching, heroesFetched, heroesFetchingError, heroDeleted } from '../../actions';
import HeroesListItem from "../heroesListItem/HeroesListItem";
import Spinner from '../spinner/Spinner';

import './heroesList.scss';

const HeroesList = () => {

    const filteredHeroesSelector = createSelector(
        (state) => state.filters.activeFilter,
        (state) => state.heroes.heroes,
        (filter, heroes) => {
            if (filter === 'all') {
                console.log('render');
                return heroes;
            } else {
                return heroes.filter(item => item.element === filter);
            }
        }
    );

    const filteredHeroes = useSelector(filteredHeroesSelector);
    const heroesLoadingStatus = useSelector(state => state.heroes.heroesLoadingStatus);
    const dispatch = useDispatch();
    const {request} = useHttp();

    useEffect(() => {
        dispatch(heroesFetching());
        request("http://localhost:3001/heroes")
            .then(data => dispatch(heroesFetched(data)))
            .catch(() => dispatch(heroesFetchingError()))

        // eslint-disable-next-line
    }, []);

    const onDelete = useCallback((id) => {
        request(`http://localhost:3001/heroes/${id}`, "DELETE")
            .then(data => console.log(data, 'Deleted'))
            .then(dispatch(heroDeleted(id)))
            .catch(err => console.log(err));
        // eslint-disable-next-line  
    }, [request]);

    if (heroesLoadingStatus === "loading") {
        return <Spinner/>;
    } else if (heroesLoadingStatus === "error") {
        return <h5 className="text-center mt-5">Ошибка загрузки</h5>
    }

    const renderHeroesList = (arr) => {
        if (arr.length === 0) {
            return (
                <CSSTransition
                    timeout={0}
                    classNames="hero">
                    <h5 className="text-center mt-5">Героев пока нет</h5>
                </CSSTransition>
            )
        }

        return arr.map(({id, ...props}) => {
            return (
                <CSSTransition 
                    key={id}
                    timeout={500}
                    classNames="hero">
                    <HeroesListItem  {...props} onDelete={() => onDelete(id)}/>
                </CSSTransition>
            )
        })
    }

    const elements = renderHeroesList(filteredHeroes);
    return (
        <TransitionGroup component="ul">
            {elements}
        </TransitionGroup>
    )
}

export default HeroesList;	  
```	  
    
  **[⬆ Наверх](#top)**
	
361. ### <a name="361"></a> enhancer

```jsx harmony
import { createStore, combineReducers, compose } from 'redux';
import heroes from '../reducers/heroes';
import filters from '../reducers/filters';

const enhancer = (createStore) => (...args) => {
    const store = createStore(...args);

    const oldDispatch = store.dispatch;
    store.dispatch = (action) => {
        if (typeof action === 'string') {
            return oldDispatch({
                type: action
            })
        }
        return oldDispatch(action)
    }
    return store;
}

const store = createStore( 
                    combineReducers({heroes, filters}),
                    compose(
                        enhancer,
                        window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()
                    ));

export default store;			
```			
    
  **[⬆ Наверх](#top)**
	
362. ### <a name="362"></a> applyMiddleware

```jsx harmony
import { createStore, combineReducers, compose, applyMiddleware } from 'redux';
import heroes from '../reducers/heroes';
import filters from '../reducers/filters';

const stringMiddleware = () => (next) => (action) => {
    if (typeof action === 'string') {
        return next({
            type: action
        })
    }
    return next(action)
};

const store = createStore( 
                    combineReducers({heroes, filters}),
                    compose(applyMiddleware(stringMiddleware),
                            window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__())
                    );

export default store;			
```			
    
  **[⬆ Наверх](#top)**
	
363. ### <a name="363"></a> ReduxThunk

```jsx harmony
import { createStore, combineReducers, compose, applyMiddleware } from 'redux';
import ReduxThunk from 'redux-thunk';
import heroes from '../reducers/heroes';
import filters from '../reducers/filters';

const stringMiddleware = () => (next) => (action) => {
    if (typeof action === 'string') {
        return next({
            type: action
        })
    }
    return next(action)
};

const store = createStore( 
                combineReducers({heroes, filters}),
                compose(applyMiddleware(ReduxThunk, stringMiddleware),
                        window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__())
                );

export default store;			
```			
    
  **[⬆ Наверх](#top)**
	  
364. ### <a name="364"></a> 

    
  **[⬆ Наверх](#top)**

365. ### <a name="365"></a> 

    
  **[⬆ Наверх](#top)**
			
366. ### <a name="366"></a> 

    
  **[⬆ Наверх](#top)**			

377. ### <a name="377"></a> 

 
    
  **[⬆ Наверх](#top)**	
		
378. ### <a name="378"></a> 

 
    
  **[⬆ Наверх](#top)**	
		
379. ### <a name="379"></a> 

 
    
  **[⬆ Наверх](#top)**	
		
380. ### <a name="380"></a> 


    
  **[⬆ Наверх](#top)**
