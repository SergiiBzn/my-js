<a name="top"></a>

[На главную](../README.md)

[Перейти к вопросам](#questions)

| №. | Вопрос |
| --- | --------- |
|   | Общие вопросы |
|1 | [SOLID, KISS, DRY, YAGNI](#1) |
|2 | [Императивное и Декларативное программирование](#2) |
|3 | [HTTP, HTTPS, HTTP Headers, Status Codes, TCP vs UDP, C.O.R.S.](#3) |
|4 | [Параметры запроса и JSON](#4) |
|5 | [Git code](#5) |
|6 | [Связь с сервером: HTTP, REST, websockets](#6) |
|7 | [Методологии ведения разрботки Agile, Scrum, Kanban, Waterfall](#7) |
|8 | [Git info](#8) |
|9 | [Паттерны проектирования](#9) |
|10 | [Структуры данных. Алгоритмы поиска, Сортировки. Сложность алгоритма](#10) |
|11 | [Unit-tests](#11) |
|12 | [Оценка скорости приложения - Google Lighthouse](#12) |
|13 | [Основных модели SDLC](#13) |
|14 | [Предоставление оценок усилий, необходимых для выполнения задач на основе заданной WBS](#14) |
|15 | [](#15) |
|16 | [](#16) |
|17 | [Что такое реактивное программирование? Основные кирпичи (поток, наблюдаемый, подписка)](#17) |
|18 | [gulp / grunt, webpack, bazel](#18) |
|19 | [Хранение паролей и возможности хеширования. Разница между хешем и hmac.](#19) |
|20 | [Атаки на формы и URL-адреса (CSRF, XSS, проблема с семантическими URL-адресами. Фильтрация входных данных.)](#20) |
|21 | [Понимание концепции рефакторинга](#21) |
|22 | [Основные понятия: Test Plan, Test Suite, Test Case. Концепции различных типов тестов: Единичный / Интеграционный / Функциональный. Основы работы с JS Unit.](#22) |
|23 | [Реализация ООП в JS](#23) |
|24 | [Принципы ООП](#24) |
|25 | [Code small](#25) |
|26 | [Continuous delivery, Continuous deployment & Continuous integration (CI/CD)](#26) |
|27 | [Отладке кода, Debugging](#27) |
|28 | [Jira (Redmine,Tfs)](#28) |
|29 | [](#29) |
|30 | [Хранилище данных: Куки, LocalStorage, sessionStorage, IndexedDB](#30) |
|31 | [Критический путь рендеринга](#31) |
|32 | [Кэширование (как работает и зачем нужно)](#32) |
|33 | [](#33) |
|34 | [](#34) |
|   | HTML |
|401 | [Базовая схема HTML-документа](#401) |
|402 | [Использование символов HTML](#402) |
|403 | [Форматирование текста, абзацы](#403) |
|404 | [HTML-ссылки. Link target](#404) |
|405 | [Таблицы HTML](#405) |
|406 | [Добавление scripts](#406) |
|407 | [Разница между блочными и строчными элементами](#407) |
|408 | [Для чего нужен DOCTYPE?](#408) |
|409 | [Как следует оформлять страницу, содержимое которой может быть на разных языках?](#409) |
|410 | [На что необходимо обратить внимание при разработке мультиязычных сайтов?](#410) |
|411 | [Для чего нужны data- атрибуты?](#411) |
|412 | [Представьте HTML5 как открытую веб-платформу. Из каких блоков состоит HTML5?](#412) |
|413 | [Объясните разницу между cookie, sessionStorage и localStorage](#413) |
|414 | [Объясните разницу между <script>, <script async> и <script defer>](#414) |
|415 | [Почему хорошей практикой считается располагать <link> для подключения CSS между <head></head>, а <script> для подключения JS ставить перед </body>? Знаете ли вы исключения?](#415) |
|416 | [Что такое прогрессивный рендеринг](#416) |
|417 | [Для чего используется атрибут srcset в теге изображения? Опишите процесс, который браузер использует при обработке содержимого этого атрибута](#417) |
|418 | [Что такое семантика?](#418) |
|419 | [](#419) |
|420 | [](#420) |
|421 | [](#421) |
|422 | [](#422) |
|423 | [](#423) |
|   | CSS |
|494 | [](#494) |
|495 | [](#495) |
|496 | [](#496) |
|497 | [](#497) |
|498 | [](#498) |
|499 | [](#499) |	
|500 | [Варианты добавление CSS стилей на страницу?](#500) |	
|501 | [css modules](#501) |
|502 | [Селекторы и их вес](#502) |
|503 | [Positioning](#503) |
|504 | [Margings vs paddings](#504) |
|505 | [Добавление шрифтов](#505) |
|506 | [Видимость элемента. Способы скрыть элемент](#506) |
|507 | [Z-index](#507) |
|508 | [Чем полезны data- атрибуты?](#508) |
|509 | [Что такое кэш приложения в HTML5?](#509) |
|510 | [Объясните разницу между script, script async и script defer](#510) |
|511 | [Дайте пояснения, для какой цели добавленны след. элементы: article, aside, audio, canvas, figcaption, figure, footer, header, hgroup, output, section, video](#511) |
|512 | [Чем отличается article от section?](#512) |
|513 | [Можно ли вложить p в другой такой же p? Можно ли вложить div в p?](#513) |
|514 | [Чем отличается класс (class) от идентификатора (id) в HTML?](#514) |
|515 | [Что такое прогрессивный рендеринг](#515) |
|516 | [Почему хорошей практикой считается располагать <link> для подключения CSS между <head></head>, а <script> для подключения JS ставить перед </body>?](#516) |
|517 | [](#517) |
|518 | [Объясните, что такое плавающие элементы (floats) и как они работают?](#518) |
|519 | [Что такое flexbox?](#519) |
|520 | [Как задать flexbox?](#520) |
|521 | [Какие оси есть в flexbox?](#521) |
|522 | [Какое свойство flexbox отвечает за направление flex items?](#522) |
|523 | [Какое правило flexbox задает вывод flex items в одну строку или в несколько строк?](#523) |
|524 | [Как можно гибко изменять размеры flex элементов?](#524) |
|525 | [Расскажите про flex-grow, flex-shrink, flex-basis?](#525) |
|526 | [Что такое css grid?](#526) |
|527 | [Можно ли использовать css grid и flexbox вместе?](#527) |
|528 | [Объясните, как браузер определяет, на какие элементы накладывать CSS стили?](#528) |
|529 | [Объясните, что такое псевдоэлементы и для чего они нужны.](#529) |
|530 | [Что делает * { box-sizing: border-box; }? В чём его преимущества?](#530) |
|531 | [В чём разница между строчным и блочно-строчным элементом?](#531) |
|532 | [Можете ли вы объяснить разницу между отзывчивым (responsive) сайтом и сайтом, сделанным по принципу mobile-first?](#532) |
|533 | [Свойства display - основные значения и как они работают](#533) |
|534 | [Keyframes для чего нужно и как использовать?](#534) |
|535 | [](#535) |
|536 | [](#536) |
|537 | [](#537)	|
|538 | [](#538)	|
|539 | [](#539)	|


<a name="questions"></a>

## Ключевые концепции React

  **[⬆ Наверх](#top)**
  
1. ### <a name="1"></a> SOLID, KISS, DRY, YAGNI

- DRY – расшифровывается как Don’t Repeat Youself – не повторяйся, также известен как DIE – Duplication Is Evil – дублирование это зло. Этот принцип заключается в том, что нужно избегать повторений одного и того же кода. Лучше использовать универсальные свойства и функции.

- KISS – Keep It Simple, Stupid – не усложняй! Смысл этого принципа программирования заключается в том, что стоит делать максимально простую и понятную архитектуру, применять шаблоны проектирования и не изобретать велосипед.

- YAGNI значит You Ain’t Gonna Need It – вам это не понадобится! Его суть в том, чтобы реализовать только поставленные задачи и отказаться от избыточного функционала.

- SOLID в упрощенном варианте означает, что когда при написании кода используется несколько принципов вместе, то это значительно облегчает дальнейшую поддержку и развитие программы. Полностью акроним расшифровывается так:

1) *Single responsibility* — принцип единственной ответственности обозначает, что каждый объект должен иметь одну обязанность и эта обязанность должна быть полностью инкапсулирована в класс. Все его сервисы должны быть направлены исключительно на обеспечение этой обязанности.
2) *Open-closed* — принцип открытости / закрытости декларирует, что программные сущности (классы, модули, функции и тп) должны быть открыты для расширения, но закрыты для изменения. Это означает, что эти сущности могут менять свое поведение без изменения их исходного кода.
3) *Liskov substitution* — принцип подстановки Барбары Лисков в формулировке Роберта Мартина: «функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа не зная об этом».
4) *Interface segregation* — принцип разделения интерфейса в формулировке Роберта Мартина: «клиенты не должны зависеть от методов, которые они не используют». Принцип разделения интерфейсов говорит о том, что слишком «толстые» интерфейсы необходимо разделять на более маленькие и специфические, чтобы клиенты маленьких интерфейсов знали только о методах, которые необходимы им в работе. В итоге, при изменении метода интерфейса не должны меняться клиенты, которые этот метод не используют.
5) *Dependency inversion* — принцип инверсии зависимостей — модули верхних уровней не должны зависеть от модулей нижних уровней, а оба типа модулей должны зависеть от абстракций; сами абстракции не должны зависеть от деталей, а вот детали должны зависеть от абстракций.

### Solid
```js
// Single Responsibility Principle

class News {
  constructor(title, text) {
    this.title = title
    this.text = text
    this.modified = false
  }

  update(text) {
    this.text = text
    this.modified = true
  }
}

class NewsPrinter {
  constructor(news) {
    this.news = news
  }

  html() {
    return `
      <div class="news">
        <h1>${this.news.title}</h1>
        <p>${this.news.text}</p>
      </div>
    `
  }

  json() {
    return JSON.stringify({
      title: this.news.title,
      text: this.news.text,
      modified: this.news.modified
    }, null, 2)
  }

  xml() {
    return `
      <news>
        <title>${this.news.title}</title>
        <text>${this.news.text}</text>
      </news>
    `
  }
}


const printer = new NewsPrinter(
  new News('Путин', 'Новая конституция')
)

console.log(printer.html())
console.log(printer.xml())
console.log(printer.json())	
```	
```js
// Open Close Principle

class Shape {
  area() {
    throw new Error('Area method should be implemented')
  }
}

class Square extends Shape {
  constructor(size) {
    super()
    this.size = size
  }

  area() {
    return this.size ** 2
  }
}

class Circle extends Shape {
  constructor(radius) {
    super()
    this.radius = radius
  }

  area() {
    return (this.radius ** 2) * Math.PI
  }
}

class Rect extends Shape {
  constructor(width, height) {
    super()
    this.width = width
    this.height = height
  }

  area() {
    return this.width * this.height
  }
}

class Triangle extends Shape {
  constructor(a, b) {
    super()
    this.a = a
    this.b = b
  }

  area() {
    return (this.a * this.b) / 2
  }
}

class AreaCalculator {
  constructor(shapes = []) {
    this.shapes = shapes
  }

  sum() {
    return this.shapes.reduce((acc, shape) => {
      acc += shape.area()
      return acc
    }, 0)
  }
}


const calc = new AreaCalculator([
  new Square(10),
  new Circle(1),
  new Circle(5),
  new Rect(10, 20),
  new Triangle(10, 15)
])

console.log(calc.sum())	
```	
```js
// Liskov substitution principle

class Person {

}

class Member extends Person {
  access() {
    console.log('У тебя есть доступ')
  }
}

class Guest extends Person {
  isGuest = true
}

class Frontend extends Member {
  canCreateFrontend() {}
}

class Backend extends Member {
  canCreateBackend() {}
}

class PersonFromDifferentCompany extends Guest {
  access() {
    throw new Error('У тебя нет доступа! Иди к себе!')
  }
}

function openSecretDoor(member) {
  member.access()
}

openSecretDoor(new Frontend())
openSecretDoor(new Backend())
openSecretDoor(new PersonFromDifferentCompany())  // There should be member!

// ===============

class Component {
  isComponent = true
}

class ComponentWithTemplate extends Component {
  render() {
    return `<div>Component</div>`
  }
}

class HigherOrderComponent extends Component {

}

class HeaderComponent extends ComponentWithTemplate {
  onInit() {}
}

class FooterComponent extends ComponentWithTemplate {
  afterInit() {}
}

class HOC extends HigherOrderComponent {
  render() {
    throw new Error('Render is impossible here')
  }

  wrapComponent(component) {
    component.wrapped = true
    return component
  }
}

function renderComponent(component) {
  console.log(component.render())
}


renderComponent(new HeaderComponent())
renderComponent(new FooterComponent())	
```	
```js
// Interface segregation principle

class Animal {
  constructor(name) {
    this.name = name
  }

  walk() {
    console.log(`${this.name} умеет ходить`)
  }

  swim() {
    console.log(`${this.name} умеет плавать`)
  }

  fly() {
    console.log(`${this.name} умеет летать`)
  }
}

class Dog extends Animal {
  fly() {
    return null
  }
}

class Eagle extends Animal {
  swim() {
    return null
  }
}

class Whale extends Animal {
  fly() {
    return null
  }

  walk() {
    return null
  }
}

// =====

class Animal {
  constructor(name) {
    this.name = name
  }
}

const swimmer = {
  swim() {
    console.log(`${this.name} умеет плавать`)
  }
}

const flier = {
  fly() {
    console.log(`${this.name} умеет летать`)
  }
}

const walker = {
  walk() {
    console.log(`${this.name} умеет ходить`)
  }
}

class Dog extends Animal {}
class Eagle extends Animal {}
class Whale extends Animal {}

Object.assign(Dog.prototype, swimmer, walker)
Object.assign(Eagle.prototype, flier, walker)
Object.assign(Whale.prototype, swimmer)

const dog = new Dog('Рэкс')
dog.walk()
dog.swim()

const eagle = new Eagle('Орел')
eagle.fly()
eagle.walk()

const whale = new Whale('Большой синий друг')
whale.swim()	
```	
```js
// Dependency inversion principle


class Fetch {
  request(url) {
    // return fetch(url).then(r => r.json())
    return Promise.resolve('data from fetch')
  }
}

class LocalStorage {
  get() {
    const dataFromLocalStorage = 'data from local storage'
    return dataFromLocalStorage
  }
}

class FetchClient {
  constructor() {
    this.fetch = new Fetch()
  }

  clientGet() {
    return this.fetch.request('vk.com')
  }
}

class LocalStorageClient {
  constructor() {
    this.localStorage = new LocalStorage()
  }

  clientGet(key) {
    return this.localStorage.get(key)
  }
}


class Database {
  constructor(client) {
    this.client = client
  }

  getData(key) {
    return this.client.clientGet(key)
  }
}


const db = new Database(new LocalStorageClient())

console.log(db.getData('rand'))	
```	

  **[⬆ Наверх](#top)**

2. ### <a name="2"></a> Императивное и Декларативное программирование

`Императивное программирование` — последовательность команд, которая описывает то, как можно добиться результата.

К императивной парадигме относятся следующие виды программирования:
процедурное; структурное; аспектно-ориентированное; объектно-ориентированное и другие.

`Декларативное программирование` — описание того, какой результат нужно получить.

К декларативной парадигме относятся функциональное и логическое программирование


Это своего рода способы программирования, это то, как программа должна выполняться.

1. В *процедурном* программировании программа состоит из структур данных (объектов обработки) и алгоритма (метода обработки). Это явное описание всех вычислений, которые должен проделать компьютер.

2. В *функциональном* программировании единственной управляющей конструкцией является вызов функций. Все функции строятся на основе некоторых базовых функций с помощью композиций.

`Чистые» функции` - это любые функции, исходные данные которых получены исключительно из их входных данных и не вызывают побочных эффектов в приложении. Математические функции являются примерами «чистых» функций. 

`Чистая» функция` - это функция, которая выводит свои данные основываясь исключительно на свои входные данные и не вызывает побочных эффектов в приложении.

Например у нас есть функция, которая получает одно значение x и возвращает в данном случае x + 1:
```js
// function f(x) { return x + 1 }

const f = x => x + 1;
```
 
`Нечистые» функции` бывают разных форм и размеров. Вот некоторые примеры:

- функции, вывод которых зависит от внешнего / глобального состояния;
- функции, которые возвращают разные исходные данные при одинаковых входных;
- функции, которые изменяют состояние приложения;
- функции, которые изменяют «внешний мир».

Функциональное программирование основано на использовании «чистых» функций и строгом контроле побочных эффектов. Способность распознавать любой тип функции является ключевым для функционального программирования.

 `Функции первого класса` - они могут быть переданы другим функциям и их можно вернуть из функций. Так же их можно присваивать переменным.

Пример
/* функция не имеет имени и находится в правой части команды присваивания переменной.*/
```jsx harmony
var dog = function(num) {
    for (var i = 0; i < num; i++) {
        alert("Woof");
    }
};
dog(3); //Эту функцию можно вызвать через переменную dog.
```

`Функции высшего порядка` — это функции, которые работают с другими функциями, либо принимая их в виде параметров, либо возвращая их. Проще говоря, функцией высшего порядка называется такая функция, которая принимает функцию как аргумент или возвращает функцию в виде выходного значения.

Например, встроенные функции JavaScript Array.prototype.map, Array.prototype.filter и Array.prototype.reduce являются функциями высшего порядка.

`Каррирование` – продвинутая техника для работы с функциями. Она используется не только в JavaScript, но и в других языках.

`Каррирование` – это трансформация функций таким образом, чтобы они принимали аргументы не как f(a, b, c), а как f(a)(b)(c).
Каррирование не вызывает функцию. Оно просто трансформирует её.

3. В *объектно-ориентированном* программировании программа представляет собой совокупность объектов, обладающих свойствами и методами, обменивающихся между собой сообщениями, выстраивающихся в иерархию, наследуя свойства и методы.

Пример на JS

Мой любимый пример такой: дан массив чисел, надо написать функцию, которая вернет массив чисел, где каждое число из исходного массива удваивается. Т.е. [1, 2, 3] -> [2, 3, 6]

Императивный стиль:
```jsx harmony
function double (arr) {
  let results = [];
  for (let i = 0; i < arr.length; i++){
    results.push(arr[i] * 2);
  }
  return results;
}
```
Декларативный стиль:
```jsx harmony
function double (arr) {
  return arr.map((item) => item * 2);
}
```
  **[⬆ Наверх](#top)**

3. ### <a name="3"></a> HTTP, HTTPS, HTTP Headers, Status Codes, TCP vs UDP, C.O.R.S.

HTTP — широко распространённый протокол передачи данных, изначально предназначенный для передачи гипертекстовых документов (то есть документов, которые могут содержать ссылки, позволяющие организовать переход к другим документам).

HTTPS - HyperText Transfer Protocol Secure) — расширение протокола HTTP для поддержки шифрования в целях повышения безопасности. Данные в протоколе HTTPS передаются поверх криптографических протоколов TLS или устаревшего в 2015 году SSL. В отличие от HTTP с TCP-портом 80, для HTTPS по умолчанию используется TCP-порт 443.

Заголовки HTTP позволяют клиенту и серверу отправлять дополнительную информацию с HTTP запросом или ответом. В HTTP-заголовке содержится не чувствительное к регистру название, а затем после (:) непосредственно значение. Пробелы перед значением игнорируются.

HTTP-заголовки сопровождают обмен данными по протоколу HTTP. Они могут содержать описание данных и информацию, необходимую для взаимодействия между клиентом и сервером. Заголовки и их статусы перечислены в реестре IANA, который постоянно обновляется.

Status code (Коды ответа):
- Информационные 100 - 199
- Успешные 200 - 299
- Перенаправления 300 - 399
- Клиентские ошибки 400 - 499
- Серверные ошибки 500 - 599

TCP – транспортный протокол передачи данных в сетях TCP/IP, предварительно устанавливающий соединение с сетью. 

UDP – транспортный протокол, передающий сообщения-датаграммы без необходимости установки соединения в IP-сети.

Давайте рассмотрим основные отличия tcp от udp.

- TCP гарантирует доставку пакетов данных в неизменных виде, последовательности и без потерь, UDP ничего не гарантирует.
- TCP нумерует пакеты при передаче, а UDP нет
- TCP работает в дуплексном режиме, в одном пакете можно отправлять информацию и подтверждать получение предыдущего пакета.
- TCP требует заранее установленного соединения, UDP соединения не требует, у него это просто поток данных.
- UDP обеспечивает более высокую скорость передачи данных.
- TCP надежнее и осуществляет контроль над процессом обмена данными.
- UDP предпочтительнее для программ, воспроизводящих потоковое видео, видеофонии и телефонии, сетевых игр.
- UDP не содержит функций восстановления данных


### Что такое CORS? Кросс-доменные запросы? Зачем нужны?	
	
CORS (Cross-Origin Resource Sharing, "Совместное использование ресурсов между разными источниками") - это система, состоящая из отправки HTTP заголовков, которые определяют: заблокировать или выполнить запрос к ограниченному ресурсу на веб-странице из другого домена, отличного от домена происхождения запрашиваемого ресурса.

 
Cross-Origin Resource Sharing (CORS) — механизм, использующий дополнительные HTTP-заголовки, чтобы дать возможность агенту пользователя получать разрешения на доступ к выбранным ресурсам с сервера на источнике (домене), отличном от того, что сайт использует в данный момент. Говорят, что агент пользователя делает запрос с другого источника (cross-origin HTTP request), если источник текущего документа отличается от запрашиваемого ресурса доменом, протоколом или портом.
 
С точки зрения браузера запросы к другому источнику бывают двух видов: «простые» и все остальные.

Простые запросы должны удовлетворять следующим условиям:

- Метод: GET, POST или HEAD.
- Заголовки – мы можем установить только:
1) Accept
2) Accept-Language
3) Content-Language
4) Content-Type со значением application/x-www-form-urlencoded, multipart/form-data или text/plain.
 
Основное их отличие заключается в том, что простые запросы с давних времён выполнялись с использованием тегов <form> или <script>, в то время как непростые долгое время были невозможны для браузеров.

Практическая разница состоит в том, что простые запросы отправляются сразу с заголовком Origin, а для других браузер делает предварительный запрос, спрашивая разрешения.

Для простых запросов:

→ Браузер посылает заголовок Origin с источником.
← Для запросов без авторизационных данных (не отправляются умолчанию) сервер должен установить:
- Access-Control-Allow-Origin в * или то же значение, что и Origin
← Для запросов с авторизационными данными сервер должен установить:
- Access-Control-Allow-Origin в то же значение, что и Origin
- Access-Control-Allow-Credentials в true
 
Дополнительно, чтобы разрешить JavaScript доступ к любым заголовкам ответа, кроме Cache-Control, Content-Language, Content-Type, Expires, Last-Modified или Pragma, сервер должен перечислить разрешённые в заголовке Access-Control-Expose-Headers.

Для непростых запросов перед основным запросом отправляется предзапрос:

→ Браузер посылает запрос OPTIONS на тот же адрес с заголовками:
- Access-Control-Request-Method – содержит запрашиваемый метод,
- Access-Control-Request-Headers – перечисляет непростые запрашиваемые заголовки.
← Сервер должен ответить со статусом 200 и заголовками:
- Access-Control-Allow-Methods со списком разрешённых методов,
- Access-Control-Allow-Headers со списком разрешённых заголовков,
- Access-Control-Max-Age с количеством секунд для кеширования разрешений
→ Затем отправляется основной запрос, применяется предыдущая «простая» схема. 
 
 https://learn.javascript.ru/fetch-crossorigin
 
### Зачем нужен CORS?
 
CORS существует для защиты интернета от злых хакеров.

Многие годы скрипт с одного сайта не мог получить доступ к содержимому другого сайта.

Это простое, но могучее правило было основой интернет-безопасности. Например, хакерский скрипт с сайта hacker.com не мог получить доступ к почтовому ящику пользователя на сайте gmail.com. И люди чувствовали себя спокойно.	
	
https://developer.mozilla.org/ru/docs/Web/HTTP/CORS

  **[⬆ Наверх](#top)**

4. ### <a name="4"></a> Параметры запроса и JSON

- GET - запрашивает представление ресурса. Запросы с использованием этого метода могут только извлекать данные.
- HEAD - запрашивает ресурс так же, как и метод GET, но без тела ответа.
- POST -  используется для отправки сущностей к определённому ресурсу. Часто вызывает изменение состояния или какие-то побочные эффекты на сервере.
- PUT - заменяет все текущие представления ресурса данными запроса.
- DELETE - удаляет указанный ресурс.

- CONNECT - устанавливает "туннель" к серверу, определённому по ресурсу.
- OPTIONS - используется для описания параметров соединения с ресурсом.

- TRACE - выполняет вызов возвращаемого тестового сообщения с ресурса.
- PATCH - используется для частичного изменения ресурса.

JSON — это формат, который хранит структурированную информацию и в основном используется для передачи данных между сервером и клиентом.

Файл JSON представляет собой более простую и лёгкую альтернативу расширению с аналогичными функциями XML (Extensive Markup Language).

`JSON` - это синтаксис для сериализации объектов, массивов, чисел, строк, логических значений и null. Он основан на синтаксисе JavaScript.
	
`JSON.parse(text[, reviver])        в text`	
Разберите строку text как JSON, при необходимости преобразуйте полученное значение и его свойства и верните значение. Любые нарушения синтаксиса JSON, в том числе относящиеся к различиям между JavaScript и JSON, вызывают появление SyntaxError. Эта reviver опция позволяет интерпретировать то, что replacerиспользовалось для обозначения других типов данных.

`JSON.stringify(value[, replacer[, space]])     в JSON`
Вернуть строку JSON, соответствующую указанному значению, необязательно включая только определенные свойства или заменяя значения свойств определенным пользователем способом. По умолчанию все экземпляры undefinedзаменяются на null, а другие неподдерживаемые собственные типы данных подвергаются цензуре. replacer Опция позволяет указать другое поведение.	
	
![1](https://user-images.githubusercontent.com/80325645/137619168-5fab833b-37c0-4923-9713-b40ea232f5e1.png)

Request Payload - это любые данные, отправленные в теле запроса.

PAYLOAD или полезные данные
Вторым блоком идет eyJ1c2VyX2lkIjoxLCJleHAiOjE1ODEzNTcwMzl9

Это есть полезные данные, так же закодированные в Base64. После раскодирования получим:

{"user_id":1,"exp":1581357039}

Данные могут быть любыми. Главное, чтобы по ним можно было идентифицировать пользователя. В нашем случае - это user_id и exp - время окончания действия текущего токена.

Поскольку необходимо ограничивать токен по времени, поле exp обязательно. По нему можно проверить, актуален ли токен или нет.

А FormData - это определённый формат (content-type) передачи данных, а именно multipart/form-data. Также возможны форматы application/json, application/x-www-form-urlencoded и другие.

  **[⬆ Наверх](#top)**

5. ### <a name="5"></a> Git code

https://github.com/nicothin/web-development/tree/master/git	
	
https://frontend-stuff.com/blog/tags/git	

Git позволяет:
- просматривать историю изменений в проекте
- возращаться к старой версии проекта и обратно
- переключаться между несколькими альтернативными версиями проекта
- обмениваться кодом с другими разработчиками и совместно вести разработку	
	
### Инициализация и клонирование репозиториев
	
git init <directory> Создает пустой Git-репозиторий в указанной директории. Если запустить его без аргументов, то будет использоваться текущий каталог, как репозиторий git.

git clone <repo> Клонирует репозиторий по ссылке <repo> на локальный компьютер. Оригинальный репозиторий может находиться в локальной файловой системе или на удаленном компьютере через HTTP или SSH.

### Настройка информации о пользователях, используемой во всех локальных репозиториях
	
git config --global user.name “firstname lastname” Определяет имя автора, которое используется во всех коммитах в текущем репозитории. Обычно используется флаг —global, чтобы установить параметры конфигурации для текущего пользователя.

git config --global user.email “valid-email” Определяет адрес электронной почты, который будет связан с каждым маркером истории.

git config --global color.ui auto Устанавливает автоматическую раскраску командной строки для Git, для удобства просмотра.

git add <directory> Помещает все изменения из указаной <directory> в промежуточную область для следующего коммита. Заменив <directory> на <file>, файл будет добавлен в промежуточную область.

git add . Помещает все твои изменения в текущей директории в промежуточную область.

git commit -m "<message>" Создает коммит сообщение для изменений в промежуточной области, но, вместо запуска текстового редактора использует <message> в качестве сообщения.

git commit -am "<message>" Помещает все изменения в текущей директории в промежуточную область и создаст коммит сообщение с <message> в качестве сообщения.

git status Показывает список измененных файлы в рабочем каталоге: добавлених в промежуточную область или нет.

git log Показывает всю историю коммитов, используя формат по умолчанию. Для настройки см. дополнительные параметры.

git diff Показывает изменения в рабочем каталоге которые еще не добавлены в промежуточную область.

git diff --staged Показывает изменения в рабочем каталоге которые были добавлены в промежуточную область но еще не закоммичены.

### Отмена изменений
	
git revert <commit> Создает новое коммит сообщение, которое отменяет все изменения, сделанные в данном <commit> (хеш коммита), затем применяет его в текущей ветке. Более подробно здесь.

git reset <file> Убирает <file> из промежуточной области, но оставляет рабочий каталог без изменений.

git checkout <file> Отменяет изменения только для определенного файла или каталога, которые не были добавлены в промежуточную область.

### Переписывание Git History
	
git commit --amend Изменяет последнее коммит сообщение и добавляет изменения из промежуточной области. Для того что бы просто изменить сообщение последнего коммита нужно что бы в промежуточной области не было изменений. Более подробно здесь.

git rebase <base> Переносит текущую ветку поверх <base>. <base> - может быть хешем коммита, именем ветки, тегом или относительной ссылкой на HEAD. Применяет любые коммиты текущей ветки поверх указанной.

git reflog Показывает журнал изменений в HEAD локального репозитория. Добавь флаг —relative-date, чтобы показать информацию о дате, или —all, чтобы показать все ссылки.

git reset --hard [commit] Очищает промежуточную область, переписывает рабочее дерево до определенного коммита.

### Git Branches
	
git branch Выводит список всех веток в репозитории. Добавь аргумент <branch>, чтобы создать новую ветку с именем <branch>.

git checkout -b <branch> Создает и переходит на новую ветку с именем <branch>. Удали флаг -b, чтобы перейти на существующую ветку.

git merge <branch> Объединяет указанную ветку <branch> в текущую.

### Удалённые репозитории
	
git remote add <name> <url> Создает новое подключение к удалённому репозиторию. После добавления пульта ты можешь использовать <name> в качестве ярлыка для <url> в других командах.

git fetch <remote> <branch> Извлекает определенную ветку <branch> из репозитория. Убираем <branch>, чтобы получить все удалённые ссылки.

git pull <remote> Стягивает указанную удалённую копию текущей ветки и немедленно объединит её с локальной копией.

git push <remote> <branch> Отправляет локальную ветку в удалённый репозиторий. Создает именованную ветку в репозитории, если такой не существует.

git merge <remote> <branch> Объединяет удалённую ветку с текущей веткой, для её обновления.

### Временные коммиты
	
git stash Временно хранит все изменения в рабочей директории.

git stash list Выводит список сохраненных измененных файлов.

git stash pop Восстанавливает самое последнее сохранение файлов.

git stash drop Сбрасывает последние сохраненные изменение.

### git config
	
git config --global user.name <name> Определяет имя автора, которое будет использоваться для всех коммитов текущим пользователем.

git config --global user.email <email> Определяет адрес электронной почты автора, который будет использоваться для всех коммитов текущим пользователем.

git config --global alias. <alias-name> <git-command> Создает псевдоним (alias) для команды Git. Например: alias.glog log --graph --oneline установит git glog, эквивалентный git log --graph --oneline.

git config --system core.editor <editor> Устанавливает текстовый редактор, используемый командами для всех пользователей на машине. <editor> аргумент должен быть командой, которая запускает нужный редактор (например, vi).

git config --global --edit Открывает файл глобальной конфигурации в текстовом редакторе для ручного редактирования.

### git log
	
git log -<limit> Ограничивает количество коммитов на <limit>. Например: git log -5 ограничит до 5 коммитов.

git log --oneline Конденсирует каждый коммит в одну строку.

git log -p Показывает полный diff последнего коммита.

git log --stat Указывает, какие файлы были изменены, и относительное количество строк, которые были добавлены и удалены из каждого из них.

git log --author=”<pattern>” Ищет коммити определенного автора.

git log --grep=”<pattern>” Ищет коммити с сообщением коммита, которое соответствует <pattern>.

git log <since>..<until> Показывает коммиты, которые происходят между <since> и <until>. Аргументы могут быть идентификатором, именем ветки, HEAD или любым другим видом ссылки.

git log -- <file> Отображает только те коммиты, которые имеют указанный файл.

git log --graph --decorate Флаг --graph рисует, основанный на тексте, график коммитов в левой части коммит-сообщений. --decorate добавляет имена веток или тегов, показанных коммитов.

### git diff
	
git diff HEAD Показывает разницу между рабочим каталогом и последним коммитом.

git diff --cached Показывает разницу между изменениями в промежуточной области и последним коммитом.

### git reset
	
git reset Сбрасываает промежуточную область в соответствии с последним коммитом, но оставляет рабочий каталог без изменений.

git reset --hard Сбрасывает промежуточную область и рабочий каталог в соответствии с последним коммитом и перезаписывает все изменения в рабочем каталоге.

git reset <commit> Перемещает верхушку текущий ветки назад к <commit>; сбрасывает промежуточную область, чтобы соответствовать коммиту, но оставляет рабочий каталог.

git reset --hard <commit> Делает то же, что и предыдущий, но сбрасывает как промежуточную область, так и рабочий каталог для соответствия. Удаляет не зафиксированные изменения и все коммиты после <commit>.

### git rebase
	
git rebase -i <base> Интерактивное перебазирование текущей ветки на новую базу (хеш коммита). Запускает редактор для ввода команд о том, каким образом каждый коммит будет перенесен на новую базу.

### git pull
	
git pull --rebase <remote> Стягивает удаленную копию текущей ветки и перемещает её в локальную копию. Использует git rebase вместо merge для интеграции веток.

### git push
	
git push <remote> --force Принудительная отправка изменений git, даже если они приводят к конфликтному слиянию (non-fast-forward). Не используй флаг --force, если не уверен, что знаешь, что делаешь.

git push <remote> --all Отправка всех локальных веток на указанный <remote>.

git push <remote> --tags Теги не отправляются автоматически, когда ты отправляешь ветку или используешь флаг --all. Флаг --tags отправляет все локальные теги в удаленный репозиторий.	

  **[⬆ Наверх](#top)**

6. ### <a name="6"></a> Связь с сервером: HTTP, REST, websockets

REST (RESTful) - это общие принципы организации взаимодействия приложения/сайта с сервером посредством протокола HTTP. Особенность REST в том, что сервер не запоминает состояние пользователя между запросами - в каждом запросе передаётся информация, идентифицирующая пользователя (например, token, полученный через OAuth-авторизацию) и все параметры, необходимые для выполнения операции.

REST (Representational state transfer) - одна из самых популярных архитектур приложений.
Дело в том, что REST является архитектурным стилем, а не протоколом. С формальной точки зрения - REST - это написание сервера который принимает GET, POST, PUT, PATCH, DELETE запросы по каким-то url (как правило, есть группы url, каждая из которых делает 4 манипуляции с каким-то видом сущностей - Create, Read, Update, Delete).
	
REST архитектура должна придерживаться 6 принципов:
1. Модель клиент-сервер. - Должен быть сервер, у которого прописан набор endpoint’ов и структура payload’ов (полезной нагрузки, тело запроса), которые они могут принимать.
2. Отсутствие состояния - Протокол взаимодействия между клиентом и сервером требует соблюдения следующего условия: в период между запросами клиента никакая информация о состоянии клиента на сервере не хранится (Stateless protocol). Все запросы от клиента должны быть составлены так, чтобы сервер получил всю необходимую информацию для выполнения запроса. Состояние сессии при этом сохраняется на стороне клиент.
3. Кэширование - клиенты, а также промежуточные узлы, могут выполнять кэширование ответов сервера. Ответы сервера, в свою очередь, должны иметь явное или неявное обозначение как кэшируемые или некэшируемые с целью предотвращения получения клиентами устаревших или неверных данных в ответ на последующие запросы.
4. Единообразие интерфейса - Наличие унифицированного интерфейса является фундаментальным требованием дизайна REST-сервисов. Унифицированные интерфейсы позволяют каждому из сервисов развиваться независимо. Имеется в виду, что один раз определив, что в dogs у нас всегда передаётся массив таких объектов.
5. Слои - Клиент обычно не способен точно определить, взаимодействует он напрямую с сервером или же с промежуточным узлом, в связи с иерархической структурой сетей (подразумевая, что такая структура образует слои). Т.е. у нас есть 1 endpoint, но по нему запрос может попасть и быть обработан разными дочерними физическими серверами.
6. Код по требованию (необязательное ограничение) - Сервер может, при оприделённых запросах, загружать код (часто это - React или Angular приложение) клиенту, расширяя его функциональность. 

`HTTP` (англ. HyperText Transfer Protocol — «протокол передачи гипертекста») — протокол прикладного уровня передачи данных, изначально — в виде гипертекстовых документов в формате HTML, в настоящее время используется для передачи произвольных данных.
	
`HTTPS` (аббр. от англ. HyperText Transfer Protocol Secure) — расширение протокола HTTP для поддержки шифрования в целях повышения безопасности. Данные в протоколе HTTPS передаются поверх криптографических протоколов TLS (Transport Layer Security) или устаревшего в 2015 году SSL (Socket Security Layer). В отличие от HTTP с TCP-портом 80, для HTTPS по умолчанию используется TCP-порт 443. Многие web-сервисы переходят исключительно на HTTPS. Если мы хотим, чтобы сервер мог общаться с клиентами и по HTTP, и по HTTPS, нужно настроить на нём поддержку HTTPS. По сути, он будет иметь 2 набора конечных точек доступа к нему (т. е. 2 набора url, которые можно ввести в браузере для доступа к нему).		

Для каждого типа операции используется свой метод HTTP-запроса:

1. получение - GET
2. добавление - POST
3. модификация - PUT
4. удаление - DELETE

	
Протокол `WebSocket` («веб-сокет»), обеспечивает возможность обмена данными между браузером и сервером через постоянное соединение. Данные передаются по нему в обоих направлениях в виде «пакетов», без разрыва соединения и дополнительных HTTP-запросов.
WebSocket особенно хорош для сервисов, которые нуждаются в постоянном обмене данными, например онлайн игры, торговые площадки, работающие в реальном времени, и т.д.
Чтобы открыть веб-сокет-соединение, нам нужно создать объект new WebSocket, указав в url-адресе специальный протокол ws:	

WebSocket особенно хорош для сервисов, которые нуждаются в постоянном обмене данными, например онлайн игры, торговые площадки, работающие в реальном времени
	
Когда new WebSocket(url) создан, он тут же сам начинает устанавливать соединение.
Браузер, при помощи специальных заголовков, спрашивает сервер: «Ты поддерживаешь Websocket?» и если сервер отвечает «да», они начинают работать по протоколу WebSocket, который уже не является HTTP.
	
Метод WebSocket .send() может отправлять и текстовые и бинарные данные.
Вызов socket.send(body) принимает body в виде строки или любом бинарном формате включая Blob, ArrayBuffer и другие. Дополнительных настроек не требуется, просто отправляем в любом формате.
	
Как только объект WebSocket создан, мы должны слушать его события. Их всего 4:
- open – соединение установлено,
- message – получены данные,
- error – ошибка,
- close – соединение закрыто.	

  **[⬆ Наверх](#top)**

7. ### <a name="7"></a> Методологии ведения разрботки Agile, Scrum, Kanban, Waterfall

### Agile

Agile — это не методология, а собирательное название различных методик и подходов к управлению, которые: Фокусируют команду на нуждах и целях клиентов. Упрощают оргструктуру и процессы. Предлагают работу короткими циклами. Активно используют обратную связь. Предполагают повышение полномочий сотрудников. Имеют в своей основе гуманистический подход. Не являются конечным состоянием, а, скорее, образом мышления и жизни.

Преимущества и недостатки метода Agile

К преимуществам метода относятся:
- короткие и понятные итерации — циклы разработки длятся от 2 недели до 2 месяцев, по окончанию которых заказчик получает рабочую версию продукта
- высокая степень вовлечения исполнителей, организаторов и заказчиков проекта
- во главе угла стоит рабочий продукт как основной показатель прогресса — это можно рассматривать как плюс, так и минус, ведь в таком случае к команде проекта выдвигаются высокие требования по самоорганизации
- минимизация рисков благодаря гибкой системе внесения изменений;
- популярность метода среди разработчиков программ для управления бизнеса.


Не избежала методология и недостатков, которые органично «дополняют» её достоинства:
- стимулирование постоянных изменений проекта: гибкость разработки продукта может привести к тому, что он никогда не дойдёт до финальной версии
- повышенные требования к квалификации и опыту команды: помимо непосредственно создания продукта команда должна анализировать возможные способы улучшения эффективности собственной работы, беспрерывно обмениваться информацией по проекту, быть мотивированной и самоорганизованной. Далеко не всегда ресурсы проекта позволяют привлечь таких специалистов
- философский характер методологии: Agile — это не чёткая инструкция к действию, а целая философская концепция. Команда не может механически применить механики «гибкой» разработки, нужно принять ключевые принципы системы
- сложность подсчёта итоговой суммы работы: стимуляция изменений и усовершенствования конечного продукта приводит к плавающему значению стоимости проекта. Поэтому Agile не подойдет для управления проектами в строительстве, где составляется четкая смета под всю работу.

К отдельным agile-подходам относятся scrum и kanban.


### Scrum

Scrum — методология гибкой разработки на основе Agile, в основе которого лежит «спринт» — отрезок от 1 до 4 недель, по окончанию которого должна быть получена рабочая версия продукта.

Scrum – это «подход структуры». Над каждым проектом работает универсальная команда специалистов, к которой присоединяется еще два человека: владелец продукта и scrum-мастер. Первый соединяет команду с заказчиком и следит за развитием проекта (это не формальный руководитель команды, а скорее куратор). Второй помогает первому организовать бизнес-процесс: проводит общие собрания, решает бытовые проблемы, мотивирует команду и следит за соблюдением scrum-подхода.

Scrum-подход делит рабочий процесс на равные спринты – обычно это периоды от недели до месяца, в зависимости от проекта и команды. Перед спринтом формулируются задачи на данный спринт, в конце – обсуждаются результаты, а команда начинает новый спринт. Спринты очень удобно сравнивать между собой, что позволяет управлять эффективностью работы.


### Kanban

Kanban – это «подход баланса». Его задача – сбалансировать разных специалистов внутри команды и избежать ситуации, когда дизайнеры работают сутками, а разработчики жалуются на отсутствие новых задач.

Вся команда едина – в kanban нет ролей владельца продукта и scrum-мастера. Бизнес-процесс делится не на универсальные спринты, а на стадии выполнения конкретных задач: «Планируется», «Разрабатывается», «Тестируется», «Завершено» и др.

Главный показатель эффективности в kanban – это среднее время прохождения задачи по доске. Задача прошла быстро – команда работала продуктивно и слаженно. Задача затянулась – надо думать, на каком этапе и почему возникли задержки и чью работу надо оптимизировать.

В чем разница между Scrum и Kanban?

Основу Scrum составляют короткие спринты, как правило, 2-3-х недельные. Перед началом спринта команда сама формирует список задач на итерацию, далее запускается спринт.

После окончания спринта выполненные задачи заливаются на продакшн, а невыполненные — переносятся в другой спринт. Как правило, задачи, которые делаются во время спринта, не меняются: что было на старте спринта — должно быть сделано любой ценой к окончанию спринта.

На Kanban дает больше гибкости, если под гибкостью понимать частоту смены приоритетов. Если вчера разработчик залил выполненную задачу, а сегодня получили данные с "передовой" и узнали, что вот эта штука не работает так, как было задумано, то дают новые требования. Дополненные новые задачи поднимаются вверх и программист берет эту задачу «сверху», выполняет ее и, к вечеру все работает как надо. Все счастливы и эффективны как никогда.


### Waterfall

Waterfall — методика управления проектами, которая подразумевает последовательный переход с одного этапа на другой без пропусков и возвращений на предыдущие стадии.
Водопадная модель разработки подразумевает последовательное прохождение процесса, разбитого на стадии. Переход к новому этапу возможен только после завершения предыдущего.

Преимущества и недостатки Waterfall

В число наибольших преимуществ методики Waterfall вошли:

- понятная и простая структура процесса разработки — это снижает порог вхождения для команд
- удобная отчётность — можно легко отследить ресурсы, риски, затраченное время и финансы благодаря строгой этапности процесса разработки и детальной документации проекта
- стабильность задач — задачи, которые стоят перед продуктом, ясны команде с самого начала разработки, и остаются неизменными на протяжении всего процесса
- оценка стоимости и сроков сдачи проекта — сроки выпуска готового продукта, как и его итоговая стоимость могут быть просчитаны до момента запуска разработки.


Среди недостатков водопадного метода можно выделить:

- лишенный гибкости процесс — так, если проект требует больше временных и финансовых ресурсов, чем возможно, то под нож пойдёт фаза тестирования. Согласно исследованиям консалт-группы Rothman, стоимость исправления багов после выпуска продукта выше в среднем в 20 раз, чем во время полноценного многоэтапного тестирования в процессе разработки
- «стойкость» к изменениям — жёсткий каркас из этапов разработки и условие предоставление только готового продукта определяют невозможность вносить изменения во время разработки
- инерционность — на первых стадиях прогноз временных и финансовых трат может измениться в сторону увеличения, но изменить проект в сторону оптимизации затрат, изменения функционала или концепции до выпуска готового продукта невозможно
- повышенный риск — классическая система тестирования подразумевает отдельно тестирование каждого из компонентов проекта, в том числе, во взаимодействии с другими. При использовании Waterfall происходит тестирование готового продукта.

### V-модель
	
V-модель – это улучшенная версия классической каскадной модели. Здесь на каждом этапе происходит контроль текущего процесса, для того чтобы убедится в возможности перехода на следующий уровень. В этой модели тестирование начинается еще со стадии написания требований, причем для каждого последующего этапа предусмотрен свой уровень тестового покрытия.	

  **[⬆ Наверх](#top)**

8. ### <a name="8"></a> Git info

https://github.com/nicothin/web-development/tree/master/git#%D0%BA%D0%BE%D0%BD%D1%81%D0%BE%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D1%8B	
	
`Git` — это система управления версиями, которая пришлась по душе практически всем — от разработчиков до дизайнеров. 
`GitHub` можно считать соцсетью для хранения кода.	

Git позволяет:
- просматривать историю изменений в проекте
- возращаться к старой версии проекта и обратно
- переключаться между несколькими альтернативными версиями проекта
- обмениваться кодом с другими разработчиками и совместно вести разработку	
	
### Git flow. Что это? В чем преимущества?

Gitflow — это рабочий процесс, помогающий вести непрерывную разработку программного обеспечения и внедрять методики DevOps. 

git-flow — это набор расширений git предоставляющий высокоуровневые операции над репозиторием для поддержки модели ветвления Vincent Driessen.

![gitflow](https://user-images.githubusercontent.com/80325645/121673066-3280e280-cab9-11eb-95ad-d9533c8bca3f.png)

https://www.atlassian.com/ru/git/tutorials/comparing-workflows/gitflow-workflow

### В чем отличие merge от rebase

Оба метода преследуют одну и ту же цель — интеграция изменений из одной ветки в другую. Различаются принципы работы.

- *merge*: Слияние принимает содержимое ветки источника и объединяет их с целевой веткой. В этом процессе изменяется только целевая ветка. История исходных веток остается неизменной.
	
- *rebase:* Rebase сжимает все изменения и интегрирует их в целевую ветку. Перемещение перезаписывает историю, ввиду того, что передается завершенная работа из одной ветки в другую.

### Что делает команда cherry-pick
Команда git cherry-pick применяет изменения, которые созданы в уже существующих коммитах снова наверху текущей ветки. С помощью этой команды можно переносить изменения из разных веток

### Git — распределённая система контроля версий, которая даёт возможность разработчикам отслеживать изменения в файлах и работать над одним проектом совместно с коллегами.

- git config
Одна из самых часто используемых git команд. Она может быть использована для указания пользовательских настроек, таких как электронная почта, имя пользователя, формат и т.д. К примеру, данная команда используется для установки адреса электронной почты:
- git config --global user.email адрес@gmail.com

- git init
Эта команда используется для создания GIT репозитория. Пример использования:
- git init

- git add
Команда git add может быть использована для добавления файлов в индекс. К примеру, следующая команда добавит файл под названием temp.txt присутствующий в локальном каталоге в индекс:
- git add temp.txt

- git clone
Команда git clone используется для клонирования репозитория. Если репозиторий находится на удаленном сервере, используется команда такого рода:
- git clone имя.пользователя@хост:/путь/до/репозитория

И наоборот, для клонирования локального репозитория используйте:
- git clone /путь/до/репозитория

- git commit
Команда git commit используется для коммита изменений в файлах проекта. Обратите внимание, что коммиты не сразу попадают на удаленный репозиторий. Применение:
- git commit –m “Сообщение идущее вместе с коммитом”

- git status
Команда git status отображает список измененных файлов, вместе с файлами, которые еще не были добавлены в индекс или ожидают коммита. Применение:
- git status

- git push
- git push еще одна из часто используемых git команд. Позволяет поместить изменения в главную ветку удаленного хранилища связанного с рабочим каталогом. Например:
- git push origin master

- git checkout
Команда git checkout может быть использована для создания веток или переключения между ними. К примеру, следующий код создаст новую ветку и переключится на нее:
command git checkout -b <имя-ветки>

Чтобы просто переключиться между ветками используйте:

- git checkout <имя-ветки>

- git remote
Команда позволяет пользователю подключиться к удаленному репозиторию. Данная команда отобразит список удаленных репозиториев, настроенных в данный момент:
- git remote –v

Эта команда позволит пользователю подключить локальный репозиторий к удаленному серверу:
- git remote add origin <адрес.удаленного.сервера>

- git branch
Команда git branch может быть использована для отображения, создания или удаления веток. Для отображения всех существующих веток в репозитории введите:
- git branch

Для удаления ветки:
- git branch –d <имя-ветки>

- git pull
Команда pull используется для объединения изменений, присутствующих в удаленном репозитории, в локальный рабочий каталог. Применение:
- git pull

- git merge
Команда git merge используется для объединения ветки в активную ветвь. Применение:
- git merge <имя-ветки>

- git diff
Команда git diff используется для выявления различий между ветками. Для выявления различий с базовыми файлами, используйте
- git diff --base <имя-файла>

Следующая команда используется для просмотра различий между ветками, которые должны быть объединены, до их объединения:
- git diff <ветвь-источник> <ветвь-цель>
Для простого отображения существующих различий, используйте:
- git diff

- git tag
Используется для маркировки определенных коммитов с помощью простых меток. Примером может быть эта команда:
- git tag 1.1.0 <вставьте-commitID-здесь>

- git log
Запуск команды git log отобразит список всех коммитов в ветке вместе с соответствующими сведениями. Пример результата:
commit 15f4b6c44b3c8344caasdac9e4be13246e21sadw
Author: Alex Hunter <alexh@gmail.com>
Date:   Mon Oct 1 12:56:29 2016 -0600

- git reset
Команда git reset используется для сброса индекса и рабочего каталога до последнего состояния коммита. Применение:
- git reset --hard HEAD

- git rm
- git rm используется для удаления файлов из индекса и рабочего каталога. Применение:
- git rm имяфайла.txt

- git stash
Возможно одна из самых малоизвестных команд git. Она помогает в сохранении изменений на временной основе, эти изменения не попадут в коммит сразу. Применение:
- git stash

- git show
Для просмотра информации о любом git объекте используйте команду git show. Для примера:
- git show

- git fetch
- git fetch позволяет пользователю доставить все объекты из удаленного репозитория, которые не присутствуют в локальном рабочем каталоге. Пример применения:
- git fetch origin

- git ls-tree
Команда git ls-tree используется для просмотра дерева объекта вместе с названием, режимом каждого предмета и значением SHA-1. К примеру:
- git ls-tree HEAD

- git cat-file
Используйте команду git cat-file, чтобы просмотреть тип объекта с помощью SHA-1 значения. Например:
- git cat-file –p d670460b4b4aece5915caf5c68d12f560a9fe3e4

- git grep
- git grep позволяет пользователю проводить поиск фраз и слов в содержимом деревьев. К примеру, для поиска www.hostinger.ru во всех файлах используйте эту команду:
- git grep "www.hostinger.ru"

- gitk
- gitk — это графический интерфейс локального репозитория. Вызвать его можно выполнив данную команду:
- gitk

- git instaweb
С помощью команды git instaweb можно запустить веб-сервер, связанный с локальным репозиторием. Браузер также автоматически будет перенаправляться на него. Например:
- git instaweb –httpd=webrick

- git gc
Для оптимизации репозитория используйте команду git gc. Она поможет удалить и оптимизировать ненужные файлы:
- git gc

- git archive
Команда git archive позволяет пользователю создать .zip или .tar файл содержащий компоненты одного из деревьев репозитория. Например:
- git archive --format=tar master

- git prune
С помощью команды git prune удаляются объекты, не имеющие никаких входящих указателей. Применение:
- git prune

- git fsck
Чтобы выполнить проверку целостности файловой системы git, используйте команду git fsck, при этом будут идентифицированы все поврежденные объекты:
- git fsck

- git rebase
Команда git rebase используется для применения коммитов в другой ветке. Например:
- git rebase master

https://htmlacademy.ru/blog/boost/frontend/first-aid-git

  **[⬆ Наверх](#top)**

9. ### <a name="9"></a> Паттерны проектирования

`Паттерн` - это решение распространенных проблем, возникающих при разработке программного обеспечения - в нашем случае - при написании приложений на JavaScript.

Группы паттернов:

1. Порождающие.
2. Структурные.
3. Поведенческие.

Почему важно знать паттерны?

- Паттерны представляют собой подходы к решению задач в сфере разработки ПО, основанные на опыте большого количества профессиональных разработчиков.
- Паттерны могут быть легко адаптированы для наших нужд.
- Паттерны представляют собой общую схему решения однотипных задач.

`Порождающие дизайн паттерны` - это те паттерны которые позволяют управлять процессом созданния паттернов:
- Конструктор - наиболее частый дизайн паттерн, который позволяет нам создавать новые обьекты определенного типа.
- Фабрика - коолекция элементов похожие по функционалу, необходимо создавать инстенсы у обьектов похожего типа через классы меняя у них значения.
- Прототип - мы можем создавать какие-то обьекты используя как скилет для его прототипа какие-то другие обьекты.
- SingleTon - существует класс в приложение и в приложении может быть только один инстанс данного класса. Используется в базах даных

`Структурные:` эти паттерны отвечают за построение удобных в поддержке иерархий классов.
- Адаптер - это те которые позволяют уже в существующее приложение внедрить новый функционал не ломая его. Он позволяет интегрировать старый интерфейс в новый интерфейс и позволяет им работать совместно при чем не ломая приложение
- Декоратор - с помощью данного патерна мы имеем возможность добавлять новое поведение или функционал для существующих классов.
- Фасад - часто используется, служит для того чтобы создавать более простой и уникальный интерфейс для взаимодействия с различными классами.
- Fleweight - что бы мы могли эффективно передавать и работать с данными через различные типы обьектов. Браузеры используют его что бы избежать повторной загрузки изображений которые были загруженны.
- Proxy - избавление от лишних запросов на сервер

`Поведенческие` позволяют нам улучшить коммуникацию между обьектами разного типа:
- Chain of responsibility - позволяет последовательно у одного и того же обьекта вызывать какой-то набор операций и последовательно их модифицировать.(jQuery)
- Комманд - позволяет создавать определенную абстрактную оболочку над функционалом который позволяет управлять но уже через другой обьект и тем самым записывая определенные состоянии которые были вызваны. (Redux)
- Итератор - идея заключается в том что мы создаем какойто обьект, класс у которого мы можем последовательно получать доступ к определенной информации
- Медиатор - паттерн который в первую очередб позволяет выстраивать очень плотную коммуникацию между различными обьектами разного типа, при этом он предоставляет централизованную абстракцию которая позволяет взаимодействовать группе обьектов через друг друга.
- Observer - формирует зависимости один к многим, идея в том что у нас есть обьект у которго мы можем затригерить вызов изменения, и дальше все другие обьекты которые подписаны на эти изменение они получают эти обновления и делают свой функционал.
- State дизайн паттерн - мы можем создавать различные классы котроые будут элементами Стейта и мы можем делигировать изменеие состояние этих классов на общий класс который будет явлтся стейтом и который будет менять внутренне состояние этих элементов.
- Strategy - позволяет создавать некоторую оболочку для различных интерфейсов для того что бы могли использовать разные алгоритмы, интерфейсы в конкретной задаче. Другими словами определяет семейство некоторых алгоритмов которые наследуют обьекты в неизменяемом порядке.
- Template - определяет некоторый скелет будущего алгоритма но при этом он делигирует создание конкрерного функционала в дочерние классы, тоисть он определяет некоторую структуру а дочерние классы реализовуют конкретный функционал, при этом не изменяя поведение базового класса. 

	
### Примеры
	
`Порождающие дизайн паттерны` - это те паттерны которые позволяют управлять процессом созданния паттернов:
	
- Конструктор - наиболее частый дизайн паттерн, который позволяет нам создавать новые обьекты определенного типа.
```js
// function Server(name, ip) {
//   this.name = name
//   this.ip = ip
// }
//
// Server.prototype.getUrl = function() {
//   return `https://${this.ip}:80`
// }

class Server {
  constructor(name, ip) {
    this.name = name
    this.ip = ip
  }

  getUrl() {
    return `https://${this.ip}:80`
  }
}

const aws = new Server('AWS German', '82.21.21.32')
console.log(aws.getUrl())	
```	
		
- Фабрика - коолекция элементов похожие по функционалу, необходимо создавать инстенсы у обьектов похожего типа через классы меняя у них значения.
```js	
class SimpleMembership {
  constructor(name) {
    this.name = name
    this.cost = 50
  }
}

class StandardMembership {
  constructor(name) {
    this.name = name
    this.cost = 150
  }
}

class PremiumMembership {
  constructor(name) {
    this.name = name
    this.cost = 500
  }
}

class MemberFactory {
  static list = {
    simple: SimpleMembership,
    standard: StandardMembership,
    premium: PremiumMembership
  }

  create(name, type = 'simple') {
    const Membership = MemberFactory.list[type] || MemberFactory.list.simple
    const member = new Membership(name)
    member.type = type
    member.define = function() {
      console.log(`${this.name} (${this.type}): ${this.cost}`)
    }
    return member
  }
}

const factory = new MemberFactory()

const members = [
  factory.create('Vladilen', 'simple'),
  factory.create('Elena', 'premium'),
  factory.create('Vasilisa', 'standard'),
  factory.create('Ivan', 'premium'),
  factory.create('Petr')
]

members.forEach(m => {
  m.define()
})	
```
	
- Прототип - мы можем создавать какие-то обьекты используя как скилет для его прототипа какие-то другие обьекты.
```js
const car = {
  wheels: 4,

  init() {
    console.log(`У меня есть ${this.wheels} колеса, мой владелец ${this.owner}`)
  }
}

const carWithOwner = Object.create(car, {
  owner: {
    value: 'Дмитрий'
  }
})

console.log(carWithOwner.__proto__ === car)

carWithOwner.init()	
```
	
- SingleTon - существует класс в приложение и в приложении может быть только один инстанс данного класса. Используется в базах даных
```js
class Database {
  constructor(data) {
    if (Database.exists) {
      return Database.instance
    }
    Database.instance = this
    Database.exists = true
    this.data = data
  }

  getData() {
    return this.data
  }
}

const mongo = new Database('MongoDB')
console.log(mongo.getData())

const mysql = new Database('MySQL')
console.log(mysql.getData())	
```	

`Структурные:` эти паттерны отвечают за построение удобных в поддержке иерархий классов.
	
- Адаптер - это те которые позволяют уже в существующее приложение внедрить новый функционал не ломая его. Он позволяет интегрировать старый интерфейс в новый интерфейс и позволяет им работать совместно при чем не ломая приложение
```js
class OldCalc {
  operations(t1, t2, operation) {
    switch (operation) {
      case 'add': return t1 + t2
      case 'sub': return t1 - t2
      default: return NaN
    }
  }
}

class NewCalc {
  add(t1, t2) {
    return t1 + t2
  }

  sub(t1, t2) {
    return t1 - t2
  }
}

class CalcAdapter {
  constructor() {
    this.calc = new NewCalc()
  }

  operations(t1, t2, operation) {
    switch (operation) {
      case 'add': return this.calc.add(t1, t2)
      case 'sub': return this.calc.sub(t1, t2)
      default: return NaN
    }
  }
}

const oldCalc = new OldCalc()
console.log(oldCalc.operations(10, 5, 'add'))

const newCalc = new NewCalc()
console.log(newCalc.add(10, 5))

const adapter = new CalcAdapter()
console.log(adapter.operations(25, 10, 'sub'))	
```
	
- Декоратор - с помощью данного патерна мы имеем возможность добавлять новое поведение или функционал для существующих классов.
```js
class Server {
  constructor(ip, port) {
    this.ip = ip
    this.port = port
  }

  get url() {
    return `https://${this.ip}:${this.port}`
  }
}

function aws(server) {
  server.isAWS = true
  server.awsInfo = function() {
    return server.url
  }
  return server
}

function azure(server) {
  server.isAzure = true
  server.port += 500
  return server
}

const s1 = aws(new Server('12.34.56.78', 8080))
console.log(s1.isAWS)
console.log(s1.awsInfo())

const s2 = azure(new Server('98.87.76.12', 1000))
console.log(s2.isAzure)
console.log(s2.url)	
```
	
- Фасад - часто используется, служит для того чтобы создавать более простой и уникальный интерфейс для взаимодействия с различными классами.
```js
class Complaints {
  constructor() {
    this.complaints = []
  }

  reply(complaint) {}

  add(complaint) {
    this.complaints.push(complaint)
    return this.reply(complaint)
  }
}

class ProductComplaints extends Complaints {
  reply({id, customer, details}) {
    return `Product: ${id}: ${customer} (${details})`
  }
}

class ServiceComplaints extends Complaints {
  reply({id, customer, details}) {
    return `Service: ${id}: ${customer} (${details})`
  }
}

class ComplaintRegistry {
  register(customer, type, details) {
    const id = Date.now()
    let complaint

    if (type === 'service') {
      complaint = new ServiceComplaints()
    } else {
      complaint = new ProductComplaints()
    }

    return complaint.add({id, customer, details})
  }
}

const registry = new ComplaintRegistry()

console.log(registry.register('Vladilen', 'service', 'недоступен'))
console.log(registry.register('Elena', 'product', 'вылазит ошибка'))	
```
	
- Fleweight - что бы мы могли эффективно передавать и работать с данными через различные типы обьектов. Браузеры используют его что бы избежать повторной загрузки изображений которые были загруженны.
```js
class Car {
  constructor(model, price) {
    this.model = model
    this.price = price
  }
}

class CarFactory {
  constructor() {
    this.cars = []
  }

  create(model, price) {
    const candidate = this.getCar(model)
    if (candidate) {
      return candidate
    }

    const newCar = new Car(model, price)
    this.cars.push(newCar)
    return newCar
  }

  getCar(model) {
    return this.cars.find(car => car.model === model)
  }
}

const factory = new CarFactory()

const bmwX6 = factory.create('bmw', 10000)
const audi = factory.create('audi', 12000)
const bmwX3 = factory.create('bmw', 8000)

console.log(bmwX3 === bmwX6)	
```
	
- Proxy - избавление от лишних запросов на сервер
```js
function networkFetch(url) {
  return `${url} - Ответ с сервера`
}

const cache = new Set()
const proxiedFetch = new Proxy(networkFetch, {
  apply(target, thisArg, args) {
    const url = args[0]
    if (cache.has(url)) {
      return `${url} - Ответ из кэша`
    } else {
      cache.add(url)
      return Reflect.apply(target, thisArg, args)
    }
  }
})

console.log(proxiedFetch('angular.io'))
console.log(proxiedFetch('react.io'))
console.log(proxiedFetch('angular.io'))	
```	

`Поведенческие` позволяют нам улучшить коммуникацию между обьектами разного типа:
	
- Chain of responsibility - позволяет последовательно у одного и того же обьекта вызывать какой-то набор операций и последовательно их модифицировать.(jQuery)
```js
class MySum {
  constructor(initialValue = 42) {
    this.sum = initialValue
  }

  add(value) {
    this.sum += value
    return this
  }
}

const sum1 = new MySum()
console.log(sum1.add(8).add(10).add(1).add(9).sum)

const sum2 = new MySum(0)
console.log(sum2.add(1).add(2).add(3).sum)	
```
	
- Комманд - позволяет создавать определенную абстрактную оболочку над функционалом который позволяет управлять но уже через другой обьект и тем самым записывая определенные состоянии которые были вызваны. (Redux)
```js
class MyMath {
  constructor(initialValue = 0) {
    this.num = initialValue
  }

  square() {
    return this.num ** 2
  }

  cube() {
    return this.num ** 3
  }
}

class Command {
  constructor(subject) {
    this.subject = subject
    this.commandsExecuted = []
  }

  execute(command) {
    this.commandsExecuted.push(command)
    return this.subject[command]()
  }
}

const x = new Command(new MyMath(2))

console.log(x.execute('square'))
console.log(x.execute('cube'))

console.log(x.commandsExecuted)	
```
	
- Итератор - идея заключается в том что мы создаем какойто обьект, класс у которого мы можем последовательно получать доступ к определенной информации
```js
class MyIterator {
  constructor(data) {
    this.index = 0
    this.data = data
  }

  [Symbol.iterator]() {
    return {
      next: () => {
        if (this.index < this.data.length) {
          return {
            value: this.data[this.index++],
            done: false
          }
        } else {
          this.index = 0
          return {
            done: true,
            value: void 0
          }
        }
      }
    }
  }
}

function* generator(collection) {
  let index = 0

  while (index < collection.length) {
    yield collection[index++]
  }
}


const iterator = new MyIterator(['This', 'is', 'iterator'])
const gen = generator(['This', 'is', 'iterator'])

// for (const val of gen) {
//   console.log('Value: ', val)
// }

console.log(gen.next().value)
console.log(gen.next().value)
console.log(gen.next().value)	
```
	
- Медиатор - паттерн который в первую очередб позволяет выстраивать очень плотную коммуникацию между различными обьектами разного типа, при этом он предоставляет централизованную абстракцию которая позволяет взаимодействовать группе обьектов через друг друга.
```js
class User {
  constructor(name) {
    this.name = name
    this.room = null
  }

  send(message, to) {
    this.room.send(message, this, to)
  }

  receive(message, from) {
    console.log(`${from.name} => ${this.name}: ${message}`)
  }
}

class ChatRoom {
  constructor() {
    this.users = {}
  }

  register(user) {
    this.users[user.name] = user
    user.room = this
  }

  send(message, from, to) {
    if (to) {
      to.receive(message, from)
    } else {
      Object.keys(this.users).forEach(key => {
        if (this.users[key] !== from) {
          this.users[key].receive(message, from)
        }
      })
    }
  }
}

const vlad = new User('Vladilen')
const lena = new User('Elena')
const igor = new User('Igor')

const room = new ChatRoom()

room.register(vlad)
room.register(lena)
room.register(igor)

vlad.send('Hello!', lena)
lena.send('Hello hello!', vlad)
igor.send('Vsem privet')	
```
	
- Observer - формирует зависимости один к многим, идея в том что у нас есть обьект у которго мы можем затригерить вызов изменения, и дальше все другие обьекты которые подписаны на эти изменение они получают эти обновления и делают свой функционал.
```js
class Subject {
  constructor() {
    this.observers = []
  }

  subscribe(observer) {
    this.observers.push(observer)
  }

  unsubscribe(observer) {
    this.observers = this.observers.filter(obs => obs !== observer)
  }

  fire(action) {
    this.observers.forEach(observer => {
      observer.update(action)
    })
  }
}

class Observer {
  constructor(state = 1) {
    this.state = state
    this.initialState = state
  }

  update(action) {
    switch (action.type) {
      case 'INCREMENT':
        this.state = ++this.state
        break
      case 'DECREMENT':
        this.state = --this.state
        break
      case 'ADD':
        this.state += action.payload
        break
      default:
        this.state = this.initialState
    }
  }
}

const stream$ = new Subject()

const obs1 = new Observer()
const obs2 = new Observer(42)

stream$.subscribe(obs1)
stream$.subscribe(obs2)

stream$.fire({type: 'INCREMENT'})
stream$.fire({type: 'INCREMENT'})
stream$.fire({type: 'DECREMENT'})
stream$.fire({type: 'ADD', payload: 10})

console.log(obs1.state)
console.log(obs2.state)	
```
	
- State дизайн паттерн - мы можем создавать различные классы котроые будут элементами Стейта и мы можем делигировать изменеие состояние этих классов на общий класс который будет явлтся стейтом и который будет менять внутренне состояние этих элементов.
```js
class Light {
  constructor(light) {
    this.light = light
  }
}

class RedLight extends Light {
  constructor() {
    super('red')
  }

  sign() {
    return 'СТОП'
  }
}

class YellowLight extends Light {
  constructor() {
    super('yellow')
  }

  sign() {
    return 'ГОТОВЬСЯ'
  }
}

class GreenLight extends Light {
  constructor() {
    super('green')
  }

  sign() {
    return 'ЕДЬ!'
  }
}

class TrafficLight {
  constructor() {
    this.states = [
      new RedLight(),
      new YellowLight(),
      new GreenLight()
    ]
    this.current = this.states[0]
  }

  change() {
    const total = this.states.length
    let index = this.states.findIndex(light => light === this.current)

    if (index + 1 < total) {
      this.current = this.states[index + 1]
    } else {
      this.current = this.states[0]
    }
  }

  sign() {
    return this.current.sign()
  }
}

const traffic = new TrafficLight()
console.log(traffic.sign())
traffic.change()

console.log(traffic.sign())
traffic.change()

console.log(traffic.sign())
traffic.change()

console.log(traffic.sign())
traffic.change()

console.log(traffic.sign())
traffic.change()

console.log(traffic.sign())
traffic.change()	
```
	
- Strategy - позволяет создавать некоторую оболочку для различных интерфейсов для того что бы могли использовать разные алгоритмы, интерфейсы в конкретной задаче. Другими словами определяет семейство некоторых алгоритмов которые наследуют обьекты в неизменяемом порядке.
```js
class Vehicle {
  travelTime() {
    return this.timeTaken
  }
}

class Bus extends Vehicle {
  constructor() {
    super()
    this.timeTaken = 10
  }
}

class Taxi extends Vehicle {
  constructor() {
    super()
    this.timeTaken = 5
  }
}

class Car extends Vehicle {
  constructor() {
    super()
    this.timeTaken = 3
  }
}

class Commute {
  travel(transport) {
    return transport.travelTime()
  }
}

const commute = new Commute()

console.log(commute.travel(new Taxi()))
console.log(commute.travel(new Bus()))
console.log(commute.travel(new Car()))			  
```
			  
- Template - определяет некоторый скелет будущего алгоритма но при этом он делигирует создание конкрерного функционала в дочерние классы, тоисть он определяет некоторую структуру а дочерние классы реализовуют конкретный функционал, при этом не изменяя поведение базового класса.
```js
class Employee {
  constructor(name, salary) {
    this.name = name
    this.salary = salary
  }

  responsibilities() {}

  work() {
    return `${this.name} выполняет ${this.responsibilities()}`
  }

  getPaid() {
    return `${this.name} имеет ЗП ${this.salary}`
  }
}

class Developer extends Employee {
  constructor(name, salary) {
    super(name, salary)
  }

  responsibilities() {
    return 'процесс создания программ'
  }
}

class Tester extends Employee {
  constructor(name, salary) {
    super(name, salary)
  }

  responsibilities() {
    return 'процесс тестирования'
  }
}

const dev = new Developer('Владилен', 100000)
console.log(dev.getPaid())
console.log(dev.work())

const tester = new Tester('Виктория', 90000)
console.log(tester.getPaid())
console.log(tester.work())			  
```			  	
	
https://medium.com/@marina.kovalyova/java-script-design-patterns-569c627d25f9	
	
https://refactoring.guru/ru/design-patterns/catalog	
	
https://proglib.io/p/js-design-patterns/

  **[⬆ Наверх](#top)**

10. ### <a name="10"></a> Структуры данных. Алгоритмы поиска, Сортировки. Сложность алгоритма

*Структура данных* — это контейнер, который хранит данные в определенном макете. Макет определяет эффективность и неэффективность структуры данных по отношению к определенным операциям.

- *Массивы* Одномерные, многомерные. Последовательные. Легко обращаться к необходимым элементам по их индексам.
- *Стеки* Список элементов, организованных по принципу “последним вошел, первый вышел”
- *Очереди* Список элементов, организованных по принципу “первым вошел, первым вышел”.
- *Связный список* Однонаправленный, двунаправленный, круговой. это цепочечная структура данных, где каждый узел состоит из двух частей: данных узла и указателя на следующий узел.
- *Графы*
- *Деревья*

Возможно еще структуры дынных:
- Array (структура данных которая содержит в себе список однотипных элементов)
- Object (Описываем один обьект - персонаж: имя, фамилия, вес)
- Set (похож на массив но не может содержать в себе одинковые элементы)
- Map (аналогия обьекта но усовершенсвованее, мы храним данные как ключ и значение, однако ключем может быть что угодно, Map добавляет удобный интерфейс для работы с этими данними, много рахных методов)
- WeckMap
- WeakSet
- Матрица (Matrix)
- Связный список (Linked list)
- Стек (Stack)
- Очередь (Queue)
- Дерево (Tree)
- Куча (Heap)
- Префиксное дерево (Prefix tree)
- Хеш-таблица (Hash table)

https://robotdreams.cc/blog/58-structure-your-data-please

	
	
*Алгоритм* это набор последовательных действий, которые решают какую-то задачу, в принципи любой фрагмент кода можно назвать алгоритмом.

### Линейный поиск - сложность O(n), где n - колличество элементов в массиве.
	
Просматривайте все один за другим, пока не найдете это». Если элементов в миллион раз больше, это займет в миллион раз больше времени, и это может привести к долгому выполнению или даже зависанию браузера. 
```js
const array = [1,4,5,8,5,1,2,7,5,2,11]
let count = 0
function linearSearch(array, item) {
    for (let i = 0; i < array.length; i++) {
        count += 1
        if (array[i] === item) {
            return i;
        }
    }
    return null
}

console.log(linearSearch(array, 1))
console.log('count = ', count)	
```	
		
	
### Бинарный поиск - сложность O(log2n)				   
				     
Массив отсортированный по порядку, делим массив пополам, смотрим в какой части массива находится искомый обьект, потом делим и его пополам, пока не найдем наш обьект.
				     
```js
const array = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]
let count = 0

function binarySearch(array, item) {
    let start = 0
    let end = array.length
    let middle;
    let found = false
    let position = -1
    while (found === false && start <= end) {
        count+=1
        middle = Math.floor((start + end) / 2);
        if (array[middle] === item) {
            found = true
            position = middle
            return position;
        }
        if (item < array[middle]) {
            end = middle - 1
        } else {
            start = middle + 1
        }
    }
    return position;
}
				 
console.log(binarySearch(array, item))
console.log(count)				 
```				     

				 
### Рекурсивный бинарный поиск - сложность Olog2n				 

```js
function recursiveBinarySearch(array, item, start, end) {
    let middle = Math.floor((start + end) / 2);
    count += 1
    if (item === array[middle]) {
        return middle
    }
    if (item < array[middle]) {
        return recursiveBinarySearch(array, item, 0, middle - 1 )
    } else {
        return recursiveBinarySearch(array, item, middle + 1, end )
    }
}

console.log(recursiveBinarySearch(array, 0, 0, array.length))
console.log(count)				 
```				 				 
				 

### Сортировка выбором - сложность O(n^2)
				 
В основе сортировки выбором лежит следующий подход: мы находим минимальное значение в структуре данных и помещаем его на первую позицию, затем находим второе минимальное значение и помещаем его на вторую позицию и так далее.
				 
```js
const arr = [0,3,2,5,6,8,1,9,4,2,1,2,9,6,4,1,7,-1, -5, 23,6,2,35,6,3,32] // [0,1,1,2,3.......]
let count = 0

function selectionSort(array) {
    for (let i = 0; i < array.length; i++) {
        let indexMin = i
        for (let j = i+1; j < array.length; j++) {
            if (array[j] < array[indexMin]) {
                indexMin = j
            }
            count += 1
        }
        let tmp = array[i]
        array[i] = array[indexMin]
        array[indexMin] = tmp
    }
    return array
}

console.log(selectionSort(arr))
console.log(arr.length) // O(n*n)
console.log('count = ', count)				 
```				 				 

	
### Сортировка пузырьком - O(n*n)
	
Если говорить коротко, алгоритм сортировки пузырьком сравнивает два соседних значения и меняет их местами, если первое значение больше второго. Значения как бы всплывают подобно пузырькам воздуха в воде, выстраиваясь в восходящем порядке.
	
```js
const arr = [0,3,2,5,6,8,23,9,4,2,1,2,9,6,4,1,7,-1, -5, 23,6,2,35,6,3,32,9,4,2,1,2,9,6,4,1,7,-1, -5, 23,9,4,2,1,2,9,6,4,1,7,-1, -5, 23,]
let count = 0

function bubbleSort(array) {
    for (let i = 0; i < array.length; i++) {
        for (let j = 0; j < array.length; j++) {
            if (array[j + 1] < array[j]) {
                let tmp = array[j]
                array[j] = array[j+1]
                array[j+1] = tmp
            }
            count+=1
        }
    }
    return array
}

console.log('length', arr.length)
console.log(bubbleSort(arr)) // O(n*n)
console.log('count = ', count)	
```	
	

### Быстрая сортировка - сложность O(log2n*n)
					
- Выбираем значение в массиве, которое назовем опорным. Обычно это значение в середине массива.
- Осуществляем операцию распределения, в результате которой значения меньше опорного смещаются влево от опорного, а большие — вправо от него.
- Повторяем первые два шага для каждого подмассива (левого и правого), пока массивы не будут полностью отсортированы.

```js
const arr = [0,3,2,5,6,8,23,9,4,2,1,2,9,6,4,1,7,-1, -5, 23,6,2,35,6,3,32,9,4,2,1,2,9,6,4,1,7,-1, -5, 23,9,4,2,1,2,9,6,4,1,7,-1, -5, 23,]
let count = 0

function quickSort(array) {
    if (array.length <= 1) {
        return array
    }
    let pivotIndex = Math.floor(array.length / 2);
    let pivot = array[pivotIndex]
    let less = []
    let greater = []
    for (let i = 0; i < array.length; i++) {
        count += 1
        if(i === pivotIndex)
            continue
        if (array[i] < pivot) {
            less.push(array[i])
        } else {
            greater.push(array[i])
        }
    }
    return [...quickSort(less), pivot, ...quickSort(greater)]
}

console.log(quickSort(arr))
console.log('count', count)					
```					
															
https://tproger.ru/articles/computational-complexity-explained/


### Рекурсия					
					
*Рекурсия это функция которая вызывает сама себя*

```js
const factorial = (n) => {
    if (n === 1) {
        return 1
    }
    return n * factorial(n - 1)
}
	
console.log(factorial(5))	

	
	
// Числа фибоначчи -  1,1,2,3,5,8,13,21

const fibonachi = (n) => {
    if (n === 1 || n === 2) {
        return 1
    }
    return fibonachi(n-1) + fibonachi(n-2)
}

console.log(fibonachi(8))					
```					
					
					
					

### Big O (оценка сложности алгоритмов)

Big O - относительное представления сложности алгоритма, показывает как будет меняться производительность алгоритма в зависимости от роста входящий данных	
	
Нужна для описания сложности алгоритмов, используя понятие времени. В Big O нотации всегда рассматривается худший вариант — искомый элемент может быть самым последним.

- Константная сложность (О1): Получение элемента коллекции это O(1). Будь то получение по индексу в массиве, или по ключу в словаре в нотации Big O это будет O(1).
- Линейная сложность: Перебор коллекции это O(n).
- Квадратичная сложность: Вложенные циклы по той же коллекции это O(n^2).
- Логарифмическая сложность: Разделяй и властвуй (Divide and Conquer) всегда O(log n).
- Merge sort, для маленьких массивов используется Inserted Sort: Итерации которые используют Divide and Conquer это O(n log n).
- Кубическая сложность O(n^3) 
- Экспоненциальная сложность O(2^n)
- Факториальная сложность O(n!)	
	
![49](https://user-images.githubusercontent.com/80325645/130518255-1de96431-96be-481a-be09-e1745fa98398.jpg)

	
### Структуры данных
	
- Графы
	
```js
// Поиск в ширину в графе

const graph = {}
graph.a = ['b', 'c']
graph.b = ['f']
graph.c = ['d', 'e']
graph.d = ['f']
graph.e = ['f']
graph.f = ['g']

function breadthSearch(graph, start, end) {
    let queue = []
    queue.push(start)
    while (queue.length > 0) {
        const current = queue.shift()
        if (!graph[current]) {
            graph[current] = []
        }
        if (graph[current].includes(end)) {
            return true
        } else {
            queue = [...queue, ...graph[current]]
        }
    }
    return false
}

console.log(breadthSearch(graph, 'a', 'e'))	
```
	
- Матрица смежности
```js
const matrix = [
    [0,1,1,0,0,0,0],
    [0,0,0,0,1,0,0],
    [0,0,0,1,0,1,0],
    [0,0,0,0,1,0,0],
    [0,0,0,0,0,0,1],
    [0,0,0,0,1,0,0],
    [0,0,0,0,0,0,0],
]
```	

	
- Алгоритм дейкстры (Графы)
	
```js
// Поиск кратчайшего пути в графе

const graph = {}
graph.a = {b: 2, c: 1}
graph.b = {f: 7}
graph.c = {d: 5, e: 2}
graph.d = {f: 2}
graph.e = {f: 1}
graph.f = {g: 1}
graph.g = {}

function shortPath(graph, start, end) {
    const costs = {}
    const processed = []
    let neighbors = {}
    Object.keys(graph).forEach(node => {
        if (node !== start) {
            let value = graph[start][node]
            costs[node] = value || 100000000
        }
    })
    let node = findNodeLowestCost(costs, processed)
    while (node) {
        const cost = costs[node]
        neighbors = graph[node]
        Object.keys(neighbors).forEach(neighbor => {
            let newCost = cost + neighbors[neighbor]
            if (newCost < costs[neighbor]) {
                costs[neighbor] = newCost
            }
        })
        processed.push(node)
        node = findNodeLowestCost(costs, processed)
    }
    return costs
}


function findNodeLowestCost(costs, processed) {
    let lowestCost = 100000000
    let lowestNode;
    Object.keys(costs).forEach(node => {
        let cost = costs[node]
        if (cost < lowestCost && !processed.includes(node)) {
            lowestCost = cost
            lowestNode = node
        }
    })
    return lowestNode
}

console.log(shortPath(graph, 'a', 'g'));	
```	

			     
- Деревья
			     
```js
const tree = [
    {
        v: 5,
        c: [
            {
                v:10,
                c: [
                    {
                        v:11,
                    }
                ]
            },
            {
                v:7,
                c: [
                    {
                        v:5,
                        c: [
                            {
                                v:1
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        v: 5,
        c: [
            {
                v:10
            },
            {
                v:15
            }
        ]
    }
]

			     
			     
			     
const recursive = (tree) => {
    let sum = 0;
    tree.forEach(node => {
        sum += node.v
        if(!node.c) {
            return node.v
        }
        sum += recursive(node.c)
    })
    return sum
}

const iteration = (tree) => {
    if (!tree.length) {
        return 0
    }
    let sum = 0
    let stack = []
    tree.forEach(node => stack.push(node));
    while (stack.length) {
        const node = stack.pop()
        sum += node.v
        if (node.c) {
            node.c.forEach(child => stack.push(child))
        }
    }
    return sum
}

console.log(iteration(tree))
// console.log(recursive(tree))			     
```			     

*Стек* - элементы всегда добавляются в конец структуры, и извлекаються с конца. это как стопка бумаги, последный лист положил - последний  лист взял
	
	
	
- Кеш
	
```js
function cashFunction(fn) {
    const cash = {}
    return function (n) {
        if (cash[n]) {
            console.log('Взято из кеша', cash[n])
            return cash[n]
        }
        let result = fn(n)
        console.log('Посчитала функция = ', result)
        cash[n] = result
        return result;
    };
}

function factorial(n) {
    let result = 1
    while (n != 1) {
        result *= n
        n -= 1
    }
    return result
}

const cashFactorial = cashFunction(factorial)

cashFactorial(5)
cashFactorial(4)
cashFactorial(3)
cashFactorial(4)
cashFactorial(5)
cashFactorial(1)	
```	

			
- Связный список
	
```js
class LinkedList {
    constructor() {
        this.size = 0
        this.root = null
    }

    add(value) {
        if (this.size === 0) {
            this.root = new Node(value);
            this.size += 1;
            return true;
        }
        let node = this.root
        while (node.next) {
            node = node.next
        }
        let newNode = new Node(value)
        node.next = newNode
        this.size += 1
    }

    getSize() {
        return this.size
    }

    print() {
        let result = []
        let node = this.root
        while (node) {
            result.push(node.value)
            node = node.next
        }
        console.log(result);;
    }
}

class Node {
    constructor(value) {
        this.value = value
        this.next = null
    }
}

const list = new LinkedList()
list.add(5)
list.add(3)
list.add(2)
list.add(5)
list.add(7)

list.print()	
```	

	
- Бинарное дерево
	
```js
class BinaryTree {
    constructor() {
        this.root = null
    }

    add(value) {
        if (!this.root) {
            this.root = new TreeNode(value)
        } else {
            let node = this.root
            let newNode = new TreeNode(value)
            while (node) {
                if (value > node.value) {
                    if (!node.right) {
                        break
                    }
                    node = node.right
                } else {
                    if (!node.left) {
                        break
                    }
                    node = node.left
                }
            }
            if (value > node.value) {
                node.right = newNode
            } else {
                node.left = newNode
            }
        }
    }

    print(root = this.root) {
        if (!root) {
            return true;
        }
        console.log(root.value);
        this.print(root.left)
        this.print(root.right)
    }
}

class TreeNode {
    constructor(value) {
        this.value = value
        this.left = null
        this.right = null
    }
}

const tree = new BinaryTree()
tree.add(5)
tree.add(2)
tree.add(6)
tree.add(2)
tree.add(1)
tree.print()	
```	

	
- Set(хранит уникальные значения) & Map
	
Ключ - значение	

```js
const map = new Map()
const objKey = {id:5}
map.set(objKey, "ulbi tv")

console.log(map.get(objKey));

const set = new Set()

set.add(5)
set.add(5)
set.add(5)
set.add(5)
set.add(5)
set.add(4)
set.add(3)
console.log(set)	
```	
	
	
  **[⬆ Наверх](#top)**

11. ### <a name="11"></a> Unit-tests

*Unit-тесты* — это код, позволяющий проверить на корректность отдельные модули исходного кода. Тесты пишутся для каждой нетривиальной функции.

Юнит-тест — это код, который тестирует юниты (части) кода: функции, модули или классы. ... Вся суть — подать что-то на вход юнита и 

Преимущества юнит-тестирования очевидны:

- Являются низкоуровневым и фокусируется на маленькой части ПО
- Тесты пишут сами разработчики
- Тесты выполняются очень быстро, можно выполнять тесты несколько раз в минуту
- При разработке можно выполнять не все тесты, а только те, которые необходимы именно вам

Таким образом, при использовании юнит тестирования скорость разработки существенно не уменьшается, но при этом возрастает качество самого продукта.

Важное различия в юнит тестировании, это какой тип тестирования вы выберите: Solitary (одинокий) и Sociable (общительный) тест.

Sociable (общительный) тест — это тест который использует реальные методы (или классы), которые входят в тестируемую единицу. Например, вы тестируете метод «цена» из класса заказов. Методу «цена» необходимо вызвать методы из класса клиент и продукт. В данном виде тестов будут вызваны именно эти методы, и ошибка в этих методах приведет к ошибке теста. Методы из классов клиент и продукт называется партнеры (collaborators).

Solitary (одинокий) тест — это тест, который в качестве партнеров использует дубли (TestDouble). Тест-дубли — это общий термин для любого случая, в котором вы заменяете реальный объект, исключительно для целей тестирования.

TDD (**T**est-**D**riven **D**evelopment) — подход к разработке и тестированию, при котором сначала создаются тесты, которым должен удовлетворять код и только потом его реализация. TDD — процесс итеративный. Добавляя в класс что то новое, вы сначала пишите тест на новый функционал и только потом создаете минимальное количество кода, реализующее нужное поведение.

BDD (**B**ehavior-**D**riven **D**evelopment) — расширение подхода TDD к разработке и тестированию, при котором особое внимание уделяется поведению системы/модуля в терминах бизнеса (заказчика). Как правило, такие тесты иллюстрируют и тестируют различные сценарии, которые интересны непосредственно клиенту системы.

https://habr.com/ru/post/336030/

«Пирамида тестов» — метафора, которая означает группировку тестов программного обеспечения по разным уровням детализации. Она также даёт представление, сколько тестов должно быть в каждой из этих групп.

![44](https://user-images.githubusercontent.com/80325645/121665800-41639700-cab1-11eb-85ff-ed4d46928420.jpg)

Оригинальная пирамида тестов Майка Кона состоит из трёх уровней (снизу вверх):

- Юнит-тесты.
- Сервисные тесты.
- Тесты пользовательского интерфейса.

### Рекомендуемые инструменты

Jest — исполнитель тестов на JavaScript, который позволяет взаимодействовать с DOM через jsdom. Несмотря на то, что jsdom только приблизительно реализует работу браузера, в большинстве случаев этого достаточно для тестирования React-компонентов. Jest предлагает отличную скорость итераций вместе с мощными возможностями, например фиктивные модули и таймеры, которые дают больше контроля над исполнением кода.

React Testing Library — это набор вспомогательных функций, позволяющий тестировать React-компоненты не полагаясь на их внутреннюю реализацию. Такой подход упрощает рефакторинг, а также подталкивает вас применять лучшие практики по улучшению доступности. Несмотря на то, что библиотека не позволяет делать «поверхностный» рендер компонента без дочерних компонентов, исполнители тестов, например, Jest позволяет это сделать через фиктивные модули.

  **[⬆ Наверх](#top)**

12. ### <a name="12"></a> Оценка скорости приложения - Google Lighthouse

Google Lighthouse — это инструмент аудита с открытым исходным кодом, который помогает разработчикам повысить производительность и доступность своих веб-проектов. Любой желающий может использовать его бесплатно, чтобы увидеть, как его веб-сайт соответствует высоким стандартам Google в веб разработке.

Lighthouse расскажет вам, насколько ваш веб-сайт соответствует стандартам Google. В отчете будут объяснены сильные и слабые стороны вашего сайта, а также предложены способы повысить его оценку.

https://webdevblog.ru/ispolzovanie-google-lighthouse-dlya-audita-veb-prilozhenij/

  **[⬆ Наверх](#top)**

13. ### <a name="13"></a> Основные модели SDLC

Жизненный цикл разработки программного обеспечения — это методология, которая описывает, как вам следует подходить к разработке программного обеспечения. Этот процесс гарантирует, что вы создаёте программное обеспечение в правильном порядке, и помогает сделать разработку более эффективной.

*Как работает SDLC?*

Жизненный цикл разработки программного обеспечения состоит из семи этапов, описывающих, как следует разрабатывать программный проект. Хотя у каждого есть своё имя для каждой стадии SDLC, вот основные темы, которые вы увидите на протяжении жизненного цикла:

- Анализ и планирование.
- Дизайн.
- Развитие.
- Тестирование.
- Развёртывание.
- Обслуживание и оценка.


### Этап 1: Анализ и планирование

Прежде чем вы сможете разработать проект или создать для него функцию, вам сначала нужно знать, что вы собираетесь построить. Какие особенности должен иметь проект? Каких функций у него не должно быть
 
Хотя многие люди рассматривают разработку программного обеспечения как простое кодирование, на самом деле это гораздо больше, чем просто ввод кода. Вам нужно будет определить объём и границы проекта, прежде чем вы начнёте писать код. Здесь вы поймёте, что вы собираетесь построить и почему.

Читайте также:  Ansible или Puppet: какой из клиентских серверов с открытым исходным кодом лучший?
На этапе анализа и планирования вы будете работать со всеми заинтересованными сторонами проекта — от руководителей до других разработчиков и клиентов — чтобы обеспечить разработку соответствующих спецификаций проекта. Вам необходимо убедиться, что проект соответствует не только ожиданиям клиентов, но и целям вашего собственного бизнеса.


### Этап 2: Дизайн

Итак, у вас есть план того, что вы хотите построить. Теперь вы должны спросить себя: как мы выполним этот план? Как мы собираемся создавать выявленные нами особенности?

Следующим этапом SDLC является этап проектирования. Именно здесь вы будете решать, как должны быть реализованы функции. Работая со всеми заинтересованными сторонами, чтобы ваши планы соответствовали их потребностям.

Работа с другими важна на каждом этапе SDLC, но особенно на этапе проектирования. Вы можете понять, что вам нужно создать, но, если вы не получите мнение всех заинтересованных сторон, ваш дизайн может не соответствовать всем требованиям.


### Этап 3: Разработка

После планирования и проектирования вы готовы приступить к разработке. Здесь вы откроете терминал и текстовый редактор, чтобы начать работу над проектом. Вы потратите много времени на создание всех функций, согласованных в ходе предыдущих обсуждений.

Разработка — это не только написание кода. На этом этапе вам необходимо встретиться с другими разработчиками, чтобы распределить работу и обсудить, кто лучше всего подходит для решения конкретных проблем. Скорее всего, вы разработаете процесс, который поможет вам эффективно писать код в команде.


### Этап 4: Тестирование

Вы сделали тяжёлую работу, и функции, необходимые для создания, готовы, но вы ещё не закончили. Что делать, если ваш код содержит ошибки? Или что, если ваш проект не работает в данном пограничном случае?
 
Здесь вступает в игру фаза тестирования. Вам нужно будет определить, какие проблемы существуют в вашем коде, и создать решения этих проблем, чтобы конечный продукт соответствовал спецификациям, изложенным на этапе анализа.


### Этап 5: Развёртывание

Готовый продукт готов. Вы протестировали код и убедились, что конечный продукт соответствует всем исходным спецификациям. Теперь вы готовы начать развёртывание проекта.
 
Здесь вы перенесёте разработанное вами программное обеспечение из среды тестирования в рабочую среду. Например, с помощью веб-приложения вы можете переместить свой код на работающий веб-сервер, на котором размещён ваш веб-сайт; с игрой вы можете опубликовать свой код в игровом магазине.


### Этап 6: Обслуживание и оценка

Хотя планирование является важной частью SDLC, вы обнаружите, что потребности проекта со временем изменятся. Возможно, пользователи просят добавить другую функцию или обновить библиотеки, чтобы продукт по-прежнему работал с использованием новейших инструментов.

После публикации проекта вы будете отвечать за его поддержку. Часто разработчики используют инструменты мониторинга производительности приложений, чтобы убедиться, что их код работает эффективно. Если разработчики не поддерживают свои приложения, они могут стать нестабильными и перестать соответствовать исходным требованиям проекта. Это вредно для деловых отношений.


*Методология разработки программного обеспечения (SDLC)* представляет собой последовательность действий, которые необходимо выполнить, чтобы получить готовое решение. Проще говоря, это способ создания программного продукта. Проблема в том, что существует множество моделей SDLC, которые используются для разных типов проектов. 

### Каскадная модель (waterfall)

Это линейная и последовательная модель разработки программного обеспечения, в которой фазы проекта следуют одна за другой и включают:

- Исследование. Группа разработчиков собирает требования к проекту и включает их в документ «Спецификации требований к программному обеспечению» (SRS).
- Дизайн. Команда анализирует все требования и выкатывает прототип системы.
- Кодирование. Как только заинтересованные стороны проекта согласовывают прототип, начинается фаза написания кода.
- Тестирование. Команда QA запускает каждый модуль через различные сценарии тестирования и интегрирует их в систему. Как только все компоненты на месте, они тестируют систему целиком.
- Развертывание. Решение доставляется заказчику в полностью рабочем состоянии.
- Обслуживание. Команда разработчиков следит за проектом и при необходимости вносит обновления.

*Каким проектам подходит*

Каскадная модель – хороший вариант, если выполняются эти условия:

- Проект короткий и с нулевым риском.
- Требования фиксированные.
- Технологии стабильны.
- Доступны все необходимые ресурсы.


### V-образная модель SDLC

V-образная модель – это своего рода другая версия каскада, но в её основе лежит контроль качества каждой фазы. Например, когда группа разработчиков собирает требования к проекту, QA-специалисты пишут приемочные тесты на основе этих сценариев.

*Каким проектам подходит*

V-образная модель может быть чрезвычайно полезна в случаях, когда ошибки могут быть фатальными, и в проектах, где точность имеет решающее значение. Например, это решение, основанное на нормативных требованиях, таких как подача налоговых деклараций. Кроме того, эта модель подходит для проектов в сфере здравоохранения.


### Модель эволюционного прототипирования

Это ещё одна вариация каскада. Пока проект проходит через традиционные фазы, прототип продукта пошагово дорабатывается на основе отзывов клиентов. Как правило, первый прототип не проходит приемочный тест, поэтому модель прототипирования включает в себя несколько прототипов.

*Каким проектам подходит*

Модель эволюционного прототипирования может быть полезна для проектов, которые предполагают взаимодействие с пользователем, используют новые технологии, имеют сложную функциональность или должны учитывать быстро меняющиеся требования, которые трудно или невозможно предсказать.


### Итеративная и инкрементальная модель

В инкрементальной и итеративной модели решение разрабатывается небольшими частями через серию циклов. Рабочий процесс выглядит следующим образом:

- Планирование. Собираются все требования к проекту и делятся на составляющие.
- Реализация модулей. Каждая итерация представляет собой «мини-каскад», который имеет такой же процесс: анализ требований модуля, проектирование, реализация и тестирование модулей, интеграция и тестирование всей системы, выпуск версии и оценка. Процесс повторяется до тех пор, пока не будут выполнены все требования.

*Каким проектам подходит*

Модель будет эффективна в следующих случаях:

- Если система состоит из нескольких сегментов с чёткими требованиями.
- Ограниченные ресурсы на проекте или есть ограничения по времени выхода решения на рынок.
- Для стартапов, проходящих инвестиционные раунды.
- Масштабные проекты.
- Проекты, в основе которых новые технологии.
- Проекты, которые потребуется развивать после выпуска.


### Спиральная модель

Этот подход основан на оценке риска, он сочетает в себе функции каскадной, прототипной, итеративной и инкрементной моделей. Модель похожа на спираль с несколькими кругами. Каждый круг – это фаза, состоящая из четырёх элементов:

- Сбор требований. Он включает выявление и анализ потребностей заинтересованных сторон и бизнес-целей.
- Анализ рисков и прототипирование. Команда оценивает все возможные способы удовлетворения потребностей клиентов и выбирает лучшее решение. Затем они выявляют и устраняют риски, связанные с решением, и создают прототип, который развивается с каждым последующим циклом.
- Инжиниринг. Команда инженеров продолжает разработку и тестирование того, что было запланировано на двух предыдущих этапах.
- Планирование следующего этапа. Готовый продукт отправляется заказчику для получения обратной связи. Кроме того, команда разработчиков анализирует весь цикл с точки зрения расписания, бюджета и других критериев.

*Каким проектам подходит*

Спиральная модель подходит для:

- Больших, сложных продуктов, состоящих из нескольких компонентов.
- Проектов с частыми релизами.
- Проектов средней и высокой степени риска.
- Проектов с неясными требованиями.


### Модели гибкой разработки программного обеспечения

Вопреки распространённому мнению Agile не является ни структурой, ни методологией. Это философия с набором принципов, ориентированных на ускорение процесса разработки программного обеспечения, обеспечение 100% удовлетворённости клиентов и предоставление высококачественных решений в быстро меняющейся среде. Фактически, существует 12 принципов гибкой разработки, которые сводятся к следующим ценностям:

- Люди и взаимодействие важнее процессов и инструментов.
- Рабочее программное обеспечение над обширной документацией.
- Сотрудничество с клиентами вместо переговоров по контракту.
- Реагирование на изменения вместо следования плану.


### Scrum

Скрам-проекты разбиты на спринты. Спринт – это небольшой объём работы, который необходимо выполнить в течение определённого периода времени. Обычно заказчику доставляется часть проекта, которая была завершена во время спринта (инкремент продукта, от англ. increment). Скрам подразумевает активное общение и сотрудничество между всеми участниками проекта. Наряду с ежедневными 15-минутными встречами разработчиков, есть также:

- Планирование спринта, когда заинтересованные стороны проекта и команда разработчиков встречаются, чтобы обсудить, что нужно сделать во время следующего спринта.
- Обзор спринта, когда команда разработчиков демонстрирует заинтересованным сторонам, что было сделано во время спринта, и анализируется прогресс в достижении цели проекта.
- Ретроспектива спринта, когда команда разработчиков анализирует спринт и обсуждает, как можно улучшить процессы во время следующих спринтов.

Сердце процессов Scrum – это backlog, своего рода список задач, которые необходимо сделать для завершения проекта. По мере того, как проект продвигается, и команда узнаёт о нём больше, они редактируют бэклог продукта, добавляя, удаляя и переупорядочивая его элементы. Тем не менее, нельзя сделать что-то, если этого нет в очереди продукта.


  **[⬆ Наверх](#top)**

14. ### <a name="14"></a> Предоставление оценок усилий, необходимых для выполнения задач на основе заданной WBS

Структурной декомпозицией работ (Work Breakdown Structure) называют представление проекта, исполненное в виде иерархической структуры работ, что достигается посредством последовательной декомпозиции. Инструмент направлен на детальное планирование, оценку стоимости, определение и распределение персональной ответственности исполнителей и т. д. – то есть, на основные работы и результаты, определяющие содержание проекта

Декомпозиция — разделение на части или категории, выделение простых составляющих.

### Зачем нужна WBS

WBS – крайне полезная вещь в планировании проекта и вот почему:

- WBS – если не единственный, но точно самый эффективный способ наглядно отразить весь объем проекта.
- WBS фокусирует внимание не на процессе а на ожидаемом результате, и создает нужный «посыл».
- В идеале в разработке WBS участвует заказчик или его представитель и вся команда, что позволяет а) обеспечить единое понимание результатов проекта и его объема б) увидеть важность и вклад отдельных элементов в общий результат
- С помощью WBS можно наглядно обосновать необходимости в финансах или человеческих ресурсах, так как против конкретного описанного объема возражать гораздо сложнее, чем против «да что там системку написать, посадите программиста и все».
- WBS помогает предотвратить риски и изменения или по крайней мере значительно (очень значительно!) снизить их вероятность и влияние, так как именно здесь всплывут многие неочевидные ранее вещи и «а мы хотели совсем другое» (и так и должно быть, для этого инструмент и предназначен).
- На уровне WBS уже можно определить и согласовать контрольные точки проекта (как для решений о продолжении проекта после очередного этапа, так и для контроля затрат человеческих и финансовых ресурсов).

  **[⬆ Наверх](#top)**


17. ### <a name="17"></a> Что такое реактивное программирование? Основные кирпичи (поток, наблюдаемый, подписка)

### Реактивное программирование — программирование с асинхронными потоками данных

Для чего нужно реактивное программирование
Реактивный подход повышает уровень абстракции вашего кода и вы можете сконцентрироваться на взаимосвязи событий, которые определяют бизнес-логику, вместо того, чтобы постоянно поддерживать код с большим количеством деталей реализации. Код в реактивном программировании, вероятно, будет короче.

Преимущество более заметно в современных веб- и мобильных приложениях, которые работают с большим количеством разнообразных UI-событий.

Впрочем, ничего нового. Event bus’ы или обычные события клика — это тоже асинхронные потоки данных, которые вы можете прослушивать, чтобы реагировать какими-либо действиями. Реактивность — это та же самая идея, возведенная в абсолют. Вы можете создавать потоки данных не только из событий наведения или кликания мышью. Потоком может быть что угодно: переменные, пользовательский ввод, свойства, кэш, структуры данных и т.п. Например, представьте, что ваша лента новостей в Твиттере — поток событий. Вы можете слушать этот поток и реагировать на события соответственно.

Кроме этого, вы получаете удивительный набор функций для комбинирования, создания и фильтрации этих потоков. Вот где проявляется вся магия этого подхода. Один или несколько потоков могут использоваться как входные данные для другого потока. Вы можете объединять два потока. Также вы можете фильтровать поток, выбирая только те события, которые вам интересны.

Так как потоки — основопологающая вещь в реактивном подходе, давайте рассмотрим их подробнее на примере пользовательского клика мышью

### Поток
Поток — это последовательность событий, упорядоченная по времени. Он может выбрасывать три типа данных: значение (определенного типа), ошибку или сигнал завершения. Сигнал завершения распространяется, когда текущее окно или окно, содержащее кнопку, закрывается.

  **[⬆ Наверх](#top)**

18. ### <a name="18"></a> gulp / grunt, webpack, bazel

### Gulp

Gulp - это инструмент для автоматизации рутинных задач, которые возникают при веб-разработке. Это может быть не только frontend разработка, это может быть и backend разработка.

Если вы работаете с такими технологиями как html,  css, javascript и.т.д. Если вы внедрите в практику своей работы такой инструмент как gulp, вы значительно ускорите скорость вашей работы и, во вторых, этот инструмент "откроет вам дорогу" к новым возможностям, которые значительно повысят ваш уровень веб-разработки и знаний.

Gulp - это просто программа, которая написана на языке программирования Javascript. Для того, чтобы начать его пользоваться, желательно знать, хотя бы основы языка Javascript. Если вы это знаете, то пользоваться программой Gulp для вас будет намного проще. 

Смысл следующий: мы создаем для системы Gulp некие задания. Т.е. описываем эти задания на языке Javascript. Затем, Gulp просто выполняет эти задания в нужной последовательности, так, как мы это прописали. Т.е. Gulp - это просто система по управлению заданиями по веб-разработке. Также ее называют task manager. task - задание, manager - управлять.

Важно понимать, что Gulp - это просто некое ядро, к которому мы прикручиваем дополнительные модули, плагины, которые "учат" Gulp делать какую-то определенную функцию или работу. Устанавливая эти плагины мы получаем новые возможности в системе Gulp, которые мы можем использовать. 

*Список этих задач может быть достаточно большой.*

*Задача 1.* Минификация кода.

Это одна из самых частых задач, для которой чаще всего используют Gulp и подобные ей системы - это задача минификации кода. Т.е. вы написали какой-то код, на каком-то языке программирования. Для вас этот код воспринимается хорошо, но, если вы разместите этот код на рабочем сервере, на котором будет размещаться ваш сайт, то, соответственно, этот код будет загружаться довольно долго из-за того, что в нем есть много лишней информации в виде отступов, комментариев и.т.д. 

Gulp позволяет убрать все лишнее из кода, подготовить его для того, чтобы это можно было выложить на рабочий сервер.   

*Задача 2.* Объединение кода из разных файлов в один.

Вы можете объединять код из CSS, Javascript файлов и.т.д. в один. Это важно сделать также по причине скорости загрузки документа. При работе с протоколом http каждый запрос к файлу - это дополнительное время загрузки страницы.

Если вы объединяете код в один файл, загрузить его проще и быстрее, чем загрузить несколько файлов. 

Это типовая задача, которую приходится решать в современной веб-разработке. Написать программу намного проще, если ее код разбит на модули и независимые части. 

*Задача 3.* Работа с CSS препроцессорами: sass, less, …

Система Gulp позволяет вам использовать их в своей работе и вы получите такой мощный инструмент для того, чтобы улучшить свои навыки веб-разработки.

*Задача 4.* Поддержка новых стандартов языка Javascript.

Т.к. язык Javascript является клиентским языком программирования, то он зависит того браузера, на котором будет работать. Если посетитель вашего сайта пользуется какими-то старыми браузерами, у него новые стандарты не будут работать. С помощью Gulp вы можете решить эту задачу. 

Gulp - это не единственный инструмент, который позволяет решать такие подобные задачи. Важно понимать, что Gulp - это одно из самых простых и легких решений, которые позволяют это сделать.


### Сходства Grunt и Gulp

Grunt и Gulp автоматизируют рутинные задачи разработчика, такие как:

- минификация кода
- анализ качества кода
- оптимизация изображений
- добавление вендорных (браузерных) префиксов
- тестирование

Если в процессе разработки у вас есть задачи повторяющиеся много раз, скорее всего вы сможете их автоматизировать с помощью Grunt или Gulp.
Как сборщик выполняет задачи? Просто. Вы пишите инструкции, которые говорят сборщику, что делать:

- какие файлы использовать
- что делать с этими файлами (минимизировать, конкатенировать, анализировать на ошибки и т.д.)
- куда поместить обработанные файлы
- 
На первый взгляд Grunt и Gulp очень похожи.
Используя любой из этих сборщиков, вы автоматизируете процесс веб-разработки.
В более широком смысле, Grunt и Gulp идентичны тем, что:

- оба автоматизируют процесс разработки
- мы пишем задачи используя javascript
- оба сборщика требуют для работы Nodejs и npm

На этом сходство заканчивается. Способ выполнения задач различен.

`Различия между Grunt и Gulp`

Есть два главных различия между Grunt и Gulp:

- Как настраиваются задачи. Grunt основан на конфигурации. Gulp на потоке.
- Как запускаются задачи. Grunt запускает задачи последовательно. Gulp пытается запустить задачи параллельно.

`Разница в конфигурации задач`

Синтаксис Gulp более краток, чем Grunt. Самое замечательное, что Gulp потоковая система сборки. Для описания задач в Gulp требуется писать гораздо меньше кода.

`Выполнение задач`

*Как Grunt выполняет задачи*

Для выполнения каждого процесса в задаче, Grunt необходимо:

- Открыть необходимый файл
- Запустить текущий процесс
- Сохранить изменения
- Закрыть текущий обработанный файл, чтобы следующий процесс мог получить к нему доступ

*Как выполняет задачи Gulp*

Gulp не требует создания временных файлов между процессами. Файл, после выполнения текущего процесса, сразу передается следующему процесса, не тратя время на сохранение файла.
Gulp использует Orchestrator, который помогает запускать процессы максимально параллельно. Это значит, что Gulp пытается выполнить все задачи одновременно. Теоретически,это позволяет Gulp выполнять задачи быстрее.


### webpack

Вебпак — это сборщик модулей. Он анализирует модули приложения, создает граф зависимостей, затем собирает модули в правильном порядке в один или более бандл (bundle), на который может ссылаться файл «index.html».

`Какие проблемы решает вебпак?`

Обычно, при создании приложения на JavaScript, код разделяется на несколько частей (модулей). Затем в файле «index.html» необходимо указать ссылку на каждый скрипт.

Это не только утомительно, но и подвержено ошибкам. Важно не только не забыть про какой-нибудь скрипт, но и расположить их в правильном порядке. Если загрузить скрипт, зависящий от React, до загрузки самого React, приложение сломается. Вебпак решает эти задачи. Не нужно беспокоиться о последовательном включении всех скриптов.

Как мы скоро узнаем, сбор модулей является лишь одним из аспектов работы вебпака. При необходимости можно заставить вебпак осуществить некоторые преобразования модулей перед их добавлением в бандл. Например, преобразование SASS/LESS в обычный CSS, или современного JavaScript в ES5 для старых браузеров.

*Он также способен выполнять множество иных операций:*

- помогает собрать воедино ваши ресурсы
- следит за изменениями и повторно выполняет задачи
- может выполнить транспиляцию JavaScript следующего поколения до более старого стандарта JavaScript (ES5) с помощью Babel, что позволит использовать новейшие функции JavaScript, не беспокоясь о том, поддерживает их браузер или нет
- может выполнить транспиляцию CoffeeScript в JavaScript
- может конвертировать встроенные изображения в data:URI
- позволяет использовать require() для CSS файлов
- может запустить webpack-dev-server (в нём встроен локальный сервер и livereload (“живая перезагрузка браузера”))
- может работать с Hot Module Replacement (замена горячего модуля)
- может разделить выходной файл (output file) на несколько файлов, чтобы избежать медленной загрузки страницы из-за большого размера JS-файла
- может выполнить Tree Shaking

Webpack не ограничивается одним лишь фронтендом, его также успешно применяют в бэкенд разработке на Node.js.

### bazel

Bazel - это подмножество внутренней системы сборки Google под названием Blaze. Таким образом, Bazel развился, чтобы решить очень большую проблему, которая является несколько (но, возможно, не полностью) уникальной для Google:

- Конфигурационные файлы Bazel гораздо более структурированы, чем Gradles, что позволяет Bazel точно понимать, что делает каждое действие. Это учитывает больший параллелизм и лучшую воспроизводимость.

Файлы сборки Bazel

Bazel работает с двумя конфигурационными файлами: BUILD и WORKSPACE

*Вещи, которые Bazel действительно хорошо включает в себя:*

- бит для воспроизводимости бит. Это ОТЛИЧНО.
- Технология независимой внутрипакетной сборки. У вас есть Python, который зависит от кода C? Какая-то Java, которая требует JavaScript для внешнего интерфейса? Bazel может сделать это, и это одна из немногих систем с открытым исходным кодом, которая может это сделать.
- Благодаря своей воспроизводимости, Bazel может кэшировать результаты сборки и восстанавливать только то, что нужно. Это делает это быстро.
- Базель ГИБКИЙ. У него есть собственный язык доменов, поэтому вы можете расширять его для поддержки всего, что вам нужно, независимо от того, слышали ли об этом создатели. Хотите "собрать" (проверить и проверить синтаксис) Javascript? Java? C? C++? Цель C? Fortran? Brainfuck? НЕТ ПРОБЛЕМ. Если он еще не реализован, вы можете реализовать его. Если вам не нравится, как это работает, вы можете написать свой собственный. Хотите использовать собственный компилятор? Пользовательская статическая проверка? Пользовательский тестовый комплект? Нет проблем. Мир это твоя устрица.

*Плохо о базель*

Базель - это не настоящее управление зависимостями. Он управляет тем, КАКИЕ ваши зависимости, но не какие версии использовать. Если у вас все в вашем дереве зависимостей проверено в одном большом монолитном репозитории кода (как это делает Google с их форком производительности), то это просто прекрасно. "Путь Google" состоит в том, чтобы все строить на чаевых все время и никогда не зависеть от более старых версий.


  **[⬆ Наверх](#top)**

19. ### <a name="19"></a> Хранение паролей и возможности хеширования. Разница между хешем и hmac

hash - это функция, которая создает дайджест из сообщения. Криптографически защищенный hash-это тот, для которого вычислительно невозможно сгенерировать сообщение с заданным дайджестом. Сам по себе hash сообщения не дает никакой информации об отправителе данного сообщения. Если вы можете безопасно передать hash сообщения, то его можно использовать для проверки правильности получения большого сообщения по незащищенному транспорту.

Код аутентификации сообщения-это способ объединения общего секретного ключа с сообщением, чтобы получатель сообщения мог подтвердить, что у отправителя сообщения есть общий секретный ключ, и никто, кто не знает секретного ключа, не мог отправить или изменить сообщение.

HMAC-это код аутентификации сообщения на основе hash. Обычно это включает в себя применение функции hash один или несколько раз к какой-либо комбинации общего секрета и сообщения. HMAC обычно относится к алгоритму, задокументированному в RFC 2104 или FIPS-198.

MAC не шифрует сообщение, поэтому оно находится в виде обычного текста. Он не раскрывает секретный ключ, поэтому MAC может быть отправлен по открытому каналу без ущерба для ключа.

### Разница между хешем и hmac

Основное различие заключается в концептуальности: в то время как хэши используются для гарантии целостности данных, MAC гарантирует аутентификацию AND целостности.

Это означает, что хэш-код слепо генерируется из сообщения без какого-либо внешнего ввода: то, что вы получаете, - это то, что можно использовать для проверки того, изменилось ли сообщение во время его перемещения.

Вместо этого MAC использует закрытый ключ в качестве исходного кода для функции hash, которую он использует при генерации кода: это должно гарантировать получателю, что не только сообщение не было изменено, но и кто его отправил, это то, что мы ожидали: в противном случае злоумышленник не мог знать закрытый ключ, используемый для генерации кода.

Согласно Википедии у вас есть это:

Хотя функции MAC аналогичны криптографическим функциям hash, они обладают различными требованиями к безопасности. Чтобы считаться безопасной, функция MAC должна противостоять экзистенциальной подделке при атаках с открытым текстом. Это означает, что даже если злоумышленник имеет доступ к oracle, который обладает секретным ключом и генерирует MACs для сообщений по выбору злоумышленника, злоумышленник не может угадать MAC для других сообщений, не выполнив неосуществимые объемы вычислений.
Конечно, несмотря на их сходство, они реализованы по-разному: обычно алгоритм генерации MAC основан на алгоритме генерации кода hash с расширением, которое заботится об использовании закрытого ключа.

  **[⬆ Наверх](#top)**

20. ### <a name="20"></a> Атаки на формы и URL-адреса (CSRF, XSS, проблема с семантическими URL-адресами. Фильтрация входных данных)

### CSRF

CSRF (межсайтовая подделка запросов) — это вид атаки на сайт, которая производится с помощью мошеннического сайта или скрипта, который заставляет браузер пользователя выполнить нежелательное действие на доверенном сайте, на котором пользователь авторизован.

Обычно для этого пользователь должен перейти по мошеннической ссылке (которая может быть изменена с помощью сокращателя ссылок).

Методы POST, PUT, DELETE и PATCH должны быть защищены от CSRF.

*Как работает межсайтовая подделка запросов?*

Для того, чтобы злоумышленник осуществил атаку CSRF, нужны определённые условия:

- В приложении есть действие, которое злоумышленник хочет предпринять – например, изменить пароль, перевести средства и так далее.
- Не существует непредсказуемых параметров запроса – злоумышленник может угадать (или знать) все параметры, которые приложение ожидает увидеть из этого типа запроса.
- Действие может быть выполнено с помощью HTTP-запросов, и оно полагается только на файлы cookie, чтобы убедиться, что запрос исходит от пользователя.

CSRF могут быть подвергнуты веб-приложения использующие cookies, браузерную аутентификацию или клиентские сертификаты авторизации. По сути, CSRF подвержены все веб-приложения, которые автоматически добавляют аутентификационные данные пользователя к запросу.

Либо нужно начать с того, что злоумышленник обманом заставит жертву загрузить или отправить информацию в веб-приложение. Это может произойти несколькими способами – например, через фишинговую ссылку.

Эксплойт может быть замаскирован под обычную ссылку или скрыт в теге изображения.

Вот пример атаки через обычную ссылку:
```js
<a href=“вредоносная ссылка”>Unsubscribe here</a>

Или через тэг изображения:

<img src=“вредоносная ссылка” width=“0” height=“0” border=“0”>
```

`Итого`
- CSRF-атака – это когда «злая страница» отправляет форму или запрос на сайт, где посетитель, предположительно, залогинен.
- Если сайт проверяет только куки, то он такую форму принимает. А делать это не следует, так как её сгенерировал злой хакер.
- Для защиты от атаки формы, которые генерирует mail.com, подписываются специальным токеном. Можно подписывать не все формы, а только те, которые осуществляют действия от имени посетителя, то есть могут служить объектом атаки.
- Для подписи XMLHttpRequest токен дополнительно записывается в куку. Тогда JavaScript с домена mail.com сможет прочитать её и добавить в заголовок, а сервер – проверить, что заголовок есть и содержит корректный токен.
- Динамически сгенерированные формы подписываются аналогично: токен из куки добавляется как URL-параметр или дополнительное поле.


### XSS

XSS (англ. Cross-Site Scripting — «межсайтовый скриптинг») — довольно распространенная уязвимость, которую можно обнаружить на множестве веб-приложений. Ее суть довольно проста, злоумышленнику удается внедрить на страницу JavaScript-код, который не был предусмотрен разработчиками. Этот код будет выполняться каждый раз, когда жертвы (обычные пользователи) будут заходить на страницу приложения, куда этот код был добавлен. А дальше существует несколько сценариев развития.

`Как происходит атака межсайтового скриптинга?`
Веб-сайты хранят данные и постоянно отправляют информацию вашему браузеру: атаки межсайтового скриптинга происходят, когда ненадежные источники отправляют пользователям вредоносное содержимое посредством уязвимостей в веб-сайтах с целью кражи персональных данных или нанесения ущерба вашему компьютеру. Например: когда пользователь ищет что-то онлайн, веб-сайт отправляет браузеру данные в форме поисковой выдачи. При атаках типа XSS передаваемая информация содержит вредоносный код и может помочь злоумышленниках украсть персональные данные пользователя. По причине того, что практически каждый веб-сайт хранит и отправляет данные браузерам, межсайтовый скриптинг на сегодняшний день представляет наиболее распространенную уязвимость программного обеспечения.


  **[⬆ Наверх](#top)**

21. ### <a name="21"></a> Понимание концепции рефакторинга

Рефакторинг — это контролируемый процесс улучшения
кода, без написания новой функциональности. Результат
рефакторинга — это чистый код и простой дизайн.

*Правило трёх*
1. Делая что-то в первый раз, вы просто это делаете.
2. Делая что-то аналогичное во второй раз, вы морщитесь от необходимости повторения, но все-таки повторяете то же самое.
3. Делая что-то похожее в третий раз, вы начинаете рефакторинг.

Рефакторинг следует проводить серией небольших изменений, каждое из которых делает существующий код чуть лучше, оставляя программу в рабочем состоянии.

Чистый код — это код, который просто
читать, понимать и поддерживать. Чистый
код улучшает предсказуемость
разработки и повышает
качество продукта.


Грязный код является не только
результатом лени и невежества,
но и побочным продуктом
частых изменений в
процессе разработки.

  **[⬆ Наверх](#top)**

22. ### <a name="22"></a> Основные понятия: Test Plan, Test Suite, Test Case. Концепции различных типов тестов: Единичный / Интеграционный / Функциональный. Основы работы с JS Unit

### Test Plan

Тест-план (Testplan, план тестирования) – это документ, описывающий весь объем работ по тестированию, начиная с описания тестируемых объектов, стратегии, расписания, критериев начала и окончания тестирования, до необходимого в процессе работы оборудования, специальных знаний, а также оценки рисков с вариантами их разрешения.

Как мы можем лицезреть, тест-план является важной составляющей любого грамотно-организованного процесса тестирования, так как содержит в себе всю необходимую информацию, описывающую данный процесс. Но в большинстве случаев, с которыми нам придется столкнуться, тест-план будет играть более формальную роль, но, все же, его присутствие имеет много преимуществ. Например:

- Возможность приоритезации задач по тестированию.
- Построение стратегии тестирование, согласованной со всей командой.
- Возможность вести учет всех требуемых ресурсов, как технических, так и человеческих.
- Планирование использования ресурсов на тестирование.
- Просчет рисков, возможных при проведении тестирования.

В зависимости от конкретизации описываемых задач, тест-план может иметь два уровня детализации: мастер тест-план и детальный тест-план.

Детальный тест-план содержит в себе задачи тестирования для каждой команды, для каждого релиза или итерации проекта.  Создается детальный тест-план либо для декомпозированной части проекта, либо для небольших проектов. Он может состоять из:

- Перечень областей тестирования с приоритетами.
- Стратегия тестирования.
- Перечень возможных рисков.
- Перечень необходимых ресурсов.
- План выполнения проекта.\


### Test Case

Test Case – это тестовый артефакт, суть которого заключается в выполнении некоторого количества действий и/или условий, необходимых для проверки определенной функциональности разрабатываемой программной системы.

Структура данного артефакта заключается в «троице»:

Выполняемое действие (Action) – Ожидаемый результат (Expected result) – Фактический результат (Test result).

Непосредственно сам тестовый случай состоит из 3 частей:

- PreConditions(Предусловия) – либо список шагов, которые приводят проверяемую систему в состояние, пригодное для тестирования, либо список проверок условий того, что система уже находиться в необходимом состоянии.
- Test Case Description(Описание тестового случая) – список действий, с помощью которых осуществляется основная проверка функционала (после которой и сверяется фактический результат с ожидаемым).
- PostConditions(Постусловия) –список действий, которые возвращают систему в исходное состояние.


### Test Suite

Тест Сьют это набор тест кейсов, которые объединены тем что относятся к одному тестируемому модулю, функциональности, приоритету или одному типу тестирования. Каждый тест сьют состоит из более чем одного тест кейса и зачастую выполняется всей «пачкой» в процессе тестирования.

Тест кейсы объединяют в тест сьюты для большего удобства при проходжении тест кейсов, проходя их последовательно от модуля к модулю, от одного типа тестирования к другому а не сумбурно, бросаясь из одного угла в угол, оставив не проверенным большую часть модуля или общей функциональности.


### Единичное тестирование

Единичные тесты – это автоматические тесты, которые проверяют, делает ли данный фрагмент кода то, что вы ожидаете от него, при определенных обстоятельствах. Хорошие модульные тесты проверяют небольшие функциональные возможности, часто на уровне отдельных функций.

### Интеграционное тестирование

Интеграционное тестирование является одним из наиболее распространенных и важных видов тестирования программного обеспечения. После того, как отдельные подразделения или компоненты будут проверены разработчиками как работающие, группа тестировщиков проведет тесты, которые проведут тестирование связи между этими единицами / компонентами или несколькими устройствами / компонентами. Существуют различные подходы к интеграционному тестированию, а именно: интеграционное тестирование сверху вниз, интеграционное тестирование снизу вверх и комбинация этих двух тестов Sand witch.


### Функциональное тестирование

Функциональное тестирование – формальный тип тестирования, выполняемый тестировщиками. Функциональное тестирование сосредоточено на тестировании программного обеспечения на основе документа о состоянии, случаев и требований. Функциональное тестирование является типом тестирования «черного ящика» и не требует знаний внутренней работы программного обеспечения, в отличие от тестирования «белого ящика».


### Основы работы с JS Unit

Unit-тесты — это код, позволяющий проверить на корректность отдельные модули исходного кода. Тесты пишутся для каждой нетривиальной функции.

Юнит-тест — это код, который тестирует юниты (части) кода: функции, модули или классы. ... Вся суть — подать что-то на вход юнита и

Преимущества юнит-тестирования очевидны:

- Являются низкоуровневым и фокусируется на маленькой части ПО
- Тесты пишут сами разработчики
- Тесты выполняются очень быстро, можно выполнять тесты несколько раз в минуту
- При разработке можно выполнять не все тесты, а только те, которые необходимы именно вам

Таким образом, при использовании юнит тестирования скорость разработки существенно не уменьшается, но при этом возрастает качество самого продукта.

Важное различия в юнит тестировании, это какой тип тестирования вы выберите: Solitary (одинокий) и Sociable (общительный) тест.

*Sociable* (общительный) тест — это тест который использует реальные методы (или классы), которые входят в тестируемую единицу. Например, вы тестируете метод «цена» из класса заказов. Методу «цена» необходимо вызвать методы из класса клиент и продукт. В данном виде тестов будут вызваны именно эти методы, и ошибка в этих методах приведет к ошибке теста. Методы из классов клиент и продукт называется партнеры (collaborators).

*Solitary* (одинокий) тест — это тест, который в качестве партнеров использует дубли (TestDouble). Тест-дубли — это общий термин для любого случая, в котором вы заменяете реальный объект, исключительно для целей тестирования.

  **[⬆ Наверх](#top)**

23. ### <a name="23"></a> Реализация ООП в JS

Объектно-ориентированное программирование (ООП) — это шаблон проектирования программного обеспечения, который позволяет решать задачи с точки зрения объектов и их взаимодействий.	
	
```js	
let str = 'some';
let strObj = new String(str);

console.log(typeof(str)); //string
console.log(typeof(strObj)); //jbject

console.dir([1, 2, 3]);


const soldier = {
  health: 400,
  armor: 100,
  sayHello: function() {
    console.log('Hello');
  }
};

const jonh = Object.create(soldier);
// тоже самое только современный вариант < =

// const jonh = {
//   health: 100
// };

// jonh.__proto__ = soldier;
// это устаревший вариант, он не используется, а вот тоже самое, только современный вариант =>

// Object.setPrototypeOf(jonh, soldier);

console.log(jonh);
console.log(jonh.armor);
jonh.sayHello();	
```	
	
Ключевое слово this

this - это объект, свойством которого является функция;
this - дает функциям доступ к своему объекту и его свойствам;
this - помогает выполнить один и тот же код для нескольких объектов;
this - можно рассматривать как кто меня вызвал?; т.е. то, что находится слева от точки. Например, window.a();
this - имеет динамическую область, т. е. не важно, где он был написан, важно, где он был вызван.

```jsx harmony
const obj = {
  name: 'Alex',
  sing() {
    console.log('a this ', this);
    var anotherFunc = function() {
      console.log('b this ', this);
    }
    anotherFunc();
  }
};

obj.sing();

// a this  {name: "Alex", sing: ƒ}
// b this  Window {parent: Window, postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, …}
```
```jsx harmony
var b = {
  name: 'jay',
  say() {
    console.log('this is ', this);
  }
}
b.say()
// this is  {name: "jay", say: ƒ}

var c = {
  name: 'jay',
  say() {
    return function () {
      console.log('this is ', this);
    }
  }
}
c.say()()
// this is  Window {parent: Window, postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, …}

var d = {
  name: 'jay',
  say() {
    // стрелочная функция не имеют собственного контекста выполнения.
    return () => console.log('this is ', this);
  }
}
d.say()()
// this is  {name: "jay", say: ƒ}
```

Стрелочные функции связывают this с лексической областью действия.
```jsx harmony
const obj = {
  name: 'Alex',
  sing() {
    console.log('a this ', this);
    var anotherFunc = () => {
      console.log('b this ', this);
    }
    anotherFunc();
  }
};

obj.sing();

// a this  {name: "Alex", sing: ƒ}
// b this  {name: "Alex", sing: ƒ}
```

Прототип

- Прототип (prototype) - это экземпляр рабочего объекта. Объекты наследуются напрямую от других объектов.
- __proto__ является ссылкой на свойство прототипа родительского объекта, например:
```jsx harmony
const obj = {};
obj.__proto__ === Object.prototype // true
```

- Свойство prototype принадлежит только функциям, в частности, функциям конструктора. Конструктор Object создает обертку объекта.
- Свойства proto и prototype используются для создания цепочки наследования свойств между объектами, начиная с Object и Primitive Types.
- Object.create() можно использовать для создания объектов с его свойством proto, связанным со свойством prototype объекта, переданного в качестве аргумента Object.create().
- Object - это базовая функция (конструктор). Корнем всего в JavaScript является Object, который на самом деле является функцией.
```jsx harmony
typeof Object // "function"
```jsx harmony
Object имеет свойство prototype, которое является базовым объектом для всех вещей в JavaScript, включая функции JavaScript.
```jsx harmony
typeof Object.prototype // "object"
```

ES6 Классы
- Ключевое слово class в JS - синтаксический сахар. Под капотом он всё еще использует прототипное наследование (prototypal inheritance).
- Экземпляры класса должны создаваться с ключевым словом new.
- Метод constructor используется для создания экземпляра state (данных) нового объекта. State обычно уникально для каждого экземпляра.
- Функции обычно не включаются в конструктор, так как они создают ссылку на место в памяти в каждом новом экземпляре класса. Таким образом используя больше памяти, чем необходимо. Включая функции в качестве методов класса, экземпляры класса могут ссылаться на функцию через цепочку прототипов.
- Прототипное наследование (prototypal inheritance) имеет лучшую эффективность памяти, чем классическое наследование, благодаря тому, что оно разделяет ссылки памяти своих свойств прототипа с теми объектами, которые наследуют от него. В классическом наследовании, экземпляры класса создают новые ссылки на память для каждого унаследованного свойства.

Object.create() vs. Classes

- Оба Object.create() и class являются способами создания цепочки прототипов.
- Некоторые люди предпочитают избегать ключевые слова constructor, class и this, чтобы ограничить путаницу из-за this.
- Другие предпочитают использовать ключевые слова constructor, class и this, возможно, из-за его сходства с другими языками с парадигмой объектно-ориентированного программирования.


Private vs. Public vs. Protected

Во многих объектно-ориентированных языках программирования, которые имеют классы, идея private и public полей действительно важна. В JavaScript этого нет. Ранее, если нужно было сделать поле private, к которому нельзя обращаться из класса, мы добавляли подчеркивание _ перед именем, чтобы другие программисты знали, что это private метод. Но, к сожалению, подчеркивание на самом деле ничего не делает.

В JavaScript есть предложение ECMAScript, которое предназначено для объявлений полей класса.

Это модификаторы доступа, которые помогают нам реализовать Encapsulation (или скрытие информации). Они сообщают компилятору, какие другие классы должны иметь доступ к определенному полю или методу.

Private - только текущий класс будет иметь доступ к полю или методу. Protected - только текущий класс и подклассы этого класса будут иметь доступ к полю или методу. Public - любой класс может ссылаться на поле или вызывать метод.

Так как в Javascript таких полей пока нет, для их реализации мы можем использовать TypeScript.

  **[⬆ Наверх](#top)**

24. ### <a name="24"></a> Принципы ООП

Объектно-ориентированное программирование (ООП) — это шаблон проектирования программного обеспечения, который позволяет решать задачи с точки зрения объектов и их взаимодействий.
	
Принципы ООП:
	
- Абстракция — отделение концепции от ее экземпляра;
- Полиморфизм — реализация задач одной и той же идеи разными способами;
- Наследование — способность объекта или класса базироваться на другом объекте или классе. Это главный механизм для повторного использования кода. Наследственное отношение классов четко определяет их иерархию;
- Инкапсуляция — размещение одного объекта или класса внутри другого для разграничения доступа к ним.

4 принципа ООП

`Инкапсуляция` - включает в себя идею о том, что данные объекта не должны быть напрямую доступны. Нужно вызывать методы вместо прямого доступа к данным. Инкапсуляция позволяет нам скрывать/показывать свойства функций.

ООП заключаем код в блоки, которые связаны друг с другом, чтобы эти блоки могли просто взаимодействовать друг с другом, используя методы и свойства, которые мы делаем доступными. Данный принцып делает код проще в обслуживании и более пригодным для повторного использования.

Инкапсуляция с использованием замыкания
```jsx harmony
const createCounter = () => {
  // Переменная, определенная в области действия фабрики или конструктора
  // является приватной для этой функции.
  let count = 0;

  return ({
    // Любые другие функции, определенные в той же области, являются привилегированными:
    // Они имеют доступ к закрытой переменной `count`
    // определенной в любом месте их цепочки областей видимости (содержащей области действия функции).
    click: () => count += 1,
    getCount: () => count.toLocaleString()
  });
};

const counter = createCounter();

counter.click();
counter.click();
counter.click();

console.log(counter.getCount()); // "3"
```

`Абстракция` - это способ создания простой модели, которая содержит только важные свойства с точки зрения контекста приложения, из более сложной модели. Иными словами - это способ скрыть детали реализации и показать пользователям только функциональность. Абстракция игнорирует нерелевантные детали и показывает только необходимые. Важно помнить, что мы не можем создать экземпляр абстрактного класса.

Всё программное обеспечение - это абстракция, скрывающая всю тяжелую работу и бездумные детали.

Многие программные процессы повторяются снова и снова. Поэтому, на этапе декомпозиции проблемы, мы удалим дублирование, записывая какой-либо компонент (функцию, модуль, класс и т. Д.), присваивая ему имя (идентификатор) и повторно используя его столько раз, сколько нам нужно.

Процесс декомпозиции - это процесс абстракции. Успешная абстракция подразумевает, что результатом является набор независимо полезных и перекомпонованных компонентов.

`Полиморфизмом` - является одним из принципов объектно-ориентированного программирования (ООП). Это помогает проектировать объекты таким образом, чтобы они могли совместно использовать или переопределять любое поведение с конкретными предоставленными объектами.

Само слово означает много форм. Существует много толкований того, что именно оно означает, но идея заключается в способности вызывать один и тот же метод для разных объектов, и при этом каждый объект реагирует по-своему.

Чтобы это произошло полиморфизм использует наследование.

В следующем примере дочерний объект, такой как Coder, переопределяет метод say, вызванный из родительского объекта Human, и возвращает новую строку соответственно. Тогда как другой дочерний объект Men, вместо переопределения метода say, наследует его и отображал родительскую строку.
```jsx harmony
class Human {
  constructor(name) {
    this.name = name;
  }

  say() {
    return `Hello, my name is ${this.name}, I like travelling`;
  }
}

class Men extends Human {
  constructor(name) {
    super(name)
  }
  // Берем метод say у родителя.
}

class Coder extends Human {
  constructor(name) {
    super(name)
  }

  say() {
    // Переопределяем метод родителя say для отображения нового значения.
    return `Hello, my name is ${this.name}, I like coding`;
  }
}

const alex = new Men('Alex');
const leo = new Coder('Leo');

alex.say() // "Hello, my name is Alex, I like travelling"
leo.say() // "Hello, my name is Leo, I like coding"
```

`Наследование` - это механизм базирования объекта или class на другом объекте (наследование на основе прототипа) или class (наследование на основе класса). Мы избегаем необходимости переписывать один и тот же код, а также экономим пространство памяти, используя общие методы.
```jsx harmony
class Human {
  constructor(name) {
    this.name = name;
  }

  sayMyName() {
    return 'Hello, I am ' + this.name;
  }
}

class Men extends Human {
  constructor(name) {
    super(name)
  }
}
class Coder extends Human {
  constructor(name) {
    super(name)
  }
}

const alex = new Men('Alex');
const leo = new Coder('Leo');

alex.sayMyName() // Hello, I am Alex
leo.sayMyName() // Hello, I am Leo
```
https://learn.javascript.ru/prototype-inheritance

  **[⬆ Наверх](#top)**

25. ### <a name="25"></a> Code small

Code Smells — это некий набор общих признаков, которые указывают на то, что код недостаточно хорош, и для его чистоты потребуется рефакторинг.

- Дублированный код и логика
- Длинные методы и классы
- Дублирующие методы в тех же или разных классах
- Расходящиеся модификации класса
Если вы хоть раз читали о принципах SOLID (особенно о единственной ответственности), то должны знать, что в одном классе должна существовать только одна причина для изменения кода. То есть, в классе User не должно быть функции, связанных с продуктами или преобразованием файла. Этот code smell можно легко исправить извлечением постороннего метода в новый класс, например, в класс Product или FileSystem.
- Стрельба дробью
Стрельба дробью — антипаттерн в разработке ПО (прим. переводчика) и это полная противоположность расходящимся модификациям. В данном случае, вы будете менять множество классов по единой причине. То есть для применения какого-либо действия всем этим классам потребуется одна и та же причина изменения. Например, вам нужно создать новое правило пользователя «Суперадминистратор», после чего вы должны будете отредактировать ряд методов в классах Profile, Products и Employees. В таком случае призадумайтесь о том, чтобы сгруппировать эти методы в один единый класс, чтобы этот новый класс имел единую причину изменения.
- Завистливая функция
Иногда в своем классе вы находите метод, который активно пользуется другим классом. В таком случае стоит переместить этот метод в тот самый используемый класс. Посмотрите на картинку ниже. Разве не логично будет перенести getFullAddress() из класса User в ContactInfo, раз вся его работа сводится к использованию методов ContactInfo.
- Группы данных
Иногда вы встречаете множество функций с почти одинаковым списком параметров. Этот тип параметров, используемых только вместе, и вызывает code smell группы данных. Взгляните на пример ниже. Вы увидите, что почти все типы бронирования требуют паспортных данных.

  **[⬆ Наверх](#top)**

26. ### <a name="26"></a> Continuous delivery, Continuous deployment & Continuous integration (CI/CD): зачем это нужно?

DevOps — это сокращение от Development Operations. Это связующее звено между командой разработки и командой эксплуатации.

- разработчик отправляет код в центральный репозиторий;
- на сервере непрерывной интеграции изменения объединяются с основным кодом, выполняются юнит – тесты и всё заливается на стейджинг среду;
- в стейджинг среде QA (**Q**uality **A**ssurance) инженеры тестируют приложение;
- дальше всё проверяется для попадания на продакшен;
- развёртывание на продакшене.

*Continuous Delivery* — это серия практик, направленных на то, чтобы обновления программного обеспечения происходили практически постоянно.

*Continuous Deployment* отвечает за то, чтобы весь новый функционал после тестирования сразу же попал в основную программу без ручного вмешательства инженеров DevOps.

*Continuous Integration* — постоянное попадание кода в центральный репозиторий после успешного запуска тестов, поиск и устранение потенциальных проблем как можно быстрее, улучшение качества ПО и сокращение время для выпуска обновлений.

  **[⬆ Наверх](#top)**

27. ### <a name="27"></a> Отладке кода, Debugging

Отладка – это процесс поиска и исправления ошибок в скрипте. Все современные браузеры и большинство других сред разработки поддерживают инструменты для отладки – специальный графический интерфейс, который сильно упрощает отладку. Он также позволяет по шагам отследить, что именно происходит в нашем коде.

Приостановить выполнение скрипта можно тремя способами:

- Точками останова.
- Использованием в коде команды debugger.
- При ошибке (если инструменты разработчика открыты и опция  включена).

При остановке мы можем отлаживать – проанализировать переменные и пошагово пройти по процессу, что поможет отыскать проблему.
	
1. React и Redux
- React Devtools
- Redux Devtools
	
2. Vue
- Vue Devtools
	
3. JavaScript
- Chrome Devtools
- Выражение debugger
- Отладка при помощи старого доброго console.log	

https://learn.javascript.ru/debugging-chrome

  **[⬆ Наверх](#top)**

28. ### <a name="28"></a> Jira (Redmine,Tfs)

Jira - декомпозиция, эстимация, создания тасков, саб-тасков, багов, задачей на сборку

Система багтрекинга нужна для учета и контроля дефектов программы или сайта, для эффективного описания проблем: что сделал, что получил и что ожидал получить.

1. *Возможность отслеживания статуса проблемы*:
    - Предоставляет статусы для каждой проблемы, которые можно отслеживать, как лично, так и используя оповещения на почту или RSS.
2. *Качество описания проблемы*:
    - Обязательные поля для категорий, воспроизводимости, системы, описания и шагов повторения.
3. *Возможность прикрепления файлов*:
    - Можно прикреплять любые файлы в любое время.
4. *Комментирование проблем*:
    - Можно комментировать проблему, как, например, обычные записи в блогах.
5. *Совместная работа над проблемами*:
    - Система ролей и прав доступа.

  **[⬆ Наверх](#top)**

	
29. ### <a name="29"></a> 
	
	
	
  **[⬆ Наверх](#top)**	
	
30. ### <a name="30"></a> Хранилище данных: Куки, LocalStorage, sessionStorage, IndexedDB

### Какие знаешь способы хранения данных в приложении?
 
1. Куки, document.cookie
2. LocalStorage, sessionStorage
3. IndexedDB
 
### Куки, document.cookie
 
Куки – это небольшие строки данных, которые хранятся непосредственно в браузере.
	
Куки обычно устанавливаются веб-сервером при помощи заголовка Set-Cookie. Затем браузер будет автоматически добавлять их в (почти) каждый запрос на тот же домен при помощи заголовка Cookie.

Один из наиболее частых случаев использования куки – это аутентификация:

1. При входе на сайт сервер отсылает в ответ HTTP-заголовок Set-Cookie для того, чтобы установить куки со специальным уникальным идентификатором сессии («session identifier»).
2. Во время следующего запроса к этому же домену браузер посылает на сервер HTTP-заголовок Cookie.
3. Таким образом, сервер понимает, кто сделал запрос.
	
Мы также можем получить доступ к куки непосредственно из браузера, используя свойство document.cookie	
	
document.cookie предоставляет доступ к куки

- операция записи изменяет только то куки, которое было указано.
- имя и значение куки должны быть закодированы.
- одно куки вмещает до 4kb данных, разрешается более 20 куки на сайт (зависит от браузера).
 
Настройки куки:

- path=/, по умолчанию устанавливается текущий путь, делает куки видимым только по указанному пути и ниже.
- domain=site.com, по умолчанию куки видно только на текущем домене, если явно указан домен, то куки видно и на поддоменах.
- expires или max-age устанавливает дату истечения срока действия, без них куки умрёт при закрытии браузера.
- secure делает куки доступным только при использовании HTTPS.
- samesite запрещает браузеру отправлять куки с запросами, поступающими извне, помогает предотвратить XSRF-атаки.
 
Дополнительно:

- Сторонние куки могут быть запрещены браузером, например Safari делает это по умолчанию.
- Установка отслеживающих куки пользователям из стран ЕС требует их явного согласия на это в соответствии с законодательством GDPR.	
	
### В чем смысл cookies?
 
 Cookies — это небольшие текстовые файлы у нас на компьютерах, в которых хранится информация о наших предыдущих действиях на сайтах. Кроме входов в аккаунты они умеют запоминать:

- предпочтения пользователей, например, язык, валюту или размер шрифта.
- товары, которые мы просматривали или добавили в корзину;
- текст, который мы вводили на сайте раньше;
- IP-адрес и местоположение пользователя;
- дату и время посещения сайта;
- версию ОС и браузера;
- клики и переходы.
 
Как работают cookies
 
Когда мы совершаем на сайте какое-то действие, например, добавляем товар в корзину или вводим детали входа в аккаунт, сервер записывает эту информацию в куки и отправляет браузеру вместе со страницей. Когда мы переходим на другую страницу сайта или заходим на него через время, браузер отправляет куки обратно.

Куки бывают временными и постоянными. Постоянные куки остаются на компьютере, когда мы закрываем вкладку с сайтом, а временные удаляются. Какие именно куки использовать на конкретном сайте — временные или постоянные — решает его разработчик. Именно поэтому на одних сайтах мы не выходим из аккаунтов, даже когда заходим на них раз спустя несколько дней, а на других вводим пароль заново, хотя отошли от компьютера на пять минут.	
	
 
### LocalStorage, sessionStorage
 
Объекты веб-хранилища localStorage и sessionStorage позволяют хранить пары ключ/значение в браузере.

- key и value должны быть строками.
- Лимит 2 Мб+, зависит от браузера.
- Данные не имеют «времени истечения».
- Данные привязаны к источнику (домен/протокол/порт).
 
 localStorage:
 - Совместно используется между всеми вкладками и окнами с одинаковым источником
 - «Переживает» перезапуск браузера
 
 sessionStorage:
 - Разделяется в рамках вкладки браузера, среди ифреймов из того же источника
 - «Переживает» перезагрузку страницы (но не закрытие вкладки)
 
 API:

- setItem(key, value) – сохранить пару ключ/значение.
- getItem(key) – получить данные по ключу key.
- removeItem(key) – удалить значение по ключу key.
- clear() – удалить всё.
- key(index) – получить ключ на заданной позиции.
- length – количество элементов в хранилище.
- Используйте Object.keys для получения всех ключей.
- Можно обращаться к ключам как к обычным свойствам объекта, в этом случае событиеstorage не срабатывает.
 
Событие storage:

- Срабатывает при вызове setItem, removeItem, clear.
- Содержит все данные об произошедшем обновлении (key/oldValue/newValue), url документа и объект хранилища storageArea.
- Срабатывает на всех объектах window, которые имеют доступ к хранилищу, кроме того, где оно было сгенерировано (внутри вкладки для sessionStorage, глобально для localStorage).
 
### LocalStorage пример
	
```js
localStorage.setItem('number', 5);

localStorage.getItem('number');

localStorage.removeItem('number');

localStorage.clear();

console.log(localStorage.getItem('number'));

// Пример 
	
const checkbox = document.querySelector('#checkbox'),
      form = document.querySelector('form'),
      change = document.querySelector('#color');

if (localStorage.getItem('isChecked')) {
  checkbox.checked = true;
}

if (localStorage.getItem('bg') === 'changed') {
  form.style.backgroundColor = 'red';
}

checkbox.addEventListener('change', () => {
  localStorage.setItem('isChecked', true);
});

change.addEventListener('click', () => {
  if (localStorage.getItem('bg') === 'changed') {
    localStorage.removeItem('bg');
    form.style.backgroundColor = '#fff';
  } else {
    localStorage.setItem('bg', 'changed');
    form.style.backgroundColor = 'red';
  }
});

const persone = {
  name: 'Alex',
  age: 28
};

const serializedPersone = JSON.stringify(persone);
localStorage.setItem('alex', serializedPersone);

console.log(JSON.parse(localStorage.getItem('alex')));	
```	
	
### IndexedDB
 
IndexedDB можно рассматривать как «localStorage на стероидах». Это простая база данных типа ключ-значение, достаточно мощная для оффлайн приложений, но простая в использовании.

Использование можно описать в нескольких фразах:

1. Подключить обёртку над промисами, например idb.
2. Открыть базу данных: idb.openDb(name, version, onupgradeneeded)
- Создание хранилищ объектов и индексов происходит в обработчике onupgradeneeded.
- Обновление версии – либо сравнивая номера версий, либо можно проверить что существует, а что нет.
3. Для запросов:
- Создать транзакцию db.transaction('books') (можно указать readwrite, если надо).
- Получить хранилище объектов transaction.objectStore('books').
4. Затем для поиска по ключу вызываем методы непосредственно у хранилища объектов.
- Для поиска по любому полю объекта создайте индекс.
5. Если данные не помещаются в памяти, то используйте курсор.
 
```jsx harmony 
<!doctype html>
<script src="https://cdn.jsdelivr.net/npm/idb@3.0.2/build/idb.min.js"></script>

<button onclick="addBook()">Добавить книгу</button>
<button onclick="clearBooks()">Очистить хранилище</button>

<p>Список книг:</p>

<ul id="listElem"></ul>

<script>
let db;

init();

async function init() {
  db = await idb.openDb('booksDb', 1, db => {
    db.createObjectStore('books', {keyPath: 'name'});
  });

  list();
}

async function list() {
  let tx = db.transaction('books');
  let bookStore = tx.objectStore('books');

  let books = await bookStore.getAll();

  if (books.length) {
    listElem.innerHTML = books.map(book => `<li>
        название: ${book.name}, цена: ${book.price}
      </li>`).join('');
  } else {
    listElem.innerHTML = '<li>Книг пока нет. Пожалуйста, добавьте книги.</li>'
  }


}

async function clearBooks() {
  let tx = db.transaction('books', 'readwrite');
  await tx.objectStore('books').clear();
  await list();
}

async function addBook() {
  let name = prompt("Название книги");
  let price = +prompt("Цена книги");

  let tx = db.transaction('books', 'readwrite');

  try {
    await tx.objectStore('books').add({name, price});
    await list();
  } catch(err) {
    if (err.name == 'ConstraintError') {
      alert("Такая книга уже существует");
      await addBook();
    } else {
      throw err;
    }
  }
}

window.addEventListener('unhandledrejection', event => {
  alert("Ошибка: " + event.reason.message);
});

</script>
```

  **[⬆ Наверх](#top)**
	
31. ### <a name="31"></a> Критический путь рендеринга

### Что происходит, когда вводишь адрес в браузер и нажимаешь enter (как до сервера доходит запрос, dns, отрисовка dom, css и т.д.)
 
1. Происходит парсинг URL (**U**niform **R**esource **L**ocator) запроса: является ли это адресом, если нет, то введенная строка расценивается как поисковый запрос и передается на обработку поисковому движку.
2. Производится поиск адреса в кэше и в файле hosts, если не находится, то адрес запрашивается у DNS (**D**omain **N**ame **S**ystem)-сервера. Если DNS-сервер находится в той же подсети, то запрос отправляется этому серверу, если в другой подсети, то запрос отправляется на IP (**I**nternet **P**rotocol) - адрес шлюза по умолчанию.
3. Когда браузер получает IP-адрес конечного сервера, то он берет данные об используемом порте из URL и запускает соединение.
4. Сервер получает HTTP (**H**yper**T**ext **T**ransfer **P**rotocol) запрос, начинает его обработку, проверяет наличие запрашиваемого ресурса и в случае успеха направляет результат клиенту.
5. Браузер получает результат в качества HTML (**H**yper**T**ext **M**arkup **L**anguage). Начинает парсинг HTML, где производит разбор HTML разметки в DOM (**D**ocument **O**bject **M**odel) дерево.
6. Во время разбора HTML производится парсинг и интерпретация CSS (**C**ascading **S**tyle **S**heets).
7. Путем перебора DOM-узлов и вычисления для каждого узла значений CSS-стилей создается дерево рендера.

  **[⬆ Наверх](#top)**
	
32. ### <a name="32"></a> Кэширование (как работает и зачем нужно)

Небольшой объем памяти кэша компенсируется высокой скоростью доступа. В кэше обычно хранится только требуемый набор данных, причем временно, в отличие от баз данных, где данные обычно хранятся полностью и постоянно.
	
Приватный кеш предназначен для отдельного пользователя. Вы, возможно, уже видели параметры кеширования в настройках своего браузера. Кеш браузера содержит все документы, загруженные пользователем по HTTP. Он используется для доступа к ранее загруженным страницам при навигации назад/вперёд, позволяет сохранять страницы, или просматривать их код, не обращаясь лишний раз к серверу. Кроме того, кеш полезен при отключении от сети.
	
В идеале браузерное кэширование должно функционировать следующим образом:
1. сервер отправляет файл клиенту при первичном запросе;
2. клиент кэширует файл на срок, определённый в HTTP-заголовке ответа сервера;
3. по истечении срока клиент делает запрос к серверу на проверку изменений файла;
4. если файл не менялся, он вновь берётся из кэша.	
	
Ресурсы веб-страниц делятся на 2 группы:
- Динамические
Эти ресурсы не хранятся на сервере, а генерируются его средствами при запросах веб-страниц. К таким ресурсам обычно относят HTML-код, который может генерироваться посредством PHP на серверах Apache.
- Статические
Такие ресурсы хранятся на сервере. Как правило, к ним относится медиа-контент (картинки и видео), а также файлы стилей, скриптов и шрифтов.
	
Происходит кеширование статистических ресурсов.	

	
Производительность веб-сайтов и приложений можно значительно повысить за счёт повторного использования ранее полученных ресурсов. Веб-кеши сокращают задержку и снижают сетевой трафик, уменьшая тем самым время, необходимое для отображения ресурсов. Используя HTTP-кеширование, сайты становятся более отзывчивыми.

Как на стороне клиента, так и на стороне сервера можно использовать различные технологии кэширования. Для кэширования на стороне сервера обычно используется прокси-сервер, сохраняющий запросы от веб-серверов, которые за ним расположены, эффективно сокращая нагрузку на них и задержку ответа.
   
Различные виды кеширования
Техника кеширования заключается в сохранении копии полученного ресурса для возврата этой копии в ответ на дальнейшие запросы. Запрос на ресурс, уже имеющийся в веб-кеше, перехватывается, и вместо обращения к исходному серверу выполняется загрузка копии из кеша. Таким образом снижается нагрузка на сервер, которому не приходится самому обслуживать всех клиентов, и повышается производительность — кеш ближе к клиенту и ресурс передаётся быстрее. Кеширование является основным источником повышения производительности веб-сайтов. Однако, кеш надо правильно сконфигурировать: ресурсы редко остаются неизменными, так что копию требуется хранить только до того момента, как ресурс изменился, но не дольше.

Существует несколько видов кешей, которые можно разделить на две основные категории: приватные кеши и кеши совместного использования. В кешах совместного использования (shared cache) хранятся копии, которые могут направляться разным пользователям. Приватный кеш (private cache) предназначен для отдельного пользователя.
 
 Приватный (private) кеш браузера
Приватный кеш предназначен для отдельного пользователя. Вы, возможно, уже видели параметры кеширования в настройках своего браузера. Кеш браузера содержит все документы, загруженные пользователем по HTTP. Он используется для доступа к ранее загруженным страницам при навигации назад/вперёд, позволяет сохранять страницы, или просматривать их код, не обращаясь лишний раз к серверу. Кроме того, кеш полезен при отключении от сети.

Общий (shared) прокси-кеш
Кеш совместного использования — это кеш, который сохраняет ответы, чтобы их потом могли использовать разные пользователи. Например, в локальной сети вашего провайдера или компании, может быть установлен прокси, обслуживающий множество пользователей, чтобы можно было повторно использовать популярные ресурсы, сокращая тем самым сетевой трафик и время ожидания.
 
 https://developer.mozilla.org/ru/docs/Web/HTTP/Caching

  **[⬆ Наверх](#top)**
	
	
33. ### <a name="33"></a> 



  **[⬆ Наверх](#top)**
	
34. ### <a name="34"></a> 



  **[⬆ Наверх](#top)**	
	
	
44. ### <a name="44"></a> 



  **[⬆ Наверх](#top)**
	
45. ### <a name="45"></a> 
	

  **[⬆ Наверх](#top)**  
  
401. ### <a name="401"></a> Базовая схема HTML-документа

Взглянем на базовую структуру любого HTML-документа:
```html
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Моя первая страница</title>
</head>
<body>

</body>
</html>
```	
Этот набор кажется не очень большим, но браузеру он сообщает множество полезной информации. В этом уроке разберёмся с каждой строчкой этой структуры.	
	
  **[⬆ Наверх](#top)**

402. ### <a name="402"></a> Использование символов HTML

  **[⬆ Наверх](#top)**

403. ### <a name="403"></a> Форматирование текста, абзацы

  **[⬆ Наверх](#top)**

404. ### <a name="404"></a> HTML-ссылки. Link target

  **[⬆ Наверх](#top)**

405. ### <a name="405"></a> Таблицы HTML 

Элемент <table служит контейнером для элементов, определяющих содержимое таблицы. Любая таблица состоит из строк и ячеек, которые задаются с помощью тегов <tr и <td. Внутри <table допустимо использовать следующие элементы: <caption, <col, <colgroup, <tbody, <td, <tfoot, <th, <thead и <tr.

Таблицы с невидимой границей долгое время использовались для верстки веб-страниц, позволяя разделять документ на модульные блоки. Подобный способ применения таблиц нашел воплощение на многих сайтах, пока ему на смену не пришел более современный способ верстки с помощью слоев.

Синтаксис
	
```html	
<table>
  <tr>
    <td>...</td>
  </tr>
</table>
```
	
*Атрибуты*
align - Определяет выравнивание таблицы.
background - Задает фоновый рисунок в таблице.
bgcolor - Цвет фона таблицы.
border - Толщина рамки в пикселах.
bordercolor - Цвет рамки.
cellpadding - Отступ от рамки до содержимого ячейки.
cellspacing - Расстояние между ячейками.
cols - Число колонок в таблице.
frame - Сообщает браузеру, как отображать границы вокруг таблицы.
height - Высота таблицы.
rules - Сообщает браузеру, где отображать границы между ячейками.
summary - Краткое описание таблицы.
width - Ширина таблицы.	
	
  **[⬆ Наверх](#top)**

406. ### <a name="406"></a> Добавление scripts

Тег <script> предназначен для описания скриптов, может содержать ссылку на программу или ее текст на определенном языке. Скрипты могут располагаться во внешнем файле и связываться с любым HTML-документом. Такой подход позволяет использовать одни и те же общие функции на многих веб-страницах и ускоряет их загрузку, т.к. внешний файл кэшируется при первой загрузке, и скрипт вызывается быстрее при последующих вызовах.

<script> может располагаться в заголовке или теле HTML-документа в неограниченном количестве. В большинстве случаев местоположение скрипта никак не сказывается на работу программы. Однако скрипты, которые должны выполняться в первую очередь, обычно помещают в заголовок документа.

Синтаксис
	
- <script type="тип"></script> 
	
- <script type="тип" src="URL"></script>

	
Атрибуты
- async - Загружает скрипт асинхронно.
- defer - Откладывает выполнение скрипта до тех пор, пока вся страница не будет загружена полностью.
- language - Устанавливает язык программирования на котором написан скрипт.
- src - Адрес скрипта из внешнего файла для импорта в текущий документ.
- type - Определяет тип содержимого тега <script>.
	
Закрывающий тег - Обязателен.	
	
  **[⬆ Наверх](#top)**

407. ### <a name="407"></a> Разница между блочными и строчными элементами

### Блочные элементы
	
Блочные элементы являются основой, которая используется для верстки веб-страниц. Такой элемент представляет собой прямоугольник, который по умолчанию занимает всю доступную ширину страницы (если иное значение не указано в CSS), а длина элемента зависит от его содержимого. Такой элемент всегда начинается с новой строки, то есть, располагается под предыдущим элементом. Блочный элемент может содержать в себе другие блочные и строчные элементы.

Примеры блочных элементов: <div, <p, <ul, <ol, <h1 и т. д.
 

### Строчные элементы
	
В отличие от блочного, строчный элемент не переносится на новую строку, а располагается на той же строке, что и предыдущий элемент. Такие элементы, как правило, находятся внутри блочных элементов и их ширина зависит лишь от содержимого и настроек CSS. Еще одно отличие строчного элемента от блочного заключается к том, что в нем может находиться только контент и другие строчные элементы. Блочные элементы в строчные вкладывать нельзя.

Примеры строчных элементов: <a, <span, <strong, <em, <img и т. д.	

	
Разница между блочными и строчными элементами следующая.

- Строчные элементы могут содержать только данные или другие строчные элементы, а в блочные допустимо вкладывать другие блочные элементы, строчные элементы, а также данные. Иными словами, строчные элементы никак не могут хранить блочные элементы.
- Блочные элементы всегда начинаются с новой строки, а строчные таким способом не акцентируются.
- Блочные элементы занимают всю доступную ширину, например, окна браузера, а ширина строчных элементов равна их содержимому плюс значения отступов, полей и границ.	
	
	
  **[⬆ Наверх](#top)**

408. ### <a name="408"></a> Для чего нужен DOCTYPE?

DOCTYPE — это сокращение от DOCument TYPE (тип документа). DOCTYPE всегда связан с DTD — Document Type Definition (определение типа документа).

DTD определяет как должны быть структурированы документы определенного типа (т.е. тег button может содержать в себе тег span, но не div), в то время как DOCTYPE объявляет, к какому DTD предположительно относится документ.

Для веб-страниц объявление DOCTYPE необходимо. Он используется для того, чтобы сообщить пользовательскому агенту, к какой версии спецификаций HTML принадлежит ваш документ. Как только пользовательский агент распознал правильный DOCTYPE, он запустит режим no-quirks, соответствующий этому DOCTYPE, для чтения документа. Если пользовательский агент не распознает правильный DOCTYPE, он активирует режим quirks.

DOCTYPE для стандарта HTML5 определяется как <!DOCTYPE html>
	
  **[⬆ Наверх](#top)**

409. ### <a name="409"></a> Как следует оформлять страницу, содержимое которой может быть на разных языках?

Вопрос немного расплывчатый. Полагаю, что речь о наиболее частом случае: как показывать страницу, где содержимое доступно на нескольких языках, но отображается на одном определенном.

Когда к серверу делается HTTP-запрос, то браузер пользователя обычно отсылает информацию о предпочитаемом языке в заголовке Accept-Language. Сервер может использовать эту информацию, чтобы вернуть версию документа на подходящем языке, если такая возможность есть. В возвращённом HTML-документе обязательно должен быть указан атрибут lang у тега <html>, к примеру <html lang="en">...</html>.

На бэкенде HTML-разметка будет содержать плейсхолдер i18n, а контент для конкретного языка будет храниться в YAML- или JSON-формате. Сервер динамически формирует HTML-страницу с контентом на конкретном языке, чаще всего при помощи бэкенд-фреймворка.
	
  **[⬆ Наверх](#top)**

410. ### <a name="410"></a> На что необходимо обратить внимание при разработке мультиязычных сайтов?

- Используйте атрибут lang в HTML.
- Перенаправляйте пользователей на версию сайта на их языке. Позволяйте быстро и без проблем изменить страну и язык.
- Текст на картинках плохо поддается адаптации. Многие до сих пор помещают текст на картинки чтобы получить хорошо выглядящий несистемный шрифт на любом компьютере. Однако чтобы перевести текст картинкой, нужно иметь подготовленную картинку с каждой строкой текста для каждого языка. При большом количестве текста это быстро выйдет из-под контроля.
- Ограничение длины слов и предложений. Некоторый текст может быть длиннее при написании на другом языке. Будьте внимательны к макету и проверяйте поведение блоков при переполнении. Количество символов важно в таких элементах, как заголовки, лейблы и кнопки. Но не так важно в основном тексте или в блоке комментария.
- Помните о восприятии цветов. В разных языках и культурах цвета имеют разное значение. Дизайн должен учитывать эти особенности.
- Форматируйте даты и валюты. Календарные даты иногда пишутся по-разному. Например, «Май 31, 2012» в США или «31 мая 2012» в странах Европы.
- Не склеивайте переведённые строки. Не пишите что-то вроде "Сегодняшняя дата " + date. Эта фраза будет выглядеть некорректно на языках с другим порядком слов. Вместо этого используйте шаблонную строку с подстановкой параметров для каждого языка. Например, посмотрите на следующие два предложения на русском и китайском соответственно: Я буду путешествовать {% date %} и {% date %} 我会出发. Обратите внимание, что положение переменной отличается из-за грамматических правил языка.
- Разные направления чтения. В русском мы читаем слева направо, сверху вниз. В традиционном японском языке текст читается сверху вниз, справа налево.
	
  **[⬆ Наверх](#top)**

411. ### <a name="411"></a> Для чего нужны data- атрибуты

До того, как JavaScript-фреймворки стали популярны, фронтенд-разработчики использовали data- атрибуты чтобы хранить дополнительные данные прямо в DOM без хаков вроде нестандартных атрибутов или дополнительных свойств в DOM. Атрибуты этого семейства предназначены для хранения частных данных пользователя, для которых не существует более подходящих атрибутов или элементов на странице или в приложении.

На сегодняшний день использование data-атрибутов не поощряется. Одной из причин является то, что пользователь может модифицировать данные в атрибуте, используя инспектор кода в браузере. Данные лучше хранить в самом JavaScript и обновлять DOM при помощи связывания данных через библиотеку или фреймворк.
	
  **[⬆ Наверх](#top)**

412. ### <a name="412"></a> Представьте HTML5 как открытую веб-платформу. Из каких блоков состоит HTML5?

- Семантика. Позволяет более точно описать из чего состоит контент.
- Связанность. Позволяет общаться с сервером новыми и инновационными способами.
- Офлайн и хранилище. Позволяют страницам хранить данные локально на клиентской стороне и более эффективно работать в офлайне.
- Мультимедиа. Ставит создание видео и аудио на первое место в вебе.
- 2D/3D-графика и эффекты. Позволяет расширить возможности презентации.
- Производительность и интеграция. Обеспечивает большую скорость оптимизации и лучшее использование аппаратных средств.
- Доступ к устройствам. Позволяет взаимодействовать с различными устройствами ввода и вывода.
- Стилизация. Позволяет создавать более сложные темы оформления.	

  **[⬆ Наверх](#top)**

413. ### <a name="413"></a> Объясните разницу между cookie, sessionStorage и localStorage

Все вышеупомянутые технологии являются механизмами хранения типа ключ-значение на клиентской стороне. Они могут хранить данные только как строки.

![50](https://user-images.githubusercontent.com/80325645/151212346-bbf5e336-671d-4e48-bffa-18d09816e24b.jpg)
	
  **[⬆ Наверх](#top)**

414. ### <a name="414"></a> Объясните разницу между <script>, <script async> и <script defer>

- <script> - отрисовка HTML блокируется, скрипт извлекается и выполняется немедленно, отрисовка HTML возобновляется после окончания выполнения скрипта.
- <script async> - скрипт будет получен и обработан параллельно с отрисовкой HTML, его выполнение закончится как только это будет возможно (обычно до того, как закончилась отрисовка HTML). Используйте async тогда, когда скрипт не зависит от других скриптов на странице, например для аналитики.
- <script defer> - скрипт будет получен параллельно с отрисовкой HTML, его выполнение произойдет после того, как вся страница будет загружена. Если таких скриптов несколько, то каждый из них будет исполнятся в том порядке, в котором они расположены в документе. Если скрипту нужен полностью распарсеный DOM, то атрибут defer обеспечит уверенность в том, что на момент отработки скрипта весь HTML отрисован. Нет особой разницы со скриптами, расположенными перед тегом <body>. Отложенный скрипт не должен содержать document.write.

Примечание: Атрибуты async и defer игнорируются, если у тега <script> нет атрибута src.
	
  **[⬆ Наверх](#top)**

415. ### <a name="415"></a> Почему хорошей практикой считается располагать <link> для подключения CSS между <head></head>, а <script> для подключения JS ставить перед </body>? Знаете ли вы исключения?

Размещение <link> внутри <head>

Размещение <link> внутри тега <head> необходимо при создании оптимизированного веб-сайта. Когда страница загружается впервые, HTML и CSS анализируются одновременно; HTML создает DOM (объектную модель документа), а CSS создает CSSOM (объектную модель CSS). И то, и другое необходимо для создания визуальных элементов на веб-сайте, что позволяет быстро определить время «первого значимого рисования». Этот прогрессивный рендеринг является категорией оптимизации сайтов, которые измеряются в их показателях эффективности. Размещение таблиц стилей в нижней части документа - это то, что препятствует прогрессивной загрузке страницы во многих браузерах. Некоторые браузеры блокируют рендеринг, чтобы избежать перерисовки элементов страницы, если ее стили изменятся. Все это время пользователь будет пялиться на пустую белую страницу. В других случаях может возникать мерцание нестилизованного содержимого (FOUC), на котором может отображаться веб-страница без применения стилей.

Размещение <script> прямо перед </body>

Теги <script> блокируют отрисовку HTML на то время, пока они скачиваются и исполняются. Размещение скриптов внизу позволяет сперва распарсить и показать пользователю весь HTML.

Исключением является случай, когда в вашем скрипте содержится document.write(). Но на сегодняшний день его использование не считается хорошей практикой. К тому же, расположение скриптов внизу разметки означает, что браузер не может начать их скачивать до тех пор, пока не отрисован весь документ. Единственным рабочим способом, при котором <script> будет расположен внутри <head>, является добавление атрибута defer.
	
  **[⬆ Наверх](#top)**

416. ### <a name="416"></a> Что такое прогрессивный рендеринг

Прогрессивный рендеринг — это название технологий, используемых для ускорения отрисовки страниц (в частности, для уменьшения времени загрузки), чтобы показать пользователю контент как можно скорее.

До того, как широкополосный интернет распространился повсеместно, прогрессивный рендеринг встречался довольно часто. Но этот подход по прежнему полезен в современной разработке, поскольку все более популярным (и ненадежным) становится мобильный доступ в интернет.

Примеры подобных технологий:

- Ленивая загрузка изображений. Изображения на странице не загружаются все разом. JavaScript подгрузит изображения тогда, когда пользователь доскроллит до той части страницы, на которой они расположены.
- Приоритизация видимого контента. Только минимум CSS, контента, скриптов, необходимых для отрисовки той части страницы, которую пользователь увидит первой. Вы можете использовать отложенные скрипты или слушать события DOMContentLoaded или load, чтобы загрузить остальные ресурсы и контент.
- Асинхронные фрагменты HTML. Отправка в браузер частей HTML-страницы, созданной на бэкенде.
	
  **[⬆ Наверх](#top)**

417. ### <a name="417"></a> 

	
  **[⬆ Наверх](#top)**

418. ### <a name="418"></a> Что такое семантика?

`Семантическая вёрстка` — подход к разметке, который опирается не на содержание сайта, а на смысловое предназначение каждого блока и логическую структуру документа. Даже в этой статье есть заголовки разных уровней — это помогает читателю выстроить в голове структуру документа. Так и на странице сайта — только читатели будут немного другими.

`Чтобы сделать сайт доступным.` Зрячие пользователи могут без проблем с первого взгляда понять, где какая часть страницы находится — где заголовок, списки или изображения. Для незрячих или частично незрячих всё сложнее. Основной инструмент для просмотра сайтов не браузер, который отрисовывает страницу, а скринридер, который читает текст со страницы вслух.

Этот инструмент «зачитывает» содержимое страницы, и семантическая структура помогает ему лучше определять, какой сейчас блок, а пользователю понимать, о чём идёт речь. Таким образом семантическая разметка помогает большему количеству пользователей работать с вашим сайтом. Например, наличие заголовков помогает незрячим в навигации по странице. У скринридеров есть функция навигации по заголовкам, что ускоряет знакомство с информацией на сайте.

`Чтобы сайт был выше в поисковиках.` 

`Основные семантические теги HTML`

Тег `i` и тег `em` теги. Внешне ничем не различаются, но семантический смысл разный. Первый тег `i` просто выделяет текст курсивным начертанием, второй же тег em придает тексту, помещенному в него, особый смысл. Текст становится более важным на странице. То есть, если не смотреть внешний результат, то тег `em` дает смысловое выделение, а тег `i` нет. Когда же посмотреть в браузере результат, выглядят они одинаково, но особое значение у текста в теге em. Таким образом, разница между `i` и `em` установлена.

Другой аналогичный пример, теги `b` и `strong`. Здесь даже из названия можно понять, что второй тег гораздо значимый. Действительно, `b` просто выделяет текст жирным начертанием, а `strong` выделяет жирным и придает семантический смысл тексту, помещенного в этот тег. Особенно важно для поисковых систем, текст в `strong` играет большое значение при выдаче.

Среди «старых» тегов из ранних версий HTML тоже есть семантические — например, тег `<p>`, который обозначает параграф. При этом теги `<i>` или `<b>` не семантические, потому что они не добавляют смысла выделенному тексту, а просто определяют его внешний вид.

`<article>`
- Значение: независимая, отделяемая смысловая единица, например комментарий, твит, статья, виджет ВК и так далее.
- Особенности: желателен заголовок внутри.
- Типовые ошибки: путают с тегами `<section>` и `<div>`.

`<section>`
- Значение: смысловой раздел документа. Неотделяемый, в отличие от `<article>`.
- Особенности: желателен заголовок внутри.
- Типовые ошибки: путают с тегами `<article>` и `<div>`.

`<aside>`
- Значение: побочный, косвенный для страницы контент.
- Особенности: может иметь свой заголовок. Может встречаться несколько раз на странице.
- Типовые ошибки: считать `<aside`> тегом для «боковой панели» и размечать этим тегом основной контент, который связан с окружающими его элементами.

`<nav>`
- Значение: навигационный раздел со ссылками на другие страницы или другие части страниц.
- Особенности: используется для основной навигации, а не для всех групп ссылок. Основной является навигация или нет — на усмотрение верстальщика. Например, меню в подвале сайта можно не оборачивать в <nav>. В подвале обычно появляется краткий список ссылок (например, ссылка на главную, копирайт и условия) — это не является основной навигацией, семантически для такой информации предназначен `<footer>` сам по себе.
- Типовые ошибки: многие считают, что в `<nav>` может быть только список навигационных ссылок, но согласно спецификации там может быть навигация в любой форме.

`<header>`
- Значение: вводная часть смыслового раздела или всего сайта, обычно содержит подсказки и навигацию. Чаще всего повторяется на всех страницах сайта.
- Особенности: этих элементов может быть несколько на странице.
- Типовые ошибки: использовать только как шапку сайта.

`<main>`
- Значение: основное, не повторяющееся на других страницах, содержание страницы.
- Особенности: должен быть один на странице, исходя из определения.
- Типовые ошибки: включать в этот тег то, что повторяется на других страницах (навигацию, копирайты и так далее).

`<footer>`
- Значение: заключительная часть смыслового раздела или всего сайта, обычно содержит информацию об авторах, список литературы, копирайт и так далее. Чаще всего повторяется на всех страницах сайта.
- Особенности: этих элементов может быть несколько на странице. Тег `<footer>` не обязан находиться в конце раздела.
- Типовые ошибки: использовать только как подвал сайта.

  **[⬆ Наверх](#top)**

419. ### <a name="419"></a> 

	
  **[⬆ Наверх](#top)**

420. ### <a name="420"></a> 

	
  **[⬆ Наверх](#top)**

421. ### <a name="421"></a> 

	
  **[⬆ Наверх](#top)**

422. ### <a name="422"></a> 

	
  **[⬆ Наверх](#top)**

423. ### <a name="423"></a> 

	
  **[⬆ Наверх](#top)**

499. ### <a name="499"></a> 

	
  **[⬆ Наверх](#top)**

500. ### <a name="500"></a> Варианты добавление CSS стилей на страницу?

- `Подключение CSS через внешний файл стилей тегом link`

Наиболее правильный вариант определения общих стилей для сайта - это подключение внешнего файла CSS с помощью тега <link>.

Чтобы подключить CSS файл, в head области страницы используйте следующую конструкцию:
```js
<link href="URL_адрес_CSS_файла" rel="stylesheet" type="text/css">
```
В атрибуте href необходимо указать URL адрес файла, содержащего набор стилей CSS. Атрибуты rel="stylesheet" и type="text/css" указывают, что указанный файл является таблицей стиля в формате CSS.

Вы можете привязать неограниченное количество файлов CSS к одной странице сайта. Однако подключение большого количества объемных CSS файлов приведет к увеличению веса страницы, и соответственно может привести к увеличению времени загрузки и обработки страницы.

- `Добавление CSS с помощью тега style`

Этот метод подойдет когда нужно вставить (определить) стили для группы уникальных элементов страницы, то есть, набор стилей, которые используются только в пределах одной страницы и не нужны для корректной работы остальных страниц сайта.

В любом месте областей <head> и <body> HTML документа используйте тег <style>, внутри которого поместите необходимые CSS правила.
```js
<style type="text/css">
  /* CSS код */
</style>
```

- `CSS стили для конкретного тега атрибутом style`

Если вам нужно задать стиль для конкретного элемента контента страницы (одного конкретного тега), воспользуйтесь атрибутом style.
```js
<p style="CSS_код">текст</p>
```
Стили, заданные через атрибут style называют inline-стилями. Такие стили имеют приоритет перед стилями, заданными через внешний файл или с помощью тега <style>, но есть исключения.

Inline-стили также обычно используются, когда вы редактируете контент через программы - визуальные редакторы WYSIWYG.

- `Стили CSS через JavaScript`
Практически на каждом современном сайте используются скрипты, написанные на языке JavaScript.

В JavaScript, при использовании библиотеки jQuery, есть много различных функций для управления стилями HTML элементов. Например, функция .css() - задает CSS стиль для элемента, .hide() - добавление элементу CSS свойства display: none; (скрытие элемента) и др.

При использовании этих функций CSS свойства добавляются в style атрибут тега.
	
  **[⬆ Наверх](#top)**

501. ### <a name="501"></a> css modules

`CSS модуль` — это CSS файл, в котором все имена классов и анимаций имеют локальную область видимости по умолчанию.

Ключевая идея здесь — локальная область видимости.

Чтобы проиллюстрировать эту концепцию, давайте создадим JavaScript и CSS файлы компонента.
```js
/* select.css */
.select {}
.loading {}
.item {}
.icon {}
```
```js
/* select.js */
import styles from "./select.css";

console.log(styles.select, styles.loading);
```
 
Зачем нам нужно использовать CSS-модули?

CSS-модули гарантируют, что все стили одного компонента:

Находятся в одном месте
Применяются только к этому компоненту и никакому другому

Кроме того, каждый компонент может иметь настоящие зависимости, например:
```js
import buttons from "./buttons.css";
import padding from "./padding.css";

element.innerHTML = `<div class="${buttons.red} ${padding.large}">`;
```

Этот подход был разработан, что бы решить проблему глобальной области видимости в CSS

Вы когда-нибудь испытывали соблазн в условиях нехватки времени или ресурсов просто писать CSS так быстро, как можете, не думая о последствиях?

Пихали ли в конец таблицы стилей какой-нибудь мусор, собираясь потом его отрефакторить, и так никогда этого и не сделали?

Бывало ли такое, что вы просматривали стили, не до конца понимая что они делают и используются ли они вообще?

Задумывались ли вы, получится ли избавиться от некоторых стилей, ничего при этом не сломав? Не приходилось ли гадать, эти стили работают сами по себе или зависят от других? Случалось ли вам перезаписывать стили?

Это вопросы, которые могут привести к серьезной головной боли, пропущенным дедлайнам и грустным взглядам в окно.

С CSS-модулями и концепцией использования локальной области видимости по умолчанию таких проблем можно избежать. Вам всегда приходится думать о последствиях, когда вы пишите стили.

Например, если вы используете в HTML класс random-gross-class, не обработав его как класс CSS-модуля, стили не применятся, так как CSS-селектор превратится во что-то вроде ._style_random-gross-class_0038089.

`Ключевое слово composes`

Допустим, у нас есть модуль под названием type.css, содержащий стили для текста. В этом файле может быть, например, такое:
```js
.serif-font {
  font-family: Georgia, serif;
}

.display {
  composes: serif-font;
  font-size: 30px;
  line-height: 35px;
}
```
Один из этих классов мы используем в шаблоне:
```js
import type from "./type.css";

element.innerHTML = 
  `<h1 class="${type.display}">
    Пример заголовка
  </h1>`;
```
В результате получится такая разметка:
```js
<h1 class="_type__display_0980340 _type__serif_404840">
  Пример заголовка
</h1>
```
Оба класса связаны с элементом через использование ключевого слова composes, решая таким образом некоторые проблемы, которые есть в похожих решениях, например в @extend Sass.

Так можно даже подставлять данные из отдельного CSS-файла:
```js
.element {
  composes: dark-red from "./colors.css";
  font-size: 30px;
  line-height: 1.2;
}
```

`Нам не нужен БЭМ`, если мы используем CSS-модули. По двум причинам:

- Простота чтения. Код вроде type.display так же понятен для разработчика, как и .font-size__serif--large из БЭМ. Его даже проще читать, чем разросшиеся БЭМ-селекторы.

- Локальная область видимости. Допустим, в одном из модулей у нас есть класс .big и он увеличивает font-size на некоторую величину. В другом модуле у нас есть точно такой же класс .big, который увеличивает padding и font-size на другую величину. И это не имеет никакого значения! Они не будут конфликтовать, так как у стилей различаются области видимости. Даже если модуль импортирует обе таблицы стилей, у классов будет своё уникальное имя, созданное в процессе сборки специально для них.

Другими словами, при использовании CSS-модулей проблемы специфичности селекторов просто исчезают.

  **[⬆ Наверх](#top)**

502. ### <a name="502"></a> Селекторы и их вес

Селектор — это строка, представляющая собой формальное описание структуры, на основе которого выбирается элемент или группа элементов в дереве документа и применяется объявленный блок свойств.

Селекторы бывают самые разные. Существуют простые селекторы, например, состоящие из одной буквы или одного слова, и сложные, состоящие из большого количества слов и различных синтаксических конструкций.
	
Вес селектора — это условные четыре позиции x, x, x, x, которые заполняются нулями и единицами в соответствии с содержимым селектора. Каждая из позиций имеет своё содержимое:

- Инлайн стили
- Идентификаторы
- Классы, атрибуты и псевдоклассы
- Теги и псевдоэлементы	
	
*А что, если вес селекторов одинаковый?*
Допустим, что у вас есть два или несколько селекторов так или иначе указывающих на один и тот же элемент. И вот так сложилось, что вы посчитали или просто взглянули на них, и вес оказался одинаковым. Не стоит отчаиваться, просто блок объявлений последнего селектора в вашем CSS-коде из этой группы и будет применяться к элементу. Как-то так. Мне кажется это логичным. Прямо как в поговорке «кто не успел, тот опоздал», но наоборот: «кто опоздал, тот и успел».	
		
	
  **[⬆ Наверх](#top)**

503. ### <a name="503"></a> Positioning

Устанавливает способ позиционирования элемента относительно окна браузера или других объектов на веб-странице.

Синтаксис
	
position: absolute | fixed | relative | static | inherit
	
Значения
	
- `absolute` - Указывает, что элемент абсолютно позиционирован, при этом другие элементы отображаются на веб-странице словно абсолютно позиционированного элемента и нет. Положение элемента задается свойствами left, top, right и bottom, также на положение влияет значение свойства position родительского элемента. Так, если у родителя значение position установлено как static или родителя нет, то отсчет координат ведется от края окна браузера. Если у родителя значение position задано как fixed, relative или absolute, то отсчет координат ведется от края родительского элемента.
- `fixed` - По своему действию это значение близко к absolute, но в отличие от него привязывается к указанной свойствами left, top, right и bottom точке на экране и не меняет своего положения при прокрутке веб-страницы. Браузер Firefox вообще не отображает полосы прокрутки, если положение элемента задано фиксированным, и оно не помещается целиком в окно браузера. В браузере Opera хотя и показываются полосы прокрутки, но они никак не влияют на позицию элемента.
- `relative` - Положение элемента устанавливается относительно его исходного места. Добавление свойств left, top, right и bottom изменяет позицию элемента и сдвигает его в ту или иную сторону от первоначального расположения.
- `static` - Элементы отображаются как обычно. Использование свойств left, top, right и bottom не приводит к каким-либо результатам.
- `inherit` - Наследует значение родителя.	
	
  **[⬆ Наверх](#top)**

504. ### <a name="504"></a> Margings vs paddings

margin и padding являются наиболее популярными свойствами для расстановки элементов. В то время как margin определяет пространство за пределами (снаружи) элемента, padding определяет пространство внутри элемента.
	
*Блочная модель*
	
Margin, padding и border – это части так называемой Блочной модели. Механизм Блочной модели следующий: Посередине есть зона контента, которую окружает padding, окруженный границей border, которая в свою очередь окружена полями margin. Визуально представление Блочной модели выглядит так:	
	
![box-model-standard-small](https://user-images.githubusercontent.com/80325645/131230563-aadc77ec-a38e-4125-ac9d-29aa64dc0f42.png)
	
	
  **[⬆ Наверх](#top)**

505. ### <a name="505"></a> Добавление шрифтов

Шрифты можно подключать тремя разными спосоами:
	
1. При помощи font-family подключаем лакальный шрифт. Используется редко, так как такие шрифты не используютсяв web. В CSS файле пишем:
```js
html {
	font-family: Roboto, sans-serif;	
}	
```	

2. При помощи удаленных серверов, Google fonts, там есть не все шрифты или они платные
	
Выбираем шрифт, кастомизируем его, выбираем link и вставляем его в html файл до link со стилями. Копируем строку с font-family: 'Roboto', sans-serif и вставляем ее в style.css в тег html {font-family: 'Roboto', sans-serif} и дальше по стилям файла пишем только font-weight: 400 (или любое другое очертание шрифта)	

3. Локальное подключение: если его нету на google fonts то шрифт нужно смотреть на других сайтах, таких как webfonts.pro, находим шрифт, заходим в web и копируем font-face и вставляем его в css файл перед html, редактируем путь до наших локальных шрифтов которые находдятся в этом проекте в папке fonts. Можно добавить font-weight и использовать их по файлу, так лучше и легче
	
	
  **[⬆ Наверх](#top)**

506. ### <a name="506"></a> Видимость элемента. Способы скрыть элемент

Есть свойство, которое позволяет управлять видимостью содержимого элемента.

*visibility* — управляет в CSS, видимостью содержимого элемента.

Значения:
- visible – содержимое отображается.
- hidden — содержимое не отображается.	
- inherit - наследует видимость родительского элемента;
	
		
Следующее свойство, которое позволяет управлять видимостью блока – это display.

*display* — определяет, как будет отображаться элемент

Значения:
- none — элемент не отображается
- block - разбивает строку до и после элемента (т.е. элемент не может находится на одной линии с другими элементами)
- inline - не разбивает строку	
- inline-block - аналогично block;
- list-item - аналогично block, но при этом элемент страницы считается позицией списка.	
	
  **[⬆ Наверх](#top)**

507. ### <a name="507"></a> Z-index

Любые позиционированные элементы на веб-странице могут накладываться друг на друга в определенном порядке, имитируя тем самым третье измерение, перпендикулярное экрану. Каждый элемент может находиться как ниже, так и выше других объектов веб-страницы, их размещением по z-оси и управляет z-index. Это свойство работает только для элементов, у которых значение position задано как absolute, fixed или relative.

Синтаксис
	
z-index: число | auto | inherit

Значения
В качестве значения используются целые числа (положительные, отрицательные и ноль). Чем больше значение, тем выше находится элемент по сравнению с теми элементами, у которых оно меньше. При равном значении z-index, на переднем плане находится тот элемент, который в коде HTML описан ниже. Хотя спецификация и разрешает использовать отрицательные значения z-index, но такие элементы не отображаются в браузере Firefox до версии 2.0 включительно.

Кроме числовых значений применяется auto — порядок элементов в этом случае строится автоматически, исходя из их положения в коде HTML и принадлежности к родителю, поскольку дочерние элементы имеют тот же номер, что их родительский элемент. Значение inherit указывает, что оно наследуется у родителя.	
	
  **[⬆ Наверх](#top)**

508. ### <a name="508"></a> Чем полезны data- атрибуты?

HTML5 спроектирован с возможностью расширения данных ассоциированных с каким-либо элементом, но в то же время не обязательно имеющих определённое значение. data-* атрибуты позволяют хранить дополнительную информацию в стандартных элементах HTML, без хаков вроде нестандартных атрибутов, лишних DOM-свойств или Node.setUserData().

Синтаксис HTML
```html	
<article
	id="electriccars"
	data-columns="3"
	data-index-number="12314"
	data-parent="cars">
</article>
```	
Доступ в JavaScript
```js
var article = document.getElementById('electriccars');
article.dataset.columns // "3"
article.dataset.indexNumber // "12314"
article.dataset.parent // "cars"
```	
Доступ в CSS
```js
article::before {
	content: attr(data-parent);
}
```	
	
  **[⬆ Наверх](#top)**

509. ### <a name="509"></a> Что такое кэш приложения в HTML5?

Доступность в оффлайне становится всё более важной для веб-приложений. Да, все браузеры имеют механизмы кэширования, но они ненадежны и работают не всегда ожидаемо. HTML5 устраняет некоторые из этих неприятностей с помощью интерфейса ApplicationCache.

Использование интерфейса кэша даёт вашему приложению три преимущества:

- автономный просмотр — пользователи могут исследовать ваш сайт целиком, когда они находятся в оффлайне;
- скорость — ресурсы кэшируются локально, поэтому загружаются быстрее;
- снижение нагрузки на сервер — браузер загружает с сервера только изменённые ресурсы.
- Кэш приложения (или AppCache) позволяет разработчику указать, какие файлы браузер должен кэшировать и сделать доступными для оффлайновых пользователей. Ваше приложение будет работать корректно, даже если пользователь нажимает кнопку «Обновить», находясь в автономном режиме.	
	
  **[⬆ Наверх](#top)**

510. ### <a name="510"></a> Объясните разницу между <script>, <script async> и <script defer>

Просто script с src:
- Получить страницу HTML (например, index.html)
- Начните синтаксический анализ HTML
- Парсер встречает тег ```<script>```, ссылающийся на внешний файл script.
- Браузер запрашивает файл script. Между тем, синтаксический анализатор блокирует и останавливает анализ другого HTML на вашей странице.
- Через некоторое время загрузится и затем выполняется script.
- Парсер продолжает анализировать остальную часть HTML-документа.
	
async: Поддерживается всеми браузерами, кроме IE9-. Скрипт выполняется полностью асинхронно. То есть, при обнаружении ```<script async src="...">``` браузер не останавливает обработку страницы, а спокойно работает дальше. Когда скрипт будет загружен – он выполнится.

defer: Поддерживается всеми браузерами, включая самые старые IE. Скрипт также выполняется асинхронно, не заставляет ждать страницу, но есть два отличия от async.

Первое – браузер гарантирует, что относительный порядок скриптов с defer будет сохранён.

Второе отличие – скрипт с defer сработает, когда весь HTML-документ будет обработан браузером.	
	
  **[⬆ Наверх](#top)**

511. ### <a name="511"></a> Дайте пояснения, для какой цели добавленны след. элементы: article, aside, audio, canvas, figcaption, figure, footer, header, hgroup, output, section, video

- article: Тег article задает содержание сайта вроде новости, статьи, записи блога, форума или др. Элемент должен содержать часть самодостаточной информации, которая может быть вырвана из контекста всей страницы без потери смысла.
- aside: Определяет блок сбоку от контента для размещения рубрик, ссылок на архив, меток и другой информации. Такой блок, как правило, называется «сайдбар» или «боковая панель».
- audio: Добавляет, воспроизводит и управляет настройками аудиозаписи на веб-странице. Путь к файлу задается через атрибут src или вложенный тег source. Внутри контейнера audio можно написать текст, который будет выводиться в браузерах, не работающих с этим тегом.
- canvas: Это HTML элемент, использующийся для рисования графики средствами языков программирования (обычно это JavaScript).
- figcaption: Содержит описание для тега figure. Тег figcaption должен быть первым или последним элементом в группе.
- figure: Используется для группирования любых элементов, например, изображений и подписей к ним.
- footer: Тег footer задаёт «подвал» сайта или раздела, в нём может располагаться имя автора, дата документа, контактная и правовая информация.
- header: Тег header задает «шапку» сайта или раздела, в которой обычно располагается заголовок.
- hgroup: Используется для группирования заголовков веб-страницы или раздела. Внутри располагаются теги заголовков от h1 до h6. Данный тег исключён из версии HTML от W3C, но остался в версии WHATWG, будущее элемента пока не определено.
- output: Определяет область в которую выводится информация, преимущественно с помощью скриптов.
- section: Задаёт раздел документа, может применяться для блока новостей, контактной информации, глав текста, вкладок в диалоговом окне и др. Раздел обычно содержит заголовок. Допускается вкладывать один тег section внутрь другого.
- video: Добавляет, воспроизводит и управляет настройками видеоролика на веб-странице. Путь к файлу задается через атрибут src или вложенный тег source.	
	
  **[⬆ Наверх](#top)**

512. ### <a name="512"></a> Чем отличается article от section?

Чтобы не было путаницы, разберём где и когда использовать разные контейнеры:
- div — контейнер общего назначения, не обязательно смысловой. Дивы используются для разметки мелких блоков, создания сетки и декоративных эффектов.
- section — более крупный логический контейнер, объединяющий содержание по смыслу. Например, блок «О компании», список товаров, раздел личной информации в профиле и так далее.
- article — самостоятельный, цельный и независимый раздел документа. Этот раздел можно в неизменном виде использовать в различных местах, в том числе и на других сайтах. Примеры: статья, пост в блоге, сообщение на форуме и так далее.	
	
  **[⬆ Наверх](#top)**

513. ### <a name="513"></a> Можно ли вложить p в другой такой же p? Можно ли вложить div в p?

Синтаксически div и p внутри p является недопустимым во всех стандартах HTML. Более того, при использовании соответствующего парсера HTML невозможно разместить элемент div внутри p в DOM, потому что открывающий тег div автоматически закрывает элемент p.	
	
  **[⬆ Наверх](#top)**

514. ### <a name="514"></a> Чем отличается класс (class) от идентификатора (id) в HTML?

Идентификаторы:
- В коде документа каждый идентификатор уникален и должен быть включён лишь один раз.
- Имя идентификатора чувствительно к регистру.
- Через метод getElementById можно получить доступ к элементу по его идентификатору и изменить свойства элемента.
- Стиль для идентификатора имеет приоритет выше, чем у классов.

Классы:
- Классы могут использоваться в коде неоднократно.
- Имена классов чувствительны к регистру.
- Классы можно комбинировать между собой, добавляя несколько классов к одному тегу.	
	
  **[⬆ Наверх](#top)**

515. ### <a name="515"></a> Что такое прогрессивный рендеринг

Асинхронные фрагменты HTML. Отправка в браузер частей HTML-страницы, созданной на бэкенде. Более подробно про эту технологию можно почитать в этой статье.

Прогрессивный рендеринг — это название технологий, используемых для ускорения отрисовки страниц (в частности, для уменьшения времени загрузки), чтобы показать пользователю контент как можно скорее.

До того, как широкополосный интернет распространился повсеместно, прогрессивный рендеринг встречался довольно часто. Но этот подход по прежнему полезен в современной разработке, поскольку все более популярным (и ненадежным) становится мобильный доступ в интернет.

Примеры подобных технологий:

- Ленивая загрузка изображений. Изображения на странице не загружаются все разом. JavaScript подгрузит изображения тогда, когда пользователь доскроллит до той части страницы, на которой они расположены.
- Приоритизация видимого контента. Только минимум CSS, контента, скриптов, необходимых для отрисовки той части страницы, которую пользователь увидит первой. Вы можете использовать отложенные скрипты или слушать события DOMContentLoaded или load, чтобы загрузить остальные ресурсы и контент.
- Асинхронные фрагменты HTML. Отправка в браузер частей HTML-страницы, созданной на бэкенде.	
	
  **[⬆ Наверх](#top)**

516. ### <a name="516"></a> Почему хорошей практикой считается располагать <link> для подключения CSS между <head></head>, а <script> для подключения JS ставить перед </body>? Знаете ли вы исключения?

### Размещение <link> внутри <head>

Размещение <link> внутри тега <head> необходимо при создании оптимизированного веб-сайта. Когда страница загружается впервые, HTML и CSS анализируются одновременно; HTML создает DOM (объектную модель документа), а CSS создает CSSOM (объектную модель CSS). И то, и другое необходимо для создания визуальных элементов на веб-сайте, что позволяет быстро определить время «первого значимого рисования». Этот прогрессивный рендеринг является категорией оптимизации сайтов, которые измеряются в их показателях эффективности. Размещение таблиц стилей в нижней части документа - это то, что препятствует прогрессивной загрузке страницы во многих браузерах. Некоторые браузеры блокируют рендеринг, чтобы избежать перерисовки элементов страницы, если ее стили изменятся. Все это время пользователь будет пялиться на пустую белую страницу. В других случаях может возникать мерцание нестилизованного содержимого (FOUC), на котором может отображаться веб-страница без применения стилей.

### Размещение <script> прямо перед </body>

Теги <script> блокируют отрисовку HTML на то время, пока они скачиваются и исполняются. Размещение скриптов внизу позволяет сперва распарсить и показать пользователю весь HTML.

Исключением является случай, когда в вашем скрипте содержится document.write(). Но на сегодняшний день его использование не считается хорошей практикой. К тому же, расположение скриптов внизу разметки означает, что браузер не может начать их скачивать до тех пор, пока не отрисован весь документ. Единственным рабочим способом, при котором <script> будет расположен внутри <head>, является добавление атрибута defer.	
	
  **[⬆ Наверх](#top)**

517. ### <a name="517"></a> 

  **[⬆ Наверх](#top)**
	
518. ### <a name="518"></a> Объясните, что такое плавающие элементы (floats) и как они работают?

- Float определяет, по какой стороне будет выравниваться элемент, при этом остальные элементы будут обтекать его с других сторон. Плавающие (обтекающие) элементы сначала выстраиваются в нормальном потоке, затем образуется новый поток, и они сдвигаются либо вправо, либо влево (в зависимости от выбранного значения) в родительском контейнере. Иными словами, они идут по порядку друг за другом. Учитывая, что в родительском контейнере есть достаточно свободного места, эти плавающие элементы не подстраиваются и не выравниваются для распределения пространства между этими самыми элементами.
- Как правило, плавающий элемент обязательно должен иметь фиксированную ширину. Это гарантирует, что float ведет себя так как и ожидалось, избегая проблем в некоторых браузерах.
- Используя свойство clear, вы можете указать пять значений: left, right, both, inherit, и none. Это свойство определяет, по какой стороне будет выравниваться элемент, при этом остальные элементы будут обтекать его с других сторон. Например, если вы укажите «left», элемент задействует отмену обтекания с левого края плавающего элемента. При этом все другие элементы на этой стороне будут опущены вниз, и располагаться под текущим элементом.
- Правило, которое я обнаружил для себя, прекрасно работает для моих float-макетов.В своем HTML коде, я почти всегда сначала создаю плавающие элементы во время разметки, прежде чем добавлять простые элементы, которые могут взаимодействовать с ними. Вы экономите большую часть времени, и это дает желаемый результат.
- Но и тут бывают проблемы, когда вы помещаете в родительский блок плавающие элементы, родительский контейнер не может определить динамически высоту своих дочерних элементов, поэтому родительский контейнер будет иметь высоту равную нулю. Это может поломать вашу верстку. Существует метод, который позволяет родительскому элементу, определить свое пространство с учетом каких-либо плавающих элементов внутри. Можно использовать CSS свойство overflow (переполнение) со значением hidden (скрыть). Обратите внимание, что значение свойства overflow не предназначено для такого рода использования, и может вызывать некоторые проблемы, такие как скрытие нужного контента в данный момент или появление нежелательных полос прокрутки.
- Хак: для очистки плавающих элементов лучше применять ‘overflow:auto’ к родительскому элементу.
- Обратите внимание, что данный трюк не очищает плавающие элементы — он просто растягивает родительский контейнер. Вы можете принудительно очистить float, если вы добавите очищающий элемент после последнего плавающего элемента, или вы можете добавить в любом нужном вам месте, создав тем самым новый поток. Родительский элемент не умеет очищать дочерние плавающие элементы.
	
9 правил:
- Плавающие элементы прижимаются к границам своих контейнеров, но не дальше.
- Любой плавающий элемент будет находится либо рядом, либо ниже предыдущего элемента. Если элементы прижаты влево, второй элемент появится точно справа от первого. Если они прижаты вправо, второй элемент появится слева от первого (reverse).
- Элемент с левым обтеканием, не может быть правее, чем элемент с правым обтеканием.
- Плавающие элементы не могут подняться выше верхнего края родительского контейнера (однако становится еще сложнее, когда задействованы отступы).
- Плавающий элемент не может быть выше своего соседа плавающего элемента.
- Плавающий элемент не может быть выше своего соседа строчного элемента.
- Плавающий элемент совместно со своим таким же соседом элементом, не могут выходить за края родительского контейнера.
- Плавающий элемент должен быть помещен как можно выше.
- Элемент с левым обтеканием должен быть помещен как можно дальше влево, как это возможно, элемент с правым обтеканием должен быть помещен как можно дальше вправо, как это возможно.	
	
  **[⬆ Наверх](#top)**
	
519. ### <a name="519"></a> Что такое flexbox?

- Направлена на предоставление более эффективного способа выравнивания и распределения места между элементами в контейнере (родительском блоке), даже если их размер неизвестен или динамический.
- Основная идея flex-блоков, обладать способностью изменять свою ширина/высота (и другое), чтобы наилучшим образом заполнять свободное место (в основном, для поддержки адаптивности на всех видах устройств и размеров экрана).
- В основном элементы будут распределяться либо вдоль главной оси, либо вдоль поперечной оси контейнера.
- Flex-блоки лучше всего подходят для составных частей приложения и мелкомасштабных компонентов на странице, в то время как grid-блоки больше используется для компонентов на странице большого масштаба.
- Также как существует inline-block, inline-table, существует и inline-flex.	
	
  **[⬆ Наверх](#top)**	

520. ### <a name="520"></a> Как задать flexbox?

Для начала нам нужно выбрать, какие элементы следует выкладывать в виде flex блоков. Для этого мы устанавливаем специальное значение display в родительском элементе тех элементов, которые вы хотите оформить. display: flex;

Примечание: Вы также можете установить значение display inline-flex, если хотите расставить inline элементы как flex блоки.	
	
  **[⬆ Наверх](#top)**
	
521. ### <a name="521"></a> Какие оси есть в flexbox?

- Главная ось (main axis) проходит в том направлении, вдоль которого расположены Flex элемнеты (например, в строку слева направо или вдоль колонок вниз.) Начало и конец этой оси называются main start и main end.
- Поперечная ось (сross axis) проходит перпендикулярно Flex элементам. Начало и конец этой оси называются cross start and cross end.
- Родительский элемент, на который назначено свойство display: flex называется flex container.
- Элементы, размещённые в нём как Flex блоки называются flex items	
	
  **[⬆ Наверх](#top)**
	
522. ### <a name="522"></a> Какое свойство flexbox отвечает за направление flex items?

В Flexbox есть свойство под названием flex-direction, которое определяет направление главной оси (в каком направлении располагаются flexbox дети) — по умолчанию ему присваивается значение row, т.е. располагать дочерние элементы в ряд слева направо (для большинства языков) или справа налево (для арабских языков).

- row | row-reverse | column | column-reverse
- row Основная ось гибкого контейнера определяется так же, как направление текста. Основные начальные и конечные точки совпадают с направлением содержимого.
- row-reverse Ведет себя так же, как строка, но точки начала и конца меняются местами.
- column Главная ось гибкого контейнера такая же, как ось блока. Точки main-start и main-end такие же, как точки до и после режима записи.
- column-reverse Ведет себя так же, как column, но меняет местами main-start и main-end.	
	
  **[⬆ Наверх](#top)**
	
523. ### <a name="523"></a> Какое правило flexbox задает вывод flex items в одну строку или в несколько строк?

Свойство CSS flex-wrap

nowrap | wrap | wrap-reverse	
	
  **[⬆ Наверх](#top)**
	
524. ### <a name="524"></a> Как можно гибко изменять размеры flex элементов?

```js	
article {
  flex: 1 200px;
}

article:nth-of-type(3) {
  flex: 2 200px;
}
```	
Это просто означает, что каждому flex элементу сначала будет дано 200px от свободного места. Потом оставшееся место будет поделено в соответствии с частями пропорций.	
	
  **[⬆ Наверх](#top)**
	
525. ### <a name="525"></a> Расскажите про flex-grow, flex-shrink, flex-basis?

- Свойство CSS flex-grow определяет, какую часть свободного пространства может занять контейнер, в соотношении с другими контейнерами.
- flex-shrink — свойство CSS, которое определяет фактор сжатия flex-элемента. Flex-элементы будут заполнять контейнер в зависимости от значения flex-shrink, когда стандартная ширина flex-элементов шире, чем flex-контейнер.
- flex-basis CSS свойство задает базовые размеры флекс элемента, а именно ширину. Это свойство определяет размер содержимого контента, если оно не было заданно свойством box-sizing.	
	
  **[⬆ Наверх](#top)**
	
526. ### <a name="526"></a> Что такое css grid?

- Значение grid позволяет нам создавать макет сетки. Она направлена на решении проблем со старыми методами компоновки блоков, имеющих float и inline-block, которые в свою очередь имеют недостатки, и действительно не предназначались для макета страницы.
- Основная идея grid-концепции, управлять содержимым, обеспечивая механизм распределения имеющегося пространство блоков в столбцы и строки, с помощью набора заранее установленных размеров.
- Вместе с этим фактом мы можем устранить проблемы, которые появляются при разработке, опираясь на старую технику разработки сайтов, теперь вы тратите меньше усилий.
- Не поддерживается. Только в IE10+.
- Также как существует inline-block, inline-table, inline-flex, существует и inline-grid	
	
  **[⬆ Наверх](#top)**
	
527. ### <a name="527"></a> Можно ли использовать css grid и flexbox вместе?

Flexbox и Grid это не два противоборствующих свойства, они наоборот дополняют друг друга.

Grid - инструмент позиционирования основных блоков страницы.

Flexbox - инструмент позиционирования элементов внутри блоков, спозиционированных с помощью Grid.	
	
  **[⬆ Наверх](#top)**
	
528. ### <a name="528"></a> Объясните, как браузер определяет, на какие элементы накладывать CSS стили?

CSSOM (объектная модель CSS) — это объект, представляющий стили, связанные с DOM. Он выглядит так же как DOM, но с соответствующими стилями для каждого узла. Не имеет значения были ли стили объявлены явно или наследуются.	
	
  **[⬆ Наверх](#top)**
	
529. ### <a name="529"></a> Объясните, что такое псевдоэлементы и для чего они нужны.

Псевдоэлемент - это ключевое слово, добавляемое к селектору, которое позводяет стилизовать определенную часть выбранного элемента. Они могут использоваться для украшения (:first-line, :first-letter) или для добавления элементов к разметке (вместе c content: ...) без изменения HTML.	
	
  **[⬆ Наверх](#top)**
	
530. ### <a name="530"></a> Что делает * { box-sizing: border-box; }? В чём его преимущества?

По умолчанию все элементы имеют box-sizing: content-box. Размеры блока рассчитываются из размеров контента.

box-sizing: border-box меняет то, как расчитываются width и height. Border и padding включаются в расчёт. Высота будет состоять из: высота контента + вертикальные padding'и + ширина вертикальных border. Ширина будет состоять из: ширина контента + горизонтальные padding'и + ширина горизонтальных border.	
	
  **[⬆ Наверх](#top)**
	
531. ### <a name="531"></a> В чём разница между строчным и блочно-строчным элементом?

Для лучшего сравнения я добавил блочный элемент.

block

- Начинается с новой строки родительского элемента и занимает всю строку.
- Можно задавать ширину и высоту.
- Можно выровнять с помощью vertical-align.
- Margins и paddings работают со всех сторон.
	
inline-block

- Размер зависит от контента.
- Можно задавать ширину и высоту.
- Можно выровнять с помощью vertical-align.
- Margins и paddings работают со всех сторон.
	
inline

- Размер зависит от контента.
- Ширину и высоту задавать нельзя.
- Можно выровнять только по горизонтали. Место, которое занимает элемент по вертикали, зависит от line-height.
- Ведёт себя как блочный элемент, если задать вертикальные margins и paddings.	
	
  **[⬆ Наверх](#top)**
	
532. ### <a name="532"></a> Можете ли вы объяснить разницу между отзывчивым (responsive) сайтом и сайтом, сделанным по принципу mobile-first?

Отзывчивая и mobile-first верстки служат для того, чтобы пользователь мог пользоваться сайтом с разных устройств. Верстка подстраивается под различные размеры экрана, разрешения, контекст использования, механизмы контроля и т.д.

Отзывчивая верстка начинается с верстки десктопной версии сайта. Затем она адаптируется для меньших экранов.

Mobile-first начинается с верстки версии сайта для мобильных устройств.	
	
  **[⬆ Наверх](#top)**
	
533. ### <a name="533"></a> Свойства display - основные значения и как они работают

None, Block, Inline, Inline-block, Flex, Grid

Inline - элеменнты в одну строку и их размер завист от содержимого

Block - размеры определяются размерами самого блока задаными в стилях, но сам блок занимает всю свободную ширину экрана

Inline-block - элементы расположены в одну строку, но мы можем им задавать размер

Flex - можем управлять как угодно, это display flex

Grid - большая тема, смотрю видео

  **[⬆ Наверх](#top)**
	
534. ### <a name="534"></a> Keyframes для чего нужно и как использовать?

`Keyframes` - определяет ключевые кадры по которым будет работать анимация, указывается начальная точка и конечная, так же эти точки можно указывать в %. Ключевое слова animation.

  **[⬆ Наверх](#top)**
	
535. ### <a name="535"></a> 

  **[⬆ Наверх](#top)**
	
536. ### <a name="536"></a> 

  **[⬆ Наверх](#top)**	  
