<a name="top"></a>

[–ù–∞ –≥–ª–∞–≤–Ω—É—é](../../README.md)

[–ü–µ—Ä–µ–π—Ç–∏ –∫ –≤–æ–ø—Ä–æ—Å–∞–º](#questions)

| ‚Ññ. | –í–æ–ø—Ä–æ—Å |
| --- | --------- |
|   | ReactJS Grundlagen |
|1 | [Was ist React und welche Probleme l√∂st es?](#1) |
|2 | [Was ist JSX und warum wird es verwendet?](#2) |
|3 | [Was ist Virtual DOM und wie funktioniert es?](#3) |
|4 | [Was ist der Unterschied zwischen React und ReactDOM?](#4) |
|5 | [Warum importieren wir React, auch wenn es scheinbar nicht benutzt wird?](#5) |
|6 | [Was ist ein React Fragment und warum ist es n√ºtzlich?](#6) |
|7 | [Was ist der Unterschied zwischen einem Element, einer Komponente und einer Instanz?](#7) |
|8 | [Was ist das Fiber-Architekturmodell in React?](#8) |
|9 | [Was bedeutet ‚ÄûBatching‚Äú in React?](#9) |
|10 | [Was ist die Rolle des key in React-Listen?](#10) |
|11 | [Wie funktioniert die Wiederverwendung von Komponenten?](#11) |
|12 | [](#12) |
|13 | [](#13) |
|14 | [](#14) |
|15 | [](#15) |
|16 | [](#16) |
|17 | [](#17) |
|18 | [](#18) |
|19 | [](#19) |
|20 | [](#20) |
|   | Komponenten, Props & State |
|21 | [Was sind Props und wozu werden sie verwendet?](#21) |
|22 | [Was ist der Unterschied zwischen Props und State?](#22) |
|23 | [Warum sind Props nur lesbar?](#23) |
|24 | [Wie funktioniert der unidirektionale Datenfluss in React?](#24) |
|25 | [Was ist State in Klassen- und Funktionskomponenten?](#25) |
|26 | [Wie funktioniert setState?](#26) |
|27 | [Was ist der Unterschied zwischen kontrollierten und unkontrollierten Komponenten?](#27) |
|28 | [Was sind Default Props und PropTypes?](#28) |
|29 | [Was ist React.memo und wof√ºr wird es verwendet?](#29) |
|30 | [Was ist PureComponent und wie unterscheidet es sich von Component?](#30) |
|31 | [Wann sollte shouldComponentUpdate verwendet werden?](#31) |
|32 | [Was ist ein ref und wann wird er eingesetzt?](#32) |
|33 | [Was bedeutet ‚ÄûLifting State Up‚Äú?](#33) |
|34 | [](#34) |
|35 | [](#35) |
|36 | [](#36) |
|37 | [](#37) |
|38 | [](#38) |
|39 | [](#39) |
|40 | [](#40) |
|   | Lebenszyklus von Komponenten |
|41 | [Was sind die Phasen des Komponentenlebenszyklus?](#41) |
|42 | [Welche Lifecycle-Methoden gibt es in Klassenkomponenten?](#42) |
|43 | [Welche Lifecycle-Methoden sind veraltet?](#43) |
|44 | [Wie kann man Lifecycle-Methoden mit Hooks ersetzen?](#44) |
|45 | [Was ist componentDidMount und was ist das √Ñquivalent mit Hooks?](#45) |
|46 | [](#46) |
|47 | [](#47) |
|48 | [](#48) |
|49 | [](#49) |
|50 | [](#50) |
|   | Hooks |
|51 | [Was sind Hooks in React?](#51) |
|52 | [Wie funktionieren useState und useEffect?](#52) |
|53 | [Was macht useContext?](#53) |
|54 | [Was ist useRef und wann wird es verwendet?](#54) |
|55 | [Was ist useCallback, useMemo, useReducer?](#55) |
|56 | [Wie schreibt man einen benutzerdefinierten Hook?](#56) |
|57 | [Wie verhindert man eine Endlosschleife in useEffect?](#57) |
|58 | [Wie implementiert man Timeout oder Interval mit Hooks?](#58) |
|59 | [](#59) |
|60 | [](#60) |
|   | React-Patterns und Konzepte |
|61 | [Was ist ein Higher-Order Component (HOC)?](#61) |
|62 | [Was ist das Render-Prop-Pattern?](#62) |
|63 | [Was ist die Context-API und wie funktioniert useContext?](#63) |
|64 | [Was sind Portale in React?](#64) |
|65 | [Was ist bedingtes Rendern (Conditional Rendering)?](#65) |
|66 | [Was ist ein Error Boundary?](#66) |
|67 | [Wie funktioniert Event-Handling in React?](#67) |
|68 | [Was ist ein synthetisches Ereignis (SyntheticEvent)?](#68) |
|69 | [Was ist props.children?](#69) |
|70 | [Was bedeutet ‚Äûcontrolled component‚Äú und ‚Äûuncontrolled component‚Äú bei Formularen?](#70) |
|71 | [](#71) |
|72 | [](#72) |
|73 | [](#73) |
|74 | [](#74) |
|75 | [](#75) |
|   | Daten & API |
|76 | [Wie f√ºhrt man API-Aufrufe mit Fetch oder Axios durch?](#76) |
|77 | [Wie verwaltet man Lade-, Fehler- und Erfolgsstatus?](#77) |
|78 | [Wie funktioniert WebSocket mit React?](#78) |
|79 | [Wie kann man Daten zwischen Komponenten weitergeben?](#79) |
|80 | [Wie macht man einen Datenabruf nur beim ersten Rendern?](#80) |
|81 | [Was ist das Problem bei ‚Äûstale closures‚Äú mit Hooks?](#81) |
|82 | [Wie funktioniert die Fehlerbehandlung mit try/catch in React?](#82) |
|83 | [Wie kann man ein Mock-API oder Mock Server verwenden?](#83) |
|84 | [Wie funktioniert Suspense f√ºr Datenabfragen?](#84) |
|85 | [](#85) |
|86 | [](#86) |
|87 | [](#87) |
|88 | [](#88) |
|89 | [](#89) |
|90 | [](#90) |
|   | Testing |
|91 | [Was ist Unit-, Integration- und E2E-Testing?](#91) |
|92 | [Was ist Snapshot-Testing?](#92) |
|93 | [Welche Tools nutzt man f√ºr React-Tests (Jest, React Testing Library)?](#93) |
|94 | [Wie testet man Komponenten, Props und Events?](#94) |
|95 | [Wie testet man benutzerdefinierte Hooks?](#95) |
|96 | [](#96) |
|97 | [](#97) |
|98 | [](#98) |
|99 | [](#99) |
|100 | [](#100) |
|   | Routing mit React Router |
|101 | [Wie funktioniert Routing in React mit react-router-dom?](#101) |
|102 | [Was sind die Unterschiede zwischen react-router v5 und v6?](#102) |
|103 | [Was sind Route, Link, Navigate, Outlet?](#103) |
|104 | [Wie erstellt man Nested Routes?](#104) |
|105 | [Wie implementiert man Redirects?](#105) |
|106 | [Wie funktioniert programmgesteuerte Navigation (useNavigate)?](#106) |
|107 | [](#107) |
|108 | [](#108) |
|109 | [](#109) |
|110 | [](#110) |
|   | Redux & Redux Toolkit |
|111 | [Was ist Redux und wie funktioniert es?](#111) |
|112 | [Was sind Actions, Reducer und Store?](#112) |
|113 | [Wie funktioniert Redux Toolkit (createSlice, configureStore, createAsyncThunk)?](#113) |
|114 | [Was ist RTK Query?](#114) |
|115 | [Was ist der Unterschied zwischen Redux und der Context-API?](#115) |
|116 | [Was ist connect() in Redux?](#116) |
|117 | [Was sind Middleware in Redux (z. B. redux-thunk, redux-logger)?](#117) |
|118 | [Was ist createSelector und wie funktioniert Reselect?](#118) |
|119 | [Wie verbindet man Redux mit React √ºber Hooks (useSelector, useDispatch)?](#119) |
|120 | [](#120) |
|121 | [](#121) |
|122 | [](#122) |
|123 | [](#123) |
|124 | [](#124) |
|125 | [](#125) |
|126 | [](#126) |
|127 | [](#127) |
|128 | [](#128) |
|129 | [](#129) |
|130 | [](#130) |
|   | Optimierung & Performance |
|131 | [Was ist Code-Splitting?](#131) |
|132 | [Wie funktionieren React.lazy und Suspense?](#132) |
|133 | [Was ist Tree Shaking?](#133) |
|134 | [Was ist Server-Side Rendering (SSR) und Hydration?](#134) |
|135 | [Wie geht man mit Hydration-Fehlern bei SSR um?](#135) |
|136 | [Was bedeutet Virtualisierung (z. B. mit react-window)?](#136) |
|137 | [Wie verhindert man unn√∂tige Re-Renders?](#137) |
|138 | [Was ist React Transition Group?](#138) |
|139 | [Was ist React Strict Mode und welche Vorteile bietet er?](#139) |
|140 | [Was ist Concurrent Mode und welche Probleme l√∂st er?](#140) |
|141 | [](#141) |
|142 | [](#142) |
|143 | [](#143) |
|144 | [](#144) |
|145 | [](#145) |
|   | Sonstiges |
|146 | [Was ist ein Service Worker?](#146) |
|147 | [Was ist react-helmet und wie hilft es beim SEO?](#147) |
|148 | [Wie funktioniert Lazy Loading mit dynamic import()?](#148) |
|149 | [Was ist ein Finite-State Machine (FSM), z. B. mit XState?](#149) |
|150 | [Wie kann man ein Formular mit Formik und Yup erstellen und validieren?](#150) |
|151 | [Wie konfiguriert man ESLint und Prettier in einem React-Projekt?](#151) |
|152 | [Wie funktioniert dynamic import() in React (Syntax, Anwendungsf√§lle)?](#152) |
|153 | [](#153) |
|154 | [](#154) |
|155 | [](#155) |
|156 | [](#156) |
|157 | [](#157) |
|158 | [](#158) |
|159 | [](#159) |
|160 | [](#160) |
|   | React + TypeScript |
|161 | [Was ist der Unterschied zwischen interface und type in TypeScript?](#161) |
|162 | [Wie typisiert man Props und State in einer funktionalen Komponente?](#162) |
|163 | [Wie nutzt man Generics in React mit TypeScript (z. B. f√ºr Listen)?](#163) |
|164 | [Wie typisiert man Events in React mit TypeScript (onChange, onClick, FormEvent, MouseEvent)?](#164) |
|165 | [Wie erstellt man einen benutzerdefinierten Hook mit TypeScript?](#165) |
|166 | [Wie typisiert man useReducer mit TypeScript?](#166) |
|167 | [Wie typisiert man children korrekt in React-Komponenten?](#167) |
|168 | [Was ist React.FC und welche Vor- und Nachteile hat es?](#168) |
|169 | [Wie typisiert man eine Komponente mit optionalen Props?](#169) |
|170 | [Wie arbeitet man mit Drittanbieter-Bibliotheken, die keine Typen enthalten?](#170) |
|171 | [Was ist der Unterschied zwischen ESM und CommonJS?](#171) |
|172 | [](#172) |
|173 | [](#173) |
|174 | [](#174) |
|175 | [](#175) |
|176 | [](#176) |
|177 | [](#177) |
|178 | [](#178) |
|179 | [](#179) |
|180 | [](#180) |
|181 | [](#181) |
|182 | [](#182) |
|183 | [](#183) |
|184 | [](#184) |
|185 | [](#185) |
|186 | [](#186) |
|187 | [](#187) |
|188 | [](#188) |
|189 | [](#189) |
|190 | [](#190) |
|191 | [](#191) |
|192 | [](#192) |
|193 | [](#193) |
|194 | [](#194) |
|195 | [](#195) |
|196 | [](#196) |
|197 | [](#197) |
|198 | [](#198) |
|199 | [](#199) |
|200 | [](#200) |



<a name="questions"></a>

## ReactJS 

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**
  
1. ### <a name="1"></a> Was ist React und welche Probleme l√∂st es?

**React** ist eine **JavaScript-Bibliothek** f√ºr den Aufbau von **User Interfaces** (UI), entwickelt von Facebook (heute Meta). Sie konzentriert sich auf die **View-Schicht** (im MVC-Pattern) und l√∂st typische Probleme moderner Frontend-Entwicklung:

### Probleme, die React l√∂st

1. **Komplexit√§t bei dynamischen UIs**

   * Klassisches DOM-Manipulieren mit `document.querySelector` oder `innerHTML` ist fehleranf√§llig und schwer zu warten.
   * React nutzt das **Virtual DOM**, um √Ñnderungen effizient zu berechnen und nur die n√∂tigen Teile des echten DOM zu aktualisieren.

2. **Wiederverwendbarkeit von UI-Logik**

   * In Vanilla JS oder jQuery ist es schwierig, UI-Elemente als eigenst√§ndige, wiederverwendbare Bausteine zu organisieren.
   * React bietet **Komponenten** (Functions oder Classes), die UI + Logik kapseln.

3. **State-Management**

   * Ohne Framework muss man Zust√§nde (z. B. Eingaben, UI-√Ñnderungen) manuell im DOM nachverfolgen.
   * React bietet ein klares **State- und Props-Konzept**: Datenfluss von oben nach unten (Top-down Data Flow) und kontrollierte Zustandsverwaltung.

4. **Lesbarkeit & Wartbarkeit**

   * Mit **JSX** verbindet React deklarative Syntax mit JavaScript, wodurch UI-Struktur dem HTML √§hnelt, aber direkt in JS geschrieben wird.
   * Dadurch wird Code strukturierter, testbarer und besser wartbar.

---

### Beispiel

```jsx
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Aktueller Wert: {count}</p>
      <button onClick={() => setCount(count + 1)}>
        Erh√∂hen
      </button>
    </div>
  );
}

export default Counter;
```

* `useState` verwaltet den Zustand.
* Bei jedem Klick wird nur der relevante Teil des DOM aktualisiert.

---

### Zusammenfassung

* **React** = Bibliothek f√ºr deklarative UI-Entwicklung.
* L√∂st Probleme: ineffiziente DOM-Manipulation, fehlende Wiederverwendbarkeit, un√ºbersichtliches State-Handling.
* Schl√ºsselkonzepte: **Virtual DOM, Komponenten, State, Props, JSX**.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Grundlagen](https://react.dev/learn)
* [MDN ‚Äì Einf√ºhrung in das DOM](https://developer.mozilla.org/ru/docs/Web/API/Document_Object_Model/Introduction)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

2. ### <a name="2"></a> Was ist JSX und warum wird es verwendet?

**JSX (JavaScript XML)** ist eine **erweiterte Syntax f√ºr JavaScript**, die es erlaubt, UI-Strukturen in einer HTML-√§hnlichen Schreibweise direkt im JavaScript-Code zu definieren. JSX wird von **Babel** oder anderen Transpilern in reines JavaScript (meist `React.createElement`) √ºbersetzt.

---

### Warum wird JSX verwendet?

1. **Deklarative UI-Beschreibung**

   * UI-Struktur sieht aus wie HTML, ist aber vollst√§ndig in JavaScript eingebettet.
   * Entwicklern f√§llt es leichter, die Logik und das UI zusammen zu lesen und zu verstehen.

2. **Verkn√ºpfung von Logik und Darstellung**

   * Man kann JavaScript-Ausdr√ºcke direkt in JSX einbetten: `{...}`.
   * Bedingte Renderings oder Schleifen lassen sich elegant integrieren.

3. **Bessere Lesbarkeit & Wartbarkeit**

   * Statt verschachtelter `React.createElement`-Aufrufe ist JSX k√ºrzer, klarer und n√§her an HTML.

---

### Beispiel

```jsx
import { useState } from "react";

function Greeting() {
  const [name, setName] = useState("Sergii");

  return (
    <div>
      <h1>Hallo, {name}!</h1> {/* JS-Ausdruck in geschweiften Klammern */}
      <button onClick={() => setName("Frontend-Dev")}>
        √Ñndern
      </button>
    </div>
  );
}

export default Greeting;
```

Ohne JSX w√ºrde derselbe Code so aussehen:

```js
import { createElement, useState } from "react";

function Greeting() {
  const [name, setName] = useState("Sergii");

  return createElement(
    "div",
    null,
    createElement("h1", null, `Hallo, ${name}!`),
    createElement(
      "button",
      { onClick: () => setName("Frontend-Dev") },
      "√Ñndern"
    )
  );
}
```

---

### Zusammenfassung

* **JSX** = Syntax-Erweiterung f√ºr JavaScript, die UI-Strukturen wie HTML aussehen l√§sst.
* Vorteile: bessere Lesbarkeit, Integration von Logik + UI, effizienteres Arbeiten mit React.
* JSX wird in reines JavaScript transpiliert.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì JSX](https://react.dev/learn/writing-markup-with-jsx)
* [MDN ‚Äì JSX (Einf√ºhrung)](https://developer.mozilla.org/ru/docs/Glossary/JSX)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

3. ### <a name="3"></a> Was ist Virtual DOM und wie funktioniert es?

**Virtual DOM (VDOM)** ist eine **leichte, virtuelle Repr√§sentation** des echten DOM im Speicher. Es dient als Zwischenschicht, um √Ñnderungen effizient zu berechnen, bevor sie im **realen DOM** angewendet werden.

---

### Funktionsweise

1. **Rendern in den Virtual DOM**

   * Wenn sich State oder Props √§ndern, erzeugt React ein **neues Virtual DOM**-Baumobjekt.

2. **Diffing-Algorithmus**

   * React vergleicht den neuen VDOM mit der vorherigen Version (Reconciliation).
   * Nur die Unterschiede (‚Äûdiff‚Äú) werden ermittelt.

3. **Minimaler Update im echten DOM**

   * React aktualisiert nur die tats√§chlich ver√§nderten Teile im **realen DOM**.
   * Dadurch sind Updates wesentlich effizienter, da direkte DOM-Manipulationen sehr teuer sind.

---

### Beispiel

```jsx
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Z√§hler: {count}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
    </div>
  );
}

export default Counter;
```

* Bei `setCount` erstellt React ein neues Virtual DOM.
* React erkennt, dass nur `<p>` sich ge√§ndert hat.
* Nur dieser Knoten im echten DOM wird neu gerendert, **nicht die gesamte Seite**.

---

### Zusammenfassung

* **Virtual DOM** = virtuelles Abbild des echten DOM.
* Ablauf: **neuer VDOM ‚Üí Diffing ‚Üí minimaler DOM-Update**.
* Vorteil: Performance, klare Trennung von Logik und DOM-Manipulation.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Reconciliation](https://react.dev/learn/render-and-commit#step-2-react-renders-your-components)
* [MDN ‚Äì DOM Einf√ºhrung](https://developer.mozilla.org/ru/docs/Web/API/Document_Object_Model/Introduction)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

4. ### <a name="4"></a> Was ist der Unterschied zwischen React und ReactDOM?

**React** ist die **Kernbibliothek**, die Werkzeuge f√ºr das **Erstellen von Komponenten, State-Management, Hooks und JSX-Verarbeitung** bereitstellt.
**ReactDOM** ist das **Rendering-Paket**, das React-Komponenten mit dem **echten DOM im Browser** verbindet.

---

### Details

1. **React**

   * Definiert, **wie** UI-Komponenten aussehen und funktionieren.
   * Enth√§lt Hooks wie `useState`, `useEffect`.
   * Ist plattformunabh√§ngig (kann auch mit React Native, ReactDOM, ReactVR genutzt werden).

2. **ReactDOM**

   * Speziell f√ºr **Web-Umgebungen** gedacht.
   * Stellt Funktionen wie `createRoot` oder `render` bereit, um React-Komponenten in den Browser zu mounten.
   * Trennt die Logik von der konkreten Rendering-Umgebung (Browser-DOM).

---

### Beispiel

```jsx
// index.jsx
import React from "react";
import { createRoot } from "react-dom/client";
import App from "./App.jsx";

const root = createRoot(document.getElementById("root"));
root.render(<App />);
```

* `React` stellt die Komponente `App` bereit.
* `ReactDOM` sorgt daf√ºr, dass diese Komponente im `<div id="root">` im Browser angezeigt wird.

---

### Zusammenfassung

* **React** = Kernbibliothek (Komponenten, State, Hooks).
* **ReactDOM** = Bindeglied zum echten Browser-DOM (Mounting, Rendering).
* Trennung erm√∂glicht, React auch au√üerhalb des Browsers (z. B. mit React Native) zu verwenden.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Einstieg](https://react.dev/learn)
* [ReactDOM API ‚Äì Offizielle Docs](https://react.dev/reference/react-dom)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

5. ### <a name="5"></a> Warum importieren wir React, auch wenn es scheinbar nicht benutzt wird?

Fr√ºher musste man in jeder Datei mit JSX immer **`import React from "react";`** schreiben, auch wenn React im Code nicht direkt benutzt wurde.
Grund: **JSX wird von Babel in `React.createElement`-Aufrufe umgewandelt**, daher war `React` im Scope notwendig.

Seit **React 17 (2020)** wurde das durch die **neue JSX-Transform** ge√§ndert:

* Der Compiler f√ºgt die n√∂tigen Funktionen automatisch hinzu.
* Deshalb muss man `import React` nicht mehr explizit einf√ºgen, wenn man nur JSX nutzt.
* In √§lteren Projekten oder Setups ohne neue Transform ist der Import weiterhin Pflicht.

---

### Beispiel ‚Äì Babel-Umwandlung

**JSX-Eingabe:**

```jsx
const element = <h1>Hallo Welt</h1>;
```

**Transpilierte Ausgabe (vor React 17):**

```js
import React from "react";

const element = React.createElement("h1", null, "Hallo Welt");
```

**Transpilierte Ausgabe (ab React 17 mit neuer JSX-Transform):**

```js
import { jsx as _jsx } from "react/jsx-runtime";

const element = _jsx("h1", { children: "Hallo Welt" });
```

---

### Zusammenfassung

* Fr√ºher: `import React` war n√∂tig, weil JSX ‚Üí `React.createElement` kompiliert wurde.
* Heute (React 17+): Dank neuer JSX-Transform meist **nicht mehr notwendig**.
* Import wird nur gebraucht, wenn man `React` direkt nutzt (z. B. `React.Children`, `React.cloneElement`).

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Neue JSX-Transform](https://react.dev/blog/2020/09/22/introducing-the-new-jsx-transform)
* [MDN ‚Äì JSX](https://developer.mozilla.org/ru/docs/Glossary/JSX)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

6. ### <a name="6"></a> Was ist ein React Fragment und warum ist es n√ºtzlich?

**React Fragment** ist ein spezieller Wrapper (`<React.Fragment>` oder Kurzschreibweise `<>...</>`), mit dem man **mehrere Elemente gruppieren** kann, **ohne zus√§tzliches DOM-Element** (wie `<div>`) zu erzeugen.

---

### Warum n√ºtzlich?

1. **Kein unn√∂tiges DOM-Markup**

   * `<div>`-Wrapper erzeugen oft ‚Äûdiv soup‚Äú und machen das DOM un√ºbersichtlich.
   * Fragmente f√ºgen nichts ins echte DOM ein.

2. **Mehrere Elemente zur√ºckgeben**

   * Eine React-Komponente darf nur **ein einziges Root-Element** zur√ºckgeben.
   * Mit Fragmenten kann man mehrere Geschwister-Elemente zur√ºckgeben.

3. **Performance & Semantik**

   * Weniger DOM-Knoten ‚Üí bessere Performance.
   * Bessere Semantik, da unn√∂tige Container-Elemente vermieden werden.

---

### Beispiel

```jsx
import React from "react";

function UserInfo() {
  return (
    <>
      <h2>Benutzername: Sergii</h2>
      <p>Rolle: Frontend-Entwickler</p>
    </>
  );
}

export default UserInfo;
```

Ohne Fragment m√ºsste man alles in ein `<div>` packen:

```jsx
function UserInfo() {
  return (
    <div>
      <h2>Benutzername: Sergii</h2>
      <p>Rolle: Frontend-Entwickler</p>
    </div>
  );
}
```

Ergebnis im DOM:

* Mit Fragment ‚Üí nur `<h2>` und `<p>`.
* Mit `<div>` ‚Üí unn√∂tiger zus√§tzlicher Container.

---

### Zusammenfassung

* **React Fragment** gruppiert mehrere Elemente ohne zus√§tzliches DOM-Tag.
* Vorteile: sauberes DOM, bessere Semantik, kein ‚Äûdiv soup‚Äú.
* Schreibweisen: `<React.Fragment>...</React.Fragment>` oder `<>...</>`.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Fragments](https://react.dev/reference/react/Fragment)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

7. ### <a name="7"></a> Was ist der Unterschied zwischen einem Element, einer Komponente und einer Instanz?

### Unterschied: Element, Komponente, Instanz

1. **React Element**

   * Ein **leichtes, unver√§nderliches Objekt**, das beschreibt, **was im UI gerendert werden soll**.
   * Wird von JSX erzeugt und dient React als Bauplan.
   * Beispiel:

   ```jsx
   const element = <h1>Hallo</h1>; // React Element
   ```

2. **React Komponente**

   * Eine **Funktion oder Klasse**, die React Elements zur√ºckgibt.
   * Definiert **wie UI-Elemente aufgebaut sind** (Logik + Struktur).
   * Beispiel:

   ```jsx
   function Greeting() {
     return <h1>Hallo Sergii</h1>;
   }
   ```

3. **Instanz einer Komponente**

   * Entsteht, wenn React eine Komponente **rendert** und im UI einsetzt.
   * Jede Verwendung von `<Greeting />` erzeugt eine neue Instanz dieser Komponente.
   * Beispiel:

   ```jsx
   function App() {
     return (
       <>
         <Greeting />   {/* Instanz 1 */}
         <Greeting />   {/* Instanz 2 */}
       </>
     );
   }
   ```

---

### Bildhafte Erkl√§rung

* **Element** = Bauplan/Zwischenschicht (JSX-Output).
* **Komponente** = Definition (Funktion/Klasse).
* **Instanz** = konkrete Auspr√§gung der Komponente im DOM.

---

### Zusammenfassung

* **Element**: unver√§nderliches Objekt, beschreibt UI.
* **Komponente**: Funktion/Klasse, die Elemente zur√ºckgibt.
* **Instanz**: konkrete gerenderte Erscheinung einer Komponente.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Rendering Elements](https://react.dev/learn/render-and-commit)
* [MDN ‚Äì Komponenten-Definition](https://developer.mozilla.org/ru/docs/Glossary/Component)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

8. ### <a name="8"></a> Was ist das Fiber-Architekturmodell in React?

### Fiber-Architekturmodell in React

**React Fiber** ist die **neue Rendering-Engine** von React (seit v16), die das alte ‚ÄûStack Reconciler‚Äú-Modell ersetzt. Ziel: **flexible, unterbrechbare Updates** im UI.

---

### Hauptideen

1. **Unterbrechbare Renderings**

   * Gro√üe UI-Updates k√∂nnen in **kleine Arbeitseinheiten** zerlegt werden.
   * React kann Rendering pausieren, priorisieren oder abbrechen, wenn wichtigere Aufgaben (z. B. User-Input) eintreffen.

2. **Priorisierung von Updates**

   * Updates erhalten eine **Priorit√§t** (z. B. Animation > Datenladen).
   * Dadurch bleibt die UI reaktionsschnell.

3. **Inkremetelles Rendern**

   * Statt den ganzen Baum auf einmal zu rendern, wird er St√ºck f√ºr St√ºck (fiberweise) bearbeitet.

---

### Aufbau

* **Fiber Node**: interner Datenknoten, der eine **Einheit der Arbeit** repr√§sentiert (z. B. eine Komponente oder ein DOM-Element).
* Jeder Fiber enth√§lt Infos wie: Typ der Komponente, Props, State, Nebenwirkungen.

---

### Beispiel (vereinfacht gedacht)

```jsx
function App() {
  return (
    <>
      <Header />
      <Content />
      <Footer />
    </>
  );
}
```

* F√ºr `Header`, `Content`, `Footer` erstellt React einzelne **Fiber-Nodes**.
* React arbeitet diese nacheinander ab, kann aber z. B. `Footer` sp√§ter fertigstellen, wenn ein **User-Klick** sofort verarbeitet werden muss.

---

### Zusammenfassung

* **Fiber** = Reacts Rendering-Engine ab v16.
* Vorteile: unterbrechbare, priorisierte und inkrementelle Renderings.
* Kernziel: **bessere Performance & User Experience** bei komplexen UIs.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Render and Commit](https://react.dev/learn/render-and-commit)
* [React Blog ‚Äì Fiber Architecture](https://reactjs.org/docs/faq-internals.html#what-is-react-fiber)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

9. ### <a name="9"></a> Was bedeutet ‚ÄûBatching‚Äú in React?

### Batching in React

**Batching** bedeutet, dass React mehrere **State-Updates** zusammenfasst und in **einem einzigen Re-Render** ausf√ºhrt, anstatt nach jedem Update sofort zu rendern. Das reduziert unn√∂tige DOM-Updates und verbessert die Performance.

---

### Details

* Standardm√§√üig werden in **Event-Handlern** (z. B. `onClick`) mehrere `setState`-Aufrufe geb√ºndelt.
* Seit **React 18** gilt ‚ÄûAutomatic Batching‚Äú auch f√ºr **Promises, setTimeout, native Events** usw.
* Ohne Batching w√ºrde jede State-√Ñnderung einzeln ein Re-Render ausl√∂sen.

---

### Beispiel

```jsx
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);
  const [text, setText] = useState("");

  function handleClick() {
    setCount(c => c + 1);
    setText("Aktualisiert");
    // Beide Updates werden in EINEM Re-Render geb√ºndelt (Batching)
  }

  return (
    <>
      <p>{count} - {text}</p>
      <button onClick={handleClick}>Update</button>
    </>
  );
}

export default Counter;
```

---

### Zusammenfassung

* **Batching** = mehrere State-Updates ‚Üí ein Re-Render.
* Vorteil: weniger DOM-Updates, bessere Performance.
* Seit React 18: **automatisches Batching √ºberall**, nicht nur in Event-Handlern.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì State Updates Batching](https://react.dev/learn/queueing-a-series-of-state-updates#batching-of-state-updates)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

10. ### <a name="10"></a> Was ist die Rolle des key in React-Listen?

### Rolle des `key` in React-Listen

**`key`** ist ein spezielles Attribut in React, das jeder Listenkomponente zugewiesen wird, um sie **eindeutig zu identifizieren**. Es hilft React beim **Diffing-Prozess** (Vergleich von altem und neuem Virtual DOM), effizient zu erkennen, welche Elemente ge√§ndert, hinzugef√ºgt oder entfernt wurden.

---

### Warum wichtig?

1. **Performance**: React muss nicht die ganze Liste neu rendern, sondern nur die betroffenen Elemente.
2. **Stabilit√§t**: `key` sorgt daf√ºr, dass Komponenteninstanzen korrekt erhalten bleiben (z. B. State in Formularfeldern).
3. **Vorhersehbarkeit**: Ohne eindeutigen Key kann es zu unerwarteten UI-Effekten kommen.

---

### Beispiel

```jsx
const users = ["Anna", "Max", "Sergii"];

function UserList() {
  return (
    <ul>
      {users.map(user => (
        <li key={user}>{user}</li> // key = eindeutiger Identifier
      ))}
    </ul>
  );
}

export default UserList;
```

**Falsch (z. B. Index als Key, nur wenn Daten wirklich stabil sind):**

```jsx
<li key={index}>{user}</li>
```

‚Üí Problematisch, wenn Elemente umsortiert oder gel√∂scht werden.

---

### Zusammenfassung

* **`key`** identifiziert Listenelemente eindeutig.
* Hilft React beim effizienten Re-Rendern und verhindert UI-Fehler.
* Best Practice: stabile, eindeutige IDs nutzen, **nicht** Array-Index.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Schl√ºssel (Keys)](https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

11. ### <a name="11"></a> Wie funktioniert die Wiederverwendung von Komponenten?

### Wiederverwendung von Komponenten in React

**Wiederverwendbarkeit** bedeutet, dass eine Komponente mehrfach in unterschiedlichen Kontexten eingesetzt werden kann, ohne ihren Code zu duplizieren. React erreicht dies durch **Props, Komposition und Children**.

---

### Hauptmechanismen

1. **Props**

   * Komponenten k√∂nnen konfigurierbar gemacht werden, indem man ihnen Daten √ºbergibt.

   ```jsx
   function Button({ label, color }) {
     return <button style={{ background: color }}>{label}</button>;
   }

   export default function App() {
     return (
       <>
         <Button label="Speichern" color="green" />
         <Button label="L√∂schen" color="red" />
       </>
     );
   }
   ```

   ‚Üí Gleiche Komponente, unterschiedliche Darstellung durch Props.

2. **Komposition**

   * Komponenten k√∂nnen andere Komponenten enthalten oder kombinieren.

   ```jsx
   function Card({ children }) {
     return <div className="card">{children}</div>;
   }

   function App() {
     return (
       <Card>
         <h2>Titel</h2>
         <p>Inhalt</p>
       </Card>
     );
   }
   ```

   ‚Üí Card ist wiederverwendbar als Container f√ºr beliebigen Inhalt.

3. **Children & Higher-Order-Komponenten / Render Props**

   * Muster, um Verhalten und Layout flexibel wiederzuverwenden.

---

### Zusammenfassung

* Wiederverwendbarkeit in React basiert auf **Props, Komposition und Children**.
* Eine Komponente kann mehrfach in verschiedenen Kontexten mit unterschiedlicher Konfiguration genutzt werden.
* Ziel: **DRY-Prinzip** (Don‚Äôt Repeat Yourself) und saubere Architektur.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Komposition vs. Vererbung](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

12. ### <a name="12"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

13. ### <a name="13"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

14. ### <a name="14"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

15. ### <a name="15"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

16. ### <a name="16"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

17. ### <a name="17"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

18. ### <a name="18"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

19. ### <a name="19"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

20. ### <a name="20"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

21. ### <a name="21"></a> Was sind Props und wozu werden sie verwendet?

### Props in React

**Props (Properties)** sind **Eingabeparameter**, die von einer Elternkomponente an eine Kindkomponente √ºbergeben werden. Sie machen Komponenten **dynamisch, wiederverwendbar und konfigurierbar**.

---

### Eigenschaften von Props

1. **Read-only** ‚Äì Props k√∂nnen innerhalb der Kindkomponente **nicht ver√§ndert** werden.
2. **Datenfluss** ‚Äì Props folgen dem **Top-down Data Flow** (von Eltern zu Kindern).
3. **Flexibilit√§t** ‚Äì erlauben es, dasselbe UI-Element mit unterschiedlichen Werten zu nutzen.

---

### Beispiel

```jsx
function Greeting({ name }) {
  return <h1>Hallo, {name}!</h1>;
}

function App() {
  return (
    <>
      <Greeting name="Sergii" />
      <Greeting name="Anna" />
    </>
  );
}

export default App;
```

* `Greeting` ist wiederverwendbar.
* `name` wird als Prop √ºbergeben und individuell gerendert.

---

### Zusammenfassung

* **Props** = unver√§nderliche Eingabeparameter f√ºr Komponenten.
* Nutzen: Datenweitergabe, Wiederverwendbarkeit, dynamisches Rendering.
* Props sind **nur lesbar** und werden von Eltern an Kinder √ºbergeben.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Props](https://react.dev/learn/passing-props-to-a-component)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

22. ### <a name="22"></a> Was ist der Unterschied zwischen Props und State?

### Unterschied zwischen **Props** und **State**

1. **Props**

   * Eingabeparameter, die eine Komponente von au√üen (Elternkomponente) erh√§lt.
   * **Unver√§nderlich** innerhalb der Kindkomponente (read-only).
   * Dienen zur **Datenweitergabe** und **Konfiguration**.

2. **State**

   * Interner Zustand einer Komponente, der sich √ºber die Zeit √§ndern kann.
   * Wird mit Hooks wie `useState` verwaltet.
   * √Ñnderungen am State l√∂sen ein **Re-Render** der Komponente aus.

---

### Beispiel

```jsx
import { useState } from "react";

function Counter({ initial }) {   // Prop
  const [count, setCount] = useState(initial); // State

  return (
    <>
      <p>Z√§hler: {count}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
    </>
  );
}

export default function App() {
  return <Counter initial={5} />; // √úbergabe per Prop
}
```

* `initial` = **Prop**, von au√üen √ºbergeben, nicht ver√§nderbar.
* `count` = **State**, geh√∂rt zur Komponente selbst und wird durch User-Interaktion ver√§ndert.

---

### Zusammenfassung

* **Props**: von au√üen, unver√§nderlich, konfigurieren Komponenten.
* **State**: intern, ver√§nderlich, speichert dynamische Daten.
* Zusammenspiel: Props geben Startwerte, State steuert dynamisches Verhalten.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Props vs State](https://react.dev/learn/state-a-components-memory)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

23. ### <a name="23"></a> Warum sind Props nur lesbar?

### Warum Props nur lesbar sind

1. **Eindirektionaler Datenfluss (Top-down Data Flow)**

   * React erzwingt, dass Daten **nur von Eltern zu Kindern** flie√üen.
   * Dadurch bleibt der Datenfluss vorhersehbar und leicht nachvollziehbar.

2. **Unver√§nderlichkeit**

   * Props sind **read-only**, weil sie von au√üen (Elternkomponente) kontrolliert werden.
   * W√ºrden Kinder Props ver√§ndern, k√∂nnte es zu **Inkonsistenzen und schwer nachvollziehbaren Fehlern** kommen.

3. **Wartbarkeit & Debugging**

   * Wenn nur die Eltern Daten √§ndern d√ºrfen, ist klar definiert, **wo Daten herkommen** und **wer sie ver√§ndert**.
   * Das erh√∂ht die Stabilit√§t gro√üer Anwendungen.

---

### Beispiel

```jsx
function Greeting({ name }) {
  // name = Prop, nicht ver√§nderbar
  return <h1>Hallo, {name}</h1>;
}

function App() {
  return <Greeting name="Sergii" />;
}
```

* `Greeting` darf `name` **nicht √ºberschreiben**.
* √Ñnderungen am Wert m√ºssen in der Elternkomponente erfolgen.

---

### Zusammenfassung

* **Props sind nur lesbar**, weil React einen klaren, eindirektionalen Datenfluss erzwingt.
* Eltern kontrollieren die Daten, Kinder konsumieren sie.
* Ergebnis: **Vorhersehbarkeit, Stabilit√§t und einfacheres Debugging**.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Props](https://react.dev/learn/passing-props-to-a-component)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

24. ### <a name="24"></a> Wie funktioniert der unidirektionale Datenfluss in React?

### Unidirektionaler Datenfluss in React

React folgt strikt dem Prinzip des **Top-down Data Flow**:

* **Elternkomponenten** geben Daten √ºber **Props** an ihre **Kindkomponenten** weiter.
* Daten flie√üen **nur in eine Richtung** (von oben nach unten).
* Kindkomponenten k√∂nnen Daten nicht direkt zur√ºckgeben, sondern nur √ºber **Callbacks/Events** √Ñnderungen an die Eltern melden.

---

### Beispiel

```jsx
import { useState } from "react";

function Child({ value, onChange }) {
  return (
    <>
      <p>Aktueller Wert: {value}</p>
      <button onClick={() => onChange(value + 1)}>+1</button>
    </>
  );
}

function Parent() {
  const [count, setCount] = useState(0);

  return <Child value={count} onChange={setCount} />;
}

export default Parent;
```

* `Parent` besitzt den **State**.
* `Child` erh√§lt `value` und `onChange` als **Props**.
* √Ñnderungen flie√üen **√ºber ein Callback** zur√ºck zur Elternkomponente.

---

### Vorteile

1. **Vorhersehbarkeit**: Es ist klar, wo Daten liegen und wie sie sich √§ndern.
2. **Wartbarkeit**: Einfacher zu debuggen, da Daten nur an einer Stelle gepflegt werden.
3. **Stabilit√§t**: Keine unkontrollierten Seiteneffekte durch bidirektionalen Fluss.

---

### Zusammenfassung

* **Unidirektionaler Datenfluss** = Daten von Eltern ‚Üí Kinder (via Props).
* Kinder melden √Ñnderungen durch **Events/Callbacks** zur√ºck.
* Ergebnis: **klare Struktur, bessere Wartbarkeit, weniger Fehler**.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Datenfluss](https://react.dev/learn/passing-props-to-a-component#how-props-flow-through-components)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

25. ### <a name="25"></a> Was ist State in Klassen- und Funktionskomponenten?

### State in React

1. **State in Klassenkomponenten**

   * Wird in einer Klasse als Objekt definiert.
   * Zugriff √ºber `this.state`, √Ñnderungen mit `this.setState()`.

   ```jsx
   import React, { Component } from "react";

   class Counter extends Component {
     constructor(props) {
       super(props);
       this.state = { count: 0 }; // State-Objekt
     }

     render() {
       return (
         <>
           <p>Z√§hler: {this.state.count}</p>
           <button onClick={() => this.setState({ count: this.state.count + 1 })}>
             +1
           </button>
         </>
       );
     }
   }

   export default Counter;
   ```

   * `this.setState()` f√ºhrt **asynchrone Updates** aus und triggert ein Re-Render.

---

2. **State in Funktionskomponenten**

   * Ab React 16.8 mit **Hooks** m√∂glich (`useState`).
   * State ist kein Objekt mehr, sondern ein beliebiger Wert (Primitive oder Objekt).

   ```jsx
   import { useState } from "react";

   function Counter() {
     const [count, setCount] = useState(0); // State-Hook

     return (
       <>
         <p>Z√§hler: {count}</p>
         <button onClick={() => setCount(count + 1)}>+1</button>
       </>
     );
   }

   export default Counter;
   ```

   * `useState` gibt ein Array `[state, updater]` zur√ºck.
   * Updates sind deklarativ und l√∂sen ein Re-Render aus.

---

### Vergleich

| Klassenkomponente              | Funktionskomponente       |
| ------------------------------ | ------------------------- |
| `this.state = { ... }`         | `const [value, setValue]` |
| √Ñnderung mit `this.setState()` | √Ñnderung mit Setter       |
| OOP-Stil                       | Funktional, Hooks         |

---

### Zusammenfassung

* **State = interner Speicher** einer Komponente, der sich √ºber die Zeit √§ndern kann.
* In **Klassen**: Objekt mit `this.state` + Updates via `setState()`.
* In **Funktionen**: `useState`-Hook mit Wert + Setter.
* √Ñnderungen triggern ein **Re-Render** der Komponente.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì State und Lifecycle](https://react.dev/learn/state-a-components-memory)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

26. ### <a name="26"></a> Wie funktioniert setState?

### Funktionsweise von `setState` in React

1. **In Klassenkomponenten**

   * `setState()` ist die Methode zum Aktualisieren des internen **State-Objekts**.
   * Updates sind **asynchron** und werden oft zusammengefasst (**Batching**).
   * `setState` kann ein **Objekt** oder eine **Funktion** akzeptieren.

   ```jsx
   this.setState({ count: this.state.count + 1 }); // Objektform
   this.setState(prev => ({ count: prev.count + 1 })); // Funktionsform (empfohlen)
   ```

2. **In Funktionskomponenten** (`useState`)

   * `setState` ist der **Updater**, den React vom Hook zur√ºckgibt.
   * √úberschreibt den alten Wert durch einen neuen.
   * Akzeptiert direkt einen Wert oder eine Funktion basierend auf dem vorherigen Wert.

   ```jsx
   const [count, setCount] = useState(0);

   setCount(count + 1);          // Wert
   setCount(prev => prev + 1);   // Funktionsform (empfohlen bei Abh√§ngigkeit vom alten Wert)
   ```

---

### Wichtige Eigenschaften

* **Asynchron**: Mehrere Aufrufe von `setState` k√∂nnen gebatcht werden.
* **Re-Render**: Jede √Ñnderung l√∂st ein erneutes Rendern der Komponente aus.
* **Funktionsform** wird bevorzugt, wenn der neue Wert vom alten abh√§ngt.

---

### Zusammenfassung

* `setState` aktualisiert den State und l√∂st ein Re-Render aus.
* In **Klassenkomponenten**: Methode mit Objekt/Funktion.
* In **Funktionskomponenten**: Setter vom `useState`-Hook.
* Updates sind **asynchron** und werden **geb√ºndelt**.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì setState](https://react.dev/reference/react/useState#updating-state-based-on-the-previous-state)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

27. ### <a name="27"></a> Was ist der Unterschied zwischen kontrollierten und unkontrollierten Komponenten?

### Unterschied: Kontrollierte vs. Unkontrollierte Komponenten

1. **Kontrollierte Komponenten**

   * Der **State der Eingabeelemente** (z. B. `input`, `textarea`, `select`) wird in React verwaltet.
   * Der Wert kommt aus dem **State** der Komponente, √Ñnderungen laufen √ºber ein Event-Handler.
   * React = **Single Source of Truth**.

   ```jsx
   import { useState } from "react";

   function ControlledInput() {
     const [value, setValue] = useState("");

     return (
       <input
         value={value} // State bestimmt den Wert
         onChange={e => setValue(e.target.value)} // React kontrolliert
       />
     );
   }
   ```

---

2. **Unkontrollierte Komponenten**

   * Der Wert wird direkt vom **DOM selbst** verwaltet.
   * Zugriff √ºber **Refs** anstatt √ºber State.
   * React kontrolliert den Wert **nicht kontinuierlich**.

   ```jsx
   import { useRef } from "react";

   function UncontrolledInput() {
     const inputRef = useRef();

     const handleClick = () => {
       alert(inputRef.current.value); // Wert direkt aus DOM
     };

     return (
       <>
         <input ref={inputRef} />
         <button onClick={handleClick}>Zeig Wert</button>
       </>
     );
   }
   ```

---

### Vergleich

| Kontrolliert                         | Unkontrolliert                           |
| ------------------------------------ | ---------------------------------------- |
| React verwaltet den Wert (State)     | DOM verwaltet den Wert                   |
| `value` + `onChange`                 | Zugriff via `ref`                        |
| Besser f√ºr Validierung & komplexe UI | Einfacher f√ºr schnelle, kleine Formulare |

---

### Zusammenfassung

* **Kontrollierte Komponenten**: Wert = State in React, √Ñnderungen laufen √ºber Events ‚Üí **voller React-Kontrolle**.
* **Unkontrollierte Komponenten**: Wert = DOM, Zugriff √ºber Ref ‚Üí **schneller, aber weniger flexibel**.
* Best Practice: Kontrollierte Komponenten f√ºr gr√∂√üere UIs, unkontrollierte f√ºr einfache F√§lle.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Forms](https://react.dev/learn/sharing-state-between-components#controlled-and-uncontrolled-components)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

28. ### <a name="28"></a> Was sind Default Props und PropTypes?

### Default Props

* Mit **Default Props** kann man Standardwerte f√ºr Props definieren, falls der Elternkomponente kein Wert √ºbergeben wird.
* Praktisch, um **Fallback-Werte** sicherzustellen.

```jsx
function Button({ label }) {
  return <button>{label}</button>;
}

// Standardwert, falls `label` nicht √ºbergeben wird
Button.defaultProps = {
  label: "Klicken"
};

export default Button;
```

‚Üí In modernen React-Versionen (17+) werden Default Props f√ºr **Funktionskomponenten** weniger genutzt, stattdessen oft **Default-Parameter**:

```jsx
function Button({ label = "Klicken" }) {
  return <button>{label}</button>;
}
```

---

### PropTypes

* **PropTypes** ist ein Typpr√ºfungssystem f√ºr Props zur **Laufzeit**.
* Hilft, Fehler fr√ºh zu erkennen, indem √ºberpr√ºft wird, ob Props den erwarteten Typ haben.

```jsx
import PropTypes from "prop-types";

function User({ name, age }) {
  return <p>{name} ist {age} Jahre alt</p>;
}

User.propTypes = {
  name: PropTypes.string.isRequired,
  age: PropTypes.number
};
```

* Wird ein falscher Typ √ºbergeben, zeigt React im **Konsolen-Log eine Warnung**.

---

### Zusammenfassung

* **Default Props**: legen Standardwerte fest, wenn keine Props √ºbergeben werden.
* **PropTypes**: pr√ºfen Props-Typen **zur Laufzeit** und helfen bei der Fehlervermeidung.
* Heute oft ersetzt durch **TypeScript** f√ºr statische Typisierung.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Typpr√ºfung](https://react.dev/reference/react/Component#static-defaultprops)
* [PropTypes auf npm](https://www.npmjs.com/package/prop-types)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

29. ### <a name="29"></a> Was ist React.memo und wof√ºr wird es verwendet?

### React.memo

**`React.memo`** ist eine **Higher-Order-Komponente (HOC)**, die Funktionskomponenten **memoisiert**.
Das bedeutet: Eine Komponente wird **nur neu gerendert, wenn sich ihre Props √§ndern**.

---

### Wof√ºr wird es verwendet?

1. **Performance-Optimierung**

   * Verhindert unn√∂tige Re-Renders bei unver√§nderten Props.
   * Besonders sinnvoll bei **teuren Berechnungen** oder **gro√üen Listen**.

2. **Vergleich der Props**

   * Standardm√§√üig nutzt React einen **shallow comparison** (flacher Vergleich).
   * F√ºr komplexe Objekte kann man eine eigene Vergleichsfunktion √ºbergeben.

---

### Beispiel

```jsx
import React, { useState } from "react";

const Child = React.memo(function Child({ value }) {
  console.log("Render:", value);
  return <p>Wert: {value}</p>;
});

export default function App() {
  const [count, setCount] = useState(0);
  const [text, setText] = useState("");

  return (
    <>
      <Child value={count} />
      <button onClick={() => setCount(count + 1)}>+1</button>
      <input value={text} onChange={e => setText(e.target.value)} />
    </>
  );
}
```

* `Child` rendert nur neu, wenn sich `value` √§ndert.
* √Ñnderungen an `text` haben **keinen Einfluss** auf `Child`.

---

### Zusammenfassung

* **`React.memo`** = Memoization f√ºr Funktionskomponenten.
* Verhindert unn√∂tige Re-Renders, wenn Props unver√§ndert bleiben.
* Standard: **shallow comparison**, optional eigene Vergleichsfunktion.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì React.memo](https://react.dev/reference/react/memo)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

30. ### <a name="30"></a> Was ist PureComponent und wie unterscheidet es sich von Component?

### PureComponent vs. Component

1. **`React.Component`**

   * Basis-Klasse f√ºr Klassenkomponenten.
   * F√ºhrt bei jedem `setState` oder neuen Props ein Re-Render durch, auch wenn sich die Werte nicht tats√§chlich ge√§ndert haben.

2. **`React.PureComponent`**

   * Erweiterung von `Component`.
   * F√ºhrt **automatisch einen shallow comparison** (flachen Vergleich) von Props und State durch.
   * Rendert nur neu, wenn sich **wirklich etwas ge√§ndert hat**.

---

### Beispiel

```jsx
import React, { Component, PureComponent } from "react";

class NormalComponent extends Component {
  render() {
    console.log("NormalComponent gerendert");
    return <p>{this.props.value}</p>;
  }
}

class OptimizedComponent extends PureComponent {
  render() {
    console.log("PureComponent gerendert");
    return <p>{this.props.value}</p>;
  }
}
```

* `NormalComponent` rendert bei **jeder Aktualisierung**, auch wenn `value` gleich bleibt.
* `OptimizedComponent` rendert **nur, wenn sich `value` ge√§ndert hat**.

---

### Unterschiede im √úberblick

| **Component**                         | **PureComponent**                                 |
| ------------------------------------- | ------------------------------------------------- |
| Rendert immer bei Updates             | Rendert nur bei √Ñnderungen (shallow compare)      |
| Keine Optimierung                     | Eingebaute Performance-Optimierung                |
| Manuell `shouldComponentUpdate` n√∂tig | `shouldComponentUpdate` automatisch implementiert |

---

### Zusammenfassung

* **Component**: rendert immer neu bei Updates.
* **PureComponent**: optimiert, rendert nur bei tats√§chlichen √Ñnderungen (shallow compare).
* Ziel: **Performance-Optimierung** bei Klassenkomponenten.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì PureComponent](https://react.dev/reference/react/PureComponent)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

31. ### <a name="31"></a> Wann sollte shouldComponentUpdate verwendet werden?

### `shouldComponentUpdate` in React

**`shouldComponentUpdate(nextProps, nextState)`** ist eine Lifecycle-Methode in **Klassenkomponenten**, die bestimmt, ob ein Re-Render stattfinden soll.
Sie gibt **true** (neu rendern) oder **false** (kein Render) zur√ºck.

---

### Wann einsetzen?

1. **Performance-Optimierung**

   * Wenn eine Komponente sehr oft aktualisiert wird, aber die meisten Updates keine sichtbaren √Ñnderungen im UI verursachen.
   * Durch R√ºckgabe von `false` k√∂nnen unn√∂tige Re-Renders vermieden werden.

2. **Feinsteuerung**

   * Wenn der Standardvergleich von `PureComponent` (shallow compare) nicht ausreicht.
   * Beispiel: tiefe Objektstrukturen, die differenziert gepr√ºft werden m√ºssen.

---

### Beispiel

```jsx
import React, { Component } from "react";

class User extends Component {
  shouldComponentUpdate(nextProps) {
    // Nur neu rendern, wenn sich der Name ge√§ndert hat
    return nextProps.name !== this.props.name;
  }

  render() {
    console.log("Rendering:", this.props.name);
    return <p>{this.props.name}</p>;
  }
}

export default User;
```

---

### Zusammenfassung

* **`shouldComponentUpdate`** steuert, ob ein Re-Render notwendig ist.
* Sinnvoll bei **Performance-Optimierungen** und **kontrollierten Updates**.
* Heute oft ersetzt durch **PureComponent** oder **React.memo** in Funktionskomponenten.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì shouldComponentUpdate](https://react.dev/reference/react/Component#shouldcomponentupdate)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

32. ### <a name="32"></a> Was ist ein ref und wann wird er eingesetzt?

### Ref in React

Ein **ref (reference)** ist ein spezielles Objekt in React, mit dem man direkt auf ein **DOM-Element** oder eine **Komponenteninstanz** zugreifen kann. Refs werden mit `useRef` (Funktionskomponenten) oder `React.createRef` (Klassenkomponenten) erstellt.

---

### Wann einsetzen?

1. **Direkter Zugriff auf DOM-Elemente**

   * Fokus setzen, Text selektieren, Scrollen steuern.

2. **Speichern von ver√§nderlichen Werten**

   * Werte zwischen Renders behalten, ohne ein Re-Render auszul√∂sen.

3. **Integration mit Drittbibliotheken**

   * z. B. Zugriff auf Canvas, Charts, Animationen.

---

### Beispiele

**Funktionskomponente mit `useRef`:**

```jsx
import { useRef } from "react";

function InputFocus() {
  const inputRef = useRef();

  const handleClick = () => {
    inputRef.current.focus(); // direkter DOM-Zugriff
  };

  return (
    <>
      <input ref={inputRef} type="text" />
      <button onClick={handleClick}>Fokus setzen</button>
    </>
  );
}

export default InputFocus;
```

**Persistente Werte ohne Re-Render:**

```jsx
import { useRef, useState } from "react";

function Timer() {
  const countRef = useRef(0);
  const [stateCount, setStateCount] = useState(0);

  const increment = () => {
    countRef.current += 1;      // kein Re-Render
    setStateCount(stateCount+1); // triggert Re-Render
  };

  return (
    <p>Ref: {countRef.current}, State: {stateCount}</p>
  );
}
```

---

### Zusammenfassung

* **Refs** = direkte Referenzen auf DOM-Elemente oder persistente Werte.
* Einsatz: Fokus, Scroll, Animationssteuerung, Integration mit Drittlibs, Werte speichern ohne Re-Render.
* Erstellung: `useRef` (Hooks), `createRef` (Klassen).

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Refs](https://react.dev/learn/referencing-values-with-refs)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

33. ### <a name="33"></a> Was bedeutet ‚ÄûLifting State Up‚Äú?

### Lifting State Up in React

**Lifting State Up** bedeutet, dass man den **State aus einer Kindkomponente in die gemeinsame Elternkomponente verlagert**, wenn mehrere Komponenten denselben Zustand ben√∂tigen.
So entsteht **eine gemeinsame Quelle der Wahrheit** (Single Source of Truth), und der Datenfluss bleibt **eindirektional**.

---

### Beispiel

```jsx
import { useState } from "react";

function TemperatureInput({ label, value, onChange }) {
  return (
    <>
      <label>{label}: </label>
      <input
        type="number"
        value={value}
        onChange={e => onChange(e.target.value)}
      />
    </>
  );
}

function Calculator() {
  const [temperature, setTemperature] = useState("");

  return (
    <>
      <TemperatureInput
        label="Celsius"
        value={temperature}
        onChange={setTemperature}
      />
      <TemperatureInput
        label="Fahrenheit"
        value={(temperature * 9) / 5 + 32}
        onChange={val => setTemperature(((val - 32) * 5) / 9)}
      />
    </>
  );
}

export default Calculator;
```

* Beide Inputs teilen sich denselben **State in der Elternkomponente**.
* √Ñnderungen an einem Feld werden sofort im anderen reflektiert.

---

### Zusammenfassung

* **Lifting State Up** = Verschieben von State in die **Elternkomponente**, um Daten zwischen Kindern zu synchronisieren.
* Vorteile: eine gemeinsame Wahrheit, konsistenter Datenfluss, bessere Wartbarkeit.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Lifting State Up](https://react.dev/learn/sharing-state-between-components#lifting-state-up)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

34. ### <a name="34"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

35. ### <a name="35"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

36. ### <a name="36"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

37. ### <a name="37"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

38. ### <a name="38"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

39. ### <a name="39"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

40. ### <a name="40"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

41. ### <a name="41"></a> Was sind die Phasen des Komponentenlebenszyklus?

### Phasen des Komponentenlebenszyklus (Class Components)

In React (bei **Klassenkomponenten**) besteht der **Lebenszyklus** einer Komponente aus drei Hauptphasen:

1. **Mounting (Einf√ºgen ins DOM)**

   * Methoden:

     * `constructor()`
     * `static getDerivedStateFromProps()`
     * `render()`
     * `componentDidMount()`

2. **Updating (Aktualisierung bei Props/State-√Ñnderungen)**

   * Methoden:

     * `static getDerivedStateFromProps()`
     * `shouldComponentUpdate()`
     * `render()`
     * `getSnapshotBeforeUpdate()`
     * `componentDidUpdate()`

3. **Unmounting (Entfernen aus dem DOM)**

   * Methode:

     * `componentWillUnmount()`

---

### Beispiel

```jsx
import React, { Component } from "react";

class Demo extends Component {
  constructor(props) {
    super(props);
    console.log("1. constructor");
    this.state = { count: 0 };
  }

  componentDidMount() {
    console.log("4. componentDidMount");
  }

  shouldComponentUpdate() {
    console.log("Update? -> true");
    return true;
  }

  componentDidUpdate() {
    console.log("componentDidUpdate");
  }

  componentWillUnmount() {
    console.log("componentWillUnmount");
  }

  render() {
    console.log("render()");
    return (
      <button onClick={() => this.setState({ count: this.state.count + 1 })}>
        {this.state.count}
      </button>
    );
  }
}

export default Demo;
```

---

### Vergleich zu Hooks

* **Mounting/Updating/Unmounting** wird heute meist mit **`useEffect`** in Funktionskomponenten abgebildet.

```jsx
import { useState, useEffect } from "react";

function Demo() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log("Mounting & Updating");
    return () => console.log("Unmounting");
  }, [count]);

  return <button onClick={() => setCount(count + 1)}>{count}</button>;
}
```

---

### Zusammenfassung

* Lebenszyklus hat drei Phasen: **Mounting, Updating, Unmounting**.
* Klassenkomponenten nutzen Methoden (`componentDidMount`, `componentDidUpdate`, `componentWillUnmount`).
* Funktionskomponenten verwenden stattdessen **Hooks (useEffect)**.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Lifecycle](https://react.dev/reference/react/Component)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

42. ### <a name="42"></a> Welche Lifecycle-Methoden gibt es in Klassenkomponenten?

### Lifecycle-Methoden in Klassenkomponenten

React-Klassenkomponenten haben verschiedene Lifecycle-Methoden, die in drei Phasen eingeteilt werden:

---

#### 1. **Mounting (Einf√ºgen ins DOM)**

* `constructor()` ‚Üí Initialisierung von State und Binding.
* `static getDerivedStateFromProps(props, state)` ‚Üí selten genutzt, synchronisiert State mit Props.
* `render()` ‚Üí gibt das JSX zur√ºck.
* `componentDidMount()` ‚Üí ausgef√ºhrt **nach dem ersten Render**, ideal f√ºr API-Calls oder DOM-Manipulation.

---

#### 2. **Updating (bei Props/State-√Ñnderungen)**

* `static getDerivedStateFromProps(props, state)` ‚Üí wird auch hier aufgerufen.
* `shouldComponentUpdate(nextProps, nextState)` ‚Üí entscheidet, ob Re-Render n√∂tig ist (Performance-Optimierung).
* `render()` ‚Üí erneutes Rendern der Komponente.
* `getSnapshotBeforeUpdate(prevProps, prevState)` ‚Üí Zugriff auf DOM vor dem Update.
* `componentDidUpdate(prevProps, prevState, snapshot)` ‚Üí nach dem Rendern, gut f√ºr Netzwerkaufrufe oder DOM-Updates.

---

#### 3. **Unmounting (Entfernen aus DOM)**

* `componentWillUnmount()` ‚Üí Aufr√§umarbeiten (Timer clearen, Event Listener entfernen).

---

#### 4. **Error Handling (seit React 16)**

* `static getDerivedStateFromError(error)` ‚Üí f√§ngt Fehler ab, bevor UI zusammenbricht.
* `componentDidCatch(error, info)` ‚Üí Logging von Fehlern.

---

### Zusammenfassung

* **Mounting**: `constructor`, `getDerivedStateFromProps`, `render`, `componentDidMount`.
* **Updating**: `getDerivedStateFromProps`, `shouldComponentUpdate`, `render`, `getSnapshotBeforeUpdate`, `componentDidUpdate`.
* **Unmounting**: `componentWillUnmount`.
* **Error Handling**: `getDerivedStateFromError`, `componentDidCatch`.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Component API](https://react.dev/reference/react/Component)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

43. ### <a name="43"></a> Welche Lifecycle-Methoden sind veraltet?

### Veraltete Lifecycle-Methoden in React

Einige Lifecycle-Methoden von **Klassenkomponenten** gelten seit **React 16.3** als **deprecated** (veraltet), weil sie oft zu **Fehlern und unerwartetem Verhalten** f√ºhrten.

---

### Veraltete Methoden

1. **`componentWillMount()`**

   * Wurde vor dem ersten Render ausgef√ºhrt.
   * Ersetzt durch: **`constructor`** oder **`componentDidMount`**.

2. **`componentWillReceiveProps(nextProps)`**

   * Wurde bei neuen Props aufgerufen.
   * Ersetzt durch: **`static getDerivedStateFromProps`** oder **`componentDidUpdate`**.

3. **`componentWillUpdate(nextProps, nextState)`**

   * Wurde vor einem Update aufgerufen.
   * Ersetzt durch: **`getSnapshotBeforeUpdate`** oder **`componentDidUpdate`**.

---

### UNSAFE_-Pr√§fix

Seit React 16.3 existieren diese Methoden noch, aber mit **`UNSAFE_`-Pr√§fix**, z. B.:

* `UNSAFE_componentWillMount`
* `UNSAFE_componentWillReceiveProps`
* `UNSAFE_componentWillUpdate`

---

### Zusammenfassung

* Veraltet: `componentWillMount`, `componentWillReceiveProps`, `componentWillUpdate`.
* Grund: sie verursachen **Side-Effects** im falschen Zeitpunkt.
* Alternative: **`getDerivedStateFromProps`, `componentDidMount`, `componentDidUpdate`, `getSnapshotBeforeUpdate`**.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì UNSAFE Lifecycle Methods](https://react.dev/reference/react/Component#unsafe_componentwillmount)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

44. ### <a name="44"></a> Wie kann man Lifecycle-Methoden mit Hooks ersetzen?

### Lifecycle-Methoden ‚Üí Hooks: 1:1-Ersatz und Patterns

| Klassen-Lifecycle                                             | Entsprechung mit Hooks (Funktionskomponenten)                                                                                | Hinweis                                                              |
| ------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------- |
| `constructor`                                                 | Initial-State via `useState(initial)`                                                                                        | Auch f√ºr Event-Handler-Binding nicht n√∂tig.                          |
| `componentDidMount`                                           | `useEffect(() => { /* init */ }, [])`                                                                                        | L√§uft nach dem ersten Render (commit).                               |
| `componentDidUpdate`                                          | `useEffect(() => { /* reagiert auf deps */ }, [deps])`                                                                       | L√§uft nach jedem Render, wenn `deps` sich √§ndern.                    |
| `componentWillUnmount`                                        | Cleanup-Funktion in `useEffect`: `return () => {/* cleanup */}`                                                              | Abmelden von Listenern, Timer clearen etc.                           |
| `shouldComponentUpdate`                                       | Strukturell: `React.memo(Component)`; feingranular: `useMemo`, `useCallback`                                                 | Verhindert unn√∂tige Re-Renders.                                      |
| `getDerivedStateFromProps`                                    | Meist **vermeiden**. Alternativen: ableiten im Render, `useMemo` f√ºr teure Ableitungen, oder `useEffect` zum Synchronisieren | Props nicht in State duplizieren, wenn m√∂glich.                      |
| `getSnapshotBeforeUpdate` ‚Üí `componentDidUpdate`              | `useLayoutEffect` + `useRef` f√ºr **Layout-Messungen** vor dem Paint; Vor-/Nachwerte per Ref speichern                        | `useLayoutEffect` l√§uft synchron nach DOM-Mutationen, vor dem Paint. |
| Fehlergrenzen: `getDerivedStateFromError`/`componentDidCatch` | **Kein Hook-√Ñquivalent**. Error Boundaries weiterhin als **Klassenkomponenten** implementieren                               | Alternativ: vorhandene Boundary-Komponenten wiederverwenden.         |

---

### Minimalbeispiele

**Mount/Update/Unmount (Effect + Cleanup)**

```jsx
import { useEffect, useState } from "react";

export default function Chat() {
  const [connected, setConnected] = useState(false);

  useEffect(() => {
    const conn = connect();       // componentDidMount / DidUpdate (deps s.u.)
    setConnected(true);
    return () => conn.disconnect(); // componentWillUnmount
  }, []); // leeres Array: nur einmal nach Mount

  return <p>{connected ? "Online" : "Offline"}</p>;
}
```

**shouldComponentUpdate ‚Üí React.memo**

```jsx
import React, { useMemo } from "react";

const List = React.memo(function List({ items }) {
  const total = useMemo(() => items.reduce((s, x) => s + x.value, 0), [items]);
  return <p>Total: {total}</p>;
});

export default List;
```

**getDerivedStateFromProps vermeiden (Ableitung statt Spiegeln)**

```jsx
import { useMemo } from "react";

// Statt Prop -> State-Spiegelung:
export default function Price({ net, vatPercent }) {
  const gross = useMemo(() => net * (1 + vatPercent / 100), [net, vatPercent]);
  return <span>{gross.toFixed(2)} ‚Ç¨</span>;
}
```

**getSnapshotBeforeUpdate ‚Üí useLayoutEffect f√ºr Layout/Scroll**

```jsx
import { useLayoutEffect, useRef } from "react";

export default function AutoScroll({ messages }) {
  const listRef = useRef(null);
  const prevLen = useRef(0);

  useLayoutEffect(() => {
    const list = listRef.current;
    const nearBottom =
      list.scrollHeight - list.scrollTop - list.clientHeight < 20;

    // l√§uft nach DOM-Mutationen, vor dem Paint
    if (nearBottom || messages.length < prevLen.current) {
      list.scrollTop = list.scrollHeight; // ‚ÄûSnapshot‚Äú-artiges Verhalten
    }
    prevLen.current = messages.length;
  }, [messages]);

  return (
    <ul ref={listRef} style={{ maxHeight: 200, overflow: "auto" }}>
      {messages.map(m => <li key={m.id}>{m.text}</li>)}
    </ul>
  );
}
```

**Fehlergrenze (weiterhin Klasse)**

```jsx
import React from "react";

export class ErrorBoundary extends React.Component {
  state = { hasError: false };

  static getDerivedStateFromError() {
    return { hasError: true };
  }
  componentDidCatch(error, info) {
    console.error(error, info);
  }
  render() {
    return this.state.hasError ? <h1>Etwas ging schief.</h1> : this.props.children;
  }
}
```

---

### Zusammenfassung

* Mount/Update/Unmount: `useEffect` (mit/ohne deps) + **Cleanup**.
* Rendersteuerung: `React.memo`, `useMemo`, `useCallback`.
* Layout-kritisch: `useLayoutEffect` + `useRef`.
* `getDerivedStateFromProps` meist vermeiden (Props nicht spiegeln).
* Error Boundaries: weiterhin **Klassenkomponenten**.

üìñ Weiterf√ºhrend:

* React Docs: [Effects](https://react.dev/learn/synchronizing-with-effects), [useEffect](https://react.dev/reference/react/useEffect), [useLayoutEffect](https://react.dev/reference/react/useLayoutEffect), [Memoisierung](https://react.dev/learn/escape-hatches#memoizing-calculations), [React.memo](https://react.dev/reference/react/memo), [Error Boundaries](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary)
* MDN (RU): [–°–æ–±—ã—Ç–∏—è](https://developer.mozilla.org/ru/docs/Learn/JavaScript/Building_blocks/Events), [requestAnimationFrame](https://developer.mozilla.org/ru/docs/Web/API/window/requestAnimationFrame) (Kontext f√ºr Layout/Rendering-Zeitpunkte)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

45. ### <a name="45"></a> Was ist componentDidMount und was ist das √Ñquivalent mit Hooks?

### `componentDidMount` in Klassenkomponenten

* Wird **einmal nach dem ersten Render** ausgef√ºhrt, sobald die Komponente ins DOM eingef√ºgt wurde.
* Typische Eins√§tze:

  * **API-Requests starten**
  * **Event-Listener registrieren**
  * **DOM-Manipulationen** (Fokus setzen etc.)

```jsx
import React, { Component } from "react";

class Demo extends Component {
  componentDidMount() {
    console.log("Komponente wurde gemountet");
    document.title = "Hallo Sergii";
  }

  render() {
    return <h1>Hallo</h1>;
  }
}
```

---

### √Ñquivalent mit Hooks ‚Üí `useEffect`

In Funktionskomponenten √ºbernimmt `useEffect` die Rolle von Lifecycle-Methoden.

* **√Ñquivalent zu `componentDidMount`:** `useEffect` mit leerem Abh√§ngigkeitsarray `[]`.

```jsx
import { useEffect } from "react";

function Demo() {
  useEffect(() => {
    console.log("Komponente wurde gemountet");
    document.title = "Hallo Sergii";
  }, []); // leeres Array -> nur beim ersten Mount

  return <h1>Hallo</h1>;
}

export default Demo;
```

---

### Zusammenfassung

* **`componentDidMount`**: l√§uft einmal nach dem Einf√ºgen ins DOM (Klassenkomponenten).
* **Hook-√Ñquivalent**: `useEffect(() => { ... }, [])` in Funktionskomponenten.
* Typische Nutzung: API-Calls, Event-Registrierung, DOM-Manipulation.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì useEffect](https://react.dev/reference/react/useEffect)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

46. ### <a name="46"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

47. ### <a name="47"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

48. ### <a name="48"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

49. ### <a name="49"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

50. ### <a name="50"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

51. ### <a name="51"></a> Was sind Hooks in React?

### Hooks in React

**Hooks** sind spezielle **Funktionen**, die es erm√∂glichen, in **Funktionskomponenten** React-Features wie **State, Lifecycle-Methoden und Context** zu nutzen ‚Äì ohne Klassenkomponenten zu schreiben. Sie wurden mit **React 16.8** eingef√ºhrt.

---

### Warum Hooks?

1. Ersetzen viele Anwendungsf√§lle von **Klassenkomponenten**.
2. Erlauben **Wiederverwendung von Logik** (Custom Hooks).
3. Machen Code **k√ºrzer, klarer und besser testbar**.

---

### Wichtige eingebaute Hooks

* **State**: `useState` ‚Üí lokaler Zustand.
* **Lifecycle/Side Effects**: `useEffect`, `useLayoutEffect`.
* **Referenzen**: `useRef`.
* **Performance**: `useMemo`, `useCallback`.
* **Context**: `useContext`.
* **Reducer**: `useReducer` f√ºr komplexere State-Logik.

---

### Beispiel

```jsx
import { useState, useEffect } from "react";

function Counter() {
  const [count, setCount] = useState(0); // State-Hook

  useEffect(() => {
    document.title = `Z√§hler: ${count}`; // Effect-Hook (componentDidMount/DidUpdate)
  }, [count]);

  return (
    <>
      <p>Z√§hler: {count}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
    </>
  );
}

export default Counter;
```

---

### Zusammenfassung

* **Hooks = Funktionen**, die React-Features (State, Lifecycle, Context) in **Funktionskomponenten** bringen.
* Vorteil: keine Klassen mehr n√∂tig, bessere Wiederverwendung von Logik.
* Kernhooks: `useState`, `useEffect`, `useContext`, `useRef`, `useMemo`, `useCallback`.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Einf√ºhrung in Hooks](https://react.dev/learn/state-a-components-memory#using-hooks)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

52. ### <a name="52"></a> Wie funktionieren useState und useEffect?

### `useState`

* `useState` ist ein Hook, der in einer **Funktionskomponente** lokalen State speichert.
* Er liefert ein **Array mit zwei Werten**: `[aktuellerState, SetterFunktion]`.
* √Ñnderungen √ºber den Setter triggern ein **Re-Render** der Komponente.

```jsx
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0); // Initialwert = 0

  return (
    <>
      <p>Z√§hler: {count}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
    </>
  );
}
```

---

### `useEffect`

* `useEffect` erm√∂glicht **Side Effects** in Funktionskomponenten (z. B. API-Calls, Event-Listener, DOM-Manipulation).
* Standardm√§√üig l√§uft er **nach jedem Render**.
* Mit **Abh√§ngigkeitsarray** kann man steuern:

  * `[]` ‚Üí nur beim ersten Mount (`componentDidMount`).
  * `[deps]` ‚Üí bei √Ñnderungen der Abh√§ngigkeiten (`componentDidUpdate`).
  * Cleanup-Funktion ‚Üí beim Unmount (`componentWillUnmount`).

```jsx
import { useEffect, useState } from "react";

function Timer() {
  const [seconds, setSeconds] = useState(0);

  useEffect(() => {
    const id = setInterval(() => setSeconds(s => s + 1), 1000);

    return () => clearInterval(id); // Cleanup beim Unmount
  }, []);

  return <p>Timer: {seconds}s</p>;
}
```

---

### Zusammenfassung

* **`useState`**: lokaler State in Funktionskomponenten (`[state, setState]`).
* **`useEffect`**: verwaltet Side Effects (API, Timer, DOM), inkl. Cleanup.
* Zusammen bilden sie das Grundger√ºst f√ºr State-Management und Lifecycle-Handling in React.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì useState](https://react.dev/reference/react/useState)
* [React Offizielle Dokumentation ‚Äì useEffect](https://react.dev/reference/react/useEffect)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

53. ### <a name="53"></a> Was macht useContext?

### `useContext` in React

* **`useContext`** ist ein Hook, der Zugriff auf den Wert eines **React Contexts** erm√∂glicht.
* Er ersetzt die Notwendigkeit, Props durch viele Komponenten weiterzureichen (**Prop Drilling**).
* Jede Komponente, die `useContext` nutzt, wird neu gerendert, sobald sich der Context-Wert √§ndert.

---

### Beispiel

```jsx
import { createContext, useContext } from "react";

// 1. Context erstellen
const ThemeContext = createContext("light");

function ThemedButton() {
  // 2. Zugriff auf den aktuellen Wert
  const theme = useContext(ThemeContext);
  return <button className={theme}>Klick mich</button>;
}

export default function App() {
  return (
    // 3. Provider legt den Wert fest
    <ThemeContext.Provider value="dark">
      <ThemedButton />
    </ThemeContext.Provider>
  );
}
```

* `ThemeContext.Provider` ‚Üí stellt den Wert (`"dark"`) bereit.
* `useContext(ThemeContext)` ‚Üí liest den Wert aus, ohne Props weiterzureichen.

---

### Zusammenfassung

* **`useContext`**: Hook zum direkten Zugriff auf einen Context-Wert.
* Nutzen: Vermeidet **Prop Drilling**, ideal f√ºr globale Daten (Theme, Auth, Sprache).
* √Ñnderung des Contexts ‚Üí Re-Render aller abh√§ngigen Komponenten.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì useContext](https://react.dev/reference/react/useContext)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

54. ### <a name="54"></a> Was ist useRef und wann wird es verwendet?

### `useRef` in React

* **`useRef`** ist ein Hook, der ein **ver√§nderbares Objekt mit der Eigenschaft `.current`** zur√ºckgibt.
* Dieses Objekt bleibt **√ºber die gesamte Lebensdauer** der Komponente gleich.
* √Ñnderungen an `.current` l√∂sen **kein Re-Render** aus.

---

### Wann wird `useRef` verwendet?

1. **Direkter Zugriff auf DOM-Elemente**

   * Fokus setzen, Scroll-Position manipulieren, Integration mit Drittbibliotheken.

2. **Speichern von Werten zwischen Renders**

   * Persistente Werte behalten (z. B. Timer-ID, vorheriger Wert).

3. **Performance-Optimierung**

   * Verhindern, dass ein Wert bei jedem Render neu erzeugt wird.

---

### Beispiele

**DOM-Zugriff:**

```jsx
import { useRef } from "react";

function InputFocus() {
  const inputRef = useRef();

  const handleClick = () => {
    inputRef.current.focus(); // Zugriff auf das DOM-Element
  };

  return (
    <>
      <input ref={inputRef} type="text" />
      <button onClick={handleClick}>Fokus setzen</button>
    </>
  );
}
```

**Persistenter Wert (kein Re-Render):**

```jsx
import { useRef, useEffect } from "react";

function Timer() {
  const count = useRef(0);

  useEffect(() => {
    const id = setInterval(() => {
      count.current += 1; // Wert √§ndern ohne Re-Render
      console.log("Sekunden:", count.current);
    }, 1000);
    return () => clearInterval(id);
  }, []);

  return <p>Siehe Konsole</p>;
}
```

---

### Zusammenfassung

* **`useRef`** speichert eine ver√§nderbare Referenz (`.current`) √ºber Renders hinweg.
* Einsatz: DOM-Zugriffe, persistente Werte, Performance-Optimierung.
* Unterschied zu State: **√Ñnderungen an `useRef` triggern kein Re-Render**.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì useRef](https://react.dev/reference/react/useRef)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

55. ### <a name="55"></a> Was ist useCallback, useMemo, useReducer?

### 1. `useCallback`

* Gibt eine **memoisierte Callback-Funktion** zur√ºck.
* N√ºtzlich, um **unn√∂tige Re-Renders** von Kindkomponenten zu vermeiden, die eine Callback-Prop erhalten.
* Nur neu erstellt, wenn sich die Abh√§ngigkeiten √§ndern.

```jsx
import { useState, useCallback } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  const increment = useCallback(() => setCount(c => c + 1), []);
  // gleiche Funktion bleibt √ºber Renders hinweg erhalten

  return <button onClick={increment}>{count}</button>;
}
```

---

### 2. `useMemo`

* Gibt einen **memoisierten Wert** zur√ºck.
* Verhindert, dass **teure Berechnungen** bei jedem Render erneut ausgef√ºhrt werden.
* Nur neu berechnet, wenn sich die Abh√§ngigkeiten √§ndern.

```jsx
import { useState, useMemo } from "react";

function ExpensiveCalc({ num }) {
  const result = useMemo(() => {
    console.log("Teure Berechnung...");
    return num * 2;
  }, [num]);

  return <p>Ergebnis: {result}</p>;
}
```

---

### 3. `useReducer`

* Alternative zu `useState`, besonders f√ºr **komplexe State-Logik** oder **mehrere verbundene Zust√§nde**.
* Funktioniert √§hnlich wie ein **Redux-Reducer**: `state` + `action` ‚Üí neuer `state`.

```jsx
import { useReducer } from "react";

function reducer(state, action) {
  switch (action.type) {
    case "increment":
      return { count: state.count + 1 };
    case "decrement":
      return { count: state.count - 1 };
    default:
      return state;
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, { count: 0 });

  return (
    <>
      <p>Z√§hler: {state.count}</p>
      <button onClick={() => dispatch({ type: "increment" })}>+1</button>
      <button onClick={() => dispatch({ type: "decrement" })}>-1</button>
    </>
  );
}
```

---

### Zusammenfassung

* **`useCallback`**: memoisiert Funktionen ‚Üí vermeidet unn√∂tige Neu-Erstellungen.
* **`useMemo`**: memoisiert Werte ‚Üí verhindert teure Neuberechnungen.
* **`useReducer`**: State-Management f√ºr komplexe Logik, basierend auf Reducer-Pattern.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì useCallback](https://react.dev/reference/react/useCallback)
* [React Offizielle Dokumentation ‚Äì useMemo](https://react.dev/reference/react/useMemo)
* [React Offizielle Dokumentation ‚Äì useReducer](https://react.dev/reference/react/useReducer)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

56. ### <a name="56"></a> Wie schreibt man einen benutzerdefinierten Hook?

### Benutzerdefinierte Hooks (Custom Hooks)

Ein **Custom Hook** ist eine normale **JavaScript-Funktion**, deren Name mit **`use`** beginnt und die **React Hooks** (z. B. `useState`, `useEffect`) verwendet.
Zweck: **Wiederverwendung von Logik** in verschiedenen Komponenten.

---

### Regeln

1. Name muss mit `use...` beginnen.
2. Darf nur innerhalb von React-Komponenten oder anderen Hooks verwendet werden.
3. Muss die [Regeln der Hooks](https://react.dev/warnings/rules-of-hooks) einhalten: nur **Top-Level**, niemals in Schleifen oder Bedingungen.

---

### Beispiel ‚Äì Fensterbreite beobachten

```jsx
import { useState, useEffect } from "react";

// Custom Hook
function useWindowWidth() {
  const [width, setWidth] = useState(window.innerWidth);

  useEffect(() => {
    const handleResize = () => setWidth(window.innerWidth);
    window.addEventListener("resize", handleResize);

    return () => window.removeEventListener("resize", handleResize);
  }, []);

  return width; // gibt Wert zur√ºck
}

// Nutzung in einer Komponente
export default function App() {
  const width = useWindowWidth();

  return <p>Aktuelle Fensterbreite: {width}px</p>;
}
```

---

### Zusammenfassung

* **Custom Hook** = Funktion mit `use...`, die Hooks nutzt, um Logik wiederverwendbar zu machen.
* Vorteile: **Code-Wiederverwendung, bessere Lesbarkeit, klarere Trennung von Logik und UI**.
* Beispiel: `useWindowWidth`, `useFetch`, `useForm`.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Eigene Hooks](https://react.dev/learn/reusing-logic-with-custom-hooks)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

57. ### <a name="57"></a> Wie verhindert man eine Endlosschleife in useEffect?

### Endlosschleifen in `useEffect`

Eine Endlosschleife entsteht, wenn **State im Effect ge√§ndert** wird, ohne die Abh√§ngigkeiten korrekt zu steuern ‚Üí jeder State-Update l√∂st erneut den Effect aus.

---

### Ursachen

1. **Fehlendes oder falsches Abh√§ngigkeitsarray**

   ```jsx
   useEffect(() => {
     setCount(count + 1); // triggert bei jedem Render -> Endlosschleife
   }); // kein []
   ```

2. **Unn√∂tige Abh√§ngigkeiten**

   * Wenn Werte ins Array aufgenommen werden, die sich bei jedem Render √§ndern (z. B. Objekte/Funktionen).

---

### L√∂sungen

1. **Korrektes Abh√§ngigkeitsarray nutzen**

   ```jsx
   useEffect(() => {
     fetchData();
   }, []); // nur beim ersten Mount
   ```

2. **Funktionsupdates f√ºr State nutzen**

   ```jsx
   useEffect(() => {
     const id = setInterval(() => {
       setCount(prev => prev + 1); // nutzt vorherigen Wert, vermeidet Endlosschleife
     }, 1000);

     return () => clearInterval(id);
   }, []);
   ```

3. **Memoization f√ºr Objekte/Funktionen**

   * `useMemo` oder `useCallback` nutzen, damit sich die Abh√§ngigkeiten nicht bei jedem Render √§ndern.

   ```jsx
   const memoizedFn = useCallback(() => {
     console.log("Nur bei Bedarf neu erzeugt");
   }, []);

   useEffect(() => {
     memoizedFn();
   }, [memoizedFn]);
   ```

---

### Zusammenfassung

* Endlosschleifen entstehen durch **falsche oder fehlende Dependency Arrays** in `useEffect`.
* L√∂sung: korrektes Abh√§ngigkeitsarray, funktionale Updates, Memoization (`useCallback`, `useMemo`).
* Grundregel: **nur echte Abh√§ngigkeiten angeben** und Werte stabil halten.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì useEffect](https://react.dev/reference/react/useEffect)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

58. ### <a name="58"></a> Wie implementiert man Timeout oder Interval mit Hooks?

### Timeout & Interval mit Hooks

In Funktionskomponenten werden **`setTimeout`** und **`setInterval`** zusammen mit `useEffect` und `useRef` genutzt. Wichtig: **Cleanup** im `useEffect` verhindert Speicherlecks.

---

### Timeout (`setTimeout`)

```jsx
import { useEffect, useState } from "react";

function TimeoutDemo() {
  const [message, setMessage] = useState("Warte...");

  useEffect(() => {
    const id = setTimeout(() => {
      setMessage("Fertig nach 3 Sekunden!");
    }, 3000);

    return () => clearTimeout(id); // Cleanup beim Unmount
  }, []);

  return <p>{message}</p>;
}

export default TimeoutDemo;
```

---

### Interval (`setInterval`)

```jsx
import { useEffect, useState } from "react";

function IntervalDemo() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const id = setInterval(() => {
      setCount(prev => prev + 1); // funktionales Update vermeidet Endlosschleife
    }, 1000);

    return () => clearInterval(id); // Cleanup beim Unmount
  }, []);

  return <p>Z√§hler: {count}</p>;
}

export default IntervalDemo;
```

---

### Zusammenfassung

* **Timeout**: `setTimeout` + `clearTimeout` in `useEffect`.
* **Interval**: `setInterval` + `clearInterval` in `useEffect`.
* Cleanup-Funktion verhindert Leaks und unerw√ºnschte Effekte.
* Funktionale Updates (`prev => prev + 1`) sind wichtig, um Endlosschleifen zu vermeiden.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì useEffect](https://react.dev/reference/react/useEffect)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

59. ### <a name="59"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

60. ### <a name="60"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

61. ### <a name="61"></a> Was ist ein Higher-Order Component (HOC)?

### Higher-Order Component (HOC)

Ein **Higher-Order Component (HOC)** ist eine **Funktion**, die eine Komponente entgegennimmt und eine **neue erweiterte Komponente** zur√ºckgibt.
HOCs sind ein **Pattern zur Wiederverwendung von Logik** zwischen Komponenten.

---

### Merkmale

* HOC = **`Component => NewComponent`**.
* Trennung von **Logik** und **Darstellung**.
* Typisch f√ºr: Code-Wiederverwendung, Cross-Cutting Concerns (z. B. Auth, Logging).

---

### Beispiel

```jsx
import React from "react";

// HOC: nimmt Komponente, liefert neue zur√ºck
function withLogger(WrappedComponent) {
  return function Enhanced(props) {
    console.log("Props:", props);
    return <WrappedComponent {...props} />;
  };
}

// Nutzung
function Button({ label }) {
  return <button>{label}</button>;
}

const LoggedButton = withLogger(Button);

export default function App() {
  return <LoggedButton label="Klick mich" />;
}
```

* `withLogger` erweitert `Button` um Logging.
* `Button` selbst bleibt unver√§ndert, Wiederverwendung bleibt m√∂glich.

---

### Zusammenfassung

* **HOC** = Funktion, die eine Komponente um zus√§tzliche Logik erweitert.
* Typische Verwendung: **Code-Sharing, Auth, Logging, Daten-Handling**.
* Heute oft ersetzt durch **Hooks** oder **Render Props**.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì HOCs](https://react.dev/learn/reusing-logic-with-higher-order-components)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

62. ### <a name="62"></a> Was ist das Render-Prop-Pattern?

### Render-Prop-Pattern

Ein **Render-Prop** ist ein **Pattern in React**, bei dem eine Komponente eine **Funktion als Prop** erh√§lt, die bestimmt, **was gerendert wird**.
Damit k√∂nnen Komponenten **Logik wiederverwenden**, ohne UI starr vorzugeben.

---

### Merkmale

* ‚ÄûProp‚Äú = eine **Funktion**, die React-Elemente zur√ºckgibt.
* Trennung von **Logik** (in der Container-Komponente) und **Darstellung** (durch die Render-Prop-Funktion).
* Alternative zu HOCs f√ºr **Code-Wiederverwendung**.

---

### Beispiel

```jsx
import { useState } from "react";

// Container-Komponente mit Render-Prop
function MouseTracker({ render }) {
  const [pos, setPos] = useState({ x: 0, y: 0 });

  return (
    <div
      style={{ height: "200px", border: "1px solid black" }}
      onMouseMove={e => setPos({ x: e.clientX, y: e.clientY })}
    >
      {render(pos)} {/* Render-Prop entscheidet, was angezeigt wird */}
    </div>
  );
}

// Nutzung
export default function App() {
  return (
    <MouseTracker
      render={({ x, y }) => (
        <p>Cursor bei ({x}, {y})</p>
      )}
    />
  );
}
```

* `MouseTracker` enth√§lt die **Logik (onMouseMove)**.
* Das UI wird flexibel durch `render` definiert.

---

### Zusammenfassung

* **Render-Prop-Pattern**: Komponente erh√§lt eine **Funktion als Prop**, die JSX zur√ºckgibt.
* Vorteil: **Wiederverwendbare Logik** + flexible Darstellung.
* Wird heute oft durch **Custom Hooks** ersetzt.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Render Props](https://react.dev/learn/passing-props-to-a-component#passing-render-props)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

63. ### <a name="63"></a> Was ist die Context-API und wie funktioniert useContext?

### Context-API in React

Die **Context-API** ist ein Mechanismus, um **globale Daten** (z. B. Theme, Auth-Status, Sprache) bereitzustellen, **ohne Prop Drilling** durch viele Ebenen.
Sie besteht aus drei Teilen:

1. `createContext(defaultValue)` ‚Äì erstellt einen Context.
2. `Provider` ‚Äì stellt den Wert f√ºr Kinder bereit.
3. `useContext` ‚Äì liest den Wert direkt in einer Kindkomponente aus.

---

### Funktionsweise von `useContext`

* `useContext(MyContext)` greift auf den **n√§chstgelegenen Provider-Wert** zu.
* √Ñndert sich der Context-Wert, werden alle abh√§ngigen Komponenten neu gerendert.
* Ohne Provider wird der **defaultValue** genutzt.

---

### Beispiel

```jsx
import { createContext, useContext } from "react";

// 1. Context erstellen
const ThemeContext = createContext("light");

function ThemedButton() {
  // 2. Zugriff auf den Wert
  const theme = useContext(ThemeContext);
  return <button className={theme}>Thema: {theme}</button>;
}

export default function App() {
  return (
    // 3. Provider umschlie√üt die Kinder
    <ThemeContext.Provider value="dark">
      <ThemedButton />
    </ThemeContext.Provider>
  );
}
```

* `App` definiert den Wert `"dark"`.
* `ThemedButton` greift mit `useContext(ThemeContext)` darauf zu.

---

### Zusammenfassung

* **Context-API** = globale Datenverwaltung ohne Prop Drilling.
* **`useContext`** = Hook zum direkten Zugriff auf Context-Werte.
* Vorteil: einfache Verteilung globaler Zust√§nde, Nachteil: viele Re-Renders bei gro√üen B√§umen ‚Üí oft mit **Memoization/State-Management-Libs** kombiniert.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Context](https://react.dev/reference/react/useContext)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

64. ### <a name="64"></a> Was sind Portale in React?

### Portale in React

Ein **Portal** in React erm√∂glicht es, **JSX-Inhalte au√üerhalb der DOM-Hierarchie der Elternkomponente** zu rendern.
Man kann damit UI-Elemente (z. B. Modals, Tooltips, Overlays) direkt in einen **anderen DOM-Knoten** einf√ºgen.

---

### Funktionsweise

* `ReactDOM.createPortal(child, container)`
* `child` = React-Element(e), die gerendert werden sollen.
* `container` = Zielknoten im DOM, au√üerhalb des Standard-Root-Elements.

---

### Beispiel

```jsx
import { useState } from "react";
import { createPortal } from "react-dom";

function Modal({ children, onClose }) {
  return createPortal(
    <div className="modal">
      <div className="content">{children}</div>
      <button onClick={onClose}>Schlie√üen</button>
    </div>,
    document.getElementById("modal-root") // anderer DOM-Knoten
  );
}

export default function App() {
  const [open, setOpen] = useState(false);

  return (
    <>
      <button onClick={() => setOpen(true)}>Modal √∂ffnen</button>
      {open && <Modal onClose={() => setOpen(false)}>Hallo aus dem Portal!</Modal>}
    </>
  );
}
```

* In `index.html` muss ein zus√§tzlicher Knoten vorhanden sein:

```html
<div id="root"></div>
<div id="modal-root"></div>
```

---

### Zusammenfassung

* **Portale** = M√∂glichkeit, Inhalte in einen **anderen DOM-Knoten** zu rendern.
* Typische Anwendungsf√§lle: **Modals, Tooltips, Overlays**.
* API: `ReactDOM.createPortal(child, container)`.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Portals](https://react.dev/reference/react-dom/createPortal)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

65. ### <a name="65"></a> Was ist bedingtes Rendern (Conditional Rendering)?

### Bedingtes Rendern in React

**Conditional Rendering** bedeutet, dass eine Komponente **UI-Elemente abh√§ngig von Bedingungen** rendert ‚Äì √§hnlich wie `if/else` in JavaScript.
Damit kann React **unterschiedliche Inhalte** anzeigen, je nach State, Props oder Logik.

---

### Beispiele

**1. If/Else √ºber tern√§ren Operator:**

```jsx
function Greeting({ isLoggedIn }) {
  return (
    <div>
      {isLoggedIn ? <h1>Willkommen zur√ºck!</h1> : <h1>Bitte einloggen</h1>}
    </div>
  );
}
```

**2. Bedingte Anzeige mit `&&`:**

```jsx
function Notification({ unread }) {
  return (
    <div>
      <h2>Postfach</h2>
      {unread > 0 && <p>Du hast {unread} ungelesene Nachrichten.</p>}
    </div>
  );
}
```

**3. R√ºckgabe von `null`:**

```jsx
function Warning({ show }) {
  if (!show) return null; // nichts rendern
  return <p>Achtung!</p>;
}
```

---

### Zusammenfassung

* **Conditional Rendering** = UI abh√§ngig von Bedingungen.
* M√∂glichkeiten: **Ternary Operator, `&&`, `if/else`, `null`**.
* Typische F√§lle: Auth, Ladezustand, Fehleranzeige.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Conditional Rendering](https://react.dev/learn/conditional-rendering)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

66. ### <a name="66"></a> Was ist ein Error Boundary?

### Error Boundary in React

Ein **Error Boundary** ist eine **Klassenkomponente**, die **JavaScript-Fehler** in ihrem Kind-Baum abf√§ngt und eine **Fallback-UI** anzeigt, anstatt dass die gesamte Anwendung abst√ºrzt.

---

### Eigenschaften

* Error Boundaries fangen **Render-Fehler**, Fehler in **Lifecycle-Methoden** und in **Konstruktoren von Kind-Komponenten** ab.
* Sie fangen **keine Fehler** in Event-Handlern, asynchronem Code (z. B. `setTimeout`) oder Server-Code.
* Wichtige Methoden:

  * `static getDerivedStateFromError(error)` ‚Üí aktualisiert State f√ºr Fallback-UI.
  * `componentDidCatch(error, info)` ‚Üí Logging oder Error-Reporting.

---

### Beispiel

```jsx
import React from "react";

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError() {
    return { hasError: true };
  }

  componentDidCatch(error, info) {
    console.error("Fehler abgefangen:", error, info);
  }

  render() {
    if (this.state.hasError) {
      return <h2>Etwas ist schiefgelaufen.</h2>;
    }
    return this.props.children;
  }
}

// Nutzung
function BuggyComponent() {
  throw new Error("Crash!");
}

export default function App() {
  return (
    <ErrorBoundary>
      <BuggyComponent />
    </ErrorBoundary>
  );
}
```

---

### Zusammenfassung

* **Error Boundary** = Klassenkomponente, die Fehler abf√§ngt und Fallback-UI rendert.
* Methoden: `getDerivedStateFromError`, `componentDidCatch`.
* Einsatz: Schutz vor UI-Crashs, Logging, bessere User Experience.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Error Boundaries](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

67. ### <a name="67"></a> Wie funktioniert Event-Handling in React?

### Event-Handling in React

* Events in React funktionieren √§hnlich wie in DOM, sind aber in eine **synthetische Event-Schicht** (Synthetic Events) eingebettet.
* Dadurch sind Events in allen Browsern **konsistent**.
* Event-Handler werden als **CamelCase-Props** √ºbergeben (z. B. `onClick` statt `onclick`).
* Statt Strings wird eine **Funktion** √ºbergeben.

---

### Beispiel

```jsx
function Button() {
  function handleClick(event) {
    console.log("Geklickt!", event.type);
  }

  return (
    <button onClick={handleClick}>
      Klick mich
    </button>
  );
}

export default Button;
```

* `onClick={handleClick}` ‚Üí Funktion wird als Callback √ºbergeben.
* Das Event-Objekt (`event`) ist ein **SyntheticEvent** mit gleichen Methoden wie beim DOM-Event (`preventDefault`, `stopPropagation`).

---

### Besondere Punkte

1. **Event-Bindung mit Arrow Functions**

   ```jsx
   <button onClick={() => console.log("Inline-Handler")}>Click</button>
   ```

2. **`this`-Binding bei Klassen**
   In Klassenkomponenten muss man Methoden oft im Konstruktor binden oder Arrow Functions verwenden.

3. **Event Delegation**
   React h√§ngt Events **nicht direkt am DOM-Element**, sondern am Root-Knoten (`document`), was Performance optimiert.

---

### Zusammenfassung

* Event-Handling in React basiert auf **Synthetic Events** f√ºr Browser-Konsistenz.
* Syntax: **CamelCase**-Props + Callback-Funktion.
* Vorteile: einheitliches API, Event Delegation, bekannte DOM-Methoden (`preventDefault`, `stopPropagation`).

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Events](https://react.dev/learn/responding-to-events)
* [MDN ‚Äì Einf√ºhrung in DOM-Events (RU)](https://developer.mozilla.org/ru/docs/Learn/JavaScript/Building_blocks/Events)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

68. ### <a name="68"></a> Was ist ein synthetisches Ereignis (SyntheticEvent)?

### SyntheticEvent in React

Ein **SyntheticEvent** ist eine von React bereitgestellte **Wrapper-Schicht um native DOM-Events**.
Es sorgt f√ºr **Browser-Konsistenz** und stellt in allen Umgebungen die gleiche API bereit.

---

### Eigenschaften

* Enth√§lt die gleichen Methoden wie native Events: `preventDefault()`, `stopPropagation()`.
* Funktioniert in allen Browsern gleich ‚Üí kein spezielles Polyfill n√∂tig.
* Events werden aus Performance-Gr√ºnden **gepoolt** (nach der Event-Callback-Ausf√ºhrung sind die Eigenschaften auf `null` gesetzt).

  * Falls man das Event **asynchron** nutzen will, muss man `event.persist()` aufrufen.

---

### Beispiel

```jsx
function Form() {
  function handleSubmit(e) {
    e.preventDefault(); // SyntheticEvent mit DOM-API
    console.log("Formular gesendet!");
  }

  return (
    <form onSubmit={handleSubmit}>
      <button type="submit">Absenden</button>
    </form>
  );
}
```

**Asynchrone Nutzung:**

```jsx
function InputLogger() {
  function handleChange(e) {
    e.persist(); // Event bleibt erhalten
    setTimeout(() => console.log(e.target.value), 1000);
  }

  return <input onChange={handleChange} />;
}
```

---

### Zusammenfassung

* **SyntheticEvent** = React-Wrapper um native DOM-Events.
* Vorteil: **einheitliches Event-System, Cross-Browser-Kompatibilit√§t, Performance durch Event-Pooling**.
* Bei asynchroner Nutzung: `event.persist()`.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì SyntheticEvent](https://react.dev/reference/react/SyntheticEvent)
* [MDN ‚Äì DOM Events](https://developer.mozilla.org/ru/docs/Web/API/Event)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

69. ### <a name="69"></a> Was ist props.children?

### `props.children` in React

* **`props.children`** ist eine **spezielle Prop**, die automatisch alle **verschachtelten Inhalte (Child-Elemente)** einer Komponente enth√§lt.
* Damit lassen sich **Wrapper- oder Layout-Komponenten** flexibel gestalten, ohne vorher zu wissen, was darin steht.

---

### Beispiel

```jsx
function Card({ children }) {
  return <div className="card">{children}</div>;
}

export default function App() {
  return (
    <Card>
      <h2>Titel</h2>
      <p>Das ist Inhalt innerhalb von Card</p>
    </Card>
  );
}
```

* `props.children` enth√§lt hier `<h2>...</h2>` und `<p>...</p>`.
* Card kann beliebige Inhalte aufnehmen, ohne diese fest im Code zu definieren.

---

### Zusammenfassung

* **`props.children`** = Container f√ºr verschachtelte Inhalte einer Komponente.
* Einsatz: Wrapper-, Layout- und Container-Komponenten.
* Vorteil: **maximale Flexibilit√§t** und Wiederverwendung von UI-Strukturen.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Children](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

70. ### <a name="70"></a> Was bedeutet ‚Äûcontrolled component‚Äú und ‚Äûuncontrolled component‚Äú bei Formularen?

### Controlled Components

* Bei einer **controlled component** verwaltet **React den Wert** eines Formularelements √ºber den **State**.
* Der Wert wird durch `value`-Prop gesetzt und √ºber `onChange` aktualisiert.
* React = **Single Source of Truth**.

```jsx
import { useState } from "react";

function ControlledInput() {
  const [text, setText] = useState("");

  return (
    <input
      value={text}
      onChange={e => setText(e.target.value)}
    />
  );
}
```

---

### Uncontrolled Components

* Bei einer **uncontrolled component** verwaltet das **DOM selbst den Wert**.
* React greift √ºber eine **Ref** auf den aktuellen Wert zu.
* Weniger Code, aber weniger Kontrolle durch React.

```jsx
import { useRef } from "react";

function UncontrolledInput() {
  const inputRef = useRef();

  const handleSubmit = () => {
    alert(inputRef.current.value); // Wert direkt aus DOM
  };

  return (
    <>
      <input ref={inputRef} />
      <button onClick={handleSubmit}>Absenden</button>
    </>
  );
}
```

---

### Vergleich

| Controlled                       | Uncontrolled                  |
| -------------------------------- | ----------------------------- |
| React verwaltet den Wert (State) | DOM verwaltet den Wert        |
| `value` + `onChange`             | Zugriff via `ref`             |
| Bessere Validierung & Kontrolle  | Einfachere schnelle Umsetzung |

---

### Zusammenfassung

* **Controlled Component**: Wert im React-State, volle Kontrolle.
* **Uncontrolled Component**: Wert im DOM, Zugriff via Ref.
* Best Practice: Controlled f√ºr komplexe Formulare, Uncontrolled f√ºr einfache F√§lle.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Controlled vs. Uncontrolled](https://react.dev/learn/sharing-state-between-components#controlled-and-uncontrolled-components)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

71. ### <a name="71"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

72. ### <a name="72"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

73. ### <a name="73"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

74. ### <a name="74"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

75. ### <a name="75"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

76. ### <a name="76"></a> Wie f√ºhrt man API-Aufrufe mit Fetch oder Axios durch?

### API-Aufrufe in React mit **Fetch** und **Axios**

In React f√ºhrt man API-Requests meist in **`useEffect`** aus, damit sie nach dem Rendern starten.
Der Response wird im **State** gespeichert.

---

### Mit **Fetch**

```jsx
import { useState, useEffect } from "react";

function Users() {
  const [users, setUsers] = useState([]);

  useEffect(() => {
    fetch("https://jsonplaceholder.typicode.com/users")
      .then(res => res.json())
      .then(data => setUsers(data))
      .catch(err => console.error(err));
  }, []); // nur einmal beim Mount

  return (
    <ul>
      {users.map(u => <li key={u.id}>{u.name}</li>)}
    </ul>
  );
}
```

---

### Mit **Axios**

```jsx
import { useState, useEffect } from "react";
import axios from "axios";

function Users() {
  const [users, setUsers] = useState([]);

  useEffect(() => {
    axios.get("https://jsonplaceholder.typicode.com/users")
      .then(res => setUsers(res.data))
      .catch(err => console.error(err));
  }, []);

  return (
    <ul>
      {users.map(u => <li key={u.id}>{u.name}</li>)}
    </ul>
  );
}
```

---

### Unterschiede **Fetch vs. Axios**

* **Fetch**: eingebaut im Browser, aber kein automatisches JSON-Parsing f√ºr Fehler.
* **Axios**: externe Bibliothek, komfortabler (automatisches JSON, Timeouts, Interceptors).

---

### Zusammenfassung

* API-Aufrufe in React mit **`useEffect` + State** umsetzen.
* **Fetch** = native API, minimalistisch.
* **Axios** = komfortabler, mit Extras wie Interceptors.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Daten abrufen](https://react.dev/learn/synchronizing-with-effects#fetching-data)
* [MDN ‚Äì Fetch API (RU)](https://developer.mozilla.org/ru/docs/Web/API/Fetch_API)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

77. ### <a name="77"></a> Wie verwaltet man Lade-, Fehler- und Erfolgsstatus?

### Lade-, Fehler- und Erfolgsstatus verwalten (Patterns)

**Grundidee:** Status als **endlichen Automat** modellieren (`'idle' | 'loading' | 'success' | 'error'`) und **UI zustandsbasiert** rendern.

---

### Minimal-Pattern mit Fetch + `useEffect`

```jsx
import { useEffect, useState } from "react";

export default function Users() {
  const [status, setStatus] = useState("idle");     // 'idle' | 'loading' | 'success' | 'error'
  const [data, setData] = useState(null);
  const [error, setError] = useState(null);

  useEffect(() => {
    const ctrl = new AbortController();
    const load = async () => {
      try {
        setStatus("loading");
        const res = await fetch("https://jsonplaceholder.typicode.com/users", { signal: ctrl.signal });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const json = await res.json();
        setData(json);
        setStatus("success");
      } catch (e) {
        if (e.name !== "AbortError") {
          setError(e);
          setStatus("error");
        }
      }
    };
    load();
    return () => ctrl.abort(); // Cleanup verhindert Setzen nach Unmount
  }, []);

  if (status === "loading") return <p>Laden‚Ä¶</p>;
  if (status === "error") return <p>Fehler: {error.message}</p>;
  if (status === "success") {
    return <ul>{data.map(u => <li key={u.id}>{u.name}</li>)}</ul>;
  }
  return <button onClick={() => { /* optional: Lazy-Load triggern */ }}>Daten laden</button>;
}
```

**Wichtig**

* **Ein Statusfeld** statt mehrerer Booleans (verhindert inkonsistente Kombinationen).
* **AbortController** f√ºr Abbruch bei Unmount/Neuladen.
* **Fehlerpr√ºfung** (`!res.ok`) vor `res.json()`.

---

### Reusable: kleiner `useAsync`-Hook

```jsx
import { useEffect, useRef, useState } from "react";

export function useAsync(fn, deps = []) {
  const [state, setState] = useState({ status: "idle", data: null, error: null });
  const mounted = useRef(true);

  useEffect(() => {
    mounted.current = true;
    const run = async () => {
      setState({ status: "loading", data: null, error: null });
      try {
        const data = await fn();
        if (mounted.current) setState({ status: "success", data, error: null });
      } catch (err) {
        if (mounted.current) setState({ status: "error", data: null, error: err });
      }
    };
    run();
    return () => { mounted.current = false; };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, deps);

  return state; // {status, data, error}
}

// Nutzung
// const { status, data, error } = useAsync(() => fetch("/api").then(r => r.json()), []);
```

---

### UI-Muster

* **Skeleton/Spinner** bei `loading`.
* **Retry-Button** bei `error` (neuen Fetch triggern).
* **Disabled/ARIA** w√§hrend `loading` (Barrierefreiheit).
* **Optimistic UI**/Rollback bei Mutationen (separater Status je Mutation).

---

### Zusammenfassung

* Status als **disjunkte Zust√§nde** modellieren; UI rein **zustandsgetrieben** rendern.
* Netzwerkcode in `useEffect` (mit **Cleanup/Abort**), Fehler fr√ºh pr√ºfen.
* F√ºr Wiederverwendung: **Custom Hook** (`useAsync`) oder Libraries (z. B. React Query/SWR).

üìñ Weiterf√ºhrend:

* React Docs: [Synchronizing with Effects](https://react.dev/learn/synchronizing-with-effects), [Conditional Rendering](https://react.dev/learn/conditional-rendering)
* MDN (RU): [Fetch API](https://developer.mozilla.org/ru/docs/Web/API/Fetch_API), [AbortController](https://developer.mozilla.org/ru/docs/Web/API/AbortController)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

78. ### <a name="78"></a> Wie funktioniert WebSocket mit React?

### WebSocket mit React: Grundlagen & Pattern

**Idee:** In React √∂ffnest du die Verbindung in einem **Effect**, h√§ltst die Socket-Instanz in einem **Ref**, registrierst **Event-Handler**, und r√§umst im **Cleanup** wieder auf. State speichert eingehende Daten.

---

### Minimalbeispiel (Empfangen & Senden)

```jsx
import { useEffect, useRef, useState, useCallback } from "react";

export default function Chat() {
  const [messages, setMessages] = useState([]);
  const [connected, setConnected] = useState(false);
  const socketRef = useRef(null);

  // Verbindung aufbauen
  useEffect(() => {
    const ws = new WebSocket("wss://echo.websocket.events"); // Demo-Endpoint
    socketRef.current = ws;

    ws.addEventListener("open", () => setConnected(true));
    ws.addEventListener("message", (e) => {
      // optional JSON.parse(e.data)
      setMessages((prev) => [...prev, String(e.data)]);
    });
    ws.addEventListener("close", () => setConnected(false));
    ws.addEventListener("error", () => setConnected(false));

    return () => {
      ws.close(); // Cleanup beim Unmount
    };
  }, []);

  // Stabiler send()-Callback
  const sendMessage = useCallback((text) => {
    const ws = socketRef.current;
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(text);
    }
  }, []);

  return (
    <>
      <p>Status: {connected ? "verbunden" : "getrennt"}</p>
      <button onClick={() => sendMessage("Hallo WebSocket!")}>Senden</button>
      <ul>{messages.map((m, i) => <li key={i}>{m}</li>)}</ul>
    </>
  );
}
```

---

### Robuster Custom Hook mit Reconnect & Backoff

```jsx
import { useEffect, useRef, useState, useCallback } from "react";

export function useWebSocket(url, { reconnect = true, maxDelay = 8000 } = {}) {
  const wsRef = useRef(null);
  const [readyState, setReadyState] = useState(WebSocket.CLOSED);
  const [lastMessage, setLastMessage] = useState(null);
  const retryRef = useRef(0);
  const timerRef = useRef(null);

  const connect = useCallback(() => {
    const ws = new WebSocket(url);
    wsRef.current = ws;

    ws.onopen = () => {
      setReadyState(ws.readyState);
      retryRef.current = 0; // Reset Backoff
    };
    ws.onmessage = (e) => setLastMessage(e.data);
    ws.onerror = () => {};
    ws.onclose = () => {
      setReadyState(WebSocket.CLOSED);
      if (reconnect) {
        const delay = Math.min(1000 * 2 ** retryRef.current++, maxDelay);
        timerRef.current = setTimeout(connect, delay);
      }
    };
    setReadyState(ws.readyState);
  }, [url, reconnect, maxDelay]);

  useEffect(() => {
    connect();
    return () => {
      reconnect = false; // eslint-disable-line no-param-reassign
      clearTimeout(timerRef.current);
      wsRef.current?.close();
    };
  }, [connect]);

  const send = useCallback((data) => {
    const ws = wsRef.current;
    if (ws?.readyState === WebSocket.OPEN) ws.send(data);
  }, []);

  return { readyState, lastMessage, send };
}
```

**Nutzung:**

```jsx
import { useEffect, useState } from "react";
import { useWebSocket } from "./useWebSocket.js";

export default function Ticker() {
  const { readyState, lastMessage, send } = useWebSocket("wss://echo.websocket.events");
  const [log, setLog] = useState([]);

  useEffect(() => {
    if (lastMessage != null) setLog((l) => [...l, String(lastMessage)]);
  }, [lastMessage]);

  return (
    <>
      <p>State: {readyState === WebSocket.OPEN ? "OPEN" : readyState}</p>
      <button onClick={() => send(JSON.stringify({ ping: Date.now() }))}>Ping</button>
      <ul>{log.map((x, i) => <li key={i}>{x}</li>)}</ul>
    </>
  );
}
```

---

### Best Practices

* **`useRef`** f√ºr die Socket-Instanz (ver√§ndert sich ohne Re-Render).
* **Cleanup** im `useEffect` ‚Üí `ws.close()`.
* **Nachrichtenformat**: JSON verwenden (`JSON.stringify/parse`), Versionierung des Payloads beachten.
* **Reconnect** mit **exponentiellem Backoff**; bei Auth-Sockets (JWT) Token-Refresh einplanen.
* **Sicherheit**: `wss://`, serverseitige Origin/Rate-Limits, Heartbeats/Pings f√ºr Keep-Alive.
* **Zustandsmodell**: UI klar zwischen `OPEN/CONNECTING/CLOSING/CLOSED` unterscheiden.

---

### Zusammenfassung

* WebSocket in React: **√∂ffnen im `useEffect`**, **Instanz in `useRef`**, **Event-Handler registrieren**, **Cleanup** beim Unmount.
* Senden √ºber stabilen **`useCallback`**; f√ºr Wiederverwendung **Custom Hook** mit Reconnect/Backoff bauen.
* JSON-Payloads, Fehler-/Statushandling und Sicherheit ber√ºcksichtigen.

üìñ Weiterf√ºhrend:

* React Docs: [Effects](https://react.dev/learn/synchronizing-with-effects)
* MDN (RU): [WebSocket API](https://developer.mozilla.org/ru/docs/Web/API/WebSockets_API), [WebSocket](https://developer.mozilla.org/ru/docs/Web/API/WebSocket)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

79. ### <a name="79"></a> Wie kann man Daten zwischen Komponenten weitergeben?

### Datenfluss zwischen Komponenten in React

**1) Eltern ‚Üí Kind: √ºber Props**

```jsx
function Child({ title }) {
  return <h2>{title}</h2>;
}

export default function Parent() {
  return <Child title="Hallo, Sergii" />;
}
```

**2) Kind ‚Üí Eltern: √ºber Callback-Props (Bottom-up Events)**

```jsx
import { useState } from "react";

function Child({ onChange }) {
  return <button onClick={() => onChange("Neuer Wert")}>Senden</button>;
}

export default function Parent() {
  const [val, setVal] = useState("");
  return (
    <>
      <Child onChange={setVal} />
      <p>Empfangen: {val}</p>
    </>
  );
}
```

**3) Geschwister-Komponenten:** **Lifting State Up** (gemeinsamer Eltern-State)

```jsx
import { useState } from "react";

function A({ value, onChange }) {
  return <button onClick={() => onChange(value + 1)}>A+1</button>;
}
function B({ value }) { return <p>B sieht: {value}</p>; }

export default function Parent() {
  const [n, setN] = useState(0);
  return (
    <>
      <A value={n} onChange={setN} />
      <B value={n} />
    </>
  );
}
```

**4) Global/√ºber viele Ebenen:** **Context-API (`useContext`)** ‚Äì vermeidet Prop Drilling

```jsx
import { createContext, useContext } from "react";

const AuthContext = createContext({ user: null });

function UserTag() {
  const { user } = useContext(AuthContext);
  return <span>{user?.name ?? "Gast"}</span>;
}

export default function App() {
  return (
    <AuthContext.Provider value={{ user: { name: "Sergii" } }}>
      <UserTag />
    </AuthContext.Provider>
  );
}
```

**5) Fortgeschritten (optional):**

* **URL/Router** (z. B. Query-/Path-Parameter), **State-Management-Libs** (Redux, Zustand), **Events** (selten), **Server State** (React Query/SWR).
* **Refs** via `forwardRef` f√ºr imperativen Zugriff, **nicht** f√ºr allgemeinen Datenfluss.

---

### Zusammenfassung

* Standard: **Props** (Top-down) und **Callbacks** (Bottom-up).
* **Geschwister** teilen Daten √ºber **Lifting State Up**.
* **Context** f√ºr globale/weit gestreute Daten.
* Bei komplexen F√§llen: **Router/State-Management/Server-State** erg√§nzen.

üìñ Weiterf√ºhrend:

* React Docs: [Props weitergeben](https://react.dev/learn/passing-props-to-a-component), [State teilen & Lifting State Up](https://react.dev/learn/sharing-state-between-components), [Context & useContext](https://react.dev/reference/react/useContext)
* MDN (RU): [–í–µ–±-—Å–æ–±—ã—Ç–∏—è (–æ–±–∑–æ—Ä)](https://developer.mozilla.org/ru/docs/Learn/JavaScript/Building_blocks/Events)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

80. ### <a name="80"></a> Wie macht man einen Datenabruf nur beim ersten Rendern?

### Datenabruf nur beim ersten Render (Mount)

**Pattern:** `useEffect` mit **leerem Abh√§ngigkeitsarray `[]`**.
Hinweis: In **React 18** ruft der Dev-Mode (Strict Mode) Effekte absichtlich **zweimal** auf (Mount ‚Üí Cleanup ‚Üí Mount) zur Fehlererkennung. In Production nur einmal. Nutze **AbortController** oder eine **Ref-Garde**, um Doppel-Requests zu vermeiden.

```jsx
import { useEffect, useState, useRef } from "react";

export default function UsersOnce() {
  const [users, setUsers] = useState([]);
  const [status, setStatus] = useState("idle"); // 'idle' | 'loading' | 'success' | 'error'
  const fetchedRef = useRef(false); // sch√ºtzt vor Doppel-Fetch im Dev-Mode

  useEffect(() => {
    if (fetchedRef.current) return;    // schon geladen? -> abbrechen
    fetchedRef.current = true;

    const ctrl = new AbortController();
    const load = async () => {
      try {
        setStatus("loading");
        const res = await fetch("https://jsonplaceholder.typicode.com/users", {
          signal: ctrl.signal,
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();
        setUsers(data);
        setStatus("success");
      } catch (e) {
        if (e.name !== "AbortError") setStatus("error");
      }
    };

    load();
    return () => ctrl.abort(); // Cleanup verhindert Leaks/SetState-after-unmount
  }, []); // nur beim (ersten) Mount

  if (status === "loading") return <p>Laden‚Ä¶</p>;
  if (status === "error") return <p>Fehler beim Laden.</p>;
  return <ul>{users.map(u => <li key={u.id}>{u.name}</li>)}</ul>;
}
```

**Alternativen/Erg√§nzungen**

* **Idempotenter Request** (Server akzeptiert wiederholte Calls ohne Seiteneffekt).
* **Datenbibliotheken** wie React Query/SWR cachen & deduplizieren Requests automatisch.

---

### Zusammenfassung

* ‚ÄûNur einmal laden‚Äú: `useEffect(() => {...}, [])`.
* In React 18 dev kann der Effekt doppelt laufen ‚Üí **`AbortController`** oder **Ref-Garde** nutzen.
* Cleanup im Effekt verhindert Speicherlecks und Fehlzust√§nde.

üìñ Weiterf√ºhrend:

* React Docs: [Effects & Abh√§ngigkeiten](https://react.dev/learn/synchronizing-with-effects)
* React Docs: [useEffect API](https://react.dev/reference/react/useEffect)
* MDN (RU): [Fetch API](https://developer.mozilla.org/ru/docs/Web/API/Fetch_API), [AbortController](https://developer.mozilla.org/ru/docs/Web/API/AbortController)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

81. ### <a name="81"></a> Was ist das Problem bei ‚Äûstale closures‚Äú mit Hooks?

### ‚ÄûStale Closures‚Äú in React Hooks

Ein **stale closure** tritt auf, wenn eine Funktion innerhalb einer Komponente auf **veraltete Variablenwerte** zugreift, weil sie an den Zustand **gebunden wurde, der zum Zeitpunkt der Definition g√ºltig war** ‚Äì nicht am aktuellen State/Prop.

---

### Beispiel (Problem)

```jsx
import { useEffect, useState } from "react";

function Timer() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const id = setInterval(() => {
      // ‚ùå stale closure: 'count' ist immer 0
      setCount(count + 1);
    }, 1000);

    return () => clearInterval(id);
  }, []); // [] ‚Üí Effekt l√§uft nur einmal, count ist ‚Äûeingefroren‚Äú

  return <p>{count}</p>;
}
```

* `count` im Callback bleibt **immer 0**, weil das Closure aus dem ersten Render eingefroren ist.
* Ergebnis: Z√§hler bleibt bei `1` stehen.

---

### L√∂sungen

1. **Funktionale Updates verwenden**

   ```jsx
   setCount(prev => prev + 1); // aktueller Wert garantiert
   ```

   ```jsx
   useEffect(() => {
     const id = setInterval(() => setCount(prev => prev + 1), 1000);
     return () => clearInterval(id);
   }, []);
   ```

2. **Abh√§ngigkeiten korrekt setzen**

   ```jsx
   useEffect(() => {
     console.log("Neuer Count:", count);
   }, [count]); // aktualisiert bei jedem Count
   ```

3. **useRef f√ºr mutable Werte**

   * Wenn man Werte **lesen, aber kein Re-Render ausl√∂sen** m√∂chte.

---

### Zusammenfassung

* **Stale closure** = Callback in Hook verwendet **veraltete Variablenwerte**.
* Ursache: Closures binden Werte aus dem Render-Zeitpunkt.
* L√∂sung: **funktionale Updates (`prev => ...`)**, korrekte **Dependencies** oder **Refs**.

üìñ Weiterf√ºhrend:

* [React Docs ‚Äì useEffect & Closures](https://react.dev/learn/synchronizing-with-effects#what-to-do-when-you-disagree-with-the-linter)
* [Dan Abramov ‚Äì A Complete Guide to useEffect](https://overreacted.io/a-complete-guide-to-useeffect/)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

82. ### <a name="82"></a> Wie funktioniert die Fehlerbehandlung mit try/catch in React?

### Fehlerbehandlung mit `try...catch` in React

1. **In Event-Handlern**

* Fehler k√∂nnen direkt mit `try...catch` abgefangen werden.
* Das verhindert, dass die App abst√ºrzt.

```jsx
function Form() {
  function handleSubmit(e) {
    e.preventDefault();
    try {
      throw new Error("Ups!");
    } catch (err) {
      console.error("Fehler im Event:", err.message);
    }
  }

  return <form onSubmit={handleSubmit}><button>Absenden</button></form>;
}
```

---

2. **In asynchronem Code (z. B. Fetch, Axios)**

* `try...catch` funktioniert nur in `async`-Funktionen.
* Alternative: `.catch()` bei Promises.

```jsx
import { useEffect, useState } from "react";

function DataFetcher() {
  const [data, setData] = useState(null);
  const [error, setError] = useState(null);

  useEffect(() => {
    async function load() {
      try {
        const res = await fetch("https://jsonplaceholder.typicode.com/users");
        if (!res.ok) throw new Error("HTTP-Fehler " + res.status);
        const json = await res.json();
        setData(json);
      } catch (err) {
        setError(err);
      }
    }
    load();
  }, []);

  if (error) return <p>Fehler: {error.message}</p>;
  if (!data) return <p>Laden...</p>;
  return <ul>{data.map(u => <li key={u.id}>{u.name}</li>)}</ul>;
}
```

---

3. **Nicht m√∂glich: Render-Phase/Lifecycle**

* Fehler im **Rendern von Komponenten** oder in **Hooks** k√∂nnen mit `try...catch` **nicht** abgefangen werden.
* Daf√ºr braucht man **Error Boundaries** (`getDerivedStateFromError`, `componentDidCatch`).

---

### Zusammenfassung

* **`try...catch`** funktioniert in Event-Handlern und asynchronem Code (z. B. `fetch`).
* In der Render-Phase reicht `try...catch` nicht ‚Üí dort braucht man **Error Boundaries**.
* Best Practice: **`try...catch` f√ºr asynchrone Logik**, **Error Boundaries f√ºr UI-Absturz-Schutz**.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Error Boundaries](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary)
* [MDN ‚Äì try...catch (RU)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/try...catch)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

83. ### <a name="83"></a> Wie kann man ein Mock-API oder Mock Server verwenden?

### Mock-API / Mock Server in React: g√§ngige Optionen

#### 1) **MSW ‚Äì Mock Service Worker** (empfohlen: realit√§tsnah im Browser & Node)

* Interceptet **`fetch`/`XHR`** auf Netzwerkebene, kein Code-√Ñndern in Komponenten.
* Funktioniert in **Dev**, **Storybook** und **Tests (Jest/Vitest)**.

```js
// src/mocks/handlers.js
import { http, HttpResponse } from "msw";

export const handlers = [
  http.get("/api/users", () => HttpResponse.json([
    { id: 1, name: "Sergii" },
    { id: 2, name: "Anna" },
  ])),
];

// src/mocks/browser.js
import { setupWorker } from "msw/browser";
import { handlers } from "./handlers.js";
export const worker = setupWorker(...handlers);

// src/main.jsx
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import App from "./App.jsx";

async function enableMocking() {
  if (import.meta.env.DEV) {
    const { worker } = await import("./mocks/browser.js");
    await worker.start({ onUnhandledRequest: "bypass" });
  }
}
enableMocking();

createRoot(document.getElementById("root")).render(
  <StrictMode><App /></StrictMode>
);
```

```jsx
// Normales Fetching bleibt unver√§ndert
import { useEffect, useState } from "react";

export default function Users() {
  const [users, setUsers] = useState([]);
  useEffect(() => {
    fetch("/api/users").then(r => r.json()).then(setUsers);
  }, []);
  return <ul>{users.map(u => <li key={u.id}>{u.name}</li>)}</ul>;
}
```

**Vorteile:** keine Codever√§nderung am Fetching, gleiche API wie Produktion, ideal f√ºr UI-Entwicklung & Tests.

---

#### 2) **JSON Server** (schneller REST-Mock via Datei)

* Startet in Sekunden eine REST-API aus `db.json`.

```json
// db.json
{
  "users": [
    { "id": 1, "name": "Sergii" },
    { "id": 2, "name": "Anna" }
  ]
}
```

```bash
# Installation & Start
npm i -D json-server
npx json-server --watch db.json --port 4000
```

```jsx
// React: ganz normal fetchen
import { useEffect, useState } from "react";

export default function Users() {
  const [users, setUsers] = useState([]);
  useEffect(() => {
    fetch("http://localhost:4000/users").then(r => r.json()).then(setUsers);
  }, []);
  return <ul>{users.map(u => <li key={u.id}>{u.name}</li>)}</ul>;
}
```

**Vorteile:** echte REST-URLs, unterst√ºtzt Filter/Queries, ideal f√ºr Team-Prototyping.
**Hinweis:** CORS/Port beachten; ggf. Proxy in Vite/CRA konfigurieren.

---

#### 3) **MirageJS** (in-app Mock-Server)

* Startet einen **virtuellen Server im Browser**, definiert Routen/Models in JS.

```js
// src/server.js
import { createServer } from "miragejs";

export function makeServer() {
  return createServer({
    routes() {
      this.namespace = "api";
      this.get("/users", () => [
        { id: "1", name: "Sergii" },
        { id: "2", name: "Anna" },
      ]);
    },
  });
}

// src/main.jsx
import { makeServer } from "./server.js";
if (import.meta.env.DEV) makeServer();
```

**Vorteile:** komplexere Szenarien (Beziehungen, Statuscodes) ohne externen Prozess.

---

### Mocking im **Test** (Jest/Vitest) ‚Äì minimal

* Entweder **MSW (Node-Adapter)** oder **Fetch mocken**:

```js
// __tests__/users.test.js
import { render, screen, waitFor } from "@testing-library/react";
import Users from "../Users.jsx";

global.fetch = vi.fn(() =>
  Promise.resolve({ ok: true, json: () => Promise.resolve([{ id: 1, name: "Sergii" }]) })
);

test("rendert Nutzerliste", async () => {
  render(<Users />);
  await waitFor(() => screen.getByText("Sergii"));
});
```

---

### Wann welche L√∂sung?

* **MSW:** realit√§tsnah, ‚Äûnetzwerkgetreu‚Äú, Dev & Test ‚Äì **Standard-Empfehlung**.
* **JSON Server:** schnell, eigenst√§ndiger REST-Endpunkt, gut f√ºr Teams/Backend-Entkopplung.
* **MirageJS:** alles in einem Bundle, m√§chtig f√ºr komplexe Fake-Backends.

---

### Zusammenfassung

* Mocking-Optionen: **MSW** (Intercept), **JSON Server** (echter Dev-Server), **MirageJS** (in-app).
* React-Code bleibt idR unver√§ndert; Mock-Schicht ersetzt/bedient die API.
* F√ºr Tests: **MSW (Node)** oder gezieltes **Fetch-Mocking**.

üìñ Weiterf√ºhrend:

* React Docs: [Daten holen mit Effects](https://react.dev/learn/synchronizing-with-effects)
* MDN (RU): [Fetch API](https://developer.mozilla.org/ru/docs/Web/API/Fetch_API)
* MSW: [https://mswjs.io](https://mswjs.io)
* JSON Server: [https://github.com/typicode/json-server](https://github.com/typicode/json-server)
* MirageJS: [https://miragejs.com](https://miragejs.com)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

84. ### <a name="84"></a> Wie funktioniert Suspense f√ºr Datenabfragen?

### Suspense f√ºr Datenabfragen in React

**Suspense** ist ein React-Feature, das es erm√∂glicht, eine **Fallback-UI (z. B. Spinner)** anzuzeigen, solange Daten noch nicht geladen sind.
Anstatt den Ladezustand selbst mit `useState`/`useEffect` zu managen, ‚Äûwartet‚Äú React, bis ein Promise **resolved** ist, und zeigt in der Zwischenzeit den Fallback an.

---

### Grundprinzip

* Eine Komponente ‚Äûwirft‚Äú (`throw`) ein Promise w√§hrend des Renderns.
* React erkennt dies und zeigt den `fallback` aus `<Suspense>` an.
* Sobald das Promise resolved ist, rendert React die eigentliche UI.

---

### Einfaches Beispiel (Simulation)

```jsx
import { Suspense } from "react";

// Hilfsfunktion: "Ressource" mit read()
function fetchData() {
  let status = "pending";
  let result;
  const suspender = fetch("https://jsonplaceholder.typicode.com/users")
    .then(r => r.json())
    .then(
      res => {
        status = "success";
        result = res;
      },
      err => {
        status = "error";
        result = err;
      }
    );

  return {
    read() {
      if (status === "pending") throw suspender; // l√∂st Suspense aus
      if (status === "error") throw result;      // l√∂st Error Boundary aus
      return result;
    }
  };
}

const resource = fetchData();

function UserList() {
  const users = resource.read(); // wartet √ºber Suspense
  return (
    <ul>
      {users.map(u => <li key={u.id}>{u.name}</li>)}
    </ul>
  );
}

export default function App() {
  return (
    <Suspense fallback={<p>Lade Nutzer...</p>}>
      <UserList />
    </Suspense>
  );
}
```

---

### Typische moderne Nutzung

* React-Team empfiehlt **React Query**, **Relay** oder **Next.js (App Router)** ‚Üí diese Libraries integrieren Suspense.
* Suspense selbst liefert nur den **UI-Mechanismus** ‚Äì kein Fetch- oder Cache-System.

---

### Zusammenfassung

* **Suspense** zeigt Fallback-UI, solange Daten noch nicht geladen sind.
* Funktioniert, indem Komponenten w√§hrend des Renderns ein **Promise werfen**.
* F√ºr echte Projekte: in Kombination mit Libraries wie **React Query, Relay, Next.js**.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Suspense f√ºr Datenabfragen](https://react.dev/reference/react/Suspense#suspense-for-data-fetching)
* [React Docs ‚Äì Asynchronous Rendering](https://react.dev/learn/suspense)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

85. ### <a name="85"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

86. ### <a name="86"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

87. ### <a name="87"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

88. ### <a name="88"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

89. ### <a name="89"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

90. ### <a name="90"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

91. ### <a name="91"></a> Was ist Unit-, Integration- und E2E-Testing?

# Was ist Unit-, Integration- und E2E-Testing in der Webentwicklung?

Beim Testen von Anwendungen unterscheidet man drei zentrale Testarten:  
**Unit-Tests**, **Integrationstests** und **End-to-End-Tests (E2E)**.  
Sie pr√ºfen den Code auf verschiedenen Ebenen.

---

## ‚úÖ 1. Unit-Testing (Einheitentest)

**Testet eine einzelne Funktion oder Komponente isoliert.**

### Ziel:
- Pr√ºfen, ob eine **kleine logische Einheit** korrekt funktioniert

### Beispiel:

```jsx
// sum.js
export function sum(a, b) {
  return a + b;
}

// sum.test.js
import { sum } from './sum';

test('addiert zwei Zahlen korrekt', () => {
  expect(sum(2, 3)).toBe(5);
});
```

### Tools:
- **Jest**, **Vitest**, **Mocha**

---

## ‚úÖ 2. Integrationstests

**Testet das Zusammenspiel mehrerer Einheiten.**

### Ziel:
- Sicherstellen, dass **Komponenten oder Module korrekt interagieren**

### Beispiel:

```jsx
// LoginForm.js mit Input + Button + Handler
// Integrationstest pr√ºft, ob das Form korrekt absendet

import { render, screen, fireEvent } from '@testing-library/react';
import LoginForm from './LoginForm';

test('LoginForm ruft onSubmit mit richtigen Daten auf', () => {
  const handleSubmit = jest.fn();
  render(<LoginForm onSubmit={handleSubmit} />);

  fireEvent.change(screen.getByLabelText(/email/i), {
    target: { value: 'test@mail.com' },
  });
  fireEvent.click(screen.getByText(/einloggen/i));

  expect(handleSubmit).toHaveBeenCalledWith({
    email: 'test@mail.com',
  });
});
```

### Tools:
- **React Testing Library**, **Jest**

---

## ‚úÖ 3. E2E-Testing (End-to-End)

**Testet die gesamte App vom Nutzer aus betrachtet (UI + Backend).**

### Ziel:
- Simulieren, wie ein **echter Benutzer** mit der App interagiert
- Test umfasst: Browser, Klicks, Navigation, API, Server

### Beispiel:

```js
// login.spec.js mit Cypress

describe('Login Flow', () => {
  it('meldet sich erfolgreich an', () => {
    cy.visit('/login');
    cy.get('input[name="email"]').type('user@mail.com');
    cy.get('input[name="password"]').type('pass123');
    cy.get('button[type="submit"]').click();
    cy.contains('Willkommen, user@mail.com');
  });
});
```

### Tools:
- **Cypress**, **Playwright**, **TestCafe**

---

## üìä Vergleich

| Testtyp        | Umfang             | Geschwindigkeit | Stabilit√§t | Fehlerursache erkennbar |
|----------------|--------------------|------------------|------------|--------------------------|
| Unit-Test      | Sehr klein (1 Unit)| üü¢ Sehr schnell  | üü¢ Hoch     | üéØ Sehr pr√§zise          |
| Integration    | Mittelgro√ü         | üü° Mittel         | üü° Gut      | üéØ Meist klar            |
| E2E-Test       | Ganze App (UI/API) | üî¥ Langsam        | üî¥ Weniger stabil | ‚ö†Ô∏è Fehler schwerer zu debuggen |

---

## üìù Zusammenfassung

| Testart      | Was wird getestet?                            | Tools                    |
|--------------|-----------------------------------------------|--------------------------|
| Unit         | Einzelne Funktion oder Komponente             | Jest, Vitest             |
| Integration  | Zusammenspiel mehrerer Komponenten            | React Testing Library    |
| E2E          | Gesamter Ablauf aus Sicht des Benutzers       | Cypress, Playwright      |

---

## üîó Quellen

- [Jest ‚Äì Unit Testing](https://jestjs.io/docs/getting-started)  
- [React Testing Library](https://testing-library.com/docs/react-testing-library/intro/)  
- [Cypress E2E Testing](https://www.cypress.io)  
- [Playwright Testing](https://playwright.dev)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

92. ### <a name="92"></a> Was ist Snapshot-Testing?

# Was ist Snapshot-Testing in React?

**Snapshot-Testing** ist eine Testmethode, bei der die **Ausgabe einer Komponente** gespeichert  
und bei jedem Testlauf automatisch mit dem vorherigen **‚ÄûSnapshot‚Äú** verglichen wird.  
So erkennt man unbeabsichtigte √Ñnderungen in der UI.

---

## üéØ Ziel

- Sicherstellen, dass sich die gerenderte Ausgabe einer Komponente **nicht unerwartet ver√§ndert**
- Ideal f√ºr **pr√§sentationsorientierte Komponenten** (UI, Layout)

---

## üß™ Beispiel mit Jest

```jsx
// Hello.jsx
function Hello({ name }) {
  return <h1>Hallo, {name}!</h1>;
}

export default Hello;
```

```jsx
// Hello.test.js
import { render } from '@testing-library/react';
import Hello from './Hello';

test('erstellt einen Snapshot der Hello-Komponente', () => {
  const { asFragment } = render(<Hello name="Sergii" />);
  expect(asFragment()).toMatchSnapshot();
});
```

### ‚ûï Beim ersten Testlauf:

Es wird eine Datei erstellt:  
`__snapshots__/Hello.test.js.snap` mit dem HTML-Output:

```txt
<document-fragment>
  <h1>Hallo, Sergii!</h1>
</document-fragment>
```

### üîÅ Bei weiteren Testl√§ufen:

- Wenn sich der HTML-Output **√§ndert**, schl√§gt der Test fehl
- Man kann dann entscheiden:  
  - ‚úÖ ‚Äû√Ñnderung gewollt‚Äú ‚Üí `jest -u` zum **aktualisieren**  
  - ‚ùå ‚ÄûFehlerhaft‚Äú ‚Üí Komponente korrigieren

---

## üì¶ Vorteile

- Schnell und einfach f√ºr reine UI-Komponenten
- Automatisches Erkennen von √Ñnderungen

---

## ‚ö†Ô∏è Nachteile

- Snapshots k√∂nnen **zu gro√ü** und **unn√ºtz** werden, wenn man zu viele auf einmal testet
- √Ñnderungen im Output ‚â† tats√§chlicher Fehler

‚û°Ô∏è Nicht geeignet f√ºr **Logiktests** oder dynamische Inhalte

---

## üìù Zusammenfassung

- Snapshot-Tests vergleichen JSX-Output mit gespeicherten Referenzwerten
- Verwende `toMatchSnapshot()` z.‚ÄØB. mit **Jest** + **Testing Library**
- Nur sinnvoll f√ºr **statische, visuelle Komponenten**

---

## üîó Quellen

- [Jest ‚Äì Snapshot Testing](https://jestjs.io/docs/snapshot-testing)  
- [React Testing Library ‚Äì Snapshots](https://testing-library.com/docs/react-testing-library/api/#asfragment)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

93. ### <a name="93"></a> Welche Tools nutzt man f√ºr React-Tests (Jest, React Testing Library)?

# Welche Tools nutzt man f√ºr React-Tests?

In der React-Entwicklung sind die g√§ngigsten Test-Tools:

1. **Jest** ‚Äì Test-Runner + Assertion-Bibliothek  
2. **React Testing Library (RTL)** ‚Äì UI-Verhalten aus Nutzersicht testen  
3. Weitere: **Vitest**, **MSW**, **Cypress**, **Playwright**

---

## ‚úÖ 1. Jest

üõ† **Test-Runner**, **Mocking**, **Snapshot-Testing**, **Assertions**

```bash
npm install --save-dev jest
```

- L√§uft JavaScript-Tests (z.‚ÄØB. `.test.js`)
- Unterst√ºtzt `describe`, `test`, `expect`, `beforeEach` etc.
- Integriert gut mit Babel, TypeScript und React

### Beispiel:

```js
test('addiert zwei Zahlen', () => {
  expect(2 + 2).toBe(4);
});
```

üìò [Jest Docs](https://jestjs.io/docs/getting-started)

---

## ‚úÖ 2. React Testing Library (RTL)

üîç Testet **Komponentenverhalten aus Sicht des Nutzers**

```bash
npm install --save-dev @testing-library/react
```

- Zugriff auf UI via `getByText`, `getByRole`, `getByLabelText`
- Kein Zugriff auf Implementierungsdetails
- Gute Best Practices durch Design

### Beispiel:

```jsx
import { render, screen } from '@testing-library/react';
import Button from './Button';

test('zeigt Buttontext korrekt an', () => {
  render(<Button>Speichern</Button>);
  expect(screen.getByText('Speichern')).toBeInTheDocument();
});
```

üìò [React Testing Library Docs](https://testing-library.com/docs/react-testing-library/intro/)

---

## ‚úÖ 3. Vitest (Alternative zu Jest)

üöÄ Schneller Test-Runner f√ºr Vite-Projekte

```bash
npm install --save-dev vitest
```

- Kompatibel mit Jest-API
- Schneller durch native ESModules

üìò [Vitest Docs](https://vitest.dev)

---

## ‚úÖ 4. MSW (Mock Service Worker)

üß™ Simuliert echte API-Requests im Test oder Browser

```bash
npm install msw --save-dev
```

üìò [MSW Docs](https://mswjs.io)

---

## ‚úÖ 5. Cypress / Playwright

üß≠ F√ºr **End-to-End (E2E)**-Tests im echten Browser

- Simuliert Nutzerverhalten: klicken, tippen, navigieren
- Cypress zielt auf Entwicklerfreundlichkeit
- Playwright testet auch mehrere Browser

üìò [Cypress.io](https://www.cypress.io)  
üìò [Playwright.dev](https://playwright.dev)

---

## üìù Zusammenfassung

| Tool                   | Zweck                     | Beschreibung                              |
|------------------------|---------------------------|--------------------------------------------|
| **Jest**               | Unit + Snapshot Tests     | Test-Runner & Mocking                      |
| **React Testing Library** | Integration/Component | Testet aus Nutzersicht                     |
| **Vitest**             | Schnelle Alternative      | Besonders f√ºr Vite-Projekte                |
| **MSW**                | Mocking API               | Reale Netzwerkrequests simulieren         |
| **Cypress / Playwright** | E2E Testing             | UI-Tests im echten Browser                 |

---

## üîó Weitere Links

- [Testing in React ‚Äì Offizielle Doku](https://react.dev/learn/testing)  
- [Testing Library ‚Äì Guide](https://testing-library.com/docs/)  
- [Jest ‚Äì Snapshot Testing](https://jestjs.io/docs/snapshot-testing)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

94. ### <a name="94"></a> Wie testet man Komponenten, Props und Events?

# Wie testet man Komponenten, Props und Events in React?

Beim Testen von React-Komponenten geht es darum zu pr√ºfen, ob:

1. Die **Komponente korrekt rendert**
2. **Props richtig verwendet** werden
3. **Benutzerinteraktionen (Events)** korrekt funktionieren

Daf√ºr nutzt man typischerweise:

- **React Testing Library** (RTL)
- **Jest** als Test-Runner

---

## ‚úÖ 1. Komponente rendern und Inhalt testen

```jsx
import { render, screen } from '@testing-library/react';
import Greeting from './Greeting';

test('zeigt Begr√º√üung an', () => {
  render(<Greeting name="Sergii" />);
  expect(screen.getByText(/Hallo, Sergii/i)).toBeInTheDocument();
});
```

---

## ‚úÖ 2. Props testen

Du testest **indirekt**, ob Props korrekt verwendet wurden ‚Äì  
z.‚ÄØB. durch gerendeten Text oder Verhalten.

```jsx
function Title({ text }) {
  return <h1>{text}</h1>;
}

// Test
test('zeigt den Titel-Prop korrekt an', () => {
  render(<Title text="Dashboard" />);
  expect(screen.getByText('Dashboard')).toBeInTheDocument();
});
```

---

## ‚úÖ 3. Events testen (z.‚ÄØB. Button-Klick)

```jsx
function Button({ onClick }) {
  return <button onClick={onClick}>Klick mich</button>;
}

// Test
import userEvent from '@testing-library/user-event';

test('ruft onClick beim Klicken auf', async () => {
  const handleClick = jest.fn();
  render(<Button onClick={handleClick} />);

  await userEvent.click(screen.getByText('Klick mich'));
  expect(handleClick).toHaveBeenCalledTimes(1);
});
```

---

## üõ† Tools & Methoden (RTL)

| Methode                   | Beschreibung                                  |
|---------------------------|-----------------------------------------------|
| `render()`                | Rendert die Komponente f√ºr den Test           |
| `screen.getByText()`      | Findet Elemente am Bildschirm                 |
| `userEvent.click()`       | Simuliert Benutzeraktionen                    |
| `jest.fn()`               | Erstellt Mockfunktionen f√ºr Eventhandler      |
| `toBeInTheDocument()`     | Pr√ºft, ob ein Element im DOM enthalten ist    |

---

## üìù Zusammenfassung

| Was wird getestet?      | Wie?                            |
|-------------------------|---------------------------------|
| Komponenteninhalte      | `screen.getByText`, `render()`  |
| Props                   | Text oder Verhalten √ºberpr√ºfen  |
| Events (z.‚ÄØB. Klicks)   | `userEvent`, `jest.fn()`        |

---

## üîó Quellen

- [React Testing Library ‚Äì Intro](https://testing-library.com/docs/react-testing-library/intro/)  
- [Jest ‚Äì Mock Functions](https://jestjs.io/docs/mock-functions)  
- [React Docs ‚Äì Testing UI](https://react.dev/learn/testing)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

95. ### <a name="95"></a> Wie testet man benutzerdefinierte Hooks?

# Wie testet man benutzerdefinierte Hooks in React?

Benutzerdefinierte Hooks (`useXXX`) enthalten wiederverwendbare Logik.  
Um sie zu testen, verwendet man:

- ‚úÖ **`@testing-library/react-hooks`** (√§lter, eingestellt)  
- ‚úÖ **`@testing-library/react` + eigene Testkomponente**  
- ‚úÖ **`@testing-library/react-hooks/dom`** (aus `@tanstack/react-hooks-testing-library`)

> Der moderne Weg ist: **React-Hooks innerhalb eines Testkomponenten-Kontextes rendern**.

---

## üì¶ Beispiel: Eigener Hook

```jsx
// useCounter.js
import { useState } from 'react';

export function useCounter(initial = 0) {
  const [count, setCount] = useState(initial);
  const increment = () => setCount((c) => c + 1);
  return { count, increment };
}
```

---

## ‚úÖ Variante 1: Test mit Testkomponente (Standard mit RTL)

```jsx
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { useCounter } from './useCounter';

function TestComponent() {
  const { count, increment } = useCounter();
  return (
    <>
      <p>Count: {count}</p>
      <button onClick={increment}>+</button>
    </>
  );
}

test('useCounter erh√∂ht den Wert', async () => {
  render(<TestComponent />);
  const button = screen.getByText('+');

  await userEvent.click(button);
  expect(screen.getByText('Count: 1')).toBeInTheDocument();
});
```

---

## ‚úÖ Variante 2: `@testing-library/react-hooks` (wenn n√∂tig)

```bash
npm install --save-dev @testing-library/react-hooks
```

```jsx
import { renderHook, act } from '@testing-library/react-hooks';
import { useCounter } from './useCounter';

test('useCounter funktioniert korrekt', () => {
  const { result } = renderHook(() => useCounter(0));

  expect(result.current.count).toBe(0);

  act(() => {
    result.current.increment();
  });

  expect(result.current.count).toBe(1);
});
```

> ‚ö†Ô∏è Diese Variante wird **nicht mehr aktiv gepflegt**.

---

## üìù Zusammenfassung

| Methode                            | Vorteil                          |
|------------------------------------|----------------------------------|
| ‚úÖ Eigene Test-Komponente           | Kompatibel mit `@testing-library/react` |
| ‚ö†Ô∏è `@testing-library/react-hooks`   | F√ºr reine Hook-Tests (√§lter)     |

---

## üîó Quellen

- [React Testing Library ‚Äì Hooks testen](https://testing-library.com/docs/example-react-hooks)  
- [React-Hooks-Test-Bibliothek ‚Äì TanStack](https://github.com/TanStack/testing-react-hooks)  
- [React Docs ‚Äì eigene Hooks schreiben](https://react.dev/learn/reusing-logic-with-custom-hooks)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

96. ### <a name="96"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

97. ### <a name="97"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

98. ### <a name="98"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

99. ### <a name="99"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

100. ### <a name="100"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**    

101. ### <a name="101"></a> Wie funktioniert Routing in React mit react-router-dom?

# Wie funktioniert Routing in React mit `react-router-dom`?

`react-router-dom` ist die Standard-Bibliothek f√ºr **Client-seitiges Routing** in React.  
Sie erm√∂glicht die Navigation zwischen Seiten **ohne Neuladen** der Website.

---

## üì¶ Installation

```bash
npm install react-router-dom
```

---

## üß± Grundkonzepte

| Komponente          | Zweck                                          |
|---------------------|-------------------------------------------------|
| `<BrowserRouter>`   | Wurzel-Router, verwendet HTML5 History API     |
| `<Routes>`          | Container f√ºr alle Routen                      |
| `<Route>`           | Definiert eine einzelne Route                  |
| `<Link>`            | Navigation ohne Seiten-Reload                  |
| `useNavigate()`     | Programmatische Navigation                     |
| `useParams()`       | Zugriff auf URL-Parameter                      |

---

## ‚úÖ Beispiel: Basis-Routing

```jsx
import { BrowserRouter, Routes, Route, Link } from 'react-router-dom';

function Home() {
  return <h2>Startseite</h2>;
}

function About() {
  return <h2>√úber uns</h2>;
}

function App() {
  return (
    <BrowserRouter>
      <nav>
        <Link to="/">Start</Link> | <Link to="/about">√úber</Link>
      </nav>

      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
      </Routes>
    </BrowserRouter>
  );
}
```

---

## üìå Dynamische Routen mit Parametern

```jsx
// URL: /user/123

function UserPage() {
  const { id } = useParams();
  return <p>User ID: {id}</p>;
}

<Routes>
  <Route path="/user/:id" element={<UserPage />} />
</Routes>
```

---

## üöÄ Navigation per Code (z.‚ÄØB. nach Login)

```jsx
import { useNavigate } from 'react-router-dom';

function LoginButton() {
  const navigate = useNavigate();

  const handleLogin = () => {
    // ...Login-Logik
    navigate('/dashboard'); // Weiterleitung
  };

  return <button onClick={handleLogin}>Login</button>;
}
```

---

## üîÅ Weiterleitungen

```jsx
import { Navigate } from 'react-router-dom';

<Route path="/alt" element={<Navigate to="/neu" />} />
```

---

## üìù Zusammenfassung

- Routing wird mit `BrowserRouter`, `Routes` und `Route` umgesetzt
- Navigation per `<Link>` oder `useNavigate()`
- Dynamische Parameter via `:id` und `useParams()`
- Kein Seitenreload n√∂tig ‚Üí **Single Page Application (SPA)**

---

## üîó Quellen

- [React Router Doku](https://reactrouter.com/en/main/start/tutorial)  
- [MDN ‚Äì Client-Side Routing](https://developer.mozilla.org/en-US/docs/Glossary/SPA)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

102. ### <a name="102"></a> Was sind die Unterschiede zwischen react-router v5 und v6?

# Was sind die Unterschiede zwischen `react-router-dom` v5 und v6?

`react-router-dom` v6 ist eine **komplett √ºberarbeitete Version** mit  
neuem Syntax, klarerer Struktur und vereinfachter Logik.  
Hier sind die wichtigsten Unterschiede zwischen v5 und v6:

---

## üîÑ 1. `<Switch>` ‚Üí **`<Routes>`**

- **v5:** `<Switch>` rendert die erste passende Route  
- **v6:** `<Routes>` ersetzt `<Switch>` und **rendert nur genau eine Route**

```jsx
// v5
<Switch>
  <Route path="/about" component={About} />
</Switch>

// v6
<Routes>
  <Route path="/about" element={<About />} />
</Routes>
```

---

## ‚öõÔ∏è 2. `component` vs `element`

- **v5:** `component={MyComponent}`
- **v6:** `element={<MyComponent />}` (JSX wird erwartet)

```jsx
// v5
<Route path="/home" component={Home} />

// v6
<Route path="/home" element={<Home />} />
```

---

## üß≠ 3. `Redirect` ‚Üí **`<Navigate />`**

- **v5:** `<Redirect to="/login" />`
- **v6:** `<Navigate to="/login" />`

```jsx
// v6 Beispiel
<Route path="*" element={<Navigate to="/" />} />
```

---

## üß¨ 4. Verschachtelte Routen (Nested Routes)

- **v6** nutzt **nested `<Route>`** mit `outlet`-Konzept

```jsx
// v6
<Routes>
  <Route path="/dashboard" element={<Dashboard />}>
    <Route path="profile" element={<Profile />} />
    <Route path="settings" element={<Settings />} />
  </Route>
</Routes>
```

```jsx
// Dashboard.jsx
import { Outlet } from 'react-router-dom';
export default function Dashboard() {
  return (
    <div>
      <h1>Dashboard</h1>
      <Outlet />
    </div>
  );
}
```

---

## ‚ö†Ô∏è 5. `exact` ist **nicht mehr n√∂tig**

- **v6 matcht automatisch exakt**
- In v5 war `exact` notwendig, um √úberlappung zu vermeiden

```jsx
// v5
<Route exact path="/" component={Home} />

// v6
<Route path="/" element={<Home />} /> // exact implizit
```

---

## ‚úÖ 6. Neue Features in v6

| Feature                | Beschreibung                                    |
|------------------------|-------------------------------------------------|
| `<Outlet />`           | F√ºr Nested Routing                             |
| `useRoutes()`          | Routing mit Objekt-Definition                   |
| `createBrowserRouter`  | F√ºr Data-Routing mit `react-router v6.4+`       |
| `Loader`, `Action`     | Neue API f√ºr Datenladen direkt in Route-Objekten|

---

## üìù Zusammenfassung

| Unterschied         | v5                        | v6                             |
|---------------------|---------------------------|--------------------------------|
| Routencontainer     | `<Switch>`                | `<Routes>`                     |
| Komponenten         | `component`/`render`      | `element={<... />}`            |
| Weiterleitung       | `<Redirect>`              | `<Navigate>`                   |
| Nested Routes       | Manuell / kompliziert     | Mit `<Outlet>` einfach         |
| `exact`             | Manuell n√∂tig             | Automatisch exakt              |

---

## üîó Quellen

- [React Router v6 Doku](https://reactrouter.com/en/main)  
- [Migration von v5 zu v6](https://reactrouter.com/en/main/start/overview#migrating-from-v5)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

103. ### <a name="103"></a> Was sind Route, Link, Navigate, Outlet?

# Was sind `Route`, `Link`, `Navigate`, `Outlet` in React Router?

Diese Komponenten stammen aus **`react-router-dom`** und bilden das Grundger√ºst  
f√ºr Navigation, Seitenwechsel und Seitenstruktur in React-Anwendungen.

---

## üîÅ `Route`

Definiert, **welche Komponente bei welcher URL angezeigt wird**.

```jsx
<Route path="/about" element={<About />} />
```

- Wird innerhalb von `<Routes>` verwendet
- `path` = URL-Pfad
- `element` = JSX-Komponente, die gerendert wird

---

## üîó `Link`

Erstellt **einen Link**, der beim Klicken die URL **√§ndert**,  
ohne die Seite neu zu laden (SPA-Verhalten).

```jsx
<Link to="/about">√úber uns</Link>
```

- Vergleichbar mit `<a href="..." />`, aber **Client-seitig**
- Nutzt History API intern
- Vorteil: Schnelle Navigation ohne Reload

---

## üöÄ `Navigate`

Ersetzt `<Redirect>` (aus v5).  
Wird verwendet, um **programmatisch weiterzuleiten**.

```jsx
<Route path="*" element={<Navigate to="/" />} />
```

Oder innerhalb einer Komponente:

```jsx
if (!isLoggedIn) {
  return <Navigate to="/login" />;
}
```

- Automatische Weiterleitung (z.‚ÄØB. nach Login, Fehler, Logout)

---

## üß© `Outlet`

Wird verwendet, um **geschachtelte Routen** (Nested Routes) einzuf√ºgen.

```jsx
// App.jsx
<Routes>
  <Route path="/dashboard" element={<Dashboard />}>
    <Route path="profile" element={<Profile />} />
  </Route>
</Routes>
```

```jsx
// Dashboard.jsx
import { Outlet } from 'react-router-dom';

function Dashboard() {
  return (
    <div>
      <h1>Dashboard</h1>
      <Outlet /> {/* Hier erscheint <Profile /> */}
    </div>
  );
}
```

---

## üìù Zusammenfassung

| Element      | Funktion                                      |
|--------------|-----------------------------------------------|
| `Route`      | Definiert, welche Komponente bei welcher URL |
| `Link`       | Navigation per Klick ohne Seitenreload        |
| `Navigate`   | Programmgesteuerte Weiterleitung               |
| `Outlet`     | Platzhalter f√ºr verschachtelte Routen         |

---

## üîó Quellen

- [React Router ‚Äì Startseite](https://reactrouter.com/en/main/start/tutorial)  
- [React Router ‚Äì API Referenz](https://reactrouter.com/en/main/components/route)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

104. ### <a name="104"></a> Wie erstellt man Nested Routes?

# Wie erstellt man Nested Routes in React Router (v6)?

**Nested Routes** (geschachtelte Routen) erm√∂glichen es,  
eine **Hauptkomponente mit untergeordnetem Inhalt** anzuzeigen,  
z.‚ÄØB. ein Dashboard mit Tabs wie ‚ÄûProfil‚Äú, ‚ÄûEinstellungen‚Äú usw.

---

## üß± Grundprinzip

- Verwende `<Route>` innerhalb eines anderen `<Route>`
- Platziere `<Outlet />` dort, wo die **Kind-Komponenten** erscheinen sollen

---

## ‚úÖ Beispiel

### üîß Struktur

```
/dashboard
/dashboard/profile
/dashboard/settings
```

---

### 1Ô∏è‚É£ Routen in `App.jsx`

```jsx
import { BrowserRouter, Routes, Route } from 'react-router-dom';
import Dashboard from './pages/Dashboard';
import Profile from './pages/Profile';
import Settings from './pages/Settings';

function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/dashboard" element={<Dashboard />}>
          <Route path="profile" element={<Profile />} />
          <Route path="settings" element={<Settings />} />
        </Route>
      </Routes>
    </BrowserRouter>
  );
}
```

---

### 2Ô∏è‚É£ `Dashboard.jsx` ‚Äì mit `<Outlet />`

```jsx
import { Outlet, Link } from 'react-router-dom';

function Dashboard() {
  return (
    <div>
      <h1>Dashboard</h1>
      <nav>
        <Link to="profile">Profil</Link> |{' '}
        <Link to="settings">Einstellungen</Link>
      </nav>
      <hr />
      <Outlet /> {/* ‚Üê hier erscheinen verschachtelte Komponenten */}
    </div>
  );
}

export default Dashboard;
```

---

### 3Ô∏è‚É£ Profile.jsx / Settings.jsx

```jsx
function Profile() {
  return <p>üë§ Benutzerprofil</p>;
}

function Settings() {
  return <p>‚öôÔ∏è Einstellungen</p>;
}
```

---

## üìù Zusammenfassung

| Schritt       | Was passiert?                             |
|---------------|--------------------------------------------|
| `Route`-Verschachtelung | Unterseiten innerhalb eines Hauptlayouts |
| `<Outlet />`   | Platzhalter f√ºr die aktive Kind-Komponente  |
| `Link`         | Navigation innerhalb der Unterrouten        |

---

## üîó Quellen

- [React Router ‚Äì Nested Routes](https://reactrouter.com/en/main/start/tutorial#nested-routes)  
- [React Docs ‚Äì Routing](https://react.dev/learn/start-a-new-react-project#routing)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

105. ### <a name="105"></a> Wie implementiert man Redirects?

# Wie implementiert man Redirects in React Router v6?

Ein **Redirect** (Weiterleitung) bedeutet, dass ein Benutzer  
automatisch von einer Route zu einer anderen Route umgeleitet wird.

In **React Router v6** nutzt man daf√ºr die Komponente **`<Navigate />`**.

---

## ‚úÖ 1. Statischer Redirect √ºber Route

```jsx
import { Routes, Route, Navigate } from 'react-router-dom';

function App() {
  return (
    <Routes>
      <Route path="/" element={<Home />} />
      <Route path="/start" element={<Navigate to="/" />} />
    </Routes>
  );
}
```

üìå `/start` ‚Üí `/` automatisch weitergeleitet

---

## ‚úÖ 2. Wildcard-Redirect (404-Fallback)

```jsx
<Route path="*" element={<Navigate to="/" />} />
```

üìå Alle unbekannten Pfade leiten zur Startseite um

---

## ‚úÖ 3. Programmgesteuerter Redirect (z.‚ÄØB. nach Login)

```jsx
import { useNavigate } from 'react-router-dom';

function LoginForm() {
  const navigate = useNavigate();

  function handleLogin() {
    // ...Login-Logik
    navigate('/dashboard'); // Weiterleitung nach Login
  }

  return <button onClick={handleLogin}>Login</button>;
}
```

---

## üîÑ 4. Bedingter Redirect

```jsx
function ProtectedPage({ isLoggedIn }) {
  if (!isLoggedIn) {
    return <Navigate to="/login" replace />;
  }

  return <p>Willkommen im gesch√ºtzten Bereich</p>;
}
```

- `replace` verhindert, dass die Weiterleitung in den Verlauf kommt (`history.back` geht nicht zur√ºck)

---

## üìù Zusammenfassung

| Typ                          | Methode                      |
|------------------------------|-------------------------------|
| Statische Weiterleitung      | `<Route path="..." element={<Navigate to="..." />} />` |
| Fallback (404)               | `<Route path="*" element={<Navigate to="/" />} />` |
| Logikbasiert (z.‚ÄØB. Login)   | `useNavigate()` Hook         |
| Bedingt in Komponente        | `{ isLoggedIn ? ... : <Navigate /> }` |

---

## üîó Quellen

- [React Router ‚Äì `<Navigate />`](https://reactrouter.com/en/main/components/navigate)  
- [React Router ‚Äì useNavigate Hook](https://reactrouter.com/en/main/hooks/use-navigate)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

106. ### <a name="106"></a> Wie funktioniert programmgesteuerte Navigation (useNavigate)?

# Wie funktioniert programmgesteuerte Navigation mit `useNavigate`?

Mit dem **Hook `useNavigate()`** aus `react-router-dom` kannst du  
**per Code** (statt durch Klick auf einen Link) zwischen Routen navigieren.

---

## ‚úÖ Verwendung

```jsx
import { useNavigate } from 'react-router-dom';

function LoginButton() {
  const navigate = useNavigate();

  const handleLogin = () => {
    // ‚úÖ Login-Logik
    // üîÑ Navigation nach erfolgreichem Login
    navigate('/dashboard');
  };

  return <button onClick={handleLogin}>Login</button>;
}
```

---

## üìå Optionen

```js
navigate('/ziel', {
  replace: true,   // ersetzt aktuellen Eintrag im Verlauf (kein Zur√ºck m√∂glich)
  state: { userId: 123 }, // optionaler Zustand, √ºber `location.state` abrufbar
});
```

---

## üì• Weitergabe von State

```jsx
navigate('/profile', { state: { userName: 'Sergii' } });
```

```jsx
// Ziel-Komponente
import { useLocation } from 'react-router-dom';

const location = useLocation();
console.log(location.state.userName); // "Sergii"
```

---

## üîÅ Dynamische Navigation mit Parametern

```jsx
navigate(`/user/${userId}`);
```

---

## üìù Zusammenfassung

| Funktion             | Beschreibung                         |
|----------------------|--------------------------------------|
| `useNavigate()`      | Hook zum Navigieren per Code         |
| `navigate('/pfad')`  | Navigation zur Zielroute             |
| `replace: true`      | Ersetzt History-Eintrag (kein Zur√ºck)|
| `state: {...}`       | √úbergibt Daten an Zielkomponente     |

---

## üîó Quellen

- [React Router ‚Äì useNavigate](https://reactrouter.com/en/main/hooks/use-navigate)  
- [React Router ‚Äì useLocation](https://reactrouter.com/en/main/hooks/use-location)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

107. ### <a name="107"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

108. ### <a name="108"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

109. ### <a name="109"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

110. ### <a name="110"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

111. ### <a name="111"></a> Was ist Redux und wie funktioniert es?

# Was ist Redux und wie funktioniert es?

**Redux** ist eine **State-Management-Bibliothek**,  
die hilft, **globalen Zustand zentral** zu verwalten ‚Äì besonders in gr√∂√üeren React-Apps.  
Sie basiert auf einem **Single Source of Truth** (ein globales Store-Objekt)  
und nutzt ein **unidirektionales Datenflussmodell**.

---

## üéØ Wann ist Redux n√ºtzlich?

- Viele Komponenten m√ºssen denselben Zustand verwenden oder ver√§ndern
- Du willst Zustand **vorhersagbar, nachvollziehbar und testbar** halten
- Du brauchst eine **klare Trennung von Logik und UI**

---

## üß† Grundkonzepte

| Begriff        | Beschreibung                                                                 |
|----------------|-------------------------------------------------------------------------------|
| `Store`        | Zentrale Datenquelle (globaler Zustand)                                      |
| `Action`       | Ein einfaches Objekt, das **beschreibt, was passieren soll**                 |
| `Reducer`      | Eine reine Funktion, die **neuen Zustand basierend auf Action erstellt**     |
| `Dispatch()`   | Methode, um eine Action an den Store zu senden                               |
| `Selector`     | Liest bestimmte Teile des States aus                                         |

---

## ‚öôÔ∏è Beispiel: Z√§hler mit Redux Toolkit

### üîß Setup

```bash
npm install @reduxjs/toolkit react-redux
```

---

### 1Ô∏è‚É£ Store & Reducer

```js
// store.js
import { configureStore, createSlice } from '@reduxjs/toolkit';

const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 },
  reducers: {
    increment(state) {
      state.value += 1;
    },
    decrement(state) {
      state.value -= 1;
    },
  },
});

export const { increment, decrement } = counterSlice.actions;

export const store = configureStore({
  reducer: { counter: counterSlice.reducer },
});
```

---

### 2Ô∏è‚É£ Bereitstellen des Stores

```jsx
// main.jsx
import { Provider } from 'react-redux';
import { store } from './store';
import App from './App';

<Provider store={store}>
  <App />
</Provider>
```

---

### 3Ô∏è‚É£ Verwenden in einer Komponente

```jsx
// Counter.jsx
import { useSelector, useDispatch } from 'react-redux';
import { increment, decrement } from './store';

function Counter() {
  const count = useSelector((state) => state.counter.value);
  const dispatch = useDispatch();

  return (
    <div>
      <p>Z√§hler: {count}</p>
      <button onClick={() => dispatch(increment())}>+</button>
      <button onClick={() => dispatch(decrement())}>‚Äì</button>
    </div>
  );
}
```

---

## üîÅ Datenfluss

```text
UI ‚Üí dispatch(action) ‚Üí reducer ‚Üí neuer state ‚Üí UI-Update
```

---

## üìù Zusammenfassung

| Begriff       | Funktion                              |
|---------------|----------------------------------------|
| `Store`       | Zentrale Datenhaltung                  |
| `Action`      | Ereignisbeschreibung                   |
| `Reducer`     | Ver√§ndert Zustand basierend auf Action |
| `dispatch()`  | Sendet Action an Reducer               |
| `useSelector` | Liest Daten aus dem Store              |
| `useDispatch` | Ruft Aktionen auf                      |

---

## üîó Quellen

- [Redux Toolkit ‚Äì Offizielle Doku](https://redux-toolkit.js.org)  
- [React Redux ‚Äì Einstieg](https://react-redux.js.org/introduction/getting-started)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

112. ### <a name="112"></a> Was sind Actions, Reducer und Store?

# Was sind Actions, Reducer und Store in Redux?

Diese drei Konzepte bilden das **Herzst√ºck von Redux**.  
Sie sorgen f√ºr einen **vorhersagbaren Datenfluss** und eine **klare Trennung der Logik**.

---

## üü© 1. **Store**

Der **Store** ist die **zentrale Datenquelle** deiner Anwendung.  
Er enth√§lt den **globalen Zustand** (State) und stellt Methoden bereit, um:

- den Zustand zu lesen (`getState`)
- √Ñnderungen auszul√∂sen (`dispatch`)
- auf √Ñnderungen zu reagieren (`subscribe`)

### Beispiel:

```js
import { configureStore } from '@reduxjs/toolkit';
import counterReducer from './counterSlice';

const store = configureStore({
  reducer: {
    counter: counterReducer,
  },
});
```

---

## üü® 2. **Action**

Eine **Action** ist ein **JavaScript-Objekt**, das beschreibt, **was passiert ist**.  
Sie hat mindestens ein `type`-Feld.

### Beispiel:

```js
const incrementAction = { type: 'counter/increment' };
```

Mit Redux Toolkit:

```js
dispatch(increment()); // automatisch erzeugte Action
```

---

## üü• 3. **Reducer**

Ein **Reducer** ist eine **reine Funktion**, die den neuen Zustand berechnet  
auf Basis des aktuellen Zustands + Action.

### Beispiel (klassisch):

```js
function counterReducer(state = { value: 0 }, action) {
  switch (action.type) {
    case 'counter/increment':
      return { value: state.value + 1 };
    default:
      return state;
  }
}
```

### Beispiel mit Redux Toolkit:

```js
const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 },
  reducers: {
    increment(state) {
      state.value += 1; // dank Immer.js erlaubt
    },
  },
});
```

---

## üîÅ Zusammenwirken der drei

```text
UI ‚Üí dispatch(Action) ‚Üí Reducer ‚Üí Neuer State ‚Üí Store ‚Üí UI-Update
```

---

## üìù Zusammenfassung

| Begriff     | Funktion                                      |
|-------------|-----------------------------------------------|
| **Store**   | H√§lt den globalen Zustand                     |
| **Action**  | Beschreibt, was passiert ist (`{ type: ... }`)|
| **Reducer** | Erzeugt neuen Zustand basierend auf Action    |

---

## üîó Quellen

- [Redux Grundlagen (offiziell)](https://redux.js.org/tutorials/fundamentals/part-3-state-actions-reducers)  
- [Redux Toolkit Docs](https://redux-toolkit.js.org/introduction/getting-started)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

113. ### <a name="113"></a> Wie funktioniert Redux Toolkit (createSlice, configureStore, createAsyncThunk)?

# Wie funktioniert Redux Toolkit (`createSlice`, `configureStore`, `createAsyncThunk`)?

**Redux Toolkit** ist die offizielle, empfohlene Methode zum Schreiben von Redux-Code.  
Es reduziert Boilerplate-Code und bietet moderne, einfache APIs f√ºr `Store`, `Reducer`, `Async-Logik`.

---

## üì¶ Installation

```bash
npm install @reduxjs/toolkit react-redux
```

---

## üîß 1. `createSlice` ‚Äì Reducer + Actions in einem

```js
import { createSlice } from '@reduxjs/toolkit';

const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 },
  reducers: {
    increment(state) {
      state.value += 1;
    },
    decrement(state) {
      state.value -= 1;
    },
  },
});

export const { increment, decrement } = counterSlice.actions;
export default counterSlice.reducer;
```

‚úÖ Vorteile:
- automatische Action-Erstellung (`increment`, `decrement`)
- automatische Action-Typen (`counter/increment`)

---

## üè™ 2. `configureStore` ‚Äì Store erstellen

```js
import { configureStore } from '@reduxjs/toolkit';
import counterReducer from './counterSlice';

export const store = configureStore({
  reducer: {
    counter: counterReducer,
  },
});
```

- akzeptiert ein **Reducer-Objekt**
- aktiviert automatisch Redux DevTools & Middleware

---

## üîÅ 3. `createAsyncThunk` ‚Äì Asynchrone Logik wie API-Fetch

```js
import { createAsyncThunk } from '@reduxjs/toolkit';

export const fetchUsers = createAsyncThunk(
  'users/fetchUsers',
  async () => {
    const response = await fetch('https://jsonplaceholder.typicode.com/users');
    return await response.json();
  }
);
```

‚û° Wird automatisch in `pending`, `fulfilled`, `rejected` unterteilt.

---

### In Kombination mit `extraReducers`:

```js
const usersSlice = createSlice({
  name: 'users',
  initialState: { list: [], loading: false },
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchUsers.pending, (state) => {
        state.loading = true;
      })
      .addCase(fetchUsers.fulfilled, (state, action) => {
        state.loading = false;
        state.list = action.payload;
      })
      .addCase(fetchUsers.rejected, (state) => {
        state.loading = false;
      });
  },
});
```

---

## üß† Verwendung im React-Komponenten

```jsx
import { useSelector, useDispatch } from 'react-redux';
import { increment } from './counterSlice';

function Counter() {
  const value = useSelector((state) => state.counter.value);
  const dispatch = useDispatch();

  return (
    <>
      <p>Z√§hler: {value}</p>
      <button onClick={() => dispatch(increment())}>+</button>
    </>
  );
}
```

---

## üìù Zusammenfassung

| Funktion              | Aufgabe                                  |
|-----------------------|-------------------------------------------|
| `createSlice`         | erstellt Reducer + Actions automatisch    |
| `configureStore`      | erzeugt den Store + Middleware             |
| `createAsyncThunk`    | einfache Handhabung asynchroner Logik     |
| `extraReducers`       | Reaktion auf externe Actions (z.‚ÄØB. Thunks) |

---

## üîó Quellen

- [Redux Toolkit ‚Äì Einstieg](https://redux-toolkit.js.org/introduction/getting-started)  
- [createSlice Doku](https://redux-toolkit.js.org/api/createSlice)  
- [createAsyncThunk Doku](https://redux-toolkit.js.org/api/createAsyncThunk)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

114. ### <a name="114"></a> Was ist RTK Query?

# Was ist RTK Query?

**RTK Query** ist eine leistungsstarke Erweiterung von Redux Toolkit,  
die **API-Daten abrufen, cachen, synchronisieren und verwalten** kann ‚Äì  
ohne manuell Thunks, Reducer oder Actions zu schreiben.

‚úÖ **Ziel**: API-Zugriff mit minimalem Code, integriert in den Redux Store.

---

## üéØ Vorteile

- üöÄ Automatisches Caching, Refetching, Invalidierung
- üßº Weniger Boilerplate als `createAsyncThunk`
- üîÑ Automatische Lade- und Fehlerzust√§nde (`isLoading`, `error`, etc.)
- üß† Integriert sich direkt in den Redux-Store

---

## üì¶ Installation

```bash
npm install @reduxjs/toolkit react-redux
```

---

## ‚úÖ Beispiel: API-Daten mit RTK Query laden

### 1Ô∏è‚É£ API-Slice erstellen

```js
// services/api.js
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';

export const api = createApi({
  reducerPath: 'api', // automatisch im Store
  baseQuery: fetchBaseQuery({ baseUrl: 'https://jsonplaceholder.typicode.com/' }),
  endpoints: (builder) => ({
    getUsers: builder.query({
      query: () => 'users',
    }),
  }),
});

export const { useGetUsersQuery } = api;
```

---

### 2Ô∏è‚É£ Store konfigurieren

```js
// store.js
import { configureStore } from '@reduxjs/toolkit';
import { api } from './services/api';

export const store = configureStore({
  reducer: {
    [api.reducerPath]: api.reducer,
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(api.middleware),
});
```

---

### 3Ô∏è‚É£ Verwendung in einer Komponente

```jsx
import { useGetUsersQuery } from './services/api';

function UserList() {
  const { data: users, error, isLoading } = useGetUsersQuery();

  if (isLoading) return <p>L√§dt...</p>;
  if (error) return <p>Fehler beim Laden</p>;

  return (
    <ul>
      {users.map((u) => (
        <li key={u.id}>{u.name}</li>
      ))}
    </ul>
  );
}
```

---

## üß† Caching & Refetching

- RTK Query cached Daten automatisch
- Man kann Daten **invalidieren**, **refetchen**, **polling** aktivieren usw.

```js
getUsers: builder.query({
  query: () => 'users',
  keepUnusedDataFor: 60, // Sekunden
});
```

---

## üìù Zusammenfassung

| Feature             | Beschreibung                                         |
|---------------------|------------------------------------------------------|
| `createApi`         | Erstellt API-Slice                                   |
| `fetchBaseQuery`    | Basiert auf `fetch()`                                |
| `useXYZQuery()`     | Auto-generierter React-Hook                          |
| `api.middleware`    | Automatische Integration in Redux-Middleware         |
| Vorteile            | Weniger Code, Caching, Refetching, isLoading, error |

---

## üîó Quellen

- [RTK Query ‚Äì Offizielle Docs](https://redux-toolkit.js.org/rtk-query/overview)  
- [API Service mit RTK Query](https://redux-toolkit.js.org/rtk-query/usage)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

115. ### <a name="115"></a> Was ist der Unterschied zwischen Redux und der Context-API?

# Was ist der Unterschied zwischen Redux und der Context-API?

Sowohl **Redux** als auch die **React Context-API** erm√∂glichen es,  
**globalen Zustand** in einer Anwendung zu teilen.  
Aber sie unterscheiden sich in **Funktion**, **Skalierbarkeit** und **Zweck**.

---

## üîç Vergleich Redux vs Context-API

| Kriterium               | **Redux**                                     | **Context-API**                             |
|-------------------------|-----------------------------------------------|---------------------------------------------|
| üì¶ Zweck                | Globales **State-Management mit Logik**       | **Einfaches Teilen** von Daten              |
| üß† Zustand              | komplexer, strukturiert (Slices, Reducer)     | einfacher Zustand (z.‚ÄØB. useState)          |
| ‚öô Middleware            | Ja (z.‚ÄØB. Logging, Async mit Thunks)          | Nein                                        |
| üîÅ Updates              | selektiv durch `useSelector`                  | **Alle** Children werden neu gerendert      |
| üöÄ Performance          | effizient durch Trennung von Logik & UI       | kann bei gro√üen Apps Performance-Probleme bringen |
| üß∞ Tooling              | Redux DevTools, RTK, RTK Query                | Keine integrierten Tools                    |
| üìö Boilerplate          | mehr (aber reduziert durch RTK)               | sehr wenig                                  |
| üîÑ Asynchronit√§t        | `createAsyncThunk`, Middleware                 | manuell √ºber Hooks                          |
| üë®‚Äçüë©‚Äçüëß‚Äçüë¶ Zielgruppe        | mittlere bis gro√üe Anwendungen                | kleine bis mittlere Komponentenkommunikation |

---

## üìå Wann Context-API verwenden?

- Themen wie: **Theme, Sprache, Auth-Status**
- Wenn **wenige Werte** in **vielen Komponenten** gebraucht werden
- **Kein komplexes State-Handling** n√∂tig

---

## üìå Wann Redux verwenden?

- **Viele voneinander abh√§ngige Komponenten**
- Komplexe Logik: **API-Calls, Caching, Optimierung**
- Zustandslogik soll **testbar, strukturiert und erweiterbar** sein
- Zusammenarbeit im Team / skalierbare App

---

## üìù Zusammenfassung

| React Context            | Gut f√ºr **einfache Datenweitergabe** in der App  
| Redux (+RTK)             | Ideal f√ºr **komplexes, strukturiertes State-Management**

> Die Context-API ist **kein Ersatz**, sondern eine **Alternative f√ºr bestimmte F√§lle**.

---

## üîó Quellen

- [React Docs ‚Äì Context API](https://react.dev/learn/passing-data-deeply-with-context)  
- [Redux Toolkit Docs](https://redux-toolkit.js.org)  
- [Vergleich Redux vs Context (Blog)](https://kentcdodds.com/blog/application-state-management-with-react)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

116. ### <a name="116"></a> Was ist connect() in Redux?

# Was ist `connect()` in Redux?

`connect()` ist eine **h√∂herwertige Funktion (Higher-Order Component)**  
aus der Bibliothek **`react-redux`**, die verwendet wurde,  
um **Klassen- oder Funktionskomponenten** mit dem Redux-Store zu verbinden  
(vor Hooks wie `useSelector`, `useDispatch`).

---

## üìå Zweck von `connect()`

- Zugriff auf den globalen Redux-State
- Dispatchen von Actions aus der Komponente
- Verbindung von **React-Komponenten mit dem Redux-Store**

---

## ‚úÖ Syntax

```js
connect(mapStateToProps, mapDispatchToProps)(Component)
```

| Argument              | Bedeutung                                                 |
|------------------------|------------------------------------------------------------|
| `mapStateToProps`      | Welche Teile des States als Props in die Komponente kommen |
| `mapDispatchToProps`   | Welche Actions als Props verf√ºgbar gemacht werden sollen   |

---

## üß± Beispiel

### 1Ô∏è‚É£ Redux: Actions & Reducer

```js
// counterSlice.js (klassisch ohne Toolkit)
const initialState = { value: 0 };

export function counterReducer(state = initialState, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { value: state.value + 1 };
    default:
      return state;
  }
}

export const increment = () => ({ type: 'INCREMENT' });
```

---

### 2Ô∏è‚É£ Komponente mit `connect()`

```jsx
import React from 'react';
import { connect } from 'react-redux';
import { increment } from './counterSlice';

function Counter({ value, increment }) {
  return (
    <div>
      <p>Wert: {value}</p>
      <button onClick={increment}>+</button>
    </div>
  );
}

const mapStateToProps = (state) => ({
  value: state.counter.value,
});

export default connect(mapStateToProps, { increment })(Counter);
```

---

## üö´ Heute: lieber Hooks verwenden

Statt `connect()` ‚Üí moderner Ansatz:

```jsx
import { useSelector, useDispatch } from 'react-redux';

function Counter() {
  const value = useSelector((state) => state.counter.value);
  const dispatch = useDispatch();

  return <button onClick={() => dispatch({ type: 'INCREMENT' })}>+</button>;
}
```

---

## üìù Zusammenfassung

| `connect()`                   | Alte Methode zur Verbindung mit Redux-Store (HOC)       |
|------------------------------|----------------------------------------------------------|
| `mapStateToProps`            | W√§hlt Teile des States aus                              |
| `mapDispatchToProps`         | Bindet Action Creators an Props                         |
| ‚ùó Empfehlung heute           | Lieber `useSelector`, `useDispatch` (funktionale Hooks) |

---

## üîó Quellen

- [react-redux ‚Äì `connect()` Doku](https://react-redux.js.org/api/connect)  
- [React Redux ‚Äì Hooks vs connect](https://react-redux.js.org/api/hooks)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

117. ### <a name="117"></a> Was sind Middleware in Redux (z. B. redux-thunk, redux-logger)?

# Was sind Middleware in Redux (z.‚ÄØB. `redux-thunk`, `redux-logger`)?

**Middleware** in Redux sind **Funktionen**, die sich **zwischen `dispatch()` und dem Reducer** schalten.  
Sie erm√∂glichen erweiterte Funktionen wie:

- asynchrone Aktionen (z.‚ÄØB. API-Calls)
- Logging
- Caching
- Fehlerbehandlung

---

## üîß Wie funktioniert Middleware?

```text
dispatch(action) ‚Üí middleware ‚Üí reducer ‚Üí new state
```

Middleware haben Zugriff auf:

- `dispatch`
- `getState`
- `next` (weiterf√ºhrender Aufruf)
- `action`

---

## ‚úÖ Beispiel: Eigene Middleware

```js
const loggerMiddleware = (store) => (next) => (action) => {
  console.log('Action:', action);
  const result = next(action); // zum n√§chsten Middleware/Reducer
  console.log('Neuer State:', store.getState());
  return result;
};
```

---

## üß∞ G√§ngige Middleware

### 1Ô∏è‚É£ `redux-thunk`

Erm√∂glicht es, **Funktionen statt Objekte** zu dispatchen (f√ºr Async-Logik).

```bash
npm install redux-thunk
```

```js
const fetchData = () => async (dispatch) => {
  dispatch({ type: 'FETCH_START' });
  const res = await fetch('/api');
  const data = await res.json();
  dispatch({ type: 'FETCH_SUCCESS', payload: data });
};
```

> Wird automatisch von **Redux Toolkit** mitgeliefert

---

### 2Ô∏è‚É£ `redux-logger`

Protokolliert alle Aktionen und State-√Ñnderungen in der Konsole (Debugging).

```bash
npm install redux-logger
```

```js
import logger from 'redux-logger';

const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(logger),
});
```

---

### 3Ô∏è‚É£ Eigene Middleware integrieren

```js
const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(myMiddleware),
});
```

---

## üìù Zusammenfassung

| Middleware       | Zweck                                    |
|------------------|-------------------------------------------|
| `redux-thunk`    | Asynchrone Logik (API, Delay, etc.)       |
| `redux-logger`   | Logging von Aktionen & Zust√§nden          |
| Eigene Middleware| Erweiterung von Dispatch-Logik            |

> Middleware = **flexible Erweiterung** der Redux-Funktionalit√§t.

---

## üîó Quellen

- [Redux ‚Äì Middleware Doku](https://redux.js.org/tutorials/fundamentals/part-4-store#middleware)  
- [redux-logger auf GitHub](https://github.com/LogRocket/redux-logger)  
- [redux-thunk ‚Äì GitHub](https://github.com/reduxjs/redux-thunk)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

118. ### <a name="118"></a> Was ist createSelector und wie funktioniert Reselect?

# Was ist `createSelector` und wie funktioniert `reselect`?

**`reselect`** ist eine Bibliothek f√ºr **selektives, memoisiertes Selektieren von Zustand** in Redux.  
Das zentrale Feature ist **`createSelector()`**, mit dem du komplexe Ableitungen aus dem Store berechnen kannst ‚Äì  
**nur wenn sich relevante Teile des Zustands ge√§ndert haben**.

---

## üéØ Ziel

- Performance optimieren
- unn√∂tige Berechnungen und Re-Renders vermeiden
- komplexe Daten aus Store ableiten (z.‚ÄØB. Filter, Map, Reduce)

---

## üîß Installation

```bash
npm install reselect
```

---

## ‚úÖ Einfaches Beispiel mit `createSelector`

```js
import { createSelector } from 'reselect';

// Basis-Selector: roher Zugriff auf State
const selectTodos = (state) => state.todos;

// Memoisierter Selector: nur wenn todos sich √§ndern
export const selectCompletedTodos = createSelector(
  [selectTodos],
  (todos) => todos.filter((todo) => todo.completed)
);
```

üìå `selectCompletedTodos(state)` gibt **nur neue Werte zur√ºck**,  
wenn sich die urspr√ºnglichen `todos` ver√§ndert haben.

---

## üß† Beispiel im Redux Toolkit Setup

```js
// store.js
const initialState = {
  todos: [
    { id: 1, text: 'Lernen', completed: true },
    { id: 2, text: 'Coden', completed: false },
  ],
};

// selectors.js
import { createSelector } from 'reselect';

const selectTodos = (state) => state.todos;

export const selectIncompleteTodos = createSelector(
  [selectTodos],
  (todos) => todos.filter((t) => !t.completed)
);
```

---

## üß™ Verwendung im Component

```jsx
import { useSelector } from 'react-redux';
import { selectIncompleteTodos } from './selectors';

function TodoList() {
  const todos = useSelector(selectIncompleteTodos);

  return (
    <ul>
      {todos.map((t) => (
        <li key={t.id}>{t.text}</li>
      ))}
    </ul>
  );
}
```

---

## üìå Vorteile von `createSelector`

- **Memoisierung**: Caches das Ergebnis bis sich Input-Selektoren √§ndern
- **Komposition**: Selektoren k√∂nnen andere Selektoren nutzen
- **Performance**: Weniger Re-Render und Berechnungen

---

## üìù Zusammenfassung

| Begriff           | Beschreibung                                              |
|-------------------|-----------------------------------------------------------|
| `createSelector`  | Memoisierter Selektor f√ºr abgeleiteten Zustand            |
| `reselect`        | Bibliothek f√ºr performantes Selektieren aus dem Redux-Store |
| Vorteile          | Wiederverwendbar, performant, selektiv                    |

---

## üîó Quellen

- [Reselect ‚Äì GitHub](https://github.com/reduxjs/reselect)  
- [Redux Docs: Computing Derived Data](https://redux.js.org/usage/deriving-data-selectors)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

119. ### <a name="119"></a> Wie verbindet man Redux mit React √ºber Hooks (useSelector, useDispatch)?

# Wie verbindet man Redux mit React √ºber Hooks (`useSelector`, `useDispatch`)?

Statt der alten `connect()`-Funktion nutzt man in modernen React-Apps  
die **React-Redux Hooks** `useSelector` und `useDispatch`,  
um Komponenten einfach mit dem Redux-Store zu verbinden.

---

## üß† `useSelector`

Wird verwendet, um **Daten aus dem Redux-Store** auszulesen.

```jsx
import { useSelector } from 'react-redux';

const count = useSelector((state) => state.counter.value);
```

- Zugriff auf beliebige Teile des States
- Automatisch neu gerendert bei √Ñnderung

---

## ‚öôÔ∏è `useDispatch`

Gibt die `dispatch`-Funktion zur√ºck, um **Actions zu senden**.

```jsx
import { useDispatch } from 'react-redux';
import { increment } from './counterSlice';

const dispatch = useDispatch();
dispatch(increment());
```

- Ideal in Event-Handlern (`onClick`, `onSubmit`, etc.)

---

## ‚úÖ Beispiel: Counter-Komponente

```jsx
import { useSelector, useDispatch } from 'react-redux';
import { increment, decrement } from './counterSlice';

function Counter() {
  const count = useSelector((state) => state.counter.value);
  const dispatch = useDispatch();

  return (
    <div>
      <p>Wert: {count}</p>
      <button onClick={() => dispatch(increment())}>+</button>
      <button onClick={() => dispatch(decrement())}>‚Äì</button>
    </div>
  );
}
```

---

## üîÑ Vergleich: `connect()` vs Hooks

| Alt (connect)                     | Modern (Hooks)              |
|----------------------------------|-----------------------------|
| `mapStateToProps()`              | `useSelector()`             |
| `mapDispatchToProps()`           | `useDispatch()`             |
| Mehr Boilerplate                 | Weniger Code, klarer Stil   |

---

## üìù Zusammenfassung

| Hook             | Zweck                                     |
|------------------|--------------------------------------------|
| `useSelector`    | Daten aus Redux-Store lesen                |
| `useDispatch`    | Aktionen an den Store senden (dispatch)   |
| Vorteil          | weniger Code, bessere Lesbarkeit, Flexibilit√§t |

---

## üîó Quellen

- [React Redux ‚Äì `useSelector`](https://react-redux.js.org/api/hooks#useselector)  
- [React Redux ‚Äì `useDispatch`](https://react-redux.js.org/api/hooks#usedispatch)  
- [Redux Toolkit ‚Äì Einstieg](https://redux-toolkit.js.org/introduction/getting-started)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

120. ### <a name="120"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

121. ### <a name="121"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

122. ### <a name="122"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

123. ### <a name="123"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

124. ### <a name="124"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

125. ### <a name="125"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

126. ### <a name="126"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

127. ### <a name="127"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

128. ### <a name="128"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

129. ### <a name="129"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

130. ### <a name="130"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

131. ### <a name="131"></a> Was ist Code-Splitting?

# Was ist Code-Splitting?

**Code-Splitting** ist eine Technik, mit der du **JavaScript-Bundles in kleinere Teile aufteilst**,  
damit der Browser **nicht alles auf einmal laden muss**, sondern nur das, was wirklich gebraucht wird.

Ziel:  
üöÄ **Ladezeit reduzieren**  
üì¶ **Initiales Bundle kleiner halten**  
üìà **Performance verbessern**

---

## üì¶ Warum ist das wichtig?

Ohne Code-Splitting wird deine gesamte Anwendung als ein einziges gro√ües JS-Bundle geladen.  
Das verlangsamt die erste Ladezeit (‚ÄûInitial Load‚Äú) ‚Äì besonders bei gro√üen Apps.

---

## üöÄ Wie funktioniert Code-Splitting in React?

React verwendet **`React.lazy()`** in Kombination mit **`Suspense`** f√ºr dynamisches Laden von Komponenten.

---

## ‚úÖ Beispiel mit `React.lazy()` und `Suspense`

```jsx
import React, { Suspense } from 'react';

// Komponente wird nur bei Bedarf geladen
const LazyComponent = React.lazy(() => import('./MyComponent'));

function App() {
  return (
    <div>
      <h1>Meine App</h1>
      <Suspense fallback={<p>Lade...</p>}>
        <LazyComponent />
      </Suspense>
    </div>
  );
}
```

üìå Nur wenn `LazyComponent` wirklich gerendert wird, l√§dt React den zugeh√∂rigen Code.

---

## üß© Dynamisches Routing mit Code-Splitting

In Kombination mit `react-router-dom`:

```jsx
const Home = React.lazy(() => import('./pages/Home'));
const About = React.lazy(() => import('./pages/About'));

<Routes>
  <Route path="/" element={
    <Suspense fallback={<p>Lade Startseite...</p>}>
      <Home />
    </Suspense>
  } />
  <Route path="/about" element={
    <Suspense fallback={<p>Lade Info...</p>}>
      <About />
    </Suspense>
  } />
</Routes>
```

---

## üìÅ Webpack & Vite

Code-Splitting wird meist vom **Bundler** √ºbernommen:
- `webpack`: automatisch bei `import()`
- `vite`: unterst√ºtzt dynamisches Importieren nativ

---

## üìù Zusammenfassung

| Begriff          | Beschreibung                                |
|------------------|---------------------------------------------|
| `React.lazy()`   | dynamisches Laden von Komponenten           |
| `Suspense`       | zeigt Fallback w√§hrend des Ladens           |
| Vorteil          | schnelleres Initial-Loading                 |
| Einsatzbereiche  | gro√üe Seiten, Routen, selten genutzte Features |

---

## üîó Quellen

- [React ‚Äì Code-Splitting](https://react.dev/learn/code-splitting)  
- [MDN ‚Äì Code Splitting](https://developer.mozilla.org/en-US/docs/Glossary/Code_splitting)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

132. ### <a name="132"></a> Wie funktionieren React.lazy und Suspense?

# Wie funktionieren `React.lazy` und `Suspense`?

Mit `React.lazy()` und `Suspense` kannst du **Komponenten dynamisch (on-demand) laden**,  
anstatt sie beim Initial-Load in das Hauptbundle einzuschlie√üen.

‚û°Ô∏è Das nennt man **Code-Splitting auf Komponentenebene**.

---

## üß© `React.lazy()`

Mit `React.lazy()` definierst du eine **dynamisch importierte Komponente**.

```jsx
const LazyComponent = React.lazy(() => import('./MyComponent'));
```

üìå Der Code von `MyComponent` wird **erst geladen**, wenn sie **wirklich gerendert** wird.

---

## ‚è≥ `Suspense`

Da das Laden asynchron ist, brauchst du `Suspense`,  
um einen **Fallback (z.‚ÄØB. Ladeanzeige)** zu zeigen, w√§hrend die Komponente l√§dt.

```jsx
import React, { Suspense } from 'react';

function App() {
  return (
    <div>
      <h1>Meine App</h1>
      <Suspense fallback={<p>L√§dt‚Ä¶</p>}>
        <LazyComponent />
      </Suspense>
    </div>
  );
}
```

- `fallback` zeigt die UI w√§hrend des Ladevorgangs
- Der Fallback kann beliebig sein: Spinner, Skeleton, Text, etc.

---

## üìÇ Beispiel mit mehreren Lazy-Komponenten

```jsx
const Home = React.lazy(() => import('./pages/Home'));
const About = React.lazy(() => import('./pages/About'));

function App() {
  return (
    <Suspense fallback={<p>Lade Seite‚Ä¶</p>}>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
      </Routes>
    </Suspense>
  );
}
```

---

## üìå Einschr√§nkungen

- `React.lazy()` funktioniert **nur f√ºr Default-Exports**  
- Bei Fehlern beim Laden solltest du **Error Boundaries** verwenden  
- Suspense funktioniert aktuell **nicht f√ºr Datenfetching ohne weitere Libs** (au√üer mit `React 18` + Server Components oder Libs wie `React Query`, `Relay`)

---

## üìù Zusammenfassung

| Methode             | Beschreibung                                |
|---------------------|---------------------------------------------|
| `React.lazy()`      | dynamisches Importieren einer Komponente    |
| `Suspense`          | zeigt Fallback w√§hrend Ladevorgang          |
| Vorteil             | schnelleres Initial-Loading, besseres UX    |

---

## üîó Quellen

- [React.dev ‚Äì Code-Splitting](https://react.dev/learn/code-splitting)  
- [React.dev ‚Äì `React.lazy`](https://react.dev/reference/react/lazy)  
- [React.dev ‚Äì `Suspense`](https://react.dev/reference/react/Suspense)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

133. ### <a name="133"></a> Was ist Tree Shaking?

# Was ist Tree Shaking?

**Tree Shaking** ist ein Optimierungsverfahren beim **JavaScript-Bundling**,  
das **nicht verwendeten (toten) Code automatisch entfernt**  
‚Üí dadurch wird das finale Bundle kleiner und die Ladezeit schneller.

---

## üß† Wie funktioniert Tree Shaking?

Tree Shaking analysiert den **Modul-Import-Baum** (Import-Tree)  
und entfernt **unbenutzte Exporte** aus ES6+ Modulen.

‚û°Ô∏è Voraussetzung: Der Code muss **modular** und **statisch analysierbar** sein (ES Modules).

---

## ‚úÖ Beispiel

```js
// utils.js
export function used() {
  console.log('wird verwendet');
}

export function unused() {
  console.log('wird nie verwendet');
}

// main.js
import { used } from './utils.js';

used();
```

‚û°Ô∏è Beim Bundling (z.‚ÄØB. mit `webpack`, `vite`) wird `unused()` **eliminiert**,  
weil sie **nirgendwo verwendet wird**.

---

## üì¶ Voraussetzung f√ºr Tree Shaking

| Anforderung             | Erkl√§rung                              |
|--------------------------|-----------------------------------------|
| ‚úÖ ES Modules (`import`) | Kein `require()` oder CommonJS          |
| ‚úÖ statische Imports     | keine dynamischen `import(expr)`        |
| ‚úÖ kein Side-Effect      | Modul darf keine Seiteneffekte enthalten |

---

## üìÅ `package.json` mit `"sideEffects": false`

Damit der Bundler wei√ü, dass ein Modul **keine Nebenwirkungen hat**:

```json
{
  "name": "mein-paket",
  "sideEffects": false
}
```

‚û°Ô∏è Dadurch kann Tree Shaking aggressiver arbeiten.

---

## üö´ Was wird *nicht* entfernt?

- Dynamisch importierter Code
- Code mit Seiteneffekten (`console.log`, DOM-Zugriff)
- Nicht als Modul geschriebene Dateien (CommonJS)

---

## üìù Zusammenfassung

| Begriff        | Bedeutung                                  |
|----------------|---------------------------------------------|
| Tree Shaking   | Entfernt ungenutzten Code aus Bundles       |
| Voraussetzung  | ES Module, statische Imports, keine Side-Effects |
| Tools          | Webpack, Rollup, Vite, esbuild              |

---

## üîó Quellen

- [MDN ‚Äì Tree Shaking](https://developer.mozilla.org/en-US/docs/Glossary/Tree_shaking)  
- [webpack ‚Äì Tree Shaking](https://webpack.js.org/guides/tree-shaking/)  
- [Rollup ‚Äì Tree Shaking](https://rollupjs.org/guide/en/#tree-shaking)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

134. ### <a name="134"></a> Was ist Server-Side Rendering (SSR) und Hydration?

# Was ist Server-Side Rendering (SSR) und Hydration?

**Server-Side Rendering (SSR)** ist eine Technik, bei der **React-Komponenten auf dem Server in HTML umgewandelt**  
und an den Browser gesendet werden ‚Äì **bevor** JavaScript im Browser ausgef√ºhrt wird.

**Hydration** bedeutet, dass React im Browser den **interaktiven Zustand** (Events, State etc.)  
auf das **vom Server gelieferte HTML** anwendet.

---

## üì¶ Warum SSR verwenden?

| Vorteil                             | Beschreibung                                           |
|-------------------------------------|--------------------------------------------------------|
| ‚è± Schnellere erste Ladezeit         | HTML ist sofort da, auch ohne JS                      |
| üîç Bessere SEO                      | Crawler sehen direkt fertiges HTML                    |
| üì° Besser bei langsamen Verbindungen | Seite funktioniert teilweise, auch ohne JS sofort     |

---

## üîÅ SSR Ablauf (vereinfacht)

```text
1. Client sendet Anfrage an Server
2. Server rendert React-Komponenten ‚Üí HTML
3. HTML wird an Browser gesendet
4. Browser zeigt HTML
5. React wird im Hintergrund geladen ‚Üí Hydration
6. Seite wird interaktiv
```

---

## üîß Beispiel mit Next.js (SSR + Hydration)

```js
// pages/index.jsx
export default function Home({ name }) {
  return <h1>Hallo {name}</h1>;
}

export async function getServerSideProps() {
  return { props: { name: 'Sergii' } };
}
```

‚û°Ô∏è `getServerSideProps()` rendert die Seite **bei jeder Anfrage auf dem Server**.

---

## üíß Was ist Hydration?

Nach dem Server-Render muss React im Browser:

- das **gerenderte HTML √ºbernehmen**
- es mit **Event-Handlern und State** verbinden

‚û°Ô∏è Dieser Vorgang hei√üt **Hydration** und geschieht automatisch bei z.‚ÄØB. Next.js oder Remix.

---

## üß† Vergleich: CSR vs SSR

| Merkmal              | Client-Side Rendering (CSR)          | Server-Side Rendering (SSR)              |
|----------------------|--------------------------------------|------------------------------------------|
| Initiales HTML       | Leeres `div#root`                    | Vollst√§ndiges HTML                       |
| Ladegeschwindigkeit  | Langsamer Start                      | Schneller First Paint                    |
| SEO                  | Eingeschr√§nkt                        | Sehr gut                                 |
| Umsetzung            | CRA, Vite                            | Next.js, Remix                           |

---

## üìù Zusammenfassung

| Begriff       | Bedeutung                                                                |
|---------------|---------------------------------------------------------------------------|
| SSR           | React rendert HTML auf dem Server ‚Üí schneller Start + bessere SEO        |
| Hydration     | React macht servergerendertes HTML im Browser interaktiv                 |
| Tools         | `Next.js`, `Remix`, `express + react-dom/server`                         |

---

## üîó Quellen

- [React ‚Äì Rendering on the Server](https://react.dev/learn/rendering-on-the-server)  
- [Next.js ‚Äì SSR](https://nextjs.org/docs/pages/building-your-application/rendering/server-side-rendering)  
- [MDN ‚Äì Hydration](https://developer.mozilla.org/en-US/docs/Glossary/Hydration)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

135. ### <a name="135"></a> Wie geht man mit Hydration-Fehlern bei SSR um?

# Wie geht man mit Hydration-Fehlern bei SSR um?

**Hydration-Fehler** entstehen, wenn der HTML-Code vom Server  
nicht exakt mit dem initialen React-Render im Browser √ºbereinstimmt.

‚û°Ô∏è React zeigt dann Warnungen wie:

```text
Warning: Text content did not match.
Server: "A" | Client: "B"
```

---

## üîç Ursachen von Hydration-Problemen

| Ursache                                  | Beschreibung                                              |
|------------------------------------------|-----------------------------------------------------------|
| üïì Unterschiedlicher Zustand (z.‚ÄØB. Datum, Zufallszahl) | Server & Client generieren unterschiedliche Inhalte        |
| üß† Zugriff auf `window`, `document`       | Nur im Browser verf√ºgbar ‚Üí auf dem Server Fehler          |
| üß≠ Unterschiedliches Rendering je nach Umgebung | z.‚ÄØB. Sprache, Zeit, Browser                              |

---

## ‚úÖ Best Practices zur Vermeidung

### 1Ô∏è‚É£ **Nur im Browser ausf√ºhren** (`useEffect`)

```jsx
import { useEffect, useState } from 'react';

function ClientOnlyDate() {
  const [now, setNow] = useState(null);

  useEffect(() => {
    setNow(new Date().toLocaleTimeString());
  }, []);

  return <p>Uhrzeit: {now ?? 'L√§dt...'}</p>;
}
```

> ‚úÖ Wird **nicht** beim Server-Render ausgef√ºhrt ‚Üí keine Hydration-Probleme

---

### 2Ô∏è‚É£ **`typeof window !== 'undefined'` pr√ºfen**

```js
if (typeof window !== 'undefined') {
  const width = window.innerWidth;
}
```

---

### 3Ô∏è‚É£ **Client-Only-Komponenten auslagern**

In Next.js:

```jsx
'use client';

import dynamic from 'next/dynamic';

const NoSSRComponent = dynamic(() => import('./ClientComponent'), {
  ssr: false,
});
```

‚û°Ô∏è Die Komponente wird **nur im Browser** geladen und gerendert.

---

### 4Ô∏è‚É£ **Gleiches HTML auf Server und Client erzeugen**

- Keine `Math.random()`, `Date.now()`, `Intl`, etc. im JSX w√§hrend SSR
- Vermeide bedingtes Rendering auf Basis von Umgebungen

---

## üß™ Hydration-Fehler erkennen

- **Entwicklermodus** zeigt Warnungen in der Konsole
- Tools wie **React DevTools** und **Lighthouse** k√∂nnen helfen

---

## üìù Zusammenfassung

| Problem                   | Unterschied zwischen Server-HTML und Client-Render         |
|---------------------------|------------------------------------------------------------|
| Ursachen                  | Zustand, Zeit, Zufall, Browser-APIs                        |
| L√∂sung                    | `useEffect`, `typeof window`, `dynamic(ssr: false)`        |
| Ziel                      | Server-HTML = Client-HTML vor Hydration                    |

---

## üîó Quellen

- [React ‚Äì Hydration Errors](https://react.dev/reference/react-dom/client/hydrateRoot#hydration-errors)  
- [Next.js ‚Äì Avoiding Hydration Mismatches](https://nextjs.org/docs/messages/react-hydration-error)  
- [MDN ‚Äì Hydration](https://developer.mozilla.org/en-US/docs/Glossary/Hydration)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

136. ### <a name="136"></a> Was bedeutet Virtualisierung (z. B. mit react-window)?

# Was bedeutet Virtualisierung (z.‚ÄØB. mit `react-window`)?

**Virtualisierung** ist eine Technik zur **leistungsoptimierten Darstellung gro√üer Listen**,  
indem **nur die sichtbaren Elemente** im DOM gerendert werden ‚Äì  
statt Tausende gleichzeitig.

üì¶ Bekannte Libraries:  
- `react-window` (leicht & schnell)  
- `react-virtualized` (umfangreicher)

---

## üß† Warum Virtualisierung?

| Problem bei gro√üen Listen       | L√∂sung durch Virtualisierung             |
|----------------------------------|------------------------------------------|
| üö´ Langsames Rendering (1000+ DOM-Elemente) | ‚úÖ Nur sichtbarer Bereich wird gerendert |
| üìâ Hoher Speicherverbrauch       | ‚úÖ Geringe DOM-Last                       |
| üòµ Unn√∂tige Repaints/Updates     | ‚úÖ Bessere Performance                    |

---

## ‚úÖ Beispiel mit `react-window`

### 1Ô∏è‚É£ Installation

```bash
npm install react-window
```

---

### 2Ô∏è‚É£ Code-Beispiel

```jsx
import { FixedSizeList as List } from 'react-window';

const Row = ({ index, style }) => (
  <div style={style}>Zeile #{index}</div>
);

function VirtualizedList() {
  return (
    <List
      height={300}        // sichtbare H√∂he
      itemCount={1000}    // Anzahl der Elemente
      itemSize={35}       // H√∂he jedes Eintrags (px)
      width="100%"        // Breite
    >
      {Row}
    </List>
  );
}
```

‚û°Ô∏è Nur die Elemente im sichtbaren Bereich (z.‚ÄØB. 10‚Äì20 Zeilen)  
werden tats√§chlich ins DOM gerendert.

---

## üìå Unterschied: Pagination vs. Virtualisierung

| Technik          | Beschreibung                              |
|------------------|-------------------------------------------|
| Pagination       | Seite f√ºr Seite, Daten werden nachgeladen |
| Virtualisierung  | Alles im Speicher, aber nur sichtbarer Teil im DOM |

---

## üìà Vorteile

- üöÄ Schnelles Scrollen auch bei 10.000+ Eintr√§gen
- üì¶ Sehr kleine DOM-Gr√∂√üe
- üîÑ Reduziert Re-Renders und Speicherverbrauch

---

## üìù Zusammenfassung

| Begriff           | Erkl√§rung                                               |
|-------------------|----------------------------------------------------------|
| Virtualisierung   | Rendert nur sichtbare UI-Elemente                        |
| `react-window`    | Minimalistische Library f√ºr Listen-/Grid-Virtualisierung |
| Einsatzbereich    | Gro√üe Tabellen, Listen, Men√ºs                            |

---

## üîó Quellen

- [react-window ‚Äì GitHub](https://github.com/bvaughn/react-window)  
- [react-window ‚Äì Doku & Beispiele](https://react-window.vercel.app/)  
- [Artikel: Virtualisierung erkl√§rt](https://blog.logrocket.com/using-react-window-for-efficient-list-rendering/)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

137. ### <a name="137"></a> Wie verhindert man unn√∂tige Re-Renders?

# Wie verhindert man unn√∂tige Re-Renders in React?

**Unn√∂tige Re-Renders** entstehen, wenn eine Komponente erneut rendert,  
obwohl sich ihr sichtbarer Output nicht ge√§ndert hat.  
Das kann zu **Performance-Problemen** f√ºhren ‚Äì besonders bei gro√üen Apps.

---

## ‚úÖ Techniken zur Optimierung

### 1Ô∏è‚É£ `React.memo` (f√ºr Funktionskomponenten)

Verhindert Re-Render, wenn Props **gleich bleiben**.

```jsx
const MyComponent = React.memo(function MyComponent({ name }) {
  return <p>{name}</p>;
});
```

‚û°Ô∏è Vergleich erfolgt **flach (shallow)** ‚Äì bei komplexen Objekten ggf. manuell optimieren.

---

### 2Ô∏è‚É£ `useMemo` (f√ºr berechnete Werte)

Memoisiert einen R√ºckgabewert, wenn sich Abh√§ngigkeiten **nicht ge√§ndert** haben.

```jsx
const expensiveValue = useMemo(() => computeHeavy(a, b), [a, b]);
```

‚û°Ô∏è Ideal f√ºr teure Berechnungen (Filter, Sortierung usw.)

---

### 3Ô∏è‚É£ `useCallback` (f√ºr stabile Funktions-Referenzen)

Verhindert, dass Funktionen bei jedem Render neu erzeugt werden.

```jsx
const handleClick = useCallback(() => {
  doSomething();
}, []);
```

‚û°Ô∏è N√ºtzlich, wenn Props als Callback an `React.memo`-Komponenten √ºbergeben werden.

---

### 4Ô∏è‚É£ `shouldComponentUpdate` (bei Klassenkomponenten)

Steuert manuell, ob ein Re-Render n√∂tig ist.

```js
shouldComponentUpdate(nextProps, nextState) {
  return nextProps.value !== this.props.value;
}
```

‚û°Ô∏è Alternative: `PureComponent`, das das automatisch macht (flacher Vergleich).

---

### 5Ô∏è‚É£ Selektives `useSelector` in Redux

Vermeide globale Re-Renders durch pr√§zise Selektoren:

```jsx
const value = useSelector((state) => state.counter.value);
```

‚û°Ô∏è Keine Abh√§ngigkeit von globalem State, wenn nicht n√∂tig.

---

### 6Ô∏è‚É£ Komponentenaufteilung (Component Splitting)

Teile gro√üe Komponenten in kleinere auf,  
damit nur betroffene Teile neu gerendert werden.

---

### 7Ô∏è‚É£ Props vermeiden, die sich st√§ndig √§ndern

Beispiel:

```jsx
// Schlechter Stil: erzeugt neues Objekt bei jedem Render
<Component config={{ a: 1 }} />

// Besser: config als useMemo oder aus dem State
```

---

## üìù Zusammenfassung

| Technik          | Zweck                                               |
|------------------|------------------------------------------------------|
| `React.memo`     | Memoisiert Funktionskomponenten                     |
| `useMemo`        | Memoisiert R√ºckgabewerte von Funktionen             |
| `useCallback`    | Verhindert neue Funktionsreferenzen                 |
| `shouldComponentUpdate` | Kontrolle √ºber Updates in Klassen             |
| Genaue `useSelector`    | Vermeidet unn√∂tige Redux-abh√§ngige Re-Renders |

---

## üîó Quellen

- [React Docs ‚Äì Optimizing Performance](https://react.dev/learn/optimizing-performance)  
- [React.memo ‚Äì Referenz](https://react.dev/reference/react/memo)  
- [useMemo ‚Äì Referenz](https://react.dev/reference/react/useMemo)  
- [useCallback ‚Äì Referenz](https://react.dev/reference/react/useCallback)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

138. ### <a name="138"></a> Was ist React Transition Group?

# Was ist React Transition Group?

**React Transition Group** ist eine React-Bibliothek f√ºr **einfache Animationen und √úberg√§nge**,  
z.‚ÄØB. beim Einblenden, Ausblenden oder √Ñndern von Komponenten im DOM.

‚û°Ô∏è Sie steuert **den Zeitpunkt**, wann eine Komponente in den DOM eingef√ºgt oder entfernt wird  
und bietet daf√ºr passende CSS-Klassen.

---

## üì¶ Installation

```bash
npm install react-transition-group
```

---

## üìö Wichtige Komponenten

| Komponente         | Zweck                                         |
|--------------------|-----------------------------------------------|
| `<Transition>`     | Kontrolle √ºber Mount/Unmount mit √úbergang     |
| `<CSSTransition>`  | Wie `<Transition>`, aber mit CSS-Klassen      |
| `<SwitchTransition>` | √úbergang zwischen zwei exklusiven Komponenten |
| `<TransitionGroup>` | Sammlung mehrerer animierter Komponenten     |

---

## ‚úÖ Beispiel mit `CSSTransition`

```jsx
import { CSSTransition } from 'react-transition-group';
import './styles.css';

function Example({ show }) {
  return (
    <CSSTransition
      in={show}
      timeout={300}
      classNames="fade"
      unmountOnExit
    >
      <div className="box">Ich werde animiert!</div>
    </CSSTransition>
  );
}
```

---

## üé® CSS f√ºr Animation

```css
.fade-enter {
  opacity: 0;
}
.fade-enter-active {
  opacity: 1;
  transition: opacity 300ms;
}

.fade-exit {
  opacity: 1;
}
.fade-exit-active {
  opacity: 0;
  transition: opacity 300ms;
}
```

---

## üß† Warum `Transition Group`?

- Nutzt **kein JavaScript-Animationstool**, sondern **CSS-Animationen**
- Arbeitet direkt mit dem React-Lifecycle (`mount`, `unmount`)
- Kompatibel mit Conditional Rendering (`{show && <Component />}`)

---

## üìù Zusammenfassung

| Begriff              | Beschreibung                              |
|----------------------|-------------------------------------------|
| `React Transition Group` | Animation von Komponenten √ºber Lebenszyklus |
| `CSSTransition`      | Automatisiert Klassenwechsel f√ºr CSS-Animation |
| Vorteil              | Leichtgewichtig, flexibel, kein Fremdanimationstool n√∂tig |

---

## üîó Quellen

- [React Transition Group ‚Äì Doku](https://reactcommunity.org/react-transition-group/)  
- [Beispiel: CSSTransition](https://reactcommunity.org/react-transition-group/css-transition)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

139. ### <a name="139"></a> Was ist React Strict Mode und welche Vorteile bietet er?

# Was ist React Strict Mode und welche Vorteile bietet er?

**`React.StrictMode`** ist eine Wrapper-Komponente von React,  
die **zus√§tzliche Pr√ºfungen und Warnungen** im Entwicklungsmodus aktiviert.  
‚û°Ô∏è Ziel: **Fehler fr√ºhzeitig erkennen** und **zuk√ºnftige Probleme vermeiden**.

üìå Wichtig: Strict Mode **hat keine Auswirkungen im Produktions-Build**.

---

## üß± Verwendung

```jsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
```

---

## ‚úÖ Vorteile und Pr√ºfungen

| Pr√ºfung / Verhalten                      | Beschreibung                                         |
|------------------------------------------|------------------------------------------------------|
| üîÅ Doppelte Aufrufe von Lifecycles        | z.‚ÄØB. `useEffect`, `constructor` ‚Üí zur Fehlererkennung |
| ‚ö†Ô∏è Veraltete Methoden erkennen            | z.‚ÄØB. `componentWillMount` (nicht mehr empfohlen)    |
| üßµ Unerw√ºnschte Side-Effects aufdecken    | durch mehrfaches Mounten/Unmounten simuliert        |
| üö® Warnungen bei Legacy-API-Nutzung       | z.‚ÄØB. `findDOMNode()`, veraltete Context-API         |
| üöß Vorbereitung auf zuk√ºnftige Features   | z.‚ÄØB. automatische Batching oder Concurrent Mode     |

---

## üß™ Beispiel: doppeltes `useEffect`

```jsx
useEffect(() => {
  console.log('l√§uft');
}, []);
```

‚û°Ô∏è Im Strict Mode erscheint `l√§uft` **zweimal in der Konsole** ‚Äì aber nur im Dev-Modus.  
Das ist **beabsichtigt**, um **unsichere Nebeneffekte aufzudecken**.

---

## üìù Zusammenfassung

| Merkmal            | Beschreibung                                           |
|--------------------|--------------------------------------------------------|
| `StrictMode`       | React-Tool zur Entwicklungssicherheit                  |
| Nur Dev-Modus      | Keine Auswirkungen auf Produktion                      |
| Vorteile           | Warnungen, doppelte Checks, fr√ºhe Fehlererkennung      |

---

## üîó Quellen

- [React ‚Äì Strict Mode](https://react.dev/reference/react/StrictMode)  
- [React ‚Äì Stricter Effects](https://react.dev/learn/strict-mode#ensuring-reusable-state)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

140. ### <a name="140"></a> Was ist Concurrent Mode und welche Probleme l√∂st er?

# Was ist Concurrent Mode und welche Probleme l√∂st er?

**Concurrent Mode** (in React 18 als **Concurrent Features** bezeichnet) ist ein moderner Render-Modus,  
der React erlaubt, **Rendering-Aufgaben zu unterbrechen, zu pausieren und fortzusetzen**,  
um eine **reaktionsschnellere und fl√ºssigere Benutzeroberfl√§che** zu erm√∂glichen.

‚û°Ô∏è Ziel: **Asynchrones, priorit√§tsbasiertes und unterbrechbares Rendering**.

---

## üß† Probleme im traditionellen Modus

| Problem                          | Erkl√§rung                                                  |
|----------------------------------|-------------------------------------------------------------|
| üòµ Blockierendes Rendering        | Langsame Komponenten blockieren die ganze UI               |
| üïì Lange Ladezeiten bei √úberg√§ngen | Kein Feedback f√ºr Nutzer bei langsamer Datenverarbeitung   |
| üò° Kein Abbruch laufender Updates | Bei schnellen √Ñnderungen wird trotzdem alles gerendert     |

---

## ‚úÖ Vorteile von Concurrent Mode

| Feature                     | Beschreibung                                                   |
|-----------------------------|----------------------------------------------------------------|
| üßµ Unterbrechbares Rendering | React kann rendering pausieren und sp√§ter fortsetzen          |
| üóÇ Priorisierung             | Wichtige Updates (z.‚ÄØB. Eingaben) k√∂nnen vorgezogen werden     |
| ü™Ñ Automatisches Batching   | Mehrere `setState` Calls werden automatisch zusammengefasst    |
| üåÄ √úberg√§nge (`startTransition`) | √úberg√§nge erscheinen fl√ºssiger, weniger ‚ÄûUI-Freeze‚Äú         |
| üß™ Verbesserung f√ºr SSR + Streaming | Bessere Unterst√ºtzung f√ºr `Suspense` & Server Components |

---

## ‚öôÔ∏è Aktivierung (React 18+)

Concurrent Mode ist **automatisch verf√ºgbar** in React 18,  
wenn du **`createRoot()`** verwendest (statt `ReactDOM.render`):

```jsx
import ReactDOM from 'react-dom/client';
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);
```

---

## üß≠ Beispiel mit `startTransition`

```jsx
import { useState, startTransition } from 'react';

function Search({ items }) {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);

  const handleChange = (e) => {
    const value = e.target.value;
    setQuery(value);

    startTransition(() => {
      const filtered = items.filter((item) => item.includes(value));
      setResults(filtered);
    });
  };

  return (
    <>
      <input value={query} onChange={handleChange} />
      <ul>{results.map((r) => <li key={r}>{r}</li>)}</ul>
    </>
  );
}
```

‚û°Ô∏è `startTransition` markiert den Filtervorgang als **niedrige Priorit√§t**,  
damit Eingaben ohne Verz√∂gerung verarbeitet werden.

---

## üìù Zusammenfassung

| Begriff           | Beschreibung                                                         |
|-------------------|----------------------------------------------------------------------|
| Concurrent Mode   | Neuer React-Modus mit unterbrechbarem, priorisiertem Rendering       |
| Vorteile          | Bessere UX, kein UI-Freeze, schnellere Reaktion auf Nutzeraktionen   |
| Tools             | `createRoot`, `startTransition`, `Suspense`, automatische Batching   |

---

## üîó Quellen

- [React ‚Äì Concurrent Mode](https://react.dev/learn/synchronizing-with-effects#concurrent-rendering)  
- [React 18 ‚Äì Neue Features](https://reactjs.org/blog/2022/03/29/react-v18.html)  
- [startTransition ‚Äì API](https://react.dev/reference/react/startTransition)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

141. ### <a name="141"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

142. ### <a name="142"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

143. ### <a name="143"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

144. ### <a name="144"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

145. ### <a name="145"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

146. ### <a name="146"></a> Was ist ein Service Worker?

# Was ist ein Service Worker?

Ein **Service Worker** ist ein **hintergrundaktives JavaScript-Skript**,  
das **zwischen der Webanwendung und dem Netzwerk** steht.  
Es l√§uft **au√üerhalb der Hauptseite**, kann Netzwerk-Anfragen abfangen,  
Antworten cachen und Funktionen wie **Offline-Unterst√ºtzung** oder **Push-Benachrichtigungen** erm√∂glichen.

---

## üîß Eigenschaften

| Merkmal              | Beschreibung                                                |
|----------------------|-------------------------------------------------------------|
| L√§uft im Hintergrund | Unabh√§ngig vom DOM und UI-Thread                            |
| Ereignisgesteuert    | Reagiert auf `fetch`, `install`, `activate`, `push` etc.   |
| Offline-f√§hig        | Kann Anfragen aus dem Cache bedienen                        |
| Keine direkte DOM-Zugriff | Arbeitet mit `postMessage()` zur Kommunikation        |

---

## ‚úÖ Typische Anwendungsf√§lle

- üì¥ Offline-Webseiten (z.‚ÄØB. PWA)
- ‚ö°Ô∏è Schnellere Ladezeiten durch Caching
- üì° Hintergrund-Synchronisierung
- üîî Push-Benachrichtigungen

---

## üìÅ Lebenszyklus

1. **Registrierung**

```js
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js')
    .then(() => console.log('SW registriert'))
    .catch((err) => console.error('SW Fehler', err));
}
```

2. **Installation**

```js
self.addEventListener('install', (event) => {
  console.log('Service Worker installiert');
});
```

3. **Aktivierung**

```js
self.addEventListener('activate', (event) => {
  console.log('Service Worker aktiviert');
});
```

4. **Anfragen abfangen (`fetch`)**

```js
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request)
      .then((response) => response || fetch(event.request))
  );
});
```

---

## ‚ö†Ô∏è Einschr√§nkungen

| Einschr√§nkung            | Grund                                       |
|---------------------------|---------------------------------------------|
| Nur √ºber HTTPS            | Aus Sicherheitsgr√ºnden                      |
| Kein DOM-Zugriff          | Nur √ºber Messaging                         |
| Komplexe Caching-Strategien | Erfordert manuelles Cache-Management     |

---

## üìù Zusammenfassung

| Begriff         | Beschreibung                                        |
|------------------|-----------------------------------------------------|
| Service Worker   | JS-Skript im Hintergrund, kontrolliert Netzwerk     |
| Vorteil          | Offline-Funktion, schnelleres Laden, Push-Services  |
| Tools            | `navigator.serviceWorker`, `Cache API`, `fetch`     |

---

## üîó Quellen

- [MDN ‚Äì Service Workers](https://developer.mozilla.org/de/docs/Web/API/Service_Worker_API)  
- [Google Web ‚Äì Service Worker Guide](https://developer.chrome.com/docs/workbox/service-worker-overview/)  
- [Web.dev ‚Äì Learn Service Workers](https://web.dev/learn/pwa/service-workers/)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

147. ### <a name="147"></a> Was ist react-helmet und wie hilft es beim SEO?

# Was ist `react-helmet` und wie hilft es beim SEO?

**`react-helmet`** ist eine React-Bibliothek, mit der du dynamisch den `<head>`-Bereich  
deiner Anwendung verwalten kannst ‚Äì z.‚ÄØB. Titel, Meta-Tags, Open Graph Daten etc.

‚û°Ô∏è Besonders hilfreich f√ºr **SEO**, **Social Sharing** und **dynamische Inhalte** bei React-SPAs.

---

## üì¶ Installation

```bash
npm install react-helmet
```

---

## ‚úÖ Verwendung

```jsx
import { Helmet } from 'react-helmet';

function MyPage() {
  return (
    <>
      <Helmet>
        <title>Meine Seite ‚Äì React</title>
        <meta name="description" content="Beschreibung der Seite f√ºr SEO." />
        <meta property="og:title" content="OpenGraph Titel" />
      </Helmet>
      <h1>Willkommen</h1>
    </>
  );
}
```

‚û°Ô∏è Die `<head>`-Elemente werden zur Laufzeit aktualisiert.

---

## üîç SEO-Vorteile

| Vorteil                          | Beschreibung                                      |
|----------------------------------|---------------------------------------------------|
| üß† Dynamischer `<title>`         | Je nach Seite oder Route individuell anpassbar    |
| üîç Meta-Tags optimierbar         | Bessere Sichtbarkeit bei Google, Bing usw.        |
| üì≤ OpenGraph / Twitter Cards     | Attraktive Vorschauen bei Social-Media-Teilen     |
| üåê hreflang, Canonical etc.      | Internationale SEO / Duplicate Content vermeiden  |

---

## üõ† Alternative f√ºr SSR-Umgebungen

Bei **Server-Side Rendering (z.‚ÄØB. Next.js)** wird `react-helmet` oft ersetzt durch:

- `next/head` (Next.js)
- `@remix-run/react` ‚Üí `<Meta />`

‚û°Ô∏è Diese L√∂sungen integrieren sich besser mit SSR und liefern **Head-Infos direkt im initialen HTML**.

---

## üìù Zusammenfassung

| Begriff         | Beschreibung                                       |
|------------------|----------------------------------------------------|
| `react-helmet`   | Bibliothek zur Verwaltung von `<head>`-Tags       |
| Nutzen           | Verbesserte SEO, bessere Social-Media-Darstellung |
| Typische Tags    | `<title>`, `<meta>`, OpenGraph, Canonical-Links   |

---

## üîó Quellen

- [react-helmet ‚Äì GitHub](https://github.com/nfl/react-helmet)  
- [react-helmet ‚Äì Dokumentation](https://www.npmjs.com/package/react-helmet)  
- [MDN ‚Äì Meta-Tags f√ºr SEO](https://developer.mozilla.org/de/docs/Learn/HTML/Introduction_to_HTML/The_head_metadata_in_HTML)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

148. ### <a name="148"></a> Wie funktioniert Lazy Loading mit dynamic import()?

# Wie funktioniert Lazy Loading mit `dynamic import()`?

**Lazy Loading** bedeutet, dass Module oder Komponenten **erst bei Bedarf** geladen werden ‚Äì  
nicht beim Initial-Load.  
Mit `dynamic import()` kannst du in JavaScript oder React **Code-Splitting** betreiben  
und so die **Ladezeit und Performance verbessern**.

---

## üì¶ Syntax: `import()` als Funktion

```js
import('./modul.js').then((modul) => {
  modul.doSomething();
});
```

- Gibt ein **Promise** zur√ºck  
- L√§dt das Modul **asynchron**

---

## ‚úÖ Verwendung in React mit `React.lazy()`

```jsx
import React, { Suspense } from 'react';

const LazyComponent = React.lazy(() => import('./MyComponent'));

function App() {
  return (
    <Suspense fallback={<p>L√§dt‚Ä¶</p>}>
      <LazyComponent />
    </Suspense>
  );
}
```

üìå Nur wenn `LazyComponent` gerendert werden soll, wird es mit `import()` geladen.

---

## üß† Vorteile von Lazy Loading

| Vorteil                 | Beschreibung                                 |
|--------------------------|----------------------------------------------|
| üöÄ Schnellere Initial-Ladezeit | Nur kritischer Code wird zuerst geladen       |
| üì¶ Kleineres Bundle         | Spart Speicher und Traffic                   |
| üì≤ Besseres Nutzererlebnis  | Schnellerer Page Load ‚Üí weniger Wartezeit     |

---

## üåç Beispiel: Lazy Loading bei Routen (mit `react-router`)

```jsx
const Home = React.lazy(() => import('./pages/Home'));
const About = React.lazy(() => import('./pages/About'));

<Routes>
  <Route path="/" element={
    <Suspense fallback={<p>Home l√§dt‚Ä¶</p>}>
      <Home />
    </Suspense>
  } />
  <Route path="/about" element={
    <Suspense fallback={<p>About l√§dt‚Ä¶</p>}>
      <About />
    </Suspense>
  } />
</Routes>
```

---

## ‚ö†Ô∏è Einschr√§nkungen

| Einschr√§nkung            | Beschreibung                                |
|---------------------------|---------------------------------------------|
| Nur Default-Exports       | `React.lazy()` funktioniert nur mit Default |
| Suspense erforderlich     | Ohne `Suspense` keine Anzeige beim Laden    |
| Kein SSR-Support direkt   | Nur clientseitiges Lazy Loading             |

---

## üìù Zusammenfassung

| Begriff             | Beschreibung                                     |
|----------------------|--------------------------------------------------|
| `import()`           | Asynchrone Modul-Ladung                          |
| `React.lazy()`       | Lazy Loading von React-Komponenten               |
| Vorteil              | Code-Splitting, schnellere Ladezeit              |

---

## üîó Quellen

- [MDN ‚Äì import()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#dynamic_imports)  
- [React ‚Äì Code-Splitting mit lazy()](https://react.dev/learn/code-splitting)  
- [React ‚Äì React.lazy() API](https://react.dev/reference/react/lazy)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

149. ### <a name="149"></a> Was ist ein Finite-State Machine (FSM), z. B. mit XState?

# Was ist eine Finite-State Machine (FSM), z.‚ÄØB. mit XState?

Eine **Finite-State Machine (FSM)** ist ein Modell zur Darstellung von **endlich vielen Zust√§nden**  
und den **√úberg√§ngen (Transitions)** zwischen ihnen ‚Äì abh√§ngig von bestimmten Ereignissen (Events).

‚û°Ô∏è In React-Anwendungen eignet sich FSM perfekt zur **klaren Zustandslogik**, z.‚ÄØB. f√ºr Formulare, Auth, UI-States etc.

üì¶ Beliebtes Tool: [`XState`](https://xstate.js.org)

---

## üß† Grundprinzip einer FSM

| Begriff      | Erkl√§rung                                 |
|--------------|--------------------------------------------|
| `State`      | Ein Zustand (z.‚ÄØB. `idle`, `loading`)      |
| `Event`      | Ausl√∂ser f√ºr Zustandswechsel (`FETCH`, `ERROR`) |
| `Transition` | √úbergang von Zustand A zu B                |
| `Initial`    | Startzustand                              |
| `Final`      | Endzustand (optional)                      |

---

## ‚úÖ Beispiel als Objekt (XState-Syntax)

```js
import { createMachine } from 'xstate';

const fetchMachine = createMachine({
  id: 'fetch',
  initial: 'idle',
  states: {
    idle: {
      on: { FETCH: 'loading' },
    },
    loading: {
      on: {
        RESOLVE: 'success',
        REJECT: 'failure',
      },
    },
    success: {},
    failure: {
      on: { RETRY: 'loading' },
    },
  },
});
```

‚û°Ô∏è FSM wechselt nur **kontrolliert** zwischen definierten Zust√§nden.

---

## ‚öõÔ∏è Verwendung mit React (`@xstate/react`)

```jsx
import { useMachine } from '@xstate/react';
import { fetchMachine } from './machines/fetchMachine';

function Fetcher() {
  const [state, send] = useMachine(fetchMachine);

  return (
    <>
      {state.matches('idle') && <button onClick={() => send('FETCH')}>Laden</button>}
      {state.matches('loading') && <p>‚è≥ Ladevorgang...</p>}
      {state.matches('success') && <p>‚úÖ Erfolgreich geladen</p>}
      {state.matches('failure') && (
        <button onClick={() => send('RETRY')}>üîÅ Wiederholen</button>
      )}
    </>
  );
}
```

---

## üß≠ Warum FSM in UI sinnvoll ist

| Vorteil                            | Beschreibung                                 |
|------------------------------------|----------------------------------------------|
| üí° Klar definierte Zust√§nde         | Kein "unbekannter" Zustand mehr              |
| üîê Vorhersehbares Verhalten         | Transitions nur auf erlaubte Events m√∂glich  |
| üîÑ Wiederverwendbar & testbar       | Zust√§nde sind unabh√§ngig von Komponenten     |
| üß© Visualisierbar                   | Tools wie [XState Visualizer](https://xstate.js.org/viz/) zeigen √úberg√§nge grafisch |

---

## üìù Zusammenfassung

| Begriff     | Erkl√§rung                                            |
|--------------|-------------------------------------------------------|
| FSM         | Modell zur Kontrolle von Zust√§nden                    |
| XState      | Library zur Definition & Ausf√ºhrung von FSMs          |
| Vorteil     | Mehr Kontrolle, bessere UI-Logik, einfache Wartbarkeit|

---

## üîó Quellen

- [XState Docs](https://xstate.js.org/docs/)  
- [XState ‚Äì React Integration](https://xstate.js.org/docs/packages/xstate-react/)  
- [MDN ‚Äì Finite-State Machine](https://developer.mozilla.org/en-US/docs/Glossary/Finite-state_machine)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

150. ### <a name="150"></a> Wie kann man ein Formular mit Formik und Yup erstellen und validieren?

# Wie kann man ein Formular mit Formik und Yup erstellen und validieren?

**Formik** ist eine beliebte React-Bibliothek zur einfachen Erstellung und Verwaltung von Formularen.  
**Yup** ist ein Schema-Builder zur Validierung von Formularwerten.  
‚û°Ô∏è Zusammen erm√∂glichen sie **strukturiertes, sauberes und validiertes Formular-Handling** in React.

---

## üì¶ Installation

```bash
npm install formik yup
```

---

## ‚úÖ Beispiel: Login-Formular mit Validierung

```jsx
import { Formik, Form, Field, ErrorMessage } from 'formik';
import * as Yup from 'yup';

// ‚úÖ Validierungsschema mit Yup
const validationSchema = Yup.object({
  email: Yup.string()
    .email('Ung√ºltige E-Mail')
    .required('E-Mail ist erforderlich'),
  password: Yup.string()
    .min(6, 'Mindestens 6 Zeichen')
    .required('Passwort ist erforderlich'),
});

function LoginForm() {
  return (
    <Formik
      initialValues={{ email: '', password: '' }}
      validationSchema={validationSchema}
      onSubmit={(values) => {
        console.log('Formulardaten:', values);
      }}
    >
      <Form className="space-y-4">
        <div>
          <label htmlFor="email">E-Mail:</label>
          <Field name="email" type="email" className="border p-1 w-full" />
          <ErrorMessage name="email" component="div" className="text-red-600 text-sm" />
        </div>

        <div>
          <label htmlFor="password">Passwort:</label>
          <Field name="password" type="password" className="border p-1 w-full" />
          <ErrorMessage name="password" component="div" className="text-red-600 text-sm" />
        </div>

        <button type="submit" className="bg-blue-500 text-white px-4 py-2 rounded">
          Einloggen
        </button>
      </Form>
    </Formik>
  );
}
```

---

## üß† Was macht Formik?

| Feature              | Beschreibung                                            |
|----------------------|---------------------------------------------------------|
| `initialValues`      | Startwerte f√ºr das Formular                             |
| `validationSchema`   | Yup-Schema zur Feldvalidierung                          |
| `onSubmit`           | Funktion, die bei erfolgreichem Submit ausgef√ºhrt wird  |
| `<Field>`            | Automatisch angebundene Eingabefelder                   |
| `<ErrorMessage>`     | Zeigt Fehlermeldungen f√ºr bestimmte Felder              |

---

## üìå Vorteile von Formik + Yup

| Vorteil               | Beschreibung                                     |
|------------------------|--------------------------------------------------|
| ‚úÖ Trennung von Logik & UI | Validierung getrennt in Schema                  |
| üß™ Testbare Formulare   | Zust√§nde und Fehler leicht √ºberpr√ºfbar            |
| üîÅ Automatisches Reset  | Einfaches Reset bei Erfolg oder Abbruch          |
| ‚ö†Ô∏è Benutzerfreundliche Fehlermeldungen | Direkt unter Eingabefeldern              |

---

## üìù Zusammenfassung

| Tool     | Zweck                          |
|----------|--------------------------------|
| Formik   | Formularzustand, Events, Submit |
| Yup      | Validierungsschema f√ºr Felder   |
| Vorteil  | Weniger Boilerplate, klare Struktur, bessere UX |

---

## üîó Quellen

- [Formik ‚Äì Dokumentation](https://formik.org/docs/overview)  
- [Yup ‚Äì Doku](https://github.com/jquense/yup)  
- [Formik + Yup Beispiel](https://formik.org/docs/guides/validation)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

151. ### <a name="151"></a> Wie konfiguriert man ESLint und Prettier in einem React-Projekt?

# Wie konfiguriert man ESLint und Prettier in einem React-Projekt?

**ESLint** analysiert deinen Code und findet potenzielle Fehler und Stilprobleme.  
**Prettier** ist ein Code-Formatter, der f√ºr konsistente Formatierung sorgt.  
Zusammen sorgen sie f√ºr **sauberen, wartbaren Code** in React-Projekten.

---

## üì¶ Schritt-f√ºr-Schritt-Anleitung

### 1Ô∏è‚É£ ESLint + Prettier installieren

```bash
npm install -D eslint prettier eslint-config-prettier eslint-plugin-prettier
```

### 2Ô∏è‚É£ ESLint f√ºr React installieren

```bash
npm install -D eslint-plugin-react eslint-plugin-react-hooks
```

Bei TypeScript zus√§tzlich:

```bash
npm install -D @typescript-eslint/eslint-plugin @typescript-eslint/parser
```

---

## üìÅ ESLint-Konfiguration (`.eslintrc.json`)

```json
{
  "env": {
    "browser": true,
    "es2021": true
  },
  "extends": [
    "eslint:recommended",
    "plugin:react/recommended",
    "plugin:react-hooks/recommended",
    "plugin:prettier/recommended"
  ],
  "plugins": ["react", "react-hooks", "prettier"],
  "parserOptions": {
    "ecmaVersion": "latest",
    "sourceType": "module",
    "ecmaFeatures": {
      "jsx": true
    }
  },
  "rules": {
    "prettier/prettier": "error"
  },
  "settings": {
    "react": {
      "version": "detect"
    }
  }
}
```

‚û°Ô∏è `"plugin:prettier/recommended"` integriert Prettier automatisch in ESLint.

---

## üßº Prettier-Konfiguration (`.prettierrc`)

```json
{
  "semi": true,
  "singleQuote": true,
  "tabWidth": 2,
  "trailingComma": "es5",
  "printWidth": 80
}
```

---

## üõ† Weitere Dateien

### `.eslintignore`

```
node_modules
build
dist
```

### `.prettierignore`

```
build
dist
*.svg
```

---

## üß™ Test: ESLint und Prettier ausf√ºhren

```bash
npx eslint src --ext .js,.jsx,.ts,.tsx
npx prettier --check .
```

Oder automatisch fixen:

```bash
npx eslint src --fix
npx prettier --write .
```

---

## ‚öõÔ∏è VSCode-Integration

- Erweiterungen installieren:
  - ESLint
  - Prettier ‚Äì Code formatter

- In den Einstellungen (`.vscode/settings.json`):

```json
{
  "editor.formatOnSave": true,
  "editor.defaultFormatter": "esbenp.prettier-vscode"
}
```

---

## üìù Zusammenfassung

| Tool       | Zweck                                  |
|------------|-----------------------------------------|
| ESLint     | Analyse von Code-Stil und Fehlern       |
| Prettier   | Einheitliche automatische Formatierung  |
| Vorteil    | Sauberer Code, weniger Fehler, Teamkonsistenz |

---

## üîó Quellen

- [ESLint ‚Äì Dokumentation](https://eslint.org/docs/latest/)  
- [Prettier ‚Äì Docs](https://prettier.io/docs/en/index.html)  
- [eslint-config-prettier](https://github.com/prettier/eslint-config-prettier)  
- [React ESLint Setup](https://react.dev/learn/linting)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

152. ### <a name="152"></a> Wie funktioniert dynamic import() in React (Syntax, Anwendungsf√§lle)?

# Wie funktioniert `dynamic import()` in React (Syntax & Anwendungsf√§lle)?

`dynamic import()` ist eine **JavaScript-Funktion**, mit der Module **asynchron geladen** werden k√∂nnen.  
In React wird diese Technik vor allem f√ºr **Lazy Loading und Code-Splitting** eingesetzt,  
um die **Initial-Ladezeit zu reduzieren** und die **Performance zu verbessern**.

---

## üì¶ Syntax

```js
import('./MyComponent.js').then((modul) => {
  modul.default(); // Zugriff auf den Default-Export
});
```

- Gibt ein **Promise** zur√ºck
- Kann √ºberall im Code verwendet werden, z.‚ÄØB. in Funktionen, Event-Handlern oder Bedingungsausdr√ºcken

---

## ‚úÖ Verwendung mit `React.lazy()`

In React ist `React.lazy()` die empfohlene Methode f√ºr dynamisches Importieren von **Komponenten**.

```jsx
import React, { Suspense } from 'react';

const LazyComponent = React.lazy(() => import('./MyComponent'));

function App() {
  return (
    <Suspense fallback={<div>L√§dt‚Ä¶</div>}>
      <LazyComponent />
    </Suspense>
  );
}
```

üìå Wichtig: Komponenten m√ºssen **default-exportiert** sein.  
Das `fallback` wird w√§hrend des Ladevorgangs angezeigt.

---

## üß† Anwendungsf√§lle

| Anwendungsfall           | Beschreibung                                       |
|---------------------------|----------------------------------------------------|
| üéØ Route-basiertes Lazy Loading | Nur beim Aufruf einer Seite wird Code geladen     |
| üß© Gro√üe Komponenten       | Nur geladen, wenn sie ben√∂tigt werden (z.‚ÄØB. Modale) |
| üåç Sprache / i18n          | Dynamisches Nachladen von Sprachdateien            |
| üõ† Admin-Panels            | Nur bei bestimmten Rollen laden                   |

---

## üåç Beispiel: Routing mit React Router

```jsx
const Home = React.lazy(() => import('./pages/Home'));
const About = React.lazy(() => import('./pages/About'));

<Routes>
  <Route path="/" element={
    <Suspense fallback={<p>Loading...</p>}>
      <Home />
    </Suspense>
  } />
  <Route path="/about" element={
    <Suspense fallback={<p>Loading...</p>}>
      <About />
    </Suspense>
  } />
</Routes>
```

---

## üìù Zusammenfassung

| Begriff            | Beschreibung                                 |
|---------------------|----------------------------------------------|
| `import()`          | Dynamischer Modulimport, Promise-basiert     |
| `React.lazy()`      | F√ºr Lazy Loading von Komponenten             |
| Vorteil             | Geringere Bundle-Gr√∂√üe, schnellerer Start    |
| Voraussetzung       | Nur f√ºr **Default-Exports** geeignet         |

---

## üîó Quellen

- [MDN ‚Äì Dynamic import()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#dynamic_imports)  
- [React Docs ‚Äì Lazy Loading](https://react.dev/learn/code-splitting)  
- [React.lazy() ‚Äì API](https://react.dev/reference/react/lazy)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

153. ### <a name="153"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

154. ### <a name="154"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

155. ### <a name="155"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

156. ### <a name="156"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

157. ### <a name="157"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

158. ### <a name="158"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

159. ### <a name="159"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

160. ### <a name="160"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

161. ### <a name="161"></a> Was ist der Unterschied zwischen interface und type in TypeScript?

# Was ist der Unterschied zwischen `interface` und `type` in TypeScript?

Sowohl `interface` als auch `type` dienen in TypeScript zur **Definition von Strukturen** f√ºr Objekte,  
Funktionen oder andere Typen.  
‚û°Ô∏è In vielen F√§llen sind sie **austauschbar**, aber es gibt **wichtige Unterschiede**.

---

## ‚úÖ Gemeinsamkeiten

Beide k√∂nnen verwendet werden, um **Objektformen** zu beschreiben:

```ts
interface Person {
  name: string;
  age: number;
}

type PersonType = {
  name: string;
  age: number;
};
```

Beide k√∂nnen **f√ºr Funktionen** verwendet werden:

```ts
interface SayHi {
  (name: string): string;
}

type SayHiType = (name: string) => string;
```

---

## üîç Unterschiede im Detail

| Aspekt               | `interface`                                  | `type`                                         |
|----------------------|-----------------------------------------------|------------------------------------------------|
| Erweiterung          | `extends` ‚Äì mehrfach erweiterbar             | `&` ‚Äì Intersection f√ºr Kombination             |
| Zusammenf√ºhrbarkeit  | ‚úÖ Automatisches Merging                      | ‚ùå Kein Merging m√∂glich                        |
| Union / Intersection | ‚ùå Nur √ºber Vererbung                        | ‚úÖ `A | B`, `A & B` m√∂glich                    |
| Verwendung f√ºr Primitives | ‚ùå Nicht erlaubt                          | ‚úÖ `type ID = string | number;`                |
| Lesbarkeit im Compiler | üëå besser geeignet f√ºr IntelliSense         | weniger sichtbar in komplexen Typen            |

---

## üß™ Beispiel: Interface Merging

```ts
interface User {
  name: string;
}

interface User {
  age: number;
}

// Merged automatisch zu:
const u: User = {
  name: 'Anna',
  age: 30,
};
```

Mit `type` w√§re das ein Fehler:

```ts
type User = {
  name: string;
};

type User = {
  age: number;
}; // ‚ùå Fehler: Duplicate Identifier
```

---

## üìå Wann welches?

| Anwendungsfall                  | Empfehlung         |
|----------------------------------|--------------------|
| √ñffentliche API (Libraries)     | `interface`        |
| Kombinationen, Unions           | `type`             |
| Erweiterung von Komponenten     | `interface`        |
| Primitive oder komplexe Typkombination | `type`     |

---

## üìù Zusammenfassung

| `interface`                     | `type`                                      |
|----------------------------------|---------------------------------------------|
| Gut f√ºr OOP & Vererbung         | Flexibel f√ºr Kombinationen & Unions         |
| Unterst√ºtzt automatische Merges | Keine Mehrfachdefinition erlaubt            |
| Empfohlen f√ºr Klassen & Props   | Empfohlen f√ºr komplexe Typdefinitionen      |

---

## üîó Quellen

- [TypeScript: Interfaces](https://www.typescriptlang.org/docs/handbook/interfaces.html)  
- [TypeScript: Advanced Types](https://www.typescriptlang.org/docs/handbook/advanced-types.html)  
- [Type vs Interface ‚Äì offizielle Empfehlung](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#interfaces)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

162. ### <a name="162"></a> Wie typisiert man Props und State in einer funktionalen Komponente?

# Wie typisiert man Props und State in einer funktionalen Komponente (TypeScript)?

In TypeScript kannst du Props und State in funktionalen React-Komponenten mithilfe von **Generics**  
und eigenen **Interfaces oder Typen** explizit typisieren.

---

## ‚úÖ 1. Props typisieren

```tsx
type UserProps = {
  name: string;
  age: number;
};

const UserCard: React.FC<UserProps> = ({ name, age }) => {
  return (
    <div>
      <h2>{name}</h2>
      <p>{age} Jahre alt</p>
    </div>
  );
};
```

> `React.FC<Props>` enth√§lt automatisch `children` und `FunctionComponent`-Typisierung.

Alternativ ohne `React.FC`:

```tsx
const UserCard = ({ name, age }: UserProps) => {
  return <p>{name} ({age})</p>;
};
```

---

## ‚úÖ 2. State typisieren mit `useState`

```tsx
import { useState } from 'react';

const Counter = () => {
  const [count, setCount] = useState<number>(0);

  return (
    <button onClick={() => setCount(count + 1)}>
      Klicks: {count}
    </button>
  );
};
```

üî∏ F√ºr komplexe State-Objekte:

```tsx
type Todo = {
  id: number;
  text: string;
  completed: boolean;
};

const TodoList = () => {
  const [todos, setTodos] = useState<Todo[]>([]);
  // todos: Array von Todo-Objekten
};
```

---

## üß† Best Practices

| Bereich     | Empfehlung                                      |
|-------------|-------------------------------------------------|
| Props       | Interface oder Type erstellen                   |
| State       | Typen direkt in `useState<T>()` angeben         |
| React.FC    | Optional, aber gut f√ºr automatische `children`  |

---

## üìù Zusammenfassung

| Typisierung | Beispiel                                       |
|-------------|------------------------------------------------|
| Props       | `type Props = { name: string }`               |
| State       | `useState<number>(0)` oder `useState<Todo[]>()` |
| Vorteil     | Typsicherheit, bessere DX, Autovervollst√§ndigung |

---

## üîó Quellen

- [React mit TypeScript ‚Äì Props & State](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example/)  
- [TypeScript: React.FC vs normales Function Props Typing](https://www.typescriptlang.org/docs/handbook/react.html)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

163. ### <a name="163"></a> Wie nutzt man Generics in React mit TypeScript (z. B. f√ºr Listen)?

# Wie nutzt man Generics in React mit TypeScript? (z.‚ÄØB. f√ºr Listen)

**Generics** erlauben es dir, Komponenten in React **flexibel und wiederverwendbar** zu gestalten,  
indem du den Typ der Daten **zur Laufzeit bestimmst**, ohne ihn fest zu codieren.

‚û°Ô∏è Besonders n√ºtzlich f√ºr **Listen, Tabellen, Formulare, Dropdowns**, u.‚ÄØv.‚ÄØm.

---

## üß± Beispiel: Generische `List`-Komponente

```tsx
type ListProps<T> = {
  items: T[];
  renderItem: (item: T) => React.ReactNode;
};

function List<T>({ items, renderItem }: ListProps<T>) {
  return (
    <ul>
      {items.map((item, index) => (
        <li key={index}>{renderItem(item)}</li>
      ))}
    </ul>
  );
}
```

‚úÖ `T` ist der **generische Typ**  
‚úÖ `items: T[]` ist ein Array beliebiger Typen  
‚úÖ `renderItem` definiert, **wie ein Element gerendert wird**

---

## üîç Verwendung mit verschiedenen Typen

### üßç Beispiel 1: Liste von Benutzern

```tsx
type User = {
  id: number;
  name: string;
};

const users: User[] = [
  { id: 1, name: 'Anna' },
  { id: 2, name: 'Tom' },
];

<List
  items={users}
  renderItem={(user) => <span>{user.name}</span>}
/>
```

### üì¶ Beispiel 2: Liste von Zahlen

```tsx
const zahlen = [1, 2, 3];

<List
  items={zahlen}
  renderItem={(n) => <strong>{n}</strong>}
/>
```

---

## üß† Vorteile von Generics in React

| Vorteil                   | Beschreibung                                 |
|----------------------------|----------------------------------------------|
| üîÅ Wiederverwendbarkeit    | Komponente funktioniert mit jedem Typ        |
| ‚úÖ Typsicherheit           | Keine `any`-Typen, volle Autovervollst√§ndigung |
| üß© Kombinierbar mit Props  | Flexible, starke Komponenten m√∂glich         |

---

## üìù Zusammenfassung

| Element     | Beschreibung                                |
|-------------|---------------------------------------------|
| `T`         | Platzhalter f√ºr einen konkreten Typ         |
| `List<T>`   | Komponente mit generischem Datentyp         |
| Vorteil     | Wiederverwendbare & typsichere Komponenten  |

---

## üîó Quellen

- [TypeScript ‚Äì Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)  
- [React + TS ‚Äì Generische Komponenten](https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase#generic-components)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

164. ### <a name="164"></a> Wie typisiert man Events in React mit TypeScript (onChange, onClick, FormEvent, MouseEvent)?

# Wie typisiert man Events in React mit TypeScript?  
(z.‚ÄØB. `onChange`, `onClick`, `FormEvent`, `MouseEvent`)

In TypeScript kannst du Events in React pr√§zise typisieren,  
um Typsicherheit bei Event-Handlern wie `onClick`, `onChange`, `onSubmit` usw. zu gew√§hrleisten.

---

## ‚úÖ H√§ufige Event-Typen

| Event                | Typ                                                  |
|----------------------|------------------------------------------------------|
| `onClick`            | `React.MouseEvent<HTMLButtonElement>`               |
| `onChange`           | `React.ChangeEvent<HTMLInputElement>`               |
| `onSubmit`           | `React.FormEvent<HTMLFormElement>`                  |
| `onKeyDown`          | `React.KeyboardEvent<HTMLInputElement>`             |

---

## üì¶ Beispiele

### üñ± `onClick` mit Button

```tsx
const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {
  console.log('Button geklickt');
};

<button onClick={handleClick}>Klick mich</button>
```

---

### üî§ `onChange` mit Input-Feld

```tsx
const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
  console.log(e.target.value);
};

<input type="text" onChange={handleChange} />
```

---

### üì© `onSubmit` bei Formular

```tsx
const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
  e.preventDefault();
  console.log('Formular abgeschickt');
};

<form onSubmit={handleSubmit}>
  <button type="submit">Senden</button>
</form>
```

---

### ‚å®Ô∏è `onKeyDown` bei Texteingabe

```tsx
const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
  if (e.key === 'Enter') {
    console.log('Enter gedr√ºckt');
  }
};

<input type="text" onKeyDown={handleKeyDown} />
```

---

## üß† Tipp: Generische Schreibweise (optional)

```tsx
const handleClick = <T extends HTMLElement>(
  e: React.MouseEvent<T>
) => {
  console.log(e.currentTarget);
};
```

---

## üìù Zusammenfassung

| Event-Typ                  | React-Typ                                       |
|-----------------------------|-------------------------------------------------|
| Button-Klick (`onClick`)    | `React.MouseEvent<HTMLButtonElement>`          |
| Texteingabe (`onChange`)    | `React.ChangeEvent<HTMLInputElement>`          |
| Formular-Abgabe (`onSubmit`)| `React.FormEvent<HTMLFormElement>`             |
| Tastatur (`onKeyDown`)      | `React.KeyboardEvent<HTMLInputElement>`        |

---

## üîó Quellen

- [React TypeScript Cheatsheet ‚Äì Events](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/events/)  
- [TypeScript Handbook ‚Äì React Events](https://www.typescriptlang.org/docs/handbook/react.html)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

165. ### <a name="165"></a> Wie erstellt man einen benutzerdefinierten Hook mit TypeScript?

# Wie erstellt man einen benutzerdefinierten Hook mit TypeScript?

Ein **benutzerdefinierter Hook** (Custom Hook) ist eine Funktion,  
die React-Hooks verwendet und eine **wiederverwendbare Logik** kapselt.  
Mit TypeScript kannst du ihn **typisieren**, um Typsicherheit und Autovervollst√§ndigung zu erhalten.

---

## ‚úÖ Beispiel: useLocalStorage-Hook

```tsx
import { useState, useEffect } from 'react';

function useLocalStorage<T>(key: string, initialValue: T) {
  const [value, setValue] = useState<T>(() => {
    try {
      const item = localStorage.getItem(key);
      return item ? (JSON.parse(item) as T) : initialValue;
    } catch (error) {
      console.warn('Fehler beim Lesen aus localStorage', error);
      return initialValue;
    }
  });

  useEffect(() => {
    try {
      localStorage.setItem(key, JSON.stringify(value));
    } catch (error) {
      console.warn('Fehler beim Schreiben in localStorage', error);
    }
  }, [key, value]);

  return [value, setValue] as const;
}
```

---

## üì¶ Verwendung

```tsx
const [username, setUsername] = useLocalStorage<string>('username', 'Gast');

<input
  value={username}
  onChange={(e) => setUsername(e.target.value)}
/>
```

---

## üîç Erkl√§rung

| Teil                       | Bedeutung                                     |
|----------------------------|-----------------------------------------------|
| `useLocalStorage<T>`       | Generischer Hook, der mit beliebigem Typ funktioniert |
| `initialValue: T`          | Startwert wird als Typ √ºbergeben              |
| `as const`                 | R√ºckgabe-Tuple ist readonly & typensicher     |

---

## üß† Typische Einsatzbereiche f√ºr Custom Hooks

- `useWindowSize` ‚Äì Fensterbreite/-h√∂he verfolgen  
- `useDebounce` ‚Äì Werte verz√∂gert weitergeben  
- `usePrevious` ‚Äì Vorherigen Wert merken  
- `useForm` ‚Äì Formular-Handling kapseln  
- `useFetch` ‚Äì API-Daten abrufen  

---

## üìù Zusammenfassung

| Element             | Beschreibung                            |
|---------------------|------------------------------------------|
| Custom Hook         | Wiederverwendbare Logik mit Hooks        |
| TypeScript Support  | Generische Parameter und R√ºckgabetypen   |
| Vorteil             | Kapselung, Typensicherheit, Wiederverwendbarkeit |

---

## üîó Quellen

- [React ‚Äì Custom Hooks](https://react.dev/learn/reusing-logic-with-custom-hooks)  
- [TypeScript ‚Äì Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)  
- [React TypeScript Cheatsheet ‚Äì Custom Hooks](https://react-typescript-cheatsheet.netlify.app/docs/advanced/hooks/)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

166. ### <a name="166"></a> Wie typisiert man useReducer mit TypeScript?

# Wie typisiert man `useReducer` mit TypeScript?

`useReducer` ist ein React-Hook zur **Verwaltung komplexer Zustandslogik**.  
Mit TypeScript kannst du die **State- und Action-Typen** exakt definieren, um Typsicherheit zu garantieren.

---

## ‚úÖ Grundstruktur mit TypeScript

```tsx
import { useReducer } from 'react';

// 1. State-Typ
type CounterState = {
  count: number;
};

// 2. Action-Typen (Union)
type CounterAction =
  | { type: 'increment' }
  | { type: 'decrement' }
  | { type: 'reset'; payload: number };

// 3. Reducer
function counterReducer(state: CounterState, action: CounterAction): CounterState {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    case 'reset':
      return { count: action.payload };
    default:
      return state;
  }
}

// 4. Verwendung
function Counter() {
  const [state, dispatch] = useReducer(counterReducer, { count: 0 });

  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: 'increment' })}>+</button>
      <button onClick={() => dispatch({ type: 'decrement' })}>‚àí</button>
      <button onClick={() => dispatch({ type: 'reset', payload: 0 })}>Reset</button>
    </div>
  );
}
```

---

## üß† Was wird hier typisiert?

| Element        | Beschreibung                             |
|----------------|------------------------------------------|
| `CounterState` | Struktur des States                      |
| `CounterAction`| M√∂gliche Aktionen als Union-Typ          |
| `useReducer`   | bekommt typisiertes `state` und `action` |

---

## üß© Generischer Reducer-Hook

```tsx
function useGenericReducer<S, A>(
  reducer: (state: S, action: A) => S,
  initialState: S
): [S, React.Dispatch<A>] {
  return useReducer(reducer, initialState);
}
```

---

## üìù Zusammenfassung

| Schritt              | Was wird gemacht                          |
|----------------------|-------------------------------------------|
| `type State`         | Definiert die Struktur des States         |
| `type Action`        | Legt alle m√∂glichen Aktionen fest         |
| `useReducer`         | Erh√§lt `reducer`-Funktion und Startwert   |
| Vorteil              | Saubere Trennung von Logik und UI         |

---

## üîó Quellen

- [React ‚Äì useReducer](https://react.dev/reference/react/useReducer)  
- [TypeScript ‚Äì Typisierung von useReducer](https://react-typescript-cheatsheet.netlify.app/docs/advanced/hooks/#usereducer)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

167. ### <a name="167"></a> Wie typisiert man children korrekt in React-Komponenten?

# Wie typisiert man `children` korrekt in React-Komponenten? (TypeScript)

In React ist `children` ein spezielles Prop, das automatisch √ºbergeben wird,  
wenn **JSX-Inhalte zwischen √ñffnungs- und Schlie√ü-Tags** einer Komponente stehen.

Mit TypeScript kannst du `children` explizit typisieren, um **Typsicherheit** und **bessere Autovervollst√§ndigung** zu erhalten.

---

## ‚úÖ Standard-Typ f√ºr `children`

```tsx
type MyComponentProps = {
  children: React.ReactNode;
};

const MyComponent = ({ children }: MyComponentProps) => {
  return <div>{children}</div>;
};
```

‚û°Ô∏è `React.ReactNode` erlaubt Strings, Zahlen, JSX, Arrays, `null`, `undefined` usw.

---

## üß† Alternativen zu `React.ReactNode`

| Typ                | Beschreibung                                         |
|--------------------|------------------------------------------------------|
| `ReactNode`        | Alles, was in JSX verwendet werden kann              |
| `ReactElement`     | Nur **ein einzelnes JSX-Element**                    |
| `JSX.Element`      | Alias f√ºr `ReactElement`                             |
| `ReactChild`       | Nur string, number, JSX.Element                      |
| `ReactNode[]`      | Nur Array von JSX (nicht `null`, `undefined` etc.)   |

---

## üì¶ Beispiel mit mehreren Props

```tsx
type CardProps = {
  title: string;
  children: React.ReactNode;
};

const Card = ({ title, children }: CardProps) => (
  <div className="border p-4">
    <h2>{title}</h2>
    <div>{children}</div>
  </div>
);
```

üìå Verwendung:

```tsx
<Card title="Info">
  <p>Das ist Inhalt innerhalb von `children`.</p>
</Card>
```

---

## üîÑ Mit `React.FC` (automatisch `children` enthalten)

```tsx
const Layout: React.FC = ({ children }) => {
  return <main>{children}</main>;
};
```

‚û°Ô∏è Vorteil: Kein eigener Typ f√ºr `children` notwendig.  
‚û°Ô∏è Nachteil: `React.FC` hat Einschr√§nkungen bei generischen Props und `defaultProps`.

---

## üìù Zusammenfassung

| Ziel                | Empfehlung                         |
|---------------------|-------------------------------------|
| Beliebige Inhalte   | `children: React.ReactNode`         |
| Nur ein Element     | `children: React.ReactElement`      |
| Automatisch (optional) | `React.FC` verwenden             |

---

## üîó Quellen

- [React ‚Äì Children Props](https://react.dev/learn/passing-props-to-a-component#passing-jsx)  
- [React TypeScript Cheatsheet ‚Äì Children](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example/#typing-children)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

168. ### <a name="168"></a> Was ist React.FC und welche Vor- und Nachteile hat es?

# Was ist `React.FC` und welche Vor- und Nachteile hat es?

`React.FC` (oder `React.FunctionComponent`) ist ein generischer Typ in TypeScript,  
der zur Typisierung von **funktionalen Komponenten** verwendet wird.  
Er ist besonders hilfreich, wenn man **`children` automatisch typisieren** m√∂chte.

---

## ‚úÖ Syntax

```tsx
const MyComponent: React.FC = () => {
  return <div>Hallo</div>;
};
```

Mit Props:

```tsx
type Props = {
  title: string;
};

const Header: React.FC<Props> = ({ title, children }) => (
  <header>
    <h1>{title}</h1>
    {children}
  </header>
);
```

---

## üì¶ Was bringt `React.FC`?

| Funktion                 | Beschreibung                               |
|--------------------------|--------------------------------------------|
| ‚úÖ Automatisch `children`| Kein manuelles Hinzuf√ºgen von `children`  |
| ‚úÖ Generische Props      | √úbergabe von Typen an die Komponente       |
| ‚úÖ Intellisense          | Automatische Vorschl√§ge in VSCode etc.     |

---

## ‚ö†Ô∏è Nachteile von `React.FC`

| Problem                                 | Beschreibung                                  |
|------------------------------------------|-----------------------------------------------|
| ‚ùå Eingeschr√§nkte Generics               | Komplexe Props schwer typisierbar              |
| ‚ùå `defaultProps` wird nicht korrekt unterst√ºtzt | TypeScript erkennt sie nicht automatisch   |
| ‚ùå Zwingt `children`                    | Auch wenn Komponente keine `children` erwartet |

---

## üß† Best Practices

| Situation                       | Empfehlung                   |
|----------------------------------|------------------------------|
| Mit `children`                  | `React.FC` ist praktisch     |
| Ohne `children`                 | Besser eigenes Props-Interface |
| Gro√üe/generische Komponenten   | Lieber eigene Typisierung     |

---

## üîç Vergleich mit manuellem Props-Typ

```tsx
type Props = {
  name: string;
};

const Hello = ({ name }: Props) => <p>Hallo {name}</p>;
```

‚û°Ô∏è Kein `children`, aber volle Kontrolle.  
‚û°Ô∏è Mehr Flexibilit√§t bei Generics.

---

## üìù Zusammenfassung

| Vorteil (`React.FC`)       | Nachteil                              |
|----------------------------|----------------------------------------|
| Automatische `children`    | Eingeschr√§nkte Flexibilit√§t            |
| Klarer Funktions-Typ       | Probleme mit `defaultProps` und Generics |

---

## üîó Quellen

- [React.FC ‚Äì Diskussion auf GitHub](https://github.com/facebook/create-react-app/pull/8177)  
- [React TypeScript Cheatsheet ‚Äì React.FC](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/function_components/)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

169. ### <a name="169"></a> Wie typisiert man eine Komponente mit optionalen Props?

# Wie typisiert man eine Komponente mit **optionalen Props** in TypeScript?

In TypeScript kannst du Props als **optional** deklarieren,  
indem du ein **Fragezeichen (`?`)** hinter dem Namen eines Props setzt.

---

## ‚úÖ Beispiel mit optionalem Prop

```tsx
type ButtonProps = {
  label: string;
  color?: string; // optional
};

const Button = ({ label, color = 'blue' }: ButtonProps) => {
  return <button className={`bg-${color}-500 text-white p-2`}>{label}</button>;
};
```

üìå `color` ist optional. Wenn es nicht √ºbergeben wird, nutzt die Komponente `"blue"` als Default.

---

## üß† Warum `color = 'blue'`?

Das ist der **Default-Wert** in der Funktion.  
Wird `color` nicht √ºbergeben, verwendet React automatisch den angegebenen Fallback.

---

## üí° Mit `React.FC` (funktioniert auch)

```tsx
type AlertProps = {
  message?: string;
};

const Alert: React.FC<AlertProps> = ({ message }) => {
  return <div>{message ?? 'Standard-Nachricht'}</div>;
};
```

---

## üß™ Mit `children` und optionalen Props

```tsx
type CardProps = {
  title?: string;
  children: React.ReactNode;
};

const Card = ({ title, children }: CardProps) => (
  <div className="p-4 border">
    {title && <h2>{title}</h2>}
    {children}
  </div>
);
```

---

## üìù Zusammenfassung

| Merkmal                  | Beschreibung                                 |
|--------------------------|----------------------------------------------|
| `propName?: type`        | Macht das Prop optional                      |
| `propName = value`       | Setzt einen Default-Wert innerhalb der Funktion |
| Vorteil                  | Flexible Verwendung, saubere Komponenten     |

---

## üîó Quellen

- [TypeScript ‚Äì Optional Properties](https://www.typescriptlang.org/docs/handbook/2/objects.html#optional-properties)  
- [React TypeScript Cheatsheet ‚Äì Props](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example/)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

170. ### <a name="170"></a> Wie arbeitet man mit Drittanbieter-Bibliotheken, die keine Typen enthalten?

# Wie arbeitet man mit Drittanbieter-Bibliotheken, die **keine Typen** enthalten?

Wenn eine JavaScript-Bibliothek **keine TypeScript-Typen** bereitstellt,  
kannst du sie trotzdem verwenden ‚Äì mithilfe von:

1. üß© **@types/**-Paketen  
2. üß® **declare module**  
3. üß† Eigene Typdefinitionen schreiben  

---

## ‚úÖ 1. Pr√ºfen, ob es ein `@types/`-Paket gibt

Viele Bibliotheken haben ein **extern gepflegtes Typ-Paket**:

```bash
npm install --save-dev @types/lodash
```

üì¶ Quelle: https://github.com/DefinitelyTyped/DefinitelyTyped

---

## ‚ùå 2. Wenn keine Typen existieren: `declare module`

Erstelle z.‚ÄØB. eine Datei `src/types/thirdparty.d.ts`:

```ts
declare module 'untypisierte-lib' {
  const content: any;
  export default content;
}
```

‚û°Ô∏è Damit kannst du das Modul **ohne Typsicherheitsfehler** importieren:

```ts
import foo from 'untypisierte-lib';
```

---

## ‚úçÔ∏è 3. Eigene Typen definieren (besser als `any`)

```ts
declare module 'untypisierte-lib' {
  export function greet(name: string): string;
  export const version: string;
}
```

‚û°Ô∏è Nun bekommst du **Autovervollst√§ndigung & Typsicherheit** beim Import:

```ts
import { greet } from 'untypisierte-lib';
greet('Sergii');
```

---

## üß† Typ "any" vermeiden

```ts
import xyz from 'legacy-lib';
// schlechter Stil:
(xyz as any).doSomething(); // ‚õîÔ∏è Keine Typsicherheit!
```

‚úÖ Besser: Eigene Schnittstellen oder Typen definieren!

---

## üìù Zusammenfassung

| Schritt                | Vorgehen                                                  |
|------------------------|-----------------------------------------------------------|
| ‚úÖ Pr√ºfen auf `@types/` | `npm i -D @types/libname`                                |
| üî® Kein Typ vorhanden   | `declare module 'lib' {}` verwenden                      |
| ‚úçÔ∏è Eigenes Typing       | Besser als `any`, mehr Kontrolle                         |
| üîê Ziel                 | Typsicherheit und bessere Entwicklererfahrung            |

---

## üîó Quellen

- [TypeScript ‚Äì Declaration Files](https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html)  
- [DefinitelyTyped Repo](https://github.com/DefinitelyTyped/DefinitelyTyped)  
- [Using Non-TypeScript Libraries](https://www.typescriptlang.org/docs/handbook/modules.html#ambient-modules)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

171. ### <a name="171"></a> Was ist der Unterschied zwischen ESM und CommonJS?

# Was ist der Unterschied zwischen **ESM** und **CommonJS**?

**ESM (ECMAScript Modules)** und **CommonJS (CJS)** sind zwei unterschiedliche **Modulsysteme** in JavaScript.  
Sie definieren, **wie Code importiert und exportiert wird** ‚Äì besonders wichtig bei der Arbeit mit Node.js und modernen Frontend-Bundlern.

---

## ‚úÖ √úbersicht

| Merkmal              | ESM                                 | CommonJS                           |
|----------------------|--------------------------------------|-------------------------------------|
| Einf√ºhrung           | Offizieller JS-Standard (ES6)        | Node.js-spezifisch (√§lter)         |
| Syntax               | `import` / `export`                  | `require()` / `module.exports`     |
| Ausf√ºhrung           | statisch analysierbar                | dynamisch zur Laufzeit             |
| Dateiendung (Node.js)| `.mjs` oder `"type": "module"`       | `.cjs` oder keine spezielle Angabe |
| Tree Shaking         | ‚úÖ m√∂glich                           | ‚ùå nicht zuverl√§ssig                |
| Verwendung           | Frontend + modernes Node.js          | Klassisches Node.js                |

---

## üì¶ Beispiel: Import / Export

### ESM

```js
// math.js
export const add = (a, b) => a + b;

// index.js
import { add } from './math.js';
```

### CommonJS

```js
// math.js
exports.add = (a, b) => a + b;

// index.js
const { add } = require('./math');
```

---

## üîÅ Interoperabilit√§t (CJS ‚Üî ESM)

- In Node.js ist **Mischen m√∂glich**, aber **kompliziert**  
- `import` kann **keine CJS-Datei mit `default`** direkt lesen  
- Viele Tools (z.‚ÄØB. Webpack, Vite) unterst√ºtzen **beide Formate**

---

## üß† Wann was nutzen?

| Situation                         | Empfehlung        |
|-----------------------------------|-------------------|
| Neues Projekt mit Bundler         | **ESM**           |
| Legacy-Node.js ohne Transpiler    | **CommonJS**      |
| Bibliothek mit Tree Shaking       | **ESM bevorzugt** |

---

## üìù Zusammenfassung

| ESM                  | CommonJS              |
|----------------------|------------------------|
| `import/export`      | `require/module.exports` |
| Modern & standardisiert | Node.js-spezifisch (√§lter) |
| Tree Shaking m√∂glich | Kein Tree Shaking      |

---

## üîó Quellen

- [MDN ‚Äì Modules: ES6](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules)  
- [Node.js ‚Äì CommonJS vs ESM](https://nodejs.org/api/esm.html)  
- [ESM vs CJS ‚Äì Differences](https://blog.logrocket.com/esm-vs-commonjs-node-js/)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

172. ### <a name="172"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

173. ### <a name="173"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

174. ### <a name="174"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

175. ### <a name="175"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

176. ### <a name="176"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

177. ### <a name="177"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

178. ### <a name="178"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

179. ### <a name="179"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

180. ### <a name="180"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

181. ### <a name="181"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

182. ### <a name="182"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

183. ### <a name="183"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

184. ### <a name="184"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

185. ### <a name="185"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

186. ### <a name="186"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

187. ### <a name="187"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

188. ### <a name="188"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

189. ### <a name="189"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

190. ### <a name="190"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

191. ### <a name="191"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

192. ### <a name="192"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

193. ### <a name="193"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

194. ### <a name="194"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

195. ### <a name="195"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

196. ### <a name="196"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

197. ### <a name="197"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

198. ### <a name="198"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

199. ### <a name="199"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

200. ### <a name="200"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**      
