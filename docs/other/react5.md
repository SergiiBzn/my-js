<a name="top"></a>

[На главную](../../README.md)

[Перейти к вопросам](#questions)

| №. | Вопрос |
| --- | --------- |
|   | ReactJS Grundlagen |
|1 | [Was ist React und welche Probleme löst es?](#1) |
|2 | [Was ist JSX und warum wird es verwendet?](#2) |
|3 | [Was ist Virtual DOM und wie funktioniert es?](#3) |
|4 | [Was ist der Unterschied zwischen React und ReactDOM?](#4) |
|5 | [Warum importieren wir React, auch wenn es scheinbar nicht benutzt wird?](#5) |
|6 | [Was ist ein React Fragment und warum ist es nützlich?](#6) |
|7 | [Was ist der Unterschied zwischen einem Element, einer Komponente und einer Instanz?](#7) |
|8 | [Was ist das Fiber-Architekturmodell in React?](#8) |
|9 | [Was bedeutet „Batching“ in React?](#9) |
|10 | [Was ist die Rolle des key in React-Listen?](#10) |
|11 | [Wie funktioniert die Wiederverwendung von Komponenten?](#11) |
|12 | [](#12) |
|13 | [](#13) |
|14 | [](#14) |
|15 | [](#15) |
|16 | [](#16) |
|17 | [](#17) |
|18 | [](#18) |
|19 | [](#19) |
|20 | [](#20) |
|   | Komponenten, Props & State |
|21 | [Was sind Props und wozu werden sie verwendet?](#21) |
|22 | [Was ist der Unterschied zwischen Props und State?](#22) |
|23 | [Warum sind Props nur lesbar?](#23) |
|24 | [Wie funktioniert der unidirektionale Datenfluss in React?](#24) |
|25 | [Was ist State in Klassen- und Funktionskomponenten?](#25) |
|26 | [Wie funktioniert setState?](#26) |
|27 | [Was ist der Unterschied zwischen kontrollierten und unkontrollierten Komponenten?](#27) |
|28 | [Was sind Default Props und PropTypes?](#28) |
|29 | [Was ist React.memo und wofür wird es verwendet?](#29) |
|30 | [Was ist PureComponent und wie unterscheidet es sich von Component?](#30) |
|31 | [Wann sollte shouldComponentUpdate verwendet werden?](#31) |
|32 | [Was ist ein ref und wann wird er eingesetzt?](#32) |
|33 | [Was bedeutet „Lifting State Up“?](#33) |
|34 | [](#34) |
|35 | [](#35) |
|36 | [](#36) |
|37 | [](#37) |
|38 | [](#38) |
|39 | [](#39) |
|40 | [](#40) |
|   | Lebenszyklus von Komponenten |
|41 | [Was sind die Phasen des Komponentenlebenszyklus?](#41) |
|42 | [Welche Lifecycle-Methoden gibt es in Klassenkomponenten?](#42) |
|43 | [Welche Lifecycle-Methoden sind veraltet?](#43) |
|44 | [Wie kann man Lifecycle-Methoden mit Hooks ersetzen?](#44) |
|45 | [Was ist componentDidMount und was ist das Äquivalent mit Hooks?](#45) |
|46 | [](#46) |
|47 | [](#47) |
|48 | [](#48) |
|49 | [](#49) |
|50 | [](#50) |
|   | Hooks |
|51 | [Was sind Hooks in React?](#51) |
|52 | [Wie funktionieren useState und useEffect?](#52) |
|53 | [Was macht useContext?](#53) |
|54 | [Was ist useRef und wann wird es verwendet?](#54) |
|55 | [Was ist useCallback, useMemo, useReducer?](#55) |
|56 | [Wie schreibt man einen benutzerdefinierten Hook?](#56) |
|57 | [Wie verhindert man eine Endlosschleife in useEffect?](#57) |
|58 | [Wie implementiert man Timeout oder Interval mit Hooks?](#58) |
|59 | [](#59) |
|60 | [](#60) |
|   | React-Patterns und Konzepte |
|61 | [Was ist ein Higher-Order Component (HOC)?](#61) |
|62 | [Was ist das Render-Prop-Pattern?](#62) |
|63 | [Was ist die Context-API und wie funktioniert useContext?](#63) |
|64 | [Was sind Portale in React?](#64) |
|65 | [Was ist bedingtes Rendern (Conditional Rendering)?](#65) |
|66 | [Was ist ein Error Boundary?](#66) |
|67 | [Wie funktioniert Event-Handling in React?](#67) |
|68 | [Was ist ein synthetisches Ereignis (SyntheticEvent)?](#68) |
|69 | [Was ist props.children?](#69) |
|70 | [Was bedeutet „controlled component“ und „uncontrolled component“ bei Formularen?](#70) |
|71 | [](#71) |
|72 | [](#72) |
|73 | [](#73) |
|74 | [](#74) |
|75 | [](#75) |
|   | Daten & API |
|76 | [Wie führt man API-Aufrufe mit Fetch oder Axios durch?](#76) |
|77 | [Wie verwaltet man Lade-, Fehler- und Erfolgsstatus?](#77) |
|78 | [Wie funktioniert WebSocket mit React?](#78) |
|79 | [Wie kann man Daten zwischen Komponenten weitergeben?](#79) |
|80 | [Wie macht man einen Datenabruf nur beim ersten Rendern?](#80) |
|81 | [Was ist das Problem bei „stale closures“ mit Hooks?](#81) |
|82 | [Wie funktioniert die Fehlerbehandlung mit try/catch in React?](#82) |
|83 | [Wie kann man ein Mock-API oder Mock Server verwenden?](#83) |
|84 | [Wie funktioniert Suspense für Datenabfragen?](#84) |
|85 | [](#85) |
|86 | [](#86) |
|87 | [](#87) |
|88 | [](#88) |
|89 | [](#89) |
|90 | [](#90) |
|   | Testing |
|91 | [Was ist Unit-, Integration- und E2E-Testing?](#91) |
|92 | [Was ist Snapshot-Testing?](#92) |
|93 | [Welche Tools nutzt man für React-Tests (Jest, React Testing Library)?](#93) |
|94 | [Wie testet man Komponenten, Props und Events?](#94) |
|95 | [Wie testet man benutzerdefinierte Hooks?](#95) |
|96 | [](#96) |
|97 | [](#97) |
|98 | [](#98) |
|99 | [](#99) |
|100 | [](#100) |
|   | Routing mit React Router |
|101 | [Wie funktioniert Routing in React mit react-router-dom?](#101) |
|102 | [Was sind die Unterschiede zwischen react-router v5 und v6?](#102) |
|103 | [Was sind Route, Link, Navigate, Outlet?](#103) |
|104 | [Wie erstellt man Nested Routes?](#104) |
|105 | [Wie implementiert man Redirects?](#105) |
|106 | [Wie funktioniert programmgesteuerte Navigation (useNavigate)?](#106) |
|107 | [](#107) |
|108 | [](#108) |
|109 | [](#109) |
|110 | [](#110) |
|   | Redux & Redux Toolkit |
|111 | [Was ist Redux und wie funktioniert es?](#111) |
|112 | [Was sind Actions, Reducer und Store?](#112) |
|113 | [Wie funktioniert Redux Toolkit (createSlice, configureStore, createAsyncThunk)?](#113) |
|114 | [Was ist RTK Query?](#114) |
|115 | [Was ist der Unterschied zwischen Redux und der Context-API?](#115) |
|116 | [Was ist connect() in Redux?](#116) |
|117 | [Was sind Middleware in Redux (z. B. redux-thunk, redux-logger)?](#117) |
|118 | [Was ist createSelector und wie funktioniert Reselect?](#118) |
|119 | [Wie verbindet man Redux mit React über Hooks (useSelector, useDispatch)?](#119) |
|120 | [](#120) |
|121 | [](#121) |
|122 | [](#122) |
|123 | [](#123) |
|124 | [](#124) |
|125 | [](#125) |
|126 | [](#126) |
|127 | [](#127) |
|128 | [](#128) |
|129 | [](#129) |
|130 | [](#130) |
|   | Optimierung & Performance |
|131 | [Was ist Code-Splitting?](#131) |
|132 | [Wie funktionieren React.lazy und Suspense?](#132) |
|133 | [Was ist Tree Shaking?](#133) |
|134 | [Was ist Server-Side Rendering (SSR) und Hydration?](#134) |
|135 | [Wie geht man mit Hydration-Fehlern bei SSR um?](#135) |
|136 | [Was bedeutet Virtualisierung (z. B. mit react-window)?](#136) |
|137 | [Wie verhindert man unnötige Re-Renders?](#137) |
|138 | [Was ist React Transition Group?](#138) |
|139 | [Was ist React Strict Mode und welche Vorteile bietet er?](#139) |
|140 | [Was ist Concurrent Mode und welche Probleme löst er?](#140) |
|141 | [](#141) |
|142 | [](#142) |
|143 | [](#143) |
|144 | [](#144) |
|145 | [](#145) |
|   | Sonstiges |
|146 | [Was ist ein Service Worker?](#146) |
|147 | [Was ist react-helmet und wie hilft es beim SEO?](#147) |
|148 | [Wie funktioniert Lazy Loading mit dynamic import()?](#148) |
|149 | [Was ist ein Finite-State Machine (FSM), z. B. mit XState?](#149) |
|150 | [Wie kann man ein Formular mit Formik und Yup erstellen und validieren?](#150) |
|151 | [Wie konfiguriert man ESLint und Prettier in einem React-Projekt?](#151) |
|152 | [Wie funktioniert dynamic import() in React (Syntax, Anwendungsfälle)?](#152) |
|153 | [](#153) |
|154 | [](#154) |
|155 | [](#155) |
|156 | [](#156) |
|157 | [](#157) |
|158 | [](#158) |
|159 | [](#159) |
|160 | [](#160) |
|   | React + TypeScript |
|161 | [Was ist der Unterschied zwischen interface und type in TypeScript?](#161) |
|162 | [Wie typisiert man Props und State in einer funktionalen Komponente?](#162) |
|163 | [Wie nutzt man Generics in React mit TypeScript (z. B. für Listen)?](#163) |
|164 | [Wie typisiert man Events in React mit TypeScript (onChange, onClick, FormEvent, MouseEvent)?](#164) |
|165 | [Wie erstellt man einen benutzerdefinierten Hook mit TypeScript?](#165) |
|166 | [Wie typisiert man useReducer mit TypeScript?](#166) |
|167 | [Wie typisiert man children korrekt in React-Komponenten?](#167) |
|168 | [Was ist React.FC und welche Vor- und Nachteile hat es?](#168) |
|169 | [Wie typisiert man eine Komponente mit optionalen Props?](#169) |
|170 | [Wie arbeitet man mit Drittanbieter-Bibliotheken, die keine Typen enthalten?](#170) |
|171 | [Was ist der Unterschied zwischen ESM und CommonJS?](#171) |
|172 | [](#172) |
|173 | [](#173) |
|174 | [](#174) |
|175 | [](#175) |
|176 | [](#176) |
|177 | [](#177) |
|178 | [](#178) |
|179 | [](#179) |
|180 | [](#180) |
|181 | [](#181) |
|182 | [](#182) |
|183 | [](#183) |
|184 | [](#184) |
|185 | [](#185) |
|186 | [](#186) |
|187 | [](#187) |
|188 | [](#188) |
|189 | [](#189) |
|190 | [](#190) |
|191 | [](#191) |
|192 | [](#192) |
|193 | [](#193) |
|194 | [](#194) |
|195 | [](#195) |
|196 | [](#196) |
|197 | [](#197) |
|198 | [](#198) |
|199 | [](#199) |
|200 | [](#200) |



<a name="questions"></a>

## ReactJS 

  **[⬆ Наверх](#top)**
  
1. ### <a name="1"></a> Was ist React und welche Probleme löst es?

**React** ist eine **JavaScript-Bibliothek** für den Aufbau von **User Interfaces** (UI), entwickelt von Facebook (heute Meta). Sie konzentriert sich auf die **View-Schicht** (im MVC-Pattern) und löst typische Probleme moderner Frontend-Entwicklung:

### Probleme, die React löst

1. **Komplexität bei dynamischen UIs**

   * Klassisches DOM-Manipulieren mit `document.querySelector` oder `innerHTML` ist fehleranfällig und schwer zu warten.
   * React nutzt das **Virtual DOM**, um Änderungen effizient zu berechnen und nur die nötigen Teile des echten DOM zu aktualisieren.

2. **Wiederverwendbarkeit von UI-Logik**

   * In Vanilla JS oder jQuery ist es schwierig, UI-Elemente als eigenständige, wiederverwendbare Bausteine zu organisieren.
   * React bietet **Komponenten** (Functions oder Classes), die UI + Logik kapseln.

3. **State-Management**

   * Ohne Framework muss man Zustände (z. B. Eingaben, UI-Änderungen) manuell im DOM nachverfolgen.
   * React bietet ein klares **State- und Props-Konzept**: Datenfluss von oben nach unten (Top-down Data Flow) und kontrollierte Zustandsverwaltung.

4. **Lesbarkeit & Wartbarkeit**

   * Mit **JSX** verbindet React deklarative Syntax mit JavaScript, wodurch UI-Struktur dem HTML ähnelt, aber direkt in JS geschrieben wird.
   * Dadurch wird Code strukturierter, testbarer und besser wartbar.

---

### Beispiel

```jsx
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Aktueller Wert: {count}</p>
      <button onClick={() => setCount(count + 1)}>
        Erhöhen
      </button>
    </div>
  );
}

export default Counter;
```

* `useState` verwaltet den Zustand.
* Bei jedem Klick wird nur der relevante Teil des DOM aktualisiert.

---

### Zusammenfassung

* **React** = Bibliothek für deklarative UI-Entwicklung.
* Löst Probleme: ineffiziente DOM-Manipulation, fehlende Wiederverwendbarkeit, unübersichtliches State-Handling.
* Schlüsselkonzepte: **Virtual DOM, Komponenten, State, Props, JSX**.

📖 Weiterführend:

* [React Offizielle Dokumentation – Grundlagen](https://react.dev/learn)
* [MDN – Einführung in das DOM](https://developer.mozilla.org/ru/docs/Web/API/Document_Object_Model/Introduction)

---

  **[⬆ Наверх](#top)**

2. ### <a name="2"></a> Was ist JSX und warum wird es verwendet?

**JSX (JavaScript XML)** ist eine **erweiterte Syntax für JavaScript**, die es erlaubt, UI-Strukturen in einer HTML-ähnlichen Schreibweise direkt im JavaScript-Code zu definieren. JSX wird von **Babel** oder anderen Transpilern in reines JavaScript (meist `React.createElement`) übersetzt.

---

### Warum wird JSX verwendet?

1. **Deklarative UI-Beschreibung**

   * UI-Struktur sieht aus wie HTML, ist aber vollständig in JavaScript eingebettet.
   * Entwicklern fällt es leichter, die Logik und das UI zusammen zu lesen und zu verstehen.

2. **Verknüpfung von Logik und Darstellung**

   * Man kann JavaScript-Ausdrücke direkt in JSX einbetten: `{...}`.
   * Bedingte Renderings oder Schleifen lassen sich elegant integrieren.

3. **Bessere Lesbarkeit & Wartbarkeit**

   * Statt verschachtelter `React.createElement`-Aufrufe ist JSX kürzer, klarer und näher an HTML.

---

### Beispiel

```jsx
import { useState } from "react";

function Greeting() {
  const [name, setName] = useState("Sergii");

  return (
    <div>
      <h1>Hallo, {name}!</h1> {/* JS-Ausdruck in geschweiften Klammern */}
      <button onClick={() => setName("Frontend-Dev")}>
        Ändern
      </button>
    </div>
  );
}

export default Greeting;
```

Ohne JSX würde derselbe Code so aussehen:

```js
import { createElement, useState } from "react";

function Greeting() {
  const [name, setName] = useState("Sergii");

  return createElement(
    "div",
    null,
    createElement("h1", null, `Hallo, ${name}!`),
    createElement(
      "button",
      { onClick: () => setName("Frontend-Dev") },
      "Ändern"
    )
  );
}
```

---

### Zusammenfassung

* **JSX** = Syntax-Erweiterung für JavaScript, die UI-Strukturen wie HTML aussehen lässt.
* Vorteile: bessere Lesbarkeit, Integration von Logik + UI, effizienteres Arbeiten mit React.
* JSX wird in reines JavaScript transpiliert.

📖 Weiterführend:

* [React Offizielle Dokumentation – JSX](https://react.dev/learn/writing-markup-with-jsx)
* [MDN – JSX (Einführung)](https://developer.mozilla.org/ru/docs/Glossary/JSX)

---

  **[⬆ Наверх](#top)**

3. ### <a name="3"></a> Was ist Virtual DOM und wie funktioniert es?

**Virtual DOM (VDOM)** ist eine **leichte, virtuelle Repräsentation** des echten DOM im Speicher. Es dient als Zwischenschicht, um Änderungen effizient zu berechnen, bevor sie im **realen DOM** angewendet werden.

---

### Funktionsweise

1. **Rendern in den Virtual DOM**

   * Wenn sich State oder Props ändern, erzeugt React ein **neues Virtual DOM**-Baumobjekt.

2. **Diffing-Algorithmus**

   * React vergleicht den neuen VDOM mit der vorherigen Version (Reconciliation).
   * Nur die Unterschiede („diff“) werden ermittelt.

3. **Minimaler Update im echten DOM**

   * React aktualisiert nur die tatsächlich veränderten Teile im **realen DOM**.
   * Dadurch sind Updates wesentlich effizienter, da direkte DOM-Manipulationen sehr teuer sind.

---

### Beispiel

```jsx
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Zähler: {count}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
    </div>
  );
}

export default Counter;
```

* Bei `setCount` erstellt React ein neues Virtual DOM.
* React erkennt, dass nur `<p>` sich geändert hat.
* Nur dieser Knoten im echten DOM wird neu gerendert, **nicht die gesamte Seite**.

---

### Zusammenfassung

* **Virtual DOM** = virtuelles Abbild des echten DOM.
* Ablauf: **neuer VDOM → Diffing → minimaler DOM-Update**.
* Vorteil: Performance, klare Trennung von Logik und DOM-Manipulation.

📖 Weiterführend:

* [React Offizielle Dokumentation – Reconciliation](https://react.dev/learn/render-and-commit#step-2-react-renders-your-components)
* [MDN – DOM Einführung](https://developer.mozilla.org/ru/docs/Web/API/Document_Object_Model/Introduction)

---

  **[⬆ Наверх](#top)**

4. ### <a name="4"></a> Was ist der Unterschied zwischen React und ReactDOM?

**React** ist die **Kernbibliothek**, die Werkzeuge für das **Erstellen von Komponenten, State-Management, Hooks und JSX-Verarbeitung** bereitstellt.
**ReactDOM** ist das **Rendering-Paket**, das React-Komponenten mit dem **echten DOM im Browser** verbindet.

---

### Details

1. **React**

   * Definiert, **wie** UI-Komponenten aussehen und funktionieren.
   * Enthält Hooks wie `useState`, `useEffect`.
   * Ist plattformunabhängig (kann auch mit React Native, ReactDOM, ReactVR genutzt werden).

2. **ReactDOM**

   * Speziell für **Web-Umgebungen** gedacht.
   * Stellt Funktionen wie `createRoot` oder `render` bereit, um React-Komponenten in den Browser zu mounten.
   * Trennt die Logik von der konkreten Rendering-Umgebung (Browser-DOM).

---

### Beispiel

```jsx
// index.jsx
import React from "react";
import { createRoot } from "react-dom/client";
import App from "./App.jsx";

const root = createRoot(document.getElementById("root"));
root.render(<App />);
```

* `React` stellt die Komponente `App` bereit.
* `ReactDOM` sorgt dafür, dass diese Komponente im `<div id="root">` im Browser angezeigt wird.

---

### Zusammenfassung

* **React** = Kernbibliothek (Komponenten, State, Hooks).
* **ReactDOM** = Bindeglied zum echten Browser-DOM (Mounting, Rendering).
* Trennung ermöglicht, React auch außerhalb des Browsers (z. B. mit React Native) zu verwenden.

📖 Weiterführend:

* [React Offizielle Dokumentation – Einstieg](https://react.dev/learn)
* [ReactDOM API – Offizielle Docs](https://react.dev/reference/react-dom)

---

  **[⬆ Наверх](#top)**

5. ### <a name="5"></a> Warum importieren wir React, auch wenn es scheinbar nicht benutzt wird?

Früher musste man in jeder Datei mit JSX immer **`import React from "react";`** schreiben, auch wenn React im Code nicht direkt benutzt wurde.
Grund: **JSX wird von Babel in `React.createElement`-Aufrufe umgewandelt**, daher war `React` im Scope notwendig.

Seit **React 17 (2020)** wurde das durch die **neue JSX-Transform** geändert:

* Der Compiler fügt die nötigen Funktionen automatisch hinzu.
* Deshalb muss man `import React` nicht mehr explizit einfügen, wenn man nur JSX nutzt.
* In älteren Projekten oder Setups ohne neue Transform ist der Import weiterhin Pflicht.

---

### Beispiel – Babel-Umwandlung

**JSX-Eingabe:**

```jsx
const element = <h1>Hallo Welt</h1>;
```

**Transpilierte Ausgabe (vor React 17):**

```js
import React from "react";

const element = React.createElement("h1", null, "Hallo Welt");
```

**Transpilierte Ausgabe (ab React 17 mit neuer JSX-Transform):**

```js
import { jsx as _jsx } from "react/jsx-runtime";

const element = _jsx("h1", { children: "Hallo Welt" });
```

---

### Zusammenfassung

* Früher: `import React` war nötig, weil JSX → `React.createElement` kompiliert wurde.
* Heute (React 17+): Dank neuer JSX-Transform meist **nicht mehr notwendig**.
* Import wird nur gebraucht, wenn man `React` direkt nutzt (z. B. `React.Children`, `React.cloneElement`).

📖 Weiterführend:

* [React Offizielle Dokumentation – Neue JSX-Transform](https://react.dev/blog/2020/09/22/introducing-the-new-jsx-transform)
* [MDN – JSX](https://developer.mozilla.org/ru/docs/Glossary/JSX)

---

  **[⬆ Наверх](#top)**

6. ### <a name="6"></a> Was ist ein React Fragment und warum ist es nützlich?

**React Fragment** ist ein spezieller Wrapper (`<React.Fragment>` oder Kurzschreibweise `<>...</>`), mit dem man **mehrere Elemente gruppieren** kann, **ohne zusätzliches DOM-Element** (wie `<div>`) zu erzeugen.

---

### Warum nützlich?

1. **Kein unnötiges DOM-Markup**

   * `<div>`-Wrapper erzeugen oft „div soup“ und machen das DOM unübersichtlich.
   * Fragmente fügen nichts ins echte DOM ein.

2. **Mehrere Elemente zurückgeben**

   * Eine React-Komponente darf nur **ein einziges Root-Element** zurückgeben.
   * Mit Fragmenten kann man mehrere Geschwister-Elemente zurückgeben.

3. **Performance & Semantik**

   * Weniger DOM-Knoten → bessere Performance.
   * Bessere Semantik, da unnötige Container-Elemente vermieden werden.

---

### Beispiel

```jsx
import React from "react";

function UserInfo() {
  return (
    <>
      <h2>Benutzername: Sergii</h2>
      <p>Rolle: Frontend-Entwickler</p>
    </>
  );
}

export default UserInfo;
```

Ohne Fragment müsste man alles in ein `<div>` packen:

```jsx
function UserInfo() {
  return (
    <div>
      <h2>Benutzername: Sergii</h2>
      <p>Rolle: Frontend-Entwickler</p>
    </div>
  );
}
```

Ergebnis im DOM:

* Mit Fragment → nur `<h2>` und `<p>`.
* Mit `<div>` → unnötiger zusätzlicher Container.

---

### Zusammenfassung

* **React Fragment** gruppiert mehrere Elemente ohne zusätzliches DOM-Tag.
* Vorteile: sauberes DOM, bessere Semantik, kein „div soup“.
* Schreibweisen: `<React.Fragment>...</React.Fragment>` oder `<>...</>`.

📖 Weiterführend:

* [React Offizielle Dokumentation – Fragments](https://react.dev/reference/react/Fragment)

---

  **[⬆ Наверх](#top)**

7. ### <a name="7"></a> Was ist der Unterschied zwischen einem Element, einer Komponente und einer Instanz?

### Unterschied: Element, Komponente, Instanz

1. **React Element**

   * Ein **leichtes, unveränderliches Objekt**, das beschreibt, **was im UI gerendert werden soll**.
   * Wird von JSX erzeugt und dient React als Bauplan.
   * Beispiel:

   ```jsx
   const element = <h1>Hallo</h1>; // React Element
   ```

2. **React Komponente**

   * Eine **Funktion oder Klasse**, die React Elements zurückgibt.
   * Definiert **wie UI-Elemente aufgebaut sind** (Logik + Struktur).
   * Beispiel:

   ```jsx
   function Greeting() {
     return <h1>Hallo Sergii</h1>;
   }
   ```

3. **Instanz einer Komponente**

   * Entsteht, wenn React eine Komponente **rendert** und im UI einsetzt.
   * Jede Verwendung von `<Greeting />` erzeugt eine neue Instanz dieser Komponente.
   * Beispiel:

   ```jsx
   function App() {
     return (
       <>
         <Greeting />   {/* Instanz 1 */}
         <Greeting />   {/* Instanz 2 */}
       </>
     );
   }
   ```

---

### Bildhafte Erklärung

* **Element** = Bauplan/Zwischenschicht (JSX-Output).
* **Komponente** = Definition (Funktion/Klasse).
* **Instanz** = konkrete Ausprägung der Komponente im DOM.

---

### Zusammenfassung

* **Element**: unveränderliches Objekt, beschreibt UI.
* **Komponente**: Funktion/Klasse, die Elemente zurückgibt.
* **Instanz**: konkrete gerenderte Erscheinung einer Komponente.

📖 Weiterführend:

* [React Offizielle Dokumentation – Rendering Elements](https://react.dev/learn/render-and-commit)
* [MDN – Komponenten-Definition](https://developer.mozilla.org/ru/docs/Glossary/Component)

---

  **[⬆ Наверх](#top)**

8. ### <a name="8"></a> Was ist das Fiber-Architekturmodell in React?

### Fiber-Architekturmodell in React

**React Fiber** ist die **neue Rendering-Engine** von React (seit v16), die das alte „Stack Reconciler“-Modell ersetzt. Ziel: **flexible, unterbrechbare Updates** im UI.

---

### Hauptideen

1. **Unterbrechbare Renderings**

   * Große UI-Updates können in **kleine Arbeitseinheiten** zerlegt werden.
   * React kann Rendering pausieren, priorisieren oder abbrechen, wenn wichtigere Aufgaben (z. B. User-Input) eintreffen.

2. **Priorisierung von Updates**

   * Updates erhalten eine **Priorität** (z. B. Animation > Datenladen).
   * Dadurch bleibt die UI reaktionsschnell.

3. **Inkremetelles Rendern**

   * Statt den ganzen Baum auf einmal zu rendern, wird er Stück für Stück (fiberweise) bearbeitet.

---

### Aufbau

* **Fiber Node**: interner Datenknoten, der eine **Einheit der Arbeit** repräsentiert (z. B. eine Komponente oder ein DOM-Element).
* Jeder Fiber enthält Infos wie: Typ der Komponente, Props, State, Nebenwirkungen.

---

### Beispiel (vereinfacht gedacht)

```jsx
function App() {
  return (
    <>
      <Header />
      <Content />
      <Footer />
    </>
  );
}
```

* Für `Header`, `Content`, `Footer` erstellt React einzelne **Fiber-Nodes**.
* React arbeitet diese nacheinander ab, kann aber z. B. `Footer` später fertigstellen, wenn ein **User-Klick** sofort verarbeitet werden muss.

---

### Zusammenfassung

* **Fiber** = Reacts Rendering-Engine ab v16.
* Vorteile: unterbrechbare, priorisierte und inkrementelle Renderings.
* Kernziel: **bessere Performance & User Experience** bei komplexen UIs.

📖 Weiterführend:

* [React Offizielle Dokumentation – Render and Commit](https://react.dev/learn/render-and-commit)
* [React Blog – Fiber Architecture](https://reactjs.org/docs/faq-internals.html#what-is-react-fiber)

---

  **[⬆ Наверх](#top)**

9. ### <a name="9"></a> Was bedeutet „Batching“ in React?

### Batching in React

**Batching** bedeutet, dass React mehrere **State-Updates** zusammenfasst und in **einem einzigen Re-Render** ausführt, anstatt nach jedem Update sofort zu rendern. Das reduziert unnötige DOM-Updates und verbessert die Performance.

---

### Details

* Standardmäßig werden in **Event-Handlern** (z. B. `onClick`) mehrere `setState`-Aufrufe gebündelt.
* Seit **React 18** gilt „Automatic Batching“ auch für **Promises, setTimeout, native Events** usw.
* Ohne Batching würde jede State-Änderung einzeln ein Re-Render auslösen.

---

### Beispiel

```jsx
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);
  const [text, setText] = useState("");

  function handleClick() {
    setCount(c => c + 1);
    setText("Aktualisiert");
    // Beide Updates werden in EINEM Re-Render gebündelt (Batching)
  }

  return (
    <>
      <p>{count} - {text}</p>
      <button onClick={handleClick}>Update</button>
    </>
  );
}

export default Counter;
```

---

### Zusammenfassung

* **Batching** = mehrere State-Updates → ein Re-Render.
* Vorteil: weniger DOM-Updates, bessere Performance.
* Seit React 18: **automatisches Batching überall**, nicht nur in Event-Handlern.

📖 Weiterführend:

* [React Offizielle Dokumentation – State Updates Batching](https://react.dev/learn/queueing-a-series-of-state-updates#batching-of-state-updates)

---

  **[⬆ Наверх](#top)**

10. ### <a name="10"></a> Was ist die Rolle des key in React-Listen?

### Rolle des `key` in React-Listen

**`key`** ist ein spezielles Attribut in React, das jeder Listenkomponente zugewiesen wird, um sie **eindeutig zu identifizieren**. Es hilft React beim **Diffing-Prozess** (Vergleich von altem und neuem Virtual DOM), effizient zu erkennen, welche Elemente geändert, hinzugefügt oder entfernt wurden.

---

### Warum wichtig?

1. **Performance**: React muss nicht die ganze Liste neu rendern, sondern nur die betroffenen Elemente.
2. **Stabilität**: `key` sorgt dafür, dass Komponenteninstanzen korrekt erhalten bleiben (z. B. State in Formularfeldern).
3. **Vorhersehbarkeit**: Ohne eindeutigen Key kann es zu unerwarteten UI-Effekten kommen.

---

### Beispiel

```jsx
const users = ["Anna", "Max", "Sergii"];

function UserList() {
  return (
    <ul>
      {users.map(user => (
        <li key={user}>{user}</li> // key = eindeutiger Identifier
      ))}
    </ul>
  );
}

export default UserList;
```

**Falsch (z. B. Index als Key, nur wenn Daten wirklich stabil sind):**

```jsx
<li key={index}>{user}</li>
```

→ Problematisch, wenn Elemente umsortiert oder gelöscht werden.

---

### Zusammenfassung

* **`key`** identifiziert Listenelemente eindeutig.
* Hilft React beim effizienten Re-Rendern und verhindert UI-Fehler.
* Best Practice: stabile, eindeutige IDs nutzen, **nicht** Array-Index.

📖 Weiterführend:

* [React Offizielle Dokumentation – Schlüssel (Keys)](https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key)

---

  **[⬆ Наверх](#top)**

11. ### <a name="11"></a> Wie funktioniert die Wiederverwendung von Komponenten?

### Wiederverwendung von Komponenten in React

**Wiederverwendbarkeit** bedeutet, dass eine Komponente mehrfach in unterschiedlichen Kontexten eingesetzt werden kann, ohne ihren Code zu duplizieren. React erreicht dies durch **Props, Komposition und Children**.

---

### Hauptmechanismen

1. **Props**

   * Komponenten können konfigurierbar gemacht werden, indem man ihnen Daten übergibt.

   ```jsx
   function Button({ label, color }) {
     return <button style={{ background: color }}>{label}</button>;
   }

   export default function App() {
     return (
       <>
         <Button label="Speichern" color="green" />
         <Button label="Löschen" color="red" />
       </>
     );
   }
   ```

   → Gleiche Komponente, unterschiedliche Darstellung durch Props.

2. **Komposition**

   * Komponenten können andere Komponenten enthalten oder kombinieren.

   ```jsx
   function Card({ children }) {
     return <div className="card">{children}</div>;
   }

   function App() {
     return (
       <Card>
         <h2>Titel</h2>
         <p>Inhalt</p>
       </Card>
     );
   }
   ```

   → Card ist wiederverwendbar als Container für beliebigen Inhalt.

3. **Children & Higher-Order-Komponenten / Render Props**

   * Muster, um Verhalten und Layout flexibel wiederzuverwenden.

---

### Zusammenfassung

* Wiederverwendbarkeit in React basiert auf **Props, Komposition und Children**.
* Eine Komponente kann mehrfach in verschiedenen Kontexten mit unterschiedlicher Konfiguration genutzt werden.
* Ziel: **DRY-Prinzip** (Don’t Repeat Yourself) und saubere Architektur.

📖 Weiterführend:

* [React Offizielle Dokumentation – Komposition vs. Vererbung](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children)

---

  **[⬆ Наверх](#top)**

12. ### <a name="12"></a> 



  **[⬆ Наверх](#top)**

13. ### <a name="13"></a> 



  **[⬆ Наверх](#top)**

14. ### <a name="14"></a> 



  **[⬆ Наверх](#top)**

15. ### <a name="15"></a> 



  **[⬆ Наверх](#top)**

16. ### <a name="16"></a> 



  **[⬆ Наверх](#top)**

17. ### <a name="17"></a> 



  **[⬆ Наверх](#top)**

18. ### <a name="18"></a> 



  **[⬆ Наверх](#top)**

19. ### <a name="19"></a> 



  **[⬆ Наверх](#top)**

20. ### <a name="20"></a> 



  **[⬆ Наверх](#top)**

21. ### <a name="21"></a> Was sind Props und wozu werden sie verwendet?

### Props in React

**Props (Properties)** sind **Eingabeparameter**, die von einer Elternkomponente an eine Kindkomponente übergeben werden. Sie machen Komponenten **dynamisch, wiederverwendbar und konfigurierbar**.

---

### Eigenschaften von Props

1. **Read-only** – Props können innerhalb der Kindkomponente **nicht verändert** werden.
2. **Datenfluss** – Props folgen dem **Top-down Data Flow** (von Eltern zu Kindern).
3. **Flexibilität** – erlauben es, dasselbe UI-Element mit unterschiedlichen Werten zu nutzen.

---

### Beispiel

```jsx
function Greeting({ name }) {
  return <h1>Hallo, {name}!</h1>;
}

function App() {
  return (
    <>
      <Greeting name="Sergii" />
      <Greeting name="Anna" />
    </>
  );
}

export default App;
```

* `Greeting` ist wiederverwendbar.
* `name` wird als Prop übergeben und individuell gerendert.

---

### Zusammenfassung

* **Props** = unveränderliche Eingabeparameter für Komponenten.
* Nutzen: Datenweitergabe, Wiederverwendbarkeit, dynamisches Rendering.
* Props sind **nur lesbar** und werden von Eltern an Kinder übergeben.

📖 Weiterführend:

* [React Offizielle Dokumentation – Props](https://react.dev/learn/passing-props-to-a-component)

---

  **[⬆ Наверх](#top)**

22. ### <a name="22"></a> Was ist der Unterschied zwischen Props und State?

### Unterschied zwischen **Props** und **State**

1. **Props**

   * Eingabeparameter, die eine Komponente von außen (Elternkomponente) erhält.
   * **Unveränderlich** innerhalb der Kindkomponente (read-only).
   * Dienen zur **Datenweitergabe** und **Konfiguration**.

2. **State**

   * Interner Zustand einer Komponente, der sich über die Zeit ändern kann.
   * Wird mit Hooks wie `useState` verwaltet.
   * Änderungen am State lösen ein **Re-Render** der Komponente aus.

---

### Beispiel

```jsx
import { useState } from "react";

function Counter({ initial }) {   // Prop
  const [count, setCount] = useState(initial); // State

  return (
    <>
      <p>Zähler: {count}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
    </>
  );
}

export default function App() {
  return <Counter initial={5} />; // Übergabe per Prop
}
```

* `initial` = **Prop**, von außen übergeben, nicht veränderbar.
* `count` = **State**, gehört zur Komponente selbst und wird durch User-Interaktion verändert.

---

### Zusammenfassung

* **Props**: von außen, unveränderlich, konfigurieren Komponenten.
* **State**: intern, veränderlich, speichert dynamische Daten.
* Zusammenspiel: Props geben Startwerte, State steuert dynamisches Verhalten.

📖 Weiterführend:

* [React Offizielle Dokumentation – Props vs State](https://react.dev/learn/state-a-components-memory)

---

  **[⬆ Наверх](#top)**

23. ### <a name="23"></a> Warum sind Props nur lesbar?

### Warum Props nur lesbar sind

1. **Eindirektionaler Datenfluss (Top-down Data Flow)**

   * React erzwingt, dass Daten **nur von Eltern zu Kindern** fließen.
   * Dadurch bleibt der Datenfluss vorhersehbar und leicht nachvollziehbar.

2. **Unveränderlichkeit**

   * Props sind **read-only**, weil sie von außen (Elternkomponente) kontrolliert werden.
   * Würden Kinder Props verändern, könnte es zu **Inkonsistenzen und schwer nachvollziehbaren Fehlern** kommen.

3. **Wartbarkeit & Debugging**

   * Wenn nur die Eltern Daten ändern dürfen, ist klar definiert, **wo Daten herkommen** und **wer sie verändert**.
   * Das erhöht die Stabilität großer Anwendungen.

---

### Beispiel

```jsx
function Greeting({ name }) {
  // name = Prop, nicht veränderbar
  return <h1>Hallo, {name}</h1>;
}

function App() {
  return <Greeting name="Sergii" />;
}
```

* `Greeting` darf `name` **nicht überschreiben**.
* Änderungen am Wert müssen in der Elternkomponente erfolgen.

---

### Zusammenfassung

* **Props sind nur lesbar**, weil React einen klaren, eindirektionalen Datenfluss erzwingt.
* Eltern kontrollieren die Daten, Kinder konsumieren sie.
* Ergebnis: **Vorhersehbarkeit, Stabilität und einfacheres Debugging**.

📖 Weiterführend:

* [React Offizielle Dokumentation – Props](https://react.dev/learn/passing-props-to-a-component)

---

  **[⬆ Наверх](#top)**

24. ### <a name="24"></a> Wie funktioniert der unidirektionale Datenfluss in React?

### Unidirektionaler Datenfluss in React

React folgt strikt dem Prinzip des **Top-down Data Flow**:

* **Elternkomponenten** geben Daten über **Props** an ihre **Kindkomponenten** weiter.
* Daten fließen **nur in eine Richtung** (von oben nach unten).
* Kindkomponenten können Daten nicht direkt zurückgeben, sondern nur über **Callbacks/Events** Änderungen an die Eltern melden.

---

### Beispiel

```jsx
import { useState } from "react";

function Child({ value, onChange }) {
  return (
    <>
      <p>Aktueller Wert: {value}</p>
      <button onClick={() => onChange(value + 1)}>+1</button>
    </>
  );
}

function Parent() {
  const [count, setCount] = useState(0);

  return <Child value={count} onChange={setCount} />;
}

export default Parent;
```

* `Parent` besitzt den **State**.
* `Child` erhält `value` und `onChange` als **Props**.
* Änderungen fließen **über ein Callback** zurück zur Elternkomponente.

---

### Vorteile

1. **Vorhersehbarkeit**: Es ist klar, wo Daten liegen und wie sie sich ändern.
2. **Wartbarkeit**: Einfacher zu debuggen, da Daten nur an einer Stelle gepflegt werden.
3. **Stabilität**: Keine unkontrollierten Seiteneffekte durch bidirektionalen Fluss.

---

### Zusammenfassung

* **Unidirektionaler Datenfluss** = Daten von Eltern → Kinder (via Props).
* Kinder melden Änderungen durch **Events/Callbacks** zurück.
* Ergebnis: **klare Struktur, bessere Wartbarkeit, weniger Fehler**.

📖 Weiterführend:

* [React Offizielle Dokumentation – Datenfluss](https://react.dev/learn/passing-props-to-a-component#how-props-flow-through-components)

---

  **[⬆ Наверх](#top)**

25. ### <a name="25"></a> Was ist State in Klassen- und Funktionskomponenten?

### State in React

1. **State in Klassenkomponenten**

   * Wird in einer Klasse als Objekt definiert.
   * Zugriff über `this.state`, Änderungen mit `this.setState()`.

   ```jsx
   import React, { Component } from "react";

   class Counter extends Component {
     constructor(props) {
       super(props);
       this.state = { count: 0 }; // State-Objekt
     }

     render() {
       return (
         <>
           <p>Zähler: {this.state.count}</p>
           <button onClick={() => this.setState({ count: this.state.count + 1 })}>
             +1
           </button>
         </>
       );
     }
   }

   export default Counter;
   ```

   * `this.setState()` führt **asynchrone Updates** aus und triggert ein Re-Render.

---

2. **State in Funktionskomponenten**

   * Ab React 16.8 mit **Hooks** möglich (`useState`).
   * State ist kein Objekt mehr, sondern ein beliebiger Wert (Primitive oder Objekt).

   ```jsx
   import { useState } from "react";

   function Counter() {
     const [count, setCount] = useState(0); // State-Hook

     return (
       <>
         <p>Zähler: {count}</p>
         <button onClick={() => setCount(count + 1)}>+1</button>
       </>
     );
   }

   export default Counter;
   ```

   * `useState` gibt ein Array `[state, updater]` zurück.
   * Updates sind deklarativ und lösen ein Re-Render aus.

---

### Vergleich

| Klassenkomponente              | Funktionskomponente       |
| ------------------------------ | ------------------------- |
| `this.state = { ... }`         | `const [value, setValue]` |
| Änderung mit `this.setState()` | Änderung mit Setter       |
| OOP-Stil                       | Funktional, Hooks         |

---

### Zusammenfassung

* **State = interner Speicher** einer Komponente, der sich über die Zeit ändern kann.
* In **Klassen**: Objekt mit `this.state` + Updates via `setState()`.
* In **Funktionen**: `useState`-Hook mit Wert + Setter.
* Änderungen triggern ein **Re-Render** der Komponente.

📖 Weiterführend:

* [React Offizielle Dokumentation – State und Lifecycle](https://react.dev/learn/state-a-components-memory)

---

  **[⬆ Наверх](#top)**

26. ### <a name="26"></a> Wie funktioniert setState?

### Funktionsweise von `setState` in React

1. **In Klassenkomponenten**

   * `setState()` ist die Methode zum Aktualisieren des internen **State-Objekts**.
   * Updates sind **asynchron** und werden oft zusammengefasst (**Batching**).
   * `setState` kann ein **Objekt** oder eine **Funktion** akzeptieren.

   ```jsx
   this.setState({ count: this.state.count + 1 }); // Objektform
   this.setState(prev => ({ count: prev.count + 1 })); // Funktionsform (empfohlen)
   ```

2. **In Funktionskomponenten** (`useState`)

   * `setState` ist der **Updater**, den React vom Hook zurückgibt.
   * Überschreibt den alten Wert durch einen neuen.
   * Akzeptiert direkt einen Wert oder eine Funktion basierend auf dem vorherigen Wert.

   ```jsx
   const [count, setCount] = useState(0);

   setCount(count + 1);          // Wert
   setCount(prev => prev + 1);   // Funktionsform (empfohlen bei Abhängigkeit vom alten Wert)
   ```

---

### Wichtige Eigenschaften

* **Asynchron**: Mehrere Aufrufe von `setState` können gebatcht werden.
* **Re-Render**: Jede Änderung löst ein erneutes Rendern der Komponente aus.
* **Funktionsform** wird bevorzugt, wenn der neue Wert vom alten abhängt.

---

### Zusammenfassung

* `setState` aktualisiert den State und löst ein Re-Render aus.
* In **Klassenkomponenten**: Methode mit Objekt/Funktion.
* In **Funktionskomponenten**: Setter vom `useState`-Hook.
* Updates sind **asynchron** und werden **gebündelt**.

📖 Weiterführend:

* [React Offizielle Dokumentation – setState](https://react.dev/reference/react/useState#updating-state-based-on-the-previous-state)

---

  **[⬆ Наверх](#top)**

27. ### <a name="27"></a> Was ist der Unterschied zwischen kontrollierten und unkontrollierten Komponenten?

### Unterschied: Kontrollierte vs. Unkontrollierte Komponenten

1. **Kontrollierte Komponenten**

   * Der **State der Eingabeelemente** (z. B. `input`, `textarea`, `select`) wird in React verwaltet.
   * Der Wert kommt aus dem **State** der Komponente, Änderungen laufen über ein Event-Handler.
   * React = **Single Source of Truth**.

   ```jsx
   import { useState } from "react";

   function ControlledInput() {
     const [value, setValue] = useState("");

     return (
       <input
         value={value} // State bestimmt den Wert
         onChange={e => setValue(e.target.value)} // React kontrolliert
       />
     );
   }
   ```

---

2. **Unkontrollierte Komponenten**

   * Der Wert wird direkt vom **DOM selbst** verwaltet.
   * Zugriff über **Refs** anstatt über State.
   * React kontrolliert den Wert **nicht kontinuierlich**.

   ```jsx
   import { useRef } from "react";

   function UncontrolledInput() {
     const inputRef = useRef();

     const handleClick = () => {
       alert(inputRef.current.value); // Wert direkt aus DOM
     };

     return (
       <>
         <input ref={inputRef} />
         <button onClick={handleClick}>Zeig Wert</button>
       </>
     );
   }
   ```

---

### Vergleich

| Kontrolliert                         | Unkontrolliert                           |
| ------------------------------------ | ---------------------------------------- |
| React verwaltet den Wert (State)     | DOM verwaltet den Wert                   |
| `value` + `onChange`                 | Zugriff via `ref`                        |
| Besser für Validierung & komplexe UI | Einfacher für schnelle, kleine Formulare |

---

### Zusammenfassung

* **Kontrollierte Komponenten**: Wert = State in React, Änderungen laufen über Events → **voller React-Kontrolle**.
* **Unkontrollierte Komponenten**: Wert = DOM, Zugriff über Ref → **schneller, aber weniger flexibel**.
* Best Practice: Kontrollierte Komponenten für größere UIs, unkontrollierte für einfache Fälle.

📖 Weiterführend:

* [React Offizielle Dokumentation – Forms](https://react.dev/learn/sharing-state-between-components#controlled-and-uncontrolled-components)

---

  **[⬆ Наверх](#top)**

28. ### <a name="28"></a> Was sind Default Props und PropTypes?

### Default Props

* Mit **Default Props** kann man Standardwerte für Props definieren, falls der Elternkomponente kein Wert übergeben wird.
* Praktisch, um **Fallback-Werte** sicherzustellen.

```jsx
function Button({ label }) {
  return <button>{label}</button>;
}

// Standardwert, falls `label` nicht übergeben wird
Button.defaultProps = {
  label: "Klicken"
};

export default Button;
```

→ In modernen React-Versionen (17+) werden Default Props für **Funktionskomponenten** weniger genutzt, stattdessen oft **Default-Parameter**:

```jsx
function Button({ label = "Klicken" }) {
  return <button>{label}</button>;
}
```

---

### PropTypes

* **PropTypes** ist ein Typprüfungssystem für Props zur **Laufzeit**.
* Hilft, Fehler früh zu erkennen, indem überprüft wird, ob Props den erwarteten Typ haben.

```jsx
import PropTypes from "prop-types";

function User({ name, age }) {
  return <p>{name} ist {age} Jahre alt</p>;
}

User.propTypes = {
  name: PropTypes.string.isRequired,
  age: PropTypes.number
};
```

* Wird ein falscher Typ übergeben, zeigt React im **Konsolen-Log eine Warnung**.

---

### Zusammenfassung

* **Default Props**: legen Standardwerte fest, wenn keine Props übergeben werden.
* **PropTypes**: prüfen Props-Typen **zur Laufzeit** und helfen bei der Fehlervermeidung.
* Heute oft ersetzt durch **TypeScript** für statische Typisierung.

📖 Weiterführend:

* [React Offizielle Dokumentation – Typprüfung](https://react.dev/reference/react/Component#static-defaultprops)
* [PropTypes auf npm](https://www.npmjs.com/package/prop-types)

---

  **[⬆ Наверх](#top)**

29. ### <a name="29"></a> Was ist React.memo und wofür wird es verwendet?

### React.memo

**`React.memo`** ist eine **Higher-Order-Komponente (HOC)**, die Funktionskomponenten **memoisiert**.
Das bedeutet: Eine Komponente wird **nur neu gerendert, wenn sich ihre Props ändern**.

---

### Wofür wird es verwendet?

1. **Performance-Optimierung**

   * Verhindert unnötige Re-Renders bei unveränderten Props.
   * Besonders sinnvoll bei **teuren Berechnungen** oder **großen Listen**.

2. **Vergleich der Props**

   * Standardmäßig nutzt React einen **shallow comparison** (flacher Vergleich).
   * Für komplexe Objekte kann man eine eigene Vergleichsfunktion übergeben.

---

### Beispiel

```jsx
import React, { useState } from "react";

const Child = React.memo(function Child({ value }) {
  console.log("Render:", value);
  return <p>Wert: {value}</p>;
});

export default function App() {
  const [count, setCount] = useState(0);
  const [text, setText] = useState("");

  return (
    <>
      <Child value={count} />
      <button onClick={() => setCount(count + 1)}>+1</button>
      <input value={text} onChange={e => setText(e.target.value)} />
    </>
  );
}
```

* `Child` rendert nur neu, wenn sich `value` ändert.
* Änderungen an `text` haben **keinen Einfluss** auf `Child`.

---

### Zusammenfassung

* **`React.memo`** = Memoization für Funktionskomponenten.
* Verhindert unnötige Re-Renders, wenn Props unverändert bleiben.
* Standard: **shallow comparison**, optional eigene Vergleichsfunktion.

📖 Weiterführend:

* [React Offizielle Dokumentation – React.memo](https://react.dev/reference/react/memo)

---

  **[⬆ Наверх](#top)**

30. ### <a name="30"></a> Was ist PureComponent und wie unterscheidet es sich von Component?

### PureComponent vs. Component

1. **`React.Component`**

   * Basis-Klasse für Klassenkomponenten.
   * Führt bei jedem `setState` oder neuen Props ein Re-Render durch, auch wenn sich die Werte nicht tatsächlich geändert haben.

2. **`React.PureComponent`**

   * Erweiterung von `Component`.
   * Führt **automatisch einen shallow comparison** (flachen Vergleich) von Props und State durch.
   * Rendert nur neu, wenn sich **wirklich etwas geändert hat**.

---

### Beispiel

```jsx
import React, { Component, PureComponent } from "react";

class NormalComponent extends Component {
  render() {
    console.log("NormalComponent gerendert");
    return <p>{this.props.value}</p>;
  }
}

class OptimizedComponent extends PureComponent {
  render() {
    console.log("PureComponent gerendert");
    return <p>{this.props.value}</p>;
  }
}
```

* `NormalComponent` rendert bei **jeder Aktualisierung**, auch wenn `value` gleich bleibt.
* `OptimizedComponent` rendert **nur, wenn sich `value` geändert hat**.

---

### Unterschiede im Überblick

| **Component**                         | **PureComponent**                                 |
| ------------------------------------- | ------------------------------------------------- |
| Rendert immer bei Updates             | Rendert nur bei Änderungen (shallow compare)      |
| Keine Optimierung                     | Eingebaute Performance-Optimierung                |
| Manuell `shouldComponentUpdate` nötig | `shouldComponentUpdate` automatisch implementiert |

---

### Zusammenfassung

* **Component**: rendert immer neu bei Updates.
* **PureComponent**: optimiert, rendert nur bei tatsächlichen Änderungen (shallow compare).
* Ziel: **Performance-Optimierung** bei Klassenkomponenten.

📖 Weiterführend:

* [React Offizielle Dokumentation – PureComponent](https://react.dev/reference/react/PureComponent)

---

  **[⬆ Наверх](#top)**  

31. ### <a name="31"></a> Wann sollte shouldComponentUpdate verwendet werden?

### `shouldComponentUpdate` in React

**`shouldComponentUpdate(nextProps, nextState)`** ist eine Lifecycle-Methode in **Klassenkomponenten**, die bestimmt, ob ein Re-Render stattfinden soll.
Sie gibt **true** (neu rendern) oder **false** (kein Render) zurück.

---

### Wann einsetzen?

1. **Performance-Optimierung**

   * Wenn eine Komponente sehr oft aktualisiert wird, aber die meisten Updates keine sichtbaren Änderungen im UI verursachen.
   * Durch Rückgabe von `false` können unnötige Re-Renders vermieden werden.

2. **Feinsteuerung**

   * Wenn der Standardvergleich von `PureComponent` (shallow compare) nicht ausreicht.
   * Beispiel: tiefe Objektstrukturen, die differenziert geprüft werden müssen.

---

### Beispiel

```jsx
import React, { Component } from "react";

class User extends Component {
  shouldComponentUpdate(nextProps) {
    // Nur neu rendern, wenn sich der Name geändert hat
    return nextProps.name !== this.props.name;
  }

  render() {
    console.log("Rendering:", this.props.name);
    return <p>{this.props.name}</p>;
  }
}

export default User;
```

---

### Zusammenfassung

* **`shouldComponentUpdate`** steuert, ob ein Re-Render notwendig ist.
* Sinnvoll bei **Performance-Optimierungen** und **kontrollierten Updates**.
* Heute oft ersetzt durch **PureComponent** oder **React.memo** in Funktionskomponenten.

📖 Weiterführend:

* [React Offizielle Dokumentation – shouldComponentUpdate](https://react.dev/reference/react/Component#shouldcomponentupdate)

---

  **[⬆ Наверх](#top)**

32. ### <a name="32"></a> Was ist ein ref und wann wird er eingesetzt?

### Ref in React

Ein **ref (reference)** ist ein spezielles Objekt in React, mit dem man direkt auf ein **DOM-Element** oder eine **Komponenteninstanz** zugreifen kann. Refs werden mit `useRef` (Funktionskomponenten) oder `React.createRef` (Klassenkomponenten) erstellt.

---

### Wann einsetzen?

1. **Direkter Zugriff auf DOM-Elemente**

   * Fokus setzen, Text selektieren, Scrollen steuern.

2. **Speichern von veränderlichen Werten**

   * Werte zwischen Renders behalten, ohne ein Re-Render auszulösen.

3. **Integration mit Drittbibliotheken**

   * z. B. Zugriff auf Canvas, Charts, Animationen.

---

### Beispiele

**Funktionskomponente mit `useRef`:**

```jsx
import { useRef } from "react";

function InputFocus() {
  const inputRef = useRef();

  const handleClick = () => {
    inputRef.current.focus(); // direkter DOM-Zugriff
  };

  return (
    <>
      <input ref={inputRef} type="text" />
      <button onClick={handleClick}>Fokus setzen</button>
    </>
  );
}

export default InputFocus;
```

**Persistente Werte ohne Re-Render:**

```jsx
import { useRef, useState } from "react";

function Timer() {
  const countRef = useRef(0);
  const [stateCount, setStateCount] = useState(0);

  const increment = () => {
    countRef.current += 1;      // kein Re-Render
    setStateCount(stateCount+1); // triggert Re-Render
  };

  return (
    <p>Ref: {countRef.current}, State: {stateCount}</p>
  );
}
```

---

### Zusammenfassung

* **Refs** = direkte Referenzen auf DOM-Elemente oder persistente Werte.
* Einsatz: Fokus, Scroll, Animationssteuerung, Integration mit Drittlibs, Werte speichern ohne Re-Render.
* Erstellung: `useRef` (Hooks), `createRef` (Klassen).

📖 Weiterführend:

* [React Offizielle Dokumentation – Refs](https://react.dev/learn/referencing-values-with-refs)

---

  **[⬆ Наверх](#top)**

33. ### <a name="33"></a> Was bedeutet „Lifting State Up“?

### Lifting State Up in React

**Lifting State Up** bedeutet, dass man den **State aus einer Kindkomponente in die gemeinsame Elternkomponente verlagert**, wenn mehrere Komponenten denselben Zustand benötigen.
So entsteht **eine gemeinsame Quelle der Wahrheit** (Single Source of Truth), und der Datenfluss bleibt **eindirektional**.

---

### Beispiel

```jsx
import { useState } from "react";

function TemperatureInput({ label, value, onChange }) {
  return (
    <>
      <label>{label}: </label>
      <input
        type="number"
        value={value}
        onChange={e => onChange(e.target.value)}
      />
    </>
  );
}

function Calculator() {
  const [temperature, setTemperature] = useState("");

  return (
    <>
      <TemperatureInput
        label="Celsius"
        value={temperature}
        onChange={setTemperature}
      />
      <TemperatureInput
        label="Fahrenheit"
        value={(temperature * 9) / 5 + 32}
        onChange={val => setTemperature(((val - 32) * 5) / 9)}
      />
    </>
  );
}

export default Calculator;
```

* Beide Inputs teilen sich denselben **State in der Elternkomponente**.
* Änderungen an einem Feld werden sofort im anderen reflektiert.

---

### Zusammenfassung

* **Lifting State Up** = Verschieben von State in die **Elternkomponente**, um Daten zwischen Kindern zu synchronisieren.
* Vorteile: eine gemeinsame Wahrheit, konsistenter Datenfluss, bessere Wartbarkeit.

📖 Weiterführend:

* [React Offizielle Dokumentation – Lifting State Up](https://react.dev/learn/sharing-state-between-components#lifting-state-up)

---

  **[⬆ Наверх](#top)**

34. ### <a name="34"></a> 



  **[⬆ Наверх](#top)**

35. ### <a name="35"></a> 



  **[⬆ Наверх](#top)**

36. ### <a name="36"></a> 



  **[⬆ Наверх](#top)**

37. ### <a name="37"></a> 



  **[⬆ Наверх](#top)**

38. ### <a name="38"></a> 



  **[⬆ Наверх](#top)**

39. ### <a name="39"></a> 



  **[⬆ Наверх](#top)**

40. ### <a name="40"></a> 



  **[⬆ Наверх](#top)**  

41. ### <a name="41"></a> Was sind die Phasen des Komponentenlebenszyklus?

### Phasen des Komponentenlebenszyklus (Class Components)

In React (bei **Klassenkomponenten**) besteht der **Lebenszyklus** einer Komponente aus drei Hauptphasen:

1. **Mounting (Einfügen ins DOM)**

   * Methoden:

     * `constructor()`
     * `static getDerivedStateFromProps()`
     * `render()`
     * `componentDidMount()`

2. **Updating (Aktualisierung bei Props/State-Änderungen)**

   * Methoden:

     * `static getDerivedStateFromProps()`
     * `shouldComponentUpdate()`
     * `render()`
     * `getSnapshotBeforeUpdate()`
     * `componentDidUpdate()`

3. **Unmounting (Entfernen aus dem DOM)**

   * Methode:

     * `componentWillUnmount()`

---

### Beispiel

```jsx
import React, { Component } from "react";

class Demo extends Component {
  constructor(props) {
    super(props);
    console.log("1. constructor");
    this.state = { count: 0 };
  }

  componentDidMount() {
    console.log("4. componentDidMount");
  }

  shouldComponentUpdate() {
    console.log("Update? -> true");
    return true;
  }

  componentDidUpdate() {
    console.log("componentDidUpdate");
  }

  componentWillUnmount() {
    console.log("componentWillUnmount");
  }

  render() {
    console.log("render()");
    return (
      <button onClick={() => this.setState({ count: this.state.count + 1 })}>
        {this.state.count}
      </button>
    );
  }
}

export default Demo;
```

---

### Vergleich zu Hooks

* **Mounting/Updating/Unmounting** wird heute meist mit **`useEffect`** in Funktionskomponenten abgebildet.

```jsx
import { useState, useEffect } from "react";

function Demo() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log("Mounting & Updating");
    return () => console.log("Unmounting");
  }, [count]);

  return <button onClick={() => setCount(count + 1)}>{count}</button>;
}
```

---

### Zusammenfassung

* Lebenszyklus hat drei Phasen: **Mounting, Updating, Unmounting**.
* Klassenkomponenten nutzen Methoden (`componentDidMount`, `componentDidUpdate`, `componentWillUnmount`).
* Funktionskomponenten verwenden stattdessen **Hooks (useEffect)**.

📖 Weiterführend:

* [React Offizielle Dokumentation – Lifecycle](https://react.dev/reference/react/Component)

---

  **[⬆ Наверх](#top)**

42. ### <a name="42"></a> Welche Lifecycle-Methoden gibt es in Klassenkomponenten?

### Lifecycle-Methoden in Klassenkomponenten

React-Klassenkomponenten haben verschiedene Lifecycle-Methoden, die in drei Phasen eingeteilt werden:

---

#### 1. **Mounting (Einfügen ins DOM)**

* `constructor()` → Initialisierung von State und Binding.
* `static getDerivedStateFromProps(props, state)` → selten genutzt, synchronisiert State mit Props.
* `render()` → gibt das JSX zurück.
* `componentDidMount()` → ausgeführt **nach dem ersten Render**, ideal für API-Calls oder DOM-Manipulation.

---

#### 2. **Updating (bei Props/State-Änderungen)**

* `static getDerivedStateFromProps(props, state)` → wird auch hier aufgerufen.
* `shouldComponentUpdate(nextProps, nextState)` → entscheidet, ob Re-Render nötig ist (Performance-Optimierung).
* `render()` → erneutes Rendern der Komponente.
* `getSnapshotBeforeUpdate(prevProps, prevState)` → Zugriff auf DOM vor dem Update.
* `componentDidUpdate(prevProps, prevState, snapshot)` → nach dem Rendern, gut für Netzwerkaufrufe oder DOM-Updates.

---

#### 3. **Unmounting (Entfernen aus DOM)**

* `componentWillUnmount()` → Aufräumarbeiten (Timer clearen, Event Listener entfernen).

---

#### 4. **Error Handling (seit React 16)**

* `static getDerivedStateFromError(error)` → fängt Fehler ab, bevor UI zusammenbricht.
* `componentDidCatch(error, info)` → Logging von Fehlern.

---

### Zusammenfassung

* **Mounting**: `constructor`, `getDerivedStateFromProps`, `render`, `componentDidMount`.
* **Updating**: `getDerivedStateFromProps`, `shouldComponentUpdate`, `render`, `getSnapshotBeforeUpdate`, `componentDidUpdate`.
* **Unmounting**: `componentWillUnmount`.
* **Error Handling**: `getDerivedStateFromError`, `componentDidCatch`.

📖 Weiterführend:

* [React Offizielle Dokumentation – Component API](https://react.dev/reference/react/Component)

---

  **[⬆ Наверх](#top)**

43. ### <a name="43"></a> Welche Lifecycle-Methoden sind veraltet?

### Veraltete Lifecycle-Methoden in React

Einige Lifecycle-Methoden von **Klassenkomponenten** gelten seit **React 16.3** als **deprecated** (veraltet), weil sie oft zu **Fehlern und unerwartetem Verhalten** führten.

---

### Veraltete Methoden

1. **`componentWillMount()`**

   * Wurde vor dem ersten Render ausgeführt.
   * Ersetzt durch: **`constructor`** oder **`componentDidMount`**.

2. **`componentWillReceiveProps(nextProps)`**

   * Wurde bei neuen Props aufgerufen.
   * Ersetzt durch: **`static getDerivedStateFromProps`** oder **`componentDidUpdate`**.

3. **`componentWillUpdate(nextProps, nextState)`**

   * Wurde vor einem Update aufgerufen.
   * Ersetzt durch: **`getSnapshotBeforeUpdate`** oder **`componentDidUpdate`**.

---

### UNSAFE_-Präfix

Seit React 16.3 existieren diese Methoden noch, aber mit **`UNSAFE_`-Präfix**, z. B.:

* `UNSAFE_componentWillMount`
* `UNSAFE_componentWillReceiveProps`
* `UNSAFE_componentWillUpdate`

---

### Zusammenfassung

* Veraltet: `componentWillMount`, `componentWillReceiveProps`, `componentWillUpdate`.
* Grund: sie verursachen **Side-Effects** im falschen Zeitpunkt.
* Alternative: **`getDerivedStateFromProps`, `componentDidMount`, `componentDidUpdate`, `getSnapshotBeforeUpdate`**.

📖 Weiterführend:

* [React Offizielle Dokumentation – UNSAFE Lifecycle Methods](https://react.dev/reference/react/Component#unsafe_componentwillmount)

---

  **[⬆ Наверх](#top)**

44. ### <a name="44"></a> Wie kann man Lifecycle-Methoden mit Hooks ersetzen?

### Lifecycle-Methoden → Hooks: 1:1-Ersatz und Patterns

| Klassen-Lifecycle                                             | Entsprechung mit Hooks (Funktionskomponenten)                                                                                | Hinweis                                                              |
| ------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------- |
| `constructor`                                                 | Initial-State via `useState(initial)`                                                                                        | Auch für Event-Handler-Binding nicht nötig.                          |
| `componentDidMount`                                           | `useEffect(() => { /* init */ }, [])`                                                                                        | Läuft nach dem ersten Render (commit).                               |
| `componentDidUpdate`                                          | `useEffect(() => { /* reagiert auf deps */ }, [deps])`                                                                       | Läuft nach jedem Render, wenn `deps` sich ändern.                    |
| `componentWillUnmount`                                        | Cleanup-Funktion in `useEffect`: `return () => {/* cleanup */}`                                                              | Abmelden von Listenern, Timer clearen etc.                           |
| `shouldComponentUpdate`                                       | Strukturell: `React.memo(Component)`; feingranular: `useMemo`, `useCallback`                                                 | Verhindert unnötige Re-Renders.                                      |
| `getDerivedStateFromProps`                                    | Meist **vermeiden**. Alternativen: ableiten im Render, `useMemo` für teure Ableitungen, oder `useEffect` zum Synchronisieren | Props nicht in State duplizieren, wenn möglich.                      |
| `getSnapshotBeforeUpdate` → `componentDidUpdate`              | `useLayoutEffect` + `useRef` für **Layout-Messungen** vor dem Paint; Vor-/Nachwerte per Ref speichern                        | `useLayoutEffect` läuft synchron nach DOM-Mutationen, vor dem Paint. |
| Fehlergrenzen: `getDerivedStateFromError`/`componentDidCatch` | **Kein Hook-Äquivalent**. Error Boundaries weiterhin als **Klassenkomponenten** implementieren                               | Alternativ: vorhandene Boundary-Komponenten wiederverwenden.         |

---

### Minimalbeispiele

**Mount/Update/Unmount (Effect + Cleanup)**

```jsx
import { useEffect, useState } from "react";

export default function Chat() {
  const [connected, setConnected] = useState(false);

  useEffect(() => {
    const conn = connect();       // componentDidMount / DidUpdate (deps s.u.)
    setConnected(true);
    return () => conn.disconnect(); // componentWillUnmount
  }, []); // leeres Array: nur einmal nach Mount

  return <p>{connected ? "Online" : "Offline"}</p>;
}
```

**shouldComponentUpdate → React.memo**

```jsx
import React, { useMemo } from "react";

const List = React.memo(function List({ items }) {
  const total = useMemo(() => items.reduce((s, x) => s + x.value, 0), [items]);
  return <p>Total: {total}</p>;
});

export default List;
```

**getDerivedStateFromProps vermeiden (Ableitung statt Spiegeln)**

```jsx
import { useMemo } from "react";

// Statt Prop -> State-Spiegelung:
export default function Price({ net, vatPercent }) {
  const gross = useMemo(() => net * (1 + vatPercent / 100), [net, vatPercent]);
  return <span>{gross.toFixed(2)} €</span>;
}
```

**getSnapshotBeforeUpdate → useLayoutEffect für Layout/Scroll**

```jsx
import { useLayoutEffect, useRef } from "react";

export default function AutoScroll({ messages }) {
  const listRef = useRef(null);
  const prevLen = useRef(0);

  useLayoutEffect(() => {
    const list = listRef.current;
    const nearBottom =
      list.scrollHeight - list.scrollTop - list.clientHeight < 20;

    // läuft nach DOM-Mutationen, vor dem Paint
    if (nearBottom || messages.length < prevLen.current) {
      list.scrollTop = list.scrollHeight; // „Snapshot“-artiges Verhalten
    }
    prevLen.current = messages.length;
  }, [messages]);

  return (
    <ul ref={listRef} style={{ maxHeight: 200, overflow: "auto" }}>
      {messages.map(m => <li key={m.id}>{m.text}</li>)}
    </ul>
  );
}
```

**Fehlergrenze (weiterhin Klasse)**

```jsx
import React from "react";

export class ErrorBoundary extends React.Component {
  state = { hasError: false };

  static getDerivedStateFromError() {
    return { hasError: true };
  }
  componentDidCatch(error, info) {
    console.error(error, info);
  }
  render() {
    return this.state.hasError ? <h1>Etwas ging schief.</h1> : this.props.children;
  }
}
```

---

### Zusammenfassung

* Mount/Update/Unmount: `useEffect` (mit/ohne deps) + **Cleanup**.
* Rendersteuerung: `React.memo`, `useMemo`, `useCallback`.
* Layout-kritisch: `useLayoutEffect` + `useRef`.
* `getDerivedStateFromProps` meist vermeiden (Props nicht spiegeln).
* Error Boundaries: weiterhin **Klassenkomponenten**.

📖 Weiterführend:

* React Docs: [Effects](https://react.dev/learn/synchronizing-with-effects), [useEffect](https://react.dev/reference/react/useEffect), [useLayoutEffect](https://react.dev/reference/react/useLayoutEffect), [Memoisierung](https://react.dev/learn/escape-hatches#memoizing-calculations), [React.memo](https://react.dev/reference/react/memo), [Error Boundaries](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary)
* MDN (RU): [События](https://developer.mozilla.org/ru/docs/Learn/JavaScript/Building_blocks/Events), [requestAnimationFrame](https://developer.mozilla.org/ru/docs/Web/API/window/requestAnimationFrame) (Kontext für Layout/Rendering-Zeitpunkte)

  **[⬆ Наверх](#top)**

45. ### <a name="45"></a> Was ist componentDidMount und was ist das Äquivalent mit Hooks?

### `componentDidMount` in Klassenkomponenten

* Wird **einmal nach dem ersten Render** ausgeführt, sobald die Komponente ins DOM eingefügt wurde.
* Typische Einsätze:

  * **API-Requests starten**
  * **Event-Listener registrieren**
  * **DOM-Manipulationen** (Fokus setzen etc.)

```jsx
import React, { Component } from "react";

class Demo extends Component {
  componentDidMount() {
    console.log("Komponente wurde gemountet");
    document.title = "Hallo Sergii";
  }

  render() {
    return <h1>Hallo</h1>;
  }
}
```

---

### Äquivalent mit Hooks → `useEffect`

In Funktionskomponenten übernimmt `useEffect` die Rolle von Lifecycle-Methoden.

* **Äquivalent zu `componentDidMount`:** `useEffect` mit leerem Abhängigkeitsarray `[]`.

```jsx
import { useEffect } from "react";

function Demo() {
  useEffect(() => {
    console.log("Komponente wurde gemountet");
    document.title = "Hallo Sergii";
  }, []); // leeres Array -> nur beim ersten Mount

  return <h1>Hallo</h1>;
}

export default Demo;
```

---

### Zusammenfassung

* **`componentDidMount`**: läuft einmal nach dem Einfügen ins DOM (Klassenkomponenten).
* **Hook-Äquivalent**: `useEffect(() => { ... }, [])` in Funktionskomponenten.
* Typische Nutzung: API-Calls, Event-Registrierung, DOM-Manipulation.

📖 Weiterführend:

* [React Offizielle Dokumentation – useEffect](https://react.dev/reference/react/useEffect)

---

  **[⬆ Наверх](#top)**

46. ### <a name="46"></a> 



  **[⬆ Наверх](#top)**

47. ### <a name="47"></a> 



  **[⬆ Наверх](#top)**

48. ### <a name="48"></a> 



  **[⬆ Наверх](#top)**

49. ### <a name="49"></a> 



  **[⬆ Наверх](#top)**

50. ### <a name="50"></a> 



  **[⬆ Наверх](#top)**  

51. ### <a name="51"></a> Was sind Hooks in React?

### Hooks in React

**Hooks** sind spezielle **Funktionen**, die es ermöglichen, in **Funktionskomponenten** React-Features wie **State, Lifecycle-Methoden und Context** zu nutzen – ohne Klassenkomponenten zu schreiben. Sie wurden mit **React 16.8** eingeführt.

---

### Warum Hooks?

1. Ersetzen viele Anwendungsfälle von **Klassenkomponenten**.
2. Erlauben **Wiederverwendung von Logik** (Custom Hooks).
3. Machen Code **kürzer, klarer und besser testbar**.

---

### Wichtige eingebaute Hooks

* **State**: `useState` → lokaler Zustand.
* **Lifecycle/Side Effects**: `useEffect`, `useLayoutEffect`.
* **Referenzen**: `useRef`.
* **Performance**: `useMemo`, `useCallback`.
* **Context**: `useContext`.
* **Reducer**: `useReducer` für komplexere State-Logik.

---

### Beispiel

```jsx
import { useState, useEffect } from "react";

function Counter() {
  const [count, setCount] = useState(0); // State-Hook

  useEffect(() => {
    document.title = `Zähler: ${count}`; // Effect-Hook (componentDidMount/DidUpdate)
  }, [count]);

  return (
    <>
      <p>Zähler: {count}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
    </>
  );
}

export default Counter;
```

---

### Zusammenfassung

* **Hooks = Funktionen**, die React-Features (State, Lifecycle, Context) in **Funktionskomponenten** bringen.
* Vorteil: keine Klassen mehr nötig, bessere Wiederverwendung von Logik.
* Kernhooks: `useState`, `useEffect`, `useContext`, `useRef`, `useMemo`, `useCallback`.

📖 Weiterführend:

* [React Offizielle Dokumentation – Einführung in Hooks](https://react.dev/learn/state-a-components-memory#using-hooks)

---

  **[⬆ Наверх](#top)**

52. ### <a name="52"></a> Wie funktionieren useState und useEffect?

### `useState`

* `useState` ist ein Hook, der in einer **Funktionskomponente** lokalen State speichert.
* Er liefert ein **Array mit zwei Werten**: `[aktuellerState, SetterFunktion]`.
* Änderungen über den Setter triggern ein **Re-Render** der Komponente.

```jsx
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0); // Initialwert = 0

  return (
    <>
      <p>Zähler: {count}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
    </>
  );
}
```

---

### `useEffect`

* `useEffect` ermöglicht **Side Effects** in Funktionskomponenten (z. B. API-Calls, Event-Listener, DOM-Manipulation).
* Standardmäßig läuft er **nach jedem Render**.
* Mit **Abhängigkeitsarray** kann man steuern:

  * `[]` → nur beim ersten Mount (`componentDidMount`).
  * `[deps]` → bei Änderungen der Abhängigkeiten (`componentDidUpdate`).
  * Cleanup-Funktion → beim Unmount (`componentWillUnmount`).

```jsx
import { useEffect, useState } from "react";

function Timer() {
  const [seconds, setSeconds] = useState(0);

  useEffect(() => {
    const id = setInterval(() => setSeconds(s => s + 1), 1000);

    return () => clearInterval(id); // Cleanup beim Unmount
  }, []);

  return <p>Timer: {seconds}s</p>;
}
```

---

### Zusammenfassung

* **`useState`**: lokaler State in Funktionskomponenten (`[state, setState]`).
* **`useEffect`**: verwaltet Side Effects (API, Timer, DOM), inkl. Cleanup.
* Zusammen bilden sie das Grundgerüst für State-Management und Lifecycle-Handling in React.

📖 Weiterführend:

* [React Offizielle Dokumentation – useState](https://react.dev/reference/react/useState)
* [React Offizielle Dokumentation – useEffect](https://react.dev/reference/react/useEffect)

---

  **[⬆ Наверх](#top)**

53. ### <a name="53"></a> Was macht useContext?

### `useContext` in React

* **`useContext`** ist ein Hook, der Zugriff auf den Wert eines **React Contexts** ermöglicht.
* Er ersetzt die Notwendigkeit, Props durch viele Komponenten weiterzureichen (**Prop Drilling**).
* Jede Komponente, die `useContext` nutzt, wird neu gerendert, sobald sich der Context-Wert ändert.

---

### Beispiel

```jsx
import { createContext, useContext } from "react";

// 1. Context erstellen
const ThemeContext = createContext("light");

function ThemedButton() {
  // 2. Zugriff auf den aktuellen Wert
  const theme = useContext(ThemeContext);
  return <button className={theme}>Klick mich</button>;
}

export default function App() {
  return (
    // 3. Provider legt den Wert fest
    <ThemeContext.Provider value="dark">
      <ThemedButton />
    </ThemeContext.Provider>
  );
}
```

* `ThemeContext.Provider` → stellt den Wert (`"dark"`) bereit.
* `useContext(ThemeContext)` → liest den Wert aus, ohne Props weiterzureichen.

---

### Zusammenfassung

* **`useContext`**: Hook zum direkten Zugriff auf einen Context-Wert.
* Nutzen: Vermeidet **Prop Drilling**, ideal für globale Daten (Theme, Auth, Sprache).
* Änderung des Contexts → Re-Render aller abhängigen Komponenten.

📖 Weiterführend:

* [React Offizielle Dokumentation – useContext](https://react.dev/reference/react/useContext)

---

  **[⬆ Наверх](#top)**

54. ### <a name="54"></a> Was ist useRef und wann wird es verwendet?

### `useRef` in React

* **`useRef`** ist ein Hook, der ein **veränderbares Objekt mit der Eigenschaft `.current`** zurückgibt.
* Dieses Objekt bleibt **über die gesamte Lebensdauer** der Komponente gleich.
* Änderungen an `.current` lösen **kein Re-Render** aus.

---

### Wann wird `useRef` verwendet?

1. **Direkter Zugriff auf DOM-Elemente**

   * Fokus setzen, Scroll-Position manipulieren, Integration mit Drittbibliotheken.

2. **Speichern von Werten zwischen Renders**

   * Persistente Werte behalten (z. B. Timer-ID, vorheriger Wert).

3. **Performance-Optimierung**

   * Verhindern, dass ein Wert bei jedem Render neu erzeugt wird.

---

### Beispiele

**DOM-Zugriff:**

```jsx
import { useRef } from "react";

function InputFocus() {
  const inputRef = useRef();

  const handleClick = () => {
    inputRef.current.focus(); // Zugriff auf das DOM-Element
  };

  return (
    <>
      <input ref={inputRef} type="text" />
      <button onClick={handleClick}>Fokus setzen</button>
    </>
  );
}
```

**Persistenter Wert (kein Re-Render):**

```jsx
import { useRef, useEffect } from "react";

function Timer() {
  const count = useRef(0);

  useEffect(() => {
    const id = setInterval(() => {
      count.current += 1; // Wert ändern ohne Re-Render
      console.log("Sekunden:", count.current);
    }, 1000);
    return () => clearInterval(id);
  }, []);

  return <p>Siehe Konsole</p>;
}
```

---

### Zusammenfassung

* **`useRef`** speichert eine veränderbare Referenz (`.current`) über Renders hinweg.
* Einsatz: DOM-Zugriffe, persistente Werte, Performance-Optimierung.
* Unterschied zu State: **Änderungen an `useRef` triggern kein Re-Render**.

📖 Weiterführend:

* [React Offizielle Dokumentation – useRef](https://react.dev/reference/react/useRef)

---

  **[⬆ Наверх](#top)**

55. ### <a name="55"></a> Was ist useCallback, useMemo, useReducer?

### 1. `useCallback`

* Gibt eine **memoisierte Callback-Funktion** zurück.
* Nützlich, um **unnötige Re-Renders** von Kindkomponenten zu vermeiden, die eine Callback-Prop erhalten.
* Nur neu erstellt, wenn sich die Abhängigkeiten ändern.

```jsx
import { useState, useCallback } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  const increment = useCallback(() => setCount(c => c + 1), []);
  // gleiche Funktion bleibt über Renders hinweg erhalten

  return <button onClick={increment}>{count}</button>;
}
```

---

### 2. `useMemo`

* Gibt einen **memoisierten Wert** zurück.
* Verhindert, dass **teure Berechnungen** bei jedem Render erneut ausgeführt werden.
* Nur neu berechnet, wenn sich die Abhängigkeiten ändern.

```jsx
import { useState, useMemo } from "react";

function ExpensiveCalc({ num }) {
  const result = useMemo(() => {
    console.log("Teure Berechnung...");
    return num * 2;
  }, [num]);

  return <p>Ergebnis: {result}</p>;
}
```

---

### 3. `useReducer`

* Alternative zu `useState`, besonders für **komplexe State-Logik** oder **mehrere verbundene Zustände**.
* Funktioniert ähnlich wie ein **Redux-Reducer**: `state` + `action` → neuer `state`.

```jsx
import { useReducer } from "react";

function reducer(state, action) {
  switch (action.type) {
    case "increment":
      return { count: state.count + 1 };
    case "decrement":
      return { count: state.count - 1 };
    default:
      return state;
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, { count: 0 });

  return (
    <>
      <p>Zähler: {state.count}</p>
      <button onClick={() => dispatch({ type: "increment" })}>+1</button>
      <button onClick={() => dispatch({ type: "decrement" })}>-1</button>
    </>
  );
}
```

---

### Zusammenfassung

* **`useCallback`**: memoisiert Funktionen → vermeidet unnötige Neu-Erstellungen.
* **`useMemo`**: memoisiert Werte → verhindert teure Neuberechnungen.
* **`useReducer`**: State-Management für komplexe Logik, basierend auf Reducer-Pattern.

📖 Weiterführend:

* [React Offizielle Dokumentation – useCallback](https://react.dev/reference/react/useCallback)
* [React Offizielle Dokumentation – useMemo](https://react.dev/reference/react/useMemo)
* [React Offizielle Dokumentation – useReducer](https://react.dev/reference/react/useReducer)

---

  **[⬆ Наверх](#top)**

56. ### <a name="56"></a> Wie schreibt man einen benutzerdefinierten Hook?

### Benutzerdefinierte Hooks (Custom Hooks)

Ein **Custom Hook** ist eine normale **JavaScript-Funktion**, deren Name mit **`use`** beginnt und die **React Hooks** (z. B. `useState`, `useEffect`) verwendet.
Zweck: **Wiederverwendung von Logik** in verschiedenen Komponenten.

---

### Regeln

1. Name muss mit `use...` beginnen.
2. Darf nur innerhalb von React-Komponenten oder anderen Hooks verwendet werden.
3. Muss die [Regeln der Hooks](https://react.dev/warnings/rules-of-hooks) einhalten: nur **Top-Level**, niemals in Schleifen oder Bedingungen.

---

### Beispiel – Fensterbreite beobachten

```jsx
import { useState, useEffect } from "react";

// Custom Hook
function useWindowWidth() {
  const [width, setWidth] = useState(window.innerWidth);

  useEffect(() => {
    const handleResize = () => setWidth(window.innerWidth);
    window.addEventListener("resize", handleResize);

    return () => window.removeEventListener("resize", handleResize);
  }, []);

  return width; // gibt Wert zurück
}

// Nutzung in einer Komponente
export default function App() {
  const width = useWindowWidth();

  return <p>Aktuelle Fensterbreite: {width}px</p>;
}
```

---

### Zusammenfassung

* **Custom Hook** = Funktion mit `use...`, die Hooks nutzt, um Logik wiederverwendbar zu machen.
* Vorteile: **Code-Wiederverwendung, bessere Lesbarkeit, klarere Trennung von Logik und UI**.
* Beispiel: `useWindowWidth`, `useFetch`, `useForm`.

📖 Weiterführend:

* [React Offizielle Dokumentation – Eigene Hooks](https://react.dev/learn/reusing-logic-with-custom-hooks)

---

  **[⬆ Наверх](#top)**

57. ### <a name="57"></a> Wie verhindert man eine Endlosschleife in useEffect?

### Endlosschleifen in `useEffect`

Eine Endlosschleife entsteht, wenn **State im Effect geändert** wird, ohne die Abhängigkeiten korrekt zu steuern → jeder State-Update löst erneut den Effect aus.

---

### Ursachen

1. **Fehlendes oder falsches Abhängigkeitsarray**

   ```jsx
   useEffect(() => {
     setCount(count + 1); // triggert bei jedem Render -> Endlosschleife
   }); // kein []
   ```

2. **Unnötige Abhängigkeiten**

   * Wenn Werte ins Array aufgenommen werden, die sich bei jedem Render ändern (z. B. Objekte/Funktionen).

---

### Lösungen

1. **Korrektes Abhängigkeitsarray nutzen**

   ```jsx
   useEffect(() => {
     fetchData();
   }, []); // nur beim ersten Mount
   ```

2. **Funktionsupdates für State nutzen**

   ```jsx
   useEffect(() => {
     const id = setInterval(() => {
       setCount(prev => prev + 1); // nutzt vorherigen Wert, vermeidet Endlosschleife
     }, 1000);

     return () => clearInterval(id);
   }, []);
   ```

3. **Memoization für Objekte/Funktionen**

   * `useMemo` oder `useCallback` nutzen, damit sich die Abhängigkeiten nicht bei jedem Render ändern.

   ```jsx
   const memoizedFn = useCallback(() => {
     console.log("Nur bei Bedarf neu erzeugt");
   }, []);

   useEffect(() => {
     memoizedFn();
   }, [memoizedFn]);
   ```

---

### Zusammenfassung

* Endlosschleifen entstehen durch **falsche oder fehlende Dependency Arrays** in `useEffect`.
* Lösung: korrektes Abhängigkeitsarray, funktionale Updates, Memoization (`useCallback`, `useMemo`).
* Grundregel: **nur echte Abhängigkeiten angeben** und Werte stabil halten.

📖 Weiterführend:

* [React Offizielle Dokumentation – useEffect](https://react.dev/reference/react/useEffect)

---

  **[⬆ Наверх](#top)**

58. ### <a name="58"></a> Wie implementiert man Timeout oder Interval mit Hooks?

### Timeout & Interval mit Hooks

In Funktionskomponenten werden **`setTimeout`** und **`setInterval`** zusammen mit `useEffect` und `useRef` genutzt. Wichtig: **Cleanup** im `useEffect` verhindert Speicherlecks.

---

### Timeout (`setTimeout`)

```jsx
import { useEffect, useState } from "react";

function TimeoutDemo() {
  const [message, setMessage] = useState("Warte...");

  useEffect(() => {
    const id = setTimeout(() => {
      setMessage("Fertig nach 3 Sekunden!");
    }, 3000);

    return () => clearTimeout(id); // Cleanup beim Unmount
  }, []);

  return <p>{message}</p>;
}

export default TimeoutDemo;
```

---

### Interval (`setInterval`)

```jsx
import { useEffect, useState } from "react";

function IntervalDemo() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const id = setInterval(() => {
      setCount(prev => prev + 1); // funktionales Update vermeidet Endlosschleife
    }, 1000);

    return () => clearInterval(id); // Cleanup beim Unmount
  }, []);

  return <p>Zähler: {count}</p>;
}

export default IntervalDemo;
```

---

### Zusammenfassung

* **Timeout**: `setTimeout` + `clearTimeout` in `useEffect`.
* **Interval**: `setInterval` + `clearInterval` in `useEffect`.
* Cleanup-Funktion verhindert Leaks und unerwünschte Effekte.
* Funktionale Updates (`prev => prev + 1`) sind wichtig, um Endlosschleifen zu vermeiden.

📖 Weiterführend:

* [React Offizielle Dokumentation – useEffect](https://react.dev/reference/react/useEffect)

---

  **[⬆ Наверх](#top)**

59. ### <a name="59"></a> 



  **[⬆ Наверх](#top)**

60. ### <a name="60"></a> 



  **[⬆ Наверх](#top)**

61. ### <a name="61"></a> Was ist ein Higher-Order Component (HOC)?

### Higher-Order Component (HOC)

Ein **Higher-Order Component (HOC)** ist eine **Funktion**, die eine Komponente entgegennimmt und eine **neue erweiterte Komponente** zurückgibt.
HOCs sind ein **Pattern zur Wiederverwendung von Logik** zwischen Komponenten.

---

### Merkmale

* HOC = **`Component => NewComponent`**.
* Trennung von **Logik** und **Darstellung**.
* Typisch für: Code-Wiederverwendung, Cross-Cutting Concerns (z. B. Auth, Logging).

---

### Beispiel

```jsx
import React from "react";

// HOC: nimmt Komponente, liefert neue zurück
function withLogger(WrappedComponent) {
  return function Enhanced(props) {
    console.log("Props:", props);
    return <WrappedComponent {...props} />;
  };
}

// Nutzung
function Button({ label }) {
  return <button>{label}</button>;
}

const LoggedButton = withLogger(Button);

export default function App() {
  return <LoggedButton label="Klick mich" />;
}
```

* `withLogger` erweitert `Button` um Logging.
* `Button` selbst bleibt unverändert, Wiederverwendung bleibt möglich.

---

### Zusammenfassung

* **HOC** = Funktion, die eine Komponente um zusätzliche Logik erweitert.
* Typische Verwendung: **Code-Sharing, Auth, Logging, Daten-Handling**.
* Heute oft ersetzt durch **Hooks** oder **Render Props**.

📖 Weiterführend:

* [React Offizielle Dokumentation – HOCs](https://react.dev/learn/reusing-logic-with-higher-order-components)

---

  **[⬆ Наверх](#top)**

62. ### <a name="62"></a> Was ist das Render-Prop-Pattern?

### Render-Prop-Pattern

Ein **Render-Prop** ist ein **Pattern in React**, bei dem eine Komponente eine **Funktion als Prop** erhält, die bestimmt, **was gerendert wird**.
Damit können Komponenten **Logik wiederverwenden**, ohne UI starr vorzugeben.

---

### Merkmale

* „Prop“ = eine **Funktion**, die React-Elemente zurückgibt.
* Trennung von **Logik** (in der Container-Komponente) und **Darstellung** (durch die Render-Prop-Funktion).
* Alternative zu HOCs für **Code-Wiederverwendung**.

---

### Beispiel

```jsx
import { useState } from "react";

// Container-Komponente mit Render-Prop
function MouseTracker({ render }) {
  const [pos, setPos] = useState({ x: 0, y: 0 });

  return (
    <div
      style={{ height: "200px", border: "1px solid black" }}
      onMouseMove={e => setPos({ x: e.clientX, y: e.clientY })}
    >
      {render(pos)} {/* Render-Prop entscheidet, was angezeigt wird */}
    </div>
  );
}

// Nutzung
export default function App() {
  return (
    <MouseTracker
      render={({ x, y }) => (
        <p>Cursor bei ({x}, {y})</p>
      )}
    />
  );
}
```

* `MouseTracker` enthält die **Logik (onMouseMove)**.
* Das UI wird flexibel durch `render` definiert.

---

### Zusammenfassung

* **Render-Prop-Pattern**: Komponente erhält eine **Funktion als Prop**, die JSX zurückgibt.
* Vorteil: **Wiederverwendbare Logik** + flexible Darstellung.
* Wird heute oft durch **Custom Hooks** ersetzt.

📖 Weiterführend:

* [React Offizielle Dokumentation – Render Props](https://react.dev/learn/passing-props-to-a-component#passing-render-props)

---

  **[⬆ Наверх](#top)**

63. ### <a name="63"></a> Was ist die Context-API und wie funktioniert useContext?

### Context-API in React

Die **Context-API** ist ein Mechanismus, um **globale Daten** (z. B. Theme, Auth-Status, Sprache) bereitzustellen, **ohne Prop Drilling** durch viele Ebenen.
Sie besteht aus drei Teilen:

1. `createContext(defaultValue)` – erstellt einen Context.
2. `Provider` – stellt den Wert für Kinder bereit.
3. `useContext` – liest den Wert direkt in einer Kindkomponente aus.

---

### Funktionsweise von `useContext`

* `useContext(MyContext)` greift auf den **nächstgelegenen Provider-Wert** zu.
* Ändert sich der Context-Wert, werden alle abhängigen Komponenten neu gerendert.
* Ohne Provider wird der **defaultValue** genutzt.

---

### Beispiel

```jsx
import { createContext, useContext } from "react";

// 1. Context erstellen
const ThemeContext = createContext("light");

function ThemedButton() {
  // 2. Zugriff auf den Wert
  const theme = useContext(ThemeContext);
  return <button className={theme}>Thema: {theme}</button>;
}

export default function App() {
  return (
    // 3. Provider umschließt die Kinder
    <ThemeContext.Provider value="dark">
      <ThemedButton />
    </ThemeContext.Provider>
  );
}
```

* `App` definiert den Wert `"dark"`.
* `ThemedButton` greift mit `useContext(ThemeContext)` darauf zu.

---

### Zusammenfassung

* **Context-API** = globale Datenverwaltung ohne Prop Drilling.
* **`useContext`** = Hook zum direkten Zugriff auf Context-Werte.
* Vorteil: einfache Verteilung globaler Zustände, Nachteil: viele Re-Renders bei großen Bäumen → oft mit **Memoization/State-Management-Libs** kombiniert.

📖 Weiterführend:

* [React Offizielle Dokumentation – Context](https://react.dev/reference/react/useContext)

---

  **[⬆ Наверх](#top)**

64. ### <a name="64"></a> Was sind Portale in React?

### Portale in React

Ein **Portal** in React ermöglicht es, **JSX-Inhalte außerhalb der DOM-Hierarchie der Elternkomponente** zu rendern.
Man kann damit UI-Elemente (z. B. Modals, Tooltips, Overlays) direkt in einen **anderen DOM-Knoten** einfügen.

---

### Funktionsweise

* `ReactDOM.createPortal(child, container)`
* `child` = React-Element(e), die gerendert werden sollen.
* `container` = Zielknoten im DOM, außerhalb des Standard-Root-Elements.

---

### Beispiel

```jsx
import { useState } from "react";
import { createPortal } from "react-dom";

function Modal({ children, onClose }) {
  return createPortal(
    <div className="modal">
      <div className="content">{children}</div>
      <button onClick={onClose}>Schließen</button>
    </div>,
    document.getElementById("modal-root") // anderer DOM-Knoten
  );
}

export default function App() {
  const [open, setOpen] = useState(false);

  return (
    <>
      <button onClick={() => setOpen(true)}>Modal öffnen</button>
      {open && <Modal onClose={() => setOpen(false)}>Hallo aus dem Portal!</Modal>}
    </>
  );
}
```

* In `index.html` muss ein zusätzlicher Knoten vorhanden sein:

```html
<div id="root"></div>
<div id="modal-root"></div>
```

---

### Zusammenfassung

* **Portale** = Möglichkeit, Inhalte in einen **anderen DOM-Knoten** zu rendern.
* Typische Anwendungsfälle: **Modals, Tooltips, Overlays**.
* API: `ReactDOM.createPortal(child, container)`.

📖 Weiterführend:

* [React Offizielle Dokumentation – Portals](https://react.dev/reference/react-dom/createPortal)

---

  **[⬆ Наверх](#top)**

65. ### <a name="65"></a> Was ist bedingtes Rendern (Conditional Rendering)?

### Bedingtes Rendern in React

**Conditional Rendering** bedeutet, dass eine Komponente **UI-Elemente abhängig von Bedingungen** rendert – ähnlich wie `if/else` in JavaScript.
Damit kann React **unterschiedliche Inhalte** anzeigen, je nach State, Props oder Logik.

---

### Beispiele

**1. If/Else über ternären Operator:**

```jsx
function Greeting({ isLoggedIn }) {
  return (
    <div>
      {isLoggedIn ? <h1>Willkommen zurück!</h1> : <h1>Bitte einloggen</h1>}
    </div>
  );
}
```

**2. Bedingte Anzeige mit `&&`:**

```jsx
function Notification({ unread }) {
  return (
    <div>
      <h2>Postfach</h2>
      {unread > 0 && <p>Du hast {unread} ungelesene Nachrichten.</p>}
    </div>
  );
}
```

**3. Rückgabe von `null`:**

```jsx
function Warning({ show }) {
  if (!show) return null; // nichts rendern
  return <p>Achtung!</p>;
}
```

---

### Zusammenfassung

* **Conditional Rendering** = UI abhängig von Bedingungen.
* Möglichkeiten: **Ternary Operator, `&&`, `if/else`, `null`**.
* Typische Fälle: Auth, Ladezustand, Fehleranzeige.

📖 Weiterführend:

* [React Offizielle Dokumentation – Conditional Rendering](https://react.dev/learn/conditional-rendering)

---

  **[⬆ Наверх](#top)**

66. ### <a name="66"></a> Was ist ein Error Boundary?

### Error Boundary in React

Ein **Error Boundary** ist eine **Klassenkomponente**, die **JavaScript-Fehler** in ihrem Kind-Baum abfängt und eine **Fallback-UI** anzeigt, anstatt dass die gesamte Anwendung abstürzt.

---

### Eigenschaften

* Error Boundaries fangen **Render-Fehler**, Fehler in **Lifecycle-Methoden** und in **Konstruktoren von Kind-Komponenten** ab.
* Sie fangen **keine Fehler** in Event-Handlern, asynchronem Code (z. B. `setTimeout`) oder Server-Code.
* Wichtige Methoden:

  * `static getDerivedStateFromError(error)` → aktualisiert State für Fallback-UI.
  * `componentDidCatch(error, info)` → Logging oder Error-Reporting.

---

### Beispiel

```jsx
import React from "react";

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError() {
    return { hasError: true };
  }

  componentDidCatch(error, info) {
    console.error("Fehler abgefangen:", error, info);
  }

  render() {
    if (this.state.hasError) {
      return <h2>Etwas ist schiefgelaufen.</h2>;
    }
    return this.props.children;
  }
}

// Nutzung
function BuggyComponent() {
  throw new Error("Crash!");
}

export default function App() {
  return (
    <ErrorBoundary>
      <BuggyComponent />
    </ErrorBoundary>
  );
}
```

---

### Zusammenfassung

* **Error Boundary** = Klassenkomponente, die Fehler abfängt und Fallback-UI rendert.
* Methoden: `getDerivedStateFromError`, `componentDidCatch`.
* Einsatz: Schutz vor UI-Crashs, Logging, bessere User Experience.

📖 Weiterführend:

* [React Offizielle Dokumentation – Error Boundaries](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary)

---

  **[⬆ Наверх](#top)**

67. ### <a name="67"></a> Wie funktioniert Event-Handling in React?

### Event-Handling in React

* Events in React funktionieren ähnlich wie in DOM, sind aber in eine **synthetische Event-Schicht** (Synthetic Events) eingebettet.
* Dadurch sind Events in allen Browsern **konsistent**.
* Event-Handler werden als **CamelCase-Props** übergeben (z. B. `onClick` statt `onclick`).
* Statt Strings wird eine **Funktion** übergeben.

---

### Beispiel

```jsx
function Button() {
  function handleClick(event) {
    console.log("Geklickt!", event.type);
  }

  return (
    <button onClick={handleClick}>
      Klick mich
    </button>
  );
}

export default Button;
```

* `onClick={handleClick}` → Funktion wird als Callback übergeben.
* Das Event-Objekt (`event`) ist ein **SyntheticEvent** mit gleichen Methoden wie beim DOM-Event (`preventDefault`, `stopPropagation`).

---

### Besondere Punkte

1. **Event-Bindung mit Arrow Functions**

   ```jsx
   <button onClick={() => console.log("Inline-Handler")}>Click</button>
   ```

2. **`this`-Binding bei Klassen**
   In Klassenkomponenten muss man Methoden oft im Konstruktor binden oder Arrow Functions verwenden.

3. **Event Delegation**
   React hängt Events **nicht direkt am DOM-Element**, sondern am Root-Knoten (`document`), was Performance optimiert.

---

### Zusammenfassung

* Event-Handling in React basiert auf **Synthetic Events** für Browser-Konsistenz.
* Syntax: **CamelCase**-Props + Callback-Funktion.
* Vorteile: einheitliches API, Event Delegation, bekannte DOM-Methoden (`preventDefault`, `stopPropagation`).

📖 Weiterführend:

* [React Offizielle Dokumentation – Events](https://react.dev/learn/responding-to-events)
* [MDN – Einführung in DOM-Events (RU)](https://developer.mozilla.org/ru/docs/Learn/JavaScript/Building_blocks/Events)

---

  **[⬆ Наверх](#top)**

68. ### <a name="68"></a> Was ist ein synthetisches Ereignis (SyntheticEvent)?

### SyntheticEvent in React

Ein **SyntheticEvent** ist eine von React bereitgestellte **Wrapper-Schicht um native DOM-Events**.
Es sorgt für **Browser-Konsistenz** und stellt in allen Umgebungen die gleiche API bereit.

---

### Eigenschaften

* Enthält die gleichen Methoden wie native Events: `preventDefault()`, `stopPropagation()`.
* Funktioniert in allen Browsern gleich → kein spezielles Polyfill nötig.
* Events werden aus Performance-Gründen **gepoolt** (nach der Event-Callback-Ausführung sind die Eigenschaften auf `null` gesetzt).

  * Falls man das Event **asynchron** nutzen will, muss man `event.persist()` aufrufen.

---

### Beispiel

```jsx
function Form() {
  function handleSubmit(e) {
    e.preventDefault(); // SyntheticEvent mit DOM-API
    console.log("Formular gesendet!");
  }

  return (
    <form onSubmit={handleSubmit}>
      <button type="submit">Absenden</button>
    </form>
  );
}
```

**Asynchrone Nutzung:**

```jsx
function InputLogger() {
  function handleChange(e) {
    e.persist(); // Event bleibt erhalten
    setTimeout(() => console.log(e.target.value), 1000);
  }

  return <input onChange={handleChange} />;
}
```

---

### Zusammenfassung

* **SyntheticEvent** = React-Wrapper um native DOM-Events.
* Vorteil: **einheitliches Event-System, Cross-Browser-Kompatibilität, Performance durch Event-Pooling**.
* Bei asynchroner Nutzung: `event.persist()`.

📖 Weiterführend:

* [React Offizielle Dokumentation – SyntheticEvent](https://react.dev/reference/react/SyntheticEvent)
* [MDN – DOM Events](https://developer.mozilla.org/ru/docs/Web/API/Event)

---

  **[⬆ Наверх](#top)**

69. ### <a name="69"></a> Was ist props.children?

### `props.children` in React

* **`props.children`** ist eine **spezielle Prop**, die automatisch alle **verschachtelten Inhalte (Child-Elemente)** einer Komponente enthält.
* Damit lassen sich **Wrapper- oder Layout-Komponenten** flexibel gestalten, ohne vorher zu wissen, was darin steht.

---

### Beispiel

```jsx
function Card({ children }) {
  return <div className="card">{children}</div>;
}

export default function App() {
  return (
    <Card>
      <h2>Titel</h2>
      <p>Das ist Inhalt innerhalb von Card</p>
    </Card>
  );
}
```

* `props.children` enthält hier `<h2>...</h2>` und `<p>...</p>`.
* Card kann beliebige Inhalte aufnehmen, ohne diese fest im Code zu definieren.

---

### Zusammenfassung

* **`props.children`** = Container für verschachtelte Inhalte einer Komponente.
* Einsatz: Wrapper-, Layout- und Container-Komponenten.
* Vorteil: **maximale Flexibilität** und Wiederverwendung von UI-Strukturen.

📖 Weiterführend:

* [React Offizielle Dokumentation – Children](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children)

---

  **[⬆ Наверх](#top)**

70. ### <a name="70"></a> Was bedeutet „controlled component“ und „uncontrolled component“ bei Formularen?

### Controlled Components

* Bei einer **controlled component** verwaltet **React den Wert** eines Formularelements über den **State**.
* Der Wert wird durch `value`-Prop gesetzt und über `onChange` aktualisiert.
* React = **Single Source of Truth**.

```jsx
import { useState } from "react";

function ControlledInput() {
  const [text, setText] = useState("");

  return (
    <input
      value={text}
      onChange={e => setText(e.target.value)}
    />
  );
}
```

---

### Uncontrolled Components

* Bei einer **uncontrolled component** verwaltet das **DOM selbst den Wert**.
* React greift über eine **Ref** auf den aktuellen Wert zu.
* Weniger Code, aber weniger Kontrolle durch React.

```jsx
import { useRef } from "react";

function UncontrolledInput() {
  const inputRef = useRef();

  const handleSubmit = () => {
    alert(inputRef.current.value); // Wert direkt aus DOM
  };

  return (
    <>
      <input ref={inputRef} />
      <button onClick={handleSubmit}>Absenden</button>
    </>
  );
}
```

---

### Vergleich

| Controlled                       | Uncontrolled                  |
| -------------------------------- | ----------------------------- |
| React verwaltet den Wert (State) | DOM verwaltet den Wert        |
| `value` + `onChange`             | Zugriff via `ref`             |
| Bessere Validierung & Kontrolle  | Einfachere schnelle Umsetzung |

---

### Zusammenfassung

* **Controlled Component**: Wert im React-State, volle Kontrolle.
* **Uncontrolled Component**: Wert im DOM, Zugriff via Ref.
* Best Practice: Controlled für komplexe Formulare, Uncontrolled für einfache Fälle.

📖 Weiterführend:

* [React Offizielle Dokumentation – Controlled vs. Uncontrolled](https://react.dev/learn/sharing-state-between-components#controlled-and-uncontrolled-components)

---

  **[⬆ Наверх](#top)**

71. ### <a name="71"></a> 



  **[⬆ Наверх](#top)**

72. ### <a name="72"></a> 



  **[⬆ Наверх](#top)**

73. ### <a name="73"></a> 



  **[⬆ Наверх](#top)**

74. ### <a name="74"></a> 



  **[⬆ Наверх](#top)**

75. ### <a name="75"></a> 



  **[⬆ Наверх](#top)**

76. ### <a name="76"></a> Wie führt man API-Aufrufe mit Fetch oder Axios durch?

### API-Aufrufe in React mit **Fetch** und **Axios**

In React führt man API-Requests meist in **`useEffect`** aus, damit sie nach dem Rendern starten.
Der Response wird im **State** gespeichert.

---

### Mit **Fetch**

```jsx
import { useState, useEffect } from "react";

function Users() {
  const [users, setUsers] = useState([]);

  useEffect(() => {
    fetch("https://jsonplaceholder.typicode.com/users")
      .then(res => res.json())
      .then(data => setUsers(data))
      .catch(err => console.error(err));
  }, []); // nur einmal beim Mount

  return (
    <ul>
      {users.map(u => <li key={u.id}>{u.name}</li>)}
    </ul>
  );
}
```

---

### Mit **Axios**

```jsx
import { useState, useEffect } from "react";
import axios from "axios";

function Users() {
  const [users, setUsers] = useState([]);

  useEffect(() => {
    axios.get("https://jsonplaceholder.typicode.com/users")
      .then(res => setUsers(res.data))
      .catch(err => console.error(err));
  }, []);

  return (
    <ul>
      {users.map(u => <li key={u.id}>{u.name}</li>)}
    </ul>
  );
}
```

---

### Unterschiede **Fetch vs. Axios**

* **Fetch**: eingebaut im Browser, aber kein automatisches JSON-Parsing für Fehler.
* **Axios**: externe Bibliothek, komfortabler (automatisches JSON, Timeouts, Interceptors).

---

### Zusammenfassung

* API-Aufrufe in React mit **`useEffect` + State** umsetzen.
* **Fetch** = native API, minimalistisch.
* **Axios** = komfortabler, mit Extras wie Interceptors.

📖 Weiterführend:

* [React Offizielle Dokumentation – Daten abrufen](https://react.dev/learn/synchronizing-with-effects#fetching-data)
* [MDN – Fetch API (RU)](https://developer.mozilla.org/ru/docs/Web/API/Fetch_API)

---

  **[⬆ Наверх](#top)**

77. ### <a name="77"></a> Wie verwaltet man Lade-, Fehler- und Erfolgsstatus?

### Lade-, Fehler- und Erfolgsstatus verwalten (Patterns)

**Grundidee:** Status als **endlichen Automat** modellieren (`'idle' | 'loading' | 'success' | 'error'`) und **UI zustandsbasiert** rendern.

---

### Minimal-Pattern mit Fetch + `useEffect`

```jsx
import { useEffect, useState } from "react";

export default function Users() {
  const [status, setStatus] = useState("idle");     // 'idle' | 'loading' | 'success' | 'error'
  const [data, setData] = useState(null);
  const [error, setError] = useState(null);

  useEffect(() => {
    const ctrl = new AbortController();
    const load = async () => {
      try {
        setStatus("loading");
        const res = await fetch("https://jsonplaceholder.typicode.com/users", { signal: ctrl.signal });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const json = await res.json();
        setData(json);
        setStatus("success");
      } catch (e) {
        if (e.name !== "AbortError") {
          setError(e);
          setStatus("error");
        }
      }
    };
    load();
    return () => ctrl.abort(); // Cleanup verhindert Setzen nach Unmount
  }, []);

  if (status === "loading") return <p>Laden…</p>;
  if (status === "error") return <p>Fehler: {error.message}</p>;
  if (status === "success") {
    return <ul>{data.map(u => <li key={u.id}>{u.name}</li>)}</ul>;
  }
  return <button onClick={() => { /* optional: Lazy-Load triggern */ }}>Daten laden</button>;
}
```

**Wichtig**

* **Ein Statusfeld** statt mehrerer Booleans (verhindert inkonsistente Kombinationen).
* **AbortController** für Abbruch bei Unmount/Neuladen.
* **Fehlerprüfung** (`!res.ok`) vor `res.json()`.

---

### Reusable: kleiner `useAsync`-Hook

```jsx
import { useEffect, useRef, useState } from "react";

export function useAsync(fn, deps = []) {
  const [state, setState] = useState({ status: "idle", data: null, error: null });
  const mounted = useRef(true);

  useEffect(() => {
    mounted.current = true;
    const run = async () => {
      setState({ status: "loading", data: null, error: null });
      try {
        const data = await fn();
        if (mounted.current) setState({ status: "success", data, error: null });
      } catch (err) {
        if (mounted.current) setState({ status: "error", data: null, error: err });
      }
    };
    run();
    return () => { mounted.current = false; };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, deps);

  return state; // {status, data, error}
}

// Nutzung
// const { status, data, error } = useAsync(() => fetch("/api").then(r => r.json()), []);
```

---

### UI-Muster

* **Skeleton/Spinner** bei `loading`.
* **Retry-Button** bei `error` (neuen Fetch triggern).
* **Disabled/ARIA** während `loading` (Barrierefreiheit).
* **Optimistic UI**/Rollback bei Mutationen (separater Status je Mutation).

---

### Zusammenfassung

* Status als **disjunkte Zustände** modellieren; UI rein **zustandsgetrieben** rendern.
* Netzwerkcode in `useEffect` (mit **Cleanup/Abort**), Fehler früh prüfen.
* Für Wiederverwendung: **Custom Hook** (`useAsync`) oder Libraries (z. B. React Query/SWR).

📖 Weiterführend:

* React Docs: [Synchronizing with Effects](https://react.dev/learn/synchronizing-with-effects), [Conditional Rendering](https://react.dev/learn/conditional-rendering)
* MDN (RU): [Fetch API](https://developer.mozilla.org/ru/docs/Web/API/Fetch_API), [AbortController](https://developer.mozilla.org/ru/docs/Web/API/AbortController)

  **[⬆ Наверх](#top)**

78. ### <a name="78"></a> Wie funktioniert WebSocket mit React?

### WebSocket mit React: Grundlagen & Pattern

**Idee:** In React öffnest du die Verbindung in einem **Effect**, hältst die Socket-Instanz in einem **Ref**, registrierst **Event-Handler**, und räumst im **Cleanup** wieder auf. State speichert eingehende Daten.

---

### Minimalbeispiel (Empfangen & Senden)

```jsx
import { useEffect, useRef, useState, useCallback } from "react";

export default function Chat() {
  const [messages, setMessages] = useState([]);
  const [connected, setConnected] = useState(false);
  const socketRef = useRef(null);

  // Verbindung aufbauen
  useEffect(() => {
    const ws = new WebSocket("wss://echo.websocket.events"); // Demo-Endpoint
    socketRef.current = ws;

    ws.addEventListener("open", () => setConnected(true));
    ws.addEventListener("message", (e) => {
      // optional JSON.parse(e.data)
      setMessages((prev) => [...prev, String(e.data)]);
    });
    ws.addEventListener("close", () => setConnected(false));
    ws.addEventListener("error", () => setConnected(false));

    return () => {
      ws.close(); // Cleanup beim Unmount
    };
  }, []);

  // Stabiler send()-Callback
  const sendMessage = useCallback((text) => {
    const ws = socketRef.current;
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(text);
    }
  }, []);

  return (
    <>
      <p>Status: {connected ? "verbunden" : "getrennt"}</p>
      <button onClick={() => sendMessage("Hallo WebSocket!")}>Senden</button>
      <ul>{messages.map((m, i) => <li key={i}>{m}</li>)}</ul>
    </>
  );
}
```

---

### Robuster Custom Hook mit Reconnect & Backoff

```jsx
import { useEffect, useRef, useState, useCallback } from "react";

export function useWebSocket(url, { reconnect = true, maxDelay = 8000 } = {}) {
  const wsRef = useRef(null);
  const [readyState, setReadyState] = useState(WebSocket.CLOSED);
  const [lastMessage, setLastMessage] = useState(null);
  const retryRef = useRef(0);
  const timerRef = useRef(null);

  const connect = useCallback(() => {
    const ws = new WebSocket(url);
    wsRef.current = ws;

    ws.onopen = () => {
      setReadyState(ws.readyState);
      retryRef.current = 0; // Reset Backoff
    };
    ws.onmessage = (e) => setLastMessage(e.data);
    ws.onerror = () => {};
    ws.onclose = () => {
      setReadyState(WebSocket.CLOSED);
      if (reconnect) {
        const delay = Math.min(1000 * 2 ** retryRef.current++, maxDelay);
        timerRef.current = setTimeout(connect, delay);
      }
    };
    setReadyState(ws.readyState);
  }, [url, reconnect, maxDelay]);

  useEffect(() => {
    connect();
    return () => {
      reconnect = false; // eslint-disable-line no-param-reassign
      clearTimeout(timerRef.current);
      wsRef.current?.close();
    };
  }, [connect]);

  const send = useCallback((data) => {
    const ws = wsRef.current;
    if (ws?.readyState === WebSocket.OPEN) ws.send(data);
  }, []);

  return { readyState, lastMessage, send };
}
```

**Nutzung:**

```jsx
import { useEffect, useState } from "react";
import { useWebSocket } from "./useWebSocket.js";

export default function Ticker() {
  const { readyState, lastMessage, send } = useWebSocket("wss://echo.websocket.events");
  const [log, setLog] = useState([]);

  useEffect(() => {
    if (lastMessage != null) setLog((l) => [...l, String(lastMessage)]);
  }, [lastMessage]);

  return (
    <>
      <p>State: {readyState === WebSocket.OPEN ? "OPEN" : readyState}</p>
      <button onClick={() => send(JSON.stringify({ ping: Date.now() }))}>Ping</button>
      <ul>{log.map((x, i) => <li key={i}>{x}</li>)}</ul>
    </>
  );
}
```

---

### Best Practices

* **`useRef`** für die Socket-Instanz (verändert sich ohne Re-Render).
* **Cleanup** im `useEffect` → `ws.close()`.
* **Nachrichtenformat**: JSON verwenden (`JSON.stringify/parse`), Versionierung des Payloads beachten.
* **Reconnect** mit **exponentiellem Backoff**; bei Auth-Sockets (JWT) Token-Refresh einplanen.
* **Sicherheit**: `wss://`, serverseitige Origin/Rate-Limits, Heartbeats/Pings für Keep-Alive.
* **Zustandsmodell**: UI klar zwischen `OPEN/CONNECTING/CLOSING/CLOSED` unterscheiden.

---

### Zusammenfassung

* WebSocket in React: **öffnen im `useEffect`**, **Instanz in `useRef`**, **Event-Handler registrieren**, **Cleanup** beim Unmount.
* Senden über stabilen **`useCallback`**; für Wiederverwendung **Custom Hook** mit Reconnect/Backoff bauen.
* JSON-Payloads, Fehler-/Statushandling und Sicherheit berücksichtigen.

📖 Weiterführend:

* React Docs: [Effects](https://react.dev/learn/synchronizing-with-effects)
* MDN (RU): [WebSocket API](https://developer.mozilla.org/ru/docs/Web/API/WebSockets_API), [WebSocket](https://developer.mozilla.org/ru/docs/Web/API/WebSocket)

  **[⬆ Наверх](#top)**

79. ### <a name="79"></a> Wie kann man Daten zwischen Komponenten weitergeben?

### Datenfluss zwischen Komponenten in React

**1) Eltern → Kind: über Props**

```jsx
function Child({ title }) {
  return <h2>{title}</h2>;
}

export default function Parent() {
  return <Child title="Hallo, Sergii" />;
}
```

**2) Kind → Eltern: über Callback-Props (Bottom-up Events)**

```jsx
import { useState } from "react";

function Child({ onChange }) {
  return <button onClick={() => onChange("Neuer Wert")}>Senden</button>;
}

export default function Parent() {
  const [val, setVal] = useState("");
  return (
    <>
      <Child onChange={setVal} />
      <p>Empfangen: {val}</p>
    </>
  );
}
```

**3) Geschwister-Komponenten:** **Lifting State Up** (gemeinsamer Eltern-State)

```jsx
import { useState } from "react";

function A({ value, onChange }) {
  return <button onClick={() => onChange(value + 1)}>A+1</button>;
}
function B({ value }) { return <p>B sieht: {value}</p>; }

export default function Parent() {
  const [n, setN] = useState(0);
  return (
    <>
      <A value={n} onChange={setN} />
      <B value={n} />
    </>
  );
}
```

**4) Global/über viele Ebenen:** **Context-API (`useContext`)** – vermeidet Prop Drilling

```jsx
import { createContext, useContext } from "react";

const AuthContext = createContext({ user: null });

function UserTag() {
  const { user } = useContext(AuthContext);
  return <span>{user?.name ?? "Gast"}</span>;
}

export default function App() {
  return (
    <AuthContext.Provider value={{ user: { name: "Sergii" } }}>
      <UserTag />
    </AuthContext.Provider>
  );
}
```

**5) Fortgeschritten (optional):**

* **URL/Router** (z. B. Query-/Path-Parameter), **State-Management-Libs** (Redux, Zustand), **Events** (selten), **Server State** (React Query/SWR).
* **Refs** via `forwardRef` für imperativen Zugriff, **nicht** für allgemeinen Datenfluss.

---

### Zusammenfassung

* Standard: **Props** (Top-down) und **Callbacks** (Bottom-up).
* **Geschwister** teilen Daten über **Lifting State Up**.
* **Context** für globale/weit gestreute Daten.
* Bei komplexen Fällen: **Router/State-Management/Server-State** ergänzen.

📖 Weiterführend:

* React Docs: [Props weitergeben](https://react.dev/learn/passing-props-to-a-component), [State teilen & Lifting State Up](https://react.dev/learn/sharing-state-between-components), [Context & useContext](https://react.dev/reference/react/useContext)
* MDN (RU): [Веб-события (обзор)](https://developer.mozilla.org/ru/docs/Learn/JavaScript/Building_blocks/Events)

  **[⬆ Наверх](#top)**

80. ### <a name="80"></a> Wie macht man einen Datenabruf nur beim ersten Rendern?

### Datenabruf nur beim ersten Render (Mount)

**Pattern:** `useEffect` mit **leerem Abhängigkeitsarray `[]`**.
Hinweis: In **React 18** ruft der Dev-Mode (Strict Mode) Effekte absichtlich **zweimal** auf (Mount → Cleanup → Mount) zur Fehlererkennung. In Production nur einmal. Nutze **AbortController** oder eine **Ref-Garde**, um Doppel-Requests zu vermeiden.

```jsx
import { useEffect, useState, useRef } from "react";

export default function UsersOnce() {
  const [users, setUsers] = useState([]);
  const [status, setStatus] = useState("idle"); // 'idle' | 'loading' | 'success' | 'error'
  const fetchedRef = useRef(false); // schützt vor Doppel-Fetch im Dev-Mode

  useEffect(() => {
    if (fetchedRef.current) return;    // schon geladen? -> abbrechen
    fetchedRef.current = true;

    const ctrl = new AbortController();
    const load = async () => {
      try {
        setStatus("loading");
        const res = await fetch("https://jsonplaceholder.typicode.com/users", {
          signal: ctrl.signal,
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();
        setUsers(data);
        setStatus("success");
      } catch (e) {
        if (e.name !== "AbortError") setStatus("error");
      }
    };

    load();
    return () => ctrl.abort(); // Cleanup verhindert Leaks/SetState-after-unmount
  }, []); // nur beim (ersten) Mount

  if (status === "loading") return <p>Laden…</p>;
  if (status === "error") return <p>Fehler beim Laden.</p>;
  return <ul>{users.map(u => <li key={u.id}>{u.name}</li>)}</ul>;
}
```

**Alternativen/Ergänzungen**

* **Idempotenter Request** (Server akzeptiert wiederholte Calls ohne Seiteneffekt).
* **Datenbibliotheken** wie React Query/SWR cachen & deduplizieren Requests automatisch.

---

### Zusammenfassung

* „Nur einmal laden“: `useEffect(() => {...}, [])`.
* In React 18 dev kann der Effekt doppelt laufen → **`AbortController`** oder **Ref-Garde** nutzen.
* Cleanup im Effekt verhindert Speicherlecks und Fehlzustände.

📖 Weiterführend:

* React Docs: [Effects & Abhängigkeiten](https://react.dev/learn/synchronizing-with-effects)
* React Docs: [useEffect API](https://react.dev/reference/react/useEffect)
* MDN (RU): [Fetch API](https://developer.mozilla.org/ru/docs/Web/API/Fetch_API), [AbortController](https://developer.mozilla.org/ru/docs/Web/API/AbortController)

  **[⬆ Наверх](#top)**  

81. ### <a name="81"></a> Was ist das Problem bei „stale closures“ mit Hooks?

### „Stale Closures“ in React Hooks

Ein **stale closure** tritt auf, wenn eine Funktion innerhalb einer Komponente auf **veraltete Variablenwerte** zugreift, weil sie an den Zustand **gebunden wurde, der zum Zeitpunkt der Definition gültig war** – nicht am aktuellen State/Prop.

---

### Beispiel (Problem)

```jsx
import { useEffect, useState } from "react";

function Timer() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const id = setInterval(() => {
      // ❌ stale closure: 'count' ist immer 0
      setCount(count + 1);
    }, 1000);

    return () => clearInterval(id);
  }, []); // [] → Effekt läuft nur einmal, count ist „eingefroren“

  return <p>{count}</p>;
}
```

* `count` im Callback bleibt **immer 0**, weil das Closure aus dem ersten Render eingefroren ist.
* Ergebnis: Zähler bleibt bei `1` stehen.

---

### Lösungen

1. **Funktionale Updates verwenden**

   ```jsx
   setCount(prev => prev + 1); // aktueller Wert garantiert
   ```

   ```jsx
   useEffect(() => {
     const id = setInterval(() => setCount(prev => prev + 1), 1000);
     return () => clearInterval(id);
   }, []);
   ```

2. **Abhängigkeiten korrekt setzen**

   ```jsx
   useEffect(() => {
     console.log("Neuer Count:", count);
   }, [count]); // aktualisiert bei jedem Count
   ```

3. **useRef für mutable Werte**

   * Wenn man Werte **lesen, aber kein Re-Render auslösen** möchte.

---

### Zusammenfassung

* **Stale closure** = Callback in Hook verwendet **veraltete Variablenwerte**.
* Ursache: Closures binden Werte aus dem Render-Zeitpunkt.
* Lösung: **funktionale Updates (`prev => ...`)**, korrekte **Dependencies** oder **Refs**.

📖 Weiterführend:

* [React Docs – useEffect & Closures](https://react.dev/learn/synchronizing-with-effects#what-to-do-when-you-disagree-with-the-linter)
* [Dan Abramov – A Complete Guide to useEffect](https://overreacted.io/a-complete-guide-to-useeffect/)

---

  **[⬆ Наверх](#top)**

82. ### <a name="82"></a> Wie funktioniert die Fehlerbehandlung mit try/catch in React?

### Fehlerbehandlung mit `try...catch` in React

1. **In Event-Handlern**

* Fehler können direkt mit `try...catch` abgefangen werden.
* Das verhindert, dass die App abstürzt.

```jsx
function Form() {
  function handleSubmit(e) {
    e.preventDefault();
    try {
      throw new Error("Ups!");
    } catch (err) {
      console.error("Fehler im Event:", err.message);
    }
  }

  return <form onSubmit={handleSubmit}><button>Absenden</button></form>;
}
```

---

2. **In asynchronem Code (z. B. Fetch, Axios)**

* `try...catch` funktioniert nur in `async`-Funktionen.
* Alternative: `.catch()` bei Promises.

```jsx
import { useEffect, useState } from "react";

function DataFetcher() {
  const [data, setData] = useState(null);
  const [error, setError] = useState(null);

  useEffect(() => {
    async function load() {
      try {
        const res = await fetch("https://jsonplaceholder.typicode.com/users");
        if (!res.ok) throw new Error("HTTP-Fehler " + res.status);
        const json = await res.json();
        setData(json);
      } catch (err) {
        setError(err);
      }
    }
    load();
  }, []);

  if (error) return <p>Fehler: {error.message}</p>;
  if (!data) return <p>Laden...</p>;
  return <ul>{data.map(u => <li key={u.id}>{u.name}</li>)}</ul>;
}
```

---

3. **Nicht möglich: Render-Phase/Lifecycle**

* Fehler im **Rendern von Komponenten** oder in **Hooks** können mit `try...catch` **nicht** abgefangen werden.
* Dafür braucht man **Error Boundaries** (`getDerivedStateFromError`, `componentDidCatch`).

---

### Zusammenfassung

* **`try...catch`** funktioniert in Event-Handlern und asynchronem Code (z. B. `fetch`).
* In der Render-Phase reicht `try...catch` nicht → dort braucht man **Error Boundaries**.
* Best Practice: **`try...catch` für asynchrone Logik**, **Error Boundaries für UI-Absturz-Schutz**.

📖 Weiterführend:

* [React Offizielle Dokumentation – Error Boundaries](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary)
* [MDN – try...catch (RU)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/try...catch)

---

  **[⬆ Наверх](#top)**

83. ### <a name="83"></a> Wie kann man ein Mock-API oder Mock Server verwenden?

### Mock-API / Mock Server in React: gängige Optionen

#### 1) **MSW – Mock Service Worker** (empfohlen: realitätsnah im Browser & Node)

* Interceptet **`fetch`/`XHR`** auf Netzwerkebene, kein Code-Ändern in Komponenten.
* Funktioniert in **Dev**, **Storybook** und **Tests (Jest/Vitest)**.

```js
// src/mocks/handlers.js
import { http, HttpResponse } from "msw";

export const handlers = [
  http.get("/api/users", () => HttpResponse.json([
    { id: 1, name: "Sergii" },
    { id: 2, name: "Anna" },
  ])),
];

// src/mocks/browser.js
import { setupWorker } from "msw/browser";
import { handlers } from "./handlers.js";
export const worker = setupWorker(...handlers);

// src/main.jsx
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import App from "./App.jsx";

async function enableMocking() {
  if (import.meta.env.DEV) {
    const { worker } = await import("./mocks/browser.js");
    await worker.start({ onUnhandledRequest: "bypass" });
  }
}
enableMocking();

createRoot(document.getElementById("root")).render(
  <StrictMode><App /></StrictMode>
);
```

```jsx
// Normales Fetching bleibt unverändert
import { useEffect, useState } from "react";

export default function Users() {
  const [users, setUsers] = useState([]);
  useEffect(() => {
    fetch("/api/users").then(r => r.json()).then(setUsers);
  }, []);
  return <ul>{users.map(u => <li key={u.id}>{u.name}</li>)}</ul>;
}
```

**Vorteile:** keine Codeveränderung am Fetching, gleiche API wie Produktion, ideal für UI-Entwicklung & Tests.

---

#### 2) **JSON Server** (schneller REST-Mock via Datei)

* Startet in Sekunden eine REST-API aus `db.json`.

```json
// db.json
{
  "users": [
    { "id": 1, "name": "Sergii" },
    { "id": 2, "name": "Anna" }
  ]
}
```

```bash
# Installation & Start
npm i -D json-server
npx json-server --watch db.json --port 4000
```

```jsx
// React: ganz normal fetchen
import { useEffect, useState } from "react";

export default function Users() {
  const [users, setUsers] = useState([]);
  useEffect(() => {
    fetch("http://localhost:4000/users").then(r => r.json()).then(setUsers);
  }, []);
  return <ul>{users.map(u => <li key={u.id}>{u.name}</li>)}</ul>;
}
```

**Vorteile:** echte REST-URLs, unterstützt Filter/Queries, ideal für Team-Prototyping.
**Hinweis:** CORS/Port beachten; ggf. Proxy in Vite/CRA konfigurieren.

---

#### 3) **MirageJS** (in-app Mock-Server)

* Startet einen **virtuellen Server im Browser**, definiert Routen/Models in JS.

```js
// src/server.js
import { createServer } from "miragejs";

export function makeServer() {
  return createServer({
    routes() {
      this.namespace = "api";
      this.get("/users", () => [
        { id: "1", name: "Sergii" },
        { id: "2", name: "Anna" },
      ]);
    },
  });
}

// src/main.jsx
import { makeServer } from "./server.js";
if (import.meta.env.DEV) makeServer();
```

**Vorteile:** komplexere Szenarien (Beziehungen, Statuscodes) ohne externen Prozess.

---

### Mocking im **Test** (Jest/Vitest) – minimal

* Entweder **MSW (Node-Adapter)** oder **Fetch mocken**:

```js
// __tests__/users.test.js
import { render, screen, waitFor } from "@testing-library/react";
import Users from "../Users.jsx";

global.fetch = vi.fn(() =>
  Promise.resolve({ ok: true, json: () => Promise.resolve([{ id: 1, name: "Sergii" }]) })
);

test("rendert Nutzerliste", async () => {
  render(<Users />);
  await waitFor(() => screen.getByText("Sergii"));
});
```

---

### Wann welche Lösung?

* **MSW:** realitätsnah, „netzwerkgetreu“, Dev & Test – **Standard-Empfehlung**.
* **JSON Server:** schnell, eigenständiger REST-Endpunkt, gut für Teams/Backend-Entkopplung.
* **MirageJS:** alles in einem Bundle, mächtig für komplexe Fake-Backends.

---

### Zusammenfassung

* Mocking-Optionen: **MSW** (Intercept), **JSON Server** (echter Dev-Server), **MirageJS** (in-app).
* React-Code bleibt idR unverändert; Mock-Schicht ersetzt/bedient die API.
* Für Tests: **MSW (Node)** oder gezieltes **Fetch-Mocking**.

📖 Weiterführend:

* React Docs: [Daten holen mit Effects](https://react.dev/learn/synchronizing-with-effects)
* MDN (RU): [Fetch API](https://developer.mozilla.org/ru/docs/Web/API/Fetch_API)
* MSW: [https://mswjs.io](https://mswjs.io)
* JSON Server: [https://github.com/typicode/json-server](https://github.com/typicode/json-server)
* MirageJS: [https://miragejs.com](https://miragejs.com)

  **[⬆ Наверх](#top)**

84. ### <a name="84"></a> Wie funktioniert Suspense für Datenabfragen?

### Suspense für Datenabfragen in React

**Suspense** ist ein React-Feature, das es ermöglicht, eine **Fallback-UI (z. B. Spinner)** anzuzeigen, solange Daten noch nicht geladen sind.
Anstatt den Ladezustand selbst mit `useState`/`useEffect` zu managen, „wartet“ React, bis ein Promise **resolved** ist, und zeigt in der Zwischenzeit den Fallback an.

---

### Grundprinzip

* Eine Komponente „wirft“ (`throw`) ein Promise während des Renderns.
* React erkennt dies und zeigt den `fallback` aus `<Suspense>` an.
* Sobald das Promise resolved ist, rendert React die eigentliche UI.

---

### Einfaches Beispiel (Simulation)

```jsx
import { Suspense } from "react";

// Hilfsfunktion: "Ressource" mit read()
function fetchData() {
  let status = "pending";
  let result;
  const suspender = fetch("https://jsonplaceholder.typicode.com/users")
    .then(r => r.json())
    .then(
      res => {
        status = "success";
        result = res;
      },
      err => {
        status = "error";
        result = err;
      }
    );

  return {
    read() {
      if (status === "pending") throw suspender; // löst Suspense aus
      if (status === "error") throw result;      // löst Error Boundary aus
      return result;
    }
  };
}

const resource = fetchData();

function UserList() {
  const users = resource.read(); // wartet über Suspense
  return (
    <ul>
      {users.map(u => <li key={u.id}>{u.name}</li>)}
    </ul>
  );
}

export default function App() {
  return (
    <Suspense fallback={<p>Lade Nutzer...</p>}>
      <UserList />
    </Suspense>
  );
}
```

---

### Typische moderne Nutzung

* React-Team empfiehlt **React Query**, **Relay** oder **Next.js (App Router)** → diese Libraries integrieren Suspense.
* Suspense selbst liefert nur den **UI-Mechanismus** – kein Fetch- oder Cache-System.

---

### Zusammenfassung

* **Suspense** zeigt Fallback-UI, solange Daten noch nicht geladen sind.
* Funktioniert, indem Komponenten während des Renderns ein **Promise werfen**.
* Für echte Projekte: in Kombination mit Libraries wie **React Query, Relay, Next.js**.

📖 Weiterführend:

* [React Offizielle Dokumentation – Suspense für Datenabfragen](https://react.dev/reference/react/Suspense#suspense-for-data-fetching)
* [React Docs – Asynchronous Rendering](https://react.dev/learn/suspense)

---

  **[⬆ Наверх](#top)**

85. ### <a name="85"></a> 



  **[⬆ Наверх](#top)**

86. ### <a name="86"></a> 



  **[⬆ Наверх](#top)**

87. ### <a name="87"></a> 



  **[⬆ Наверх](#top)**

88. ### <a name="88"></a> 



  **[⬆ Наверх](#top)**

89. ### <a name="89"></a> 



  **[⬆ Наверх](#top)**

90. ### <a name="90"></a> 



  **[⬆ Наверх](#top)**  

91. ### <a name="91"></a> Was ist Unit-, Integration- und E2E-Testing?

**Unit-, Integrations- und End-to-End-Testing (E2E)** sind verschiedene Testebenen in der Softwareentwicklung, auch im Frontend mit ReactJS.

---

### **1. Unit-Testing**

* Testet **einzelne, isolierte Einheiten** (z. B. Funktionen, React-Komponenten).
* Ziel: Sicherstellen, dass eine kleine Funktionalität unabhängig korrekt funktioniert.

**Beispiel:**

```jsx
// add.js
export function add(a, b) {
  return a + b;
}

// add.test.js (Jest)
import { add } from "./add.js";

test("addiert zwei Zahlen korrekt", () => {
  expect(add(2, 3)).toBe(5);
});
```

---

### **2. Integration-Testing**

* Testet das **Zusammenspiel mehrerer Einheiten** (z. B. Komponente + API-Aufruf + State).
* Ziel: Prüfen, ob die Integration der Teile korrekt funktioniert.

**Beispiel mit React Testing Library:**

```jsx
// Greeting.jsx
import { useState, useEffect } from "react";

export function Greeting({ name }) {
  const [message, setMessage] = useState("");

  useEffect(() => {
    setMessage(`Hallo, ${name}!`);
  }, [name]);

  return <h1>{message}</h1>;
}

// Greeting.test.js
import { render, screen } from "@testing-library/react";
import { Greeting } from "./Greeting.jsx";

test("zeigt eine Begrüßung basierend auf Props", () => {
  render(<Greeting name="Sergii" />);
  expect(screen.getByText("Hallo, Sergii!")).toBeInTheDocument();
});
```

---

### **3. End-to-End-Testing (E2E)**

* Testet die **gesamte Anwendung** aus Sicht des Benutzers.
* Simuliert echte Interaktionen im Browser (z. B. Klicks, Navigation, Formulare).
* Tools: **Cypress**, **Playwright**.

**Beispiel mit Cypress:**

```js
// e2e.spec.js
describe("Login Flow", () => {
  it("erlaubt einem Nutzer, sich einzuloggen", () => {
    cy.visit("/login");
    cy.get("input[name=username]").type("testuser");
    cy.get("input[name=password]").type("secret");
    cy.get("button[type=submit]").click();
    cy.url().should("include", "/dashboard");
    cy.contains("Willkommen, testuser");
  });
});
```

---

### **Zusammenfassung**

* **Unit-Test:** Testet einzelne Funktionen/Komponenten isoliert.
* **Integration-Test:** Testet Zusammenspiel mehrerer Teile.
* **E2E-Test:** Testet die komplette Anwendung wie ein echter Benutzer.

📖 Quellen:

* [React Testing Library](https://testing-library.com/docs/react-testing-library/intro)
* [MDN Testing](https://developer.mozilla.org/ru/docs/Learn/Tools_and_testing/Testing_client-side_JavaScript)
* [React Docs: Testing](https://react.dev/learn/testing)

---

  **[⬆ Наверх](#top)**

92. ### <a name="92"></a> Was ist Snapshot-Testing?

**Snapshot-Testing** ist eine Testmethode, bei der der **gerenderte Output einer Komponente** gespeichert (als Snapshot-Datei) und bei späteren Testläufen mit der aktuellen Ausgabe verglichen wird.
Wenn sich die Ausgabe verändert, schlägt der Test fehl – außer man akzeptiert die neue Version des Snapshots.

---

### **Beispiel mit Jest + React Testing Library**

```jsx
// Button.jsx
export function Button({ label }) {
  return <button>{label}</button>;
}

// Button.test.js
import { render } from "@testing-library/react";
import { Button } from "./Button.jsx";

test("Button Snapshot", () => {
  const { asFragment } = render(<Button label="Klick mich" />);
  expect(asFragment()).toMatchSnapshot();
});
```

➡️ Beim ersten Lauf erstellt Jest eine **Snapshot-Datei** (`__snapshots__/Button.test.js.snap`).
➡️ Bei späteren Läufen wird verglichen, ob die gerenderte Ausgabe noch identisch ist.

---

### **Vorteile**

* Schnell, einfach zu implementieren.
* Erkennt ungewollte Änderungen im UI.

### **Nachteile**

* Kann zu **falschen Alarmen** führen, wenn sich die UI oft ändert.
* Snapshots können groß und unübersichtlich werden.
* Empfohlen nur für **stabile, UI-relevante Komponenten**.

---

### **Zusammenfassung**

* Snapshot-Tests speichern den UI-Output und vergleichen ihn mit zukünftigen Versionen.
* Praktisch für UI-Regressionstests, aber vorsichtig einsetzen.

📖 Quellen:

* [React Docs – Testing UI](https://react.dev/learn/testing)
* [Jest: Snapshot Testing](https://jestjs.io/docs/snapshot-testing)

---

  **[⬆ Наверх](#top)**

93. ### <a name="93"></a> Welche Tools nutzt man für React-Tests (Jest, React Testing Library)?

### **Tools für React-Tests**

#### **1. Jest**

* Test-Runner und Assertions-Bibliothek.
* Standard-Tool im React-Ökosystem.
* Unterstützt **Unit-, Integration- und Snapshot-Tests**.
* Features: Mocking von Modulen, Timer, Snapshots.

**Beispiel:**

```js
// sum.js
export function sum(a, b) {
  return a + b;
}

// sum.test.js
import { sum } from "./sum.js";

test("addiert zwei Zahlen", () => {
  expect(sum(2, 3)).toBe(5);
});
```

---

#### **2. React Testing Library (RTL)**

* Baut auf Jest auf.
* Fokus: **Testen wie der Nutzer die App erlebt** (DOM-Queries statt Implementationsdetails).
* Nutzt Queries wie `getByText`, `getByRole`, `getByLabelText`.

**Beispiel:**

```jsx
// Greeting.jsx
export function Greeting({ name }) {
  return <h1>Hallo, {name}!</h1>;
}

// Greeting.test.js
import { render, screen } from "@testing-library/react";
import { Greeting } from "./Greeting.jsx";

test("zeigt Begrüßung an", () => {
  render(<Greeting name="Sergii" />);
  expect(screen.getByText("Hallo, Sergii!")).toBeInTheDocument();
});
```

---

#### **3. Ergänzende Tools**

* **Cypress / Playwright** → E2E-Tests.
* **MSW (Mock Service Worker)** → API-Calls mocken.
* **Vitest** → Alternative zu Jest (schneller, Vite-basiert).

---

### **Zusammenfassung**

* **Jest**: Test-Runner, Assertions, Snapshots.
* **React Testing Library**: Nutzt DOM-Queries, testet die App wie ein Benutzer.
* **Weitere Tools**: Cypress, Playwright, MSW für komplexere Szenarien.

📖 Quellen:

* [Jest Docs](https://jestjs.io/)
* [React Testing Library](https://testing-library.com/docs/react-testing-library/intro)
* [React Docs: Testing](https://react.dev/learn/testing)

---

  **[⬆ Наверх](#top)**

94. ### <a name="94"></a> Wie testet man Komponenten, Props und Events?

### Komponenten, Props und Events testen (React + RTL + Jest)

#### **1) Komponenten-Render**

* Ziel: Render funktioniert, relevantes UI ist sichtbar.

```jsx
// Counter.jsx
import { useState } from "react";
export function Counter({ initial = 0 }) {
  const [count, setCount] = useState(initial);
  return (
    <div>
      <h1 aria-label="count">{count}</h1>
      <button onClick={() => setCount(c => c + 1)}>+1</button>
    </div>
  );
}
```

```jsx
// Counter.test.jsx
import { render, screen } from "@testing-library/react";
import { Counter } from "./Counter.jsx";

test("rendert Überschrift und Button", () => {
  render(<Counter />);
  expect(screen.getByRole("heading", { name: /0/i })).toBeInTheDocument(); // via Rolle
  expect(screen.getByRole("button", { name: "+1" })).toBeInTheDocument();
});
```

#### **2) Props testen**

* Ziel: Ausgabe/Verhalten entspricht übergebenen Props (Text, Attribute, ARIA, initialer State).

```jsx
import { render, screen } from "@testing-library/react";
import { Counter } from "./Counter.jsx";

test("nutzt initial-Prop für Startwert", () => {
  render(<Counter initial={5} />);
  expect(screen.getByLabelText("count")).toHaveTextContent("5");
});
```

Weitere Prop-Beispiele:

```jsx
// Button.jsx
export function Button({ label, disabled }) {
  return <button disabled={disabled}>{label}</button>;
}

// Button.test.jsx
import { render, screen } from "@testing-library/react";
import { Button } from "./Button.jsx";

test("zeigt Label und disabled-Attribut", () => {
  render(<Button label="Speichern" disabled />);
  expect(screen.getByRole("button", { name: "Speichern" })).toBeDisabled();
});
```

#### **3) Events & Callback-Props**

* Ziel: Nutzerinteraktionen (Click, Tastatur, Eingabe) und aufgerufene Callback-Props.
* Empfehlung: **@testing-library/user-event** (realistischere Interaktionen als `fireEvent`).

```jsx
// Toggle.jsx
export function Toggle({ onChange }) {
  return (
    <label>
      <input type="checkbox" onChange={(e) => onChange(e.target.checked)} />
      Aktiv
    </label>
  );
}
```

```jsx
// Toggle.test.jsx (Jest/Vitest: jest.fn() bzw. vi.fn())
import { render, screen } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import { Toggle } from "./Toggle.jsx";

test("ruft onChange mit richtigem Wert auf", async () => {
  const onChange = jest.fn();
  render(<Toggle onChange={onChange} />);
  await userEvent.click(screen.getByRole("checkbox"));
  expect(onChange).toHaveBeenCalledWith(true);
});
```

**Formulare/Controlled Components:**

```jsx
// Search.jsx
import { useState } from "react";
export function Search({ onSubmit }) {
  const [q, setQ] = useState("");
  return (
    <form onSubmit={(e) => { e.preventDefault(); onSubmit(q); }}>
      <label htmlFor="q">Suche</label>
      <input id="q" value={q} onChange={(e) => setQ(e.target.value)} />
      <button type="submit">Suchen</button>
    </form>
  );
}
```

```jsx
// Search.test.jsx
import { render, screen } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import { Search } from "./Search.jsx";

test("übermittelt eingegebenen Wert", async () => {
  const onSubmit = jest.fn();
  render(<Search onSubmit={onSubmit} />);
  await userEvent.type(screen.getByLabelText("Suche"), "react testing");
  await userEvent.click(screen.getByRole("button", { name: /suchen/i }));
  expect(onSubmit).toHaveBeenCalledWith("react testing");
});
```

#### **4) Asynchrone Effekte & `findBy*`**

* Ziel: Auf UI warten, das nach einem Effekt/Fetch erscheint.

```jsx
// Greeting.jsx
import { useEffect, useState } from "react";
export function Greeting({ load }) {
  const [text, setText] = useState("Lädt...");
  useEffect(() => { load().then((t) => setText(t)); }, [load]);
  return <p>{text}</p>;
}
```

```jsx
// Greeting.test.jsx
import { render, screen } from "@testing-library/react";
import { Greeting } from "./Greeting.jsx";

test("wartet auf geladenen Text", async () => {
  const load = jest.fn().mockResolvedValue("Hallo Sergii!");
  render(<Greeting load={load} />);
  expect(await screen.findByText("Hallo Sergii!")).toBeInTheDocument(); // wartet async
});
```

#### **5) Best Practices (kurz)**

* Teste **sichtbares Verhalten**, nicht Implementierungsdetails (keine internen States mocken).
* Nutze **Rollen/Label** statt `getByTestId`, wo möglich (Barrierefreiheit).
* **user-event** statt `fireEvent` für realistische Interaktionen.
* Für HTTP: **MSW** zum Mocken statt globaler Fetch-Mocks.
* Kleine, fokussierte Tests; sprechende Queries.

---

### **Zusammenfassung**

* **Komponenten**: mit RTL `render` + DOM-Queries prüfen.
* **Props**: übergeben und UI/Attribute/ARIA validieren.
* **Events**: mit `user-event` Interaktionen auslösen; Callback-Props mit `jest.fn()`/`vi.fn()` verifizieren.
* **Async**: `findBy*` nutzen, auf UI-Ergebnis warten.

**Quellen:**

* React Docs – Testing: [https://react.dev/learn/testing](https://react.dev/learn/testing)
* RTL – Intro & Queries: [https://testing-library.com/docs/react-testing-library/intro](https://testing-library.com/docs/react-testing-library/intro)
* MDN (RU) – События / Формы / Доступность: [https://developer.mozilla.org/ru/](https://developer.mozilla.org/ru/)

  **[⬆ Наверх](#top)**

95. ### <a name="95"></a> Wie testet man benutzerdefinierte Hooks?

### Benutzerdefinierte Hooks testen (Strategien + Beispiele)

#### **Strategie**

* **Indirekt (empfohlen):** Komponente testen, die den Hook nutzt ⇒ realistisch und weniger an Implementierungsdetails gebunden. ([testing-library.com][1])
* **Direkt:** Hook isoliert mit `renderHook` testen (React Testing Library). Nutze `act` für State-Updates und `waitFor`/`findBy*` für Async. ([testing-library.com][1])

---

### **1) Reiner Logik-Hook (synchron) mit `renderHook`**

```js
// useCounter.js
import { useState, useCallback } from "react";

export function useCounter(initial = 0) {
  const [count, setCount] = useState(initial);
  const inc = useCallback(() => setCount(c => c + 1), []);
  const reset = useCallback(() => setCount(initial), [initial]);
  return { count, inc, reset };
}
```

```js
// useCounter.test.js
import { renderHook, act } from "@testing-library/react";
import { useCounter } from "./useCounter.js";

test("incrementiert und resetet korrekt", () => {
  const { result } = renderHook(() => useCounter(5));
  act(() => result.current.inc());
  expect(result.current.count).toBe(6);
  act(() => result.current.reset());
  expect(result.current.count).toBe(5);
});
```

`renderHook` ist Teil der RTL-API; `act` bündelt ausstehende Updates vor Assertions. ([testing-library.com][1])

---

### **2) Datenabholender Hook (asynchron) mit MSW**

```js
// useUser.js
import { useEffect, useState } from "react";

export function useUser(id) {
  const [state, setState] = useState({ data: null, error: null, loading: true });

  useEffect(() => {
    let cancelled = false;
    fetch(`/api/users/${id}`)
      .then(r => r.json())
      .then(data => !cancelled && setState({ data, error: null, loading: false }))
      .catch(err => !cancelled && setState({ data: null, error: err, loading: false }));
    return () => { cancelled = true; };
  }, [id]);

  return state;
}
```

```js
// useUser.test.js  (vereinfachte MSW-Nutzung)
import { renderHook, waitFor } from "@testing-library/react";
import { setupServer } from "msw/node";
import { rest } from "msw";
import { useUser } from "./useUser.js";

const server = setupServer(
  rest.get("/api/users/:id", (req, res, ctx) =>
    res(ctx.json({ id: req.params.id, name: "Sergii" }))
  )
);

beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());

test("liefert Daten und beendet Loading", async () => {
  const { result } = renderHook(() => useUser(1));
  await waitFor(() => expect(result.current.loading).toBe(false));
  expect(result.current.data).toEqual({ id: "1", name: "Sergii" });
  expect(result.current.error).toBeNull();
});
```

MSW mockt HTTP realistisch auf Netzwerkebene; mit RTL wartest du per `waitFor` auf das UI/Ergebnis. ([Chip Cullen][2])

---

### **3) Hook mit Context/Providern: `wrapper` nutzen**

```js
// useAuth.js
import { createContext, useContext } from "react";
const AuthContext = createContext(null);
export function AuthProvider({ children, user }) {
  return <AuthContext.Provider value={user}>{children}</AuthContext.Provider>;
}
export function useAuth() {
  const user = useContext(AuthContext);
  if (!user) throw new Error("No auth");
  return user;
}
```

```jsx
// useAuth.test.jsx
import { renderHook } from "@testing-library/react";
import { AuthProvider, useAuth } from "./useAuth.jsx";

test("liest Nutzer aus Context via wrapper", () => {
  const wrapper = ({ children }) => <AuthProvider user={{ id: 1 }}>{children}</AuthProvider>;
  const { result } = renderHook(() => useAuth(), { wrapper });
  expect(result.current).toEqual({ id: 1 });
});
```

`renderHook` unterstützt einen `wrapper`, um Provider/Router/QueryClient einzubinden. ([testing-library.com][1])

---

### **Best Practices (kurz)**

* Wenn möglich, **indirekt über Komponenten testen**; `renderHook` vor allem für Bibliotheks-Hooks bzw. komplexe Logik. ([testing-library.com][1])
* **Keine Implementierungsdetails mocken**; teste beobachtbares Verhalten. Nutze DOM-Queries/Benutzerfluss in Komponententests. ([testing-library.com][1])
* Für User-Interaktionen **`@testing-library/user-event`** statt `fireEvent`. ([testing-library.com][3])
* Für asynchrone Updates `act`/`waitFor`/`findBy*` verwenden. ([react.dev][4])

---

### **Zusammenfassung**

* **Zwei Wege:** indirekt über Komponenten (bevorzugt) oder direkt mit `renderHook`.
* **Async:** mit MSW HTTP mocken, mit `waitFor`/`findBy*` auf Ergebnisse warten.
* **Context:** `wrapper` im `renderHook` für Provider nutzen.

**Quellen / Weiterlesen:**

* React Testing Library API (`renderHook`, `wrapper`): ([testing-library.com][1])
* React Docs – `act`: ([react.dev][4])
* MDN (RU) – основы/тестирование клиентского JS: ([MDN Web Docs][5])
* Testing Library – `user-event`:

[1]: https://testing-library.com/docs/react-testing-library/api/ "API | Testing Library"
[2]: https://chipcullen.com/mocking-fetch-requests-in-react-testing-library-tests/?utm_source=chatgpt.com "How to mock fetch requests in React Testing Librarty tests"
[3]: https://testing-library.com/docs/user-event/intro/?utm_source=chatgpt.com "Introduction"
[4]: https://react.dev/reference/react/act?utm_source=chatgpt.com "React"
[5]: https://developer.mozilla.org/ru/docs/Web/JavaScript?utm_source=chatgpt.com "JavaScript | MDN - Mozilla"

  **[⬆ Наверх](#top)**

96. ### <a name="96"></a> 



  **[⬆ Наверх](#top)**

97. ### <a name="97"></a> 



  **[⬆ Наверх](#top)**

98. ### <a name="98"></a> 



  **[⬆ Наверх](#top)**

99. ### <a name="99"></a> 



  **[⬆ Наверх](#top)**

100. ### <a name="100"></a> 



  **[⬆ Наверх](#top)**    

101. ### <a name="101"></a> Wie funktioniert Routing in React mit react-router-dom?

### Routing in React mit **react-router-dom**

#### **Grundprinzip**

* Routing in React ist **Client-Side-Routing**: kein vollständiges Reload der Seite, sondern UI-Austausch basierend auf der URL.
* `react-router-dom` stellt Komponenten und Hooks bereit, um Pfade mit React-Komponenten zu verbinden.
* Kernkomponenten:

  * `<BrowserRouter>` – stellt den Router-Context bereit.
  * `<Routes>` – Container für definierte Routen.
  * `<Route>` – verbindet Pfad (`path`) mit UI (`element`).
  * `<Link>` / `<NavLink>` – Navigation ohne Page-Reload.
  * `useNavigate` – Navigation programmatisch.
  * `useParams` – Zugriff auf URL-Parameter.
  * `useLocation` – Zugriff auf aktuelle URL.

---

### **1) Basisrouting**

```jsx
// App.jsx
import { BrowserRouter, Routes, Route, Link } from "react-router-dom";
import { Home } from "./Home.jsx";
import { About } from "./About.jsx";

export default function App() {
  return (
    <BrowserRouter>
      <nav>
        <Link to="/">Start</Link> | <Link to="/about">Über uns</Link>
      </nav>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
      </Routes>
    </BrowserRouter>
  );
}
```

---

### **2) Dynamische Routen + useParams**

```jsx
// User.jsx
import { useParams } from "react-router-dom";

export function User() {
  const { id } = useParams();
  return <h2>User ID: {id}</h2>;
}

// App.jsx
<Route path="/user/:id" element={<User />} />
```

Aufruf `http://localhost:3000/user/42` → zeigt `User ID: 42`.

---

### **3) Programmatische Navigation**

```jsx
// Login.jsx
import { useNavigate } from "react-router-dom";

export function Login() {
  const navigate = useNavigate();
  function handleLogin() {
    // ... Auth-Logik
    navigate("/dashboard");
  }
  return <button onClick={handleLogin}>Einloggen</button>;
}
```

---

### **4) Verschachtelte Routen**

```jsx
// Dashboard.jsx
import { Outlet, Link } from "react-router-dom";

export function Dashboard() {
  return (
    <div>
      <h1>Dashboard</h1>
      <Link to="stats">Statistiken</Link>
      <Outlet /> {/* zeigt verschachtelte Route */}
    </div>
  );
}

// App.jsx
<Routes>
  <Route path="/dashboard" element={<Dashboard />}>
    <Route path="stats" element={<h2>Stats-Seite</h2>} />
  </Route>
</Routes>
```

---

### **5) Fehlerseite / Catch-All**

```jsx
<Route path="*" element={<h2>Seite nicht gefunden</h2>} />
```

---

### **Zusammenfassung**

* `react-router-dom` implementiert **Client-Side-Routing**.
* Wichtigste Bausteine: `<BrowserRouter>`, `<Routes>`, `<Route>`.
* **Navigation:** `<Link>`/`useNavigate`.
* **Dynamische Daten:** `useParams`, `useLocation`.
* **Strukturierung:** verschachtelte Routen mit `<Outlet>`.

📖 Quellen:

* [React Router – Doku](https://reactrouter.com/en/main)
* [React Docs: Adding React Router](https://react.dev/learn/adding-react-router)

---

  **[⬆ Наверх](#top)**

102. ### <a name="102"></a> Was sind die Unterschiede zwischen react-router v5 und v6?

### Unterschiede zwischen **react-router v5** und **v6**

#### 1) **`<Switch>` → `<Routes>`** (Best-Match statt Reihenfolge)

* v5: `<Switch>` rendert die **erste** passende Route.
* v6: `<Routes>` wählt anhand **bester Übereinstimmung**; verschachtelte/relative Routen sind der Standard. ([React Router][1])

```jsx
// v5
import { BrowserRouter, Switch, Route } from "react-router-dom";
<BrowserRouter>
  <Switch>
    <Route exact path="/" component={Home} />
    <Route path="/users/:id" component={User} />
  </Switch>
</BrowserRouter>

// v6
import { BrowserRouter, Routes, Route } from "react-router-dom";
<BrowserRouter>
  <Routes>
    <Route path="/" element={<Home />} />
    <Route path="/users/:id" element={<User />} />
  </Routes>
</BrowserRouter>
```

#### 2) **`element` statt `component`/`render`**

* v5: `<Route component={Home} />` oder `render`.
* v6: `<Route element={<Home/>} />` – klarere Props und bessere Typisierung. ([React Router][1])

#### 3) **Navigation: `useNavigate` statt `useHistory`**

* v5: `useHistory().push|replace|go`.
* v6: `useNavigate()`; `navigate("/x", { replace: true, state })`. ([React Router][1])

```jsx
// v5
import { useHistory } from "react-router-dom";
const history = useHistory();
history.replace("/dashboard");

// v6
import { useNavigate } from "react-router-dom";
const navigate = useNavigate();
navigate("/dashboard", { replace: true });
```

#### 4) **Redirect: `<Redirect>` → `<Navigate>`**

* v5: `<Redirect to="/login" />` (oft in `<Switch>`).
* v6: `<Navigate to="/login" replace />`. ([React Router][1])

```jsx
// v6
import { Navigate } from "react-router-dom";
<Route path="/" element={<Navigate to="/login" replace />} />
```

#### 5) **`exact` entfällt**

* v5: häufig `exact` nötig.
* v6: **exaktes Matching standardmäßig**, `NavLink exact` wurde zu `end`. ([React Router][1])

#### 6) **Relative & verschachtelte Routen + `<Outlet>`**

* v6: Routen/Links sind **relativ**; echte **Nesting-Struktur** an einer Stelle definierbar. ([React Router][1])

```jsx
import { Route } from "react-router-dom";
<Route path="/dashboard" element={<Dashboard />}>
  <Route path="stats" element={<Stats />} />
</Route>
```

#### 7) **Hooks & API-Änderungen**

* `useRouteMatch` → `useMatch`, `activeClassName/activeStyle` in `NavLink` entfernt; State an `<Link>` separat per `state` übergeben. ([React Router][1])

#### 8) **Data APIs (ab v6.4+)** – optionaler neuer Modus

* **Loader/Action**-basierter Datenfluss (`createBrowserRouter`, `RouterProvider`), deklaratives Laden/Mutieren mit Revalidierung. (Neu in v6, existiert nicht in v5.) ([React Router][2])

```jsx
// v6.4+ Data Router
import { createBrowserRouter, RouterProvider } from "react-router-dom";
const router = createBrowserRouter([{ path: "/", element: <Home/>, loader: loadHome }]);
<RouterProvider router={router} />;
```

---

### Zusammenfassung

* **Routes/element** ersetzen **Switch/component/render**; Matching ist **exakt per Default**.
* **useNavigate/Navigate** statt **useHistory/Redirect**.
* **Relative & verschachtelte Routen** mit `<Outlet>`; mehrere API-Bereinigungen.
* **Data Router (v6.4+)** bringt Loader/Actions für deklaratives Datenladen/-schreiben.

**Quellen:**

* React Router – *Upgrading from v5*: ([React Router][1])
* React Router – *Modes/Data (Loader/Action)*: ([React Router][2])
* React Router – *Data Loading* (Loader): ([React Router][3])
* React Docs – *Adding React Router*: ([React Router][4])

[1]: https://reactrouter.com/6.30.1/upgrading/v5 "Upgrading from v5 v6.30.1 | React Router"
[2]: https://reactrouter.com/start/modes?utm_source=chatgpt.com "Picking a Mode"
[3]: https://reactrouter.com/start/framework/data-loading?utm_source=chatgpt.com "Data Loading"
[4]: https://reactrouter.com/?utm_source=chatgpt.com "React Router Official Documentation"

  **[⬆ Наверх](#top)**

103. ### <a name="103"></a> Was sind Route, Link, Navigate, Outlet?

### **Route, Link, Navigate, Outlet in react-router-dom**

#### **1) `<Route>`**

* Verbindet **URL-Pfad** mit einem React-Element.
* Wird innerhalb von `<Routes>` verwendet.
* Unterstützt statische und dynamische Pfade (`/user/:id`).

```jsx
import { Routes, Route } from "react-router-dom";
<Routes>
  <Route path="/" element={<Home />} />
  <Route path="/user/:id" element={<User />} />
</Routes>
```

---

#### **2) `<Link>`**

* Erzeugt eine **Navigation ohne Page-Reload** (Client-Side Navigation).
* Ersetzt `<a href="...">`, um Single Page Application Verhalten zu erhalten.

```jsx
import { Link } from "react-router-dom";
<nav>
  <Link to="/">Startseite</Link>
  <Link to="/about">Über uns</Link>
</nav>
```

---

#### **3) `<Navigate>`**

* Dient zum **Weiterleiten/Redirecten**.
* Typisch für Login-Weiterleitungen oder geschützte Routen.

```jsx
import { Navigate } from "react-router-dom";
function ProtectedRoute({ user }) {
  if (!user) return <Navigate to="/login" replace />;
  return <Dashboard />;
}
```

---

#### **4) `<Outlet>`**

* Platzhalter für **verschachtelte Routen**.
* Zeigt die **Child-Komponente** einer Route an.

```jsx
import { Routes, Route, Outlet, Link } from "react-router-dom";

function Dashboard() {
  return (
    <div>
      <h1>Dashboard</h1>
      <Link to="stats">Stats</Link>
      <Outlet /> {/* Child-Route wird hier angezeigt */}
    </div>
  );
}

<Routes>
  <Route path="/dashboard" element={<Dashboard />}>
    <Route path="stats" element={<h2>Statistiken</h2>} />
  </Route>
</Routes>
```

---

### **Zusammenfassung**

* **Route**: definiert, welche Komponente bei einem Pfad angezeigt wird.
* **Link**: ermöglicht Navigation ohne Seitenreload.
* **Navigate**: leitet programmatisch/automatisch weiter.
* **Outlet**: zeigt Inhalte von verschachtelten Routen an.

📖 Quellen:

* [React Router – Route](https://reactrouter.com/en/main/components/route)
* [React Router – Link](https://reactrouter.com/en/main/components/link)
* [React Router – Navigate](https://reactrouter.com/en/main/components/navigate)
* [React Router – Outlet](https://reactrouter.com/en/main/components/outlet)

---
  **[⬆ Наверх](#top)**

104. ### <a name="104"></a> Wie erstellt man Nested Routes?

### Nested Routes in **react-router-dom v6**

#### **Grundidee**

* Verschachtelte Routen = Hierarchie von Routen (Eltern ↔ Kind).
* Eltern-Route definiert **Layout** oder Container.
* Kind-Routen werden mit `<Outlet>` an der Stelle gerendert, wo der Eltern-Content Platz lässt.

---

### **1) Basisstruktur**

```jsx
// App.jsx
import { BrowserRouter, Routes, Route, Link, Outlet } from "react-router-dom";

function Layout() {
  return (
    <div>
      <h1>Dashboard</h1>
      <nav>
        <Link to="overview">Übersicht</Link> |{" "}
        <Link to="settings">Einstellungen</Link>
      </nav>
      <Outlet /> {/* Kind-Route wird hier angezeigt */}
    </div>
  );
}

function Overview() {
  return <h2>Übersichtsseite</h2>;
}

function Settings() {
  return <h2>Einstellungen</h2>;
}

export default function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/dashboard" element={<Layout />}>
          <Route path="overview" element={<Overview />} />
          <Route path="settings" element={<Settings />} />
        </Route>
      </Routes>
    </BrowserRouter>
  );
}
```

👉 Aufruf:

* `/dashboard/overview` → rendert `<Layout>` + `<Overview>`
* `/dashboard/settings` → rendert `<Layout>` + `<Settings>`

---

### **2) Index-Routen**

* Default-Child, wenn kein weiterer Pfad angegeben ist.

```jsx
<Route path="/dashboard" element={<Layout />}>
  <Route index element={<h2>Willkommen im Dashboard</h2>} />
  <Route path="overview" element={<Overview />} />
</Route>
```

👉 `/dashboard` zeigt den Index-Content an.

---

### **3) Mehrstufiges Nesting**

* Kinder können selbst wieder Eltern sein → beliebige Tiefe möglich.

```jsx
<Route path="/dashboard" element={<Layout />}>
  <Route path="settings" element={<Settings />}>
    <Route path="profile" element={<h3>Profil-Einstellungen</h3>} />
    <Route path="security" element={<h3>Sicherheits-Einstellungen</h3>} />
  </Route>
</Route>
```

👉 `/dashboard/settings/profile`

---

### **Zusammenfassung**

* **`<Route>` in Route verschachteln.**
* **`<Outlet>`** = Platzhalter im Parent.
* **Index-Route** = Default-Child.
* Mehrstufig möglich durch erneutes Nesting.

📖 Quellen:

* [React Router – Nested Routes](https://reactrouter.com/en/main/start/tutorial#nested-routes)
* [React Docs: Routing mit Outlet](https://react.dev/learn/adding-react-router#nested-routes)

---

  **[⬆ Наверх](#top)**

105. ### <a name="105"></a> Wie implementiert man Redirects?

### Redirects in **react-router-dom v6**

#### **1) Mit `<Navigate>`**

* Wird als **Element** in einer Route oder direkt im JSX gerendert.
* Ersetzt `<Redirect>` aus v5.
* Props: `to` (Ziel), `replace` (verhindert neuen History-Eintrag), `state` (extra Daten).

```jsx
import { Routes, Route, Navigate } from "react-router-dom";

function App() {
  return (
    <Routes>
      <Route path="/" element={<Home />} />
      <Route path="/old" element={<Navigate to="/new" replace />} />
      <Route path="/new" element={<NewPage />} />
    </Routes>
  );
}
```

👉 Aufruf `/old` → Redirect nach `/new`.

---

#### **2) Innerhalb von Komponenten**

* Nützlich bei **Auth-Checks** oder **Bedingungen**.

```jsx
import { Navigate } from "react-router-dom";

function ProtectedRoute({ user }) {
  if (!user) {
    return <Navigate to="/login" replace state={{ from: "/dashboard" }} />;
  }
  return <Dashboard />;
}
```

---

#### **3) Programmatisch mit `useNavigate`**

* Ideal für Weiterleitungen nach einem Event (z. B. Login).

```jsx
import { useNavigate } from "react-router-dom";

function Login() {
  const navigate = useNavigate();

  function handleLogin() {
    // ... Auth-Logik
    navigate("/dashboard", { replace: true });
  }

  return <button onClick={handleLogin}>Einloggen</button>;
}
```

---

### **Zusammenfassung**

* **`<Navigate>`**: deklarative Redirects in Routen/JSX.
* **`useNavigate`**: programmatische Redirects in Events/Logik.
* **`replace`**: verhindert zusätzliche History-Einträge.

📖 Quellen:

* [React Router – Navigate](https://reactrouter.com/en/main/components/navigate)
* [React Router – useNavigate](https://reactrouter.com/en/main/hooks/use-navigate)

---

  **[⬆ Наверх](#top)**

106. ### <a name="106"></a> Wie funktioniert programmgesteuerte Navigation (useNavigate)?

### Programmgesteuerte Navigation mit **`useNavigate`**

#### **Grundidee**

* `useNavigate` ist ein Hook aus **react-router-dom v6**.
* Er ersetzt `useHistory` aus v5.
* Liefert eine Funktion `navigate`, mit der man **per Code** zu einer Route wechseln kann.
* Typische Anwendungsfälle: **Login-Weiterleitung, Logout, Form-Submit, Guarded Routes**.

---

### **1) Basisbeispiel**

```jsx
import { useNavigate } from "react-router-dom";

export function Login() {
  const navigate = useNavigate();

  function handleLogin() {
    // … Authentifizierung erfolgreich
    navigate("/dashboard"); // zur Dashboard-Seite wechseln
  }

  return <button onClick={handleLogin}>Login</button>;
}
```

---

### **2) Mit Optionen (`replace`, `state`)**

```jsx
function Logout() {
  const navigate = useNavigate();

  function handleLogout() {
    // Session löschen
    navigate("/login", { replace: true, state: { message: "Bitte erneut einloggen" } });
  }

  return <button onClick={handleLogout}>Logout</button>;
}
```

* `replace: true` → ersetzt aktuellen History-Eintrag (kein "Zurück"-Button möglich).
* `state` → Daten an nächste Route übergeben (`useLocation()` abrufbar).

---

### **3) Relative Navigation**

```jsx
function UserMenu() {
  const navigate = useNavigate();

  return (
    <button onClick={() => navigate("settings")}>
      Zu den Einstellungen
    </button>
  );
}
```

👉 Wenn UserMenu unter `/dashboard` eingebettet ist → Navigiert zu `/dashboard/settings`.

---

### **4) Zurück / Vorwärts**

```jsx
function BackButton() {
  const navigate = useNavigate();
  return <button onClick={() => navigate(-1)}>Zurück</button>; // -1 = history.back()
}
```

---

### **Zusammenfassung**

* `useNavigate()` gibt eine Funktion zurück, die Navigation **per Code** ermöglicht.
* **Syntax:** `navigate(path, { replace, state })`.
* Unterstützt **absolute/relative Pfade** und **numerische Werte** für History.
* Nützlich für Auth-Redirects, After-Submit, Guards.

📖 Quellen:

* [React Router – useNavigate](https://reactrouter.com/en/main/hooks/use-navigate)
* [React Docs: Routing](https://react.dev/learn/adding-react-router)

---

  **[⬆ Наверх](#top)**

107. ### <a name="107"></a> 



  **[⬆ Наверх](#top)**

108. ### <a name="108"></a> 



  **[⬆ Наверх](#top)**

109. ### <a name="109"></a> 



  **[⬆ Наверх](#top)**

110. ### <a name="110"></a> 



  **[⬆ Наверх](#top)**

111. ### <a name="111"></a> Was ist Redux und wie funktioniert es?

### Redux – Was es ist und wie es funktioniert

#### **Definition**

* **Redux** ist eine **State-Management-Bibliothek** für JavaScript-Apps, oft mit React genutzt.
* Grundidee: Es gibt **eine zentrale State-Quelle (Store)**, auf die alle Komponenten zugreifen können.
* Änderungen passieren nur über **Actions** und **Reducer** ⇒ Vorhersagbarkeit & Nachvollziehbarkeit.

---

#### **Kernprinzipien**

1. **Single Source of Truth**

   * Gesamter globaler State liegt in einem einzigen **Store**.

2. **State ist read-only**

   * State wird nicht direkt verändert, sondern über **Actions** beschrieben.

3. **Änderungen durch pure Reducer**

   * Reducer sind **pure functions**, die alten State + Action → neuen State berechnen.

---

#### **Ablauf**

1. Komponente löst eine **Action** aus (z. B. `{ type: "INCREMENT" }`).
2. Diese Action geht an den **Reducer**.
3. Der Reducer berechnet den **neuen State** und speichert ihn im Store.
4. Komponenten, die mit dem Store verbunden sind, werden automatisch **neu gerendert**.

---

#### **Codebeispiel**

```js
// store.js
import { createStore } from "redux";

// Reducer (pure function)
function counterReducer(state = { value: 0 }, action) {
  switch (action.type) {
    case "INCREMENT":
      return { value: state.value + 1 };
    case "DECREMENT":
      return { value: state.value - 1 };
    default:
      return state;
  }
}

// Store erstellen
export const store = createStore(counterReducer);
```

```jsx
// Counter.jsx
import { useSelector, useDispatch } from "react-redux";
import { Provider } from "react-redux";
import { store } from "./store.js";

function Counter() {
  const count = useSelector(state => state.value);
  const dispatch = useDispatch();

  return (
    <div>
      <p>Zähler: {count}</p>
      <button onClick={() => dispatch({ type: "INCREMENT" })}>+1</button>
      <button onClick={() => dispatch({ type: "DECREMENT" })}>-1</button>
    </div>
  );
}

// App.jsx
export default function App() {
  return (
    <Provider store={store}>
      <Counter />
    </Provider>
  );
}
```

---

#### **Zusammenfassung**

* Redux = zentrales **State-Management** mit klarem Datenfluss.
* Drei Prinzipien: **ein Store**, **State nur über Actions veränderbar**, **Reducer als pure functions**.
* Vorteile: **Vorhersagbarkeit, Debugging, Skalierbarkeit**.

📖 Quellen:

* [Redux Docs – Einführung](https://redux.js.org/introduction/getting-started)
* [React Redux](https://react-redux.js.org/)
* [MDN – State Management](https://developer.mozilla.org/ru/docs/Glossary/State_management)

---

  **[⬆ Наверх](#top)**

112. ### <a name="112"></a> Was sind Actions, Reducer und Store?

### Actions, Reducer und Store in **Redux**

#### **1) Actions**

* **Plain JavaScript Objects**, die beschreiben, **was passieren soll**.
* Müssen ein `type`-Feld haben (string, eindeutig).
* Können zusätzliche Daten enthalten (`payload`).

```js
// Beispiel-Action
{ type: "INCREMENT" }
{ type: "ADD_TODO", payload: { id: 1, text: "React lernen" } }
```

---

#### **2) Reducer**

* **Pure Function**: `(state, action) → newState`.
* Entscheidet anhand des `action.type`, wie der **neue State** aussieht.
* Darf State nicht direkt mutieren, sondern muss **immutabel** arbeiten.

```js
// reducer.js
function counterReducer(state = { value: 0 }, action) {
  switch (action.type) {
    case "INCREMENT":
      return { value: state.value + 1 };
    case "DECREMENT":
      return { value: state.value - 1 };
    default:
      return state;
  }
}
```

---

#### **3) Store**

* Der **zentrale Container** für den State.
* Enthält Methoden:

  * `getState()` – aktuellen State lesen
  * `dispatch(action)` – Action an Reducer senden
  * `subscribe(listener)` – auf Änderungen reagieren

```js
import { createStore } from "redux";
import counterReducer from "./reducer.js";

// Store erstellen
const store = createStore(counterReducer);

// State auslesen
console.log(store.getState()); // { value: 0 }

// Action dispatchen
store.dispatch({ type: "INCREMENT" });
console.log(store.getState()); // { value: 1 }
```

---

### **Zusammenfassung**

* **Actions**: Beschreiben *was* passiert (Objekte).
* **Reducer**: Reine Funktionen, berechnen den *neuen State* basierend auf Actions.
* **Store**: Hält den State, verwaltet den Datenfluss (`getState`, `dispatch`, `subscribe`).

📖 Quellen:

* [Redux Docs – Core Concepts](https://redux.js.org/introduction/core-concepts)
* [React Redux Docs](https://react-redux.js.org/introduction/quick-start)

---

  **[⬆ Наверх](#top)**

113. ### <a name="113"></a> Wie funktioniert Redux Toolkit (createSlice, configureStore, createAsyncThunk)?

### Redux Toolkit (RTK) – moderne Art, Redux zu nutzen

Redux Toolkit ist die **offizielle, empfohlene Methode**, Redux-Code zu schreiben.
Es reduziert Boilerplate und vereinfacht die Arbeit mit Actions, Reducern und Async-Logik.

---

## **1) `createSlice`**

* Bündelt **State**, **Reducer** und automatisch generierte **Actions** in einem "Slice".
* Spart das manuelle Erstellen von Action-Objekten und Action-Creators.

```js
// counterSlice.js
import { createSlice } from "@reduxjs/toolkit";

const counterSlice = createSlice({
  name: "counter",
  initialState: { value: 0 },
  reducers: {
    increment: (state) => { state.value += 1 },   // erlaubt direkte Mutation (immer noch immutable dank Immer)
    decrement: (state) => { state.value -= 1 },
    addBy: (state, action) => { state.value += action.payload }
  }
});

export const { increment, decrement, addBy } = counterSlice.actions;
export default counterSlice.reducer;
```

👉 Generiert automatisch:

* Reducer-Funktion (`counterSlice.reducer`)
* Action Creators (`increment()`, `decrement()`, `addBy(5)`)

---

## **2) `configureStore`**

* Erstellt den zentralen Store.
* Integriert automatisch **Redux DevTools** und Middleware (z. B. Thunk).

```js
// store.js
import { configureStore } from "@reduxjs/toolkit";
import counterReducer from "./counterSlice.js";

export const store = configureStore({
  reducer: {
    counter: counterReducer
  }
});
```

---

## **3) `createAsyncThunk`**

* Für **asynchrone Logik** (z. B. API-Aufrufe).
* Generiert automatisch Pending/ Fulfilled/ Rejected-Actions.

```js
// usersSlice.js
import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";

// Async-Action
export const fetchUsers = createAsyncThunk("users/fetchUsers", async () => {
  const res = await fetch("https://jsonplaceholder.typicode.com/users");
  return res.json();
});

const usersSlice = createSlice({
  name: "users",
  initialState: { list: [], status: "idle", error: null },
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchUsers.pending, (state) => {
        state.status = "loading";
      })
      .addCase(fetchUsers.fulfilled, (state, action) => {
        state.status = "succeeded";
        state.list = action.payload;
      })
      .addCase(fetchUsers.rejected, (state, action) => {
        state.status = "failed";
        state.error = action.error.message;
      });
  }
});

export default usersSlice.reducer;
```

---

## **4) Nutzung in Komponenten**

```jsx
// Counter.jsx
import { useSelector, useDispatch } from "react-redux";
import { increment, addBy } from "./counterSlice.js";
import { fetchUsers } from "./usersSlice.js";

export function Counter() {
  const count = useSelector((state) => state.counter.value);
  const dispatch = useDispatch();

  return (
    <div>
      <p>Zähler: {count}</p>
      <button onClick={() => dispatch(increment())}>+1</button>
      <button onClick={() => dispatch(addBy(5))}>+5</button>
      <button onClick={() => dispatch(fetchUsers())}>Load Users</button>
    </div>
  );
}
```

---

### **Zusammenfassung**

* **`createSlice`**: Definiert State + Reducer + Actions in einer kompakten Form.
* **`configureStore`**: Vereinfacht Store-Setup mit DevTools + Middleware.
* **`createAsyncThunk`**: Standardweg für asynchrone Logik, generiert automatisch Pending/Fulfilled/Rejected-Actions.
* RTK macht Redux-Code **kürzer, lesbarer und weniger fehleranfällig**.

📖 Quellen:

* [Redux Toolkit – Getting Started](https://redux-toolkit.js.org/introduction/getting-started)
* [Redux Toolkit – createSlice](https://redux-toolkit.js.org/api/createSlice)
* [Redux Toolkit – createAsyncThunk](https://redux-toolkit.js.org/api/createAsyncThunk)

---

  **[⬆ Наверх](#top)**

114. ### <a name="114"></a> Was ist RTK Query?

### RTK Query – was es ist und wie es funktioniert

#### **Definition**

* **RTK Query** ist ein offizielles Zusatzmodul von **Redux Toolkit**.
* Es bietet ein **integriertes Data-Fetching und Caching-System** für API-Anfragen.
* Ziel: Weniger Boilerplate bei Server-Requests und State-Handling (Loading, Error, Cache).

---

#### **Kernfeatures**

* Automatisches **Caching & Refetching** von Daten.
* Generiert automatisch **Hooks** für Queries (GET) und Mutations (POST/PUT/DELETE).
* Integriert sich nahtlos in Redux Toolkit (`configureStore`).
* Spart den Einsatz von zusätzlichen Libraries wie Axios + Redux Thunk + eigene Loading/Error-States.

---

#### **1) API-Slice erstellen**

```js
// services/api.js
import { createApi, fetchBaseQuery } from "@reduxjs/toolkit/query/react";

export const api = createApi({
  reducerPath: "api", // wird automatisch im Store registriert
  baseQuery: fetchBaseQuery({ baseUrl: "https://jsonplaceholder.typicode.com" }),
  endpoints: (builder) => ({
    getUsers: builder.query({
      query: () => "/users"
    }),
    addUser: builder.mutation({
      query: (newUser) => ({
        url: "/users",
        method: "POST",
        body: newUser
      })
    })
  })
});

export const { useGetUsersQuery, useAddUserMutation } = api;
```

---

#### **2) Store einrichten**

```js
// store.js
import { configureStore } from "@reduxjs/toolkit";
import { api } from "./services/api.js";

export const store = configureStore({
  reducer: {
    [api.reducerPath]: api.reducer
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(api.middleware)
});
```

---

#### **3) Nutzung in Komponenten**

```jsx
// Users.jsx
import { useGetUsersQuery, useAddUserMutation } from "./services/api.js";

export function Users() {
  const { data, error, isLoading } = useGetUsersQuery();
  const [addUser] = useAddUserMutation();

  if (isLoading) return <p>Lädt...</p>;
  if (error) return <p>Fehler: {error.message}</p>;

  return (
    <div>
      <ul>
        {data.map((user) => (
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>
      <button onClick={() => addUser({ name: "Sergii" })}>Neuer User</button>
    </div>
  );
}
```

---

### **Zusammenfassung**

* **RTK Query** = Data-Fetching- und Cache-Lösung für Redux Toolkit.
* Stellt automatisch **Hooks** (`useGetXQuery`, `useAddXMutation`) bereit.
* Handhabt **Loading, Error, Refetch, Cache** automatisch.
* Vereinfacht API-Integration erheblich.

📖 Quellen:

* [Redux Toolkit – RTK Query Overview](https://redux-toolkit.js.org/rtk-query/overview)
* [Redux Toolkit – API Reference](https://redux-toolkit.js.org/rtk-query/api/createApi)

---

  **[⬆ Наверх](#top)**

115. ### <a name="115"></a> Was ist der Unterschied zwischen Redux und der Context-API?

### Unterschied zwischen **Redux** und **React Context API**

#### **1) Zweck**

* **Context API**:

  * React-eigene Lösung, um **Props-Drilling** zu vermeiden.
  * Gut für **einfaches, globales Teilen von Daten** (z. B. Theme, Auth-Status, Sprache).

* **Redux**:

  * Vollwertige **State-Management-Bibliothek**.
  * Geeignet für **komplexe, veränderliche globale States** mit klarer Struktur (Actions, Reducer, Middleware).

---

#### **2) Datenfluss & Architektur**

* **Context API**:

  * Basiert auf **Provider/Consumer**-Pattern.
  * Kein eingebautes Konzept von Actions oder Reducern – reine Werteweitergabe.

* **Redux**:

  * Strenger **unidirektionaler Datenfluss**: Action → Reducer → Store → UI.
  * Ermöglicht **Zeitreisen (DevTools), Middleware (z. B. Logging, Async)**.

---

#### **3) Skalierung**

* **Context API**:

  * Einfach, aber bei **häufigen State-Änderungen** oder **großen Apps** kann es Performance-Probleme geben (Re-Renders aller Consumer).
  * Keine integrierte Debugging- oder DevTools-Unterstützung.

* **Redux**:

  * Entwickelt für **größere Anwendungen** mit vielen State-Änderungen.
  * Performance-optimiert, integrierte **Redux DevTools**, bessere Testbarkeit.

---

#### **4) Beispiel**

**Context API** (Theme):

```jsx
const ThemeContext = React.createContext("light");

function App() {
  return (
    <ThemeContext.Provider value="dark">
      <Toolbar />
    </ThemeContext.Provider>
  );
}
```

**Redux** (Counter):

```js
// reducer.js
function counterReducer(state = { value: 0 }, action) {
  switch (action.type) {
    case "INCREMENT": return { value: state.value + 1 };
    default: return state;
  }
}
```

---

### **Zusammenfassung**

* **Context API**: Einfach, ideal für **statische oder selten wechselnde Daten**.
* **Redux**: Komplexer, ideal für **große Apps mit viel dynamischem State, Middleware, Debugging**.
* Man kann beide auch **kombinieren** (z. B. Redux im Store, Context für UI-Settings).

📖 Quellen:

* [React Docs – Context](https://react.dev/reference/react/Context)
* [Redux Docs – Core Concepts](https://redux.js.org/introduction/core-concepts)

---

  **[⬆ Наверх](#top)**

116. ### <a name="116"></a> Was ist connect() in Redux?

### `connect()` in Redux

#### **Definition**

* `connect()` ist eine **Higher-Order-Component (HOC)** aus der Bibliothek **react-redux** (klassisches API).
* Sie verbindet eine React-Komponente mit dem **Redux-Store**, sodass die Komponente State lesen und Actions dispatchen kann.
* Heute wird es oft durch die Hooks **`useSelector`** und **`useDispatch`** ersetzt, bleibt aber in Legacy-Code weit verbreitet.

---

#### **Syntax**

```js
connect(mapStateToProps, mapDispatchToProps)(Component)
```

* **`mapStateToProps(state)`** → bestimmt, welche Teile des Redux-States als Props in die Komponente gehen.
* **`mapDispatchToProps(dispatch)`** → bestimmt, welche Actions als Props verfügbar sind.

---

#### **Beispiel**

```jsx
// Counter.jsx
import React from "react";
import { connect } from "react-redux";

function Counter({ count, increment }) {
  return (
    <div>
      <p>Zähler: {count}</p>
      <button onClick={increment}>+1</button>
    </div>
  );
}

// State → Props
const mapStateToProps = (state) => ({
  count: state.value
});

// Dispatch → Props
const mapDispatchToProps = (dispatch) => ({
  increment: () => dispatch({ type: "INCREMENT" })
});

// Komponente mit Store verbinden
export default connect(mapStateToProps, mapDispatchToProps)(Counter);
```

👉 Ergebnis:

* `count` und `increment` werden als Props an `Counter` übergeben.
* Beim Klick wird `dispatch({ type: "INCREMENT" })` ausgeführt.

---

#### **Zusammenfassung**

* `connect()` = HOC, das React-Komponenten mit Redux verbindet.
* Nutzt `mapStateToProps` und `mapDispatchToProps`, um State und Actions als Props bereitzustellen.
* Heute meist durch **Hooks (`useSelector`, `useDispatch`)** ersetzt, aber in älterem Code noch sehr wichtig.

📖 Quellen:

* [React Redux – connect()](https://react-redux.js.org/api/connect)
* [Redux Docs – React Integration](https://redux.js.org/introduction/using-react-redux)

---

  **[⬆ Наверх](#top)**

117. ### <a name="117"></a> Was sind Middleware in Redux (z. B. redux-thunk, redux-logger)?

### Middleware in Redux

#### **Definition**

* **Middleware** sind **Funktionen**, die zwischen `dispatch(action)` und dem Moment laufen, in dem die Action den **Reducer** erreicht.
* Sie ermöglichen es, den **Datenfluss in Redux zu erweitern oder zu verändern**.
* Typische Anwendungsfälle: **Asynchronität, Logging, API-Calls, Fehlerbehandlung**.

---

#### **Funktionsweise**

Middleware ist eine Funktion mit der Signatur:

```js
const middleware = store => next => action => {
  // Vor der Weitergabe: z. B. loggen, async-Logik, abfangen
  console.log("Action:", action);

  // Action weiterreichen
  return next(action);
};
```

* **`store`**: Zugriff auf `dispatch` und `getState`.
* **`next`**: leitet die Action an die nächste Middleware oder den Reducer weiter.
* **`action`**: die aktuelle Action.

---

#### **Beispiele**

**1) redux-thunk (Async-Logik)**

* Erlaubt es, **Funktionen** statt reiner Objekte zu dispatchen.
* Ideal für API-Calls oder komplexe Logik.

```js
// Thunk-Action Creator
export const fetchUsers = () => async (dispatch) => {
  dispatch({ type: "users/loading" });
  try {
    const res = await fetch("/api/users");
    const data = await res.json();
    dispatch({ type: "users/success", payload: data });
  } catch (err) {
    dispatch({ type: "users/error", payload: err.message });
  }
};
```

👉 Ohne Thunk wären nur **synchron Actions** möglich.

---

**2) redux-logger (Logging)**

* Middleware, die automatisch **Actions und State-Änderungen** in der Konsole loggt.

```js
import { createStore, applyMiddleware } from "redux";
import logger from "redux-logger";
import thunk from "redux-thunk";

const store = createStore(rootReducer, applyMiddleware(thunk, logger));
```

👉 Praktisch beim Debuggen, zeigt alte State → Action → neuer State.

---

#### **Zusammenfassung**

* **Middleware = Erweiterung des Dispatch-Prozesses.**
* Standard-Usecases: **Async (`redux-thunk`)**, **Logging (`redux-logger`)**, **Fehler-Handling**, **Analytics**.
* Mit Redux Toolkit (`configureStore`) lassen sich Middleware einfach hinzufügen.

📖 Quellen:

* [Redux Docs – Middleware](https://redux.js.org/understanding/history-and-design/middleware)
* [Redux Thunk](https://github.com/reduxjs/redux-thunk)
* [Redux Logger](https://github.com/LogRocket/redux-logger)

---

  **[⬆ Наверх](#top)**

118. ### <a name="118"></a> Was ist createSelector und wie funktioniert Reselect?

### **Reselect & createSelector in Redux**

#### **Problemstellung**

* In Redux braucht man oft **abgeleitete Daten** aus dem Store (z. B. Filter, Berechnungen).
* Ohne Optimierung wird bei jedem `mapStateToProps` oder `useSelector` **alles neu berechnet**, auch wenn sich relevante Teile nicht geändert haben → unnötige Re-Renders.

---

#### **Reselect**

* **Reselect** ist eine Bibliothek für **Memoization von Selektoren**.
* Ein *Selector* ist eine Funktion, die Daten aus dem Redux-Store auswählt.
* Vorteil: Selektoren werden **nur neu berechnet**, wenn sich die relevanten Input-Werte ändern.

---

#### **`createSelector`**

* Zentrale Funktion von Reselect.
* Syntax:

```js
createSelector(inputSelectors..., resultFunc)
```

* **inputSelectors**: Funktionen, die Teilbereiche des States zurückgeben.
* **resultFunc**: wird nur ausgeführt, wenn sich einer der Input-Werte ändert.

---

#### **Beispiel**

```js
// state.todos = [{id:1, text:"React lernen", completed:false}, ...]

// 1. Input-Selectoren
const selectTodos = (state) => state.todos;
const selectFilter = (state) => state.filter;

// 2. Memoized Selector mit Reselect
import { createSelector } from "reselect";

export const selectVisibleTodos = createSelector(
  [selectTodos, selectFilter],
  (todos, filter) => {
    console.log("Selector neu berechnet!");
    switch (filter) {
      case "completed":
        return todos.filter((t) => t.completed);
      case "active":
        return todos.filter((t) => !t.completed);
      default:
        return todos;
    }
  }
);
```

👉 `selectVisibleTodos(state)` berechnet nur dann neu, wenn sich `state.todos` oder `state.filter` ändern.
👉 Verhindert Performance-Probleme bei großen States.

---

#### **Nutzung in Komponenten**

```jsx
import { useSelector } from "react-redux";
import { selectVisibleTodos } from "./selectors.js";

function TodoList() {
  const todos = useSelector(selectVisibleTodos);
  return (
    <ul>
      {todos.map((t) => (
        <li key={t.id}>{t.text}</li>
      ))}
    </ul>
  );
}
```

---

### **Zusammenfassung**

* **Reselect**: Library für **Memoization von Selektoren**.
* **`createSelector`**: erstellt Selektoren, die nur bei relevanten State-Änderungen neu berechnen.
* Vorteil: **Performance** und **Vermeidung unnötiger Re-Renders**.

📖 Quellen:

* [Reselect Docs](https://github.com/reduxjs/reselect)
* [Redux Docs – Reselect](https://redux.js.org/usage/deriving-data-selectors#creating-memoized-selectors-with-reselect)

---

  **[⬆ Наверх](#top)**

119. ### <a name="119"></a> Wie verbindet man Redux mit React über Hooks (useSelector, useDispatch)?

### React + Redux via Hooks: **`useSelector`** und **`useDispatch`**

#### **1) Store bereitstellen (`<Provider>`)**

```jsx
// main.jsx
import React from "react";
import { createRoot } from "react-dom/client";
import { Provider } from "react-redux";
import { store } from "./store.js";
import App from "./App.jsx";

createRoot(document.getElementById("root")).render(
  <Provider store={store}>
    <App />
  </Provider>
);
```

```js
// store.js (RTK empfohlen)
import { configureStore, createSlice } from "@reduxjs/toolkit";

const counterSlice = createSlice({
  name: "counter",
  initialState: { value: 0 },
  reducers: {
    increment: (state) => { state.value += 1; },
    addBy: (state, action) => { state.value += action.payload; }
  }
});

export const { increment, addBy } = counterSlice.actions;

export const store = configureStore({
  reducer: { counter: counterSlice.reducer }
});
```

---

#### **2) Globalen State lesen: `useSelector`**

* Liest Daten **reaktiv** aus dem Store (re-rendert bei Änderungen des ausgewählten Teilzustands).
* Selektor sollte **so klein wie möglich** sein.

```jsx
// CounterView.jsx
import { useSelector } from "react-redux";

export function CounterView() {
  const value = useSelector((state) => state.counter.value);
  return <p>Wert: {value}</p>;
}
```

> Tipp: Für komplexe Ableitungen **memoisierte Selektoren** (Reselect `createSelector`) nutzen.

---

#### **3) Aktionen auslösen: `useDispatch`**

* Gibt die `dispatch`-Funktion zurück, um Actions zu senden (sync oder async).

```jsx
// CounterControls.jsx
import { useDispatch } from "react-redux";
import { increment, addBy } from "./store.js";

export function CounterControls() {
  const dispatch = useDispatch();

  return (
    <div>
      <button onClick={() => dispatch(increment())}>+1</button>
      <button onClick={() => dispatch(addBy(5))}>+5</button>
    </div>
  );
}
```

---

#### **4) Async-Dispatch (Thunk/RTK)**

```js
// thunks.js
export const fetchAndAdd = () => async (dispatch) => {
  const res = await fetch("/api/value");
  const { delta } = await res.json();
  dispatch(addBy(delta));
};
```

```jsx
// AsyncButton.jsx
import { useDispatch } from "react-redux";
import { fetchAndAdd } from "./thunks.js";

export function AsyncButton() {
  const dispatch = useDispatch();
  return <button onClick={() => dispatch(fetchAndAdd())}>Server +</button>;
}
```

---

#### **5) Performance-Hinweise (kurz)**

* Selektiere **kleine Slices**: `useSelector(s => s.counter.value)` statt ganzen State.
* Für berechnete Werte **Reselect** verwenden.
* Bei Bedarf `useSelector(selector, shallowEqual)` für flache Vergleichsoptimierung.
* In großen Apps: **RTK**-Struktur + Feature-Slices.

---

### **Zusammenfassung**

* `<Provider store>` stellt React den Redux-Store bereit.
* **`useSelector`** liest reaktiv Teilzustände aus dem Store.
* **`useDispatch`** sendet Actions (auch Thunks) an den Store.
* Für Performance: kleine Selektoren, Reselect, RTK-Struktur.

**Quellen / Weiterlesen:**

* React Redux Hooks: [https://react-redux.js.org/api/hooks](https://react-redux.js.org/api/hooks)
* Redux Toolkit: [https://redux-toolkit.js.org/introduction/getting-started](https://redux-toolkit.js.org/introduction/getting-started)
* React Docs (State-Management-Übersicht): [https://react.dev/learn/scaling-up-with-reducer-and-context](https://react.dev/learn/scaling-up-with-reducer-and-context)
* MDN (RU) – State-Management-Grundlagen: [https://developer.mozilla.org/ru/docs/Glossary/State_management](https://developer.mozilla.org/ru/docs/Glossary/State_management)

  **[⬆ Наверх](#top)**

120. ### <a name="120"></a> 



  **[⬆ Наверх](#top)**

121. ### <a name="121"></a> 



  **[⬆ Наверх](#top)**

122. ### <a name="122"></a> 



  **[⬆ Наверх](#top)**

123. ### <a name="123"></a> 



  **[⬆ Наверх](#top)**

124. ### <a name="124"></a> 



  **[⬆ Наверх](#top)**

125. ### <a name="125"></a> 



  **[⬆ Наверх](#top)**

126. ### <a name="126"></a> 



  **[⬆ Наверх](#top)**

127. ### <a name="127"></a> 



  **[⬆ Наверх](#top)**

128. ### <a name="128"></a> 



  **[⬆ Наверх](#top)**

129. ### <a name="129"></a> 



  **[⬆ Наверх](#top)**

130. ### <a name="130"></a> 



  **[⬆ Наверх](#top)**  

131. ### <a name="131"></a> Was ist Code-Splitting?

### **Code-Splitting in React**

#### **Definition**

* **Code-Splitting** bedeutet, den JavaScript-Code einer App in **kleinere Bundles** aufzuteilen.
* Statt beim Start die **gesamte App** zu laden, werden nur die **nötigen Teile** geladen.
* Ziel: **Performance** verbessern (schnelleres Initial-Loading, geringere Bundle-Größe).

---

#### **Warum wichtig?**

* Große SPAs enthalten oft viele Seiten/Features, die nicht sofort gebraucht werden.
* Ohne Code-Splitting: Alles wird im Haupt-Bundle gebündelt → lange Ladezeit.
* Mit Code-Splitting: **Lazy Loading** von Routen, Komponenten oder Libraries.

---

#### **1) React.lazy + Suspense**

* Standardmethode in React für **komponentenbasiertes Code-Splitting**.

```jsx
import React, { Suspense, lazy } from "react";

const About = lazy(() => import("./About.jsx")); // Lazy Load

function App() {
  return (
    <div>
      <Suspense fallback={<p>Lädt...</p>}>
        <About /> {/* wird nur geladen, wenn benötigt */}
      </Suspense>
    </div>
  );
}
```

👉 `About.jsx` wird erst geladen, wenn die Komponente gerendert wird.

---

#### **2) Routing mit Code-Splitting**

```jsx
import { BrowserRouter, Routes, Route } from "react-router-dom";
import { Suspense, lazy } from "react";

const Home = lazy(() => import("./Home.jsx"));
const Dashboard = lazy(() => import("./Dashboard.jsx"));

export default function App() {
  return (
    <BrowserRouter>
      <Suspense fallback={<h2>Lädt...</h2>}>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/dashboard" element={<Dashboard />} />
        </Routes>
      </Suspense>
    </BrowserRouter>
  );
}
```

---

#### **3) Dynamisches Import()**

* Basis für Code-Splitting (funktioniert ohne React).
* Webpack/Vite erzeugt automatisch **separate Bundles**.

```js
// Beispiel
button.addEventListener("click", async () => {
  const { calculate } = await import("./math.js");
  console.log(calculate(2, 3));
});
```

---

#### **Tools/Build**

* In React-Apps meist via **Webpack** oder **Vite** konfiguriert (automatisch mit `import()`).
* **Bundle Analyzer** hilft, große Pakete zu identifizieren.

---

### **Zusammenfassung**

* Code-Splitting = **Aufteilen des Bundles**, um Ladezeiten zu optimieren.
* React bietet **React.lazy + Suspense** für Komponenten und **Lazy Routing**.
* Build-Tools wie Webpack/Vite nutzen `import()` für dynamisches Laden.

📖 Quellen:

* [React Docs – Code-Splitting](https://react.dev/reference/react/lazy)
* [MDN – import()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/import)
* [Webpack – Code Splitting](https://webpack.js.org/guides/code-splitting/)

---

  **[⬆ Наверх](#top)**

132. ### <a name="132"></a> Wie funktionieren React.lazy und Suspense?

### **React.lazy & Suspense**

#### **React.lazy**

* `React.lazy()` ermöglicht **Lazy Loading von Komponenten**.
* Statt die Komponente direkt zu importieren, wird sie nur geladen, wenn sie wirklich gebraucht wird.
* Syntax: `const Component = React.lazy(() => import("./Component.jsx"));`
* Funktioniert nur für **Default Exports**.

---

#### **Suspense**

* `Suspense` ist ein **Wrapper**, der angibt, was angezeigt wird, solange eine Lazy-Komponente noch geladen wird.
* Muss die Lazy-Komponenten umschließen.
* Prop: `fallback` → UI während des Ladens.

---

#### **Beispiel**

```jsx
import React, { lazy, Suspense } from "react";

// Lazy Loading
const About = lazy(() => import("./About.jsx"));
const Dashboard = lazy(() => import("./Dashboard.jsx"));

export default function App() {
  return (
    <div>
      <h1>Meine App</h1>
      <Suspense fallback={<p>Lädt...</p>}>
        <About />
        <Dashboard />
      </Suspense>
    </div>
  );
}
```

👉 `About` und `Dashboard` werden erst dann geladen, wenn sie gerendert werden.

---

#### **Lazy Loading mit Routing**

```jsx
import { BrowserRouter, Routes, Route } from "react-router-dom";
import { Suspense, lazy } from "react";

const Home = lazy(() => import("./Home.jsx"));
const Profile = lazy(() => import("./Profile.jsx"));

export default function App() {
  return (
    <BrowserRouter>
      <Suspense fallback={<h2>Seite lädt...</h2>}>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/profile" element={<Profile />} />
        </Routes>
      </Suspense>
    </BrowserRouter>
  );
}
```

---

### **Zusammenfassung**

* **`React.lazy`**: Definiert Komponenten, die erst bei Bedarf geladen werden (Lazy Loading).
* **`Suspense`**: Zeigt ein **Fallback-UI**, bis die Lazy-Komponente fertig geladen ist.
* Vorteil: **Code-Splitting** und bessere Performance.

📖 Quellen:

* [React Docs – `React.lazy`](https://react.dev/reference/react/lazy)
* [React Docs – `Suspense`](https://react.dev/reference/react/Suspense)

---

  **[⬆ Наверх](#top)**

133. ### <a name="133"></a> Was ist Tree Shaking?

### **Tree Shaking in React/JavaScript**

#### **Definition**

* **Tree Shaking** = Prozess beim Bundling (z. B. mit Webpack, Rollup, Vite), bei dem **ungenutzter Code automatisch entfernt** wird.
* Ziel: **kleinere Bundle-Größe** → bessere Performance.
* Funktioniert durch **statische Analyse** von ES6 **`import`/`export`**.

---

#### **Wie es funktioniert**

* Bundler untersucht, welche **Exporte wirklich importiert/genutzt** werden.
* Alles, was **nicht verwendet** wird, wird aus dem finalen Bundle entfernt.
* Voraussetzung:

  * ES Modules (`import`/`export`), **keine CommonJS (`require`)**.
  * Code muss **side-effect-free** sein oder in `package.json` `"sideEffects": false` deklarieren.

---

#### **Beispiel**

```js
// utils.js
export function add(a, b) { return a + b; }
export function subtract(a, b) { return a - b; }

// app.js
import { add } from "./utils.js";

console.log(add(2, 3));
```

👉 Ergebnis-Bundle enthält nur `add`, **`subtract` wird entfernt**.

---

#### **React-spezifisch**

* Hilft, nur die tatsächlich genutzten **Komponenten, Hooks oder Funktionen** ins Bundle zu packen.
* Wichtig beim Import von **Utility-Bibliotheken** wie lodash, date-fns, Material UI.

  * Statt `import _ from "lodash";` besser: `import debounce from "lodash/debounce";`

---

#### **Zusammenfassung**

* **Tree Shaking** entfernt ungenutzten Code beim Bundling.
* Nutzt **statische ES6-Imports/Exports**.
* Führt zu **kleineren, schnelleren Bundles**.

📖 Quellen:

* [MDN – Tree shaking](https://developer.mozilla.org/ru/docs/Glossary/Tree_shaking)
* [Webpack – Tree Shaking](https://webpack.js.org/guides/tree-shaking/)
* [Rollup – Tree Shaking](https://rollupjs.org/introduction/#tree-shaking)

---

  **[⬆ Наверх](#top)**

134. ### <a name="134"></a> Was ist Server-Side Rendering (SSR) und Hydration?

### **Server-Side Rendering (SSR) und Hydration**

#### **Server-Side Rendering (SSR)**

* Bei **SSR** wird die React-App bereits **auf dem Server in HTML gerendert** und an den Browser geschickt.
* Vorteil:

  * **Schnellere First Paint** (User sieht sofort Inhalt, auch ohne JS).
  * **SEO-freundlich**, da Suchmaschinen HTML direkt lesen können.
* Nachteil:

  * Mehr Serverlast, komplexere Infrastruktur.

**Beispiel (Next.js – SSR-Page):**

```jsx
// pages/index.jsx
export async function getServerSideProps() {
  const res = await fetch("https://api.example.com/data");
  const data = await res.json();
  return { props: { data } };
}

export default function Home({ data }) {
  return <h1>{data.title}</h1>;
}
```

---

#### **Hydration**

* Prozess, bei dem **React im Browser das bereits gerenderte HTML übernimmt** und interaktiv macht.
* Der Server liefert statisches HTML → React fügt **Event-Handler & State-Management** hinzu.
* Ohne Hydration wäre die Seite nur „totes“ HTML.

**Hydration im Browser (React 18):**

```jsx
import { createRoot, hydrateRoot } from "react-dom/client";
import App from "./App.jsx";

// hydrateRoot übernimmt vom Server gerendertes HTML
hydrateRoot(document.getElementById("root"), <App />);
```

---

#### **Zusammenhang**

1. Server rendert React-Komponenten zu HTML → schickt HTML an den Client.
2. Browser zeigt sofort Inhalt (SEO + schnelle Ladezeit).
3. React **hydriert**: bindet Event-Handler an vorhandenes DOM → Seite wird interaktiv.

---

### **Zusammenfassung**

* **SSR**: Rendern von React-Komponenten zu HTML auf dem Server → schneller, SEO-freundlich.
* **Hydration**: Reaktivieren der serverseitig gerenderten HTML-Struktur durch React im Client.
* Typisch umgesetzt mit Frameworks wie **Next.js** oder **Remix**.

📖 Quellen:

* [React Docs – Hydration](https://react.dev/reference/react-dom/client/hydrateRoot)
* [Next.js Docs – SSR](https://nextjs.org/docs/basic-features/pages#server-side-rendering)
* [MDN – Server-Side Rendering](https://developer.mozilla.org/ru/docs/Glossary/Server-side_rendering)

---

  **[⬆ Наверх](#top)**

135. ### <a name="135"></a> Wie geht man mit Hydration-Fehlern bei SSR um?

### **Hydration-Fehler bei SSR: Ursachen & Lösungen**

#### **Typische Ursachen**

* **Nicht-deterministisches Rendering**: `Date.now()`, `Math.random()`, `new Date().toLocaleString()` → Server/Client unterscheiden sich.
* **Zugriff auf Browser-APIs beim Rendern**: `window`, `document` auf dem Server.
* **Instabile IDs**: selbst generierte IDs unterscheiden sich auf Server/Client.
* **Falscher Einstiegspunkt**: `createRoot` statt **`hydrateRoot`**. ([react.dev][1])

---

#### **Grundregeln zur Vermeidung**

1. **Gleiches Markup auf Server & Client erzeugen**

   * Keine zufälligen/zeitabhängigen Werte im Render-Pfad.
   * Falls nötig: Platzhalter rendern und später im Client aktualisieren.

   ```jsx
   // Uhrzeit nur clientseitig aktualisieren
   import { useEffect, useState } from "react";

   export function Time() {
     const [time, setTime] = useState("—"); // stabil auf Server & initialem Client-Render
     useEffect(() => {
       setTime(new Date().toLocaleTimeString());
     }, []);
     return <span>{time}</span>;
   }
   ```

   ([MDN Web Docs][2])

2. **SSR-sichere IDs verwenden: `useId()`**

   * Generiert **konsistente** IDs auf Server und Client.

   ```jsx
   import { useId } from "react";
   export function Field() {
     const id = useId();
     return (
       <>
         <label htmlFor={id}>Name</label>
         <input id={id} />
       </>
     );
   }
   ```

   ([react.dev][3])

3. **Hydrieren, nicht neu mounten**

   * Im Client **`hydrateRoot`** statt `createRoot` nutzen.

   ```jsx
   import { hydrateRoot } from "react-dom/client";
   import App from "./App.jsx";
   hydrateRoot(document.getElementById("root"), <App />);
   ```

   ([react.dev][1])

4. **Browser-API-Zugriffe verschieben**

   * Zugriff auf `window`/`document` nur in Effekten:

   ```jsx
   import { useEffect, useState } from "react";
   export function WidthInfo() {
     const [w, setW] = useState(null);
     useEffect(() => setW(window.innerWidth), []);
     return <p>Breite: {w ?? "—"}</p>;
   }
   ```

   ([MDN Web Docs][2])

5. **Bekannte, bewusst unterschiedliche Inhalte dämpfen**

   * Für seltene Sonderfälle: `suppressHydrationWarning` **sparsam** einsetzen.

   ```jsx
   <span suppressHydrationWarning>{/* server: "—", client: "12:34" */}</span>
   ```

   > Escape-Hatch, nur eine Ebene tief wirksam. ([legacy.reactjs.org][4])

6. **Suspense gezielt nutzen**

   * Datenabhängige UI in **Suspense-Boundaries** kapseln; React hydriert priorisiert entlang der Interaktionspfade.

   ```jsx
   import { Suspense } from "react";
   <Suspense fallback={<p>Lädt…</p>}>
     <Comments /> 
   </Suspense>
   ```

   ([react.dev][1])

---

#### **Debug-Checkliste**

* **Warnung lesen**: Welche Stelle mismatched?
* **Server vs. Client-Markup vergleichen** (View Source vs. DevTools Elements).
* **Zeit/Zufall/Locale** im Renderpfad? → in `useEffect`.
* **IDs stabil?** → `useId()`.
* **Start-API korrekt?** → `hydrateRoot` verwenden. ([react.dev][1])

---

### **Zusammenfassung**

* Hydration-Fehler entstehen, wenn **Initial-HTML (Server)** ≠ **erster Client-Render** ist.
* Lösung: deterministisch rendern, Browser-APIs in Effekte verlagern, **`useId()`**, **`hydrateRoot`**, im Ausnahmefall `suppressHydrationWarning`.
* SSR korrekt einbinden und bei dynamischen Teilen mit **Effekten/Suspense** arbeiten.

**Quellen:**

* React – **`hydrateRoot`**: react.dev/reference/react-dom/client/hydrateRoot ([react.dev][1])
* React – **`useId`**: react.dev/reference/react/useId ([react.dev][3])
* React – **`createRoot` (Hinweis zu SSR)**: react.dev/reference/react-dom/client/createRoot ([react.dev][5])
* React (Legacy) – **`suppressHydrationWarning`**: legacy.reactjs.org/docs/dom-elements.html ([legacy.reactjs.org][4])
* MDN – **SSR (Glossar)**: developer.mozilla.org » Glossary » SSR ([MDN Web Docs][2])

[1]: https://react.dev/reference/react-dom/client/hydrateRoot?utm_source=chatgpt.com "hydrateRoot"
[2]: https://developer.mozilla.org/en-US/docs/Glossary/SSR?utm_source=chatgpt.com "Server-side rendering (SSR) - Glossary - MDN"
[3]: https://react.dev/reference/react/useId?utm_source=chatgpt.com "useId"
[4]: https://legacy.reactjs.org/docs/dom-elements.html?utm_source=chatgpt.com "DOM Elements"
[5]: https://react.dev/reference/react-dom/client/createRoot?utm_source=chatgpt.com "createRoot"

  **[⬆ Наверх](#top)**

136. ### <a name="136"></a> Was bedeutet Virtualisierung (z. B. mit react-window)?

### **Virtualisierung in React (z. B. mit `react-window`)**

#### **Definition**

* **Virtualisierung** bedeutet, dass bei langen Listen oder Tabellen **nur die aktuell sichtbaren Elemente** im DOM gerendert werden.
* Unsichtbare Elemente werden nicht gerendert → **deutlich bessere Performance** bei großen Datenmengen.
* Typische Libraries: **`react-window`**, **`react-virtualized`**.

---

#### **Problem ohne Virtualisierung**

* 10 000 Listeneinträge → alle werden ins DOM geschrieben.
* Folgen: langsamer Render, hoher Speicherverbrauch, Scroll-Ruckler.

---

#### **Lösung mit Virtualisierung**

* Nur die **sichtbaren Elemente + kleiner Buffer** werden gerendert.
* Beim Scrollen rendert React die **nächsten Elemente nach**, alte verschwinden wieder.

---

#### **Beispiel mit `react-window`**

```jsx
import { FixedSizeList as List } from "react-window";

const Row = ({ index, style }) => (
  <div style={style}>Eintrag #{index}</div>
);

export default function App() {
  return (
    <List
      height={200}     // sichtbare Höhe (px)
      itemCount={1000} // Anzahl Elemente
      itemSize={35}    // Höhe pro Element
      width={300}      // Breite
    >
      {Row}
    </List>
  );
}
```

👉 Obwohl `itemCount={1000}`, werden nur so viele Items gerendert, wie in `height / itemSize` passen (z. B. 200/35 ≈ 6 Items).

---

#### **Zusätzliche Features**

* **DynamicSizeList** → Elemente mit variabler Höhe.
* **Windowing in Tabellen** (z. B. `react-virtualized`).
* **Infinite Loading** (Daten beim Scroll nachladen).

---

### **Zusammenfassung**

* Virtualisierung = **Rendern nur sichtbarer UI-Elemente** statt ganzer Listen/Tabellen.
* Vorteil: **Performance**, weniger DOM-Nodes, flüssiges Scrolling.
* `react-window` ist eine schlanke Library dafür, `react-virtualized` bietet mehr Features.

📖 Quellen:

* [react-window GitHub](https://github.com/bvaughn/react-window)
* [React Docs – Rendering Lists](https://react.dev/learn/rendering-lists)
* [MDN – Virtualization (Glossary)](https://developer.mozilla.org/ru/docs/Glossary/Virtualization)

---

  **[⬆ Наверх](#top)**

137. ### <a name="137"></a> Wie verhindert man unnötige Re-Renders?

### **Strategien gegen unnötige Re-Renders in React**

#### **1) Komponenten memoisieren**

* **`React.memo`** verhindert Re-Render, wenn sich Props **shallow** nicht ändern.
* Für teure Berechnungen: zusätzlich **`useMemo`**.

```jsx
// Child.jsx
import React from "react";
export const Child = React.memo(function Child({ value }) {
  console.log("render child");
  return <div>{value}</div>;
});
```

📖 React.memo: [react.dev/reference/react/memo](https://react.dev/reference/react/memo)

---

#### **2) Stabile Callback-Referenzen**

* **Inline-Funktionen** erzeugen bei jedem Render neue Referenzen → Child rendert neu.
* **`useCallback`** macht Handler-Referenzen stabil.

```jsx
// Parent.jsx
import { useState, useCallback } from "react";
import { Child } from "./Child.jsx";

export default function Parent() {
  const [count, setCount] = useState(0);
  const inc = useCallback(() => setCount(c => c + 1), []); // stabile Referenz
  return (
    <>
      <button onClick={inc}>+1</button>
      <Child value={count} />
    </>
  );
}
```

📖 useCallback: [react.dev/reference/react/useCallback](https://react.dev/reference/react/useCallback)

---

#### **3) Teure Berechnungen memoisieren**

* Nur neu berechnen, wenn **Dependencies** sich ändern.

```jsx
import { useMemo } from "react";
function List({ items, q }) {
  const filtered = useMemo(
    () => items.filter(i => i.includes(q)),
    [items, q]
  );
  return <ul>{filtered.map(i => <li key={i}>{i}</li>)}</ul>;
}
```

📖 useMemo: [react.dev/reference/react/useMemo](https://react.dev/reference/react/useMemo)

---

#### **4) State nahe am Nutzer der Daten platzieren**

* **State colocation**: Globaler/zu hoher State bewirkt Re-Renders in zu vielen Komponenten.
* Hebe State **nur so weit hoch**, wie nötig; nutze **Context sparsam**.
  📖 State & Skalierung: [react.dev/learn/scaling-up-with-reducer-and-context](https://react.dev/learn/scaling-up-with-reducer-and-context)

---

#### **5) Context korrekt verwenden**

* **Context-Value stabil halten** (nicht bei jedem Render neues Objekt/Funktion).

```jsx
import { createContext, useMemo } from "react";
export const AuthCtx = createContext(null);

function AuthProvider({ user, login, logout, children }) {
  const value = useMemo(() => ({ user, login, logout }), [user, login, logout]);
  return <AuthCtx.Provider value={value}>{children}</AuthCtx.Provider>;
}
```

📖 Context: [react.dev/reference/react/Context](https://react.dev/reference/react/Context)

---

#### **6) Listen: stabile Keys & Item-Komponenten memoisieren**

* **Stabile `key`** (keine Indizes bei veränderlichen Listen).
* Item als **`React.memo`** + Props minimal halten.

```jsx
const Row = React.memo(function Row({ item }) {
  return <li>{item.name}</li>;
});
function List({ items }) {
  return <ul>{items.map(it => <Row key={it.id} item={it} />)}</ul>;
}
```

📖 Listen & Keys: [react.dev/learn/rendering-lists](https://react.dev/learn/rendering-lists)

---

#### **7) Redux/State-Manager optimieren**

* **`useSelector`**: nur **kleine Slices** selektieren; optional `shallowEqual`.
* **Reselect `createSelector`**: abgeleitete Daten **memoisieren**.

```js
// selector.js
import { createSelector } from "reselect";
const selectTodos = s => s.todos;
const selectFilter = s => s.filter;
export const selectVisible = createSelector(
  [selectTodos, selectFilter],
  (todos, f) => (f === "done" ? todos.filter(t => t.done) : todos)
);
```

```jsx
import { useSelector } from "react-redux";
import { selectVisible } from "./selector.js";
const todos = useSelector(selectVisible);
```

📖 Reselect: [redux.js.org/usage/deriving-data-selectors](https://redux.js.org/usage/deriving-data-selectors) • React-Redux Hooks: [react-redux.js.org/api/hooks](https://react-redux.js.org/api/hooks)

---

#### **8) Vermeide unnötige Re-Renders durch Prop-Identität**

* **Objekte/Arrays** nicht ad hoc erstellen → mit `useMemo` stabilisieren.

```jsx
const options = useMemo(() => ({ dense: true }), []); // statt {} inline
<Child options={options} />
```

---

#### **9) Virtualisierung für große Listen**

* Render nur sichtbarer Items (z. B. **`react-window`**) → weniger DOM & weniger Updates.
  📖 react-window: [github.com/bvaughn/react-window](https://github.com/bvaughn/react-window)

---

#### **10) Sonstiges**

* **Keine unnötigen Re-Renders forcieren**: State nur setzen, wenn sich Werte wirklich ändern.
* **Event-Handler entkoppeln** (nicht in Props neue Lambdas, wenn vermeidbar).
* **Production-Build** nutzen (Entwicklungsmodus rendert strenger).
  📖 Performance-Optimierung: [react.dev/learn/escape-hatches#optimizing-performance](https://react.dev/learn/escape-hatches#optimizing-performance)

---

### **Zusammenfassung**

* **Memoisierung** (React.memo, useMemo, useCallback) + **stabile Referenzen**.
* **State colocation** & **sparsame Context-Nutzung**.
* **Reselect** bei globalem State, **stabile Keys** in Listen, **Virtualisierung** für große Datenmengen.
* Nur notwendige Props/States ändern; Produktionsbuild verwenden.

**Quellen:**

* React Docs: `memo`, `useMemo`, `useCallback`, Context, Listen/Keys, Performance – [react.dev](https://react.dev/)
* Reselect/Selectoren – [redux.js.org](https://redux.js.org/usage/deriving-data-selectors)
* MDN (RU) – Производительность веб-приложений: [developer.mozilla.org/ru/](https://developer.mozilla.org/ru/)

  **[⬆ Наверх](#top)**

138. ### <a name="138"></a> Was ist React Transition Group?

### **React Transition Group**

#### **Definition**

* **React Transition Group** ist eine kleine Zusatzbibliothek für React, die **Animationen und Transitionen beim Mounten, Unmounten oder Ändern von Komponenten** ermöglicht.
* Sie selbst enthält **keine Animations-Implementierung**, sondern stellt nur **Lifecycle-Hooks und Klassen** bereit, um CSS-Transitions oder JS-Animationen auszuführen.

---

#### **Kernkomponenten**

1. **`<Transition>`**

   * Kontrolliert Mount/Unmount einer einzelnen Komponente.
   * Zustände: `entering`, `entered`, `exiting`, `exited`.

2. **`<CSSTransition>`**

   * Wie `<Transition>`, aber mit automatischem Hinzufügen/Entfernen von **CSS-Klassen**.
   * Erwartet vordefinierte CSS-Klassen wie `.fade-enter`, `.fade-enter-active`.

3. **`<TransitionGroup>`**

   * Container für eine **Liste von Transition-Komponenten** (z. B. animierte Listen-Elemente).

---

#### **Beispiel mit `<CSSTransition>`**

```jsx
// App.jsx
import { CSSTransition } from "react-transition-group";
import { useState } from "react";
import "./styles.css";

export default function App() {
  const [visible, setVisible] = useState(false);

  return (
    <div>
      <button onClick={() => setVisible(v => !v)}>Toggle</button>
      <CSSTransition
        in={visible}
        timeout={300}
        classNames="fade"
        unmountOnExit
      >
        <div className="box">Hallo!</div>
      </CSSTransition>
    </div>
  );
}
```

**CSS (`styles.css`)**

```css
.fade-enter {
  opacity: 0;
}
.fade-enter-active {
  opacity: 1;
  transition: opacity 300ms;
}
.fade-exit {
  opacity: 1;
}
.fade-exit-active {
  opacity: 0;
  transition: opacity 300ms;
}
```

👉 Wenn `visible` wechselt, wird die Box mit sanftem Fade-In/Fade-Out animiert.

---

#### **Mit `<TransitionGroup>` (Listenanimation)**

```jsx
import { TransitionGroup, CSSTransition } from "react-transition-group";

function TodoList({ items }) {
  return (
    <TransitionGroup component="ul">
      {items.map(item => (
        <CSSTransition key={item.id} timeout={300} classNames="fade">
          <li>{item.text}</li>
        </CSSTransition>
      ))}
    </TransitionGroup>
  );
}
```

👉 Elemente erscheinen/verschwinden mit Transitionen, wenn Items zur Liste hinzugefügt oder entfernt werden.

---

### **Zusammenfassung**

* **React Transition Group** = Bibliothek für **Animations-Lifecycle beim Mount/Unmount**.
* Hauptkomponenten: **`Transition`**, **`CSSTransition`**, **`TransitionGroup`**.
* Nutzt CSS-Klassen oder JS-Hooks für flexible Animationen.
* Besonders nützlich für **Einstiegs-/Ausstiegsanimationen** von Komponenten und Listen.

📖 Quellen:

* [React Transition Group – GitHub](https://github.com/reactjs/react-transition-group)
* [CSSTransition API](https://reactcommunity.org/react-transition-group/css-transition)

---

  **[⬆ Наверх](#top)**

139. ### <a name="139"></a> Was ist React Strict Mode und welche Vorteile bietet er?

### **React Strict Mode**

#### **Definition**

* **`<React.StrictMode>`** ist eine Wrapper-Komponente von React, die beim Entwickeln zusätzliche **Checks und Warnungen** aktiviert.
* Er hat **keine Auswirkung auf das Produktions-Build**, sondern nur in **Development Mode**.

---

#### **Wichtige Funktionen**

1. **Doppelte Ausführung bestimmter Methoden**

   * Lifecycle-Methoden, `useEffect`-Cleanup + Initial-Run werden **zweimal aufgerufen**, um **Nebenwirkungen sichtbar** zu machen.
   * Ziel: Probleme frühzeitig erkennen.

2. **Warnungen für unsichere Patterns**

   * Veraltete Lifecycle-Methoden (z. B. `componentWillMount`).
   * Legacy-APIs, die in zukünftigen Versionen entfernt werden.

3. **Highlighting von Nebenwirkungen**

   * Zeigt an, wenn Code **nicht pure** ist (z. B. doppeltes Setzen von State im Render-Prozess).

4. **Vorbereitung auf zukünftige Features**

   * Hilft, Apps kompatibel mit **Concurrent Rendering** und anderen neuen React-Features zu halten.

---

#### **Beispiel**

```jsx
import React from "react";
import { createRoot } from "react-dom/client";
import App from "./App.jsx";

createRoot(document.getElementById("root")).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
```

👉 Hierdurch laufen im Dev-Modus zusätzliche Checks, aber im Production-Build bleibt nur `<App />`.

---

#### **Vorteile**

* Frühzeitige Erkennung von **fehleranfälligen Code-Stellen**.
* Bereitet auf **zukünftige React-Versionen** vor.
* Verbessert **Code-Qualität** durch Warnungen über unsichere Patterns.

---

### **Zusammenfassung**

* **Strict Mode** = Entwicklungswerkzeug, aktiviert zusätzliche Checks & Warnungen.
* Hilft, **Nebenwirkungen, veraltete APIs und unsichere Patterns** zu erkennen.
* Hat **keinen Einfluss** auf Performance oder Verhalten in Produktion.

📖 Quellen:

* [React Docs – Strict Mode](https://react.dev/reference/react/StrictMode)
* [MDN – Entwicklungsmodi](https://developer.mozilla.org/ru/docs/Learn/Tools_and_testing/Understanding_client-side_tools/Development_and_production)

---

  **[⬆ Наверх](#top)**

140. ### <a name="140"></a> Was ist Concurrent Mode und welche Probleme löst er?

### **Concurrent Mode in React**

#### **Definition**

* **Concurrent Mode** (seit React 18: Teil von **Concurrent Rendering**) ist ein Rendering-Modus, der React erlaubt, **Rendering-Aufgaben zu unterbrechen, zu priorisieren und wieder aufzunehmen**, anstatt sie blockierend auszuführen.
* Dadurch bleibt die UI **responsiv**, auch wenn große Updates oder viele State-Änderungen passieren.

---

#### **Probleme im alten (synchronen) Modus**

* Vor React 18: **Rendering war synchron und blockierend**.
* Wenn eine Komponente viel rendern musste, war die **UI eingefroren** → Buttons reagierten erst nach Abschluss des Renderings.
* Keine Möglichkeit, Updates nach **Priorität** (z. B. User-Eingaben vor Hintergrund-Rendering) zu behandeln.

---

#### **Lösungen durch Concurrent Mode**

1. **Interruptible Rendering**

   * Lange Render-Aufgaben können unterbrochen werden, um **wichtigere Tasks** (z. B. Eingabe des Users) sofort auszuführen.

2. **Priorisierung von Updates**

   * React entscheidet: User-Interaktionen → hoch priorisiert, Hintergrund-Tasks → niedriger.

3. **Start/Stop/Resume**

   * React kann Rendering **pausieren und später fortsetzen**, ohne UI-Fehler.

4. **Bessere User Experience**

   * UI bleibt **reaktiv**, auch bei Daten-Fetching, komplexem State oder Animationen.

---

#### **Beispiel: Transition Updates (React 18)**

```jsx
import { useState, useTransition } from "react";

export default function Search() {
  const [query, setQuery] = useState("");
  const [list, setList] = useState([]);
  const [isPending, startTransition] = useTransition();

  function handleChange(e) {
    const q = e.target.value;
    setQuery(q);

    // teures Update → als Übergangs-Update markieren
    startTransition(() => {
      const results = Array(20000)
        .fill()
        .map((_, i) => q + i);
      setList(results);
    });
  }

  return (
    <>
      <input value={query} onChange={handleChange} />
      {isPending && <p>Loading…</p>}
      <ul>{list.map((item, i) => <li key={i}>{item}</li>)}</ul>
    </>
  );
}
```

👉 Hier bleibt das **Input reaktiv**, auch wenn das Rendering der Liste viel Zeit kostet.

---

#### **Zusammenfassung**

* **Concurrent Mode = interruptibles, priorisiertes Rendering.**
* Löst Probleme von **blockierendem synchronem Rendering**.
* Vorteile: **bessere Performance, reaktive UI, User-Eingaben bleiben flüssig**.
* Eingeführt in **React 18** (Features wie `useTransition`, `startTransition`).

📖 Quellen:

* [React Docs – Concurrent Rendering](https://react.dev/learn/synchronizing-with-effects#concurrent-rendering)
* [React Docs – startTransition](https://react.dev/reference/react/startTransition)
* [MDN – Rendering Performance](https://developer.mozilla.org/ru/docs/Web/Performance)

---

  **[⬆ Наверх](#top)**  

141. ### <a name="141"></a> 



  **[⬆ Наверх](#top)**

142. ### <a name="142"></a> 



  **[⬆ Наверх](#top)**

143. ### <a name="143"></a> 



  **[⬆ Наверх](#top)**

144. ### <a name="144"></a> 



  **[⬆ Наверх](#top)**

145. ### <a name="145"></a> 



  **[⬆ Наверх](#top)**

146. ### <a name="146"></a> Was ist ein Service Worker?

# Was ist ein Service Worker?

Ein **Service Worker** ist ein **hintergrundaktives JavaScript-Skript**,  
das **zwischen der Webanwendung und dem Netzwerk** steht.  
Es läuft **außerhalb der Hauptseite**, kann Netzwerk-Anfragen abfangen,  
Antworten cachen und Funktionen wie **Offline-Unterstützung** oder **Push-Benachrichtigungen** ermöglichen.

---

## 🔧 Eigenschaften

| Merkmal              | Beschreibung                                                |
|----------------------|-------------------------------------------------------------|
| Läuft im Hintergrund | Unabhängig vom DOM und UI-Thread                            |
| Ereignisgesteuert    | Reagiert auf `fetch`, `install`, `activate`, `push` etc.   |
| Offline-fähig        | Kann Anfragen aus dem Cache bedienen                        |
| Keine direkte DOM-Zugriff | Arbeitet mit `postMessage()` zur Kommunikation        |

---

## ✅ Typische Anwendungsfälle

- 📴 Offline-Webseiten (z. B. PWA)
- ⚡️ Schnellere Ladezeiten durch Caching
- 📡 Hintergrund-Synchronisierung
- 🔔 Push-Benachrichtigungen

---

## 📁 Lebenszyklus

1. **Registrierung**

```js
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js')
    .then(() => console.log('SW registriert'))
    .catch((err) => console.error('SW Fehler', err));
}
```

2. **Installation**

```js
self.addEventListener('install', (event) => {
  console.log('Service Worker installiert');
});
```

3. **Aktivierung**

```js
self.addEventListener('activate', (event) => {
  console.log('Service Worker aktiviert');
});
```

4. **Anfragen abfangen (`fetch`)**

```js
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request)
      .then((response) => response || fetch(event.request))
  );
});
```

---

## ⚠️ Einschränkungen

| Einschränkung            | Grund                                       |
|---------------------------|---------------------------------------------|
| Nur über HTTPS            | Aus Sicherheitsgründen                      |
| Kein DOM-Zugriff          | Nur über Messaging                         |
| Komplexe Caching-Strategien | Erfordert manuelles Cache-Management     |

---

## 📝 Zusammenfassung

| Begriff         | Beschreibung                                        |
|------------------|-----------------------------------------------------|
| Service Worker   | JS-Skript im Hintergrund, kontrolliert Netzwerk     |
| Vorteil          | Offline-Funktion, schnelleres Laden, Push-Services  |
| Tools            | `navigator.serviceWorker`, `Cache API`, `fetch`     |

---

## 🔗 Quellen

- [MDN – Service Workers](https://developer.mozilla.org/de/docs/Web/API/Service_Worker_API)  
- [Google Web – Service Worker Guide](https://developer.chrome.com/docs/workbox/service-worker-overview/)  
- [Web.dev – Learn Service Workers](https://web.dev/learn/pwa/service-workers/)

  **[⬆ Наверх](#top)**

147. ### <a name="147"></a> Was ist react-helmet und wie hilft es beim SEO?

# Was ist `react-helmet` und wie hilft es beim SEO?

**`react-helmet`** ist eine React-Bibliothek, mit der du dynamisch den `<head>`-Bereich  
deiner Anwendung verwalten kannst – z. B. Titel, Meta-Tags, Open Graph Daten etc.

➡️ Besonders hilfreich für **SEO**, **Social Sharing** und **dynamische Inhalte** bei React-SPAs.

---

## 📦 Installation

```bash
npm install react-helmet
```

---

## ✅ Verwendung

```jsx
import { Helmet } from 'react-helmet';

function MyPage() {
  return (
    <>
      <Helmet>
        <title>Meine Seite – React</title>
        <meta name="description" content="Beschreibung der Seite für SEO." />
        <meta property="og:title" content="OpenGraph Titel" />
      </Helmet>
      <h1>Willkommen</h1>
    </>
  );
}
```

➡️ Die `<head>`-Elemente werden zur Laufzeit aktualisiert.

---

## 🔍 SEO-Vorteile

| Vorteil                          | Beschreibung                                      |
|----------------------------------|---------------------------------------------------|
| 🧠 Dynamischer `<title>`         | Je nach Seite oder Route individuell anpassbar    |
| 🔍 Meta-Tags optimierbar         | Bessere Sichtbarkeit bei Google, Bing usw.        |
| 📲 OpenGraph / Twitter Cards     | Attraktive Vorschauen bei Social-Media-Teilen     |
| 🌐 hreflang, Canonical etc.      | Internationale SEO / Duplicate Content vermeiden  |

---

## 🛠 Alternative für SSR-Umgebungen

Bei **Server-Side Rendering (z. B. Next.js)** wird `react-helmet` oft ersetzt durch:

- `next/head` (Next.js)
- `@remix-run/react` → `<Meta />`

➡️ Diese Lösungen integrieren sich besser mit SSR und liefern **Head-Infos direkt im initialen HTML**.

---

## 📝 Zusammenfassung

| Begriff         | Beschreibung                                       |
|------------------|----------------------------------------------------|
| `react-helmet`   | Bibliothek zur Verwaltung von `<head>`-Tags       |
| Nutzen           | Verbesserte SEO, bessere Social-Media-Darstellung |
| Typische Tags    | `<title>`, `<meta>`, OpenGraph, Canonical-Links   |

---

## 🔗 Quellen

- [react-helmet – GitHub](https://github.com/nfl/react-helmet)  
- [react-helmet – Dokumentation](https://www.npmjs.com/package/react-helmet)  
- [MDN – Meta-Tags für SEO](https://developer.mozilla.org/de/docs/Learn/HTML/Introduction_to_HTML/The_head_metadata_in_HTML)

  **[⬆ Наверх](#top)**

148. ### <a name="148"></a> Wie funktioniert Lazy Loading mit dynamic import()?

# Wie funktioniert Lazy Loading mit `dynamic import()`?

**Lazy Loading** bedeutet, dass Module oder Komponenten **erst bei Bedarf** geladen werden –  
nicht beim Initial-Load.  
Mit `dynamic import()` kannst du in JavaScript oder React **Code-Splitting** betreiben  
und so die **Ladezeit und Performance verbessern**.

---

## 📦 Syntax: `import()` als Funktion

```js
import('./modul.js').then((modul) => {
  modul.doSomething();
});
```

- Gibt ein **Promise** zurück  
- Lädt das Modul **asynchron**

---

## ✅ Verwendung in React mit `React.lazy()`

```jsx
import React, { Suspense } from 'react';

const LazyComponent = React.lazy(() => import('./MyComponent'));

function App() {
  return (
    <Suspense fallback={<p>Lädt…</p>}>
      <LazyComponent />
    </Suspense>
  );
}
```

📌 Nur wenn `LazyComponent` gerendert werden soll, wird es mit `import()` geladen.

---

## 🧠 Vorteile von Lazy Loading

| Vorteil                 | Beschreibung                                 |
|--------------------------|----------------------------------------------|
| 🚀 Schnellere Initial-Ladezeit | Nur kritischer Code wird zuerst geladen       |
| 📦 Kleineres Bundle         | Spart Speicher und Traffic                   |
| 📲 Besseres Nutzererlebnis  | Schnellerer Page Load → weniger Wartezeit     |

---

## 🌍 Beispiel: Lazy Loading bei Routen (mit `react-router`)

```jsx
const Home = React.lazy(() => import('./pages/Home'));
const About = React.lazy(() => import('./pages/About'));

<Routes>
  <Route path="/" element={
    <Suspense fallback={<p>Home lädt…</p>}>
      <Home />
    </Suspense>
  } />
  <Route path="/about" element={
    <Suspense fallback={<p>About lädt…</p>}>
      <About />
    </Suspense>
  } />
</Routes>
```

---

## ⚠️ Einschränkungen

| Einschränkung            | Beschreibung                                |
|---------------------------|---------------------------------------------|
| Nur Default-Exports       | `React.lazy()` funktioniert nur mit Default |
| Suspense erforderlich     | Ohne `Suspense` keine Anzeige beim Laden    |
| Kein SSR-Support direkt   | Nur clientseitiges Lazy Loading             |

---

## 📝 Zusammenfassung

| Begriff             | Beschreibung                                     |
|----------------------|--------------------------------------------------|
| `import()`           | Asynchrone Modul-Ladung                          |
| `React.lazy()`       | Lazy Loading von React-Komponenten               |
| Vorteil              | Code-Splitting, schnellere Ladezeit              |

---

## 🔗 Quellen

- [MDN – import()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#dynamic_imports)  
- [React – Code-Splitting mit lazy()](https://react.dev/learn/code-splitting)  
- [React – React.lazy() API](https://react.dev/reference/react/lazy)

  **[⬆ Наверх](#top)**

149. ### <a name="149"></a> Was ist ein Finite-State Machine (FSM), z. B. mit XState?

# Was ist eine Finite-State Machine (FSM), z. B. mit XState?

Eine **Finite-State Machine (FSM)** ist ein Modell zur Darstellung von **endlich vielen Zuständen**  
und den **Übergängen (Transitions)** zwischen ihnen – abhängig von bestimmten Ereignissen (Events).

➡️ In React-Anwendungen eignet sich FSM perfekt zur **klaren Zustandslogik**, z. B. für Formulare, Auth, UI-States etc.

📦 Beliebtes Tool: [`XState`](https://xstate.js.org)

---

## 🧠 Grundprinzip einer FSM

| Begriff      | Erklärung                                 |
|--------------|--------------------------------------------|
| `State`      | Ein Zustand (z. B. `idle`, `loading`)      |
| `Event`      | Auslöser für Zustandswechsel (`FETCH`, `ERROR`) |
| `Transition` | Übergang von Zustand A zu B                |
| `Initial`    | Startzustand                              |
| `Final`      | Endzustand (optional)                      |

---

## ✅ Beispiel als Objekt (XState-Syntax)

```js
import { createMachine } from 'xstate';

const fetchMachine = createMachine({
  id: 'fetch',
  initial: 'idle',
  states: {
    idle: {
      on: { FETCH: 'loading' },
    },
    loading: {
      on: {
        RESOLVE: 'success',
        REJECT: 'failure',
      },
    },
    success: {},
    failure: {
      on: { RETRY: 'loading' },
    },
  },
});
```

➡️ FSM wechselt nur **kontrolliert** zwischen definierten Zuständen.

---

## ⚛️ Verwendung mit React (`@xstate/react`)

```jsx
import { useMachine } from '@xstate/react';
import { fetchMachine } from './machines/fetchMachine';

function Fetcher() {
  const [state, send] = useMachine(fetchMachine);

  return (
    <>
      {state.matches('idle') && <button onClick={() => send('FETCH')}>Laden</button>}
      {state.matches('loading') && <p>⏳ Ladevorgang...</p>}
      {state.matches('success') && <p>✅ Erfolgreich geladen</p>}
      {state.matches('failure') && (
        <button onClick={() => send('RETRY')}>🔁 Wiederholen</button>
      )}
    </>
  );
}
```

---

## 🧭 Warum FSM in UI sinnvoll ist

| Vorteil                            | Beschreibung                                 |
|------------------------------------|----------------------------------------------|
| 💡 Klar definierte Zustände         | Kein "unbekannter" Zustand mehr              |
| 🔐 Vorhersehbares Verhalten         | Transitions nur auf erlaubte Events möglich  |
| 🔄 Wiederverwendbar & testbar       | Zustände sind unabhängig von Komponenten     |
| 🧩 Visualisierbar                   | Tools wie [XState Visualizer](https://xstate.js.org/viz/) zeigen Übergänge grafisch |

---

## 📝 Zusammenfassung

| Begriff     | Erklärung                                            |
|--------------|-------------------------------------------------------|
| FSM         | Modell zur Kontrolle von Zuständen                    |
| XState      | Library zur Definition & Ausführung von FSMs          |
| Vorteil     | Mehr Kontrolle, bessere UI-Logik, einfache Wartbarkeit|

---

## 🔗 Quellen

- [XState Docs](https://xstate.js.org/docs/)  
- [XState – React Integration](https://xstate.js.org/docs/packages/xstate-react/)  
- [MDN – Finite-State Machine](https://developer.mozilla.org/en-US/docs/Glossary/Finite-state_machine)

  **[⬆ Наверх](#top)**

150. ### <a name="150"></a> Wie kann man ein Formular mit Formik und Yup erstellen und validieren?

# Wie kann man ein Formular mit Formik und Yup erstellen und validieren?

**Formik** ist eine beliebte React-Bibliothek zur einfachen Erstellung und Verwaltung von Formularen.  
**Yup** ist ein Schema-Builder zur Validierung von Formularwerten.  
➡️ Zusammen ermöglichen sie **strukturiertes, sauberes und validiertes Formular-Handling** in React.

---

## 📦 Installation

```bash
npm install formik yup
```

---

## ✅ Beispiel: Login-Formular mit Validierung

```jsx
import { Formik, Form, Field, ErrorMessage } from 'formik';
import * as Yup from 'yup';

// ✅ Validierungsschema mit Yup
const validationSchema = Yup.object({
  email: Yup.string()
    .email('Ungültige E-Mail')
    .required('E-Mail ist erforderlich'),
  password: Yup.string()
    .min(6, 'Mindestens 6 Zeichen')
    .required('Passwort ist erforderlich'),
});

function LoginForm() {
  return (
    <Formik
      initialValues={{ email: '', password: '' }}
      validationSchema={validationSchema}
      onSubmit={(values) => {
        console.log('Formulardaten:', values);
      }}
    >
      <Form className="space-y-4">
        <div>
          <label htmlFor="email">E-Mail:</label>
          <Field name="email" type="email" className="border p-1 w-full" />
          <ErrorMessage name="email" component="div" className="text-red-600 text-sm" />
        </div>

        <div>
          <label htmlFor="password">Passwort:</label>
          <Field name="password" type="password" className="border p-1 w-full" />
          <ErrorMessage name="password" component="div" className="text-red-600 text-sm" />
        </div>

        <button type="submit" className="bg-blue-500 text-white px-4 py-2 rounded">
          Einloggen
        </button>
      </Form>
    </Formik>
  );
}
```

---

## 🧠 Was macht Formik?

| Feature              | Beschreibung                                            |
|----------------------|---------------------------------------------------------|
| `initialValues`      | Startwerte für das Formular                             |
| `validationSchema`   | Yup-Schema zur Feldvalidierung                          |
| `onSubmit`           | Funktion, die bei erfolgreichem Submit ausgeführt wird  |
| `<Field>`            | Automatisch angebundene Eingabefelder                   |
| `<ErrorMessage>`     | Zeigt Fehlermeldungen für bestimmte Felder              |

---

## 📌 Vorteile von Formik + Yup

| Vorteil               | Beschreibung                                     |
|------------------------|--------------------------------------------------|
| ✅ Trennung von Logik & UI | Validierung getrennt in Schema                  |
| 🧪 Testbare Formulare   | Zustände und Fehler leicht überprüfbar            |
| 🔁 Automatisches Reset  | Einfaches Reset bei Erfolg oder Abbruch          |
| ⚠️ Benutzerfreundliche Fehlermeldungen | Direkt unter Eingabefeldern              |

---

## 📝 Zusammenfassung

| Tool     | Zweck                          |
|----------|--------------------------------|
| Formik   | Formularzustand, Events, Submit |
| Yup      | Validierungsschema für Felder   |
| Vorteil  | Weniger Boilerplate, klare Struktur, bessere UX |

---

## 🔗 Quellen

- [Formik – Dokumentation](https://formik.org/docs/overview)  
- [Yup – Doku](https://github.com/jquense/yup)  
- [Formik + Yup Beispiel](https://formik.org/docs/guides/validation)

  **[⬆ Наверх](#top)**  

151. ### <a name="151"></a> Wie konfiguriert man ESLint und Prettier in einem React-Projekt?

# Wie konfiguriert man ESLint und Prettier in einem React-Projekt?

**ESLint** analysiert deinen Code und findet potenzielle Fehler und Stilprobleme.  
**Prettier** ist ein Code-Formatter, der für konsistente Formatierung sorgt.  
Zusammen sorgen sie für **sauberen, wartbaren Code** in React-Projekten.

---

## 📦 Schritt-für-Schritt-Anleitung

### 1️⃣ ESLint + Prettier installieren

```bash
npm install -D eslint prettier eslint-config-prettier eslint-plugin-prettier
```

### 2️⃣ ESLint für React installieren

```bash
npm install -D eslint-plugin-react eslint-plugin-react-hooks
```

Bei TypeScript zusätzlich:

```bash
npm install -D @typescript-eslint/eslint-plugin @typescript-eslint/parser
```

---

## 📁 ESLint-Konfiguration (`.eslintrc.json`)

```json
{
  "env": {
    "browser": true,
    "es2021": true
  },
  "extends": [
    "eslint:recommended",
    "plugin:react/recommended",
    "plugin:react-hooks/recommended",
    "plugin:prettier/recommended"
  ],
  "plugins": ["react", "react-hooks", "prettier"],
  "parserOptions": {
    "ecmaVersion": "latest",
    "sourceType": "module",
    "ecmaFeatures": {
      "jsx": true
    }
  },
  "rules": {
    "prettier/prettier": "error"
  },
  "settings": {
    "react": {
      "version": "detect"
    }
  }
}
```

➡️ `"plugin:prettier/recommended"` integriert Prettier automatisch in ESLint.

---

## 🧼 Prettier-Konfiguration (`.prettierrc`)

```json
{
  "semi": true,
  "singleQuote": true,
  "tabWidth": 2,
  "trailingComma": "es5",
  "printWidth": 80
}
```

---

## 🛠 Weitere Dateien

### `.eslintignore`

```
node_modules
build
dist
```

### `.prettierignore`

```
build
dist
*.svg
```

---

## 🧪 Test: ESLint und Prettier ausführen

```bash
npx eslint src --ext .js,.jsx,.ts,.tsx
npx prettier --check .
```

Oder automatisch fixen:

```bash
npx eslint src --fix
npx prettier --write .
```

---

## ⚛️ VSCode-Integration

- Erweiterungen installieren:
  - ESLint
  - Prettier – Code formatter

- In den Einstellungen (`.vscode/settings.json`):

```json
{
  "editor.formatOnSave": true,
  "editor.defaultFormatter": "esbenp.prettier-vscode"
}
```

---

## 📝 Zusammenfassung

| Tool       | Zweck                                  |
|------------|-----------------------------------------|
| ESLint     | Analyse von Code-Stil und Fehlern       |
| Prettier   | Einheitliche automatische Formatierung  |
| Vorteil    | Sauberer Code, weniger Fehler, Teamkonsistenz |

---

## 🔗 Quellen

- [ESLint – Dokumentation](https://eslint.org/docs/latest/)  
- [Prettier – Docs](https://prettier.io/docs/en/index.html)  
- [eslint-config-prettier](https://github.com/prettier/eslint-config-prettier)  
- [React ESLint Setup](https://react.dev/learn/linting)

  **[⬆ Наверх](#top)**

152. ### <a name="152"></a> Wie funktioniert dynamic import() in React (Syntax, Anwendungsfälle)?

# Wie funktioniert `dynamic import()` in React (Syntax & Anwendungsfälle)?

`dynamic import()` ist eine **JavaScript-Funktion**, mit der Module **asynchron geladen** werden können.  
In React wird diese Technik vor allem für **Lazy Loading und Code-Splitting** eingesetzt,  
um die **Initial-Ladezeit zu reduzieren** und die **Performance zu verbessern**.

---

## 📦 Syntax

```js
import('./MyComponent.js').then((modul) => {
  modul.default(); // Zugriff auf den Default-Export
});
```

- Gibt ein **Promise** zurück
- Kann überall im Code verwendet werden, z. B. in Funktionen, Event-Handlern oder Bedingungsausdrücken

---

## ✅ Verwendung mit `React.lazy()`

In React ist `React.lazy()` die empfohlene Methode für dynamisches Importieren von **Komponenten**.

```jsx
import React, { Suspense } from 'react';

const LazyComponent = React.lazy(() => import('./MyComponent'));

function App() {
  return (
    <Suspense fallback={<div>Lädt…</div>}>
      <LazyComponent />
    </Suspense>
  );
}
```

📌 Wichtig: Komponenten müssen **default-exportiert** sein.  
Das `fallback` wird während des Ladevorgangs angezeigt.

---

## 🧠 Anwendungsfälle

| Anwendungsfall           | Beschreibung                                       |
|---------------------------|----------------------------------------------------|
| 🎯 Route-basiertes Lazy Loading | Nur beim Aufruf einer Seite wird Code geladen     |
| 🧩 Große Komponenten       | Nur geladen, wenn sie benötigt werden (z. B. Modale) |
| 🌍 Sprache / i18n          | Dynamisches Nachladen von Sprachdateien            |
| 🛠 Admin-Panels            | Nur bei bestimmten Rollen laden                   |

---

## 🌍 Beispiel: Routing mit React Router

```jsx
const Home = React.lazy(() => import('./pages/Home'));
const About = React.lazy(() => import('./pages/About'));

<Routes>
  <Route path="/" element={
    <Suspense fallback={<p>Loading...</p>}>
      <Home />
    </Suspense>
  } />
  <Route path="/about" element={
    <Suspense fallback={<p>Loading...</p>}>
      <About />
    </Suspense>
  } />
</Routes>
```

---

## 📝 Zusammenfassung

| Begriff            | Beschreibung                                 |
|---------------------|----------------------------------------------|
| `import()`          | Dynamischer Modulimport, Promise-basiert     |
| `React.lazy()`      | Für Lazy Loading von Komponenten             |
| Vorteil             | Geringere Bundle-Größe, schnellerer Start    |
| Voraussetzung       | Nur für **Default-Exports** geeignet         |

---

## 🔗 Quellen

- [MDN – Dynamic import()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#dynamic_imports)  
- [React Docs – Lazy Loading](https://react.dev/learn/code-splitting)  
- [React.lazy() – API](https://react.dev/reference/react/lazy)

  **[⬆ Наверх](#top)**

153. ### <a name="153"></a> 



  **[⬆ Наверх](#top)**

154. ### <a name="154"></a> 



  **[⬆ Наверх](#top)**

155. ### <a name="155"></a> 



  **[⬆ Наверх](#top)**

156. ### <a name="156"></a> 



  **[⬆ Наверх](#top)**

157. ### <a name="157"></a> 



  **[⬆ Наверх](#top)**

158. ### <a name="158"></a> 



  **[⬆ Наверх](#top)**

159. ### <a name="159"></a> 



  **[⬆ Наверх](#top)**

160. ### <a name="160"></a> 



  **[⬆ Наверх](#top)**

161. ### <a name="161"></a> Was ist der Unterschied zwischen interface und type in TypeScript?

# Was ist der Unterschied zwischen `interface` und `type` in TypeScript?

Sowohl `interface` als auch `type` dienen in TypeScript zur **Definition von Strukturen** für Objekte,  
Funktionen oder andere Typen.  
➡️ In vielen Fällen sind sie **austauschbar**, aber es gibt **wichtige Unterschiede**.

---

## ✅ Gemeinsamkeiten

Beide können verwendet werden, um **Objektformen** zu beschreiben:

```ts
interface Person {
  name: string;
  age: number;
}

type PersonType = {
  name: string;
  age: number;
};
```

Beide können **für Funktionen** verwendet werden:

```ts
interface SayHi {
  (name: string): string;
}

type SayHiType = (name: string) => string;
```

---

## 🔍 Unterschiede im Detail

| Aspekt               | `interface`                                  | `type`                                         |
|----------------------|-----------------------------------------------|------------------------------------------------|
| Erweiterung          | `extends` – mehrfach erweiterbar             | `&` – Intersection für Kombination             |
| Zusammenführbarkeit  | ✅ Automatisches Merging                      | ❌ Kein Merging möglich                        |
| Union / Intersection | ❌ Nur über Vererbung                        | ✅ `A | B`, `A & B` möglich                    |
| Verwendung für Primitives | ❌ Nicht erlaubt                          | ✅ `type ID = string | number;`                |
| Lesbarkeit im Compiler | 👌 besser geeignet für IntelliSense         | weniger sichtbar in komplexen Typen            |

---

## 🧪 Beispiel: Interface Merging

```ts
interface User {
  name: string;
}

interface User {
  age: number;
}

// Merged automatisch zu:
const u: User = {
  name: 'Anna',
  age: 30,
};
```

Mit `type` wäre das ein Fehler:

```ts
type User = {
  name: string;
};

type User = {
  age: number;
}; // ❌ Fehler: Duplicate Identifier
```

---

## 📌 Wann welches?

| Anwendungsfall                  | Empfehlung         |
|----------------------------------|--------------------|
| Öffentliche API (Libraries)     | `interface`        |
| Kombinationen, Unions           | `type`             |
| Erweiterung von Komponenten     | `interface`        |
| Primitive oder komplexe Typkombination | `type`     |

---

## 📝 Zusammenfassung

| `interface`                     | `type`                                      |
|----------------------------------|---------------------------------------------|
| Gut für OOP & Vererbung         | Flexibel für Kombinationen & Unions         |
| Unterstützt automatische Merges | Keine Mehrfachdefinition erlaubt            |
| Empfohlen für Klassen & Props   | Empfohlen für komplexe Typdefinitionen      |

---

## 🔗 Quellen

- [TypeScript: Interfaces](https://www.typescriptlang.org/docs/handbook/interfaces.html)  
- [TypeScript: Advanced Types](https://www.typescriptlang.org/docs/handbook/advanced-types.html)  
- [Type vs Interface – offizielle Empfehlung](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#interfaces)

  **[⬆ Наверх](#top)**

162. ### <a name="162"></a> Wie typisiert man Props und State in einer funktionalen Komponente?

# Wie typisiert man Props und State in einer funktionalen Komponente (TypeScript)?

In TypeScript kannst du Props und State in funktionalen React-Komponenten mithilfe von **Generics**  
und eigenen **Interfaces oder Typen** explizit typisieren.

---

## ✅ 1. Props typisieren

```tsx
type UserProps = {
  name: string;
  age: number;
};

const UserCard: React.FC<UserProps> = ({ name, age }) => {
  return (
    <div>
      <h2>{name}</h2>
      <p>{age} Jahre alt</p>
    </div>
  );
};
```

> `React.FC<Props>` enthält automatisch `children` und `FunctionComponent`-Typisierung.

Alternativ ohne `React.FC`:

```tsx
const UserCard = ({ name, age }: UserProps) => {
  return <p>{name} ({age})</p>;
};
```

---

## ✅ 2. State typisieren mit `useState`

```tsx
import { useState } from 'react';

const Counter = () => {
  const [count, setCount] = useState<number>(0);

  return (
    <button onClick={() => setCount(count + 1)}>
      Klicks: {count}
    </button>
  );
};
```

🔸 Für komplexe State-Objekte:

```tsx
type Todo = {
  id: number;
  text: string;
  completed: boolean;
};

const TodoList = () => {
  const [todos, setTodos] = useState<Todo[]>([]);
  // todos: Array von Todo-Objekten
};
```

---

## 🧠 Best Practices

| Bereich     | Empfehlung                                      |
|-------------|-------------------------------------------------|
| Props       | Interface oder Type erstellen                   |
| State       | Typen direkt in `useState<T>()` angeben         |
| React.FC    | Optional, aber gut für automatische `children`  |

---

## 📝 Zusammenfassung

| Typisierung | Beispiel                                       |
|-------------|------------------------------------------------|
| Props       | `type Props = { name: string }`               |
| State       | `useState<number>(0)` oder `useState<Todo[]>()` |
| Vorteil     | Typsicherheit, bessere DX, Autovervollständigung |

---

## 🔗 Quellen

- [React mit TypeScript – Props & State](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example/)  
- [TypeScript: React.FC vs normales Function Props Typing](https://www.typescriptlang.org/docs/handbook/react.html)

  **[⬆ Наверх](#top)**

163. ### <a name="163"></a> Wie nutzt man Generics in React mit TypeScript (z. B. für Listen)?

# Wie nutzt man Generics in React mit TypeScript? (z. B. für Listen)

**Generics** erlauben es dir, Komponenten in React **flexibel und wiederverwendbar** zu gestalten,  
indem du den Typ der Daten **zur Laufzeit bestimmst**, ohne ihn fest zu codieren.

➡️ Besonders nützlich für **Listen, Tabellen, Formulare, Dropdowns**, u. v. m.

---

## 🧱 Beispiel: Generische `List`-Komponente

```tsx
type ListProps<T> = {
  items: T[];
  renderItem: (item: T) => React.ReactNode;
};

function List<T>({ items, renderItem }: ListProps<T>) {
  return (
    <ul>
      {items.map((item, index) => (
        <li key={index}>{renderItem(item)}</li>
      ))}
    </ul>
  );
}
```

✅ `T` ist der **generische Typ**  
✅ `items: T[]` ist ein Array beliebiger Typen  
✅ `renderItem` definiert, **wie ein Element gerendert wird**

---

## 🔍 Verwendung mit verschiedenen Typen

### 🧍 Beispiel 1: Liste von Benutzern

```tsx
type User = {
  id: number;
  name: string;
};

const users: User[] = [
  { id: 1, name: 'Anna' },
  { id: 2, name: 'Tom' },
];

<List
  items={users}
  renderItem={(user) => <span>{user.name}</span>}
/>
```

### 📦 Beispiel 2: Liste von Zahlen

```tsx
const zahlen = [1, 2, 3];

<List
  items={zahlen}
  renderItem={(n) => <strong>{n}</strong>}
/>
```

---

## 🧠 Vorteile von Generics in React

| Vorteil                   | Beschreibung                                 |
|----------------------------|----------------------------------------------|
| 🔁 Wiederverwendbarkeit    | Komponente funktioniert mit jedem Typ        |
| ✅ Typsicherheit           | Keine `any`-Typen, volle Autovervollständigung |
| 🧩 Kombinierbar mit Props  | Flexible, starke Komponenten möglich         |

---

## 📝 Zusammenfassung

| Element     | Beschreibung                                |
|-------------|---------------------------------------------|
| `T`         | Platzhalter für einen konkreten Typ         |
| `List<T>`   | Komponente mit generischem Datentyp         |
| Vorteil     | Wiederverwendbare & typsichere Komponenten  |

---

## 🔗 Quellen

- [TypeScript – Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)  
- [React + TS – Generische Komponenten](https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase#generic-components)

  **[⬆ Наверх](#top)**

164. ### <a name="164"></a> Wie typisiert man Events in React mit TypeScript (onChange, onClick, FormEvent, MouseEvent)?

# Wie typisiert man Events in React mit TypeScript?  
(z. B. `onChange`, `onClick`, `FormEvent`, `MouseEvent`)

In TypeScript kannst du Events in React präzise typisieren,  
um Typsicherheit bei Event-Handlern wie `onClick`, `onChange`, `onSubmit` usw. zu gewährleisten.

---

## ✅ Häufige Event-Typen

| Event                | Typ                                                  |
|----------------------|------------------------------------------------------|
| `onClick`            | `React.MouseEvent<HTMLButtonElement>`               |
| `onChange`           | `React.ChangeEvent<HTMLInputElement>`               |
| `onSubmit`           | `React.FormEvent<HTMLFormElement>`                  |
| `onKeyDown`          | `React.KeyboardEvent<HTMLInputElement>`             |

---

## 📦 Beispiele

### 🖱 `onClick` mit Button

```tsx
const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {
  console.log('Button geklickt');
};

<button onClick={handleClick}>Klick mich</button>
```

---

### 🔤 `onChange` mit Input-Feld

```tsx
const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
  console.log(e.target.value);
};

<input type="text" onChange={handleChange} />
```

---

### 📩 `onSubmit` bei Formular

```tsx
const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
  e.preventDefault();
  console.log('Formular abgeschickt');
};

<form onSubmit={handleSubmit}>
  <button type="submit">Senden</button>
</form>
```

---

### ⌨️ `onKeyDown` bei Texteingabe

```tsx
const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
  if (e.key === 'Enter') {
    console.log('Enter gedrückt');
  }
};

<input type="text" onKeyDown={handleKeyDown} />
```

---

## 🧠 Tipp: Generische Schreibweise (optional)

```tsx
const handleClick = <T extends HTMLElement>(
  e: React.MouseEvent<T>
) => {
  console.log(e.currentTarget);
};
```

---

## 📝 Zusammenfassung

| Event-Typ                  | React-Typ                                       |
|-----------------------------|-------------------------------------------------|
| Button-Klick (`onClick`)    | `React.MouseEvent<HTMLButtonElement>`          |
| Texteingabe (`onChange`)    | `React.ChangeEvent<HTMLInputElement>`          |
| Formular-Abgabe (`onSubmit`)| `React.FormEvent<HTMLFormElement>`             |
| Tastatur (`onKeyDown`)      | `React.KeyboardEvent<HTMLInputElement>`        |

---

## 🔗 Quellen

- [React TypeScript Cheatsheet – Events](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/events/)  
- [TypeScript Handbook – React Events](https://www.typescriptlang.org/docs/handbook/react.html)

  **[⬆ Наверх](#top)**

165. ### <a name="165"></a> Wie erstellt man einen benutzerdefinierten Hook mit TypeScript?

# Wie erstellt man einen benutzerdefinierten Hook mit TypeScript?

Ein **benutzerdefinierter Hook** (Custom Hook) ist eine Funktion,  
die React-Hooks verwendet und eine **wiederverwendbare Logik** kapselt.  
Mit TypeScript kannst du ihn **typisieren**, um Typsicherheit und Autovervollständigung zu erhalten.

---

## ✅ Beispiel: useLocalStorage-Hook

```tsx
import { useState, useEffect } from 'react';

function useLocalStorage<T>(key: string, initialValue: T) {
  const [value, setValue] = useState<T>(() => {
    try {
      const item = localStorage.getItem(key);
      return item ? (JSON.parse(item) as T) : initialValue;
    } catch (error) {
      console.warn('Fehler beim Lesen aus localStorage', error);
      return initialValue;
    }
  });

  useEffect(() => {
    try {
      localStorage.setItem(key, JSON.stringify(value));
    } catch (error) {
      console.warn('Fehler beim Schreiben in localStorage', error);
    }
  }, [key, value]);

  return [value, setValue] as const;
}
```

---

## 📦 Verwendung

```tsx
const [username, setUsername] = useLocalStorage<string>('username', 'Gast');

<input
  value={username}
  onChange={(e) => setUsername(e.target.value)}
/>
```

---

## 🔍 Erklärung

| Teil                       | Bedeutung                                     |
|----------------------------|-----------------------------------------------|
| `useLocalStorage<T>`       | Generischer Hook, der mit beliebigem Typ funktioniert |
| `initialValue: T`          | Startwert wird als Typ übergeben              |
| `as const`                 | Rückgabe-Tuple ist readonly & typensicher     |

---

## 🧠 Typische Einsatzbereiche für Custom Hooks

- `useWindowSize` – Fensterbreite/-höhe verfolgen  
- `useDebounce` – Werte verzögert weitergeben  
- `usePrevious` – Vorherigen Wert merken  
- `useForm` – Formular-Handling kapseln  
- `useFetch` – API-Daten abrufen  

---

## 📝 Zusammenfassung

| Element             | Beschreibung                            |
|---------------------|------------------------------------------|
| Custom Hook         | Wiederverwendbare Logik mit Hooks        |
| TypeScript Support  | Generische Parameter und Rückgabetypen   |
| Vorteil             | Kapselung, Typensicherheit, Wiederverwendbarkeit |

---

## 🔗 Quellen

- [React – Custom Hooks](https://react.dev/learn/reusing-logic-with-custom-hooks)  
- [TypeScript – Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)  
- [React TypeScript Cheatsheet – Custom Hooks](https://react-typescript-cheatsheet.netlify.app/docs/advanced/hooks/)

  **[⬆ Наверх](#top)**

166. ### <a name="166"></a> Wie typisiert man useReducer mit TypeScript?

# Wie typisiert man `useReducer` mit TypeScript?

`useReducer` ist ein React-Hook zur **Verwaltung komplexer Zustandslogik**.  
Mit TypeScript kannst du die **State- und Action-Typen** exakt definieren, um Typsicherheit zu garantieren.

---

## ✅ Grundstruktur mit TypeScript

```tsx
import { useReducer } from 'react';

// 1. State-Typ
type CounterState = {
  count: number;
};

// 2. Action-Typen (Union)
type CounterAction =
  | { type: 'increment' }
  | { type: 'decrement' }
  | { type: 'reset'; payload: number };

// 3. Reducer
function counterReducer(state: CounterState, action: CounterAction): CounterState {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    case 'reset':
      return { count: action.payload };
    default:
      return state;
  }
}

// 4. Verwendung
function Counter() {
  const [state, dispatch] = useReducer(counterReducer, { count: 0 });

  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: 'increment' })}>+</button>
      <button onClick={() => dispatch({ type: 'decrement' })}>−</button>
      <button onClick={() => dispatch({ type: 'reset', payload: 0 })}>Reset</button>
    </div>
  );
}
```

---

## 🧠 Was wird hier typisiert?

| Element        | Beschreibung                             |
|----------------|------------------------------------------|
| `CounterState` | Struktur des States                      |
| `CounterAction`| Mögliche Aktionen als Union-Typ          |
| `useReducer`   | bekommt typisiertes `state` und `action` |

---

## 🧩 Generischer Reducer-Hook

```tsx
function useGenericReducer<S, A>(
  reducer: (state: S, action: A) => S,
  initialState: S
): [S, React.Dispatch<A>] {
  return useReducer(reducer, initialState);
}
```

---

## 📝 Zusammenfassung

| Schritt              | Was wird gemacht                          |
|----------------------|-------------------------------------------|
| `type State`         | Definiert die Struktur des States         |
| `type Action`        | Legt alle möglichen Aktionen fest         |
| `useReducer`         | Erhält `reducer`-Funktion und Startwert   |
| Vorteil              | Saubere Trennung von Logik und UI         |

---

## 🔗 Quellen

- [React – useReducer](https://react.dev/reference/react/useReducer)  
- [TypeScript – Typisierung von useReducer](https://react-typescript-cheatsheet.netlify.app/docs/advanced/hooks/#usereducer)

  **[⬆ Наверх](#top)**

167. ### <a name="167"></a> Wie typisiert man children korrekt in React-Komponenten?

# Wie typisiert man `children` korrekt in React-Komponenten? (TypeScript)

In React ist `children` ein spezielles Prop, das automatisch übergeben wird,  
wenn **JSX-Inhalte zwischen Öffnungs- und Schließ-Tags** einer Komponente stehen.

Mit TypeScript kannst du `children` explizit typisieren, um **Typsicherheit** und **bessere Autovervollständigung** zu erhalten.

---

## ✅ Standard-Typ für `children`

```tsx
type MyComponentProps = {
  children: React.ReactNode;
};

const MyComponent = ({ children }: MyComponentProps) => {
  return <div>{children}</div>;
};
```

➡️ `React.ReactNode` erlaubt Strings, Zahlen, JSX, Arrays, `null`, `undefined` usw.

---

## 🧠 Alternativen zu `React.ReactNode`

| Typ                | Beschreibung                                         |
|--------------------|------------------------------------------------------|
| `ReactNode`        | Alles, was in JSX verwendet werden kann              |
| `ReactElement`     | Nur **ein einzelnes JSX-Element**                    |
| `JSX.Element`      | Alias für `ReactElement`                             |
| `ReactChild`       | Nur string, number, JSX.Element                      |
| `ReactNode[]`      | Nur Array von JSX (nicht `null`, `undefined` etc.)   |

---

## 📦 Beispiel mit mehreren Props

```tsx
type CardProps = {
  title: string;
  children: React.ReactNode;
};

const Card = ({ title, children }: CardProps) => (
  <div className="border p-4">
    <h2>{title}</h2>
    <div>{children}</div>
  </div>
);
```

📌 Verwendung:

```tsx
<Card title="Info">
  <p>Das ist Inhalt innerhalb von `children`.</p>
</Card>
```

---

## 🔄 Mit `React.FC` (automatisch `children` enthalten)

```tsx
const Layout: React.FC = ({ children }) => {
  return <main>{children}</main>;
};
```

➡️ Vorteil: Kein eigener Typ für `children` notwendig.  
➡️ Nachteil: `React.FC` hat Einschränkungen bei generischen Props und `defaultProps`.

---

## 📝 Zusammenfassung

| Ziel                | Empfehlung                         |
|---------------------|-------------------------------------|
| Beliebige Inhalte   | `children: React.ReactNode`         |
| Nur ein Element     | `children: React.ReactElement`      |
| Automatisch (optional) | `React.FC` verwenden             |

---

## 🔗 Quellen

- [React – Children Props](https://react.dev/learn/passing-props-to-a-component#passing-jsx)  
- [React TypeScript Cheatsheet – Children](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example/#typing-children)

  **[⬆ Наверх](#top)**

168. ### <a name="168"></a> Was ist React.FC und welche Vor- und Nachteile hat es?

# Was ist `React.FC` und welche Vor- und Nachteile hat es?

`React.FC` (oder `React.FunctionComponent`) ist ein generischer Typ in TypeScript,  
der zur Typisierung von **funktionalen Komponenten** verwendet wird.  
Er ist besonders hilfreich, wenn man **`children` automatisch typisieren** möchte.

---

## ✅ Syntax

```tsx
const MyComponent: React.FC = () => {
  return <div>Hallo</div>;
};
```

Mit Props:

```tsx
type Props = {
  title: string;
};

const Header: React.FC<Props> = ({ title, children }) => (
  <header>
    <h1>{title}</h1>
    {children}
  </header>
);
```

---

## 📦 Was bringt `React.FC`?

| Funktion                 | Beschreibung                               |
|--------------------------|--------------------------------------------|
| ✅ Automatisch `children`| Kein manuelles Hinzufügen von `children`  |
| ✅ Generische Props      | Übergabe von Typen an die Komponente       |
| ✅ Intellisense          | Automatische Vorschläge in VSCode etc.     |

---

## ⚠️ Nachteile von `React.FC`

| Problem                                 | Beschreibung                                  |
|------------------------------------------|-----------------------------------------------|
| ❌ Eingeschränkte Generics               | Komplexe Props schwer typisierbar              |
| ❌ `defaultProps` wird nicht korrekt unterstützt | TypeScript erkennt sie nicht automatisch   |
| ❌ Zwingt `children`                    | Auch wenn Komponente keine `children` erwartet |

---

## 🧠 Best Practices

| Situation                       | Empfehlung                   |
|----------------------------------|------------------------------|
| Mit `children`                  | `React.FC` ist praktisch     |
| Ohne `children`                 | Besser eigenes Props-Interface |
| Große/generische Komponenten   | Lieber eigene Typisierung     |

---

## 🔍 Vergleich mit manuellem Props-Typ

```tsx
type Props = {
  name: string;
};

const Hello = ({ name }: Props) => <p>Hallo {name}</p>;
```

➡️ Kein `children`, aber volle Kontrolle.  
➡️ Mehr Flexibilität bei Generics.

---

## 📝 Zusammenfassung

| Vorteil (`React.FC`)       | Nachteil                              |
|----------------------------|----------------------------------------|
| Automatische `children`    | Eingeschränkte Flexibilität            |
| Klarer Funktions-Typ       | Probleme mit `defaultProps` und Generics |

---

## 🔗 Quellen

- [React.FC – Diskussion auf GitHub](https://github.com/facebook/create-react-app/pull/8177)  
- [React TypeScript Cheatsheet – React.FC](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/function_components/)

  **[⬆ Наверх](#top)**

169. ### <a name="169"></a> Wie typisiert man eine Komponente mit optionalen Props?

# Wie typisiert man eine Komponente mit **optionalen Props** in TypeScript?

In TypeScript kannst du Props als **optional** deklarieren,  
indem du ein **Fragezeichen (`?`)** hinter dem Namen eines Props setzt.

---

## ✅ Beispiel mit optionalem Prop

```tsx
type ButtonProps = {
  label: string;
  color?: string; // optional
};

const Button = ({ label, color = 'blue' }: ButtonProps) => {
  return <button className={`bg-${color}-500 text-white p-2`}>{label}</button>;
};
```

📌 `color` ist optional. Wenn es nicht übergeben wird, nutzt die Komponente `"blue"` als Default.

---

## 🧠 Warum `color = 'blue'`?

Das ist der **Default-Wert** in der Funktion.  
Wird `color` nicht übergeben, verwendet React automatisch den angegebenen Fallback.

---

## 💡 Mit `React.FC` (funktioniert auch)

```tsx
type AlertProps = {
  message?: string;
};

const Alert: React.FC<AlertProps> = ({ message }) => {
  return <div>{message ?? 'Standard-Nachricht'}</div>;
};
```

---

## 🧪 Mit `children` und optionalen Props

```tsx
type CardProps = {
  title?: string;
  children: React.ReactNode;
};

const Card = ({ title, children }: CardProps) => (
  <div className="p-4 border">
    {title && <h2>{title}</h2>}
    {children}
  </div>
);
```

---

## 📝 Zusammenfassung

| Merkmal                  | Beschreibung                                 |
|--------------------------|----------------------------------------------|
| `propName?: type`        | Macht das Prop optional                      |
| `propName = value`       | Setzt einen Default-Wert innerhalb der Funktion |
| Vorteil                  | Flexible Verwendung, saubere Komponenten     |

---

## 🔗 Quellen

- [TypeScript – Optional Properties](https://www.typescriptlang.org/docs/handbook/2/objects.html#optional-properties)  
- [React TypeScript Cheatsheet – Props](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example/)

  **[⬆ Наверх](#top)**

170. ### <a name="170"></a> Wie arbeitet man mit Drittanbieter-Bibliotheken, die keine Typen enthalten?

# Wie arbeitet man mit Drittanbieter-Bibliotheken, die **keine Typen** enthalten?

Wenn eine JavaScript-Bibliothek **keine TypeScript-Typen** bereitstellt,  
kannst du sie trotzdem verwenden – mithilfe von:

1. 🧩 **@types/**-Paketen  
2. 🧨 **declare module**  
3. 🧠 Eigene Typdefinitionen schreiben  

---

## ✅ 1. Prüfen, ob es ein `@types/`-Paket gibt

Viele Bibliotheken haben ein **extern gepflegtes Typ-Paket**:

```bash
npm install --save-dev @types/lodash
```

📦 Quelle: https://github.com/DefinitelyTyped/DefinitelyTyped

---

## ❌ 2. Wenn keine Typen existieren: `declare module`

Erstelle z. B. eine Datei `src/types/thirdparty.d.ts`:

```ts
declare module 'untypisierte-lib' {
  const content: any;
  export default content;
}
```

➡️ Damit kannst du das Modul **ohne Typsicherheitsfehler** importieren:

```ts
import foo from 'untypisierte-lib';
```

---

## ✍️ 3. Eigene Typen definieren (besser als `any`)

```ts
declare module 'untypisierte-lib' {
  export function greet(name: string): string;
  export const version: string;
}
```

➡️ Nun bekommst du **Autovervollständigung & Typsicherheit** beim Import:

```ts
import { greet } from 'untypisierte-lib';
greet('Sergii');
```

---

## 🧠 Typ "any" vermeiden

```ts
import xyz from 'legacy-lib';
// schlechter Stil:
(xyz as any).doSomething(); // ⛔️ Keine Typsicherheit!
```

✅ Besser: Eigene Schnittstellen oder Typen definieren!

---

## 📝 Zusammenfassung

| Schritt                | Vorgehen                                                  |
|------------------------|-----------------------------------------------------------|
| ✅ Prüfen auf `@types/` | `npm i -D @types/libname`                                |
| 🔨 Kein Typ vorhanden   | `declare module 'lib' {}` verwenden                      |
| ✍️ Eigenes Typing       | Besser als `any`, mehr Kontrolle                         |
| 🔐 Ziel                 | Typsicherheit und bessere Entwicklererfahrung            |

---

## 🔗 Quellen

- [TypeScript – Declaration Files](https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html)  
- [DefinitelyTyped Repo](https://github.com/DefinitelyTyped/DefinitelyTyped)  
- [Using Non-TypeScript Libraries](https://www.typescriptlang.org/docs/handbook/modules.html#ambient-modules)

  **[⬆ Наверх](#top)**

171. ### <a name="171"></a> Was ist der Unterschied zwischen ESM und CommonJS?

# Was ist der Unterschied zwischen **ESM** und **CommonJS**?

**ESM (ECMAScript Modules)** und **CommonJS (CJS)** sind zwei unterschiedliche **Modulsysteme** in JavaScript.  
Sie definieren, **wie Code importiert und exportiert wird** – besonders wichtig bei der Arbeit mit Node.js und modernen Frontend-Bundlern.

---

## ✅ Übersicht

| Merkmal              | ESM                                 | CommonJS                           |
|----------------------|--------------------------------------|-------------------------------------|
| Einführung           | Offizieller JS-Standard (ES6)        | Node.js-spezifisch (älter)         |
| Syntax               | `import` / `export`                  | `require()` / `module.exports`     |
| Ausführung           | statisch analysierbar                | dynamisch zur Laufzeit             |
| Dateiendung (Node.js)| `.mjs` oder `"type": "module"`       | `.cjs` oder keine spezielle Angabe |
| Tree Shaking         | ✅ möglich                           | ❌ nicht zuverlässig                |
| Verwendung           | Frontend + modernes Node.js          | Klassisches Node.js                |

---

## 📦 Beispiel: Import / Export

### ESM

```js
// math.js
export const add = (a, b) => a + b;

// index.js
import { add } from './math.js';
```

### CommonJS

```js
// math.js
exports.add = (a, b) => a + b;

// index.js
const { add } = require('./math');
```

---

## 🔁 Interoperabilität (CJS ↔ ESM)

- In Node.js ist **Mischen möglich**, aber **kompliziert**  
- `import` kann **keine CJS-Datei mit `default`** direkt lesen  
- Viele Tools (z. B. Webpack, Vite) unterstützen **beide Formate**

---

## 🧠 Wann was nutzen?

| Situation                         | Empfehlung        |
|-----------------------------------|-------------------|
| Neues Projekt mit Bundler         | **ESM**           |
| Legacy-Node.js ohne Transpiler    | **CommonJS**      |
| Bibliothek mit Tree Shaking       | **ESM bevorzugt** |

---

## 📝 Zusammenfassung

| ESM                  | CommonJS              |
|----------------------|------------------------|
| `import/export`      | `require/module.exports` |
| Modern & standardisiert | Node.js-spezifisch (älter) |
| Tree Shaking möglich | Kein Tree Shaking      |

---

## 🔗 Quellen

- [MDN – Modules: ES6](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules)  
- [Node.js – CommonJS vs ESM](https://nodejs.org/api/esm.html)  
- [ESM vs CJS – Differences](https://blog.logrocket.com/esm-vs-commonjs-node-js/)

  **[⬆ Наверх](#top)**

172. ### <a name="172"></a> 



  **[⬆ Наверх](#top)**

173. ### <a name="173"></a> 



  **[⬆ Наверх](#top)**

174. ### <a name="174"></a> 



  **[⬆ Наверх](#top)**

175. ### <a name="175"></a> 



  **[⬆ Наверх](#top)**

176. ### <a name="176"></a> 



  **[⬆ Наверх](#top)**

177. ### <a name="177"></a> 



  **[⬆ Наверх](#top)**

178. ### <a name="178"></a> 



  **[⬆ Наверх](#top)**

179. ### <a name="179"></a> 



  **[⬆ Наверх](#top)**

180. ### <a name="180"></a> 



  **[⬆ Наверх](#top)**  

181. ### <a name="181"></a> 



  **[⬆ Наверх](#top)**

182. ### <a name="182"></a> 



  **[⬆ Наверх](#top)**

183. ### <a name="183"></a> 



  **[⬆ Наверх](#top)**

184. ### <a name="184"></a> 



  **[⬆ Наверх](#top)**

185. ### <a name="185"></a> 



  **[⬆ Наверх](#top)**

186. ### <a name="186"></a> 



  **[⬆ Наверх](#top)**

187. ### <a name="187"></a> 



  **[⬆ Наверх](#top)**

188. ### <a name="188"></a> 



  **[⬆ Наверх](#top)**

189. ### <a name="189"></a> 



  **[⬆ Наверх](#top)**

190. ### <a name="190"></a> 



  **[⬆ Наверх](#top)**  

191. ### <a name="191"></a> 



  **[⬆ Наверх](#top)**

192. ### <a name="192"></a> 



  **[⬆ Наверх](#top)**

193. ### <a name="193"></a> 



  **[⬆ Наверх](#top)**

194. ### <a name="194"></a> 



  **[⬆ Наверх](#top)**

195. ### <a name="195"></a> 



  **[⬆ Наверх](#top)**

196. ### <a name="196"></a> 



  **[⬆ Наверх](#top)**

197. ### <a name="197"></a> 



  **[⬆ Наверх](#top)**

198. ### <a name="198"></a> 



  **[⬆ Наверх](#top)**

199. ### <a name="199"></a> 



  **[⬆ Наверх](#top)**

200. ### <a name="200"></a> 



  **[⬆ Наверх](#top)**      
