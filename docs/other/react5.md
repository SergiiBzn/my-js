<a name="top"></a>

[–ù–∞ –≥–ª–∞–≤–Ω—É—é](../../README.md)

[–ü–µ—Ä–µ–π—Ç–∏ –∫ –≤–æ–ø—Ä–æ—Å–∞–º](#questions)

| ‚Ññ. | –í–æ–ø—Ä–æ—Å |
| --- | --------- |
|   | ReactJS Grundlagen |
|1 | [Was ist React und welche Probleme l√∂st es?](#1) |
|2 | [Was ist JSX und warum wird es verwendet?](#2) |
|3 | [Was ist Virtual DOM und wie funktioniert es?](#3) |
|4 | [Was ist der Unterschied zwischen React und ReactDOM?](#4) |
|5 | [Warum importieren wir React, auch wenn es scheinbar nicht benutzt wird?](#5) |
|6 | [Was ist ein React Fragment und warum ist es n√ºtzlich?](#6) |
|7 | [Was ist der Unterschied zwischen einem Element, einer Komponente und einer Instanz?](#7) |
|8 | [Was ist das Fiber-Architekturmodell in React?](#8) |
|9 | [Was bedeutet ‚ÄûBatching‚Äú in React?](#9) |
|10 | [Was ist die Rolle des key in React-Listen?](#10) |
|11 | [Wie funktioniert die Wiederverwendung von Komponenten?](#11) |
|12 | [](#12) |
|13 | [](#13) |
|14 | [](#14) |
|15 | [](#15) |
|16 | [](#16) |
|17 | [](#17) |
|18 | [](#18) |
|19 | [](#19) |
|20 | [](#20) |
|   | Komponenten, Props & State |
|21 | [Was sind Props und wozu werden sie verwendet?](#21) |
|22 | [Was ist der Unterschied zwischen Props und State?](#22) |
|23 | [Warum sind Props nur lesbar?](#23) |
|24 | [Wie funktioniert der unidirektionale Datenfluss in React?](#24) |
|25 | [Was ist State in Klassen- und Funktionskomponenten?](#25) |
|26 | [Wie funktioniert setState?](#26) |
|27 | [Was ist der Unterschied zwischen kontrollierten und unkontrollierten Komponenten?](#27) |
|28 | [Was sind Default Props und PropTypes?](#28) |
|29 | [Was ist React.memo und wof√ºr wird es verwendet?](#29) |
|30 | [Was ist PureComponent und wie unterscheidet es sich von Component?](#30) |
|31 | [Wann sollte shouldComponentUpdate verwendet werden?](#31) |
|32 | [Was ist ein ref und wann wird er eingesetzt?](#32) |
|33 | [Was bedeutet ‚ÄûLifting State Up‚Äú?](#33) |
|34 | [](#34) |
|35 | [](#35) |
|36 | [](#36) |
|37 | [](#37) |
|38 | [](#38) |
|39 | [](#39) |
|40 | [](#40) |
|   | Lebenszyklus von Komponenten |
|41 | [Was sind die Phasen des Komponentenlebenszyklus?](#41) |
|42 | [Welche Lifecycle-Methoden gibt es in Klassenkomponenten?](#42) |
|43 | [Welche Lifecycle-Methoden sind veraltet?](#43) |
|44 | [Wie kann man Lifecycle-Methoden mit Hooks ersetzen?](#44) |
|45 | [Was ist componentDidMount und was ist das √Ñquivalent mit Hooks?](#45) |
|46 | [](#46) |
|47 | [](#47) |
|48 | [](#48) |
|49 | [](#49) |
|50 | [](#50) |
|   | Hooks |
|51 | [Was sind Hooks in React?](#51) |
|52 | [Wie funktionieren useState und useEffect?](#52) |
|53 | [Was macht useContext?](#53) |
|54 | [Was ist useRef und wann wird es verwendet?](#54) |
|55 | [Was ist useCallback, useMemo, useReducer?](#55) |
|56 | [Wie schreibt man einen benutzerdefinierten Hook?](#56) |
|57 | [Wie verhindert man eine Endlosschleife in useEffect?](#57) |
|58 | [Wie implementiert man Timeout oder Interval mit Hooks?](#58) |
|59 | [](#59) |
|60 | [](#60) |
|   | React-Patterns und Konzepte |
|61 | [Was ist ein Higher-Order Component (HOC)?](#61) |
|62 | [Was ist das Render-Prop-Pattern?](#62) |
|63 | [Was ist die Context-API und wie funktioniert useContext?](#63) |
|64 | [Was sind Portale in React?](#64) |
|65 | [Was ist bedingtes Rendern (Conditional Rendering)?](#65) |
|66 | [Was ist ein Error Boundary?](#66) |
|67 | [Wie funktioniert Event-Handling in React?](#67) |
|68 | [Was ist ein synthetisches Ereignis (SyntheticEvent)?](#68) |
|69 | [Was ist props.children?](#69) |
|70 | [Was bedeutet ‚Äûcontrolled component‚Äú und ‚Äûuncontrolled component‚Äú bei Formularen?](#70) |
|71 | [](#71) |
|72 | [](#72) |
|73 | [](#73) |
|74 | [](#74) |
|75 | [](#75) |
|   | Daten & API |
|76 | [Wie f√ºhrt man API-Aufrufe mit Fetch oder Axios durch?](#76) |
|77 | [Wie verwaltet man Lade-, Fehler- und Erfolgsstatus?](#77) |
|78 | [Wie funktioniert WebSocket mit React?](#78) |
|79 | [Wie kann man Daten zwischen Komponenten weitergeben?](#79) |
|80 | [Wie macht man einen Datenabruf nur beim ersten Rendern?](#80) |
|81 | [Was ist das Problem bei ‚Äûstale closures‚Äú mit Hooks?](#81) |
|82 | [Wie funktioniert die Fehlerbehandlung mit try/catch in React?](#82) |
|83 | [Wie kann man ein Mock-API oder Mock Server verwenden?](#83) |
|84 | [Wie funktioniert Suspense f√ºr Datenabfragen?](#84) |
|85 | [](#85) |
|86 | [](#86) |
|87 | [](#87) |
|88 | [](#88) |
|89 | [](#89) |
|90 | [](#90) |
|   | Testing |
|91 | [Was ist Unit-, Integration- und E2E-Testing?](#91) |
|92 | [Was ist Snapshot-Testing?](#92) |
|93 | [Welche Tools nutzt man f√ºr React-Tests (Jest, React Testing Library)?](#93) |
|94 | [Wie testet man Komponenten, Props und Events?](#94) |
|95 | [Wie testet man benutzerdefinierte Hooks?](#95) |
|96 | [](#96) |
|97 | [](#97) |
|98 | [](#98) |
|99 | [](#99) |
|100 | [](#100) |
|   | Routing mit React Router |
|101 | [Wie funktioniert Routing in React mit react-router-dom?](#101) |
|102 | [Was sind die Unterschiede zwischen react-router v5 und v6?](#102) |
|103 | [Was sind Route, Link, Navigate, Outlet?](#103) |
|104 | [Wie erstellt man Nested Routes?](#104) |
|105 | [Wie implementiert man Redirects?](#105) |
|106 | [Wie funktioniert programmgesteuerte Navigation (useNavigate)?](#106) |
|107 | [](#107) |
|108 | [](#108) |
|109 | [](#109) |
|110 | [](#110) |
|   | Redux & Redux Toolkit |
|111 | [Was ist Redux und wie funktioniert es?](#111) |
|112 | [Was sind Actions, Reducer und Store?](#112) |
|113 | [Wie funktioniert Redux Toolkit (createSlice, configureStore, createAsyncThunk)?](#113) |
|114 | [Was ist RTK Query?](#114) |
|115 | [Was ist der Unterschied zwischen Redux und der Context-API?](#115) |
|116 | [Was ist connect() in Redux?](#116) |
|117 | [Was sind Middleware in Redux (z. B. redux-thunk, redux-logger)?](#117) |
|118 | [Was ist createSelector und wie funktioniert Reselect?](#118) |
|119 | [Wie verbindet man Redux mit React √ºber Hooks (useSelector, useDispatch)?](#119) |
|120 | [](#120) |
|121 | [](#121) |
|122 | [](#122) |
|123 | [](#123) |
|124 | [](#124) |
|125 | [](#125) |
|126 | [](#126) |
|127 | [](#127) |
|128 | [](#128) |
|129 | [](#129) |
|130 | [](#130) |
|   | Optimierung & Performance |
|131 | [Was ist Code-Splitting?](#131) |
|132 | [Wie funktionieren React.lazy und Suspense?](#132) |
|133 | [Was ist Tree Shaking?](#133) |
|134 | [Was ist Server-Side Rendering (SSR) und Hydration?](#134) |
|135 | [Wie geht man mit Hydration-Fehlern bei SSR um?](#135) |
|136 | [Was bedeutet Virtualisierung (z. B. mit react-window)?](#136) |
|137 | [Wie verhindert man unn√∂tige Re-Renders?](#137) |
|138 | [Was ist React Transition Group?](#138) |
|139 | [Was ist React Strict Mode und welche Vorteile bietet er?](#139) |
|140 | [Was ist Concurrent Mode und welche Probleme l√∂st er?](#140) |
|141 | [](#141) |
|142 | [](#142) |
|143 | [](#143) |
|144 | [](#144) |
|145 | [](#145) |
|   | Sonstiges |
|146 | [Was ist ein Service Worker?](#146) |
|147 | [Was ist react-helmet und wie hilft es beim SEO?](#147) |
|148 | [Wie funktioniert Lazy Loading mit dynamic import()?](#148) |
|149 | [Was ist ein Finite-State Machine (FSM), z. B. mit XState?](#149) |
|150 | [Wie kann man ein Formular mit Formik und Yup erstellen und validieren?](#150) |
|151 | [Wie konfiguriert man ESLint und Prettier in einem React-Projekt?](#151) |
|152 | [Wie funktioniert dynamic import() in React (Syntax, Anwendungsf√§lle)?](#152) |
|153 | [](#153) |
|154 | [](#154) |
|155 | [](#155) |
|156 | [](#156) |
|157 | [](#157) |
|158 | [](#158) |
|159 | [](#159) |
|160 | [](#160) |
|   | React + TypeScript |
|161 | [Was ist der Unterschied zwischen interface und type in TypeScript?](#161) |
|162 | [Wie typisiert man Props und State in einer funktionalen Komponente?](#162) |
|163 | [Wie nutzt man Generics in React mit TypeScript (z. B. f√ºr Listen)?](#163) |
|164 | [Wie typisiert man Events in React mit TypeScript (onChange, onClick, FormEvent, MouseEvent)?](#164) |
|165 | [Wie erstellt man einen benutzerdefinierten Hook mit TypeScript?](#165) |
|166 | [Wie typisiert man useReducer mit TypeScript?](#166) |
|167 | [Wie typisiert man children korrekt in React-Komponenten?](#167) |
|168 | [Was ist React.FC und welche Vor- und Nachteile hat es?](#168) |
|169 | [Wie typisiert man eine Komponente mit optionalen Props?](#169) |
|170 | [Wie arbeitet man mit Drittanbieter-Bibliotheken, die keine Typen enthalten?](#170) |
|171 | [Was ist der Unterschied zwischen ESM und CommonJS?](#171) |
|172 | [](#172) |
|173 | [](#173) |
|174 | [](#174) |
|175 | [](#175) |
|176 | [](#176) |
|177 | [](#177) |
|178 | [](#178) |
|179 | [](#179) |
|180 | [](#180) |
|181 | [](#181) |
|182 | [](#182) |
|183 | [](#183) |
|184 | [](#184) |
|185 | [](#185) |
|186 | [](#186) |
|187 | [](#187) |
|188 | [](#188) |
|189 | [](#189) |
|190 | [](#190) |
|191 | [](#191) |
|192 | [](#192) |
|193 | [](#193) |
|194 | [](#194) |
|195 | [](#195) |
|196 | [](#196) |
|197 | [](#197) |
|198 | [](#198) |
|199 | [](#199) |
|200 | [](#200) |



<a name="questions"></a>

## ReactJS 

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**
  
1. ### <a name="1"></a> Was ist React und welche Probleme l√∂st es?

**React** ist eine **JavaScript-Bibliothek** f√ºr den Aufbau von **User Interfaces** (UI), entwickelt von Facebook (heute Meta). Sie konzentriert sich auf die **View-Schicht** (im MVC-Pattern) und l√∂st typische Probleme moderner Frontend-Entwicklung:

### Probleme, die React l√∂st

1. **Komplexit√§t bei dynamischen UIs**

   * Klassisches DOM-Manipulieren mit `document.querySelector` oder `innerHTML` ist fehleranf√§llig und schwer zu warten.
   * React nutzt das **Virtual DOM**, um √Ñnderungen effizient zu berechnen und nur die n√∂tigen Teile des echten DOM zu aktualisieren.

2. **Wiederverwendbarkeit von UI-Logik**

   * In Vanilla JS oder jQuery ist es schwierig, UI-Elemente als eigenst√§ndige, wiederverwendbare Bausteine zu organisieren.
   * React bietet **Komponenten** (Functions oder Classes), die UI + Logik kapseln.

3. **State-Management**

   * Ohne Framework muss man Zust√§nde (z. B. Eingaben, UI-√Ñnderungen) manuell im DOM nachverfolgen.
   * React bietet ein klares **State- und Props-Konzept**: Datenfluss von oben nach unten (Top-down Data Flow) und kontrollierte Zustandsverwaltung.

4. **Lesbarkeit & Wartbarkeit**

   * Mit **JSX** verbindet React deklarative Syntax mit JavaScript, wodurch UI-Struktur dem HTML √§hnelt, aber direkt in JS geschrieben wird.
   * Dadurch wird Code strukturierter, testbarer und besser wartbar.

---

### Beispiel

```jsx
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Aktueller Wert: {count}</p>
      <button onClick={() => setCount(count + 1)}>
        Erh√∂hen
      </button>
    </div>
  );
}

export default Counter;
```

* `useState` verwaltet den Zustand.
* Bei jedem Klick wird nur der relevante Teil des DOM aktualisiert.

---

### Zusammenfassung

* **React** = Bibliothek f√ºr deklarative UI-Entwicklung.
* L√∂st Probleme: ineffiziente DOM-Manipulation, fehlende Wiederverwendbarkeit, un√ºbersichtliches State-Handling.
* Schl√ºsselkonzepte: **Virtual DOM, Komponenten, State, Props, JSX**.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Grundlagen](https://react.dev/learn)
* [MDN ‚Äì Einf√ºhrung in das DOM](https://developer.mozilla.org/ru/docs/Web/API/Document_Object_Model/Introduction)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

2. ### <a name="2"></a> Was ist JSX und warum wird es verwendet?

**JSX (JavaScript XML)** ist eine **erweiterte Syntax f√ºr JavaScript**, die es erlaubt, UI-Strukturen in einer HTML-√§hnlichen Schreibweise direkt im JavaScript-Code zu definieren. JSX wird von **Babel** oder anderen Transpilern in reines JavaScript (meist `React.createElement`) √ºbersetzt.

---

### Warum wird JSX verwendet?

1. **Deklarative UI-Beschreibung**

   * UI-Struktur sieht aus wie HTML, ist aber vollst√§ndig in JavaScript eingebettet.
   * Entwicklern f√§llt es leichter, die Logik und das UI zusammen zu lesen und zu verstehen.

2. **Verkn√ºpfung von Logik und Darstellung**

   * Man kann JavaScript-Ausdr√ºcke direkt in JSX einbetten: `{...}`.
   * Bedingte Renderings oder Schleifen lassen sich elegant integrieren.

3. **Bessere Lesbarkeit & Wartbarkeit**

   * Statt verschachtelter `React.createElement`-Aufrufe ist JSX k√ºrzer, klarer und n√§her an HTML.

---

### Beispiel

```jsx
import { useState } from "react";

function Greeting() {
  const [name, setName] = useState("Sergii");

  return (
    <div>
      <h1>Hallo, {name}!</h1> {/* JS-Ausdruck in geschweiften Klammern */}
      <button onClick={() => setName("Frontend-Dev")}>
        √Ñndern
      </button>
    </div>
  );
}

export default Greeting;
```

Ohne JSX w√ºrde derselbe Code so aussehen:

```js
import { createElement, useState } from "react";

function Greeting() {
  const [name, setName] = useState("Sergii");

  return createElement(
    "div",
    null,
    createElement("h1", null, `Hallo, ${name}!`),
    createElement(
      "button",
      { onClick: () => setName("Frontend-Dev") },
      "√Ñndern"
    )
  );
}
```

---

### Zusammenfassung

* **JSX** = Syntax-Erweiterung f√ºr JavaScript, die UI-Strukturen wie HTML aussehen l√§sst.
* Vorteile: bessere Lesbarkeit, Integration von Logik + UI, effizienteres Arbeiten mit React.
* JSX wird in reines JavaScript transpiliert.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì JSX](https://react.dev/learn/writing-markup-with-jsx)
* [MDN ‚Äì JSX (Einf√ºhrung)](https://developer.mozilla.org/ru/docs/Glossary/JSX)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

3. ### <a name="3"></a> Was ist Virtual DOM und wie funktioniert es?

**Virtual DOM (VDOM)** ist eine **leichte, virtuelle Repr√§sentation** des echten DOM im Speicher. Es dient als Zwischenschicht, um √Ñnderungen effizient zu berechnen, bevor sie im **realen DOM** angewendet werden.

---

### Funktionsweise

1. **Rendern in den Virtual DOM**

   * Wenn sich State oder Props √§ndern, erzeugt React ein **neues Virtual DOM**-Baumobjekt.

2. **Diffing-Algorithmus**

   * React vergleicht den neuen VDOM mit der vorherigen Version (Reconciliation).
   * Nur die Unterschiede (‚Äûdiff‚Äú) werden ermittelt.

3. **Minimaler Update im echten DOM**

   * React aktualisiert nur die tats√§chlich ver√§nderten Teile im **realen DOM**.
   * Dadurch sind Updates wesentlich effizienter, da direkte DOM-Manipulationen sehr teuer sind.

---

### Beispiel

```jsx
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Z√§hler: {count}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
    </div>
  );
}

export default Counter;
```

* Bei `setCount` erstellt React ein neues Virtual DOM.
* React erkennt, dass nur `<p>` sich ge√§ndert hat.
* Nur dieser Knoten im echten DOM wird neu gerendert, **nicht die gesamte Seite**.

---

### Zusammenfassung

* **Virtual DOM** = virtuelles Abbild des echten DOM.
* Ablauf: **neuer VDOM ‚Üí Diffing ‚Üí minimaler DOM-Update**.
* Vorteil: Performance, klare Trennung von Logik und DOM-Manipulation.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Reconciliation](https://react.dev/learn/render-and-commit#step-2-react-renders-your-components)
* [MDN ‚Äì DOM Einf√ºhrung](https://developer.mozilla.org/ru/docs/Web/API/Document_Object_Model/Introduction)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

4. ### <a name="4"></a> Was ist der Unterschied zwischen React und ReactDOM?

**React** ist die **Kernbibliothek**, die Werkzeuge f√ºr das **Erstellen von Komponenten, State-Management, Hooks und JSX-Verarbeitung** bereitstellt.
**ReactDOM** ist das **Rendering-Paket**, das React-Komponenten mit dem **echten DOM im Browser** verbindet.

---

### Details

1. **React**

   * Definiert, **wie** UI-Komponenten aussehen und funktionieren.
   * Enth√§lt Hooks wie `useState`, `useEffect`.
   * Ist plattformunabh√§ngig (kann auch mit React Native, ReactDOM, ReactVR genutzt werden).

2. **ReactDOM**

   * Speziell f√ºr **Web-Umgebungen** gedacht.
   * Stellt Funktionen wie `createRoot` oder `render` bereit, um React-Komponenten in den Browser zu mounten.
   * Trennt die Logik von der konkreten Rendering-Umgebung (Browser-DOM).

---

### Beispiel

```jsx
// index.jsx
import React from "react";
import { createRoot } from "react-dom/client";
import App from "./App.jsx";

const root = createRoot(document.getElementById("root"));
root.render(<App />);
```

* `React` stellt die Komponente `App` bereit.
* `ReactDOM` sorgt daf√ºr, dass diese Komponente im `<div id="root">` im Browser angezeigt wird.

---

### Zusammenfassung

* **React** = Kernbibliothek (Komponenten, State, Hooks).
* **ReactDOM** = Bindeglied zum echten Browser-DOM (Mounting, Rendering).
* Trennung erm√∂glicht, React auch au√üerhalb des Browsers (z. B. mit React Native) zu verwenden.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Einstieg](https://react.dev/learn)
* [ReactDOM API ‚Äì Offizielle Docs](https://react.dev/reference/react-dom)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

5. ### <a name="5"></a> Warum importieren wir React, auch wenn es scheinbar nicht benutzt wird?

Fr√ºher musste man in jeder Datei mit JSX immer **`import React from "react";`** schreiben, auch wenn React im Code nicht direkt benutzt wurde.
Grund: **JSX wird von Babel in `React.createElement`-Aufrufe umgewandelt**, daher war `React` im Scope notwendig.

Seit **React 17 (2020)** wurde das durch die **neue JSX-Transform** ge√§ndert:

* Der Compiler f√ºgt die n√∂tigen Funktionen automatisch hinzu.
* Deshalb muss man `import React` nicht mehr explizit einf√ºgen, wenn man nur JSX nutzt.
* In √§lteren Projekten oder Setups ohne neue Transform ist der Import weiterhin Pflicht.

---

### Beispiel ‚Äì Babel-Umwandlung

**JSX-Eingabe:**

```jsx
const element = <h1>Hallo Welt</h1>;
```

**Transpilierte Ausgabe (vor React 17):**

```js
import React from "react";

const element = React.createElement("h1", null, "Hallo Welt");
```

**Transpilierte Ausgabe (ab React 17 mit neuer JSX-Transform):**

```js
import { jsx as _jsx } from "react/jsx-runtime";

const element = _jsx("h1", { children: "Hallo Welt" });
```

---

### Zusammenfassung

* Fr√ºher: `import React` war n√∂tig, weil JSX ‚Üí `React.createElement` kompiliert wurde.
* Heute (React 17+): Dank neuer JSX-Transform meist **nicht mehr notwendig**.
* Import wird nur gebraucht, wenn man `React` direkt nutzt (z. B. `React.Children`, `React.cloneElement`).

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Neue JSX-Transform](https://react.dev/blog/2020/09/22/introducing-the-new-jsx-transform)
* [MDN ‚Äì JSX](https://developer.mozilla.org/ru/docs/Glossary/JSX)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

6. ### <a name="6"></a> Was ist ein React Fragment und warum ist es n√ºtzlich?

**React Fragment** ist ein spezieller Wrapper (`<React.Fragment>` oder Kurzschreibweise `<>...</>`), mit dem man **mehrere Elemente gruppieren** kann, **ohne zus√§tzliches DOM-Element** (wie `<div>`) zu erzeugen.

---

### Warum n√ºtzlich?

1. **Kein unn√∂tiges DOM-Markup**

   * `<div>`-Wrapper erzeugen oft ‚Äûdiv soup‚Äú und machen das DOM un√ºbersichtlich.
   * Fragmente f√ºgen nichts ins echte DOM ein.

2. **Mehrere Elemente zur√ºckgeben**

   * Eine React-Komponente darf nur **ein einziges Root-Element** zur√ºckgeben.
   * Mit Fragmenten kann man mehrere Geschwister-Elemente zur√ºckgeben.

3. **Performance & Semantik**

   * Weniger DOM-Knoten ‚Üí bessere Performance.
   * Bessere Semantik, da unn√∂tige Container-Elemente vermieden werden.

---

### Beispiel

```jsx
import React from "react";

function UserInfo() {
  return (
    <>
      <h2>Benutzername: Sergii</h2>
      <p>Rolle: Frontend-Entwickler</p>
    </>
  );
}

export default UserInfo;
```

Ohne Fragment m√ºsste man alles in ein `<div>` packen:

```jsx
function UserInfo() {
  return (
    <div>
      <h2>Benutzername: Sergii</h2>
      <p>Rolle: Frontend-Entwickler</p>
    </div>
  );
}
```

Ergebnis im DOM:

* Mit Fragment ‚Üí nur `<h2>` und `<p>`.
* Mit `<div>` ‚Üí unn√∂tiger zus√§tzlicher Container.

---

### Zusammenfassung

* **React Fragment** gruppiert mehrere Elemente ohne zus√§tzliches DOM-Tag.
* Vorteile: sauberes DOM, bessere Semantik, kein ‚Äûdiv soup‚Äú.
* Schreibweisen: `<React.Fragment>...</React.Fragment>` oder `<>...</>`.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Fragments](https://react.dev/reference/react/Fragment)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

7. ### <a name="7"></a> Was ist der Unterschied zwischen einem Element, einer Komponente und einer Instanz?

### Unterschied: Element, Komponente, Instanz

1. **React Element**

   * Ein **leichtes, unver√§nderliches Objekt**, das beschreibt, **was im UI gerendert werden soll**.
   * Wird von JSX erzeugt und dient React als Bauplan.
   * Beispiel:

   ```jsx
   const element = <h1>Hallo</h1>; // React Element
   ```

2. **React Komponente**

   * Eine **Funktion oder Klasse**, die React Elements zur√ºckgibt.
   * Definiert **wie UI-Elemente aufgebaut sind** (Logik + Struktur).
   * Beispiel:

   ```jsx
   function Greeting() {
     return <h1>Hallo Sergii</h1>;
   }
   ```

3. **Instanz einer Komponente**

   * Entsteht, wenn React eine Komponente **rendert** und im UI einsetzt.
   * Jede Verwendung von `<Greeting />` erzeugt eine neue Instanz dieser Komponente.
   * Beispiel:

   ```jsx
   function App() {
     return (
       <>
         <Greeting />   {/* Instanz 1 */}
         <Greeting />   {/* Instanz 2 */}
       </>
     );
   }
   ```

---

### Bildhafte Erkl√§rung

* **Element** = Bauplan/Zwischenschicht (JSX-Output).
* **Komponente** = Definition (Funktion/Klasse).
* **Instanz** = konkrete Auspr√§gung der Komponente im DOM.

---

### Zusammenfassung

* **Element**: unver√§nderliches Objekt, beschreibt UI.
* **Komponente**: Funktion/Klasse, die Elemente zur√ºckgibt.
* **Instanz**: konkrete gerenderte Erscheinung einer Komponente.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Rendering Elements](https://react.dev/learn/render-and-commit)
* [MDN ‚Äì Komponenten-Definition](https://developer.mozilla.org/ru/docs/Glossary/Component)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

8. ### <a name="8"></a> Was ist das Fiber-Architekturmodell in React?

### Fiber-Architekturmodell in React

**React Fiber** ist die **neue Rendering-Engine** von React (seit v16), die das alte ‚ÄûStack Reconciler‚Äú-Modell ersetzt. Ziel: **flexible, unterbrechbare Updates** im UI.

---

### Hauptideen

1. **Unterbrechbare Renderings**

   * Gro√üe UI-Updates k√∂nnen in **kleine Arbeitseinheiten** zerlegt werden.
   * React kann Rendering pausieren, priorisieren oder abbrechen, wenn wichtigere Aufgaben (z. B. User-Input) eintreffen.

2. **Priorisierung von Updates**

   * Updates erhalten eine **Priorit√§t** (z. B. Animation > Datenladen).
   * Dadurch bleibt die UI reaktionsschnell.

3. **Inkremetelles Rendern**

   * Statt den ganzen Baum auf einmal zu rendern, wird er St√ºck f√ºr St√ºck (fiberweise) bearbeitet.

---

### Aufbau

* **Fiber Node**: interner Datenknoten, der eine **Einheit der Arbeit** repr√§sentiert (z. B. eine Komponente oder ein DOM-Element).
* Jeder Fiber enth√§lt Infos wie: Typ der Komponente, Props, State, Nebenwirkungen.

---

### Beispiel (vereinfacht gedacht)

```jsx
function App() {
  return (
    <>
      <Header />
      <Content />
      <Footer />
    </>
  );
}
```

* F√ºr `Header`, `Content`, `Footer` erstellt React einzelne **Fiber-Nodes**.
* React arbeitet diese nacheinander ab, kann aber z. B. `Footer` sp√§ter fertigstellen, wenn ein **User-Klick** sofort verarbeitet werden muss.

---

### Zusammenfassung

* **Fiber** = Reacts Rendering-Engine ab v16.
* Vorteile: unterbrechbare, priorisierte und inkrementelle Renderings.
* Kernziel: **bessere Performance & User Experience** bei komplexen UIs.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Render and Commit](https://react.dev/learn/render-and-commit)
* [React Blog ‚Äì Fiber Architecture](https://reactjs.org/docs/faq-internals.html#what-is-react-fiber)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

9. ### <a name="9"></a> Was bedeutet ‚ÄûBatching‚Äú in React?

### Batching in React

**Batching** bedeutet, dass React mehrere **State-Updates** zusammenfasst und in **einem einzigen Re-Render** ausf√ºhrt, anstatt nach jedem Update sofort zu rendern. Das reduziert unn√∂tige DOM-Updates und verbessert die Performance.

---

### Details

* Standardm√§√üig werden in **Event-Handlern** (z. B. `onClick`) mehrere `setState`-Aufrufe geb√ºndelt.
* Seit **React 18** gilt ‚ÄûAutomatic Batching‚Äú auch f√ºr **Promises, setTimeout, native Events** usw.
* Ohne Batching w√ºrde jede State-√Ñnderung einzeln ein Re-Render ausl√∂sen.

---

### Beispiel

```jsx
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);
  const [text, setText] = useState("");

  function handleClick() {
    setCount(c => c + 1);
    setText("Aktualisiert");
    // Beide Updates werden in EINEM Re-Render geb√ºndelt (Batching)
  }

  return (
    <>
      <p>{count} - {text}</p>
      <button onClick={handleClick}>Update</button>
    </>
  );
}

export default Counter;
```

---

### Zusammenfassung

* **Batching** = mehrere State-Updates ‚Üí ein Re-Render.
* Vorteil: weniger DOM-Updates, bessere Performance.
* Seit React 18: **automatisches Batching √ºberall**, nicht nur in Event-Handlern.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì State Updates Batching](https://react.dev/learn/queueing-a-series-of-state-updates#batching-of-state-updates)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

10. ### <a name="10"></a> Was ist die Rolle des key in React-Listen?

### Rolle des `key` in React-Listen

**`key`** ist ein spezielles Attribut in React, das jeder Listenkomponente zugewiesen wird, um sie **eindeutig zu identifizieren**. Es hilft React beim **Diffing-Prozess** (Vergleich von altem und neuem Virtual DOM), effizient zu erkennen, welche Elemente ge√§ndert, hinzugef√ºgt oder entfernt wurden.

---

### Warum wichtig?

1. **Performance**: React muss nicht die ganze Liste neu rendern, sondern nur die betroffenen Elemente.
2. **Stabilit√§t**: `key` sorgt daf√ºr, dass Komponenteninstanzen korrekt erhalten bleiben (z. B. State in Formularfeldern).
3. **Vorhersehbarkeit**: Ohne eindeutigen Key kann es zu unerwarteten UI-Effekten kommen.

---

### Beispiel

```jsx
const users = ["Anna", "Max", "Sergii"];

function UserList() {
  return (
    <ul>
      {users.map(user => (
        <li key={user}>{user}</li> // key = eindeutiger Identifier
      ))}
    </ul>
  );
}

export default UserList;
```

**Falsch (z. B. Index als Key, nur wenn Daten wirklich stabil sind):**

```jsx
<li key={index}>{user}</li>
```

‚Üí Problematisch, wenn Elemente umsortiert oder gel√∂scht werden.

---

### Zusammenfassung

* **`key`** identifiziert Listenelemente eindeutig.
* Hilft React beim effizienten Re-Rendern und verhindert UI-Fehler.
* Best Practice: stabile, eindeutige IDs nutzen, **nicht** Array-Index.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Schl√ºssel (Keys)](https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

11. ### <a name="11"></a> Wie funktioniert die Wiederverwendung von Komponenten?

### Wiederverwendung von Komponenten in React

**Wiederverwendbarkeit** bedeutet, dass eine Komponente mehrfach in unterschiedlichen Kontexten eingesetzt werden kann, ohne ihren Code zu duplizieren. React erreicht dies durch **Props, Komposition und Children**.

---

### Hauptmechanismen

1. **Props**

   * Komponenten k√∂nnen konfigurierbar gemacht werden, indem man ihnen Daten √ºbergibt.

   ```jsx
   function Button({ label, color }) {
     return <button style={{ background: color }}>{label}</button>;
   }

   export default function App() {
     return (
       <>
         <Button label="Speichern" color="green" />
         <Button label="L√∂schen" color="red" />
       </>
     );
   }
   ```

   ‚Üí Gleiche Komponente, unterschiedliche Darstellung durch Props.

2. **Komposition**

   * Komponenten k√∂nnen andere Komponenten enthalten oder kombinieren.

   ```jsx
   function Card({ children }) {
     return <div className="card">{children}</div>;
   }

   function App() {
     return (
       <Card>
         <h2>Titel</h2>
         <p>Inhalt</p>
       </Card>
     );
   }
   ```

   ‚Üí Card ist wiederverwendbar als Container f√ºr beliebigen Inhalt.

3. **Children & Higher-Order-Komponenten / Render Props**

   * Muster, um Verhalten und Layout flexibel wiederzuverwenden.

---

### Zusammenfassung

* Wiederverwendbarkeit in React basiert auf **Props, Komposition und Children**.
* Eine Komponente kann mehrfach in verschiedenen Kontexten mit unterschiedlicher Konfiguration genutzt werden.
* Ziel: **DRY-Prinzip** (Don‚Äôt Repeat Yourself) und saubere Architektur.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Komposition vs. Vererbung](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

12. ### <a name="12"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

13. ### <a name="13"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

14. ### <a name="14"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

15. ### <a name="15"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

16. ### <a name="16"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

17. ### <a name="17"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

18. ### <a name="18"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

19. ### <a name="19"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

20. ### <a name="20"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

21. ### <a name="21"></a> Was sind Props und wozu werden sie verwendet?

### Props in React

**Props (Properties)** sind **Eingabeparameter**, die von einer Elternkomponente an eine Kindkomponente √ºbergeben werden. Sie machen Komponenten **dynamisch, wiederverwendbar und konfigurierbar**.

---

### Eigenschaften von Props

1. **Read-only** ‚Äì Props k√∂nnen innerhalb der Kindkomponente **nicht ver√§ndert** werden.
2. **Datenfluss** ‚Äì Props folgen dem **Top-down Data Flow** (von Eltern zu Kindern).
3. **Flexibilit√§t** ‚Äì erlauben es, dasselbe UI-Element mit unterschiedlichen Werten zu nutzen.

---

### Beispiel

```jsx
function Greeting({ name }) {
  return <h1>Hallo, {name}!</h1>;
}

function App() {
  return (
    <>
      <Greeting name="Sergii" />
      <Greeting name="Anna" />
    </>
  );
}

export default App;
```

* `Greeting` ist wiederverwendbar.
* `name` wird als Prop √ºbergeben und individuell gerendert.

---

### Zusammenfassung

* **Props** = unver√§nderliche Eingabeparameter f√ºr Komponenten.
* Nutzen: Datenweitergabe, Wiederverwendbarkeit, dynamisches Rendering.
* Props sind **nur lesbar** und werden von Eltern an Kinder √ºbergeben.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Props](https://react.dev/learn/passing-props-to-a-component)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

22. ### <a name="22"></a> Was ist der Unterschied zwischen Props und State?

### Unterschied zwischen **Props** und **State**

1. **Props**

   * Eingabeparameter, die eine Komponente von au√üen (Elternkomponente) erh√§lt.
   * **Unver√§nderlich** innerhalb der Kindkomponente (read-only).
   * Dienen zur **Datenweitergabe** und **Konfiguration**.

2. **State**

   * Interner Zustand einer Komponente, der sich √ºber die Zeit √§ndern kann.
   * Wird mit Hooks wie `useState` verwaltet.
   * √Ñnderungen am State l√∂sen ein **Re-Render** der Komponente aus.

---

### Beispiel

```jsx
import { useState } from "react";

function Counter({ initial }) {   // Prop
  const [count, setCount] = useState(initial); // State

  return (
    <>
      <p>Z√§hler: {count}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
    </>
  );
}

export default function App() {
  return <Counter initial={5} />; // √úbergabe per Prop
}
```

* `initial` = **Prop**, von au√üen √ºbergeben, nicht ver√§nderbar.
* `count` = **State**, geh√∂rt zur Komponente selbst und wird durch User-Interaktion ver√§ndert.

---

### Zusammenfassung

* **Props**: von au√üen, unver√§nderlich, konfigurieren Komponenten.
* **State**: intern, ver√§nderlich, speichert dynamische Daten.
* Zusammenspiel: Props geben Startwerte, State steuert dynamisches Verhalten.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Props vs State](https://react.dev/learn/state-a-components-memory)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

23. ### <a name="23"></a> Warum sind Props nur lesbar?

### Warum Props nur lesbar sind

1. **Eindirektionaler Datenfluss (Top-down Data Flow)**

   * React erzwingt, dass Daten **nur von Eltern zu Kindern** flie√üen.
   * Dadurch bleibt der Datenfluss vorhersehbar und leicht nachvollziehbar.

2. **Unver√§nderlichkeit**

   * Props sind **read-only**, weil sie von au√üen (Elternkomponente) kontrolliert werden.
   * W√ºrden Kinder Props ver√§ndern, k√∂nnte es zu **Inkonsistenzen und schwer nachvollziehbaren Fehlern** kommen.

3. **Wartbarkeit & Debugging**

   * Wenn nur die Eltern Daten √§ndern d√ºrfen, ist klar definiert, **wo Daten herkommen** und **wer sie ver√§ndert**.
   * Das erh√∂ht die Stabilit√§t gro√üer Anwendungen.

---

### Beispiel

```jsx
function Greeting({ name }) {
  // name = Prop, nicht ver√§nderbar
  return <h1>Hallo, {name}</h1>;
}

function App() {
  return <Greeting name="Sergii" />;
}
```

* `Greeting` darf `name` **nicht √ºberschreiben**.
* √Ñnderungen am Wert m√ºssen in der Elternkomponente erfolgen.

---

### Zusammenfassung

* **Props sind nur lesbar**, weil React einen klaren, eindirektionalen Datenfluss erzwingt.
* Eltern kontrollieren die Daten, Kinder konsumieren sie.
* Ergebnis: **Vorhersehbarkeit, Stabilit√§t und einfacheres Debugging**.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Props](https://react.dev/learn/passing-props-to-a-component)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

24. ### <a name="24"></a> Wie funktioniert der unidirektionale Datenfluss in React?

### Unidirektionaler Datenfluss in React

React folgt strikt dem Prinzip des **Top-down Data Flow**:

* **Elternkomponenten** geben Daten √ºber **Props** an ihre **Kindkomponenten** weiter.
* Daten flie√üen **nur in eine Richtung** (von oben nach unten).
* Kindkomponenten k√∂nnen Daten nicht direkt zur√ºckgeben, sondern nur √ºber **Callbacks/Events** √Ñnderungen an die Eltern melden.

---

### Beispiel

```jsx
import { useState } from "react";

function Child({ value, onChange }) {
  return (
    <>
      <p>Aktueller Wert: {value}</p>
      <button onClick={() => onChange(value + 1)}>+1</button>
    </>
  );
}

function Parent() {
  const [count, setCount] = useState(0);

  return <Child value={count} onChange={setCount} />;
}

export default Parent;
```

* `Parent` besitzt den **State**.
* `Child` erh√§lt `value` und `onChange` als **Props**.
* √Ñnderungen flie√üen **√ºber ein Callback** zur√ºck zur Elternkomponente.

---

### Vorteile

1. **Vorhersehbarkeit**: Es ist klar, wo Daten liegen und wie sie sich √§ndern.
2. **Wartbarkeit**: Einfacher zu debuggen, da Daten nur an einer Stelle gepflegt werden.
3. **Stabilit√§t**: Keine unkontrollierten Seiteneffekte durch bidirektionalen Fluss.

---

### Zusammenfassung

* **Unidirektionaler Datenfluss** = Daten von Eltern ‚Üí Kinder (via Props).
* Kinder melden √Ñnderungen durch **Events/Callbacks** zur√ºck.
* Ergebnis: **klare Struktur, bessere Wartbarkeit, weniger Fehler**.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Datenfluss](https://react.dev/learn/passing-props-to-a-component#how-props-flow-through-components)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

25. ### <a name="25"></a> Was ist State in Klassen- und Funktionskomponenten?

### State in React

1. **State in Klassenkomponenten**

   * Wird in einer Klasse als Objekt definiert.
   * Zugriff √ºber `this.state`, √Ñnderungen mit `this.setState()`.

   ```jsx
   import React, { Component } from "react";

   class Counter extends Component {
     constructor(props) {
       super(props);
       this.state = { count: 0 }; // State-Objekt
     }

     render() {
       return (
         <>
           <p>Z√§hler: {this.state.count}</p>
           <button onClick={() => this.setState({ count: this.state.count + 1 })}>
             +1
           </button>
         </>
       );
     }
   }

   export default Counter;
   ```

   * `this.setState()` f√ºhrt **asynchrone Updates** aus und triggert ein Re-Render.

---

2. **State in Funktionskomponenten**

   * Ab React 16.8 mit **Hooks** m√∂glich (`useState`).
   * State ist kein Objekt mehr, sondern ein beliebiger Wert (Primitive oder Objekt).

   ```jsx
   import { useState } from "react";

   function Counter() {
     const [count, setCount] = useState(0); // State-Hook

     return (
       <>
         <p>Z√§hler: {count}</p>
         <button onClick={() => setCount(count + 1)}>+1</button>
       </>
     );
   }

   export default Counter;
   ```

   * `useState` gibt ein Array `[state, updater]` zur√ºck.
   * Updates sind deklarativ und l√∂sen ein Re-Render aus.

---

### Vergleich

| Klassenkomponente              | Funktionskomponente       |
| ------------------------------ | ------------------------- |
| `this.state = { ... }`         | `const [value, setValue]` |
| √Ñnderung mit `this.setState()` | √Ñnderung mit Setter       |
| OOP-Stil                       | Funktional, Hooks         |

---

### Zusammenfassung

* **State = interner Speicher** einer Komponente, der sich √ºber die Zeit √§ndern kann.
* In **Klassen**: Objekt mit `this.state` + Updates via `setState()`.
* In **Funktionen**: `useState`-Hook mit Wert + Setter.
* √Ñnderungen triggern ein **Re-Render** der Komponente.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì State und Lifecycle](https://react.dev/learn/state-a-components-memory)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

26. ### <a name="26"></a> Wie funktioniert setState?

### Funktionsweise von `setState` in React

1. **In Klassenkomponenten**

   * `setState()` ist die Methode zum Aktualisieren des internen **State-Objekts**.
   * Updates sind **asynchron** und werden oft zusammengefasst (**Batching**).
   * `setState` kann ein **Objekt** oder eine **Funktion** akzeptieren.

   ```jsx
   this.setState({ count: this.state.count + 1 }); // Objektform
   this.setState(prev => ({ count: prev.count + 1 })); // Funktionsform (empfohlen)
   ```

2. **In Funktionskomponenten** (`useState`)

   * `setState` ist der **Updater**, den React vom Hook zur√ºckgibt.
   * √úberschreibt den alten Wert durch einen neuen.
   * Akzeptiert direkt einen Wert oder eine Funktion basierend auf dem vorherigen Wert.

   ```jsx
   const [count, setCount] = useState(0);

   setCount(count + 1);          // Wert
   setCount(prev => prev + 1);   // Funktionsform (empfohlen bei Abh√§ngigkeit vom alten Wert)
   ```

---

### Wichtige Eigenschaften

* **Asynchron**: Mehrere Aufrufe von `setState` k√∂nnen gebatcht werden.
* **Re-Render**: Jede √Ñnderung l√∂st ein erneutes Rendern der Komponente aus.
* **Funktionsform** wird bevorzugt, wenn der neue Wert vom alten abh√§ngt.

---

### Zusammenfassung

* `setState` aktualisiert den State und l√∂st ein Re-Render aus.
* In **Klassenkomponenten**: Methode mit Objekt/Funktion.
* In **Funktionskomponenten**: Setter vom `useState`-Hook.
* Updates sind **asynchron** und werden **geb√ºndelt**.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì setState](https://react.dev/reference/react/useState#updating-state-based-on-the-previous-state)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

27. ### <a name="27"></a> Was ist der Unterschied zwischen kontrollierten und unkontrollierten Komponenten?

### Unterschied: Kontrollierte vs. Unkontrollierte Komponenten

1. **Kontrollierte Komponenten**

   * Der **State der Eingabeelemente** (z. B. `input`, `textarea`, `select`) wird in React verwaltet.
   * Der Wert kommt aus dem **State** der Komponente, √Ñnderungen laufen √ºber ein Event-Handler.
   * React = **Single Source of Truth**.

   ```jsx
   import { useState } from "react";

   function ControlledInput() {
     const [value, setValue] = useState("");

     return (
       <input
         value={value} // State bestimmt den Wert
         onChange={e => setValue(e.target.value)} // React kontrolliert
       />
     );
   }
   ```

---

2. **Unkontrollierte Komponenten**

   * Der Wert wird direkt vom **DOM selbst** verwaltet.
   * Zugriff √ºber **Refs** anstatt √ºber State.
   * React kontrolliert den Wert **nicht kontinuierlich**.

   ```jsx
   import { useRef } from "react";

   function UncontrolledInput() {
     const inputRef = useRef();

     const handleClick = () => {
       alert(inputRef.current.value); // Wert direkt aus DOM
     };

     return (
       <>
         <input ref={inputRef} />
         <button onClick={handleClick}>Zeig Wert</button>
       </>
     );
   }
   ```

---

### Vergleich

| Kontrolliert                         | Unkontrolliert                           |
| ------------------------------------ | ---------------------------------------- |
| React verwaltet den Wert (State)     | DOM verwaltet den Wert                   |
| `value` + `onChange`                 | Zugriff via `ref`                        |
| Besser f√ºr Validierung & komplexe UI | Einfacher f√ºr schnelle, kleine Formulare |

---

### Zusammenfassung

* **Kontrollierte Komponenten**: Wert = State in React, √Ñnderungen laufen √ºber Events ‚Üí **voller React-Kontrolle**.
* **Unkontrollierte Komponenten**: Wert = DOM, Zugriff √ºber Ref ‚Üí **schneller, aber weniger flexibel**.
* Best Practice: Kontrollierte Komponenten f√ºr gr√∂√üere UIs, unkontrollierte f√ºr einfache F√§lle.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Forms](https://react.dev/learn/sharing-state-between-components#controlled-and-uncontrolled-components)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

28. ### <a name="28"></a> Was sind Default Props und PropTypes?

### Default Props

* Mit **Default Props** kann man Standardwerte f√ºr Props definieren, falls der Elternkomponente kein Wert √ºbergeben wird.
* Praktisch, um **Fallback-Werte** sicherzustellen.

```jsx
function Button({ label }) {
  return <button>{label}</button>;
}

// Standardwert, falls `label` nicht √ºbergeben wird
Button.defaultProps = {
  label: "Klicken"
};

export default Button;
```

‚Üí In modernen React-Versionen (17+) werden Default Props f√ºr **Funktionskomponenten** weniger genutzt, stattdessen oft **Default-Parameter**:

```jsx
function Button({ label = "Klicken" }) {
  return <button>{label}</button>;
}
```

---

### PropTypes

* **PropTypes** ist ein Typpr√ºfungssystem f√ºr Props zur **Laufzeit**.
* Hilft, Fehler fr√ºh zu erkennen, indem √ºberpr√ºft wird, ob Props den erwarteten Typ haben.

```jsx
import PropTypes from "prop-types";

function User({ name, age }) {
  return <p>{name} ist {age} Jahre alt</p>;
}

User.propTypes = {
  name: PropTypes.string.isRequired,
  age: PropTypes.number
};
```

* Wird ein falscher Typ √ºbergeben, zeigt React im **Konsolen-Log eine Warnung**.

---

### Zusammenfassung

* **Default Props**: legen Standardwerte fest, wenn keine Props √ºbergeben werden.
* **PropTypes**: pr√ºfen Props-Typen **zur Laufzeit** und helfen bei der Fehlervermeidung.
* Heute oft ersetzt durch **TypeScript** f√ºr statische Typisierung.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Typpr√ºfung](https://react.dev/reference/react/Component#static-defaultprops)
* [PropTypes auf npm](https://www.npmjs.com/package/prop-types)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

29. ### <a name="29"></a> Was ist React.memo und wof√ºr wird es verwendet?

### React.memo

**`React.memo`** ist eine **Higher-Order-Komponente (HOC)**, die Funktionskomponenten **memoisiert**.
Das bedeutet: Eine Komponente wird **nur neu gerendert, wenn sich ihre Props √§ndern**.

---

### Wof√ºr wird es verwendet?

1. **Performance-Optimierung**

   * Verhindert unn√∂tige Re-Renders bei unver√§nderten Props.
   * Besonders sinnvoll bei **teuren Berechnungen** oder **gro√üen Listen**.

2. **Vergleich der Props**

   * Standardm√§√üig nutzt React einen **shallow comparison** (flacher Vergleich).
   * F√ºr komplexe Objekte kann man eine eigene Vergleichsfunktion √ºbergeben.

---

### Beispiel

```jsx
import React, { useState } from "react";

const Child = React.memo(function Child({ value }) {
  console.log("Render:", value);
  return <p>Wert: {value}</p>;
});

export default function App() {
  const [count, setCount] = useState(0);
  const [text, setText] = useState("");

  return (
    <>
      <Child value={count} />
      <button onClick={() => setCount(count + 1)}>+1</button>
      <input value={text} onChange={e => setText(e.target.value)} />
    </>
  );
}
```

* `Child` rendert nur neu, wenn sich `value` √§ndert.
* √Ñnderungen an `text` haben **keinen Einfluss** auf `Child`.

---

### Zusammenfassung

* **`React.memo`** = Memoization f√ºr Funktionskomponenten.
* Verhindert unn√∂tige Re-Renders, wenn Props unver√§ndert bleiben.
* Standard: **shallow comparison**, optional eigene Vergleichsfunktion.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì React.memo](https://react.dev/reference/react/memo)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

30. ### <a name="30"></a> Was ist PureComponent und wie unterscheidet es sich von Component?

### PureComponent vs. Component

1. **`React.Component`**

   * Basis-Klasse f√ºr Klassenkomponenten.
   * F√ºhrt bei jedem `setState` oder neuen Props ein Re-Render durch, auch wenn sich die Werte nicht tats√§chlich ge√§ndert haben.

2. **`React.PureComponent`**

   * Erweiterung von `Component`.
   * F√ºhrt **automatisch einen shallow comparison** (flachen Vergleich) von Props und State durch.
   * Rendert nur neu, wenn sich **wirklich etwas ge√§ndert hat**.

---

### Beispiel

```jsx
import React, { Component, PureComponent } from "react";

class NormalComponent extends Component {
  render() {
    console.log("NormalComponent gerendert");
    return <p>{this.props.value}</p>;
  }
}

class OptimizedComponent extends PureComponent {
  render() {
    console.log("PureComponent gerendert");
    return <p>{this.props.value}</p>;
  }
}
```

* `NormalComponent` rendert bei **jeder Aktualisierung**, auch wenn `value` gleich bleibt.
* `OptimizedComponent` rendert **nur, wenn sich `value` ge√§ndert hat**.

---

### Unterschiede im √úberblick

| **Component**                         | **PureComponent**                                 |
| ------------------------------------- | ------------------------------------------------- |
| Rendert immer bei Updates             | Rendert nur bei √Ñnderungen (shallow compare)      |
| Keine Optimierung                     | Eingebaute Performance-Optimierung                |
| Manuell `shouldComponentUpdate` n√∂tig | `shouldComponentUpdate` automatisch implementiert |

---

### Zusammenfassung

* **Component**: rendert immer neu bei Updates.
* **PureComponent**: optimiert, rendert nur bei tats√§chlichen √Ñnderungen (shallow compare).
* Ziel: **Performance-Optimierung** bei Klassenkomponenten.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì PureComponent](https://react.dev/reference/react/PureComponent)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

31. ### <a name="31"></a> Wann sollte shouldComponentUpdate verwendet werden?

### `shouldComponentUpdate` in React

**`shouldComponentUpdate(nextProps, nextState)`** ist eine Lifecycle-Methode in **Klassenkomponenten**, die bestimmt, ob ein Re-Render stattfinden soll.
Sie gibt **true** (neu rendern) oder **false** (kein Render) zur√ºck.

---

### Wann einsetzen?

1. **Performance-Optimierung**

   * Wenn eine Komponente sehr oft aktualisiert wird, aber die meisten Updates keine sichtbaren √Ñnderungen im UI verursachen.
   * Durch R√ºckgabe von `false` k√∂nnen unn√∂tige Re-Renders vermieden werden.

2. **Feinsteuerung**

   * Wenn der Standardvergleich von `PureComponent` (shallow compare) nicht ausreicht.
   * Beispiel: tiefe Objektstrukturen, die differenziert gepr√ºft werden m√ºssen.

---

### Beispiel

```jsx
import React, { Component } from "react";

class User extends Component {
  shouldComponentUpdate(nextProps) {
    // Nur neu rendern, wenn sich der Name ge√§ndert hat
    return nextProps.name !== this.props.name;
  }

  render() {
    console.log("Rendering:", this.props.name);
    return <p>{this.props.name}</p>;
  }
}

export default User;
```

---

### Zusammenfassung

* **`shouldComponentUpdate`** steuert, ob ein Re-Render notwendig ist.
* Sinnvoll bei **Performance-Optimierungen** und **kontrollierten Updates**.
* Heute oft ersetzt durch **PureComponent** oder **React.memo** in Funktionskomponenten.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì shouldComponentUpdate](https://react.dev/reference/react/Component#shouldcomponentupdate)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

32. ### <a name="32"></a> Was ist ein ref und wann wird er eingesetzt?

### Ref in React

Ein **ref (reference)** ist ein spezielles Objekt in React, mit dem man direkt auf ein **DOM-Element** oder eine **Komponenteninstanz** zugreifen kann. Refs werden mit `useRef` (Funktionskomponenten) oder `React.createRef` (Klassenkomponenten) erstellt.

---

### Wann einsetzen?

1. **Direkter Zugriff auf DOM-Elemente**

   * Fokus setzen, Text selektieren, Scrollen steuern.

2. **Speichern von ver√§nderlichen Werten**

   * Werte zwischen Renders behalten, ohne ein Re-Render auszul√∂sen.

3. **Integration mit Drittbibliotheken**

   * z. B. Zugriff auf Canvas, Charts, Animationen.

---

### Beispiele

**Funktionskomponente mit `useRef`:**

```jsx
import { useRef } from "react";

function InputFocus() {
  const inputRef = useRef();

  const handleClick = () => {
    inputRef.current.focus(); // direkter DOM-Zugriff
  };

  return (
    <>
      <input ref={inputRef} type="text" />
      <button onClick={handleClick}>Fokus setzen</button>
    </>
  );
}

export default InputFocus;
```

**Persistente Werte ohne Re-Render:**

```jsx
import { useRef, useState } from "react";

function Timer() {
  const countRef = useRef(0);
  const [stateCount, setStateCount] = useState(0);

  const increment = () => {
    countRef.current += 1;      // kein Re-Render
    setStateCount(stateCount+1); // triggert Re-Render
  };

  return (
    <p>Ref: {countRef.current}, State: {stateCount}</p>
  );
}
```

---

### Zusammenfassung

* **Refs** = direkte Referenzen auf DOM-Elemente oder persistente Werte.
* Einsatz: Fokus, Scroll, Animationssteuerung, Integration mit Drittlibs, Werte speichern ohne Re-Render.
* Erstellung: `useRef` (Hooks), `createRef` (Klassen).

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Refs](https://react.dev/learn/referencing-values-with-refs)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

33. ### <a name="33"></a> Was bedeutet ‚ÄûLifting State Up‚Äú?

### Lifting State Up in React

**Lifting State Up** bedeutet, dass man den **State aus einer Kindkomponente in die gemeinsame Elternkomponente verlagert**, wenn mehrere Komponenten denselben Zustand ben√∂tigen.
So entsteht **eine gemeinsame Quelle der Wahrheit** (Single Source of Truth), und der Datenfluss bleibt **eindirektional**.

---

### Beispiel

```jsx
import { useState } from "react";

function TemperatureInput({ label, value, onChange }) {
  return (
    <>
      <label>{label}: </label>
      <input
        type="number"
        value={value}
        onChange={e => onChange(e.target.value)}
      />
    </>
  );
}

function Calculator() {
  const [temperature, setTemperature] = useState("");

  return (
    <>
      <TemperatureInput
        label="Celsius"
        value={temperature}
        onChange={setTemperature}
      />
      <TemperatureInput
        label="Fahrenheit"
        value={(temperature * 9) / 5 + 32}
        onChange={val => setTemperature(((val - 32) * 5) / 9)}
      />
    </>
  );
}

export default Calculator;
```

* Beide Inputs teilen sich denselben **State in der Elternkomponente**.
* √Ñnderungen an einem Feld werden sofort im anderen reflektiert.

---

### Zusammenfassung

* **Lifting State Up** = Verschieben von State in die **Elternkomponente**, um Daten zwischen Kindern zu synchronisieren.
* Vorteile: eine gemeinsame Wahrheit, konsistenter Datenfluss, bessere Wartbarkeit.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Lifting State Up](https://react.dev/learn/sharing-state-between-components#lifting-state-up)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

34. ### <a name="34"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

35. ### <a name="35"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

36. ### <a name="36"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

37. ### <a name="37"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

38. ### <a name="38"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

39. ### <a name="39"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

40. ### <a name="40"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

41. ### <a name="41"></a> Was sind die Phasen des Komponentenlebenszyklus?

### Phasen des Komponentenlebenszyklus (Class Components)

In React (bei **Klassenkomponenten**) besteht der **Lebenszyklus** einer Komponente aus drei Hauptphasen:

1. **Mounting (Einf√ºgen ins DOM)**

   * Methoden:

     * `constructor()`
     * `static getDerivedStateFromProps()`
     * `render()`
     * `componentDidMount()`

2. **Updating (Aktualisierung bei Props/State-√Ñnderungen)**

   * Methoden:

     * `static getDerivedStateFromProps()`
     * `shouldComponentUpdate()`
     * `render()`
     * `getSnapshotBeforeUpdate()`
     * `componentDidUpdate()`

3. **Unmounting (Entfernen aus dem DOM)**

   * Methode:

     * `componentWillUnmount()`

---

### Beispiel

```jsx
import React, { Component } from "react";

class Demo extends Component {
  constructor(props) {
    super(props);
    console.log("1. constructor");
    this.state = { count: 0 };
  }

  componentDidMount() {
    console.log("4. componentDidMount");
  }

  shouldComponentUpdate() {
    console.log("Update? -> true");
    return true;
  }

  componentDidUpdate() {
    console.log("componentDidUpdate");
  }

  componentWillUnmount() {
    console.log("componentWillUnmount");
  }

  render() {
    console.log("render()");
    return (
      <button onClick={() => this.setState({ count: this.state.count + 1 })}>
        {this.state.count}
      </button>
    );
  }
}

export default Demo;
```

---

### Vergleich zu Hooks

* **Mounting/Updating/Unmounting** wird heute meist mit **`useEffect`** in Funktionskomponenten abgebildet.

```jsx
import { useState, useEffect } from "react";

function Demo() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log("Mounting & Updating");
    return () => console.log("Unmounting");
  }, [count]);

  return <button onClick={() => setCount(count + 1)}>{count}</button>;
}
```

---

### Zusammenfassung

* Lebenszyklus hat drei Phasen: **Mounting, Updating, Unmounting**.
* Klassenkomponenten nutzen Methoden (`componentDidMount`, `componentDidUpdate`, `componentWillUnmount`).
* Funktionskomponenten verwenden stattdessen **Hooks (useEffect)**.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Lifecycle](https://react.dev/reference/react/Component)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

42. ### <a name="42"></a> Welche Lifecycle-Methoden gibt es in Klassenkomponenten?

### Lifecycle-Methoden in Klassenkomponenten

React-Klassenkomponenten haben verschiedene Lifecycle-Methoden, die in drei Phasen eingeteilt werden:

---

#### 1. **Mounting (Einf√ºgen ins DOM)**

* `constructor()` ‚Üí Initialisierung von State und Binding.
* `static getDerivedStateFromProps(props, state)` ‚Üí selten genutzt, synchronisiert State mit Props.
* `render()` ‚Üí gibt das JSX zur√ºck.
* `componentDidMount()` ‚Üí ausgef√ºhrt **nach dem ersten Render**, ideal f√ºr API-Calls oder DOM-Manipulation.

---

#### 2. **Updating (bei Props/State-√Ñnderungen)**

* `static getDerivedStateFromProps(props, state)` ‚Üí wird auch hier aufgerufen.
* `shouldComponentUpdate(nextProps, nextState)` ‚Üí entscheidet, ob Re-Render n√∂tig ist (Performance-Optimierung).
* `render()` ‚Üí erneutes Rendern der Komponente.
* `getSnapshotBeforeUpdate(prevProps, prevState)` ‚Üí Zugriff auf DOM vor dem Update.
* `componentDidUpdate(prevProps, prevState, snapshot)` ‚Üí nach dem Rendern, gut f√ºr Netzwerkaufrufe oder DOM-Updates.

---

#### 3. **Unmounting (Entfernen aus DOM)**

* `componentWillUnmount()` ‚Üí Aufr√§umarbeiten (Timer clearen, Event Listener entfernen).

---

#### 4. **Error Handling (seit React 16)**

* `static getDerivedStateFromError(error)` ‚Üí f√§ngt Fehler ab, bevor UI zusammenbricht.
* `componentDidCatch(error, info)` ‚Üí Logging von Fehlern.

---

### Zusammenfassung

* **Mounting**: `constructor`, `getDerivedStateFromProps`, `render`, `componentDidMount`.
* **Updating**: `getDerivedStateFromProps`, `shouldComponentUpdate`, `render`, `getSnapshotBeforeUpdate`, `componentDidUpdate`.
* **Unmounting**: `componentWillUnmount`.
* **Error Handling**: `getDerivedStateFromError`, `componentDidCatch`.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Component API](https://react.dev/reference/react/Component)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

43. ### <a name="43"></a> Welche Lifecycle-Methoden sind veraltet?

### Veraltete Lifecycle-Methoden in React

Einige Lifecycle-Methoden von **Klassenkomponenten** gelten seit **React 16.3** als **deprecated** (veraltet), weil sie oft zu **Fehlern und unerwartetem Verhalten** f√ºhrten.

---

### Veraltete Methoden

1. **`componentWillMount()`**

   * Wurde vor dem ersten Render ausgef√ºhrt.
   * Ersetzt durch: **`constructor`** oder **`componentDidMount`**.

2. **`componentWillReceiveProps(nextProps)`**

   * Wurde bei neuen Props aufgerufen.
   * Ersetzt durch: **`static getDerivedStateFromProps`** oder **`componentDidUpdate`**.

3. **`componentWillUpdate(nextProps, nextState)`**

   * Wurde vor einem Update aufgerufen.
   * Ersetzt durch: **`getSnapshotBeforeUpdate`** oder **`componentDidUpdate`**.

---

### UNSAFE_-Pr√§fix

Seit React 16.3 existieren diese Methoden noch, aber mit **`UNSAFE_`-Pr√§fix**, z. B.:

* `UNSAFE_componentWillMount`
* `UNSAFE_componentWillReceiveProps`
* `UNSAFE_componentWillUpdate`

---

### Zusammenfassung

* Veraltet: `componentWillMount`, `componentWillReceiveProps`, `componentWillUpdate`.
* Grund: sie verursachen **Side-Effects** im falschen Zeitpunkt.
* Alternative: **`getDerivedStateFromProps`, `componentDidMount`, `componentDidUpdate`, `getSnapshotBeforeUpdate`**.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì UNSAFE Lifecycle Methods](https://react.dev/reference/react/Component#unsafe_componentwillmount)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

44. ### <a name="44"></a> Wie kann man Lifecycle-Methoden mit Hooks ersetzen?

### Lifecycle-Methoden ‚Üí Hooks: 1:1-Ersatz und Patterns

| Klassen-Lifecycle                                             | Entsprechung mit Hooks (Funktionskomponenten)                                                                                | Hinweis                                                              |
| ------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------- |
| `constructor`                                                 | Initial-State via `useState(initial)`                                                                                        | Auch f√ºr Event-Handler-Binding nicht n√∂tig.                          |
| `componentDidMount`                                           | `useEffect(() => { /* init */ }, [])`                                                                                        | L√§uft nach dem ersten Render (commit).                               |
| `componentDidUpdate`                                          | `useEffect(() => { /* reagiert auf deps */ }, [deps])`                                                                       | L√§uft nach jedem Render, wenn `deps` sich √§ndern.                    |
| `componentWillUnmount`                                        | Cleanup-Funktion in `useEffect`: `return () => {/* cleanup */}`                                                              | Abmelden von Listenern, Timer clearen etc.                           |
| `shouldComponentUpdate`                                       | Strukturell: `React.memo(Component)`; feingranular: `useMemo`, `useCallback`                                                 | Verhindert unn√∂tige Re-Renders.                                      |
| `getDerivedStateFromProps`                                    | Meist **vermeiden**. Alternativen: ableiten im Render, `useMemo` f√ºr teure Ableitungen, oder `useEffect` zum Synchronisieren | Props nicht in State duplizieren, wenn m√∂glich.                      |
| `getSnapshotBeforeUpdate` ‚Üí `componentDidUpdate`              | `useLayoutEffect` + `useRef` f√ºr **Layout-Messungen** vor dem Paint; Vor-/Nachwerte per Ref speichern                        | `useLayoutEffect` l√§uft synchron nach DOM-Mutationen, vor dem Paint. |
| Fehlergrenzen: `getDerivedStateFromError`/`componentDidCatch` | **Kein Hook-√Ñquivalent**. Error Boundaries weiterhin als **Klassenkomponenten** implementieren                               | Alternativ: vorhandene Boundary-Komponenten wiederverwenden.         |

---

### Minimalbeispiele

**Mount/Update/Unmount (Effect + Cleanup)**

```jsx
import { useEffect, useState } from "react";

export default function Chat() {
  const [connected, setConnected] = useState(false);

  useEffect(() => {
    const conn = connect();       // componentDidMount / DidUpdate (deps s.u.)
    setConnected(true);
    return () => conn.disconnect(); // componentWillUnmount
  }, []); // leeres Array: nur einmal nach Mount

  return <p>{connected ? "Online" : "Offline"}</p>;
}
```

**shouldComponentUpdate ‚Üí React.memo**

```jsx
import React, { useMemo } from "react";

const List = React.memo(function List({ items }) {
  const total = useMemo(() => items.reduce((s, x) => s + x.value, 0), [items]);
  return <p>Total: {total}</p>;
});

export default List;
```

**getDerivedStateFromProps vermeiden (Ableitung statt Spiegeln)**

```jsx
import { useMemo } from "react";

// Statt Prop -> State-Spiegelung:
export default function Price({ net, vatPercent }) {
  const gross = useMemo(() => net * (1 + vatPercent / 100), [net, vatPercent]);
  return <span>{gross.toFixed(2)} ‚Ç¨</span>;
}
```

**getSnapshotBeforeUpdate ‚Üí useLayoutEffect f√ºr Layout/Scroll**

```jsx
import { useLayoutEffect, useRef } from "react";

export default function AutoScroll({ messages }) {
  const listRef = useRef(null);
  const prevLen = useRef(0);

  useLayoutEffect(() => {
    const list = listRef.current;
    const nearBottom =
      list.scrollHeight - list.scrollTop - list.clientHeight < 20;

    // l√§uft nach DOM-Mutationen, vor dem Paint
    if (nearBottom || messages.length < prevLen.current) {
      list.scrollTop = list.scrollHeight; // ‚ÄûSnapshot‚Äú-artiges Verhalten
    }
    prevLen.current = messages.length;
  }, [messages]);

  return (
    <ul ref={listRef} style={{ maxHeight: 200, overflow: "auto" }}>
      {messages.map(m => <li key={m.id}>{m.text}</li>)}
    </ul>
  );
}
```

**Fehlergrenze (weiterhin Klasse)**

```jsx
import React from "react";

export class ErrorBoundary extends React.Component {
  state = { hasError: false };

  static getDerivedStateFromError() {
    return { hasError: true };
  }
  componentDidCatch(error, info) {
    console.error(error, info);
  }
  render() {
    return this.state.hasError ? <h1>Etwas ging schief.</h1> : this.props.children;
  }
}
```

---

### Zusammenfassung

* Mount/Update/Unmount: `useEffect` (mit/ohne deps) + **Cleanup**.
* Rendersteuerung: `React.memo`, `useMemo`, `useCallback`.
* Layout-kritisch: `useLayoutEffect` + `useRef`.
* `getDerivedStateFromProps` meist vermeiden (Props nicht spiegeln).
* Error Boundaries: weiterhin **Klassenkomponenten**.

üìñ Weiterf√ºhrend:

* React Docs: [Effects](https://react.dev/learn/synchronizing-with-effects), [useEffect](https://react.dev/reference/react/useEffect), [useLayoutEffect](https://react.dev/reference/react/useLayoutEffect), [Memoisierung](https://react.dev/learn/escape-hatches#memoizing-calculations), [React.memo](https://react.dev/reference/react/memo), [Error Boundaries](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary)
* MDN (RU): [–°–æ–±—ã—Ç–∏—è](https://developer.mozilla.org/ru/docs/Learn/JavaScript/Building_blocks/Events), [requestAnimationFrame](https://developer.mozilla.org/ru/docs/Web/API/window/requestAnimationFrame) (Kontext f√ºr Layout/Rendering-Zeitpunkte)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

45. ### <a name="45"></a> Was ist componentDidMount und was ist das √Ñquivalent mit Hooks?

### `componentDidMount` in Klassenkomponenten

* Wird **einmal nach dem ersten Render** ausgef√ºhrt, sobald die Komponente ins DOM eingef√ºgt wurde.
* Typische Eins√§tze:

  * **API-Requests starten**
  * **Event-Listener registrieren**
  * **DOM-Manipulationen** (Fokus setzen etc.)

```jsx
import React, { Component } from "react";

class Demo extends Component {
  componentDidMount() {
    console.log("Komponente wurde gemountet");
    document.title = "Hallo Sergii";
  }

  render() {
    return <h1>Hallo</h1>;
  }
}
```

---

### √Ñquivalent mit Hooks ‚Üí `useEffect`

In Funktionskomponenten √ºbernimmt `useEffect` die Rolle von Lifecycle-Methoden.

* **√Ñquivalent zu `componentDidMount`:** `useEffect` mit leerem Abh√§ngigkeitsarray `[]`.

```jsx
import { useEffect } from "react";

function Demo() {
  useEffect(() => {
    console.log("Komponente wurde gemountet");
    document.title = "Hallo Sergii";
  }, []); // leeres Array -> nur beim ersten Mount

  return <h1>Hallo</h1>;
}

export default Demo;
```

---

### Zusammenfassung

* **`componentDidMount`**: l√§uft einmal nach dem Einf√ºgen ins DOM (Klassenkomponenten).
* **Hook-√Ñquivalent**: `useEffect(() => { ... }, [])` in Funktionskomponenten.
* Typische Nutzung: API-Calls, Event-Registrierung, DOM-Manipulation.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì useEffect](https://react.dev/reference/react/useEffect)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

46. ### <a name="46"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

47. ### <a name="47"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

48. ### <a name="48"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

49. ### <a name="49"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

50. ### <a name="50"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

51. ### <a name="51"></a> Was sind Hooks in React?

### Hooks in React

**Hooks** sind spezielle **Funktionen**, die es erm√∂glichen, in **Funktionskomponenten** React-Features wie **State, Lifecycle-Methoden und Context** zu nutzen ‚Äì ohne Klassenkomponenten zu schreiben. Sie wurden mit **React 16.8** eingef√ºhrt.

---

### Warum Hooks?

1. Ersetzen viele Anwendungsf√§lle von **Klassenkomponenten**.
2. Erlauben **Wiederverwendung von Logik** (Custom Hooks).
3. Machen Code **k√ºrzer, klarer und besser testbar**.

---

### Wichtige eingebaute Hooks

* **State**: `useState` ‚Üí lokaler Zustand.
* **Lifecycle/Side Effects**: `useEffect`, `useLayoutEffect`.
* **Referenzen**: `useRef`.
* **Performance**: `useMemo`, `useCallback`.
* **Context**: `useContext`.
* **Reducer**: `useReducer` f√ºr komplexere State-Logik.

---

### Beispiel

```jsx
import { useState, useEffect } from "react";

function Counter() {
  const [count, setCount] = useState(0); // State-Hook

  useEffect(() => {
    document.title = `Z√§hler: ${count}`; // Effect-Hook (componentDidMount/DidUpdate)
  }, [count]);

  return (
    <>
      <p>Z√§hler: {count}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
    </>
  );
}

export default Counter;
```

---

### Zusammenfassung

* **Hooks = Funktionen**, die React-Features (State, Lifecycle, Context) in **Funktionskomponenten** bringen.
* Vorteil: keine Klassen mehr n√∂tig, bessere Wiederverwendung von Logik.
* Kernhooks: `useState`, `useEffect`, `useContext`, `useRef`, `useMemo`, `useCallback`.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Einf√ºhrung in Hooks](https://react.dev/learn/state-a-components-memory#using-hooks)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

52. ### <a name="52"></a> Wie funktionieren useState und useEffect?

### `useState`

* `useState` ist ein Hook, der in einer **Funktionskomponente** lokalen State speichert.
* Er liefert ein **Array mit zwei Werten**: `[aktuellerState, SetterFunktion]`.
* √Ñnderungen √ºber den Setter triggern ein **Re-Render** der Komponente.

```jsx
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0); // Initialwert = 0

  return (
    <>
      <p>Z√§hler: {count}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
    </>
  );
}
```

---

### `useEffect`

* `useEffect` erm√∂glicht **Side Effects** in Funktionskomponenten (z. B. API-Calls, Event-Listener, DOM-Manipulation).
* Standardm√§√üig l√§uft er **nach jedem Render**.
* Mit **Abh√§ngigkeitsarray** kann man steuern:

  * `[]` ‚Üí nur beim ersten Mount (`componentDidMount`).
  * `[deps]` ‚Üí bei √Ñnderungen der Abh√§ngigkeiten (`componentDidUpdate`).
  * Cleanup-Funktion ‚Üí beim Unmount (`componentWillUnmount`).

```jsx
import { useEffect, useState } from "react";

function Timer() {
  const [seconds, setSeconds] = useState(0);

  useEffect(() => {
    const id = setInterval(() => setSeconds(s => s + 1), 1000);

    return () => clearInterval(id); // Cleanup beim Unmount
  }, []);

  return <p>Timer: {seconds}s</p>;
}
```

---

### Zusammenfassung

* **`useState`**: lokaler State in Funktionskomponenten (`[state, setState]`).
* **`useEffect`**: verwaltet Side Effects (API, Timer, DOM), inkl. Cleanup.
* Zusammen bilden sie das Grundger√ºst f√ºr State-Management und Lifecycle-Handling in React.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì useState](https://react.dev/reference/react/useState)
* [React Offizielle Dokumentation ‚Äì useEffect](https://react.dev/reference/react/useEffect)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

53. ### <a name="53"></a> Was macht useContext?

### `useContext` in React

* **`useContext`** ist ein Hook, der Zugriff auf den Wert eines **React Contexts** erm√∂glicht.
* Er ersetzt die Notwendigkeit, Props durch viele Komponenten weiterzureichen (**Prop Drilling**).
* Jede Komponente, die `useContext` nutzt, wird neu gerendert, sobald sich der Context-Wert √§ndert.

---

### Beispiel

```jsx
import { createContext, useContext } from "react";

// 1. Context erstellen
const ThemeContext = createContext("light");

function ThemedButton() {
  // 2. Zugriff auf den aktuellen Wert
  const theme = useContext(ThemeContext);
  return <button className={theme}>Klick mich</button>;
}

export default function App() {
  return (
    // 3. Provider legt den Wert fest
    <ThemeContext.Provider value="dark">
      <ThemedButton />
    </ThemeContext.Provider>
  );
}
```

* `ThemeContext.Provider` ‚Üí stellt den Wert (`"dark"`) bereit.
* `useContext(ThemeContext)` ‚Üí liest den Wert aus, ohne Props weiterzureichen.

---

### Zusammenfassung

* **`useContext`**: Hook zum direkten Zugriff auf einen Context-Wert.
* Nutzen: Vermeidet **Prop Drilling**, ideal f√ºr globale Daten (Theme, Auth, Sprache).
* √Ñnderung des Contexts ‚Üí Re-Render aller abh√§ngigen Komponenten.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì useContext](https://react.dev/reference/react/useContext)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

54. ### <a name="54"></a> Was ist useRef und wann wird es verwendet?

### `useRef` in React

* **`useRef`** ist ein Hook, der ein **ver√§nderbares Objekt mit der Eigenschaft `.current`** zur√ºckgibt.
* Dieses Objekt bleibt **√ºber die gesamte Lebensdauer** der Komponente gleich.
* √Ñnderungen an `.current` l√∂sen **kein Re-Render** aus.

---

### Wann wird `useRef` verwendet?

1. **Direkter Zugriff auf DOM-Elemente**

   * Fokus setzen, Scroll-Position manipulieren, Integration mit Drittbibliotheken.

2. **Speichern von Werten zwischen Renders**

   * Persistente Werte behalten (z. B. Timer-ID, vorheriger Wert).

3. **Performance-Optimierung**

   * Verhindern, dass ein Wert bei jedem Render neu erzeugt wird.

---

### Beispiele

**DOM-Zugriff:**

```jsx
import { useRef } from "react";

function InputFocus() {
  const inputRef = useRef();

  const handleClick = () => {
    inputRef.current.focus(); // Zugriff auf das DOM-Element
  };

  return (
    <>
      <input ref={inputRef} type="text" />
      <button onClick={handleClick}>Fokus setzen</button>
    </>
  );
}
```

**Persistenter Wert (kein Re-Render):**

```jsx
import { useRef, useEffect } from "react";

function Timer() {
  const count = useRef(0);

  useEffect(() => {
    const id = setInterval(() => {
      count.current += 1; // Wert √§ndern ohne Re-Render
      console.log("Sekunden:", count.current);
    }, 1000);
    return () => clearInterval(id);
  }, []);

  return <p>Siehe Konsole</p>;
}
```

---

### Zusammenfassung

* **`useRef`** speichert eine ver√§nderbare Referenz (`.current`) √ºber Renders hinweg.
* Einsatz: DOM-Zugriffe, persistente Werte, Performance-Optimierung.
* Unterschied zu State: **√Ñnderungen an `useRef` triggern kein Re-Render**.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì useRef](https://react.dev/reference/react/useRef)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

55. ### <a name="55"></a> Was ist useCallback, useMemo, useReducer?

### 1. `useCallback`

* Gibt eine **memoisierte Callback-Funktion** zur√ºck.
* N√ºtzlich, um **unn√∂tige Re-Renders** von Kindkomponenten zu vermeiden, die eine Callback-Prop erhalten.
* Nur neu erstellt, wenn sich die Abh√§ngigkeiten √§ndern.

```jsx
import { useState, useCallback } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  const increment = useCallback(() => setCount(c => c + 1), []);
  // gleiche Funktion bleibt √ºber Renders hinweg erhalten

  return <button onClick={increment}>{count}</button>;
}
```

---

### 2. `useMemo`

* Gibt einen **memoisierten Wert** zur√ºck.
* Verhindert, dass **teure Berechnungen** bei jedem Render erneut ausgef√ºhrt werden.
* Nur neu berechnet, wenn sich die Abh√§ngigkeiten √§ndern.

```jsx
import { useState, useMemo } from "react";

function ExpensiveCalc({ num }) {
  const result = useMemo(() => {
    console.log("Teure Berechnung...");
    return num * 2;
  }, [num]);

  return <p>Ergebnis: {result}</p>;
}
```

---

### 3. `useReducer`

* Alternative zu `useState`, besonders f√ºr **komplexe State-Logik** oder **mehrere verbundene Zust√§nde**.
* Funktioniert √§hnlich wie ein **Redux-Reducer**: `state` + `action` ‚Üí neuer `state`.

```jsx
import { useReducer } from "react";

function reducer(state, action) {
  switch (action.type) {
    case "increment":
      return { count: state.count + 1 };
    case "decrement":
      return { count: state.count - 1 };
    default:
      return state;
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, { count: 0 });

  return (
    <>
      <p>Z√§hler: {state.count}</p>
      <button onClick={() => dispatch({ type: "increment" })}>+1</button>
      <button onClick={() => dispatch({ type: "decrement" })}>-1</button>
    </>
  );
}
```

---

### Zusammenfassung

* **`useCallback`**: memoisiert Funktionen ‚Üí vermeidet unn√∂tige Neu-Erstellungen.
* **`useMemo`**: memoisiert Werte ‚Üí verhindert teure Neuberechnungen.
* **`useReducer`**: State-Management f√ºr komplexe Logik, basierend auf Reducer-Pattern.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì useCallback](https://react.dev/reference/react/useCallback)
* [React Offizielle Dokumentation ‚Äì useMemo](https://react.dev/reference/react/useMemo)
* [React Offizielle Dokumentation ‚Äì useReducer](https://react.dev/reference/react/useReducer)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

56. ### <a name="56"></a> Wie schreibt man einen benutzerdefinierten Hook?

### Benutzerdefinierte Hooks (Custom Hooks)

Ein **Custom Hook** ist eine normale **JavaScript-Funktion**, deren Name mit **`use`** beginnt und die **React Hooks** (z. B. `useState`, `useEffect`) verwendet.
Zweck: **Wiederverwendung von Logik** in verschiedenen Komponenten.

---

### Regeln

1. Name muss mit `use...` beginnen.
2. Darf nur innerhalb von React-Komponenten oder anderen Hooks verwendet werden.
3. Muss die [Regeln der Hooks](https://react.dev/warnings/rules-of-hooks) einhalten: nur **Top-Level**, niemals in Schleifen oder Bedingungen.

---

### Beispiel ‚Äì Fensterbreite beobachten

```jsx
import { useState, useEffect } from "react";

// Custom Hook
function useWindowWidth() {
  const [width, setWidth] = useState(window.innerWidth);

  useEffect(() => {
    const handleResize = () => setWidth(window.innerWidth);
    window.addEventListener("resize", handleResize);

    return () => window.removeEventListener("resize", handleResize);
  }, []);

  return width; // gibt Wert zur√ºck
}

// Nutzung in einer Komponente
export default function App() {
  const width = useWindowWidth();

  return <p>Aktuelle Fensterbreite: {width}px</p>;
}
```

---

### Zusammenfassung

* **Custom Hook** = Funktion mit `use...`, die Hooks nutzt, um Logik wiederverwendbar zu machen.
* Vorteile: **Code-Wiederverwendung, bessere Lesbarkeit, klarere Trennung von Logik und UI**.
* Beispiel: `useWindowWidth`, `useFetch`, `useForm`.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Eigene Hooks](https://react.dev/learn/reusing-logic-with-custom-hooks)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

57. ### <a name="57"></a> Wie verhindert man eine Endlosschleife in useEffect?

### Endlosschleifen in `useEffect`

Eine Endlosschleife entsteht, wenn **State im Effect ge√§ndert** wird, ohne die Abh√§ngigkeiten korrekt zu steuern ‚Üí jeder State-Update l√∂st erneut den Effect aus.

---

### Ursachen

1. **Fehlendes oder falsches Abh√§ngigkeitsarray**

   ```jsx
   useEffect(() => {
     setCount(count + 1); // triggert bei jedem Render -> Endlosschleife
   }); // kein []
   ```

2. **Unn√∂tige Abh√§ngigkeiten**

   * Wenn Werte ins Array aufgenommen werden, die sich bei jedem Render √§ndern (z. B. Objekte/Funktionen).

---

### L√∂sungen

1. **Korrektes Abh√§ngigkeitsarray nutzen**

   ```jsx
   useEffect(() => {
     fetchData();
   }, []); // nur beim ersten Mount
   ```

2. **Funktionsupdates f√ºr State nutzen**

   ```jsx
   useEffect(() => {
     const id = setInterval(() => {
       setCount(prev => prev + 1); // nutzt vorherigen Wert, vermeidet Endlosschleife
     }, 1000);

     return () => clearInterval(id);
   }, []);
   ```

3. **Memoization f√ºr Objekte/Funktionen**

   * `useMemo` oder `useCallback` nutzen, damit sich die Abh√§ngigkeiten nicht bei jedem Render √§ndern.

   ```jsx
   const memoizedFn = useCallback(() => {
     console.log("Nur bei Bedarf neu erzeugt");
   }, []);

   useEffect(() => {
     memoizedFn();
   }, [memoizedFn]);
   ```

---

### Zusammenfassung

* Endlosschleifen entstehen durch **falsche oder fehlende Dependency Arrays** in `useEffect`.
* L√∂sung: korrektes Abh√§ngigkeitsarray, funktionale Updates, Memoization (`useCallback`, `useMemo`).
* Grundregel: **nur echte Abh√§ngigkeiten angeben** und Werte stabil halten.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì useEffect](https://react.dev/reference/react/useEffect)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

58. ### <a name="58"></a> Wie implementiert man Timeout oder Interval mit Hooks?

### Timeout & Interval mit Hooks

In Funktionskomponenten werden **`setTimeout`** und **`setInterval`** zusammen mit `useEffect` und `useRef` genutzt. Wichtig: **Cleanup** im `useEffect` verhindert Speicherlecks.

---

### Timeout (`setTimeout`)

```jsx
import { useEffect, useState } from "react";

function TimeoutDemo() {
  const [message, setMessage] = useState("Warte...");

  useEffect(() => {
    const id = setTimeout(() => {
      setMessage("Fertig nach 3 Sekunden!");
    }, 3000);

    return () => clearTimeout(id); // Cleanup beim Unmount
  }, []);

  return <p>{message}</p>;
}

export default TimeoutDemo;
```

---

### Interval (`setInterval`)

```jsx
import { useEffect, useState } from "react";

function IntervalDemo() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const id = setInterval(() => {
      setCount(prev => prev + 1); // funktionales Update vermeidet Endlosschleife
    }, 1000);

    return () => clearInterval(id); // Cleanup beim Unmount
  }, []);

  return <p>Z√§hler: {count}</p>;
}

export default IntervalDemo;
```

---

### Zusammenfassung

* **Timeout**: `setTimeout` + `clearTimeout` in `useEffect`.
* **Interval**: `setInterval` + `clearInterval` in `useEffect`.
* Cleanup-Funktion verhindert Leaks und unerw√ºnschte Effekte.
* Funktionale Updates (`prev => prev + 1`) sind wichtig, um Endlosschleifen zu vermeiden.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì useEffect](https://react.dev/reference/react/useEffect)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

59. ### <a name="59"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

60. ### <a name="60"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

61. ### <a name="61"></a> Was ist ein Higher-Order Component (HOC)?

# Was ist ein Higher-Order Component (HOC)?

Ein **Higher-Order Component (HOC)** ist ein **Designmuster in React**,  
bei dem **eine Funktion eine Komponente nimmt und eine neue, erweiterte Komponente zur√ºckgibt**.

---

## üéØ Zweck eines HOC

- ‚úÖ **Wiederverwendbare Logik** auf mehrere Komponenten anwenden  
- ‚úÖ Komponenten **mit zus√§tzlichen Props, Verhalten oder Styling** erweitern  
- ‚úÖ Trennung von Zust√§ndigkeiten (Separation of Concerns)

---

## üì¶ Definition

```js
const EnhancedComponent = withSomething(WrappedComponent);
```

‚û°Ô∏è `withSomething` ist das HOC, `WrappedComponent` ist die Originalkomponente.

---

## üí° Einfaches Beispiel: `withLogger`

```jsx
function withLogger(WrappedComponent) {
  return function EnhancedComponent(props) {
    console.log('Props:', props);
    return <WrappedComponent {...props} />;
  };
}
```

### Verwendung:

```jsx
const LoggedButton = withLogger(Button);
```

‚û°Ô∏è Jedes Mal, wenn `LoggedButton` verwendet wird, werden die Props geloggt.

---

## üîÅ Typische Anwendungsf√§lle

- Zugriffsschutz (z.‚ÄØB. `withAuth`)
- Theming (z.‚ÄØB. `withTheme`)
- Logging & Analytics
- Fehlerbehandlung (`withErrorBoundary`)
- Datenanbindung (z.‚ÄØB. `connect()` in Redux)

---

## ‚ö†Ô∏è Hinweise

- HOCs **ver√§ndern nicht** die urspr√ºngliche Komponente, sondern **verpacken sie**
- HOC **d√ºrfen keine Seiteneffekte beim Rendern haben**
- Der **Komponentenname sollte erhalten bleiben** (z.‚ÄØB. mit `displayName`), f√ºr Debugging

---

## üìù Zusammenfassung

Ein **Higher-Order Component (HOC)** ist eine Funktion,  
die eine Komponente nimmt und **eine neue Komponente mit erweitertem Verhalten** zur√ºckgibt.  
Sie ist ein m√§chtiges Werkzeug zur **Wiederverwendung von Logik und Struktur**.

---

## üîó Quellen

- [React Docs ‚Äì Higher-Order Components](https://reactjs.org/docs/higher-order-components.html)  
- [MDN ‚Äì React Komponentendesignmuster](https://developer.mozilla.org/de/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_components#higher-order-components)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

62. ### <a name="62"></a> Was ist das Render-Prop-Pattern?

# Was ist das Render-Prop-Pattern?

Das **Render-Prop-Pattern** ist ein **React-Designmuster**,  
bei dem eine Komponente eine **Funktion als Prop (render prop)** erh√§lt,  
um **flexibel zu steuern, was gerendert werden soll**.

---

## üéØ Zweck des Patterns

- ‚úÖ Erm√∂glicht das **Teilen von wiederverwendbarer Logik**
- ‚úÖ Gibt der Elternkomponente die **volle Kontrolle √ºber das gerenderte UI**
- ‚úÖ Alternative zu HOCs oder Hooks bei **logikbasiertem Code-Sharing**

---

## üì¶ Struktur

```jsx
<MyComponent render={(data) => (
  <p>{data.message}</p>
)} />
```

Oder via `children`-Prop:

```jsx
<MyComponent>
  {(data) => <p>{data.message}</p>}
</MyComponent>
```

---

## üí° Beispiel: `MouseTracker` mit Render-Prop

```jsx
function MouseTracker({ render }) {
  const [position, setPosition] = useState({ x: 0, y: 0 });

  useEffect(() => {
    const handleMove = (e) => setPosition({ x: e.clientX, y: e.clientY });
    window.addEventListener('mousemove', handleMove);
    return () => window.removeEventListener('mousemove', handleMove);
  }, []);

  return render(position);
}
```

### Verwendung:

```jsx
<MouseTracker
  render={({ x, y }) => (
    <p>Position: {x}, {y}</p>
  )}
/>
```

---

## üîÅ Vorteile gegen√ºber HOC

| Aspekt               | Render-Prop             | HOC                           |
|----------------------|-------------------------|--------------------------------|
| Mehrfach verwendbar  | ‚úÖ Ja                   | ‚úÖ Ja                          |
| Flexibel im UI       | ‚úÖ Sehr flexibel         | ‚ùå Eingeschr√§nkter UI-Zugriff |
| Komponentenbaum flach| ‚úÖ Ja                   | ‚ùå Kann tiefe Wrapper erzeugen |

---

## ‚ö†Ô∏è Nachteile

- Kann bei vielen Ebenen zu **"Wrapper Hell"** f√ºhren (√§hnlich wie HOC)
- Wird heute oft durch **Hooks ersetzt**, da diese **einfacher und lesbarer** sind

---

## üìù Zusammenfassung

Das **Render-Prop-Pattern** erm√∂glicht das **Weitergeben von Logik √ºber Funktionen als Props**.  
Die aufrufende Komponente entscheidet, **wie das UI aussehen soll**, w√§hrend die Logik zentral bleibt.

---

## üîó Quellen

- [Render Props ‚Äì React Docs](https://reactjs.org/docs/render-props.html)  
- [React Patterns ‚Äì Render Props](https://reactpatterns.com/#render-callback)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

63. ### <a name="63"></a> Was ist die Context-API und wie funktioniert useContext?

# Was ist die Context-API und wie funktioniert `useContext`?

Die **Context-API** von React ist ein integrierter Mechanismus,  
um **globale Daten (z.‚ÄØB. Theme, Sprache, Benutzerinfos)**  
an beliebige Komponenten im Komponentenbaum **weiterzugeben**,  
**ohne Props manuell durch mehrere Ebenen zu reichen**.

---

## üéØ Warum Context?

- ‚úÖ Vermeidet **Prop-Drilling**  
- ‚úÖ Ideal f√ºr **globale Zust√§nde oder Konfigurationen**  
- ‚úÖ Einfach zu kombinieren mit `useContext`

---

## üß± Bestandteile der Context-API

1. **`createContext()`** ‚Äì erstellt einen neuen Kontext  
2. **`<Provider>`** ‚Äì stellt einen Wert zur Verf√ºgung  
3. **`useContext(Context)`** ‚Äì liest den aktuellen Wert des Kontexts

---

## üí° Beispiel: ThemeContext

### 1. Context erstellen:

```jsx
import { createContext } from 'react';

const ThemeContext = createContext('light'); // optionaler Default-Wert
```

---

### 2. Provider verwenden:

```jsx
function App() {
  return (
    <ThemeContext.Provider value="dark">
      <Toolbar />
    </ThemeContext.Provider>
  );
}
```

---

### 3. Zugriff mit `useContext`:

```jsx
import { useContext } from 'react';

function ThemeButton() {
  const theme = useContext(ThemeContext); // "dark"
  return <button className={theme}>Aktuelles Theme: {theme}</button>;
}
```

‚û°Ô∏è `ThemeButton` hat Zugriff auf den Kontextwert, ohne dass Props √ºber `Toolbar` weitergegeben werden m√ºssen.

---

## üìå Wichtig zu wissen

- Jeder Context-Wert ist **nur innerhalb seines `<Provider>` sichtbar**  
- Komponenten werden **neu gerendert**, wenn sich der Context-Wert √§ndert  
- Context ist **nicht als globaler State-Ersatz f√ºr komplexe Logik** gedacht (‚Üí besser: Redux, Zustand, etc.)

---

## üìù Zusammenfassung

- Die **Context-API** erlaubt das **Teilen globaler Werte** im Komponentenbaum  
- Mit `useContext(Context)` kannst du in Funktionskomponenten **einfach auf diese Werte zugreifen**  
- Sie ist n√ºtzlich f√ºr Dinge wie **Themen, Sprache, Benutzerinfo, Feature-Flags**

---

## üîó Quellen

- [Context ‚Äì React Docs](https://react.dev/learn/passing-data-deeply-with-context)  
- [useContext ‚Äì React Docs](https://react.dev/reference/react/useContext)  
- [MDN: Context in React](https://developer.mozilla.org/de/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_components#context)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

64. ### <a name="64"></a> Was sind Portale in React?

# Was sind Portale in React?

**Portale** (engl. *Portals*) in React erm√∂glichen es, **Komponenten au√üerhalb der normalen DOM-Hierarchie**  
zu rendern ‚Äì also **au√üerhalb des `div#root`**, aber trotzdem **vollst√§ndig von React verwaltet**.

---

## üéØ Wann braucht man ein Portal?

- Modale Dialoge (z.‚ÄØB. `<Modal />`)  
- Tooltips  
- Dropdown-Men√ºs  
- Overlays  
- Elemente, die visuell **√ºber anderen Komponenten liegen** m√ºssen

‚û°Ô∏è Diese Elemente m√ºssen oft **am Ende des `<body>`** gerendert werden, um korrekt zu funktionieren (z.‚ÄØB. Z-Index, Positionierung).

---

## üí° Beispiel: Portal verwenden

### 1. Ziel-Element im HTML

```html
<body>
  <div id="root"></div>
  <div id="modal-root"></div> <!-- Hier wird das Portal platziert -->
</body>
```

---

### 2. Komponente mit Portal

```jsx
import { createPortal } from 'react-dom';

function Modal({ children }) {
  return createPortal(
    <div className="modal">{children}</div>,
    document.getElementById('modal-root')
  );
}
```

---

### 3. Verwendung in der App

```jsx
function App() {
  return (
    <>
      <h1>Seite</h1>
      <Modal>
        <p>Ich werde au√üerhalb von #root gerendert!</p>
      </Modal>
    </>
  );
}
```

‚û°Ô∏è Das Modal wird **optisch au√üerhalb** des Hauptbaums gerendert,  
aber **logisch bleibt es Teil von React** ‚Äì inklusive Props, State, Events usw.

---

## üîÅ Vorteile von Portalen

| Vorteil                    | Beschreibung                                       |
|----------------------------|----------------------------------------------------|
| üîÑ Event-Bubbling bleibt   | Events funktionieren weiterhin wie gewohnt         |
| üéØ Flexibles Layout        | Bessere Positionierung im DOM                      |
| üîí Kein CSS-Zusammensto√ü   | Vermeidet Probleme mit `overflow: hidden`, `z-index` etc.

---

## üìù Zusammenfassung

- Portale rendern Komponenten **au√üerhalb des DOM-Hierarchie der Eltern**
- N√ºtzlich f√ºr **Modale, Tooltips, Overlays**
- Implementiert mit `ReactDOM.createPortal(element, domNode)`

---

## üîó Quellen

- [Portals ‚Äì React Docs](https://reactjs.org/docs/portals.html)  
- [MDN: DOM-Portale und Modale](https://developer.mozilla.org/de/docs/Web/HTML/Element/dialog)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

65. ### <a name="65"></a> Was ist bedingtes Rendern (Conditional Rendering)?

# Was ist bedingtes Rendern (Conditional Rendering) in React?

**Bedingtes Rendern** bedeutet in React, dass eine Komponente **abh√§ngig von einer Bedingung**  
**unterschiedlichen JSX-Inhalt rendert** ‚Äì also **dynamisch entscheidet, was angezeigt wird**.

---

## üéØ Anwendungsbeispiele

- Benutzer ist **eingeloggt oder nicht**
- Ladevorgang (`Loading...`) vs. Datenanzeige
- Verschiedene UI-Elemente abh√§ngig von Status, Rollen, Berechtigungen

---

## üîß Methoden f√ºr bedingtes Rendern

### ‚úÖ 1. `if`-Anweisung

```jsx
if (isLoggedIn) {
  return <Dashboard />;
} else {
  return <LoginForm />;
}
```

---

### ‚úÖ 2. Tern√§rer Operator (`? :`)

```jsx
return (
  <div>
    {isLoading ? <p>Lade Daten...</p> : <DataList />}
  </div>
);
```

---

### ‚úÖ 3. Logischer UND-Operator (`&&`)

```jsx
{hasPermission && <DeleteButton />}
```

‚û°Ô∏è Rendert `DeleteButton` **nur**, wenn `hasPermission === true` ist.

---

### ‚úÖ 4. Optionales Rendering mit `null`

```jsx
{shouldShow ? <Component /> : null}
```

‚û°Ô∏è Wenn `shouldShow === false`, wird **gar nichts** gerendert.

---

## üìù Zusammenfassung

**Conditional Rendering** bedeutet, dass JSX **dynamisch** auf Basis von Bedingungen  
**unterschiedlichen Inhalt rendert**.  
React unterst√ºtzt daf√ºr mehrere Schreibweisen:  
`if`, `? :`, `&&`, R√ºckgabe von `null`.

---

## üîó Quellen

- [Conditional Rendering ‚Äì React Docs](https://react.dev/learn/conditional-rendering)  
- [MDN: Bedingte Ausdr√ºcke](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Operators/Conditional_Operator)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

66. ### <a name="66"></a> Was ist ein Error Boundary?

# Was ist ein Error Boundary in React?

Ein **Error Boundary** (Fehlergrenze) ist eine **spezielle React-Komponente**,  
die **JavaScript-Fehler** in ihrer **Kind-Komponenten-Hierarchie abf√§ngt**,  
um zu verhindern, dass der **gesamte UI-Baum zusammenbricht**.

---

## üéØ Zweck von Error Boundaries

- ‚úÖ Fehler im UI **abfangen**, anzeigen und kontrolliert behandeln  
- ‚úÖ Verhindert den **Absturz der gesamten App**  
- ‚úÖ Zeigt stattdessen **Fallback-UI** oder eine Fehlermeldung an

---

## üì¶ Wann tritt ein Fehler auf?

Error Boundaries fangen **nur Fehler w√§hrend des Renderns**,  
in **Lifecycle-Methoden** und in **Konstruktoren von Klassenkomponenten** ab.

**Nicht abgefangen werden**:
- Fehler in Event-Handlern (diese m√ºssen manuell mit `try/catch` behandelt werden)
- Fehler in `async`-Funktionen
- Fehler au√üerhalb des React-Baums

---

## üí° Beispiel: Error Boundary (Klassenkomponente)

```jsx
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, info) {
    console.error('Fehler abgefangen:', error, info);
  }

  render() {
    if (this.state.hasError) {
      return <h2>Etwas ist schiefgelaufen.</h2>;
    }

    return this.props.children;
  }
}
```

---

### ‚úÖ Verwendung:

```jsx
<ErrorBoundary>
  <ProblematicComponent />
</ErrorBoundary>
```

‚û°Ô∏è Wenn `ProblematicComponent` crasht, zeigt `ErrorBoundary` stattdessen die Fallback-UI.

---

## üß™ Wann verwenden?

- Um Teile der App **abzusichern** (z.‚ÄØB. Seitenbereiche, Widgets)
- Um **Logs zu erfassen** (`componentDidCatch`)
- Um den Nutzer bei Fehlern **nicht allein zu lassen**

---

## üìù Zusammenfassung

Ein **Error Boundary** ist eine **Klassenkomponente**,  
die Fehler in der React-Komponentenstruktur **abf√§ngt und behandelt**,  
ohne dass die ganze App abst√ºrzt.  
Sie bietet eine **Fallback-UI** und hilft bei **Debugging & Stabilit√§t**.

---

## üîó Quellen

- [Error Boundaries ‚Äì React Docs](https://react.dev/learn/managing-errors)  
- [MDN: Fehlerbehandlung in React](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch#handling_errors_in_react)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

67. ### <a name="67"></a> Wie funktioniert Event-Handling in React?

# Wie funktioniert Event-Handling in React?

**Event-Handling** in React funktioniert √§hnlich wie in HTML/JavaScript,  
aber mit einigen **Unterschieden in Syntax und Verhalten**.

---

## üéØ Besonderheiten in React

- React verwendet **camelCase** statt Kleinschreibung:
  - `onClick` statt `onclick`
- Event-Handler werden als **Funktionen (nicht Strings)** √ºbergeben:
  - `{handleClick}` statt `"handleClick()"`

---

## üí° Beispiel: Klick-Event

```jsx
function Button() {
  function handleClick() {
    alert('Button wurde geklickt!');
  }

  return <button onClick={handleClick}>Klicken</button>;
}
```

---

## üì¶ Event-Objekt

React stellt ein **synthetisches Event-Objekt** (`SyntheticEvent`) bereit,  
das mit allen Browsern konsistent funktioniert.

```jsx
function Input() {
  function handleChange(e) {
    console.log('Eingegeben:', e.target.value);
  }

  return <input onChange={handleChange} />;
}
```

‚û°Ô∏è `e` ist das SyntheticEvent, das sich **√§hnlich wie ein native DOM-Event** verh√§lt.

---

## üîÅ Weitere Event-Beispiele

| Event         | Attribut        | Beispiel                           |
|---------------|------------------|------------------------------------|
| Klick         | `onClick`        | `<button onClick={fn} />`          |
| Eingabe       | `onChange`       | `<input onChange={fn} />`          |
| Fokus         | `onFocus`        | `<input onFocus={fn} />`           |
| Maus bewegen  | `onMouseMove`    | `<div onMouseMove={fn} />`         |
| Formular      | `onSubmit`       | `<form onSubmit={fn} />`           |
| Taste dr√ºcken | `onKeyDown`      | `<input onKeyDown={fn} />`         |

---

## ‚úÖ Standardverhalten verhindern

```jsx
function Form() {
  function handleSubmit(e) {
    e.preventDefault(); // verhindert Seitenreload
    console.log('Formular abgesendet');
  }

  return <form onSubmit={handleSubmit}>...</form>;
}
```

---

## üìù Zusammenfassung

- React verwendet eigene Events (`SyntheticEvent`) mit vertrauter API  
- Event-Handler werden als Funktionen mit camelCase geschrieben  
- Du kannst Standardverhalten (z.‚ÄØB. Form-Submit) mit `e.preventDefault()` unterdr√ºcken

---

## üîó Quellen

- [Events in React ‚Äì React Docs](https://react.dev/learn/responding-to-events)  
- [React Event Handling ‚Äì MDN](https://developer.mozilla.org/en-US/docs/Web/Events)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

68. ### <a name="68"></a> Was ist ein synthetisches Ereignis (SyntheticEvent)?

# Was ist ein synthetisches Ereignis (SyntheticEvent) in React?

Ein **synthetisches Ereignis** (`SyntheticEvent`) ist ein von React bereitgestelltes **plattformsicheres Wrapper-Objekt**  
f√ºr native DOM-Ereignisse wie `click`, `change`, `submit`, etc.

---

## üéØ Zweck von `SyntheticEvent`

- ‚úÖ Einheitliches Verhalten in **allen Browsern**
- ‚úÖ Automatisches **Event-Pooling** (fr√ºher)
- ‚úÖ Konsistente API f√ºr alle Event-Typen
- ‚úÖ Kombiniert die Vorteile von DOM- und Custom-Events

---

## üì¶ Eigenschaften

- `SyntheticEvent` hat die **gleichen Methoden und Eigenschaften** wie ein normales DOM-Event:  
  - `e.target`, `e.preventDefault()`, `e.stopPropagation()` usw.
- Funktioniert f√ºr **alle Event-Typen**: Maus, Tastatur, Formulare, Fokus, usw.

---

## üí° Beispiel

```jsx
function Form() {
  function handleSubmit(e) {
    e.preventDefault(); // verhindert Reload
    console.log('Eingabefeld:', e.target.elements.name.value);
  }

  return (
    <form onSubmit={handleSubmit}>
      <input name="name" />
      <button type="submit">Absenden</button>
    </form>
  );
}
```

‚û°Ô∏è `e` ist ein `SyntheticEvent`, nicht das native `Event`-Objekt des Browsers.

---

## ‚ö†Ô∏è Hinweis: Event-Pooling (fr√ºher)

Fr√ºher wurden `SyntheticEvent`-Objekte **recycelt** (Event Pooling), was bedeutete:  
Zugriff auf das Event nach dem Event-Handler war **nicht mehr m√∂glich**.  
**Seit React 17+ ist Pooling deaktiviert.**

---

## üìù Zusammenfassung

Ein `SyntheticEvent` ist Reacts **einheitliche Event-API**,  
die unabh√§ngig vom Browser funktioniert und dieselbe Oberfl√§che wie das native DOM-Event bietet.  
Du kannst es wie gewohnt verwenden (`e.preventDefault()`, `e.target.value`, etc.).

---

## üîó Quellen

- [React Docs ‚Äì SyntheticEvent](https://react.dev/reference/react-dom/SyntheticEvent)  
- [MDN: DOM Events √úbersicht](https://developer.mozilla.org/de/docs/Web/Events)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

69. ### <a name="69"></a> Was ist props.children?

# Was ist `props.children` in React?

**`props.children`** ist eine spezielle React-Prop,  
die automatisch alle **verschachtelten Elemente (Child-Komponenten oder JSX-Inhalte)** enth√§lt,  
die **innerhalb einer Komponente √ºbergeben** werden.

---

## üéØ Wozu wird `props.children` verwendet?

- ‚úÖ Um **dynamisch Inhalte zu rendern**, die von au√üen √ºbergeben werden  
- ‚úÖ Um **Wrapper-Komponenten** (z.‚ÄØB. Layouts, Container) zu erstellen  
- ‚úÖ F√ºr **wiederverwendbare UI-Strukturen**

---

## üí° Beispiel

```jsx
function Card(props) {
  return <div className="card">{props.children}</div>;
}

function App() {
  return (
    <Card>
      <h2>Titel</h2>
      <p>Das ist der Inhalt der Card.</p>
    </Card>
  );
}
```

‚û°Ô∏è Die `Card`-Komponente erh√§lt:

```jsx
<h2>...</h2>
<p>...</p>
```

als `props.children` und rendert sie **im Inneren**.

---

## üì¶ Typen von `props.children`

- Kann ein **Element**, ein **Text**, ein **Array**, `null`, `undefined` oder ein **Fragment** sein
- Du kannst `children` auch **pr√ºfen oder filtern**, z.‚ÄØB. mit `React.Children`

---

## üß™ Beispiel mit mehreren Kindern

```jsx
function Wrapper({ children }) {
  return (
    <section>
      {React.Children.map(children, (child, index) => (
        <div key={index}>{child}</div>
      ))}
    </section>
  );
}
```

‚û°Ô∏è So kannst du **alle `children` gezielt verarbeiten**.

---

## üìù Zusammenfassung

- `props.children` enth√§lt **alle JSX-Inhalte**, die **zwischen den Tags** einer Komponente √ºbergeben werden  
- Es macht Komponenten **flexibel und wiederverwendbar**
- Typisch bei Layout-Komponenten, Dialogen, Containern

---

## üîó Quellen

- [React Docs ‚Äì Children](https://react.dev/learn/passing-props-to-a-component#using-the-children-prop)  
- [React.Children API ‚Äì React Docs](https://react.dev/reference/react/Children)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

70. ### <a name="70"></a> Was bedeutet ‚Äûcontrolled component‚Äú und ‚Äûuncontrolled component‚Äú bei Formularen?

# Was bedeutet ‚Äûcontrolled component‚Äú und ‚Äûuncontrolled component‚Äú bei Formularen in React?

In React beschreibt man Formular-Elemente wie `<input>`, `<textarea>` oder `<select>` als  
**controlled** oder **uncontrolled**, je nachdem, **wie ihr Wert verwaltet wird**.

---

## ‚úÖ Controlled Component

Ein **controlled component** wird **vollst√§ndig durch React kontrolliert** ‚Äì  
der Wert kommt aus dem **State** und wird √ºber `onChange` aktualisiert.

### Eigenschaften:

- Wert liegt im React-State
- √Ñnderungen erfolgen √ºber `setState` / `useState`
- Ideal f√ºr Validierung, dynamische Formulare, zentrale Kontrolle

### Beispiel:

```jsx
function Form() {
  const [name, setName] = useState('');

  return (
    <input 
      value={name}
      onChange={(e) => setName(e.target.value)}
    />
  );
}
```

‚û°Ô∏è Das Eingabefeld zeigt **immer den aktuellen State-Wert**.

---

## ‚ùå Uncontrolled Component

Ein **uncontrolled component** verwaltet seinen Wert **intern im DOM**,  
React **greift nur √ºber ein Ref** darauf zu ‚Äì z.‚ÄØB. beim Absenden des Formulars.

### Eigenschaften:

- Kein React-State f√ºr den Wert
- Zugriff √ºber `ref`
- Einfach, aber schwerer zu validieren

### Beispiel:

```jsx
function Form() {
  const inputRef = useRef();

  const handleSubmit = (e) => {
    e.preventDefault();
    alert(inputRef.current.value);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input ref={inputRef} />
      <button type="submit">Absenden</button>
    </form>
  );
}
```

‚û°Ô∏è Der Wert wird **nicht in React gespeichert**, sondern **aus dem DOM gelesen**.

---

## üîÅ Vergleich

| Merkmal              | Controlled                   | Uncontrolled                    |
|----------------------|------------------------------|----------------------------------|
| Datenquelle          | React-State (`useState`)     | DOM (intern)                     |
| Zugriff              | `value` + `onChange`         | `ref.current.value`              |
| Validierung          | Einfach                      | Komplizierter                    |
| Flexibilit√§t         | Hoch                         | Gering                           |
| Initialwert          | via State                    | via `defaultValue`               |

---

## üìù Zusammenfassung

- **Controlled Components**: React verwaltet den Formularwert ‚Üí vollst√§ndig kontrollierbar
- **Uncontrolled Components**: Der Browser verwaltet den Wert ‚Üí Zugriff nur √ºber Ref
- Controlled ist der **empfohlene Standard**, besonders bei komplexen Formularen

---

## üîó Quellen

- [Controlled Components ‚Äì React Docs](https://react.dev/learn/sharing-state-between-components#controlled-and-uncontrolled-components)  
- [Formulare in React ‚Äì MDN](https://developer.mozilla.org/de/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_forms)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

71. ### <a name="71"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

72. ### <a name="72"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

73. ### <a name="73"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

74. ### <a name="74"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

75. ### <a name="75"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

76. ### <a name="76"></a> Wie f√ºhrt man API-Aufrufe mit Fetch oder Axios durch?

# Wie f√ºhrt man API-Aufrufe mit `fetch` oder `axios` in React durch?

In React kannst du API-Anfragen auf zwei g√§ngige Arten durchf√ºhren:

1. Mit dem **integrierten `fetch`-API** (nativ in JavaScript)
2. Mit der **Axios-Bibliothek** (komfortabler, aber extern)

---

## ‚úÖ 1. API-Aufruf mit `fetch`

```jsx
import { useEffect, useState } from 'react';

function UserList() {
  const [users, setUsers] = useState([]);
  const [error, setError] = useState(null);

  useEffect(() => {
    fetch('https://jsonplaceholder.typicode.com/users')
      .then((res) => {
        if (!res.ok) throw new Error('Fehler beim Laden');
        return res.json();
      })
      .then((data) => setUsers(data))
      .catch((err) => setError(err.message));
  }, []);

  if (error) return <p>Fehler: {error}</p>;
  return (
    <ul>
      {users.map((u) => (
        <li key={u.id}>{u.name}</li>
      ))}
    </ul>
  );
}
```

---

## ‚úÖ 2. API-Aufruf mit `axios`

### Installation:

```bash
npm install axios
```

### Verwendung:

```jsx
import axios from 'axios';
import { useEffect, useState } from 'react';

function PostList() {
  const [posts, setPosts] = useState([]);
  const [error, setError] = useState(null);

  useEffect(() => {
    axios
      .get('https://jsonplaceholder.typicode.com/posts')
      .then((res) => setPosts(res.data))
      .catch((err) => setError(err.message));
  }, []);

  if (error) return <p>Fehler: {error}</p>;
  return (
    <ul>
      {posts.map((p) => (
        <li key={p.id}>{p.title}</li>
      ))}
    </ul>
  );
}
```

---

## üîÅ Vergleich: `fetch` vs. `axios`

| Merkmal             | `fetch` (nativ)              | `axios` (Bibliothek)             |
|---------------------|------------------------------|----------------------------------|
| Integriert in JS?   | ‚úÖ Ja                         | ‚ùå Nein (muss installiert werden) |
| JSON automatisch?   | ‚ùå Nein (manuell: `.json()`) | ‚úÖ Ja (direkt `res.data`)         |
| Fehlerbehandlung    | Manuell mit `res.ok` pr√ºfen  | Automatisch bei HTTP-Fehler      |
| Unterst√ºtzt Abbrechen | ‚ùå Nur mit AbortController | ‚úÖ Ja                             |

---

## üìù Zusammenfassung

- Mit `fetch` und `axios` kannst du in `useEffect` **API-Daten laden**
- `fetch`: nativ, minimalistisch  
- `axios`: komfortabler, bessere Fehlerbehandlung  
- Immer Fehler abfangen (`.catch`) und Zustand (`loading`, `error`, `data`) verwalten

---

## üîó Quellen

- [fetch ‚Äì MDN Web Docs](https://developer.mozilla.org/de/docs/Web/API/Fetch_API)
- [Axios ‚Äì GitHub Docs](https://axios-http.com/docs/intro)
- [Daten in React laden ‚Äì React Docs](https://react.dev/learn/you-might-not-need-an-effect#fetching-data)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

77. ### <a name="77"></a> Wie verwaltet man Lade-, Fehler- und Erfolgsstatus?

# Wie verwaltet man Lade-, Fehler- und Erfolgsstatus in React?

Beim **Abrufen von Daten (API)** ist es wichtig, den **Status** der Anfrage zu verwalten:

1. üîÑ **Ladezustand** (`isLoading`)
2. ‚úÖ **Erfolgszustand** (Daten verf√ºgbar)
3. ‚ùå **Fehlerzustand** (Fehler beim Laden)

Diese drei Zust√§nde werden meist mit **`useState` und `useEffect`** verwaltet.

---

## üí° Beispiel mit `fetch`

```jsx
import { useState, useEffect } from 'react';

function UserList() {
  const [users, setUsers] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    fetch('https://jsonplaceholder.typicode.com/users')
      .then((res) => {
        if (!res.ok) throw new Error('Fehler beim Laden');
        return res.json();
      })
      .then((data) => {
        setUsers(data);
        setError(null);
      })
      .catch((err) => setError(err.message))
      .finally(() => setIsLoading(false));
  }, []);

  if (isLoading) return <p>‚è≥ Lade Daten...</p>;
  if (error) return <p>‚ùå Fehler: {error}</p>;

  return (
    <ul>
      {users.map((user) => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

---

## ‚úÖ Statusverwaltung im √úberblick

| Zustand     | Variable     | Bedeutung                                 |
|-------------|--------------|--------------------------------------------|
| Ladezustand | `isLoading`  | Wird `true` beim Start der Anfrage         |
| Erfolgsdaten| `data`, `users`, etc. | Wird nach erfolgreichem Laden gesetzt |
| Fehlerzustand| `error`     | Wird gesetzt, wenn `.catch()` ausgel√∂st wird |

---

## üîÑ Alternativen

- Eigener **Custom Hook** (`useFetch`, `useApi`)
- **State Machine** (z.‚ÄØB. mit `xstate`)
- Zustand mit `useReducer` verwalten, wenn komplexer

---

## üìù Zusammenfassung

- Nutze `useState` f√ºr `isLoading`, `error` und `data`
- Nutze `useEffect`, um Daten zu laden
- Zeige je nach Zustand: Ladeanzeige, Fehlernachricht oder Daten

---

## üîó Quellen

- [React: API-Daten laden ‚Äì react.dev](https://react.dev/learn/you-might-not-need-an-effect#fetching-data)  
- [fetch API ‚Äì MDN Docs](https://developer.mozilla.org/de/docs/Web/API/Fetch_API)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

78. ### <a name="78"></a> Wie funktioniert WebSocket mit React?

# Wie funktioniert WebSocket mit React?

**WebSockets** erm√∂glichen eine **bidirektionale, permanente Verbindung** zwischen Client (Browser) und Server.  
In React kannst du damit **Echtzeit-Daten** verarbeiten ‚Äì z.‚ÄØB. f√ºr Chats, Benachrichtigungen oder Live-Dashboards.

---

## üîÑ Grundprinzip WebSocket

1. Verbindung zum Server aufbauen
2. Nachrichten senden & empfangen
3. Verbindung schlie√üen (bei Unmount oder Fehler)

---

## üí° Beispiel: WebSocket in React verwenden

```jsx
import { useEffect, useRef, useState } from 'react';

function WebSocketComponent() {
  const socketRef = useRef(null);
  const [messages, setMessages] = useState([]);

  useEffect(() => {
    // 1. Verbindung aufbauen
    socketRef.current = new WebSocket('wss://example.com/socket');

    // 2. Nachricht empfangen
    socketRef.current.onmessage = (event) => {
      setMessages((prev) => [...prev, event.data]);
    };

    // 3. Fehlerbehandlung
    socketRef.current.onerror = (err) => {
      console.error('WebSocket-Fehler:', err);
    };

    // 4. Aufr√§umen beim Unmount
    return () => {
      socketRef.current.close();
    };
  }, []);

  // Nachricht senden (z.‚ÄØB. beim Button-Klick)
  const sendMessage = () => {
    if (socketRef.current.readyState === WebSocket.OPEN) {
      socketRef.current.send('Hallo vom Client!');
    }
  };

  return (
    <div>
      <h3>Empfangene Nachrichten:</h3>
      <ul>
        {messages.map((msg, i) => (
          <li key={i}>{msg}</li>
        ))}
      </ul>
      <button onClick={sendMessage}>Nachricht senden</button>
    </div>
  );
}
```

---

## üîÅ Tipps f√ºr den produktiven Einsatz

- Nutze `useRef`, damit WebSocket-Verbindung **nicht bei jedem Render neu aufgebaut** wird  
- Pr√ºfe `socket.readyState`, bevor du Nachrichten sendest  
- Verwende ggf. **Reconnect-Strategien**, falls Verbindung abbricht  
- F√ºr gro√üe Projekte: verwalte WebSocket √ºber `Context` oder `Redux`

---

## üìù Zusammenfassung

- WebSocket bietet eine **dauerhafte Verbindung** zwischen React-Client und Server  
- Ideal f√ºr **Live-Kommunikation** (Chat, Echtzeitdaten)  
- In React: mit `useEffect`, `useRef` und `setState` kombinieren  
- Nicht vergessen: **Verbindung schlie√üen** bei Unmount

---

## üîó Quellen

- [MDN: WebSocket API](https://developer.mozilla.org/de/docs/Web/API/WebSocket)  
- [React + WebSocket Guide ‚Äì LogRocket](https://blog.logrocket.com/using-websocket-react-guide/)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

79. ### <a name="79"></a> Wie kann man Daten zwischen Komponenten weitergeben?

# Wie kann man Daten zwischen Komponenten weitergeben?

In React gibt es mehrere Wege, **Daten zwischen Komponenten** auszutauschen.  
Welcher Weg sinnvoll ist, h√§ngt davon ab, **wie die Komponenten zueinander stehen**.

---

## 1Ô∏è‚É£ Parent ‚Üí Child: via **Props**

Der klassische und einfachste Weg:  
Elternkomponente √ºbergibt Daten an Kindkomponente als `props`.

```jsx
function Child({ username }) {
  return <p>Hallo, {username}!</p>;
}

function Parent() {
  return <Child username="Sergii" />;
}
```

‚û°Ô∏è Einfache, **unidirektionale Datenweitergabe**.

---

## 2Ô∏è‚É£ Child ‚Üí Parent: via **Callback-Funktion als Prop**

Kindkomponente ruft eine Funktion auf, die der Elternkomponente geh√∂rt.

```jsx
function Child({ onNameChange }) {
  return <input onChange={(e) => onNameChange(e.target.value)} />;
}

function Parent() {
  const [name, setName] = useState('');
  return (
    <>
      <Child onNameChange={setName} />
      <p>Name: {name}</p>
    </>
  );
}
```

‚û°Ô∏è **"Lifting State Up"**: Eltern verwalten den Zustand.

---

## 3Ô∏è‚É£ Geschwister-Komponenten (Sibling ‚Üí Sibling): via **gemeinsamen Eltern-State**

Beide Kinder greifen auf den **Zustand in der Elternkomponente** zu.

```jsx
function Input({ onChange }) {
  return <input onChange={(e) => onChange(e.target.value)} />;
}

function Display({ value }) {
  return <p>Wert: {value}</p>;
}

function Parent() {
  const [text, setText] = useState('');
  return (
    <>
      <Input onChange={setText} />
      <Display value={text} />
    </>
  );
}
```

---

## 4Ô∏è‚É£ Tief verschachtelte Komponenten: via **Context API**

Nutze `createContext`, `Provider` und `useContext`,  
um Daten **global im Baum** verf√ºgbar zu machen.

```jsx
const ThemeContext = createContext();

function App() {
  return (
    <ThemeContext.Provider value="dark">
      <DeepChild />
    </ThemeContext.Provider>
  );
}

function DeepChild() {
  const theme = useContext(ThemeContext);
  return <p>Aktuelles Theme: {theme}</p>;
}
```

---

## 5Ô∏è‚É£ App-weite Zust√§nde: via **State-Management** (z.‚ÄØB. Redux, Zustand)

F√ºr sehr gro√üe Apps oder komplexe Interaktionen.

```jsx
// Redux: useSelector, useDispatch
// Zustand: useStore()
// Recoil, Jotai, MobX = Alternativen
```

---

## üìù Zusammenfassung

| Beziehung          | L√∂sung                         |
|--------------------|---------------------------------|
| Eltern ‚Üí Kind      | Props                          |
| Kind ‚Üí Eltern      | Callback-Funktion als Prop     |
| Geschwister        | Gemeinsamer Eltern-State       |
| Tief verschachtelt | Context API                    |
| Global             | State-Management-Library       |

---

## üîó Quellen

- [React ‚Äì Props](https://react.dev/learn/passing-props-to-a-component)  
- [React ‚Äì State Heben](https://react.dev/learn/sharing-state-between-components)  
- [React ‚Äì Context API](https://react.dev/learn/passing-data-deeply-with-context)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

80. ### <a name="80"></a> Wie macht man einen Datenabruf nur beim ersten Rendern?

# Wie macht man einen Datenabruf nur beim ersten Rendern in React?

Um eine API-Anfrage **nur einmal beim ersten Laden der Komponente** durchzuf√ºhren,  
nutzt man den Hook **`useEffect` mit leerem Abh√§ngigkeits-Array `[]`**.

---

## üí° Beispiel: API-Fetch beim Mount

```jsx
import { useEffect, useState } from 'react';

function UserList() {
  const [users, setUsers] = useState([]);

  useEffect(() => {
    fetch('https://jsonplaceholder.typicode.com/users')
      .then((res) => res.json())
      .then((data) => setUsers(data));
  }, []); // ‚Üê nur beim ersten Rendern!

  return (
    <ul>
      {users.map((u) => (
        <li key={u.id}>{u.name}</li>
      ))}
    </ul>
  );
}
```

---

## üìå Erkl√§rung

- Das leere Array `[]` bedeutet:  
  **Dieser Effekt l√§uft nur einmal ‚Äì beim ersten Rendern (Mount)**.
- Keine erneute Ausf√ºhrung bei Re-Renders oder State-√Ñnderungen

---

## üîÅ Alternative: Async-Funktion in `useEffect`

Da `useEffect` keine `async`-Funktion direkt erlaubt:

```jsx
useEffect(() => {
  async function fetchData() {
    const res = await fetch('...');
    const data = await res.json();
    setUsers(data);
  }

  fetchData();
}, []);
```

---

## üìù Zusammenfassung

- Verwende `useEffect(() => { ... }, [])`, um einen Effekt **nur einmal beim ersten Rendern** auszuf√ºhren  
- Ideal f√ºr **API-Anfragen, Initialdaten oder Setup-Logik**  
- Async-Aufrufe m√ºssen in eine **innere Funktion** ausgelagert werden

---

## üîó Quellen

- [React Docs ‚Äì useEffect](https://react.dev/reference/react/useEffect)  
- [Daten beim Mount laden ‚Äì React Patterns](https://reactpatterns.com/#fetch-on-mount)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

81. ### <a name="81"></a> Was ist das Problem bei ‚Äûstale closures‚Äú mit Hooks?

# Was ist das Problem bei ‚Äûstale closures‚Äú mit Hooks?

Ein **‚Äûstale closure‚Äú** (veraltete Funktionseinbettung) tritt auf,  
wenn eine **Funktion in einem Hook (z.‚ÄØB. `useEffect`, `setInterval`, `addEventListener`)**  
auf **einen veralteten Wert aus dem vorherigen Render** zugreift.

---

## üì¶ Was ist eine Closure?

Eine **Closure** ist eine Funktion, die Zugriff auf Variablen aus dem **Umgebungskontext** (z.‚ÄØB. vorherigem Render) hat.

Wenn ein Hook eine Funktion verwendet, ‚Äûmerkt‚Äú sich diese Funktion **den Zustand des Wertes zu diesem Zeitpunkt**.

---

## üí° Beispiel: Problem mit `setInterval`

```jsx
function Timer() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const id = setInterval(() => {
      setCount(count + 1); // ‚ùå count ist immer 0!
    }, 1000);

    return () => clearInterval(id);
  }, []);
  
  return <p>Z√§hler: {count}</p>;
}
```

### üî¥ Problem:

- Die `count`-Variable ist **eingefroren (stale)** bei `0`, weil `useEffect` nur **einmal** ausgef√ºhrt wird
- Der Callback in `setInterval` ‚Äûsieht‚Äú nie die neuen `count`-Werte

---

## ‚úÖ L√∂sung 1: Funktionales `setState`

```jsx
setCount((prev) => prev + 1);
```

```jsx
useEffect(() => {
  const id = setInterval(() => {
    setCount((prev) => prev + 1); // ‚úÖ aktueller Wert
  }, 1000);

  return () => clearInterval(id);
}, []);
```

‚û°Ô∏è `prev` wird **zur aktuellen Version** von `count`, unabh√§ngig vom Closure

---

## ‚úÖ L√∂sung 2: useRef f√ºr aktuelle Werte

```jsx
const countRef = useRef(count);

useEffect(() => {
  countRef.current = count;
}, [count]);

useEffect(() => {
  const id = setInterval(() => {
    console.log(countRef.current); // immer aktuell
  }, 1000);

  return () => clearInterval(id);
}, []);
```

‚û°Ô∏è `useRef` bleibt **zwischen Renders gleich** und kann **aktualisiert** werden.

---

## üìù Zusammenfassung

- Ein **stale closure** tritt auf, wenn eine Funktion auf **veraltete Werte** zugreift  
- Typisch bei: `setInterval`, `useEffect`, Event-Handlern  
- L√∂sungen:
  - ‚úÖ Funktionales `setState`
  - ‚úÖ `useRef` zur Speicherung aktueller Werte

---

## üîó Quellen

- [React Docs ‚Äì useEffect Gotchas](https://react.dev/learn/synchronizing-with-effects#you-might-see-stale-values-inside-an-effect)  
- [Dan Abramov ‚Äì A Complete Guide to useEffect](https://overreacted.io/a-complete-guide-to-useeffect/)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

82. ### <a name="82"></a> Wie funktioniert die Fehlerbehandlung mit try/catch in React?

# Wie funktioniert die Fehlerbehandlung mit `try/catch` in React?

In React wird `try/catch` verwendet, um **synchronen und asynchronen Code** innerhalb von Funktionen  
(z.‚ÄØB. Event-Handlern, `async`-Funktionen) **gezielt abzusichern**.

‚ö†Ô∏è `try/catch` funktioniert **nicht f√ºr Renderfehler** in JSX ‚Äì daf√ºr ben√∂tigt man **Error Boundaries**.

---

## ‚úÖ Verwendung in Event-Handlern

```jsx
function Button() {
  const handleClick = () => {
    try {
      // synchroner Fehler
      throw new Error('Etwas ist schiefgelaufen!');
    } catch (err) {
      console.error('Fehler:', err.message);
    }
  };

  return <button onClick={handleClick}>Klick mich</button>;
}
```

---

## ‚úÖ Verwendung in `async`-Funktionen (z.‚ÄØB. Daten laden)

```jsx
function DataLoader() {
  const [data, setData] = useState(null);
  const [error, setError] = useState(null);

  useEffect(() => {
    async function fetchData() {
      try {
        const res = await fetch('https://api.example.com/data');
        if (!res.ok) throw new Error('Fehler beim Abrufen');
        const json = await res.json();
        setData(json);
      } catch (err) {
        setError(err.message);
      }
    }

    fetchData();
  }, []);

  if (error) return <p>‚ùå Fehler: {error}</p>;
  if (!data) return <p>‚è≥ L√§dt...</p>;
  return <pre>{JSON.stringify(data, null, 2)}</pre>;
}
```

---

## üî¥ Kein `try/catch` f√ºr Renderfehler

```jsx
function App() {
  try {
    return <ProblematicComponent />; // ‚ùå try/catch greift hier nicht
  } catch (e) {
    return <p>Fehler!</p>; // ‚ùå wird nicht erreicht
  }
}
```

‚û°Ô∏è React rendert **asynchron**, deshalb **fangen Error Boundaries** solche Fehler ab, nicht `try/catch`.

---

## üìù Zusammenfassung

| Fehlerquelle      | `try/catch` geeignet? | Alternative                     |
|------------------|------------------------|---------------------------------|
| Event-Handler     | ‚úÖ Ja                  | ‚Äî                               |
| `async`-Funktionen| ‚úÖ Ja                  | ‚Äî                               |
| Renderzeit (JSX)  | ‚ùå Nein                | ‚ùó `ErrorBoundary` verwenden     |

---

## üîó Quellen

- [React Docs ‚Äì Fehlerbehandlung](https://react.dev/learn/managing-errors)  
- [MDN ‚Äì try...catch](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Statements/try...catch)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

83. ### <a name="83"></a> Wie kann man ein Mock-API oder Mock Server verwenden?

# Wie kann man ein Mock-API oder Mock Server in React verwenden?

Ein **Mock-API** oder **Mock-Server** simuliert eine echte Backend-API,  
um die Entwicklung und das Testen von Frontend-Komponenten zu erm√∂glichen ‚Äì  
ohne auf ein echtes Backend warten zu m√ºssen.

---

## üéØ Vorteile

- Unabh√§ngige Entwicklung von Frontend und Backend
- Offline arbeiten m√∂glich
- Schnelleres Testen von UI-Logik
- Kontrolle √ºber Antwortdaten, Fehler, Ladezeiten

---

## ‚úÖ M√∂glichkeiten f√ºr Mocking

### 1Ô∏è‚É£ **JSON Server (lokal)**

Schneller REST-API-Mock √ºber eine JSON-Datei.

#### üîß Installation:

```bash
npm install -g json-server
```

#### üìÅ `db.json`

```json
{
  "users": [
    { "id": 1, "name": "Alice" },
    { "id": 2, "name": "Bob" }
  ]
}
```

#### üöÄ Starten:

```bash
json-server --watch db.json --port 4000
```

‚û°Ô∏è API verf√ºgbar unter `http://localhost:4000/users`

---

### 2Ô∏è‚É£ **Mock Service Worker (MSW)** ‚Äì empfohlen f√ºr komplexe Szenarien

Interceptet echte Requests auf Netzwerkebene ‚Üí realistisch & flexibel.

#### üîß Installation:

```bash
npm install msw --save-dev
```

#### üìÅ Beispiel-Handler:

```js
// src/mocks/handlers.js
import { rest } from 'msw';

export const handlers = [
  rest.get('/api/users', (req, res, ctx) => {
    return res(
      ctx.status(200),
      ctx.json([{ id: 1, name: 'Sergii' }, { id: 2, name: 'Anna' }])
    );
  }),
];
```

#### üß© Setup:

```js
// src/mocks/browser.js
import { setupWorker } from 'msw';
import { handlers } from './handlers';

export const worker = setupWorker(...handlers);
```

```js
// index.js
if (process.env.NODE_ENV === 'development') {
  const { worker } = require('./mocks/browser');
  worker.start();
}
```

---

### 3Ô∏è‚É£ **Online-Tools / √∂ffentliche APIs**

- [https://reqres.in](https://reqres.in)
- [https://jsonplaceholder.typicode.com](https://jsonplaceholder.typicode.com)
- [https://mockapi.io](https://mockapi.io)

‚û°Ô∏è Gut f√ºr schnelles Testen ohne lokale Einrichtung

---

## üìù Zusammenfassung

| Methode         | Geeignet f√ºr                  | Vorteile                    |
|------------------|-------------------------------|-----------------------------|
| `json-server`    | Lokale Fake-REST-API          | Schnell, einfach            |
| `msw`            | Realistisches Mocking (XHR)   | Sehr m√§chtig, intercepts    |
| `mockapi.io`     | Online-Testing                | Kein Setup n√∂tig            |

---

## üîó Quellen

- [Mock Service Worker ‚Äì offizielle Website](https://mswjs.io)  
- [JSON Server ‚Äì GitHub](https://github.com/typicode/json-server)  
- [jsonplaceholder ‚Äì Fake API](https://jsonplaceholder.typicode.com)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

84. ### <a name="84"></a> Wie funktioniert Suspense f√ºr Datenabfragen?

# Wie funktioniert `React.Suspense` f√ºr Datenabfragen?

`React.Suspense` erlaubt es, **asynchrone Datenladevorg√§nge** elegant zu behandeln,  
indem eine **Fallback-UI** (z.‚ÄØB. Ladeanzeige) angezeigt wird,  
solange **komponentenabh√§ngige Daten noch nicht verf√ºgbar** sind.

---

## ‚ö†Ô∏è Wichtig:

- Suspense f√ºr Daten funktioniert **nur mit speziellen Data Fetching Libraries**, z.‚ÄØB.:
  - **React Query (TanStack Query)**
  - **Relay**
  - oder man schreibt einen eigenen **Wrapper mit `Promise`-suspending**

---

## ‚úÖ Beispiel mit React Query (empfohlener Weg)

### üîß Setup:

```bash
npm install @tanstack/react-query
```

### üì¶ App mit QueryClient + Suspense:

```jsx
import {
  QueryClient,
  QueryClientProvider,
  useQuery,
} from '@tanstack/react-query';
import { Suspense } from 'react';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      suspense: true,
    },
  },
});

function Users() {
  const { data } = useQuery({
    queryKey: ['users'],
    queryFn: () =>
      fetch('https://jsonplaceholder.typicode.com/users').then((res) =>
        res.json()
      ),
  });

  return (
    <ul>
      {data.map((u) => (
        <li key={u.id}>{u.name}</li>
      ))}
    </ul>
  );
}

export default function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <Suspense fallback={<p>‚è≥ L√§dt Benutzer...</p>}>
        <Users />
      </Suspense>
    </QueryClientProvider>
  );
}
```

---

## üß† Was passiert hier?

- **`Suspense`** zeigt das `fallback`, solange `Users` noch l√§dt.
- Sobald `useQuery` Daten geladen hat, wird `fallback` ersetzt.
- Vorteil: Kein explizites `isLoading` oder `error` n√∂tig ‚Üí cleaner Code

---

## üîÅ Alternative: Eigene Datenquelle mit `suspense`-like Verhalten

```jsx
function wrapPromise(promise) {
  let status = 'pending';
  let result;
  const suspender = promise.then(
    (r) => {
      status = 'success';
      result = r;
    },
    (e) => {
      status = 'error';
      result = e;
    }
  );

  return {
    read() {
      if (status === 'pending') throw suspender;
      if (status === 'error') throw result;
      return result;
    },
  };
}
```

‚û°Ô∏è Diese Technik ist eher experimentell.

---

## üìù Zusammenfassung

- `Suspense` kann Ladezust√§nde abfangen und Fallback anzeigen
- F√ºr Daten: funktioniert nur mit Libraries wie **React Query** oder **Relay**
- Vorteil: **automatisches Laden + saubere Trennung von UI & Logik**

---

## üîó Quellen

- [React Suspense f√ºr Daten ‚Äì React Docs](https://react.dev/reference/react/Suspense)  
- [TanStack Query mit Suspense](https://tanstack.com/query/latest/docs/react/guides/suspense)  
- [MDN: Promises](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Promise)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

85. ### <a name="85"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

86. ### <a name="86"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

87. ### <a name="87"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

88. ### <a name="88"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

89. ### <a name="89"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

90. ### <a name="90"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

91. ### <a name="91"></a> Was ist Unit-, Integration- und E2E-Testing?

# Was ist Unit-, Integration- und E2E-Testing in der Webentwicklung?

Beim Testen von Anwendungen unterscheidet man drei zentrale Testarten:  
**Unit-Tests**, **Integrationstests** und **End-to-End-Tests (E2E)**.  
Sie pr√ºfen den Code auf verschiedenen Ebenen.

---

## ‚úÖ 1. Unit-Testing (Einheitentest)

**Testet eine einzelne Funktion oder Komponente isoliert.**

### Ziel:
- Pr√ºfen, ob eine **kleine logische Einheit** korrekt funktioniert

### Beispiel:

```jsx
// sum.js
export function sum(a, b) {
  return a + b;
}

// sum.test.js
import { sum } from './sum';

test('addiert zwei Zahlen korrekt', () => {
  expect(sum(2, 3)).toBe(5);
});
```

### Tools:
- **Jest**, **Vitest**, **Mocha**

---

## ‚úÖ 2. Integrationstests

**Testet das Zusammenspiel mehrerer Einheiten.**

### Ziel:
- Sicherstellen, dass **Komponenten oder Module korrekt interagieren**

### Beispiel:

```jsx
// LoginForm.js mit Input + Button + Handler
// Integrationstest pr√ºft, ob das Form korrekt absendet

import { render, screen, fireEvent } from '@testing-library/react';
import LoginForm from './LoginForm';

test('LoginForm ruft onSubmit mit richtigen Daten auf', () => {
  const handleSubmit = jest.fn();
  render(<LoginForm onSubmit={handleSubmit} />);

  fireEvent.change(screen.getByLabelText(/email/i), {
    target: { value: 'test@mail.com' },
  });
  fireEvent.click(screen.getByText(/einloggen/i));

  expect(handleSubmit).toHaveBeenCalledWith({
    email: 'test@mail.com',
  });
});
```

### Tools:
- **React Testing Library**, **Jest**

---

## ‚úÖ 3. E2E-Testing (End-to-End)

**Testet die gesamte App vom Nutzer aus betrachtet (UI + Backend).**

### Ziel:
- Simulieren, wie ein **echter Benutzer** mit der App interagiert
- Test umfasst: Browser, Klicks, Navigation, API, Server

### Beispiel:

```js
// login.spec.js mit Cypress

describe('Login Flow', () => {
  it('meldet sich erfolgreich an', () => {
    cy.visit('/login');
    cy.get('input[name="email"]').type('user@mail.com');
    cy.get('input[name="password"]').type('pass123');
    cy.get('button[type="submit"]').click();
    cy.contains('Willkommen, user@mail.com');
  });
});
```

### Tools:
- **Cypress**, **Playwright**, **TestCafe**

---

## üìä Vergleich

| Testtyp        | Umfang             | Geschwindigkeit | Stabilit√§t | Fehlerursache erkennbar |
|----------------|--------------------|------------------|------------|--------------------------|
| Unit-Test      | Sehr klein (1 Unit)| üü¢ Sehr schnell  | üü¢ Hoch     | üéØ Sehr pr√§zise          |
| Integration    | Mittelgro√ü         | üü° Mittel         | üü° Gut      | üéØ Meist klar            |
| E2E-Test       | Ganze App (UI/API) | üî¥ Langsam        | üî¥ Weniger stabil | ‚ö†Ô∏è Fehler schwerer zu debuggen |

---

## üìù Zusammenfassung

| Testart      | Was wird getestet?                            | Tools                    |
|--------------|-----------------------------------------------|--------------------------|
| Unit         | Einzelne Funktion oder Komponente             | Jest, Vitest             |
| Integration  | Zusammenspiel mehrerer Komponenten            | React Testing Library    |
| E2E          | Gesamter Ablauf aus Sicht des Benutzers       | Cypress, Playwright      |

---

## üîó Quellen

- [Jest ‚Äì Unit Testing](https://jestjs.io/docs/getting-started)  
- [React Testing Library](https://testing-library.com/docs/react-testing-library/intro/)  
- [Cypress E2E Testing](https://www.cypress.io)  
- [Playwright Testing](https://playwright.dev)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

92. ### <a name="92"></a> Was ist Snapshot-Testing?

# Was ist Snapshot-Testing in React?

**Snapshot-Testing** ist eine Testmethode, bei der die **Ausgabe einer Komponente** gespeichert  
und bei jedem Testlauf automatisch mit dem vorherigen **‚ÄûSnapshot‚Äú** verglichen wird.  
So erkennt man unbeabsichtigte √Ñnderungen in der UI.

---

## üéØ Ziel

- Sicherstellen, dass sich die gerenderte Ausgabe einer Komponente **nicht unerwartet ver√§ndert**
- Ideal f√ºr **pr√§sentationsorientierte Komponenten** (UI, Layout)

---

## üß™ Beispiel mit Jest

```jsx
// Hello.jsx
function Hello({ name }) {
  return <h1>Hallo, {name}!</h1>;
}

export default Hello;
```

```jsx
// Hello.test.js
import { render } from '@testing-library/react';
import Hello from './Hello';

test('erstellt einen Snapshot der Hello-Komponente', () => {
  const { asFragment } = render(<Hello name="Sergii" />);
  expect(asFragment()).toMatchSnapshot();
});
```

### ‚ûï Beim ersten Testlauf:

Es wird eine Datei erstellt:  
`__snapshots__/Hello.test.js.snap` mit dem HTML-Output:

```txt
<document-fragment>
  <h1>Hallo, Sergii!</h1>
</document-fragment>
```

### üîÅ Bei weiteren Testl√§ufen:

- Wenn sich der HTML-Output **√§ndert**, schl√§gt der Test fehl
- Man kann dann entscheiden:  
  - ‚úÖ ‚Äû√Ñnderung gewollt‚Äú ‚Üí `jest -u` zum **aktualisieren**  
  - ‚ùå ‚ÄûFehlerhaft‚Äú ‚Üí Komponente korrigieren

---

## üì¶ Vorteile

- Schnell und einfach f√ºr reine UI-Komponenten
- Automatisches Erkennen von √Ñnderungen

---

## ‚ö†Ô∏è Nachteile

- Snapshots k√∂nnen **zu gro√ü** und **unn√ºtz** werden, wenn man zu viele auf einmal testet
- √Ñnderungen im Output ‚â† tats√§chlicher Fehler

‚û°Ô∏è Nicht geeignet f√ºr **Logiktests** oder dynamische Inhalte

---

## üìù Zusammenfassung

- Snapshot-Tests vergleichen JSX-Output mit gespeicherten Referenzwerten
- Verwende `toMatchSnapshot()` z.‚ÄØB. mit **Jest** + **Testing Library**
- Nur sinnvoll f√ºr **statische, visuelle Komponenten**

---

## üîó Quellen

- [Jest ‚Äì Snapshot Testing](https://jestjs.io/docs/snapshot-testing)  
- [React Testing Library ‚Äì Snapshots](https://testing-library.com/docs/react-testing-library/api/#asfragment)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

93. ### <a name="93"></a> Welche Tools nutzt man f√ºr React-Tests (Jest, React Testing Library)?

# Welche Tools nutzt man f√ºr React-Tests?

In der React-Entwicklung sind die g√§ngigsten Test-Tools:

1. **Jest** ‚Äì Test-Runner + Assertion-Bibliothek  
2. **React Testing Library (RTL)** ‚Äì UI-Verhalten aus Nutzersicht testen  
3. Weitere: **Vitest**, **MSW**, **Cypress**, **Playwright**

---

## ‚úÖ 1. Jest

üõ† **Test-Runner**, **Mocking**, **Snapshot-Testing**, **Assertions**

```bash
npm install --save-dev jest
```

- L√§uft JavaScript-Tests (z.‚ÄØB. `.test.js`)
- Unterst√ºtzt `describe`, `test`, `expect`, `beforeEach` etc.
- Integriert gut mit Babel, TypeScript und React

### Beispiel:

```js
test('addiert zwei Zahlen', () => {
  expect(2 + 2).toBe(4);
});
```

üìò [Jest Docs](https://jestjs.io/docs/getting-started)

---

## ‚úÖ 2. React Testing Library (RTL)

üîç Testet **Komponentenverhalten aus Sicht des Nutzers**

```bash
npm install --save-dev @testing-library/react
```

- Zugriff auf UI via `getByText`, `getByRole`, `getByLabelText`
- Kein Zugriff auf Implementierungsdetails
- Gute Best Practices durch Design

### Beispiel:

```jsx
import { render, screen } from '@testing-library/react';
import Button from './Button';

test('zeigt Buttontext korrekt an', () => {
  render(<Button>Speichern</Button>);
  expect(screen.getByText('Speichern')).toBeInTheDocument();
});
```

üìò [React Testing Library Docs](https://testing-library.com/docs/react-testing-library/intro/)

---

## ‚úÖ 3. Vitest (Alternative zu Jest)

üöÄ Schneller Test-Runner f√ºr Vite-Projekte

```bash
npm install --save-dev vitest
```

- Kompatibel mit Jest-API
- Schneller durch native ESModules

üìò [Vitest Docs](https://vitest.dev)

---

## ‚úÖ 4. MSW (Mock Service Worker)

üß™ Simuliert echte API-Requests im Test oder Browser

```bash
npm install msw --save-dev
```

üìò [MSW Docs](https://mswjs.io)

---

## ‚úÖ 5. Cypress / Playwright

üß≠ F√ºr **End-to-End (E2E)**-Tests im echten Browser

- Simuliert Nutzerverhalten: klicken, tippen, navigieren
- Cypress zielt auf Entwicklerfreundlichkeit
- Playwright testet auch mehrere Browser

üìò [Cypress.io](https://www.cypress.io)  
üìò [Playwright.dev](https://playwright.dev)

---

## üìù Zusammenfassung

| Tool                   | Zweck                     | Beschreibung                              |
|------------------------|---------------------------|--------------------------------------------|
| **Jest**               | Unit + Snapshot Tests     | Test-Runner & Mocking                      |
| **React Testing Library** | Integration/Component | Testet aus Nutzersicht                     |
| **Vitest**             | Schnelle Alternative      | Besonders f√ºr Vite-Projekte                |
| **MSW**                | Mocking API               | Reale Netzwerkrequests simulieren         |
| **Cypress / Playwright** | E2E Testing             | UI-Tests im echten Browser                 |

---

## üîó Weitere Links

- [Testing in React ‚Äì Offizielle Doku](https://react.dev/learn/testing)  
- [Testing Library ‚Äì Guide](https://testing-library.com/docs/)  
- [Jest ‚Äì Snapshot Testing](https://jestjs.io/docs/snapshot-testing)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

94. ### <a name="94"></a> Wie testet man Komponenten, Props und Events?

# Wie testet man Komponenten, Props und Events in React?

Beim Testen von React-Komponenten geht es darum zu pr√ºfen, ob:

1. Die **Komponente korrekt rendert**
2. **Props richtig verwendet** werden
3. **Benutzerinteraktionen (Events)** korrekt funktionieren

Daf√ºr nutzt man typischerweise:

- **React Testing Library** (RTL)
- **Jest** als Test-Runner

---

## ‚úÖ 1. Komponente rendern und Inhalt testen

```jsx
import { render, screen } from '@testing-library/react';
import Greeting from './Greeting';

test('zeigt Begr√º√üung an', () => {
  render(<Greeting name="Sergii" />);
  expect(screen.getByText(/Hallo, Sergii/i)).toBeInTheDocument();
});
```

---

## ‚úÖ 2. Props testen

Du testest **indirekt**, ob Props korrekt verwendet wurden ‚Äì  
z.‚ÄØB. durch gerendeten Text oder Verhalten.

```jsx
function Title({ text }) {
  return <h1>{text}</h1>;
}

// Test
test('zeigt den Titel-Prop korrekt an', () => {
  render(<Title text="Dashboard" />);
  expect(screen.getByText('Dashboard')).toBeInTheDocument();
});
```

---

## ‚úÖ 3. Events testen (z.‚ÄØB. Button-Klick)

```jsx
function Button({ onClick }) {
  return <button onClick={onClick}>Klick mich</button>;
}

// Test
import userEvent from '@testing-library/user-event';

test('ruft onClick beim Klicken auf', async () => {
  const handleClick = jest.fn();
  render(<Button onClick={handleClick} />);

  await userEvent.click(screen.getByText('Klick mich'));
  expect(handleClick).toHaveBeenCalledTimes(1);
});
```

---

## üõ† Tools & Methoden (RTL)

| Methode                   | Beschreibung                                  |
|---------------------------|-----------------------------------------------|
| `render()`                | Rendert die Komponente f√ºr den Test           |
| `screen.getByText()`      | Findet Elemente am Bildschirm                 |
| `userEvent.click()`       | Simuliert Benutzeraktionen                    |
| `jest.fn()`               | Erstellt Mockfunktionen f√ºr Eventhandler      |
| `toBeInTheDocument()`     | Pr√ºft, ob ein Element im DOM enthalten ist    |

---

## üìù Zusammenfassung

| Was wird getestet?      | Wie?                            |
|-------------------------|---------------------------------|
| Komponenteninhalte      | `screen.getByText`, `render()`  |
| Props                   | Text oder Verhalten √ºberpr√ºfen  |
| Events (z.‚ÄØB. Klicks)   | `userEvent`, `jest.fn()`        |

---

## üîó Quellen

- [React Testing Library ‚Äì Intro](https://testing-library.com/docs/react-testing-library/intro/)  
- [Jest ‚Äì Mock Functions](https://jestjs.io/docs/mock-functions)  
- [React Docs ‚Äì Testing UI](https://react.dev/learn/testing)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

95. ### <a name="95"></a> Wie testet man benutzerdefinierte Hooks?

# Wie testet man benutzerdefinierte Hooks in React?

Benutzerdefinierte Hooks (`useXXX`) enthalten wiederverwendbare Logik.  
Um sie zu testen, verwendet man:

- ‚úÖ **`@testing-library/react-hooks`** (√§lter, eingestellt)  
- ‚úÖ **`@testing-library/react` + eigene Testkomponente**  
- ‚úÖ **`@testing-library/react-hooks/dom`** (aus `@tanstack/react-hooks-testing-library`)

> Der moderne Weg ist: **React-Hooks innerhalb eines Testkomponenten-Kontextes rendern**.

---

## üì¶ Beispiel: Eigener Hook

```jsx
// useCounter.js
import { useState } from 'react';

export function useCounter(initial = 0) {
  const [count, setCount] = useState(initial);
  const increment = () => setCount((c) => c + 1);
  return { count, increment };
}
```

---

## ‚úÖ Variante 1: Test mit Testkomponente (Standard mit RTL)

```jsx
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { useCounter } from './useCounter';

function TestComponent() {
  const { count, increment } = useCounter();
  return (
    <>
      <p>Count: {count}</p>
      <button onClick={increment}>+</button>
    </>
  );
}

test('useCounter erh√∂ht den Wert', async () => {
  render(<TestComponent />);
  const button = screen.getByText('+');

  await userEvent.click(button);
  expect(screen.getByText('Count: 1')).toBeInTheDocument();
});
```

---

## ‚úÖ Variante 2: `@testing-library/react-hooks` (wenn n√∂tig)

```bash
npm install --save-dev @testing-library/react-hooks
```

```jsx
import { renderHook, act } from '@testing-library/react-hooks';
import { useCounter } from './useCounter';

test('useCounter funktioniert korrekt', () => {
  const { result } = renderHook(() => useCounter(0));

  expect(result.current.count).toBe(0);

  act(() => {
    result.current.increment();
  });

  expect(result.current.count).toBe(1);
});
```

> ‚ö†Ô∏è Diese Variante wird **nicht mehr aktiv gepflegt**.

---

## üìù Zusammenfassung

| Methode                            | Vorteil                          |
|------------------------------------|----------------------------------|
| ‚úÖ Eigene Test-Komponente           | Kompatibel mit `@testing-library/react` |
| ‚ö†Ô∏è `@testing-library/react-hooks`   | F√ºr reine Hook-Tests (√§lter)     |

---

## üîó Quellen

- [React Testing Library ‚Äì Hooks testen](https://testing-library.com/docs/example-react-hooks)  
- [React-Hooks-Test-Bibliothek ‚Äì TanStack](https://github.com/TanStack/testing-react-hooks)  
- [React Docs ‚Äì eigene Hooks schreiben](https://react.dev/learn/reusing-logic-with-custom-hooks)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

96. ### <a name="96"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

97. ### <a name="97"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

98. ### <a name="98"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

99. ### <a name="99"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

100. ### <a name="100"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**    

101. ### <a name="101"></a> Wie funktioniert Routing in React mit react-router-dom?

# Wie funktioniert Routing in React mit `react-router-dom`?

`react-router-dom` ist die Standard-Bibliothek f√ºr **Client-seitiges Routing** in React.  
Sie erm√∂glicht die Navigation zwischen Seiten **ohne Neuladen** der Website.

---

## üì¶ Installation

```bash
npm install react-router-dom
```

---

## üß± Grundkonzepte

| Komponente          | Zweck                                          |
|---------------------|-------------------------------------------------|
| `<BrowserRouter>`   | Wurzel-Router, verwendet HTML5 History API     |
| `<Routes>`          | Container f√ºr alle Routen                      |
| `<Route>`           | Definiert eine einzelne Route                  |
| `<Link>`            | Navigation ohne Seiten-Reload                  |
| `useNavigate()`     | Programmatische Navigation                     |
| `useParams()`       | Zugriff auf URL-Parameter                      |

---

## ‚úÖ Beispiel: Basis-Routing

```jsx
import { BrowserRouter, Routes, Route, Link } from 'react-router-dom';

function Home() {
  return <h2>Startseite</h2>;
}

function About() {
  return <h2>√úber uns</h2>;
}

function App() {
  return (
    <BrowserRouter>
      <nav>
        <Link to="/">Start</Link> | <Link to="/about">√úber</Link>
      </nav>

      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
      </Routes>
    </BrowserRouter>
  );
}
```

---

## üìå Dynamische Routen mit Parametern

```jsx
// URL: /user/123

function UserPage() {
  const { id } = useParams();
  return <p>User ID: {id}</p>;
}

<Routes>
  <Route path="/user/:id" element={<UserPage />} />
</Routes>
```

---

## üöÄ Navigation per Code (z.‚ÄØB. nach Login)

```jsx
import { useNavigate } from 'react-router-dom';

function LoginButton() {
  const navigate = useNavigate();

  const handleLogin = () => {
    // ...Login-Logik
    navigate('/dashboard'); // Weiterleitung
  };

  return <button onClick={handleLogin}>Login</button>;
}
```

---

## üîÅ Weiterleitungen

```jsx
import { Navigate } from 'react-router-dom';

<Route path="/alt" element={<Navigate to="/neu" />} />
```

---

## üìù Zusammenfassung

- Routing wird mit `BrowserRouter`, `Routes` und `Route` umgesetzt
- Navigation per `<Link>` oder `useNavigate()`
- Dynamische Parameter via `:id` und `useParams()`
- Kein Seitenreload n√∂tig ‚Üí **Single Page Application (SPA)**

---

## üîó Quellen

- [React Router Doku](https://reactrouter.com/en/main/start/tutorial)  
- [MDN ‚Äì Client-Side Routing](https://developer.mozilla.org/en-US/docs/Glossary/SPA)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

102. ### <a name="102"></a> Was sind die Unterschiede zwischen react-router v5 und v6?

# Was sind die Unterschiede zwischen `react-router-dom` v5 und v6?

`react-router-dom` v6 ist eine **komplett √ºberarbeitete Version** mit  
neuem Syntax, klarerer Struktur und vereinfachter Logik.  
Hier sind die wichtigsten Unterschiede zwischen v5 und v6:

---

## üîÑ 1. `<Switch>` ‚Üí **`<Routes>`**

- **v5:** `<Switch>` rendert die erste passende Route  
- **v6:** `<Routes>` ersetzt `<Switch>` und **rendert nur genau eine Route**

```jsx
// v5
<Switch>
  <Route path="/about" component={About} />
</Switch>

// v6
<Routes>
  <Route path="/about" element={<About />} />
</Routes>
```

---

## ‚öõÔ∏è 2. `component` vs `element`

- **v5:** `component={MyComponent}`
- **v6:** `element={<MyComponent />}` (JSX wird erwartet)

```jsx
// v5
<Route path="/home" component={Home} />

// v6
<Route path="/home" element={<Home />} />
```

---

## üß≠ 3. `Redirect` ‚Üí **`<Navigate />`**

- **v5:** `<Redirect to="/login" />`
- **v6:** `<Navigate to="/login" />`

```jsx
// v6 Beispiel
<Route path="*" element={<Navigate to="/" />} />
```

---

## üß¨ 4. Verschachtelte Routen (Nested Routes)

- **v6** nutzt **nested `<Route>`** mit `outlet`-Konzept

```jsx
// v6
<Routes>
  <Route path="/dashboard" element={<Dashboard />}>
    <Route path="profile" element={<Profile />} />
    <Route path="settings" element={<Settings />} />
  </Route>
</Routes>
```

```jsx
// Dashboard.jsx
import { Outlet } from 'react-router-dom';
export default function Dashboard() {
  return (
    <div>
      <h1>Dashboard</h1>
      <Outlet />
    </div>
  );
}
```

---

## ‚ö†Ô∏è 5. `exact` ist **nicht mehr n√∂tig**

- **v6 matcht automatisch exakt**
- In v5 war `exact` notwendig, um √úberlappung zu vermeiden

```jsx
// v5
<Route exact path="/" component={Home} />

// v6
<Route path="/" element={<Home />} /> // exact implizit
```

---

## ‚úÖ 6. Neue Features in v6

| Feature                | Beschreibung                                    |
|------------------------|-------------------------------------------------|
| `<Outlet />`           | F√ºr Nested Routing                             |
| `useRoutes()`          | Routing mit Objekt-Definition                   |
| `createBrowserRouter`  | F√ºr Data-Routing mit `react-router v6.4+`       |
| `Loader`, `Action`     | Neue API f√ºr Datenladen direkt in Route-Objekten|

---

## üìù Zusammenfassung

| Unterschied         | v5                        | v6                             |
|---------------------|---------------------------|--------------------------------|
| Routencontainer     | `<Switch>`                | `<Routes>`                     |
| Komponenten         | `component`/`render`      | `element={<... />}`            |
| Weiterleitung       | `<Redirect>`              | `<Navigate>`                   |
| Nested Routes       | Manuell / kompliziert     | Mit `<Outlet>` einfach         |
| `exact`             | Manuell n√∂tig             | Automatisch exakt              |

---

## üîó Quellen

- [React Router v6 Doku](https://reactrouter.com/en/main)  
- [Migration von v5 zu v6](https://reactrouter.com/en/main/start/overview#migrating-from-v5)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

103. ### <a name="103"></a> Was sind Route, Link, Navigate, Outlet?

# Was sind `Route`, `Link`, `Navigate`, `Outlet` in React Router?

Diese Komponenten stammen aus **`react-router-dom`** und bilden das Grundger√ºst  
f√ºr Navigation, Seitenwechsel und Seitenstruktur in React-Anwendungen.

---

## üîÅ `Route`

Definiert, **welche Komponente bei welcher URL angezeigt wird**.

```jsx
<Route path="/about" element={<About />} />
```

- Wird innerhalb von `<Routes>` verwendet
- `path` = URL-Pfad
- `element` = JSX-Komponente, die gerendert wird

---

## üîó `Link`

Erstellt **einen Link**, der beim Klicken die URL **√§ndert**,  
ohne die Seite neu zu laden (SPA-Verhalten).

```jsx
<Link to="/about">√úber uns</Link>
```

- Vergleichbar mit `<a href="..." />`, aber **Client-seitig**
- Nutzt History API intern
- Vorteil: Schnelle Navigation ohne Reload

---

## üöÄ `Navigate`

Ersetzt `<Redirect>` (aus v5).  
Wird verwendet, um **programmatisch weiterzuleiten**.

```jsx
<Route path="*" element={<Navigate to="/" />} />
```

Oder innerhalb einer Komponente:

```jsx
if (!isLoggedIn) {
  return <Navigate to="/login" />;
}
```

- Automatische Weiterleitung (z.‚ÄØB. nach Login, Fehler, Logout)

---

## üß© `Outlet`

Wird verwendet, um **geschachtelte Routen** (Nested Routes) einzuf√ºgen.

```jsx
// App.jsx
<Routes>
  <Route path="/dashboard" element={<Dashboard />}>
    <Route path="profile" element={<Profile />} />
  </Route>
</Routes>
```

```jsx
// Dashboard.jsx
import { Outlet } from 'react-router-dom';

function Dashboard() {
  return (
    <div>
      <h1>Dashboard</h1>
      <Outlet /> {/* Hier erscheint <Profile /> */}
    </div>
  );
}
```

---

## üìù Zusammenfassung

| Element      | Funktion                                      |
|--------------|-----------------------------------------------|
| `Route`      | Definiert, welche Komponente bei welcher URL |
| `Link`       | Navigation per Klick ohne Seitenreload        |
| `Navigate`   | Programmgesteuerte Weiterleitung               |
| `Outlet`     | Platzhalter f√ºr verschachtelte Routen         |

---

## üîó Quellen

- [React Router ‚Äì Startseite](https://reactrouter.com/en/main/start/tutorial)  
- [React Router ‚Äì API Referenz](https://reactrouter.com/en/main/components/route)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

104. ### <a name="104"></a> Wie erstellt man Nested Routes?

# Wie erstellt man Nested Routes in React Router (v6)?

**Nested Routes** (geschachtelte Routen) erm√∂glichen es,  
eine **Hauptkomponente mit untergeordnetem Inhalt** anzuzeigen,  
z.‚ÄØB. ein Dashboard mit Tabs wie ‚ÄûProfil‚Äú, ‚ÄûEinstellungen‚Äú usw.

---

## üß± Grundprinzip

- Verwende `<Route>` innerhalb eines anderen `<Route>`
- Platziere `<Outlet />` dort, wo die **Kind-Komponenten** erscheinen sollen

---

## ‚úÖ Beispiel

### üîß Struktur

```
/dashboard
/dashboard/profile
/dashboard/settings
```

---

### 1Ô∏è‚É£ Routen in `App.jsx`

```jsx
import { BrowserRouter, Routes, Route } from 'react-router-dom';
import Dashboard from './pages/Dashboard';
import Profile from './pages/Profile';
import Settings from './pages/Settings';

function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/dashboard" element={<Dashboard />}>
          <Route path="profile" element={<Profile />} />
          <Route path="settings" element={<Settings />} />
        </Route>
      </Routes>
    </BrowserRouter>
  );
}
```

---

### 2Ô∏è‚É£ `Dashboard.jsx` ‚Äì mit `<Outlet />`

```jsx
import { Outlet, Link } from 'react-router-dom';

function Dashboard() {
  return (
    <div>
      <h1>Dashboard</h1>
      <nav>
        <Link to="profile">Profil</Link> |{' '}
        <Link to="settings">Einstellungen</Link>
      </nav>
      <hr />
      <Outlet /> {/* ‚Üê hier erscheinen verschachtelte Komponenten */}
    </div>
  );
}

export default Dashboard;
```

---

### 3Ô∏è‚É£ Profile.jsx / Settings.jsx

```jsx
function Profile() {
  return <p>üë§ Benutzerprofil</p>;
}

function Settings() {
  return <p>‚öôÔ∏è Einstellungen</p>;
}
```

---

## üìù Zusammenfassung

| Schritt       | Was passiert?                             |
|---------------|--------------------------------------------|
| `Route`-Verschachtelung | Unterseiten innerhalb eines Hauptlayouts |
| `<Outlet />`   | Platzhalter f√ºr die aktive Kind-Komponente  |
| `Link`         | Navigation innerhalb der Unterrouten        |

---

## üîó Quellen

- [React Router ‚Äì Nested Routes](https://reactrouter.com/en/main/start/tutorial#nested-routes)  
- [React Docs ‚Äì Routing](https://react.dev/learn/start-a-new-react-project#routing)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

105. ### <a name="105"></a> Wie implementiert man Redirects?

# Wie implementiert man Redirects in React Router v6?

Ein **Redirect** (Weiterleitung) bedeutet, dass ein Benutzer  
automatisch von einer Route zu einer anderen Route umgeleitet wird.

In **React Router v6** nutzt man daf√ºr die Komponente **`<Navigate />`**.

---

## ‚úÖ 1. Statischer Redirect √ºber Route

```jsx
import { Routes, Route, Navigate } from 'react-router-dom';

function App() {
  return (
    <Routes>
      <Route path="/" element={<Home />} />
      <Route path="/start" element={<Navigate to="/" />} />
    </Routes>
  );
}
```

üìå `/start` ‚Üí `/` automatisch weitergeleitet

---

## ‚úÖ 2. Wildcard-Redirect (404-Fallback)

```jsx
<Route path="*" element={<Navigate to="/" />} />
```

üìå Alle unbekannten Pfade leiten zur Startseite um

---

## ‚úÖ 3. Programmgesteuerter Redirect (z.‚ÄØB. nach Login)

```jsx
import { useNavigate } from 'react-router-dom';

function LoginForm() {
  const navigate = useNavigate();

  function handleLogin() {
    // ...Login-Logik
    navigate('/dashboard'); // Weiterleitung nach Login
  }

  return <button onClick={handleLogin}>Login</button>;
}
```

---

## üîÑ 4. Bedingter Redirect

```jsx
function ProtectedPage({ isLoggedIn }) {
  if (!isLoggedIn) {
    return <Navigate to="/login" replace />;
  }

  return <p>Willkommen im gesch√ºtzten Bereich</p>;
}
```

- `replace` verhindert, dass die Weiterleitung in den Verlauf kommt (`history.back` geht nicht zur√ºck)

---

## üìù Zusammenfassung

| Typ                          | Methode                      |
|------------------------------|-------------------------------|
| Statische Weiterleitung      | `<Route path="..." element={<Navigate to="..." />} />` |
| Fallback (404)               | `<Route path="*" element={<Navigate to="/" />} />` |
| Logikbasiert (z.‚ÄØB. Login)   | `useNavigate()` Hook         |
| Bedingt in Komponente        | `{ isLoggedIn ? ... : <Navigate /> }` |

---

## üîó Quellen

- [React Router ‚Äì `<Navigate />`](https://reactrouter.com/en/main/components/navigate)  
- [React Router ‚Äì useNavigate Hook](https://reactrouter.com/en/main/hooks/use-navigate)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

106. ### <a name="106"></a> Wie funktioniert programmgesteuerte Navigation (useNavigate)?

# Wie funktioniert programmgesteuerte Navigation mit `useNavigate`?

Mit dem **Hook `useNavigate()`** aus `react-router-dom` kannst du  
**per Code** (statt durch Klick auf einen Link) zwischen Routen navigieren.

---

## ‚úÖ Verwendung

```jsx
import { useNavigate } from 'react-router-dom';

function LoginButton() {
  const navigate = useNavigate();

  const handleLogin = () => {
    // ‚úÖ Login-Logik
    // üîÑ Navigation nach erfolgreichem Login
    navigate('/dashboard');
  };

  return <button onClick={handleLogin}>Login</button>;
}
```

---

## üìå Optionen

```js
navigate('/ziel', {
  replace: true,   // ersetzt aktuellen Eintrag im Verlauf (kein Zur√ºck m√∂glich)
  state: { userId: 123 }, // optionaler Zustand, √ºber `location.state` abrufbar
});
```

---

## üì• Weitergabe von State

```jsx
navigate('/profile', { state: { userName: 'Sergii' } });
```

```jsx
// Ziel-Komponente
import { useLocation } from 'react-router-dom';

const location = useLocation();
console.log(location.state.userName); // "Sergii"
```

---

## üîÅ Dynamische Navigation mit Parametern

```jsx
navigate(`/user/${userId}`);
```

---

## üìù Zusammenfassung

| Funktion             | Beschreibung                         |
|----------------------|--------------------------------------|
| `useNavigate()`      | Hook zum Navigieren per Code         |
| `navigate('/pfad')`  | Navigation zur Zielroute             |
| `replace: true`      | Ersetzt History-Eintrag (kein Zur√ºck)|
| `state: {...}`       | √úbergibt Daten an Zielkomponente     |

---

## üîó Quellen

- [React Router ‚Äì useNavigate](https://reactrouter.com/en/main/hooks/use-navigate)  
- [React Router ‚Äì useLocation](https://reactrouter.com/en/main/hooks/use-location)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

107. ### <a name="107"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

108. ### <a name="108"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

109. ### <a name="109"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

110. ### <a name="110"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

111. ### <a name="111"></a> Was ist Redux und wie funktioniert es?

# Was ist Redux und wie funktioniert es?

**Redux** ist eine **State-Management-Bibliothek**,  
die hilft, **globalen Zustand zentral** zu verwalten ‚Äì besonders in gr√∂√üeren React-Apps.  
Sie basiert auf einem **Single Source of Truth** (ein globales Store-Objekt)  
und nutzt ein **unidirektionales Datenflussmodell**.

---

## üéØ Wann ist Redux n√ºtzlich?

- Viele Komponenten m√ºssen denselben Zustand verwenden oder ver√§ndern
- Du willst Zustand **vorhersagbar, nachvollziehbar und testbar** halten
- Du brauchst eine **klare Trennung von Logik und UI**

---

## üß† Grundkonzepte

| Begriff        | Beschreibung                                                                 |
|----------------|-------------------------------------------------------------------------------|
| `Store`        | Zentrale Datenquelle (globaler Zustand)                                      |
| `Action`       | Ein einfaches Objekt, das **beschreibt, was passieren soll**                 |
| `Reducer`      | Eine reine Funktion, die **neuen Zustand basierend auf Action erstellt**     |
| `Dispatch()`   | Methode, um eine Action an den Store zu senden                               |
| `Selector`     | Liest bestimmte Teile des States aus                                         |

---

## ‚öôÔ∏è Beispiel: Z√§hler mit Redux Toolkit

### üîß Setup

```bash
npm install @reduxjs/toolkit react-redux
```

---

### 1Ô∏è‚É£ Store & Reducer

```js
// store.js
import { configureStore, createSlice } from '@reduxjs/toolkit';

const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 },
  reducers: {
    increment(state) {
      state.value += 1;
    },
    decrement(state) {
      state.value -= 1;
    },
  },
});

export const { increment, decrement } = counterSlice.actions;

export const store = configureStore({
  reducer: { counter: counterSlice.reducer },
});
```

---

### 2Ô∏è‚É£ Bereitstellen des Stores

```jsx
// main.jsx
import { Provider } from 'react-redux';
import { store } from './store';
import App from './App';

<Provider store={store}>
  <App />
</Provider>
```

---

### 3Ô∏è‚É£ Verwenden in einer Komponente

```jsx
// Counter.jsx
import { useSelector, useDispatch } from 'react-redux';
import { increment, decrement } from './store';

function Counter() {
  const count = useSelector((state) => state.counter.value);
  const dispatch = useDispatch();

  return (
    <div>
      <p>Z√§hler: {count}</p>
      <button onClick={() => dispatch(increment())}>+</button>
      <button onClick={() => dispatch(decrement())}>‚Äì</button>
    </div>
  );
}
```

---

## üîÅ Datenfluss

```text
UI ‚Üí dispatch(action) ‚Üí reducer ‚Üí neuer state ‚Üí UI-Update
```

---

## üìù Zusammenfassung

| Begriff       | Funktion                              |
|---------------|----------------------------------------|
| `Store`       | Zentrale Datenhaltung                  |
| `Action`      | Ereignisbeschreibung                   |
| `Reducer`     | Ver√§ndert Zustand basierend auf Action |
| `dispatch()`  | Sendet Action an Reducer               |
| `useSelector` | Liest Daten aus dem Store              |
| `useDispatch` | Ruft Aktionen auf                      |

---

## üîó Quellen

- [Redux Toolkit ‚Äì Offizielle Doku](https://redux-toolkit.js.org)  
- [React Redux ‚Äì Einstieg](https://react-redux.js.org/introduction/getting-started)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

112. ### <a name="112"></a> Was sind Actions, Reducer und Store?

# Was sind Actions, Reducer und Store in Redux?

Diese drei Konzepte bilden das **Herzst√ºck von Redux**.  
Sie sorgen f√ºr einen **vorhersagbaren Datenfluss** und eine **klare Trennung der Logik**.

---

## üü© 1. **Store**

Der **Store** ist die **zentrale Datenquelle** deiner Anwendung.  
Er enth√§lt den **globalen Zustand** (State) und stellt Methoden bereit, um:

- den Zustand zu lesen (`getState`)
- √Ñnderungen auszul√∂sen (`dispatch`)
- auf √Ñnderungen zu reagieren (`subscribe`)

### Beispiel:

```js
import { configureStore } from '@reduxjs/toolkit';
import counterReducer from './counterSlice';

const store = configureStore({
  reducer: {
    counter: counterReducer,
  },
});
```

---

## üü® 2. **Action**

Eine **Action** ist ein **JavaScript-Objekt**, das beschreibt, **was passiert ist**.  
Sie hat mindestens ein `type`-Feld.

### Beispiel:

```js
const incrementAction = { type: 'counter/increment' };
```

Mit Redux Toolkit:

```js
dispatch(increment()); // automatisch erzeugte Action
```

---

## üü• 3. **Reducer**

Ein **Reducer** ist eine **reine Funktion**, die den neuen Zustand berechnet  
auf Basis des aktuellen Zustands + Action.

### Beispiel (klassisch):

```js
function counterReducer(state = { value: 0 }, action) {
  switch (action.type) {
    case 'counter/increment':
      return { value: state.value + 1 };
    default:
      return state;
  }
}
```

### Beispiel mit Redux Toolkit:

```js
const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 },
  reducers: {
    increment(state) {
      state.value += 1; // dank Immer.js erlaubt
    },
  },
});
```

---

## üîÅ Zusammenwirken der drei

```text
UI ‚Üí dispatch(Action) ‚Üí Reducer ‚Üí Neuer State ‚Üí Store ‚Üí UI-Update
```

---

## üìù Zusammenfassung

| Begriff     | Funktion                                      |
|-------------|-----------------------------------------------|
| **Store**   | H√§lt den globalen Zustand                     |
| **Action**  | Beschreibt, was passiert ist (`{ type: ... }`)|
| **Reducer** | Erzeugt neuen Zustand basierend auf Action    |

---

## üîó Quellen

- [Redux Grundlagen (offiziell)](https://redux.js.org/tutorials/fundamentals/part-3-state-actions-reducers)  
- [Redux Toolkit Docs](https://redux-toolkit.js.org/introduction/getting-started)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

113. ### <a name="113"></a> Wie funktioniert Redux Toolkit (createSlice, configureStore, createAsyncThunk)?

# Wie funktioniert Redux Toolkit (`createSlice`, `configureStore`, `createAsyncThunk`)?

**Redux Toolkit** ist die offizielle, empfohlene Methode zum Schreiben von Redux-Code.  
Es reduziert Boilerplate-Code und bietet moderne, einfache APIs f√ºr `Store`, `Reducer`, `Async-Logik`.

---

## üì¶ Installation

```bash
npm install @reduxjs/toolkit react-redux
```

---

## üîß 1. `createSlice` ‚Äì Reducer + Actions in einem

```js
import { createSlice } from '@reduxjs/toolkit';

const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 },
  reducers: {
    increment(state) {
      state.value += 1;
    },
    decrement(state) {
      state.value -= 1;
    },
  },
});

export const { increment, decrement } = counterSlice.actions;
export default counterSlice.reducer;
```

‚úÖ Vorteile:
- automatische Action-Erstellung (`increment`, `decrement`)
- automatische Action-Typen (`counter/increment`)

---

## üè™ 2. `configureStore` ‚Äì Store erstellen

```js
import { configureStore } from '@reduxjs/toolkit';
import counterReducer from './counterSlice';

export const store = configureStore({
  reducer: {
    counter: counterReducer,
  },
});
```

- akzeptiert ein **Reducer-Objekt**
- aktiviert automatisch Redux DevTools & Middleware

---

## üîÅ 3. `createAsyncThunk` ‚Äì Asynchrone Logik wie API-Fetch

```js
import { createAsyncThunk } from '@reduxjs/toolkit';

export const fetchUsers = createAsyncThunk(
  'users/fetchUsers',
  async () => {
    const response = await fetch('https://jsonplaceholder.typicode.com/users');
    return await response.json();
  }
);
```

‚û° Wird automatisch in `pending`, `fulfilled`, `rejected` unterteilt.

---

### In Kombination mit `extraReducers`:

```js
const usersSlice = createSlice({
  name: 'users',
  initialState: { list: [], loading: false },
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchUsers.pending, (state) => {
        state.loading = true;
      })
      .addCase(fetchUsers.fulfilled, (state, action) => {
        state.loading = false;
        state.list = action.payload;
      })
      .addCase(fetchUsers.rejected, (state) => {
        state.loading = false;
      });
  },
});
```

---

## üß† Verwendung im React-Komponenten

```jsx
import { useSelector, useDispatch } from 'react-redux';
import { increment } from './counterSlice';

function Counter() {
  const value = useSelector((state) => state.counter.value);
  const dispatch = useDispatch();

  return (
    <>
      <p>Z√§hler: {value}</p>
      <button onClick={() => dispatch(increment())}>+</button>
    </>
  );
}
```

---

## üìù Zusammenfassung

| Funktion              | Aufgabe                                  |
|-----------------------|-------------------------------------------|
| `createSlice`         | erstellt Reducer + Actions automatisch    |
| `configureStore`      | erzeugt den Store + Middleware             |
| `createAsyncThunk`    | einfache Handhabung asynchroner Logik     |
| `extraReducers`       | Reaktion auf externe Actions (z.‚ÄØB. Thunks) |

---

## üîó Quellen

- [Redux Toolkit ‚Äì Einstieg](https://redux-toolkit.js.org/introduction/getting-started)  
- [createSlice Doku](https://redux-toolkit.js.org/api/createSlice)  
- [createAsyncThunk Doku](https://redux-toolkit.js.org/api/createAsyncThunk)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

114. ### <a name="114"></a> Was ist RTK Query?

# Was ist RTK Query?

**RTK Query** ist eine leistungsstarke Erweiterung von Redux Toolkit,  
die **API-Daten abrufen, cachen, synchronisieren und verwalten** kann ‚Äì  
ohne manuell Thunks, Reducer oder Actions zu schreiben.

‚úÖ **Ziel**: API-Zugriff mit minimalem Code, integriert in den Redux Store.

---

## üéØ Vorteile

- üöÄ Automatisches Caching, Refetching, Invalidierung
- üßº Weniger Boilerplate als `createAsyncThunk`
- üîÑ Automatische Lade- und Fehlerzust√§nde (`isLoading`, `error`, etc.)
- üß† Integriert sich direkt in den Redux-Store

---

## üì¶ Installation

```bash
npm install @reduxjs/toolkit react-redux
```

---

## ‚úÖ Beispiel: API-Daten mit RTK Query laden

### 1Ô∏è‚É£ API-Slice erstellen

```js
// services/api.js
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';

export const api = createApi({
  reducerPath: 'api', // automatisch im Store
  baseQuery: fetchBaseQuery({ baseUrl: 'https://jsonplaceholder.typicode.com/' }),
  endpoints: (builder) => ({
    getUsers: builder.query({
      query: () => 'users',
    }),
  }),
});

export const { useGetUsersQuery } = api;
```

---

### 2Ô∏è‚É£ Store konfigurieren

```js
// store.js
import { configureStore } from '@reduxjs/toolkit';
import { api } from './services/api';

export const store = configureStore({
  reducer: {
    [api.reducerPath]: api.reducer,
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(api.middleware),
});
```

---

### 3Ô∏è‚É£ Verwendung in einer Komponente

```jsx
import { useGetUsersQuery } from './services/api';

function UserList() {
  const { data: users, error, isLoading } = useGetUsersQuery();

  if (isLoading) return <p>L√§dt...</p>;
  if (error) return <p>Fehler beim Laden</p>;

  return (
    <ul>
      {users.map((u) => (
        <li key={u.id}>{u.name}</li>
      ))}
    </ul>
  );
}
```

---

## üß† Caching & Refetching

- RTK Query cached Daten automatisch
- Man kann Daten **invalidieren**, **refetchen**, **polling** aktivieren usw.

```js
getUsers: builder.query({
  query: () => 'users',
  keepUnusedDataFor: 60, // Sekunden
});
```

---

## üìù Zusammenfassung

| Feature             | Beschreibung                                         |
|---------------------|------------------------------------------------------|
| `createApi`         | Erstellt API-Slice                                   |
| `fetchBaseQuery`    | Basiert auf `fetch()`                                |
| `useXYZQuery()`     | Auto-generierter React-Hook                          |
| `api.middleware`    | Automatische Integration in Redux-Middleware         |
| Vorteile            | Weniger Code, Caching, Refetching, isLoading, error |

---

## üîó Quellen

- [RTK Query ‚Äì Offizielle Docs](https://redux-toolkit.js.org/rtk-query/overview)  
- [API Service mit RTK Query](https://redux-toolkit.js.org/rtk-query/usage)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

115. ### <a name="115"></a> Was ist der Unterschied zwischen Redux und der Context-API?

# Was ist der Unterschied zwischen Redux und der Context-API?

Sowohl **Redux** als auch die **React Context-API** erm√∂glichen es,  
**globalen Zustand** in einer Anwendung zu teilen.  
Aber sie unterscheiden sich in **Funktion**, **Skalierbarkeit** und **Zweck**.

---

## üîç Vergleich Redux vs Context-API

| Kriterium               | **Redux**                                     | **Context-API**                             |
|-------------------------|-----------------------------------------------|---------------------------------------------|
| üì¶ Zweck                | Globales **State-Management mit Logik**       | **Einfaches Teilen** von Daten              |
| üß† Zustand              | komplexer, strukturiert (Slices, Reducer)     | einfacher Zustand (z.‚ÄØB. useState)          |
| ‚öô Middleware            | Ja (z.‚ÄØB. Logging, Async mit Thunks)          | Nein                                        |
| üîÅ Updates              | selektiv durch `useSelector`                  | **Alle** Children werden neu gerendert      |
| üöÄ Performance          | effizient durch Trennung von Logik & UI       | kann bei gro√üen Apps Performance-Probleme bringen |
| üß∞ Tooling              | Redux DevTools, RTK, RTK Query                | Keine integrierten Tools                    |
| üìö Boilerplate          | mehr (aber reduziert durch RTK)               | sehr wenig                                  |
| üîÑ Asynchronit√§t        | `createAsyncThunk`, Middleware                 | manuell √ºber Hooks                          |
| üë®‚Äçüë©‚Äçüëß‚Äçüë¶ Zielgruppe        | mittlere bis gro√üe Anwendungen                | kleine bis mittlere Komponentenkommunikation |

---

## üìå Wann Context-API verwenden?

- Themen wie: **Theme, Sprache, Auth-Status**
- Wenn **wenige Werte** in **vielen Komponenten** gebraucht werden
- **Kein komplexes State-Handling** n√∂tig

---

## üìå Wann Redux verwenden?

- **Viele voneinander abh√§ngige Komponenten**
- Komplexe Logik: **API-Calls, Caching, Optimierung**
- Zustandslogik soll **testbar, strukturiert und erweiterbar** sein
- Zusammenarbeit im Team / skalierbare App

---

## üìù Zusammenfassung

| React Context            | Gut f√ºr **einfache Datenweitergabe** in der App  
| Redux (+RTK)             | Ideal f√ºr **komplexes, strukturiertes State-Management**

> Die Context-API ist **kein Ersatz**, sondern eine **Alternative f√ºr bestimmte F√§lle**.

---

## üîó Quellen

- [React Docs ‚Äì Context API](https://react.dev/learn/passing-data-deeply-with-context)  
- [Redux Toolkit Docs](https://redux-toolkit.js.org)  
- [Vergleich Redux vs Context (Blog)](https://kentcdodds.com/blog/application-state-management-with-react)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

116. ### <a name="116"></a> Was ist connect() in Redux?

# Was ist `connect()` in Redux?

`connect()` ist eine **h√∂herwertige Funktion (Higher-Order Component)**  
aus der Bibliothek **`react-redux`**, die verwendet wurde,  
um **Klassen- oder Funktionskomponenten** mit dem Redux-Store zu verbinden  
(vor Hooks wie `useSelector`, `useDispatch`).

---

## üìå Zweck von `connect()`

- Zugriff auf den globalen Redux-State
- Dispatchen von Actions aus der Komponente
- Verbindung von **React-Komponenten mit dem Redux-Store**

---

## ‚úÖ Syntax

```js
connect(mapStateToProps, mapDispatchToProps)(Component)
```

| Argument              | Bedeutung                                                 |
|------------------------|------------------------------------------------------------|
| `mapStateToProps`      | Welche Teile des States als Props in die Komponente kommen |
| `mapDispatchToProps`   | Welche Actions als Props verf√ºgbar gemacht werden sollen   |

---

## üß± Beispiel

### 1Ô∏è‚É£ Redux: Actions & Reducer

```js
// counterSlice.js (klassisch ohne Toolkit)
const initialState = { value: 0 };

export function counterReducer(state = initialState, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { value: state.value + 1 };
    default:
      return state;
  }
}

export const increment = () => ({ type: 'INCREMENT' });
```

---

### 2Ô∏è‚É£ Komponente mit `connect()`

```jsx
import React from 'react';
import { connect } from 'react-redux';
import { increment } from './counterSlice';

function Counter({ value, increment }) {
  return (
    <div>
      <p>Wert: {value}</p>
      <button onClick={increment}>+</button>
    </div>
  );
}

const mapStateToProps = (state) => ({
  value: state.counter.value,
});

export default connect(mapStateToProps, { increment })(Counter);
```

---

## üö´ Heute: lieber Hooks verwenden

Statt `connect()` ‚Üí moderner Ansatz:

```jsx
import { useSelector, useDispatch } from 'react-redux';

function Counter() {
  const value = useSelector((state) => state.counter.value);
  const dispatch = useDispatch();

  return <button onClick={() => dispatch({ type: 'INCREMENT' })}>+</button>;
}
```

---

## üìù Zusammenfassung

| `connect()`                   | Alte Methode zur Verbindung mit Redux-Store (HOC)       |
|------------------------------|----------------------------------------------------------|
| `mapStateToProps`            | W√§hlt Teile des States aus                              |
| `mapDispatchToProps`         | Bindet Action Creators an Props                         |
| ‚ùó Empfehlung heute           | Lieber `useSelector`, `useDispatch` (funktionale Hooks) |

---

## üîó Quellen

- [react-redux ‚Äì `connect()` Doku](https://react-redux.js.org/api/connect)  
- [React Redux ‚Äì Hooks vs connect](https://react-redux.js.org/api/hooks)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

117. ### <a name="117"></a> Was sind Middleware in Redux (z. B. redux-thunk, redux-logger)?

# Was sind Middleware in Redux (z.‚ÄØB. `redux-thunk`, `redux-logger`)?

**Middleware** in Redux sind **Funktionen**, die sich **zwischen `dispatch()` und dem Reducer** schalten.  
Sie erm√∂glichen erweiterte Funktionen wie:

- asynchrone Aktionen (z.‚ÄØB. API-Calls)
- Logging
- Caching
- Fehlerbehandlung

---

## üîß Wie funktioniert Middleware?

```text
dispatch(action) ‚Üí middleware ‚Üí reducer ‚Üí new state
```

Middleware haben Zugriff auf:

- `dispatch`
- `getState`
- `next` (weiterf√ºhrender Aufruf)
- `action`

---

## ‚úÖ Beispiel: Eigene Middleware

```js
const loggerMiddleware = (store) => (next) => (action) => {
  console.log('Action:', action);
  const result = next(action); // zum n√§chsten Middleware/Reducer
  console.log('Neuer State:', store.getState());
  return result;
};
```

---

## üß∞ G√§ngige Middleware

### 1Ô∏è‚É£ `redux-thunk`

Erm√∂glicht es, **Funktionen statt Objekte** zu dispatchen (f√ºr Async-Logik).

```bash
npm install redux-thunk
```

```js
const fetchData = () => async (dispatch) => {
  dispatch({ type: 'FETCH_START' });
  const res = await fetch('/api');
  const data = await res.json();
  dispatch({ type: 'FETCH_SUCCESS', payload: data });
};
```

> Wird automatisch von **Redux Toolkit** mitgeliefert

---

### 2Ô∏è‚É£ `redux-logger`

Protokolliert alle Aktionen und State-√Ñnderungen in der Konsole (Debugging).

```bash
npm install redux-logger
```

```js
import logger from 'redux-logger';

const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(logger),
});
```

---

### 3Ô∏è‚É£ Eigene Middleware integrieren

```js
const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(myMiddleware),
});
```

---

## üìù Zusammenfassung

| Middleware       | Zweck                                    |
|------------------|-------------------------------------------|
| `redux-thunk`    | Asynchrone Logik (API, Delay, etc.)       |
| `redux-logger`   | Logging von Aktionen & Zust√§nden          |
| Eigene Middleware| Erweiterung von Dispatch-Logik            |

> Middleware = **flexible Erweiterung** der Redux-Funktionalit√§t.

---

## üîó Quellen

- [Redux ‚Äì Middleware Doku](https://redux.js.org/tutorials/fundamentals/part-4-store#middleware)  
- [redux-logger auf GitHub](https://github.com/LogRocket/redux-logger)  
- [redux-thunk ‚Äì GitHub](https://github.com/reduxjs/redux-thunk)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

118. ### <a name="118"></a> Was ist createSelector und wie funktioniert Reselect?

# Was ist `createSelector` und wie funktioniert `reselect`?

**`reselect`** ist eine Bibliothek f√ºr **selektives, memoisiertes Selektieren von Zustand** in Redux.  
Das zentrale Feature ist **`createSelector()`**, mit dem du komplexe Ableitungen aus dem Store berechnen kannst ‚Äì  
**nur wenn sich relevante Teile des Zustands ge√§ndert haben**.

---

## üéØ Ziel

- Performance optimieren
- unn√∂tige Berechnungen und Re-Renders vermeiden
- komplexe Daten aus Store ableiten (z.‚ÄØB. Filter, Map, Reduce)

---

## üîß Installation

```bash
npm install reselect
```

---

## ‚úÖ Einfaches Beispiel mit `createSelector`

```js
import { createSelector } from 'reselect';

// Basis-Selector: roher Zugriff auf State
const selectTodos = (state) => state.todos;

// Memoisierter Selector: nur wenn todos sich √§ndern
export const selectCompletedTodos = createSelector(
  [selectTodos],
  (todos) => todos.filter((todo) => todo.completed)
);
```

üìå `selectCompletedTodos(state)` gibt **nur neue Werte zur√ºck**,  
wenn sich die urspr√ºnglichen `todos` ver√§ndert haben.

---

## üß† Beispiel im Redux Toolkit Setup

```js
// store.js
const initialState = {
  todos: [
    { id: 1, text: 'Lernen', completed: true },
    { id: 2, text: 'Coden', completed: false },
  ],
};

// selectors.js
import { createSelector } from 'reselect';

const selectTodos = (state) => state.todos;

export const selectIncompleteTodos = createSelector(
  [selectTodos],
  (todos) => todos.filter((t) => !t.completed)
);
```

---

## üß™ Verwendung im Component

```jsx
import { useSelector } from 'react-redux';
import { selectIncompleteTodos } from './selectors';

function TodoList() {
  const todos = useSelector(selectIncompleteTodos);

  return (
    <ul>
      {todos.map((t) => (
        <li key={t.id}>{t.text}</li>
      ))}
    </ul>
  );
}
```

---

## üìå Vorteile von `createSelector`

- **Memoisierung**: Caches das Ergebnis bis sich Input-Selektoren √§ndern
- **Komposition**: Selektoren k√∂nnen andere Selektoren nutzen
- **Performance**: Weniger Re-Render und Berechnungen

---

## üìù Zusammenfassung

| Begriff           | Beschreibung                                              |
|-------------------|-----------------------------------------------------------|
| `createSelector`  | Memoisierter Selektor f√ºr abgeleiteten Zustand            |
| `reselect`        | Bibliothek f√ºr performantes Selektieren aus dem Redux-Store |
| Vorteile          | Wiederverwendbar, performant, selektiv                    |

---

## üîó Quellen

- [Reselect ‚Äì GitHub](https://github.com/reduxjs/reselect)  
- [Redux Docs: Computing Derived Data](https://redux.js.org/usage/deriving-data-selectors)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

119. ### <a name="119"></a> Wie verbindet man Redux mit React √ºber Hooks (useSelector, useDispatch)?

# Wie verbindet man Redux mit React √ºber Hooks (`useSelector`, `useDispatch`)?

Statt der alten `connect()`-Funktion nutzt man in modernen React-Apps  
die **React-Redux Hooks** `useSelector` und `useDispatch`,  
um Komponenten einfach mit dem Redux-Store zu verbinden.

---

## üß† `useSelector`

Wird verwendet, um **Daten aus dem Redux-Store** auszulesen.

```jsx
import { useSelector } from 'react-redux';

const count = useSelector((state) => state.counter.value);
```

- Zugriff auf beliebige Teile des States
- Automatisch neu gerendert bei √Ñnderung

---

## ‚öôÔ∏è `useDispatch`

Gibt die `dispatch`-Funktion zur√ºck, um **Actions zu senden**.

```jsx
import { useDispatch } from 'react-redux';
import { increment } from './counterSlice';

const dispatch = useDispatch();
dispatch(increment());
```

- Ideal in Event-Handlern (`onClick`, `onSubmit`, etc.)

---

## ‚úÖ Beispiel: Counter-Komponente

```jsx
import { useSelector, useDispatch } from 'react-redux';
import { increment, decrement } from './counterSlice';

function Counter() {
  const count = useSelector((state) => state.counter.value);
  const dispatch = useDispatch();

  return (
    <div>
      <p>Wert: {count}</p>
      <button onClick={() => dispatch(increment())}>+</button>
      <button onClick={() => dispatch(decrement())}>‚Äì</button>
    </div>
  );
}
```

---

## üîÑ Vergleich: `connect()` vs Hooks

| Alt (connect)                     | Modern (Hooks)              |
|----------------------------------|-----------------------------|
| `mapStateToProps()`              | `useSelector()`             |
| `mapDispatchToProps()`           | `useDispatch()`             |
| Mehr Boilerplate                 | Weniger Code, klarer Stil   |

---

## üìù Zusammenfassung

| Hook             | Zweck                                     |
|------------------|--------------------------------------------|
| `useSelector`    | Daten aus Redux-Store lesen                |
| `useDispatch`    | Aktionen an den Store senden (dispatch)   |
| Vorteil          | weniger Code, bessere Lesbarkeit, Flexibilit√§t |

---

## üîó Quellen

- [React Redux ‚Äì `useSelector`](https://react-redux.js.org/api/hooks#useselector)  
- [React Redux ‚Äì `useDispatch`](https://react-redux.js.org/api/hooks#usedispatch)  
- [Redux Toolkit ‚Äì Einstieg](https://redux-toolkit.js.org/introduction/getting-started)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

120. ### <a name="120"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

121. ### <a name="121"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

122. ### <a name="122"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

123. ### <a name="123"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

124. ### <a name="124"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

125. ### <a name="125"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

126. ### <a name="126"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

127. ### <a name="127"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

128. ### <a name="128"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

129. ### <a name="129"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

130. ### <a name="130"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

131. ### <a name="131"></a> Was ist Code-Splitting?

# Was ist Code-Splitting?

**Code-Splitting** ist eine Technik, mit der du **JavaScript-Bundles in kleinere Teile aufteilst**,  
damit der Browser **nicht alles auf einmal laden muss**, sondern nur das, was wirklich gebraucht wird.

Ziel:  
üöÄ **Ladezeit reduzieren**  
üì¶ **Initiales Bundle kleiner halten**  
üìà **Performance verbessern**

---

## üì¶ Warum ist das wichtig?

Ohne Code-Splitting wird deine gesamte Anwendung als ein einziges gro√ües JS-Bundle geladen.  
Das verlangsamt die erste Ladezeit (‚ÄûInitial Load‚Äú) ‚Äì besonders bei gro√üen Apps.

---

## üöÄ Wie funktioniert Code-Splitting in React?

React verwendet **`React.lazy()`** in Kombination mit **`Suspense`** f√ºr dynamisches Laden von Komponenten.

---

## ‚úÖ Beispiel mit `React.lazy()` und `Suspense`

```jsx
import React, { Suspense } from 'react';

// Komponente wird nur bei Bedarf geladen
const LazyComponent = React.lazy(() => import('./MyComponent'));

function App() {
  return (
    <div>
      <h1>Meine App</h1>
      <Suspense fallback={<p>Lade...</p>}>
        <LazyComponent />
      </Suspense>
    </div>
  );
}
```

üìå Nur wenn `LazyComponent` wirklich gerendert wird, l√§dt React den zugeh√∂rigen Code.

---

## üß© Dynamisches Routing mit Code-Splitting

In Kombination mit `react-router-dom`:

```jsx
const Home = React.lazy(() => import('./pages/Home'));
const About = React.lazy(() => import('./pages/About'));

<Routes>
  <Route path="/" element={
    <Suspense fallback={<p>Lade Startseite...</p>}>
      <Home />
    </Suspense>
  } />
  <Route path="/about" element={
    <Suspense fallback={<p>Lade Info...</p>}>
      <About />
    </Suspense>
  } />
</Routes>
```

---

## üìÅ Webpack & Vite

Code-Splitting wird meist vom **Bundler** √ºbernommen:
- `webpack`: automatisch bei `import()`
- `vite`: unterst√ºtzt dynamisches Importieren nativ

---

## üìù Zusammenfassung

| Begriff          | Beschreibung                                |
|------------------|---------------------------------------------|
| `React.lazy()`   | dynamisches Laden von Komponenten           |
| `Suspense`       | zeigt Fallback w√§hrend des Ladens           |
| Vorteil          | schnelleres Initial-Loading                 |
| Einsatzbereiche  | gro√üe Seiten, Routen, selten genutzte Features |

---

## üîó Quellen

- [React ‚Äì Code-Splitting](https://react.dev/learn/code-splitting)  
- [MDN ‚Äì Code Splitting](https://developer.mozilla.org/en-US/docs/Glossary/Code_splitting)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

132. ### <a name="132"></a> Wie funktionieren React.lazy und Suspense?

# Wie funktionieren `React.lazy` und `Suspense`?

Mit `React.lazy()` und `Suspense` kannst du **Komponenten dynamisch (on-demand) laden**,  
anstatt sie beim Initial-Load in das Hauptbundle einzuschlie√üen.

‚û°Ô∏è Das nennt man **Code-Splitting auf Komponentenebene**.

---

## üß© `React.lazy()`

Mit `React.lazy()` definierst du eine **dynamisch importierte Komponente**.

```jsx
const LazyComponent = React.lazy(() => import('./MyComponent'));
```

üìå Der Code von `MyComponent` wird **erst geladen**, wenn sie **wirklich gerendert** wird.

---

## ‚è≥ `Suspense`

Da das Laden asynchron ist, brauchst du `Suspense`,  
um einen **Fallback (z.‚ÄØB. Ladeanzeige)** zu zeigen, w√§hrend die Komponente l√§dt.

```jsx
import React, { Suspense } from 'react';

function App() {
  return (
    <div>
      <h1>Meine App</h1>
      <Suspense fallback={<p>L√§dt‚Ä¶</p>}>
        <LazyComponent />
      </Suspense>
    </div>
  );
}
```

- `fallback` zeigt die UI w√§hrend des Ladevorgangs
- Der Fallback kann beliebig sein: Spinner, Skeleton, Text, etc.

---

## üìÇ Beispiel mit mehreren Lazy-Komponenten

```jsx
const Home = React.lazy(() => import('./pages/Home'));
const About = React.lazy(() => import('./pages/About'));

function App() {
  return (
    <Suspense fallback={<p>Lade Seite‚Ä¶</p>}>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
      </Routes>
    </Suspense>
  );
}
```

---

## üìå Einschr√§nkungen

- `React.lazy()` funktioniert **nur f√ºr Default-Exports**  
- Bei Fehlern beim Laden solltest du **Error Boundaries** verwenden  
- Suspense funktioniert aktuell **nicht f√ºr Datenfetching ohne weitere Libs** (au√üer mit `React 18` + Server Components oder Libs wie `React Query`, `Relay`)

---

## üìù Zusammenfassung

| Methode             | Beschreibung                                |
|---------------------|---------------------------------------------|
| `React.lazy()`      | dynamisches Importieren einer Komponente    |
| `Suspense`          | zeigt Fallback w√§hrend Ladevorgang          |
| Vorteil             | schnelleres Initial-Loading, besseres UX    |

---

## üîó Quellen

- [React.dev ‚Äì Code-Splitting](https://react.dev/learn/code-splitting)  
- [React.dev ‚Äì `React.lazy`](https://react.dev/reference/react/lazy)  
- [React.dev ‚Äì `Suspense`](https://react.dev/reference/react/Suspense)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

133. ### <a name="133"></a> Was ist Tree Shaking?

# Was ist Tree Shaking?

**Tree Shaking** ist ein Optimierungsverfahren beim **JavaScript-Bundling**,  
das **nicht verwendeten (toten) Code automatisch entfernt**  
‚Üí dadurch wird das finale Bundle kleiner und die Ladezeit schneller.

---

## üß† Wie funktioniert Tree Shaking?

Tree Shaking analysiert den **Modul-Import-Baum** (Import-Tree)  
und entfernt **unbenutzte Exporte** aus ES6+ Modulen.

‚û°Ô∏è Voraussetzung: Der Code muss **modular** und **statisch analysierbar** sein (ES Modules).

---

## ‚úÖ Beispiel

```js
// utils.js
export function used() {
  console.log('wird verwendet');
}

export function unused() {
  console.log('wird nie verwendet');
}

// main.js
import { used } from './utils.js';

used();
```

‚û°Ô∏è Beim Bundling (z.‚ÄØB. mit `webpack`, `vite`) wird `unused()` **eliminiert**,  
weil sie **nirgendwo verwendet wird**.

---

## üì¶ Voraussetzung f√ºr Tree Shaking

| Anforderung             | Erkl√§rung                              |
|--------------------------|-----------------------------------------|
| ‚úÖ ES Modules (`import`) | Kein `require()` oder CommonJS          |
| ‚úÖ statische Imports     | keine dynamischen `import(expr)`        |
| ‚úÖ kein Side-Effect      | Modul darf keine Seiteneffekte enthalten |

---

## üìÅ `package.json` mit `"sideEffects": false`

Damit der Bundler wei√ü, dass ein Modul **keine Nebenwirkungen hat**:

```json
{
  "name": "mein-paket",
  "sideEffects": false
}
```

‚û°Ô∏è Dadurch kann Tree Shaking aggressiver arbeiten.

---

## üö´ Was wird *nicht* entfernt?

- Dynamisch importierter Code
- Code mit Seiteneffekten (`console.log`, DOM-Zugriff)
- Nicht als Modul geschriebene Dateien (CommonJS)

---

## üìù Zusammenfassung

| Begriff        | Bedeutung                                  |
|----------------|---------------------------------------------|
| Tree Shaking   | Entfernt ungenutzten Code aus Bundles       |
| Voraussetzung  | ES Module, statische Imports, keine Side-Effects |
| Tools          | Webpack, Rollup, Vite, esbuild              |

---

## üîó Quellen

- [MDN ‚Äì Tree Shaking](https://developer.mozilla.org/en-US/docs/Glossary/Tree_shaking)  
- [webpack ‚Äì Tree Shaking](https://webpack.js.org/guides/tree-shaking/)  
- [Rollup ‚Äì Tree Shaking](https://rollupjs.org/guide/en/#tree-shaking)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

134. ### <a name="134"></a> Was ist Server-Side Rendering (SSR) und Hydration?

# Was ist Server-Side Rendering (SSR) und Hydration?

**Server-Side Rendering (SSR)** ist eine Technik, bei der **React-Komponenten auf dem Server in HTML umgewandelt**  
und an den Browser gesendet werden ‚Äì **bevor** JavaScript im Browser ausgef√ºhrt wird.

**Hydration** bedeutet, dass React im Browser den **interaktiven Zustand** (Events, State etc.)  
auf das **vom Server gelieferte HTML** anwendet.

---

## üì¶ Warum SSR verwenden?

| Vorteil                             | Beschreibung                                           |
|-------------------------------------|--------------------------------------------------------|
| ‚è± Schnellere erste Ladezeit         | HTML ist sofort da, auch ohne JS                      |
| üîç Bessere SEO                      | Crawler sehen direkt fertiges HTML                    |
| üì° Besser bei langsamen Verbindungen | Seite funktioniert teilweise, auch ohne JS sofort     |

---

## üîÅ SSR Ablauf (vereinfacht)

```text
1. Client sendet Anfrage an Server
2. Server rendert React-Komponenten ‚Üí HTML
3. HTML wird an Browser gesendet
4. Browser zeigt HTML
5. React wird im Hintergrund geladen ‚Üí Hydration
6. Seite wird interaktiv
```

---

## üîß Beispiel mit Next.js (SSR + Hydration)

```js
// pages/index.jsx
export default function Home({ name }) {
  return <h1>Hallo {name}</h1>;
}

export async function getServerSideProps() {
  return { props: { name: 'Sergii' } };
}
```

‚û°Ô∏è `getServerSideProps()` rendert die Seite **bei jeder Anfrage auf dem Server**.

---

## üíß Was ist Hydration?

Nach dem Server-Render muss React im Browser:

- das **gerenderte HTML √ºbernehmen**
- es mit **Event-Handlern und State** verbinden

‚û°Ô∏è Dieser Vorgang hei√üt **Hydration** und geschieht automatisch bei z.‚ÄØB. Next.js oder Remix.

---

## üß† Vergleich: CSR vs SSR

| Merkmal              | Client-Side Rendering (CSR)          | Server-Side Rendering (SSR)              |
|----------------------|--------------------------------------|------------------------------------------|
| Initiales HTML       | Leeres `div#root`                    | Vollst√§ndiges HTML                       |
| Ladegeschwindigkeit  | Langsamer Start                      | Schneller First Paint                    |
| SEO                  | Eingeschr√§nkt                        | Sehr gut                                 |
| Umsetzung            | CRA, Vite                            | Next.js, Remix                           |

---

## üìù Zusammenfassung

| Begriff       | Bedeutung                                                                |
|---------------|---------------------------------------------------------------------------|
| SSR           | React rendert HTML auf dem Server ‚Üí schneller Start + bessere SEO        |
| Hydration     | React macht servergerendertes HTML im Browser interaktiv                 |
| Tools         | `Next.js`, `Remix`, `express + react-dom/server`                         |

---

## üîó Quellen

- [React ‚Äì Rendering on the Server](https://react.dev/learn/rendering-on-the-server)  
- [Next.js ‚Äì SSR](https://nextjs.org/docs/pages/building-your-application/rendering/server-side-rendering)  
- [MDN ‚Äì Hydration](https://developer.mozilla.org/en-US/docs/Glossary/Hydration)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

135. ### <a name="135"></a> Wie geht man mit Hydration-Fehlern bei SSR um?

# Wie geht man mit Hydration-Fehlern bei SSR um?

**Hydration-Fehler** entstehen, wenn der HTML-Code vom Server  
nicht exakt mit dem initialen React-Render im Browser √ºbereinstimmt.

‚û°Ô∏è React zeigt dann Warnungen wie:

```text
Warning: Text content did not match.
Server: "A" | Client: "B"
```

---

## üîç Ursachen von Hydration-Problemen

| Ursache                                  | Beschreibung                                              |
|------------------------------------------|-----------------------------------------------------------|
| üïì Unterschiedlicher Zustand (z.‚ÄØB. Datum, Zufallszahl) | Server & Client generieren unterschiedliche Inhalte        |
| üß† Zugriff auf `window`, `document`       | Nur im Browser verf√ºgbar ‚Üí auf dem Server Fehler          |
| üß≠ Unterschiedliches Rendering je nach Umgebung | z.‚ÄØB. Sprache, Zeit, Browser                              |

---

## ‚úÖ Best Practices zur Vermeidung

### 1Ô∏è‚É£ **Nur im Browser ausf√ºhren** (`useEffect`)

```jsx
import { useEffect, useState } from 'react';

function ClientOnlyDate() {
  const [now, setNow] = useState(null);

  useEffect(() => {
    setNow(new Date().toLocaleTimeString());
  }, []);

  return <p>Uhrzeit: {now ?? 'L√§dt...'}</p>;
}
```

> ‚úÖ Wird **nicht** beim Server-Render ausgef√ºhrt ‚Üí keine Hydration-Probleme

---

### 2Ô∏è‚É£ **`typeof window !== 'undefined'` pr√ºfen**

```js
if (typeof window !== 'undefined') {
  const width = window.innerWidth;
}
```

---

### 3Ô∏è‚É£ **Client-Only-Komponenten auslagern**

In Next.js:

```jsx
'use client';

import dynamic from 'next/dynamic';

const NoSSRComponent = dynamic(() => import('./ClientComponent'), {
  ssr: false,
});
```

‚û°Ô∏è Die Komponente wird **nur im Browser** geladen und gerendert.

---

### 4Ô∏è‚É£ **Gleiches HTML auf Server und Client erzeugen**

- Keine `Math.random()`, `Date.now()`, `Intl`, etc. im JSX w√§hrend SSR
- Vermeide bedingtes Rendering auf Basis von Umgebungen

---

## üß™ Hydration-Fehler erkennen

- **Entwicklermodus** zeigt Warnungen in der Konsole
- Tools wie **React DevTools** und **Lighthouse** k√∂nnen helfen

---

## üìù Zusammenfassung

| Problem                   | Unterschied zwischen Server-HTML und Client-Render         |
|---------------------------|------------------------------------------------------------|
| Ursachen                  | Zustand, Zeit, Zufall, Browser-APIs                        |
| L√∂sung                    | `useEffect`, `typeof window`, `dynamic(ssr: false)`        |
| Ziel                      | Server-HTML = Client-HTML vor Hydration                    |

---

## üîó Quellen

- [React ‚Äì Hydration Errors](https://react.dev/reference/react-dom/client/hydrateRoot#hydration-errors)  
- [Next.js ‚Äì Avoiding Hydration Mismatches](https://nextjs.org/docs/messages/react-hydration-error)  
- [MDN ‚Äì Hydration](https://developer.mozilla.org/en-US/docs/Glossary/Hydration)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

136. ### <a name="136"></a> Was bedeutet Virtualisierung (z. B. mit react-window)?

# Was bedeutet Virtualisierung (z.‚ÄØB. mit `react-window`)?

**Virtualisierung** ist eine Technik zur **leistungsoptimierten Darstellung gro√üer Listen**,  
indem **nur die sichtbaren Elemente** im DOM gerendert werden ‚Äì  
statt Tausende gleichzeitig.

üì¶ Bekannte Libraries:  
- `react-window` (leicht & schnell)  
- `react-virtualized` (umfangreicher)

---

## üß† Warum Virtualisierung?

| Problem bei gro√üen Listen       | L√∂sung durch Virtualisierung             |
|----------------------------------|------------------------------------------|
| üö´ Langsames Rendering (1000+ DOM-Elemente) | ‚úÖ Nur sichtbarer Bereich wird gerendert |
| üìâ Hoher Speicherverbrauch       | ‚úÖ Geringe DOM-Last                       |
| üòµ Unn√∂tige Repaints/Updates     | ‚úÖ Bessere Performance                    |

---

## ‚úÖ Beispiel mit `react-window`

### 1Ô∏è‚É£ Installation

```bash
npm install react-window
```

---

### 2Ô∏è‚É£ Code-Beispiel

```jsx
import { FixedSizeList as List } from 'react-window';

const Row = ({ index, style }) => (
  <div style={style}>Zeile #{index}</div>
);

function VirtualizedList() {
  return (
    <List
      height={300}        // sichtbare H√∂he
      itemCount={1000}    // Anzahl der Elemente
      itemSize={35}       // H√∂he jedes Eintrags (px)
      width="100%"        // Breite
    >
      {Row}
    </List>
  );
}
```

‚û°Ô∏è Nur die Elemente im sichtbaren Bereich (z.‚ÄØB. 10‚Äì20 Zeilen)  
werden tats√§chlich ins DOM gerendert.

---

## üìå Unterschied: Pagination vs. Virtualisierung

| Technik          | Beschreibung                              |
|------------------|-------------------------------------------|
| Pagination       | Seite f√ºr Seite, Daten werden nachgeladen |
| Virtualisierung  | Alles im Speicher, aber nur sichtbarer Teil im DOM |

---

## üìà Vorteile

- üöÄ Schnelles Scrollen auch bei 10.000+ Eintr√§gen
- üì¶ Sehr kleine DOM-Gr√∂√üe
- üîÑ Reduziert Re-Renders und Speicherverbrauch

---

## üìù Zusammenfassung

| Begriff           | Erkl√§rung                                               |
|-------------------|----------------------------------------------------------|
| Virtualisierung   | Rendert nur sichtbare UI-Elemente                        |
| `react-window`    | Minimalistische Library f√ºr Listen-/Grid-Virtualisierung |
| Einsatzbereich    | Gro√üe Tabellen, Listen, Men√ºs                            |

---

## üîó Quellen

- [react-window ‚Äì GitHub](https://github.com/bvaughn/react-window)  
- [react-window ‚Äì Doku & Beispiele](https://react-window.vercel.app/)  
- [Artikel: Virtualisierung erkl√§rt](https://blog.logrocket.com/using-react-window-for-efficient-list-rendering/)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

137. ### <a name="137"></a> Wie verhindert man unn√∂tige Re-Renders?

# Wie verhindert man unn√∂tige Re-Renders in React?

**Unn√∂tige Re-Renders** entstehen, wenn eine Komponente erneut rendert,  
obwohl sich ihr sichtbarer Output nicht ge√§ndert hat.  
Das kann zu **Performance-Problemen** f√ºhren ‚Äì besonders bei gro√üen Apps.

---

## ‚úÖ Techniken zur Optimierung

### 1Ô∏è‚É£ `React.memo` (f√ºr Funktionskomponenten)

Verhindert Re-Render, wenn Props **gleich bleiben**.

```jsx
const MyComponent = React.memo(function MyComponent({ name }) {
  return <p>{name}</p>;
});
```

‚û°Ô∏è Vergleich erfolgt **flach (shallow)** ‚Äì bei komplexen Objekten ggf. manuell optimieren.

---

### 2Ô∏è‚É£ `useMemo` (f√ºr berechnete Werte)

Memoisiert einen R√ºckgabewert, wenn sich Abh√§ngigkeiten **nicht ge√§ndert** haben.

```jsx
const expensiveValue = useMemo(() => computeHeavy(a, b), [a, b]);
```

‚û°Ô∏è Ideal f√ºr teure Berechnungen (Filter, Sortierung usw.)

---

### 3Ô∏è‚É£ `useCallback` (f√ºr stabile Funktions-Referenzen)

Verhindert, dass Funktionen bei jedem Render neu erzeugt werden.

```jsx
const handleClick = useCallback(() => {
  doSomething();
}, []);
```

‚û°Ô∏è N√ºtzlich, wenn Props als Callback an `React.memo`-Komponenten √ºbergeben werden.

---

### 4Ô∏è‚É£ `shouldComponentUpdate` (bei Klassenkomponenten)

Steuert manuell, ob ein Re-Render n√∂tig ist.

```js
shouldComponentUpdate(nextProps, nextState) {
  return nextProps.value !== this.props.value;
}
```

‚û°Ô∏è Alternative: `PureComponent`, das das automatisch macht (flacher Vergleich).

---

### 5Ô∏è‚É£ Selektives `useSelector` in Redux

Vermeide globale Re-Renders durch pr√§zise Selektoren:

```jsx
const value = useSelector((state) => state.counter.value);
```

‚û°Ô∏è Keine Abh√§ngigkeit von globalem State, wenn nicht n√∂tig.

---

### 6Ô∏è‚É£ Komponentenaufteilung (Component Splitting)

Teile gro√üe Komponenten in kleinere auf,  
damit nur betroffene Teile neu gerendert werden.

---

### 7Ô∏è‚É£ Props vermeiden, die sich st√§ndig √§ndern

Beispiel:

```jsx
// Schlechter Stil: erzeugt neues Objekt bei jedem Render
<Component config={{ a: 1 }} />

// Besser: config als useMemo oder aus dem State
```

---

## üìù Zusammenfassung

| Technik          | Zweck                                               |
|------------------|------------------------------------------------------|
| `React.memo`     | Memoisiert Funktionskomponenten                     |
| `useMemo`        | Memoisiert R√ºckgabewerte von Funktionen             |
| `useCallback`    | Verhindert neue Funktionsreferenzen                 |
| `shouldComponentUpdate` | Kontrolle √ºber Updates in Klassen             |
| Genaue `useSelector`    | Vermeidet unn√∂tige Redux-abh√§ngige Re-Renders |

---

## üîó Quellen

- [React Docs ‚Äì Optimizing Performance](https://react.dev/learn/optimizing-performance)  
- [React.memo ‚Äì Referenz](https://react.dev/reference/react/memo)  
- [useMemo ‚Äì Referenz](https://react.dev/reference/react/useMemo)  
- [useCallback ‚Äì Referenz](https://react.dev/reference/react/useCallback)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

138. ### <a name="138"></a> Was ist React Transition Group?

# Was ist React Transition Group?

**React Transition Group** ist eine React-Bibliothek f√ºr **einfache Animationen und √úberg√§nge**,  
z.‚ÄØB. beim Einblenden, Ausblenden oder √Ñndern von Komponenten im DOM.

‚û°Ô∏è Sie steuert **den Zeitpunkt**, wann eine Komponente in den DOM eingef√ºgt oder entfernt wird  
und bietet daf√ºr passende CSS-Klassen.

---

## üì¶ Installation

```bash
npm install react-transition-group
```

---

## üìö Wichtige Komponenten

| Komponente         | Zweck                                         |
|--------------------|-----------------------------------------------|
| `<Transition>`     | Kontrolle √ºber Mount/Unmount mit √úbergang     |
| `<CSSTransition>`  | Wie `<Transition>`, aber mit CSS-Klassen      |
| `<SwitchTransition>` | √úbergang zwischen zwei exklusiven Komponenten |
| `<TransitionGroup>` | Sammlung mehrerer animierter Komponenten     |

---

## ‚úÖ Beispiel mit `CSSTransition`

```jsx
import { CSSTransition } from 'react-transition-group';
import './styles.css';

function Example({ show }) {
  return (
    <CSSTransition
      in={show}
      timeout={300}
      classNames="fade"
      unmountOnExit
    >
      <div className="box">Ich werde animiert!</div>
    </CSSTransition>
  );
}
```

---

## üé® CSS f√ºr Animation

```css
.fade-enter {
  opacity: 0;
}
.fade-enter-active {
  opacity: 1;
  transition: opacity 300ms;
}

.fade-exit {
  opacity: 1;
}
.fade-exit-active {
  opacity: 0;
  transition: opacity 300ms;
}
```

---

## üß† Warum `Transition Group`?

- Nutzt **kein JavaScript-Animationstool**, sondern **CSS-Animationen**
- Arbeitet direkt mit dem React-Lifecycle (`mount`, `unmount`)
- Kompatibel mit Conditional Rendering (`{show && <Component />}`)

---

## üìù Zusammenfassung

| Begriff              | Beschreibung                              |
|----------------------|-------------------------------------------|
| `React Transition Group` | Animation von Komponenten √ºber Lebenszyklus |
| `CSSTransition`      | Automatisiert Klassenwechsel f√ºr CSS-Animation |
| Vorteil              | Leichtgewichtig, flexibel, kein Fremdanimationstool n√∂tig |

---

## üîó Quellen

- [React Transition Group ‚Äì Doku](https://reactcommunity.org/react-transition-group/)  
- [Beispiel: CSSTransition](https://reactcommunity.org/react-transition-group/css-transition)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

139. ### <a name="139"></a> Was ist React Strict Mode und welche Vorteile bietet er?

# Was ist React Strict Mode und welche Vorteile bietet er?

**`React.StrictMode`** ist eine Wrapper-Komponente von React,  
die **zus√§tzliche Pr√ºfungen und Warnungen** im Entwicklungsmodus aktiviert.  
‚û°Ô∏è Ziel: **Fehler fr√ºhzeitig erkennen** und **zuk√ºnftige Probleme vermeiden**.

üìå Wichtig: Strict Mode **hat keine Auswirkungen im Produktions-Build**.

---

## üß± Verwendung

```jsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
```

---

## ‚úÖ Vorteile und Pr√ºfungen

| Pr√ºfung / Verhalten                      | Beschreibung                                         |
|------------------------------------------|------------------------------------------------------|
| üîÅ Doppelte Aufrufe von Lifecycles        | z.‚ÄØB. `useEffect`, `constructor` ‚Üí zur Fehlererkennung |
| ‚ö†Ô∏è Veraltete Methoden erkennen            | z.‚ÄØB. `componentWillMount` (nicht mehr empfohlen)    |
| üßµ Unerw√ºnschte Side-Effects aufdecken    | durch mehrfaches Mounten/Unmounten simuliert        |
| üö® Warnungen bei Legacy-API-Nutzung       | z.‚ÄØB. `findDOMNode()`, veraltete Context-API         |
| üöß Vorbereitung auf zuk√ºnftige Features   | z.‚ÄØB. automatische Batching oder Concurrent Mode     |

---

## üß™ Beispiel: doppeltes `useEffect`

```jsx
useEffect(() => {
  console.log('l√§uft');
}, []);
```

‚û°Ô∏è Im Strict Mode erscheint `l√§uft` **zweimal in der Konsole** ‚Äì aber nur im Dev-Modus.  
Das ist **beabsichtigt**, um **unsichere Nebeneffekte aufzudecken**.

---

## üìù Zusammenfassung

| Merkmal            | Beschreibung                                           |
|--------------------|--------------------------------------------------------|
| `StrictMode`       | React-Tool zur Entwicklungssicherheit                  |
| Nur Dev-Modus      | Keine Auswirkungen auf Produktion                      |
| Vorteile           | Warnungen, doppelte Checks, fr√ºhe Fehlererkennung      |

---

## üîó Quellen

- [React ‚Äì Strict Mode](https://react.dev/reference/react/StrictMode)  
- [React ‚Äì Stricter Effects](https://react.dev/learn/strict-mode#ensuring-reusable-state)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

140. ### <a name="140"></a> Was ist Concurrent Mode und welche Probleme l√∂st er?

# Was ist Concurrent Mode und welche Probleme l√∂st er?

**Concurrent Mode** (in React 18 als **Concurrent Features** bezeichnet) ist ein moderner Render-Modus,  
der React erlaubt, **Rendering-Aufgaben zu unterbrechen, zu pausieren und fortzusetzen**,  
um eine **reaktionsschnellere und fl√ºssigere Benutzeroberfl√§che** zu erm√∂glichen.

‚û°Ô∏è Ziel: **Asynchrones, priorit√§tsbasiertes und unterbrechbares Rendering**.

---

## üß† Probleme im traditionellen Modus

| Problem                          | Erkl√§rung                                                  |
|----------------------------------|-------------------------------------------------------------|
| üòµ Blockierendes Rendering        | Langsame Komponenten blockieren die ganze UI               |
| üïì Lange Ladezeiten bei √úberg√§ngen | Kein Feedback f√ºr Nutzer bei langsamer Datenverarbeitung   |
| üò° Kein Abbruch laufender Updates | Bei schnellen √Ñnderungen wird trotzdem alles gerendert     |

---

## ‚úÖ Vorteile von Concurrent Mode

| Feature                     | Beschreibung                                                   |
|-----------------------------|----------------------------------------------------------------|
| üßµ Unterbrechbares Rendering | React kann rendering pausieren und sp√§ter fortsetzen          |
| üóÇ Priorisierung             | Wichtige Updates (z.‚ÄØB. Eingaben) k√∂nnen vorgezogen werden     |
| ü™Ñ Automatisches Batching   | Mehrere `setState` Calls werden automatisch zusammengefasst    |
| üåÄ √úberg√§nge (`startTransition`) | √úberg√§nge erscheinen fl√ºssiger, weniger ‚ÄûUI-Freeze‚Äú         |
| üß™ Verbesserung f√ºr SSR + Streaming | Bessere Unterst√ºtzung f√ºr `Suspense` & Server Components |

---

## ‚öôÔ∏è Aktivierung (React 18+)

Concurrent Mode ist **automatisch verf√ºgbar** in React 18,  
wenn du **`createRoot()`** verwendest (statt `ReactDOM.render`):

```jsx
import ReactDOM from 'react-dom/client';
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);
```

---

## üß≠ Beispiel mit `startTransition`

```jsx
import { useState, startTransition } from 'react';

function Search({ items }) {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);

  const handleChange = (e) => {
    const value = e.target.value;
    setQuery(value);

    startTransition(() => {
      const filtered = items.filter((item) => item.includes(value));
      setResults(filtered);
    });
  };

  return (
    <>
      <input value={query} onChange={handleChange} />
      <ul>{results.map((r) => <li key={r}>{r}</li>)}</ul>
    </>
  );
}
```

‚û°Ô∏è `startTransition` markiert den Filtervorgang als **niedrige Priorit√§t**,  
damit Eingaben ohne Verz√∂gerung verarbeitet werden.

---

## üìù Zusammenfassung

| Begriff           | Beschreibung                                                         |
|-------------------|----------------------------------------------------------------------|
| Concurrent Mode   | Neuer React-Modus mit unterbrechbarem, priorisiertem Rendering       |
| Vorteile          | Bessere UX, kein UI-Freeze, schnellere Reaktion auf Nutzeraktionen   |
| Tools             | `createRoot`, `startTransition`, `Suspense`, automatische Batching   |

---

## üîó Quellen

- [React ‚Äì Concurrent Mode](https://react.dev/learn/synchronizing-with-effects#concurrent-rendering)  
- [React 18 ‚Äì Neue Features](https://reactjs.org/blog/2022/03/29/react-v18.html)  
- [startTransition ‚Äì API](https://react.dev/reference/react/startTransition)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

141. ### <a name="141"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

142. ### <a name="142"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

143. ### <a name="143"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

144. ### <a name="144"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

145. ### <a name="145"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

146. ### <a name="146"></a> Was ist ein Service Worker?

# Was ist ein Service Worker?

Ein **Service Worker** ist ein **hintergrundaktives JavaScript-Skript**,  
das **zwischen der Webanwendung und dem Netzwerk** steht.  
Es l√§uft **au√üerhalb der Hauptseite**, kann Netzwerk-Anfragen abfangen,  
Antworten cachen und Funktionen wie **Offline-Unterst√ºtzung** oder **Push-Benachrichtigungen** erm√∂glichen.

---

## üîß Eigenschaften

| Merkmal              | Beschreibung                                                |
|----------------------|-------------------------------------------------------------|
| L√§uft im Hintergrund | Unabh√§ngig vom DOM und UI-Thread                            |
| Ereignisgesteuert    | Reagiert auf `fetch`, `install`, `activate`, `push` etc.   |
| Offline-f√§hig        | Kann Anfragen aus dem Cache bedienen                        |
| Keine direkte DOM-Zugriff | Arbeitet mit `postMessage()` zur Kommunikation        |

---

## ‚úÖ Typische Anwendungsf√§lle

- üì¥ Offline-Webseiten (z.‚ÄØB. PWA)
- ‚ö°Ô∏è Schnellere Ladezeiten durch Caching
- üì° Hintergrund-Synchronisierung
- üîî Push-Benachrichtigungen

---

## üìÅ Lebenszyklus

1. **Registrierung**

```js
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js')
    .then(() => console.log('SW registriert'))
    .catch((err) => console.error('SW Fehler', err));
}
```

2. **Installation**

```js
self.addEventListener('install', (event) => {
  console.log('Service Worker installiert');
});
```

3. **Aktivierung**

```js
self.addEventListener('activate', (event) => {
  console.log('Service Worker aktiviert');
});
```

4. **Anfragen abfangen (`fetch`)**

```js
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request)
      .then((response) => response || fetch(event.request))
  );
});
```

---

## ‚ö†Ô∏è Einschr√§nkungen

| Einschr√§nkung            | Grund                                       |
|---------------------------|---------------------------------------------|
| Nur √ºber HTTPS            | Aus Sicherheitsgr√ºnden                      |
| Kein DOM-Zugriff          | Nur √ºber Messaging                         |
| Komplexe Caching-Strategien | Erfordert manuelles Cache-Management     |

---

## üìù Zusammenfassung

| Begriff         | Beschreibung                                        |
|------------------|-----------------------------------------------------|
| Service Worker   | JS-Skript im Hintergrund, kontrolliert Netzwerk     |
| Vorteil          | Offline-Funktion, schnelleres Laden, Push-Services  |
| Tools            | `navigator.serviceWorker`, `Cache API`, `fetch`     |

---

## üîó Quellen

- [MDN ‚Äì Service Workers](https://developer.mozilla.org/de/docs/Web/API/Service_Worker_API)  
- [Google Web ‚Äì Service Worker Guide](https://developer.chrome.com/docs/workbox/service-worker-overview/)  
- [Web.dev ‚Äì Learn Service Workers](https://web.dev/learn/pwa/service-workers/)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

147. ### <a name="147"></a> Was ist react-helmet und wie hilft es beim SEO?

# Was ist `react-helmet` und wie hilft es beim SEO?

**`react-helmet`** ist eine React-Bibliothek, mit der du dynamisch den `<head>`-Bereich  
deiner Anwendung verwalten kannst ‚Äì z.‚ÄØB. Titel, Meta-Tags, Open Graph Daten etc.

‚û°Ô∏è Besonders hilfreich f√ºr **SEO**, **Social Sharing** und **dynamische Inhalte** bei React-SPAs.

---

## üì¶ Installation

```bash
npm install react-helmet
```

---

## ‚úÖ Verwendung

```jsx
import { Helmet } from 'react-helmet';

function MyPage() {
  return (
    <>
      <Helmet>
        <title>Meine Seite ‚Äì React</title>
        <meta name="description" content="Beschreibung der Seite f√ºr SEO." />
        <meta property="og:title" content="OpenGraph Titel" />
      </Helmet>
      <h1>Willkommen</h1>
    </>
  );
}
```

‚û°Ô∏è Die `<head>`-Elemente werden zur Laufzeit aktualisiert.

---

## üîç SEO-Vorteile

| Vorteil                          | Beschreibung                                      |
|----------------------------------|---------------------------------------------------|
| üß† Dynamischer `<title>`         | Je nach Seite oder Route individuell anpassbar    |
| üîç Meta-Tags optimierbar         | Bessere Sichtbarkeit bei Google, Bing usw.        |
| üì≤ OpenGraph / Twitter Cards     | Attraktive Vorschauen bei Social-Media-Teilen     |
| üåê hreflang, Canonical etc.      | Internationale SEO / Duplicate Content vermeiden  |

---

## üõ† Alternative f√ºr SSR-Umgebungen

Bei **Server-Side Rendering (z.‚ÄØB. Next.js)** wird `react-helmet` oft ersetzt durch:

- `next/head` (Next.js)
- `@remix-run/react` ‚Üí `<Meta />`

‚û°Ô∏è Diese L√∂sungen integrieren sich besser mit SSR und liefern **Head-Infos direkt im initialen HTML**.

---

## üìù Zusammenfassung

| Begriff         | Beschreibung                                       |
|------------------|----------------------------------------------------|
| `react-helmet`   | Bibliothek zur Verwaltung von `<head>`-Tags       |
| Nutzen           | Verbesserte SEO, bessere Social-Media-Darstellung |
| Typische Tags    | `<title>`, `<meta>`, OpenGraph, Canonical-Links   |

---

## üîó Quellen

- [react-helmet ‚Äì GitHub](https://github.com/nfl/react-helmet)  
- [react-helmet ‚Äì Dokumentation](https://www.npmjs.com/package/react-helmet)  
- [MDN ‚Äì Meta-Tags f√ºr SEO](https://developer.mozilla.org/de/docs/Learn/HTML/Introduction_to_HTML/The_head_metadata_in_HTML)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

148. ### <a name="148"></a> Wie funktioniert Lazy Loading mit dynamic import()?

# Wie funktioniert Lazy Loading mit `dynamic import()`?

**Lazy Loading** bedeutet, dass Module oder Komponenten **erst bei Bedarf** geladen werden ‚Äì  
nicht beim Initial-Load.  
Mit `dynamic import()` kannst du in JavaScript oder React **Code-Splitting** betreiben  
und so die **Ladezeit und Performance verbessern**.

---

## üì¶ Syntax: `import()` als Funktion

```js
import('./modul.js').then((modul) => {
  modul.doSomething();
});
```

- Gibt ein **Promise** zur√ºck  
- L√§dt das Modul **asynchron**

---

## ‚úÖ Verwendung in React mit `React.lazy()`

```jsx
import React, { Suspense } from 'react';

const LazyComponent = React.lazy(() => import('./MyComponent'));

function App() {
  return (
    <Suspense fallback={<p>L√§dt‚Ä¶</p>}>
      <LazyComponent />
    </Suspense>
  );
}
```

üìå Nur wenn `LazyComponent` gerendert werden soll, wird es mit `import()` geladen.

---

## üß† Vorteile von Lazy Loading

| Vorteil                 | Beschreibung                                 |
|--------------------------|----------------------------------------------|
| üöÄ Schnellere Initial-Ladezeit | Nur kritischer Code wird zuerst geladen       |
| üì¶ Kleineres Bundle         | Spart Speicher und Traffic                   |
| üì≤ Besseres Nutzererlebnis  | Schnellerer Page Load ‚Üí weniger Wartezeit     |

---

## üåç Beispiel: Lazy Loading bei Routen (mit `react-router`)

```jsx
const Home = React.lazy(() => import('./pages/Home'));
const About = React.lazy(() => import('./pages/About'));

<Routes>
  <Route path="/" element={
    <Suspense fallback={<p>Home l√§dt‚Ä¶</p>}>
      <Home />
    </Suspense>
  } />
  <Route path="/about" element={
    <Suspense fallback={<p>About l√§dt‚Ä¶</p>}>
      <About />
    </Suspense>
  } />
</Routes>
```

---

## ‚ö†Ô∏è Einschr√§nkungen

| Einschr√§nkung            | Beschreibung                                |
|---------------------------|---------------------------------------------|
| Nur Default-Exports       | `React.lazy()` funktioniert nur mit Default |
| Suspense erforderlich     | Ohne `Suspense` keine Anzeige beim Laden    |
| Kein SSR-Support direkt   | Nur clientseitiges Lazy Loading             |

---

## üìù Zusammenfassung

| Begriff             | Beschreibung                                     |
|----------------------|--------------------------------------------------|
| `import()`           | Asynchrone Modul-Ladung                          |
| `React.lazy()`       | Lazy Loading von React-Komponenten               |
| Vorteil              | Code-Splitting, schnellere Ladezeit              |

---

## üîó Quellen

- [MDN ‚Äì import()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#dynamic_imports)  
- [React ‚Äì Code-Splitting mit lazy()](https://react.dev/learn/code-splitting)  
- [React ‚Äì React.lazy() API](https://react.dev/reference/react/lazy)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

149. ### <a name="149"></a> Was ist ein Finite-State Machine (FSM), z. B. mit XState?

# Was ist eine Finite-State Machine (FSM), z.‚ÄØB. mit XState?

Eine **Finite-State Machine (FSM)** ist ein Modell zur Darstellung von **endlich vielen Zust√§nden**  
und den **√úberg√§ngen (Transitions)** zwischen ihnen ‚Äì abh√§ngig von bestimmten Ereignissen (Events).

‚û°Ô∏è In React-Anwendungen eignet sich FSM perfekt zur **klaren Zustandslogik**, z.‚ÄØB. f√ºr Formulare, Auth, UI-States etc.

üì¶ Beliebtes Tool: [`XState`](https://xstate.js.org)

---

## üß† Grundprinzip einer FSM

| Begriff      | Erkl√§rung                                 |
|--------------|--------------------------------------------|
| `State`      | Ein Zustand (z.‚ÄØB. `idle`, `loading`)      |
| `Event`      | Ausl√∂ser f√ºr Zustandswechsel (`FETCH`, `ERROR`) |
| `Transition` | √úbergang von Zustand A zu B                |
| `Initial`    | Startzustand                              |
| `Final`      | Endzustand (optional)                      |

---

## ‚úÖ Beispiel als Objekt (XState-Syntax)

```js
import { createMachine } from 'xstate';

const fetchMachine = createMachine({
  id: 'fetch',
  initial: 'idle',
  states: {
    idle: {
      on: { FETCH: 'loading' },
    },
    loading: {
      on: {
        RESOLVE: 'success',
        REJECT: 'failure',
      },
    },
    success: {},
    failure: {
      on: { RETRY: 'loading' },
    },
  },
});
```

‚û°Ô∏è FSM wechselt nur **kontrolliert** zwischen definierten Zust√§nden.

---

## ‚öõÔ∏è Verwendung mit React (`@xstate/react`)

```jsx
import { useMachine } from '@xstate/react';
import { fetchMachine } from './machines/fetchMachine';

function Fetcher() {
  const [state, send] = useMachine(fetchMachine);

  return (
    <>
      {state.matches('idle') && <button onClick={() => send('FETCH')}>Laden</button>}
      {state.matches('loading') && <p>‚è≥ Ladevorgang...</p>}
      {state.matches('success') && <p>‚úÖ Erfolgreich geladen</p>}
      {state.matches('failure') && (
        <button onClick={() => send('RETRY')}>üîÅ Wiederholen</button>
      )}
    </>
  );
}
```

---

## üß≠ Warum FSM in UI sinnvoll ist

| Vorteil                            | Beschreibung                                 |
|------------------------------------|----------------------------------------------|
| üí° Klar definierte Zust√§nde         | Kein "unbekannter" Zustand mehr              |
| üîê Vorhersehbares Verhalten         | Transitions nur auf erlaubte Events m√∂glich  |
| üîÑ Wiederverwendbar & testbar       | Zust√§nde sind unabh√§ngig von Komponenten     |
| üß© Visualisierbar                   | Tools wie [XState Visualizer](https://xstate.js.org/viz/) zeigen √úberg√§nge grafisch |

---

## üìù Zusammenfassung

| Begriff     | Erkl√§rung                                            |
|--------------|-------------------------------------------------------|
| FSM         | Modell zur Kontrolle von Zust√§nden                    |
| XState      | Library zur Definition & Ausf√ºhrung von FSMs          |
| Vorteil     | Mehr Kontrolle, bessere UI-Logik, einfache Wartbarkeit|

---

## üîó Quellen

- [XState Docs](https://xstate.js.org/docs/)  
- [XState ‚Äì React Integration](https://xstate.js.org/docs/packages/xstate-react/)  
- [MDN ‚Äì Finite-State Machine](https://developer.mozilla.org/en-US/docs/Glossary/Finite-state_machine)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

150. ### <a name="150"></a> Wie kann man ein Formular mit Formik und Yup erstellen und validieren?

# Wie kann man ein Formular mit Formik und Yup erstellen und validieren?

**Formik** ist eine beliebte React-Bibliothek zur einfachen Erstellung und Verwaltung von Formularen.  
**Yup** ist ein Schema-Builder zur Validierung von Formularwerten.  
‚û°Ô∏è Zusammen erm√∂glichen sie **strukturiertes, sauberes und validiertes Formular-Handling** in React.

---

## üì¶ Installation

```bash
npm install formik yup
```

---

## ‚úÖ Beispiel: Login-Formular mit Validierung

```jsx
import { Formik, Form, Field, ErrorMessage } from 'formik';
import * as Yup from 'yup';

// ‚úÖ Validierungsschema mit Yup
const validationSchema = Yup.object({
  email: Yup.string()
    .email('Ung√ºltige E-Mail')
    .required('E-Mail ist erforderlich'),
  password: Yup.string()
    .min(6, 'Mindestens 6 Zeichen')
    .required('Passwort ist erforderlich'),
});

function LoginForm() {
  return (
    <Formik
      initialValues={{ email: '', password: '' }}
      validationSchema={validationSchema}
      onSubmit={(values) => {
        console.log('Formulardaten:', values);
      }}
    >
      <Form className="space-y-4">
        <div>
          <label htmlFor="email">E-Mail:</label>
          <Field name="email" type="email" className="border p-1 w-full" />
          <ErrorMessage name="email" component="div" className="text-red-600 text-sm" />
        </div>

        <div>
          <label htmlFor="password">Passwort:</label>
          <Field name="password" type="password" className="border p-1 w-full" />
          <ErrorMessage name="password" component="div" className="text-red-600 text-sm" />
        </div>

        <button type="submit" className="bg-blue-500 text-white px-4 py-2 rounded">
          Einloggen
        </button>
      </Form>
    </Formik>
  );
}
```

---

## üß† Was macht Formik?

| Feature              | Beschreibung                                            |
|----------------------|---------------------------------------------------------|
| `initialValues`      | Startwerte f√ºr das Formular                             |
| `validationSchema`   | Yup-Schema zur Feldvalidierung                          |
| `onSubmit`           | Funktion, die bei erfolgreichem Submit ausgef√ºhrt wird  |
| `<Field>`            | Automatisch angebundene Eingabefelder                   |
| `<ErrorMessage>`     | Zeigt Fehlermeldungen f√ºr bestimmte Felder              |

---

## üìå Vorteile von Formik + Yup

| Vorteil               | Beschreibung                                     |
|------------------------|--------------------------------------------------|
| ‚úÖ Trennung von Logik & UI | Validierung getrennt in Schema                  |
| üß™ Testbare Formulare   | Zust√§nde und Fehler leicht √ºberpr√ºfbar            |
| üîÅ Automatisches Reset  | Einfaches Reset bei Erfolg oder Abbruch          |
| ‚ö†Ô∏è Benutzerfreundliche Fehlermeldungen | Direkt unter Eingabefeldern              |

---

## üìù Zusammenfassung

| Tool     | Zweck                          |
|----------|--------------------------------|
| Formik   | Formularzustand, Events, Submit |
| Yup      | Validierungsschema f√ºr Felder   |
| Vorteil  | Weniger Boilerplate, klare Struktur, bessere UX |

---

## üîó Quellen

- [Formik ‚Äì Dokumentation](https://formik.org/docs/overview)  
- [Yup ‚Äì Doku](https://github.com/jquense/yup)  
- [Formik + Yup Beispiel](https://formik.org/docs/guides/validation)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

151. ### <a name="151"></a> Wie konfiguriert man ESLint und Prettier in einem React-Projekt?

# Wie konfiguriert man ESLint und Prettier in einem React-Projekt?

**ESLint** analysiert deinen Code und findet potenzielle Fehler und Stilprobleme.  
**Prettier** ist ein Code-Formatter, der f√ºr konsistente Formatierung sorgt.  
Zusammen sorgen sie f√ºr **sauberen, wartbaren Code** in React-Projekten.

---

## üì¶ Schritt-f√ºr-Schritt-Anleitung

### 1Ô∏è‚É£ ESLint + Prettier installieren

```bash
npm install -D eslint prettier eslint-config-prettier eslint-plugin-prettier
```

### 2Ô∏è‚É£ ESLint f√ºr React installieren

```bash
npm install -D eslint-plugin-react eslint-plugin-react-hooks
```

Bei TypeScript zus√§tzlich:

```bash
npm install -D @typescript-eslint/eslint-plugin @typescript-eslint/parser
```

---

## üìÅ ESLint-Konfiguration (`.eslintrc.json`)

```json
{
  "env": {
    "browser": true,
    "es2021": true
  },
  "extends": [
    "eslint:recommended",
    "plugin:react/recommended",
    "plugin:react-hooks/recommended",
    "plugin:prettier/recommended"
  ],
  "plugins": ["react", "react-hooks", "prettier"],
  "parserOptions": {
    "ecmaVersion": "latest",
    "sourceType": "module",
    "ecmaFeatures": {
      "jsx": true
    }
  },
  "rules": {
    "prettier/prettier": "error"
  },
  "settings": {
    "react": {
      "version": "detect"
    }
  }
}
```

‚û°Ô∏è `"plugin:prettier/recommended"` integriert Prettier automatisch in ESLint.

---

## üßº Prettier-Konfiguration (`.prettierrc`)

```json
{
  "semi": true,
  "singleQuote": true,
  "tabWidth": 2,
  "trailingComma": "es5",
  "printWidth": 80
}
```

---

## üõ† Weitere Dateien

### `.eslintignore`

```
node_modules
build
dist
```

### `.prettierignore`

```
build
dist
*.svg
```

---

## üß™ Test: ESLint und Prettier ausf√ºhren

```bash
npx eslint src --ext .js,.jsx,.ts,.tsx
npx prettier --check .
```

Oder automatisch fixen:

```bash
npx eslint src --fix
npx prettier --write .
```

---

## ‚öõÔ∏è VSCode-Integration

- Erweiterungen installieren:
  - ESLint
  - Prettier ‚Äì Code formatter

- In den Einstellungen (`.vscode/settings.json`):

```json
{
  "editor.formatOnSave": true,
  "editor.defaultFormatter": "esbenp.prettier-vscode"
}
```

---

## üìù Zusammenfassung

| Tool       | Zweck                                  |
|------------|-----------------------------------------|
| ESLint     | Analyse von Code-Stil und Fehlern       |
| Prettier   | Einheitliche automatische Formatierung  |
| Vorteil    | Sauberer Code, weniger Fehler, Teamkonsistenz |

---

## üîó Quellen

- [ESLint ‚Äì Dokumentation](https://eslint.org/docs/latest/)  
- [Prettier ‚Äì Docs](https://prettier.io/docs/en/index.html)  
- [eslint-config-prettier](https://github.com/prettier/eslint-config-prettier)  
- [React ESLint Setup](https://react.dev/learn/linting)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

152. ### <a name="152"></a> Wie funktioniert dynamic import() in React (Syntax, Anwendungsf√§lle)?

# Wie funktioniert `dynamic import()` in React (Syntax & Anwendungsf√§lle)?

`dynamic import()` ist eine **JavaScript-Funktion**, mit der Module **asynchron geladen** werden k√∂nnen.  
In React wird diese Technik vor allem f√ºr **Lazy Loading und Code-Splitting** eingesetzt,  
um die **Initial-Ladezeit zu reduzieren** und die **Performance zu verbessern**.

---

## üì¶ Syntax

```js
import('./MyComponent.js').then((modul) => {
  modul.default(); // Zugriff auf den Default-Export
});
```

- Gibt ein **Promise** zur√ºck
- Kann √ºberall im Code verwendet werden, z.‚ÄØB. in Funktionen, Event-Handlern oder Bedingungsausdr√ºcken

---

## ‚úÖ Verwendung mit `React.lazy()`

In React ist `React.lazy()` die empfohlene Methode f√ºr dynamisches Importieren von **Komponenten**.

```jsx
import React, { Suspense } from 'react';

const LazyComponent = React.lazy(() => import('./MyComponent'));

function App() {
  return (
    <Suspense fallback={<div>L√§dt‚Ä¶</div>}>
      <LazyComponent />
    </Suspense>
  );
}
```

üìå Wichtig: Komponenten m√ºssen **default-exportiert** sein.  
Das `fallback` wird w√§hrend des Ladevorgangs angezeigt.

---

## üß† Anwendungsf√§lle

| Anwendungsfall           | Beschreibung                                       |
|---------------------------|----------------------------------------------------|
| üéØ Route-basiertes Lazy Loading | Nur beim Aufruf einer Seite wird Code geladen     |
| üß© Gro√üe Komponenten       | Nur geladen, wenn sie ben√∂tigt werden (z.‚ÄØB. Modale) |
| üåç Sprache / i18n          | Dynamisches Nachladen von Sprachdateien            |
| üõ† Admin-Panels            | Nur bei bestimmten Rollen laden                   |

---

## üåç Beispiel: Routing mit React Router

```jsx
const Home = React.lazy(() => import('./pages/Home'));
const About = React.lazy(() => import('./pages/About'));

<Routes>
  <Route path="/" element={
    <Suspense fallback={<p>Loading...</p>}>
      <Home />
    </Suspense>
  } />
  <Route path="/about" element={
    <Suspense fallback={<p>Loading...</p>}>
      <About />
    </Suspense>
  } />
</Routes>
```

---

## üìù Zusammenfassung

| Begriff            | Beschreibung                                 |
|---------------------|----------------------------------------------|
| `import()`          | Dynamischer Modulimport, Promise-basiert     |
| `React.lazy()`      | F√ºr Lazy Loading von Komponenten             |
| Vorteil             | Geringere Bundle-Gr√∂√üe, schnellerer Start    |
| Voraussetzung       | Nur f√ºr **Default-Exports** geeignet         |

---

## üîó Quellen

- [MDN ‚Äì Dynamic import()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#dynamic_imports)  
- [React Docs ‚Äì Lazy Loading](https://react.dev/learn/code-splitting)  
- [React.lazy() ‚Äì API](https://react.dev/reference/react/lazy)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

153. ### <a name="153"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

154. ### <a name="154"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

155. ### <a name="155"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

156. ### <a name="156"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

157. ### <a name="157"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

158. ### <a name="158"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

159. ### <a name="159"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

160. ### <a name="160"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

161. ### <a name="161"></a> Was ist der Unterschied zwischen interface und type in TypeScript?

# Was ist der Unterschied zwischen `interface` und `type` in TypeScript?

Sowohl `interface` als auch `type` dienen in TypeScript zur **Definition von Strukturen** f√ºr Objekte,  
Funktionen oder andere Typen.  
‚û°Ô∏è In vielen F√§llen sind sie **austauschbar**, aber es gibt **wichtige Unterschiede**.

---

## ‚úÖ Gemeinsamkeiten

Beide k√∂nnen verwendet werden, um **Objektformen** zu beschreiben:

```ts
interface Person {
  name: string;
  age: number;
}

type PersonType = {
  name: string;
  age: number;
};
```

Beide k√∂nnen **f√ºr Funktionen** verwendet werden:

```ts
interface SayHi {
  (name: string): string;
}

type SayHiType = (name: string) => string;
```

---

## üîç Unterschiede im Detail

| Aspekt               | `interface`                                  | `type`                                         |
|----------------------|-----------------------------------------------|------------------------------------------------|
| Erweiterung          | `extends` ‚Äì mehrfach erweiterbar             | `&` ‚Äì Intersection f√ºr Kombination             |
| Zusammenf√ºhrbarkeit  | ‚úÖ Automatisches Merging                      | ‚ùå Kein Merging m√∂glich                        |
| Union / Intersection | ‚ùå Nur √ºber Vererbung                        | ‚úÖ `A | B`, `A & B` m√∂glich                    |
| Verwendung f√ºr Primitives | ‚ùå Nicht erlaubt                          | ‚úÖ `type ID = string | number;`                |
| Lesbarkeit im Compiler | üëå besser geeignet f√ºr IntelliSense         | weniger sichtbar in komplexen Typen            |

---

## üß™ Beispiel: Interface Merging

```ts
interface User {
  name: string;
}

interface User {
  age: number;
}

// Merged automatisch zu:
const u: User = {
  name: 'Anna',
  age: 30,
};
```

Mit `type` w√§re das ein Fehler:

```ts
type User = {
  name: string;
};

type User = {
  age: number;
}; // ‚ùå Fehler: Duplicate Identifier
```

---

## üìå Wann welches?

| Anwendungsfall                  | Empfehlung         |
|----------------------------------|--------------------|
| √ñffentliche API (Libraries)     | `interface`        |
| Kombinationen, Unions           | `type`             |
| Erweiterung von Komponenten     | `interface`        |
| Primitive oder komplexe Typkombination | `type`     |

---

## üìù Zusammenfassung

| `interface`                     | `type`                                      |
|----------------------------------|---------------------------------------------|
| Gut f√ºr OOP & Vererbung         | Flexibel f√ºr Kombinationen & Unions         |
| Unterst√ºtzt automatische Merges | Keine Mehrfachdefinition erlaubt            |
| Empfohlen f√ºr Klassen & Props   | Empfohlen f√ºr komplexe Typdefinitionen      |

---

## üîó Quellen

- [TypeScript: Interfaces](https://www.typescriptlang.org/docs/handbook/interfaces.html)  
- [TypeScript: Advanced Types](https://www.typescriptlang.org/docs/handbook/advanced-types.html)  
- [Type vs Interface ‚Äì offizielle Empfehlung](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#interfaces)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

162. ### <a name="162"></a> Wie typisiert man Props und State in einer funktionalen Komponente?

# Wie typisiert man Props und State in einer funktionalen Komponente (TypeScript)?

In TypeScript kannst du Props und State in funktionalen React-Komponenten mithilfe von **Generics**  
und eigenen **Interfaces oder Typen** explizit typisieren.

---

## ‚úÖ 1. Props typisieren

```tsx
type UserProps = {
  name: string;
  age: number;
};

const UserCard: React.FC<UserProps> = ({ name, age }) => {
  return (
    <div>
      <h2>{name}</h2>
      <p>{age} Jahre alt</p>
    </div>
  );
};
```

> `React.FC<Props>` enth√§lt automatisch `children` und `FunctionComponent`-Typisierung.

Alternativ ohne `React.FC`:

```tsx
const UserCard = ({ name, age }: UserProps) => {
  return <p>{name} ({age})</p>;
};
```

---

## ‚úÖ 2. State typisieren mit `useState`

```tsx
import { useState } from 'react';

const Counter = () => {
  const [count, setCount] = useState<number>(0);

  return (
    <button onClick={() => setCount(count + 1)}>
      Klicks: {count}
    </button>
  );
};
```

üî∏ F√ºr komplexe State-Objekte:

```tsx
type Todo = {
  id: number;
  text: string;
  completed: boolean;
};

const TodoList = () => {
  const [todos, setTodos] = useState<Todo[]>([]);
  // todos: Array von Todo-Objekten
};
```

---

## üß† Best Practices

| Bereich     | Empfehlung                                      |
|-------------|-------------------------------------------------|
| Props       | Interface oder Type erstellen                   |
| State       | Typen direkt in `useState<T>()` angeben         |
| React.FC    | Optional, aber gut f√ºr automatische `children`  |

---

## üìù Zusammenfassung

| Typisierung | Beispiel                                       |
|-------------|------------------------------------------------|
| Props       | `type Props = { name: string }`               |
| State       | `useState<number>(0)` oder `useState<Todo[]>()` |
| Vorteil     | Typsicherheit, bessere DX, Autovervollst√§ndigung |

---

## üîó Quellen

- [React mit TypeScript ‚Äì Props & State](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example/)  
- [TypeScript: React.FC vs normales Function Props Typing](https://www.typescriptlang.org/docs/handbook/react.html)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

163. ### <a name="163"></a> Wie nutzt man Generics in React mit TypeScript (z. B. f√ºr Listen)?

# Wie nutzt man Generics in React mit TypeScript? (z.‚ÄØB. f√ºr Listen)

**Generics** erlauben es dir, Komponenten in React **flexibel und wiederverwendbar** zu gestalten,  
indem du den Typ der Daten **zur Laufzeit bestimmst**, ohne ihn fest zu codieren.

‚û°Ô∏è Besonders n√ºtzlich f√ºr **Listen, Tabellen, Formulare, Dropdowns**, u.‚ÄØv.‚ÄØm.

---

## üß± Beispiel: Generische `List`-Komponente

```tsx
type ListProps<T> = {
  items: T[];
  renderItem: (item: T) => React.ReactNode;
};

function List<T>({ items, renderItem }: ListProps<T>) {
  return (
    <ul>
      {items.map((item, index) => (
        <li key={index}>{renderItem(item)}</li>
      ))}
    </ul>
  );
}
```

‚úÖ `T` ist der **generische Typ**  
‚úÖ `items: T[]` ist ein Array beliebiger Typen  
‚úÖ `renderItem` definiert, **wie ein Element gerendert wird**

---

## üîç Verwendung mit verschiedenen Typen

### üßç Beispiel 1: Liste von Benutzern

```tsx
type User = {
  id: number;
  name: string;
};

const users: User[] = [
  { id: 1, name: 'Anna' },
  { id: 2, name: 'Tom' },
];

<List
  items={users}
  renderItem={(user) => <span>{user.name}</span>}
/>
```

### üì¶ Beispiel 2: Liste von Zahlen

```tsx
const zahlen = [1, 2, 3];

<List
  items={zahlen}
  renderItem={(n) => <strong>{n}</strong>}
/>
```

---

## üß† Vorteile von Generics in React

| Vorteil                   | Beschreibung                                 |
|----------------------------|----------------------------------------------|
| üîÅ Wiederverwendbarkeit    | Komponente funktioniert mit jedem Typ        |
| ‚úÖ Typsicherheit           | Keine `any`-Typen, volle Autovervollst√§ndigung |
| üß© Kombinierbar mit Props  | Flexible, starke Komponenten m√∂glich         |

---

## üìù Zusammenfassung

| Element     | Beschreibung                                |
|-------------|---------------------------------------------|
| `T`         | Platzhalter f√ºr einen konkreten Typ         |
| `List<T>`   | Komponente mit generischem Datentyp         |
| Vorteil     | Wiederverwendbare & typsichere Komponenten  |

---

## üîó Quellen

- [TypeScript ‚Äì Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)  
- [React + TS ‚Äì Generische Komponenten](https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase#generic-components)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

164. ### <a name="164"></a> Wie typisiert man Events in React mit TypeScript (onChange, onClick, FormEvent, MouseEvent)?

# Wie typisiert man Events in React mit TypeScript?  
(z.‚ÄØB. `onChange`, `onClick`, `FormEvent`, `MouseEvent`)

In TypeScript kannst du Events in React pr√§zise typisieren,  
um Typsicherheit bei Event-Handlern wie `onClick`, `onChange`, `onSubmit` usw. zu gew√§hrleisten.

---

## ‚úÖ H√§ufige Event-Typen

| Event                | Typ                                                  |
|----------------------|------------------------------------------------------|
| `onClick`            | `React.MouseEvent<HTMLButtonElement>`               |
| `onChange`           | `React.ChangeEvent<HTMLInputElement>`               |
| `onSubmit`           | `React.FormEvent<HTMLFormElement>`                  |
| `onKeyDown`          | `React.KeyboardEvent<HTMLInputElement>`             |

---

## üì¶ Beispiele

### üñ± `onClick` mit Button

```tsx
const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {
  console.log('Button geklickt');
};

<button onClick={handleClick}>Klick mich</button>
```

---

### üî§ `onChange` mit Input-Feld

```tsx
const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
  console.log(e.target.value);
};

<input type="text" onChange={handleChange} />
```

---

### üì© `onSubmit` bei Formular

```tsx
const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
  e.preventDefault();
  console.log('Formular abgeschickt');
};

<form onSubmit={handleSubmit}>
  <button type="submit">Senden</button>
</form>
```

---

### ‚å®Ô∏è `onKeyDown` bei Texteingabe

```tsx
const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
  if (e.key === 'Enter') {
    console.log('Enter gedr√ºckt');
  }
};

<input type="text" onKeyDown={handleKeyDown} />
```

---

## üß† Tipp: Generische Schreibweise (optional)

```tsx
const handleClick = <T extends HTMLElement>(
  e: React.MouseEvent<T>
) => {
  console.log(e.currentTarget);
};
```

---

## üìù Zusammenfassung

| Event-Typ                  | React-Typ                                       |
|-----------------------------|-------------------------------------------------|
| Button-Klick (`onClick`)    | `React.MouseEvent<HTMLButtonElement>`          |
| Texteingabe (`onChange`)    | `React.ChangeEvent<HTMLInputElement>`          |
| Formular-Abgabe (`onSubmit`)| `React.FormEvent<HTMLFormElement>`             |
| Tastatur (`onKeyDown`)      | `React.KeyboardEvent<HTMLInputElement>`        |

---

## üîó Quellen

- [React TypeScript Cheatsheet ‚Äì Events](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/events/)  
- [TypeScript Handbook ‚Äì React Events](https://www.typescriptlang.org/docs/handbook/react.html)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

165. ### <a name="165"></a> Wie erstellt man einen benutzerdefinierten Hook mit TypeScript?

# Wie erstellt man einen benutzerdefinierten Hook mit TypeScript?

Ein **benutzerdefinierter Hook** (Custom Hook) ist eine Funktion,  
die React-Hooks verwendet und eine **wiederverwendbare Logik** kapselt.  
Mit TypeScript kannst du ihn **typisieren**, um Typsicherheit und Autovervollst√§ndigung zu erhalten.

---

## ‚úÖ Beispiel: useLocalStorage-Hook

```tsx
import { useState, useEffect } from 'react';

function useLocalStorage<T>(key: string, initialValue: T) {
  const [value, setValue] = useState<T>(() => {
    try {
      const item = localStorage.getItem(key);
      return item ? (JSON.parse(item) as T) : initialValue;
    } catch (error) {
      console.warn('Fehler beim Lesen aus localStorage', error);
      return initialValue;
    }
  });

  useEffect(() => {
    try {
      localStorage.setItem(key, JSON.stringify(value));
    } catch (error) {
      console.warn('Fehler beim Schreiben in localStorage', error);
    }
  }, [key, value]);

  return [value, setValue] as const;
}
```

---

## üì¶ Verwendung

```tsx
const [username, setUsername] = useLocalStorage<string>('username', 'Gast');

<input
  value={username}
  onChange={(e) => setUsername(e.target.value)}
/>
```

---

## üîç Erkl√§rung

| Teil                       | Bedeutung                                     |
|----------------------------|-----------------------------------------------|
| `useLocalStorage<T>`       | Generischer Hook, der mit beliebigem Typ funktioniert |
| `initialValue: T`          | Startwert wird als Typ √ºbergeben              |
| `as const`                 | R√ºckgabe-Tuple ist readonly & typensicher     |

---

## üß† Typische Einsatzbereiche f√ºr Custom Hooks

- `useWindowSize` ‚Äì Fensterbreite/-h√∂he verfolgen  
- `useDebounce` ‚Äì Werte verz√∂gert weitergeben  
- `usePrevious` ‚Äì Vorherigen Wert merken  
- `useForm` ‚Äì Formular-Handling kapseln  
- `useFetch` ‚Äì API-Daten abrufen  

---

## üìù Zusammenfassung

| Element             | Beschreibung                            |
|---------------------|------------------------------------------|
| Custom Hook         | Wiederverwendbare Logik mit Hooks        |
| TypeScript Support  | Generische Parameter und R√ºckgabetypen   |
| Vorteil             | Kapselung, Typensicherheit, Wiederverwendbarkeit |

---

## üîó Quellen

- [React ‚Äì Custom Hooks](https://react.dev/learn/reusing-logic-with-custom-hooks)  
- [TypeScript ‚Äì Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)  
- [React TypeScript Cheatsheet ‚Äì Custom Hooks](https://react-typescript-cheatsheet.netlify.app/docs/advanced/hooks/)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

166. ### <a name="166"></a> Wie typisiert man useReducer mit TypeScript?

# Wie typisiert man `useReducer` mit TypeScript?

`useReducer` ist ein React-Hook zur **Verwaltung komplexer Zustandslogik**.  
Mit TypeScript kannst du die **State- und Action-Typen** exakt definieren, um Typsicherheit zu garantieren.

---

## ‚úÖ Grundstruktur mit TypeScript

```tsx
import { useReducer } from 'react';

// 1. State-Typ
type CounterState = {
  count: number;
};

// 2. Action-Typen (Union)
type CounterAction =
  | { type: 'increment' }
  | { type: 'decrement' }
  | { type: 'reset'; payload: number };

// 3. Reducer
function counterReducer(state: CounterState, action: CounterAction): CounterState {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    case 'reset':
      return { count: action.payload };
    default:
      return state;
  }
}

// 4. Verwendung
function Counter() {
  const [state, dispatch] = useReducer(counterReducer, { count: 0 });

  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: 'increment' })}>+</button>
      <button onClick={() => dispatch({ type: 'decrement' })}>‚àí</button>
      <button onClick={() => dispatch({ type: 'reset', payload: 0 })}>Reset</button>
    </div>
  );
}
```

---

## üß† Was wird hier typisiert?

| Element        | Beschreibung                             |
|----------------|------------------------------------------|
| `CounterState` | Struktur des States                      |
| `CounterAction`| M√∂gliche Aktionen als Union-Typ          |
| `useReducer`   | bekommt typisiertes `state` und `action` |

---

## üß© Generischer Reducer-Hook

```tsx
function useGenericReducer<S, A>(
  reducer: (state: S, action: A) => S,
  initialState: S
): [S, React.Dispatch<A>] {
  return useReducer(reducer, initialState);
}
```

---

## üìù Zusammenfassung

| Schritt              | Was wird gemacht                          |
|----------------------|-------------------------------------------|
| `type State`         | Definiert die Struktur des States         |
| `type Action`        | Legt alle m√∂glichen Aktionen fest         |
| `useReducer`         | Erh√§lt `reducer`-Funktion und Startwert   |
| Vorteil              | Saubere Trennung von Logik und UI         |

---

## üîó Quellen

- [React ‚Äì useReducer](https://react.dev/reference/react/useReducer)  
- [TypeScript ‚Äì Typisierung von useReducer](https://react-typescript-cheatsheet.netlify.app/docs/advanced/hooks/#usereducer)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

167. ### <a name="167"></a> Wie typisiert man children korrekt in React-Komponenten?

# Wie typisiert man `children` korrekt in React-Komponenten? (TypeScript)

In React ist `children` ein spezielles Prop, das automatisch √ºbergeben wird,  
wenn **JSX-Inhalte zwischen √ñffnungs- und Schlie√ü-Tags** einer Komponente stehen.

Mit TypeScript kannst du `children` explizit typisieren, um **Typsicherheit** und **bessere Autovervollst√§ndigung** zu erhalten.

---

## ‚úÖ Standard-Typ f√ºr `children`

```tsx
type MyComponentProps = {
  children: React.ReactNode;
};

const MyComponent = ({ children }: MyComponentProps) => {
  return <div>{children}</div>;
};
```

‚û°Ô∏è `React.ReactNode` erlaubt Strings, Zahlen, JSX, Arrays, `null`, `undefined` usw.

---

## üß† Alternativen zu `React.ReactNode`

| Typ                | Beschreibung                                         |
|--------------------|------------------------------------------------------|
| `ReactNode`        | Alles, was in JSX verwendet werden kann              |
| `ReactElement`     | Nur **ein einzelnes JSX-Element**                    |
| `JSX.Element`      | Alias f√ºr `ReactElement`                             |
| `ReactChild`       | Nur string, number, JSX.Element                      |
| `ReactNode[]`      | Nur Array von JSX (nicht `null`, `undefined` etc.)   |

---

## üì¶ Beispiel mit mehreren Props

```tsx
type CardProps = {
  title: string;
  children: React.ReactNode;
};

const Card = ({ title, children }: CardProps) => (
  <div className="border p-4">
    <h2>{title}</h2>
    <div>{children}</div>
  </div>
);
```

üìå Verwendung:

```tsx
<Card title="Info">
  <p>Das ist Inhalt innerhalb von `children`.</p>
</Card>
```

---

## üîÑ Mit `React.FC` (automatisch `children` enthalten)

```tsx
const Layout: React.FC = ({ children }) => {
  return <main>{children}</main>;
};
```

‚û°Ô∏è Vorteil: Kein eigener Typ f√ºr `children` notwendig.  
‚û°Ô∏è Nachteil: `React.FC` hat Einschr√§nkungen bei generischen Props und `defaultProps`.

---

## üìù Zusammenfassung

| Ziel                | Empfehlung                         |
|---------------------|-------------------------------------|
| Beliebige Inhalte   | `children: React.ReactNode`         |
| Nur ein Element     | `children: React.ReactElement`      |
| Automatisch (optional) | `React.FC` verwenden             |

---

## üîó Quellen

- [React ‚Äì Children Props](https://react.dev/learn/passing-props-to-a-component#passing-jsx)  
- [React TypeScript Cheatsheet ‚Äì Children](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example/#typing-children)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

168. ### <a name="168"></a> Was ist React.FC und welche Vor- und Nachteile hat es?

# Was ist `React.FC` und welche Vor- und Nachteile hat es?

`React.FC` (oder `React.FunctionComponent`) ist ein generischer Typ in TypeScript,  
der zur Typisierung von **funktionalen Komponenten** verwendet wird.  
Er ist besonders hilfreich, wenn man **`children` automatisch typisieren** m√∂chte.

---

## ‚úÖ Syntax

```tsx
const MyComponent: React.FC = () => {
  return <div>Hallo</div>;
};
```

Mit Props:

```tsx
type Props = {
  title: string;
};

const Header: React.FC<Props> = ({ title, children }) => (
  <header>
    <h1>{title}</h1>
    {children}
  </header>
);
```

---

## üì¶ Was bringt `React.FC`?

| Funktion                 | Beschreibung                               |
|--------------------------|--------------------------------------------|
| ‚úÖ Automatisch `children`| Kein manuelles Hinzuf√ºgen von `children`  |
| ‚úÖ Generische Props      | √úbergabe von Typen an die Komponente       |
| ‚úÖ Intellisense          | Automatische Vorschl√§ge in VSCode etc.     |

---

## ‚ö†Ô∏è Nachteile von `React.FC`

| Problem                                 | Beschreibung                                  |
|------------------------------------------|-----------------------------------------------|
| ‚ùå Eingeschr√§nkte Generics               | Komplexe Props schwer typisierbar              |
| ‚ùå `defaultProps` wird nicht korrekt unterst√ºtzt | TypeScript erkennt sie nicht automatisch   |
| ‚ùå Zwingt `children`                    | Auch wenn Komponente keine `children` erwartet |

---

## üß† Best Practices

| Situation                       | Empfehlung                   |
|----------------------------------|------------------------------|
| Mit `children`                  | `React.FC` ist praktisch     |
| Ohne `children`                 | Besser eigenes Props-Interface |
| Gro√üe/generische Komponenten   | Lieber eigene Typisierung     |

---

## üîç Vergleich mit manuellem Props-Typ

```tsx
type Props = {
  name: string;
};

const Hello = ({ name }: Props) => <p>Hallo {name}</p>;
```

‚û°Ô∏è Kein `children`, aber volle Kontrolle.  
‚û°Ô∏è Mehr Flexibilit√§t bei Generics.

---

## üìù Zusammenfassung

| Vorteil (`React.FC`)       | Nachteil                              |
|----------------------------|----------------------------------------|
| Automatische `children`    | Eingeschr√§nkte Flexibilit√§t            |
| Klarer Funktions-Typ       | Probleme mit `defaultProps` und Generics |

---

## üîó Quellen

- [React.FC ‚Äì Diskussion auf GitHub](https://github.com/facebook/create-react-app/pull/8177)  
- [React TypeScript Cheatsheet ‚Äì React.FC](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/function_components/)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

169. ### <a name="169"></a> Wie typisiert man eine Komponente mit optionalen Props?

# Wie typisiert man eine Komponente mit **optionalen Props** in TypeScript?

In TypeScript kannst du Props als **optional** deklarieren,  
indem du ein **Fragezeichen (`?`)** hinter dem Namen eines Props setzt.

---

## ‚úÖ Beispiel mit optionalem Prop

```tsx
type ButtonProps = {
  label: string;
  color?: string; // optional
};

const Button = ({ label, color = 'blue' }: ButtonProps) => {
  return <button className={`bg-${color}-500 text-white p-2`}>{label}</button>;
};
```

üìå `color` ist optional. Wenn es nicht √ºbergeben wird, nutzt die Komponente `"blue"` als Default.

---

## üß† Warum `color = 'blue'`?

Das ist der **Default-Wert** in der Funktion.  
Wird `color` nicht √ºbergeben, verwendet React automatisch den angegebenen Fallback.

---

## üí° Mit `React.FC` (funktioniert auch)

```tsx
type AlertProps = {
  message?: string;
};

const Alert: React.FC<AlertProps> = ({ message }) => {
  return <div>{message ?? 'Standard-Nachricht'}</div>;
};
```

---

## üß™ Mit `children` und optionalen Props

```tsx
type CardProps = {
  title?: string;
  children: React.ReactNode;
};

const Card = ({ title, children }: CardProps) => (
  <div className="p-4 border">
    {title && <h2>{title}</h2>}
    {children}
  </div>
);
```

---

## üìù Zusammenfassung

| Merkmal                  | Beschreibung                                 |
|--------------------------|----------------------------------------------|
| `propName?: type`        | Macht das Prop optional                      |
| `propName = value`       | Setzt einen Default-Wert innerhalb der Funktion |
| Vorteil                  | Flexible Verwendung, saubere Komponenten     |

---

## üîó Quellen

- [TypeScript ‚Äì Optional Properties](https://www.typescriptlang.org/docs/handbook/2/objects.html#optional-properties)  
- [React TypeScript Cheatsheet ‚Äì Props](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example/)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

170. ### <a name="170"></a> Wie arbeitet man mit Drittanbieter-Bibliotheken, die keine Typen enthalten?

# Wie arbeitet man mit Drittanbieter-Bibliotheken, die **keine Typen** enthalten?

Wenn eine JavaScript-Bibliothek **keine TypeScript-Typen** bereitstellt,  
kannst du sie trotzdem verwenden ‚Äì mithilfe von:

1. üß© **@types/**-Paketen  
2. üß® **declare module**  
3. üß† Eigene Typdefinitionen schreiben  

---

## ‚úÖ 1. Pr√ºfen, ob es ein `@types/`-Paket gibt

Viele Bibliotheken haben ein **extern gepflegtes Typ-Paket**:

```bash
npm install --save-dev @types/lodash
```

üì¶ Quelle: https://github.com/DefinitelyTyped/DefinitelyTyped

---

## ‚ùå 2. Wenn keine Typen existieren: `declare module`

Erstelle z.‚ÄØB. eine Datei `src/types/thirdparty.d.ts`:

```ts
declare module 'untypisierte-lib' {
  const content: any;
  export default content;
}
```

‚û°Ô∏è Damit kannst du das Modul **ohne Typsicherheitsfehler** importieren:

```ts
import foo from 'untypisierte-lib';
```

---

## ‚úçÔ∏è 3. Eigene Typen definieren (besser als `any`)

```ts
declare module 'untypisierte-lib' {
  export function greet(name: string): string;
  export const version: string;
}
```

‚û°Ô∏è Nun bekommst du **Autovervollst√§ndigung & Typsicherheit** beim Import:

```ts
import { greet } from 'untypisierte-lib';
greet('Sergii');
```

---

## üß† Typ "any" vermeiden

```ts
import xyz from 'legacy-lib';
// schlechter Stil:
(xyz as any).doSomething(); // ‚õîÔ∏è Keine Typsicherheit!
```

‚úÖ Besser: Eigene Schnittstellen oder Typen definieren!

---

## üìù Zusammenfassung

| Schritt                | Vorgehen                                                  |
|------------------------|-----------------------------------------------------------|
| ‚úÖ Pr√ºfen auf `@types/` | `npm i -D @types/libname`                                |
| üî® Kein Typ vorhanden   | `declare module 'lib' {}` verwenden                      |
| ‚úçÔ∏è Eigenes Typing       | Besser als `any`, mehr Kontrolle                         |
| üîê Ziel                 | Typsicherheit und bessere Entwicklererfahrung            |

---

## üîó Quellen

- [TypeScript ‚Äì Declaration Files](https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html)  
- [DefinitelyTyped Repo](https://github.com/DefinitelyTyped/DefinitelyTyped)  
- [Using Non-TypeScript Libraries](https://www.typescriptlang.org/docs/handbook/modules.html#ambient-modules)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

171. ### <a name="171"></a> Was ist der Unterschied zwischen ESM und CommonJS?

# Was ist der Unterschied zwischen **ESM** und **CommonJS**?

**ESM (ECMAScript Modules)** und **CommonJS (CJS)** sind zwei unterschiedliche **Modulsysteme** in JavaScript.  
Sie definieren, **wie Code importiert und exportiert wird** ‚Äì besonders wichtig bei der Arbeit mit Node.js und modernen Frontend-Bundlern.

---

## ‚úÖ √úbersicht

| Merkmal              | ESM                                 | CommonJS                           |
|----------------------|--------------------------------------|-------------------------------------|
| Einf√ºhrung           | Offizieller JS-Standard (ES6)        | Node.js-spezifisch (√§lter)         |
| Syntax               | `import` / `export`                  | `require()` / `module.exports`     |
| Ausf√ºhrung           | statisch analysierbar                | dynamisch zur Laufzeit             |
| Dateiendung (Node.js)| `.mjs` oder `"type": "module"`       | `.cjs` oder keine spezielle Angabe |
| Tree Shaking         | ‚úÖ m√∂glich                           | ‚ùå nicht zuverl√§ssig                |
| Verwendung           | Frontend + modernes Node.js          | Klassisches Node.js                |

---

## üì¶ Beispiel: Import / Export

### ESM

```js
// math.js
export const add = (a, b) => a + b;

// index.js
import { add } from './math.js';
```

### CommonJS

```js
// math.js
exports.add = (a, b) => a + b;

// index.js
const { add } = require('./math');
```

---

## üîÅ Interoperabilit√§t (CJS ‚Üî ESM)

- In Node.js ist **Mischen m√∂glich**, aber **kompliziert**  
- `import` kann **keine CJS-Datei mit `default`** direkt lesen  
- Viele Tools (z.‚ÄØB. Webpack, Vite) unterst√ºtzen **beide Formate**

---

## üß† Wann was nutzen?

| Situation                         | Empfehlung        |
|-----------------------------------|-------------------|
| Neues Projekt mit Bundler         | **ESM**           |
| Legacy-Node.js ohne Transpiler    | **CommonJS**      |
| Bibliothek mit Tree Shaking       | **ESM bevorzugt** |

---

## üìù Zusammenfassung

| ESM                  | CommonJS              |
|----------------------|------------------------|
| `import/export`      | `require/module.exports` |
| Modern & standardisiert | Node.js-spezifisch (√§lter) |
| Tree Shaking m√∂glich | Kein Tree Shaking      |

---

## üîó Quellen

- [MDN ‚Äì Modules: ES6](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules)  
- [Node.js ‚Äì CommonJS vs ESM](https://nodejs.org/api/esm.html)  
- [ESM vs CJS ‚Äì Differences](https://blog.logrocket.com/esm-vs-commonjs-node-js/)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

172. ### <a name="172"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

173. ### <a name="173"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

174. ### <a name="174"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

175. ### <a name="175"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

176. ### <a name="176"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

177. ### <a name="177"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

178. ### <a name="178"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

179. ### <a name="179"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

180. ### <a name="180"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

181. ### <a name="181"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

182. ### <a name="182"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

183. ### <a name="183"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

184. ### <a name="184"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

185. ### <a name="185"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

186. ### <a name="186"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

187. ### <a name="187"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

188. ### <a name="188"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

189. ### <a name="189"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

190. ### <a name="190"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

191. ### <a name="191"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

192. ### <a name="192"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

193. ### <a name="193"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

194. ### <a name="194"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

195. ### <a name="195"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

196. ### <a name="196"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

197. ### <a name="197"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

198. ### <a name="198"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

199. ### <a name="199"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

200. ### <a name="200"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**      
