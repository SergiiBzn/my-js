<a name="top"></a>

[На главную](../../README.md)

[Перейти к вопросам](#questions)

| №. | Вопрос |
| --- | --------- |
|   | ReactJS Grundlagen |
|1 | [Was ist React und welche Probleme löst es?](#1) |
|2 | [Was ist JSX und warum wird es verwendet?](#2) |
|3 | [Was ist Virtual DOM und wie funktioniert es?](#3) |
|4 | [Was ist der Unterschied zwischen React und ReactDOM?](#4) |
|5 | [Warum importieren wir React, auch wenn es scheinbar nicht benutzt wird?](#5) |
|6 | [Was ist ein React Fragment und warum ist es nützlich?](#6) |
|7 | [Was ist der Unterschied zwischen einem Element, einer Komponente und einer Instanz?](#7) |
|8 | [Was ist das Fiber-Architekturmodell in React?](#8) |
|9 | [Was bedeutet „Batching“ in React?](#9) |
|10 | [Was ist die Rolle des key in React-Listen?](#10) |
|11 | [Wie funktioniert die Wiederverwendung von Komponenten?](#11) |
|12 | [](#12) |
|13 | [](#13) |
|14 | [](#14) |
|15 | [](#15) |
|16 | [](#16) |
|17 | [](#17) |
|18 | [](#18) |
|19 | [](#19) |
|20 | [](#20) |
|   | Komponenten, Props & State |
|21 | [Was sind Props und wozu werden sie verwendet?](#21) |
|22 | [Was ist der Unterschied zwischen Props und State?](#22) |
|23 | [Warum sind Props nur lesbar?](#23) |
|24 | [Wie funktioniert der unidirektionale Datenfluss in React?](#24) |
|25 | [Was ist State in Klassen- und Funktionskomponenten?](#25) |
|26 | [Wie funktioniert setState?](#26) |
|27 | [Was ist der Unterschied zwischen kontrollierten und unkontrollierten Komponenten?](#27) |
|28 | [Was sind Default Props und PropTypes?](#28) |
|29 | [Was ist React.memo und wofür wird es verwendet?](#29) |
|30 | [Was ist PureComponent und wie unterscheidet es sich von Component?](#30) |
|31 | [Wann sollte shouldComponentUpdate verwendet werden?](#31) |
|32 | [Was ist ein ref und wann wird er eingesetzt?](#32) |
|33 | [Was bedeutet „Lifting State Up“?](#33) |
|34 | [](#34) |
|35 | [](#35) |
|36 | [](#36) |
|37 | [](#37) |
|38 | [](#38) |
|39 | [](#39) |
|40 | [](#40) |
|   | Lebenszyklus von Komponenten |
|41 | [Was sind die Phasen des Komponentenlebenszyklus?](#41) |
|42 | [Welche Lifecycle-Methoden gibt es in Klassenkomponenten?](#42) |
|43 | [Welche Lifecycle-Methoden sind veraltet?](#43) |
|44 | [Wie kann man Lifecycle-Methoden mit Hooks ersetzen?](#44) |
|45 | [Was ist componentDidMount und was ist das Äquivalent mit Hooks?](#45) |
|46 | [](#46) |
|47 | [](#47) |
|48 | [](#48) |
|49 | [](#49) |
|50 | [](#50) |
|   | Hooks |
|51 | [Was sind Hooks in React?](#51) |
|52 | [Wie funktionieren useState und useEffect?](#52) |
|53 | [Was macht useContext?](#53) |
|54 | [Was ist useRef und wann wird es verwendet?](#54) |
|55 | [Was ist useCallback, useMemo, useReducer?](#55) |
|56 | [Wie schreibt man einen benutzerdefinierten Hook?](#56) |
|57 | [Wie verhindert man eine Endlosschleife in useEffect?](#57) |
|58 | [Wie implementiert man Timeout oder Interval mit Hooks?](#58) |
|59 | [](#59) |
|60 | [](#60) |
|   | React-Patterns und Konzepte |
|61 | [Was ist ein Higher-Order Component (HOC)?](#61) |
|62 | [Was ist das Render-Prop-Pattern?](#62) |
|63 | [Was ist die Context-API und wie funktioniert useContext?](#63) |
|64 | [Was sind Portale in React?](#64) |
|65 | [Was ist bedingtes Rendern (Conditional Rendering)?](#65) |
|66 | [Was ist ein Error Boundary?](#66) |
|67 | [Wie funktioniert Event-Handling in React?](#67) |
|68 | [Was ist ein synthetisches Ereignis (SyntheticEvent)?](#68) |
|69 | [Was ist props.children?](#69) |
|70 | [Was bedeutet „controlled component“ und „uncontrolled component“ bei Formularen?](#70) |
|71 | [](#71) |
|72 | [](#72) |
|73 | [](#73) |
|74 | [](#74) |
|75 | [](#75) |
|   | Daten & API |
|76 | [Wie führt man API-Aufrufe mit Fetch oder Axios durch?](#76) |
|77 | [Wie verwaltet man Lade-, Fehler- und Erfolgsstatus?](#77) |
|78 | [Wie funktioniert WebSocket mit React?](#78) |
|79 | [Wie kann man Daten zwischen Komponenten weitergeben?](#79) |
|80 | [Wie macht man einen Datenabruf nur beim ersten Rendern?](#80) |
|81 | [Was ist das Problem bei „stale closures“ mit Hooks?](#81) |
|82 | [Wie funktioniert die Fehlerbehandlung mit try/catch in React?](#82) |
|83 | [Wie kann man ein Mock-API oder Mock Server verwenden?](#83) |
|84 | [Wie funktioniert Suspense für Datenabfragen?](#84) |
|85 | [](#85) |
|86 | [](#86) |
|87 | [](#87) |
|88 | [](#88) |
|89 | [](#89) |
|90 | [](#90) |
|   | Testing |
|91 | [Was ist Unit-, Integration- und E2E-Testing?](#91) |
|92 | [Was ist Snapshot-Testing?](#92) |
|93 | [Welche Tools nutzt man für React-Tests (Jest, React Testing Library)?](#93) |
|94 | [Wie testet man Komponenten, Props und Events?](#94) |
|95 | [Wie testet man benutzerdefinierte Hooks?](#95) |
|96 | [](#96) |
|97 | [](#97) |
|98 | [](#98) |
|99 | [](#99) |
|100 | [](#100) |
|   | Routing mit React Router |
|101 | [Wie funktioniert Routing in React mit react-router-dom?](#101) |
|102 | [Was sind die Unterschiede zwischen react-router v5 und v6?](#102) |
|103 | [Was sind Route, Link, Navigate, Outlet?](#103) |
|104 | [Wie erstellt man Nested Routes?](#104) |
|105 | [Wie implementiert man Redirects?](#105) |
|106 | [Wie funktioniert programmgesteuerte Navigation (useNavigate)?](#106) |
|107 | [](#107) |
|108 | [](#108) |
|109 | [](#109) |
|110 | [](#110) |
|   | Redux & Redux Toolkit |
|111 | [Was ist Redux und wie funktioniert es?](#111) |
|112 | [Was sind Actions, Reducer und Store?](#112) |
|113 | [Wie funktioniert Redux Toolkit (createSlice, configureStore, createAsyncThunk)?](#113) |
|114 | [Was ist RTK Query?](#114) |
|115 | [Was ist der Unterschied zwischen Redux und der Context-API?](#115) |
|116 | [Was ist connect() in Redux?](#116) |
|117 | [Was sind Middleware in Redux (z. B. redux-thunk, redux-logger)?](#117) |
|118 | [Was ist createSelector und wie funktioniert Reselect?](#118) |
|119 | [Wie verbindet man Redux mit React über Hooks (useSelector, useDispatch)?](#119) |
|120 | [](#120) |
|121 | [](#121) |
|122 | [](#122) |
|123 | [](#123) |
|124 | [](#124) |
|125 | [](#125) |
|126 | [](#126) |
|127 | [](#127) |
|128 | [](#128) |
|129 | [](#129) |
|130 | [](#130) |
|   | Optimierung & Performance |
|131 | [Was ist Code-Splitting?](#131) |
|132 | [Wie funktionieren React.lazy und Suspense?](#132) |
|133 | [Was ist Tree Shaking?](#133) |
|134 | [Was ist Server-Side Rendering (SSR) und Hydration?](#134) |
|135 | [Wie geht man mit Hydration-Fehlern bei SSR um?](#135) |
|136 | [Was bedeutet Virtualisierung (z. B. mit react-window)?](#136) |
|137 | [Wie verhindert man unnötige Re-Renders?](#137) |
|138 | [Was ist React Transition Group?](#138) |
|139 | [Was ist React Strict Mode und welche Vorteile bietet er?](#139) |
|140 | [Was ist Concurrent Mode und welche Probleme löst er?](#140) |
|141 | [](#141) |
|142 | [](#142) |
|143 | [](#143) |
|144 | [](#144) |
|145 | [](#145) |
|   | Sonstiges |
|146 | [Was ist ein Service Worker?](#146) |
|147 | [Was ist react-helmet und wie hilft es beim SEO?](#147) |
|148 | [Wie funktioniert Lazy Loading mit dynamic import()?](#148) |
|149 | [Was ist ein Finite-State Machine (FSM), z. B. mit XState?](#149) |
|150 | [Wie kann man ein Formular mit Formik und Yup erstellen und validieren?](#150) |
|151 | [Wie konfiguriert man ESLint und Prettier in einem React-Projekt?](#151) |
|152 | [Wie funktioniert dynamic import() in React (Syntax, Anwendungsfälle)?](#152) |
|153 | [](#153) |
|154 | [](#154) |
|155 | [](#155) |
|156 | [](#156) |
|157 | [](#157) |
|158 | [](#158) |
|159 | [](#159) |
|160 | [](#160) |
|   | React + TypeScript |
|161 | [Was ist der Unterschied zwischen interface und type in TypeScript?](#161) |
|162 | [Wie typisiert man Props und State in einer funktionalen Komponente?](#162) |
|163 | [Wie nutzt man Generics in React mit TypeScript (z. B. für Listen)?](#163) |
|164 | [Wie typisiert man Events in React mit TypeScript (onChange, onClick, FormEvent, MouseEvent)?](#164) |
|165 | [Wie erstellt man einen benutzerdefinierten Hook mit TypeScript?](#165) |
|166 | [Wie typisiert man useReducer mit TypeScript?](#166) |
|167 | [Wie typisiert man children korrekt in React-Komponenten?](#167) |
|168 | [Was ist React.FC und welche Vor- und Nachteile hat es?](#168) |
|169 | [Wie typisiert man eine Komponente mit optionalen Props?](#169) |
|170 | [Wie arbeitet man mit Drittanbieter-Bibliotheken, die keine Typen enthalten?](#170) |
|171 | [Was ist der Unterschied zwischen ESM und CommonJS?](#171) |
|172 | [](#172) |
|173 | [](#173) |
|174 | [](#174) |
|175 | [](#175) |
|176 | [](#176) |
|177 | [](#177) |
|178 | [](#178) |
|179 | [](#179) |
|180 | [](#180) |
|181 | [](#181) |
|182 | [](#182) |
|183 | [](#183) |
|184 | [](#184) |
|185 | [](#185) |
|186 | [](#186) |
|187 | [](#187) |
|188 | [](#188) |
|189 | [](#189) |
|190 | [](#190) |
|191 | [](#191) |
|192 | [](#192) |
|193 | [](#193) |
|194 | [](#194) |
|195 | [](#195) |
|196 | [](#196) |
|197 | [](#197) |
|198 | [](#198) |
|199 | [](#199) |
|200 | [](#200) |



<a name="questions"></a>

## ReactJS 

  **[⬆ Наверх](#top)**
  
1. ### <a name="1"></a> Was ist React und welche Probleme löst es?

**React** ist eine **JavaScript-Bibliothek** für den Aufbau von **User Interfaces** (UI), entwickelt von Facebook (heute Meta). Sie konzentriert sich auf die **View-Schicht** (im MVC-Pattern) und löst typische Probleme moderner Frontend-Entwicklung:

### Probleme, die React löst

1. **Komplexität bei dynamischen UIs**

   * Klassisches DOM-Manipulieren mit `document.querySelector` oder `innerHTML` ist fehleranfällig und schwer zu warten.
   * React nutzt das **Virtual DOM**, um Änderungen effizient zu berechnen und nur die nötigen Teile des echten DOM zu aktualisieren.

2. **Wiederverwendbarkeit von UI-Logik**

   * In Vanilla JS oder jQuery ist es schwierig, UI-Elemente als eigenständige, wiederverwendbare Bausteine zu organisieren.
   * React bietet **Komponenten** (Functions oder Classes), die UI + Logik kapseln.

3. **State-Management**

   * Ohne Framework muss man Zustände (z. B. Eingaben, UI-Änderungen) manuell im DOM nachverfolgen.
   * React bietet ein klares **State- und Props-Konzept**: Datenfluss von oben nach unten (Top-down Data Flow) und kontrollierte Zustandsverwaltung.

4. **Lesbarkeit & Wartbarkeit**

   * Mit **JSX** verbindet React deklarative Syntax mit JavaScript, wodurch UI-Struktur dem HTML ähnelt, aber direkt in JS geschrieben wird.
   * Dadurch wird Code strukturierter, testbarer und besser wartbar.

---

### Beispiel

```jsx
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Aktueller Wert: {count}</p>
      <button onClick={() => setCount(count + 1)}>
        Erhöhen
      </button>
    </div>
  );
}

export default Counter;
```

* `useState` verwaltet den Zustand.
* Bei jedem Klick wird nur der relevante Teil des DOM aktualisiert.

---

### Zusammenfassung

* **React** = Bibliothek für deklarative UI-Entwicklung.
* Löst Probleme: ineffiziente DOM-Manipulation, fehlende Wiederverwendbarkeit, unübersichtliches State-Handling.
* Schlüsselkonzepte: **Virtual DOM, Komponenten, State, Props, JSX**.

📖 Weiterführend:

* [React Offizielle Dokumentation – Grundlagen](https://react.dev/learn)
* [MDN – Einführung in das DOM](https://developer.mozilla.org/ru/docs/Web/API/Document_Object_Model/Introduction)

---

  **[⬆ Наверх](#top)**

2. ### <a name="2"></a> Was ist JSX und warum wird es verwendet?

**JSX (JavaScript XML)** ist eine **erweiterte Syntax für JavaScript**, die es erlaubt, UI-Strukturen in einer HTML-ähnlichen Schreibweise direkt im JavaScript-Code zu definieren. JSX wird von **Babel** oder anderen Transpilern in reines JavaScript (meist `React.createElement`) übersetzt.

---

### Warum wird JSX verwendet?

1. **Deklarative UI-Beschreibung**

   * UI-Struktur sieht aus wie HTML, ist aber vollständig in JavaScript eingebettet.
   * Entwicklern fällt es leichter, die Logik und das UI zusammen zu lesen und zu verstehen.

2. **Verknüpfung von Logik und Darstellung**

   * Man kann JavaScript-Ausdrücke direkt in JSX einbetten: `{...}`.
   * Bedingte Renderings oder Schleifen lassen sich elegant integrieren.

3. **Bessere Lesbarkeit & Wartbarkeit**

   * Statt verschachtelter `React.createElement`-Aufrufe ist JSX kürzer, klarer und näher an HTML.

---

### Beispiel

```jsx
import { useState } from "react";

function Greeting() {
  const [name, setName] = useState("Sergii");

  return (
    <div>
      <h1>Hallo, {name}!</h1> {/* JS-Ausdruck in geschweiften Klammern */}
      <button onClick={() => setName("Frontend-Dev")}>
        Ändern
      </button>
    </div>
  );
}

export default Greeting;
```

Ohne JSX würde derselbe Code so aussehen:

```js
import { createElement, useState } from "react";

function Greeting() {
  const [name, setName] = useState("Sergii");

  return createElement(
    "div",
    null,
    createElement("h1", null, `Hallo, ${name}!`),
    createElement(
      "button",
      { onClick: () => setName("Frontend-Dev") },
      "Ändern"
    )
  );
}
```

---

### Zusammenfassung

* **JSX** = Syntax-Erweiterung für JavaScript, die UI-Strukturen wie HTML aussehen lässt.
* Vorteile: bessere Lesbarkeit, Integration von Logik + UI, effizienteres Arbeiten mit React.
* JSX wird in reines JavaScript transpiliert.

📖 Weiterführend:

* [React Offizielle Dokumentation – JSX](https://react.dev/learn/writing-markup-with-jsx)
* [MDN – JSX (Einführung)](https://developer.mozilla.org/ru/docs/Glossary/JSX)

---

  **[⬆ Наверх](#top)**

3. ### <a name="3"></a> Was ist Virtual DOM und wie funktioniert es?

**Virtual DOM (VDOM)** ist eine **leichte, virtuelle Repräsentation** des echten DOM im Speicher. Es dient als Zwischenschicht, um Änderungen effizient zu berechnen, bevor sie im **realen DOM** angewendet werden.

---

### Funktionsweise

1. **Rendern in den Virtual DOM**

   * Wenn sich State oder Props ändern, erzeugt React ein **neues Virtual DOM**-Baumobjekt.

2. **Diffing-Algorithmus**

   * React vergleicht den neuen VDOM mit der vorherigen Version (Reconciliation).
   * Nur die Unterschiede („diff“) werden ermittelt.

3. **Minimaler Update im echten DOM**

   * React aktualisiert nur die tatsächlich veränderten Teile im **realen DOM**.
   * Dadurch sind Updates wesentlich effizienter, da direkte DOM-Manipulationen sehr teuer sind.

---

### Beispiel

```jsx
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Zähler: {count}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
    </div>
  );
}

export default Counter;
```

* Bei `setCount` erstellt React ein neues Virtual DOM.
* React erkennt, dass nur `<p>` sich geändert hat.
* Nur dieser Knoten im echten DOM wird neu gerendert, **nicht die gesamte Seite**.

---

### Zusammenfassung

* **Virtual DOM** = virtuelles Abbild des echten DOM.
* Ablauf: **neuer VDOM → Diffing → minimaler DOM-Update**.
* Vorteil: Performance, klare Trennung von Logik und DOM-Manipulation.

📖 Weiterführend:

* [React Offizielle Dokumentation – Reconciliation](https://react.dev/learn/render-and-commit#step-2-react-renders-your-components)
* [MDN – DOM Einführung](https://developer.mozilla.org/ru/docs/Web/API/Document_Object_Model/Introduction)

---

  **[⬆ Наверх](#top)**

4. ### <a name="4"></a> Was ist der Unterschied zwischen React und ReactDOM?

**React** ist die **Kernbibliothek**, die Werkzeuge für das **Erstellen von Komponenten, State-Management, Hooks und JSX-Verarbeitung** bereitstellt.
**ReactDOM** ist das **Rendering-Paket**, das React-Komponenten mit dem **echten DOM im Browser** verbindet.

---

### Details

1. **React**

   * Definiert, **wie** UI-Komponenten aussehen und funktionieren.
   * Enthält Hooks wie `useState`, `useEffect`.
   * Ist plattformunabhängig (kann auch mit React Native, ReactDOM, ReactVR genutzt werden).

2. **ReactDOM**

   * Speziell für **Web-Umgebungen** gedacht.
   * Stellt Funktionen wie `createRoot` oder `render` bereit, um React-Komponenten in den Browser zu mounten.
   * Trennt die Logik von der konkreten Rendering-Umgebung (Browser-DOM).

---

### Beispiel

```jsx
// index.jsx
import React from "react";
import { createRoot } from "react-dom/client";
import App from "./App.jsx";

const root = createRoot(document.getElementById("root"));
root.render(<App />);
```

* `React` stellt die Komponente `App` bereit.
* `ReactDOM` sorgt dafür, dass diese Komponente im `<div id="root">` im Browser angezeigt wird.

---

### Zusammenfassung

* **React** = Kernbibliothek (Komponenten, State, Hooks).
* **ReactDOM** = Bindeglied zum echten Browser-DOM (Mounting, Rendering).
* Trennung ermöglicht, React auch außerhalb des Browsers (z. B. mit React Native) zu verwenden.

📖 Weiterführend:

* [React Offizielle Dokumentation – Einstieg](https://react.dev/learn)
* [ReactDOM API – Offizielle Docs](https://react.dev/reference/react-dom)

---

  **[⬆ Наверх](#top)**

5. ### <a name="5"></a> Warum importieren wir React, auch wenn es scheinbar nicht benutzt wird?

Früher musste man in jeder Datei mit JSX immer **`import React from "react";`** schreiben, auch wenn React im Code nicht direkt benutzt wurde.
Grund: **JSX wird von Babel in `React.createElement`-Aufrufe umgewandelt**, daher war `React` im Scope notwendig.

Seit **React 17 (2020)** wurde das durch die **neue JSX-Transform** geändert:

* Der Compiler fügt die nötigen Funktionen automatisch hinzu.
* Deshalb muss man `import React` nicht mehr explizit einfügen, wenn man nur JSX nutzt.
* In älteren Projekten oder Setups ohne neue Transform ist der Import weiterhin Pflicht.

---

### Beispiel – Babel-Umwandlung

**JSX-Eingabe:**

```jsx
const element = <h1>Hallo Welt</h1>;
```

**Transpilierte Ausgabe (vor React 17):**

```js
import React from "react";

const element = React.createElement("h1", null, "Hallo Welt");
```

**Transpilierte Ausgabe (ab React 17 mit neuer JSX-Transform):**

```js
import { jsx as _jsx } from "react/jsx-runtime";

const element = _jsx("h1", { children: "Hallo Welt" });
```

---

### Zusammenfassung

* Früher: `import React` war nötig, weil JSX → `React.createElement` kompiliert wurde.
* Heute (React 17+): Dank neuer JSX-Transform meist **nicht mehr notwendig**.
* Import wird nur gebraucht, wenn man `React` direkt nutzt (z. B. `React.Children`, `React.cloneElement`).

📖 Weiterführend:

* [React Offizielle Dokumentation – Neue JSX-Transform](https://react.dev/blog/2020/09/22/introducing-the-new-jsx-transform)
* [MDN – JSX](https://developer.mozilla.org/ru/docs/Glossary/JSX)

---

  **[⬆ Наверх](#top)**

6. ### <a name="6"></a> Was ist ein React Fragment und warum ist es nützlich?

**React Fragment** ist ein spezieller Wrapper (`<React.Fragment>` oder Kurzschreibweise `<>...</>`), mit dem man **mehrere Elemente gruppieren** kann, **ohne zusätzliches DOM-Element** (wie `<div>`) zu erzeugen.

---

### Warum nützlich?

1. **Kein unnötiges DOM-Markup**

   * `<div>`-Wrapper erzeugen oft „div soup“ und machen das DOM unübersichtlich.
   * Fragmente fügen nichts ins echte DOM ein.

2. **Mehrere Elemente zurückgeben**

   * Eine React-Komponente darf nur **ein einziges Root-Element** zurückgeben.
   * Mit Fragmenten kann man mehrere Geschwister-Elemente zurückgeben.

3. **Performance & Semantik**

   * Weniger DOM-Knoten → bessere Performance.
   * Bessere Semantik, da unnötige Container-Elemente vermieden werden.

---

### Beispiel

```jsx
import React from "react";

function UserInfo() {
  return (
    <>
      <h2>Benutzername: Sergii</h2>
      <p>Rolle: Frontend-Entwickler</p>
    </>
  );
}

export default UserInfo;
```

Ohne Fragment müsste man alles in ein `<div>` packen:

```jsx
function UserInfo() {
  return (
    <div>
      <h2>Benutzername: Sergii</h2>
      <p>Rolle: Frontend-Entwickler</p>
    </div>
  );
}
```

Ergebnis im DOM:

* Mit Fragment → nur `<h2>` und `<p>`.
* Mit `<div>` → unnötiger zusätzlicher Container.

---

### Zusammenfassung

* **React Fragment** gruppiert mehrere Elemente ohne zusätzliches DOM-Tag.
* Vorteile: sauberes DOM, bessere Semantik, kein „div soup“.
* Schreibweisen: `<React.Fragment>...</React.Fragment>` oder `<>...</>`.

📖 Weiterführend:

* [React Offizielle Dokumentation – Fragments](https://react.dev/reference/react/Fragment)

---

  **[⬆ Наверх](#top)**

7. ### <a name="7"></a> Was ist der Unterschied zwischen einem Element, einer Komponente und einer Instanz?

### Unterschied: Element, Komponente, Instanz

1. **React Element**

   * Ein **leichtes, unveränderliches Objekt**, das beschreibt, **was im UI gerendert werden soll**.
   * Wird von JSX erzeugt und dient React als Bauplan.
   * Beispiel:

   ```jsx
   const element = <h1>Hallo</h1>; // React Element
   ```

2. **React Komponente**

   * Eine **Funktion oder Klasse**, die React Elements zurückgibt.
   * Definiert **wie UI-Elemente aufgebaut sind** (Logik + Struktur).
   * Beispiel:

   ```jsx
   function Greeting() {
     return <h1>Hallo Sergii</h1>;
   }
   ```

3. **Instanz einer Komponente**

   * Entsteht, wenn React eine Komponente **rendert** und im UI einsetzt.
   * Jede Verwendung von `<Greeting />` erzeugt eine neue Instanz dieser Komponente.
   * Beispiel:

   ```jsx
   function App() {
     return (
       <>
         <Greeting />   {/* Instanz 1 */}
         <Greeting />   {/* Instanz 2 */}
       </>
     );
   }
   ```

---

### Bildhafte Erklärung

* **Element** = Bauplan/Zwischenschicht (JSX-Output).
* **Komponente** = Definition (Funktion/Klasse).
* **Instanz** = konkrete Ausprägung der Komponente im DOM.

---

### Zusammenfassung

* **Element**: unveränderliches Objekt, beschreibt UI.
* **Komponente**: Funktion/Klasse, die Elemente zurückgibt.
* **Instanz**: konkrete gerenderte Erscheinung einer Komponente.

📖 Weiterführend:

* [React Offizielle Dokumentation – Rendering Elements](https://react.dev/learn/render-and-commit)
* [MDN – Komponenten-Definition](https://developer.mozilla.org/ru/docs/Glossary/Component)

---

  **[⬆ Наверх](#top)**

8. ### <a name="8"></a> Was ist das Fiber-Architekturmodell in React?

### Fiber-Architekturmodell in React

**React Fiber** ist die **neue Rendering-Engine** von React (seit v16), die das alte „Stack Reconciler“-Modell ersetzt. Ziel: **flexible, unterbrechbare Updates** im UI.

---

### Hauptideen

1. **Unterbrechbare Renderings**

   * Große UI-Updates können in **kleine Arbeitseinheiten** zerlegt werden.
   * React kann Rendering pausieren, priorisieren oder abbrechen, wenn wichtigere Aufgaben (z. B. User-Input) eintreffen.

2. **Priorisierung von Updates**

   * Updates erhalten eine **Priorität** (z. B. Animation > Datenladen).
   * Dadurch bleibt die UI reaktionsschnell.

3. **Inkremetelles Rendern**

   * Statt den ganzen Baum auf einmal zu rendern, wird er Stück für Stück (fiberweise) bearbeitet.

---

### Aufbau

* **Fiber Node**: interner Datenknoten, der eine **Einheit der Arbeit** repräsentiert (z. B. eine Komponente oder ein DOM-Element).
* Jeder Fiber enthält Infos wie: Typ der Komponente, Props, State, Nebenwirkungen.

---

### Beispiel (vereinfacht gedacht)

```jsx
function App() {
  return (
    <>
      <Header />
      <Content />
      <Footer />
    </>
  );
}
```

* Für `Header`, `Content`, `Footer` erstellt React einzelne **Fiber-Nodes**.
* React arbeitet diese nacheinander ab, kann aber z. B. `Footer` später fertigstellen, wenn ein **User-Klick** sofort verarbeitet werden muss.

---

### Zusammenfassung

* **Fiber** = Reacts Rendering-Engine ab v16.
* Vorteile: unterbrechbare, priorisierte und inkrementelle Renderings.
* Kernziel: **bessere Performance & User Experience** bei komplexen UIs.

📖 Weiterführend:

* [React Offizielle Dokumentation – Render and Commit](https://react.dev/learn/render-and-commit)
* [React Blog – Fiber Architecture](https://reactjs.org/docs/faq-internals.html#what-is-react-fiber)

---

  **[⬆ Наверх](#top)**

9. ### <a name="9"></a> Was bedeutet „Batching“ in React?

### Batching in React

**Batching** bedeutet, dass React mehrere **State-Updates** zusammenfasst und in **einem einzigen Re-Render** ausführt, anstatt nach jedem Update sofort zu rendern. Das reduziert unnötige DOM-Updates und verbessert die Performance.

---

### Details

* Standardmäßig werden in **Event-Handlern** (z. B. `onClick`) mehrere `setState`-Aufrufe gebündelt.
* Seit **React 18** gilt „Automatic Batching“ auch für **Promises, setTimeout, native Events** usw.
* Ohne Batching würde jede State-Änderung einzeln ein Re-Render auslösen.

---

### Beispiel

```jsx
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);
  const [text, setText] = useState("");

  function handleClick() {
    setCount(c => c + 1);
    setText("Aktualisiert");
    // Beide Updates werden in EINEM Re-Render gebündelt (Batching)
  }

  return (
    <>
      <p>{count} - {text}</p>
      <button onClick={handleClick}>Update</button>
    </>
  );
}

export default Counter;
```

---

### Zusammenfassung

* **Batching** = mehrere State-Updates → ein Re-Render.
* Vorteil: weniger DOM-Updates, bessere Performance.
* Seit React 18: **automatisches Batching überall**, nicht nur in Event-Handlern.

📖 Weiterführend:

* [React Offizielle Dokumentation – State Updates Batching](https://react.dev/learn/queueing-a-series-of-state-updates#batching-of-state-updates)

---

  **[⬆ Наверх](#top)**

10. ### <a name="10"></a> Was ist die Rolle des key in React-Listen?

### Rolle des `key` in React-Listen

**`key`** ist ein spezielles Attribut in React, das jeder Listenkomponente zugewiesen wird, um sie **eindeutig zu identifizieren**. Es hilft React beim **Diffing-Prozess** (Vergleich von altem und neuem Virtual DOM), effizient zu erkennen, welche Elemente geändert, hinzugefügt oder entfernt wurden.

---

### Warum wichtig?

1. **Performance**: React muss nicht die ganze Liste neu rendern, sondern nur die betroffenen Elemente.
2. **Stabilität**: `key` sorgt dafür, dass Komponenteninstanzen korrekt erhalten bleiben (z. B. State in Formularfeldern).
3. **Vorhersehbarkeit**: Ohne eindeutigen Key kann es zu unerwarteten UI-Effekten kommen.

---

### Beispiel

```jsx
const users = ["Anna", "Max", "Sergii"];

function UserList() {
  return (
    <ul>
      {users.map(user => (
        <li key={user}>{user}</li> // key = eindeutiger Identifier
      ))}
    </ul>
  );
}

export default UserList;
```

**Falsch (z. B. Index als Key, nur wenn Daten wirklich stabil sind):**

```jsx
<li key={index}>{user}</li>
```

→ Problematisch, wenn Elemente umsortiert oder gelöscht werden.

---

### Zusammenfassung

* **`key`** identifiziert Listenelemente eindeutig.
* Hilft React beim effizienten Re-Rendern und verhindert UI-Fehler.
* Best Practice: stabile, eindeutige IDs nutzen, **nicht** Array-Index.

📖 Weiterführend:

* [React Offizielle Dokumentation – Schlüssel (Keys)](https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key)

---

  **[⬆ Наверх](#top)**

11. ### <a name="11"></a> Wie funktioniert die Wiederverwendung von Komponenten?

### Wiederverwendung von Komponenten in React

**Wiederverwendbarkeit** bedeutet, dass eine Komponente mehrfach in unterschiedlichen Kontexten eingesetzt werden kann, ohne ihren Code zu duplizieren. React erreicht dies durch **Props, Komposition und Children**.

---

### Hauptmechanismen

1. **Props**

   * Komponenten können konfigurierbar gemacht werden, indem man ihnen Daten übergibt.

   ```jsx
   function Button({ label, color }) {
     return <button style={{ background: color }}>{label}</button>;
   }

   export default function App() {
     return (
       <>
         <Button label="Speichern" color="green" />
         <Button label="Löschen" color="red" />
       </>
     );
   }
   ```

   → Gleiche Komponente, unterschiedliche Darstellung durch Props.

2. **Komposition**

   * Komponenten können andere Komponenten enthalten oder kombinieren.

   ```jsx
   function Card({ children }) {
     return <div className="card">{children}</div>;
   }

   function App() {
     return (
       <Card>
         <h2>Titel</h2>
         <p>Inhalt</p>
       </Card>
     );
   }
   ```

   → Card ist wiederverwendbar als Container für beliebigen Inhalt.

3. **Children & Higher-Order-Komponenten / Render Props**

   * Muster, um Verhalten und Layout flexibel wiederzuverwenden.

---

### Zusammenfassung

* Wiederverwendbarkeit in React basiert auf **Props, Komposition und Children**.
* Eine Komponente kann mehrfach in verschiedenen Kontexten mit unterschiedlicher Konfiguration genutzt werden.
* Ziel: **DRY-Prinzip** (Don’t Repeat Yourself) und saubere Architektur.

📖 Weiterführend:

* [React Offizielle Dokumentation – Komposition vs. Vererbung](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children)

---

  **[⬆ Наверх](#top)**

12. ### <a name="12"></a> 



  **[⬆ Наверх](#top)**

13. ### <a name="13"></a> 



  **[⬆ Наверх](#top)**

14. ### <a name="14"></a> 



  **[⬆ Наверх](#top)**

15. ### <a name="15"></a> 



  **[⬆ Наверх](#top)**

16. ### <a name="16"></a> 



  **[⬆ Наверх](#top)**

17. ### <a name="17"></a> 



  **[⬆ Наверх](#top)**

18. ### <a name="18"></a> 



  **[⬆ Наверх](#top)**

19. ### <a name="19"></a> 



  **[⬆ Наверх](#top)**

20. ### <a name="20"></a> 



  **[⬆ Наверх](#top)**

21. ### <a name="21"></a> Was sind Props und wozu werden sie verwendet?

### Props in React

**Props (Properties)** sind **Eingabeparameter**, die von einer Elternkomponente an eine Kindkomponente übergeben werden. Sie machen Komponenten **dynamisch, wiederverwendbar und konfigurierbar**.

---

### Eigenschaften von Props

1. **Read-only** – Props können innerhalb der Kindkomponente **nicht verändert** werden.
2. **Datenfluss** – Props folgen dem **Top-down Data Flow** (von Eltern zu Kindern).
3. **Flexibilität** – erlauben es, dasselbe UI-Element mit unterschiedlichen Werten zu nutzen.

---

### Beispiel

```jsx
function Greeting({ name }) {
  return <h1>Hallo, {name}!</h1>;
}

function App() {
  return (
    <>
      <Greeting name="Sergii" />
      <Greeting name="Anna" />
    </>
  );
}

export default App;
```

* `Greeting` ist wiederverwendbar.
* `name` wird als Prop übergeben und individuell gerendert.

---

### Zusammenfassung

* **Props** = unveränderliche Eingabeparameter für Komponenten.
* Nutzen: Datenweitergabe, Wiederverwendbarkeit, dynamisches Rendering.
* Props sind **nur lesbar** und werden von Eltern an Kinder übergeben.

📖 Weiterführend:

* [React Offizielle Dokumentation – Props](https://react.dev/learn/passing-props-to-a-component)

---

  **[⬆ Наверх](#top)**

22. ### <a name="22"></a> Was ist der Unterschied zwischen Props und State?

### Unterschied zwischen **Props** und **State**

1. **Props**

   * Eingabeparameter, die eine Komponente von außen (Elternkomponente) erhält.
   * **Unveränderlich** innerhalb der Kindkomponente (read-only).
   * Dienen zur **Datenweitergabe** und **Konfiguration**.

2. **State**

   * Interner Zustand einer Komponente, der sich über die Zeit ändern kann.
   * Wird mit Hooks wie `useState` verwaltet.
   * Änderungen am State lösen ein **Re-Render** der Komponente aus.

---

### Beispiel

```jsx
import { useState } from "react";

function Counter({ initial }) {   // Prop
  const [count, setCount] = useState(initial); // State

  return (
    <>
      <p>Zähler: {count}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
    </>
  );
}

export default function App() {
  return <Counter initial={5} />; // Übergabe per Prop
}
```

* `initial` = **Prop**, von außen übergeben, nicht veränderbar.
* `count` = **State**, gehört zur Komponente selbst und wird durch User-Interaktion verändert.

---

### Zusammenfassung

* **Props**: von außen, unveränderlich, konfigurieren Komponenten.
* **State**: intern, veränderlich, speichert dynamische Daten.
* Zusammenspiel: Props geben Startwerte, State steuert dynamisches Verhalten.

📖 Weiterführend:

* [React Offizielle Dokumentation – Props vs State](https://react.dev/learn/state-a-components-memory)

---

  **[⬆ Наверх](#top)**

23. ### <a name="23"></a> Warum sind Props nur lesbar?

### Warum Props nur lesbar sind

1. **Eindirektionaler Datenfluss (Top-down Data Flow)**

   * React erzwingt, dass Daten **nur von Eltern zu Kindern** fließen.
   * Dadurch bleibt der Datenfluss vorhersehbar und leicht nachvollziehbar.

2. **Unveränderlichkeit**

   * Props sind **read-only**, weil sie von außen (Elternkomponente) kontrolliert werden.
   * Würden Kinder Props verändern, könnte es zu **Inkonsistenzen und schwer nachvollziehbaren Fehlern** kommen.

3. **Wartbarkeit & Debugging**

   * Wenn nur die Eltern Daten ändern dürfen, ist klar definiert, **wo Daten herkommen** und **wer sie verändert**.
   * Das erhöht die Stabilität großer Anwendungen.

---

### Beispiel

```jsx
function Greeting({ name }) {
  // name = Prop, nicht veränderbar
  return <h1>Hallo, {name}</h1>;
}

function App() {
  return <Greeting name="Sergii" />;
}
```

* `Greeting` darf `name` **nicht überschreiben**.
* Änderungen am Wert müssen in der Elternkomponente erfolgen.

---

### Zusammenfassung

* **Props sind nur lesbar**, weil React einen klaren, eindirektionalen Datenfluss erzwingt.
* Eltern kontrollieren die Daten, Kinder konsumieren sie.
* Ergebnis: **Vorhersehbarkeit, Stabilität und einfacheres Debugging**.

📖 Weiterführend:

* [React Offizielle Dokumentation – Props](https://react.dev/learn/passing-props-to-a-component)

---

  **[⬆ Наверх](#top)**

24. ### <a name="24"></a> Wie funktioniert der unidirektionale Datenfluss in React?

### Unidirektionaler Datenfluss in React

React folgt strikt dem Prinzip des **Top-down Data Flow**:

* **Elternkomponenten** geben Daten über **Props** an ihre **Kindkomponenten** weiter.
* Daten fließen **nur in eine Richtung** (von oben nach unten).
* Kindkomponenten können Daten nicht direkt zurückgeben, sondern nur über **Callbacks/Events** Änderungen an die Eltern melden.

---

### Beispiel

```jsx
import { useState } from "react";

function Child({ value, onChange }) {
  return (
    <>
      <p>Aktueller Wert: {value}</p>
      <button onClick={() => onChange(value + 1)}>+1</button>
    </>
  );
}

function Parent() {
  const [count, setCount] = useState(0);

  return <Child value={count} onChange={setCount} />;
}

export default Parent;
```

* `Parent` besitzt den **State**.
* `Child` erhält `value` und `onChange` als **Props**.
* Änderungen fließen **über ein Callback** zurück zur Elternkomponente.

---

### Vorteile

1. **Vorhersehbarkeit**: Es ist klar, wo Daten liegen und wie sie sich ändern.
2. **Wartbarkeit**: Einfacher zu debuggen, da Daten nur an einer Stelle gepflegt werden.
3. **Stabilität**: Keine unkontrollierten Seiteneffekte durch bidirektionalen Fluss.

---

### Zusammenfassung

* **Unidirektionaler Datenfluss** = Daten von Eltern → Kinder (via Props).
* Kinder melden Änderungen durch **Events/Callbacks** zurück.
* Ergebnis: **klare Struktur, bessere Wartbarkeit, weniger Fehler**.

📖 Weiterführend:

* [React Offizielle Dokumentation – Datenfluss](https://react.dev/learn/passing-props-to-a-component#how-props-flow-through-components)

---

  **[⬆ Наверх](#top)**

25. ### <a name="25"></a> Was ist State in Klassen- und Funktionskomponenten?

### State in React

1. **State in Klassenkomponenten**

   * Wird in einer Klasse als Objekt definiert.
   * Zugriff über `this.state`, Änderungen mit `this.setState()`.

   ```jsx
   import React, { Component } from "react";

   class Counter extends Component {
     constructor(props) {
       super(props);
       this.state = { count: 0 }; // State-Objekt
     }

     render() {
       return (
         <>
           <p>Zähler: {this.state.count}</p>
           <button onClick={() => this.setState({ count: this.state.count + 1 })}>
             +1
           </button>
         </>
       );
     }
   }

   export default Counter;
   ```

   * `this.setState()` führt **asynchrone Updates** aus und triggert ein Re-Render.

---

2. **State in Funktionskomponenten**

   * Ab React 16.8 mit **Hooks** möglich (`useState`).
   * State ist kein Objekt mehr, sondern ein beliebiger Wert (Primitive oder Objekt).

   ```jsx
   import { useState } from "react";

   function Counter() {
     const [count, setCount] = useState(0); // State-Hook

     return (
       <>
         <p>Zähler: {count}</p>
         <button onClick={() => setCount(count + 1)}>+1</button>
       </>
     );
   }

   export default Counter;
   ```

   * `useState` gibt ein Array `[state, updater]` zurück.
   * Updates sind deklarativ und lösen ein Re-Render aus.

---

### Vergleich

| Klassenkomponente              | Funktionskomponente       |
| ------------------------------ | ------------------------- |
| `this.state = { ... }`         | `const [value, setValue]` |
| Änderung mit `this.setState()` | Änderung mit Setter       |
| OOP-Stil                       | Funktional, Hooks         |

---

### Zusammenfassung

* **State = interner Speicher** einer Komponente, der sich über die Zeit ändern kann.
* In **Klassen**: Objekt mit `this.state` + Updates via `setState()`.
* In **Funktionen**: `useState`-Hook mit Wert + Setter.
* Änderungen triggern ein **Re-Render** der Komponente.

📖 Weiterführend:

* [React Offizielle Dokumentation – State und Lifecycle](https://react.dev/learn/state-a-components-memory)

---

  **[⬆ Наверх](#top)**

26. ### <a name="26"></a> Wie funktioniert setState?

### Funktionsweise von `setState` in React

1. **In Klassenkomponenten**

   * `setState()` ist die Methode zum Aktualisieren des internen **State-Objekts**.
   * Updates sind **asynchron** und werden oft zusammengefasst (**Batching**).
   * `setState` kann ein **Objekt** oder eine **Funktion** akzeptieren.

   ```jsx
   this.setState({ count: this.state.count + 1 }); // Objektform
   this.setState(prev => ({ count: prev.count + 1 })); // Funktionsform (empfohlen)
   ```

2. **In Funktionskomponenten** (`useState`)

   * `setState` ist der **Updater**, den React vom Hook zurückgibt.
   * Überschreibt den alten Wert durch einen neuen.
   * Akzeptiert direkt einen Wert oder eine Funktion basierend auf dem vorherigen Wert.

   ```jsx
   const [count, setCount] = useState(0);

   setCount(count + 1);          // Wert
   setCount(prev => prev + 1);   // Funktionsform (empfohlen bei Abhängigkeit vom alten Wert)
   ```

---

### Wichtige Eigenschaften

* **Asynchron**: Mehrere Aufrufe von `setState` können gebatcht werden.
* **Re-Render**: Jede Änderung löst ein erneutes Rendern der Komponente aus.
* **Funktionsform** wird bevorzugt, wenn der neue Wert vom alten abhängt.

---

### Zusammenfassung

* `setState` aktualisiert den State und löst ein Re-Render aus.
* In **Klassenkomponenten**: Methode mit Objekt/Funktion.
* In **Funktionskomponenten**: Setter vom `useState`-Hook.
* Updates sind **asynchron** und werden **gebündelt**.

📖 Weiterführend:

* [React Offizielle Dokumentation – setState](https://react.dev/reference/react/useState#updating-state-based-on-the-previous-state)

---

  **[⬆ Наверх](#top)**

27. ### <a name="27"></a> Was ist der Unterschied zwischen kontrollierten und unkontrollierten Komponenten?

### Unterschied: Kontrollierte vs. Unkontrollierte Komponenten

1. **Kontrollierte Komponenten**

   * Der **State der Eingabeelemente** (z. B. `input`, `textarea`, `select`) wird in React verwaltet.
   * Der Wert kommt aus dem **State** der Komponente, Änderungen laufen über ein Event-Handler.
   * React = **Single Source of Truth**.

   ```jsx
   import { useState } from "react";

   function ControlledInput() {
     const [value, setValue] = useState("");

     return (
       <input
         value={value} // State bestimmt den Wert
         onChange={e => setValue(e.target.value)} // React kontrolliert
       />
     );
   }
   ```

---

2. **Unkontrollierte Komponenten**

   * Der Wert wird direkt vom **DOM selbst** verwaltet.
   * Zugriff über **Refs** anstatt über State.
   * React kontrolliert den Wert **nicht kontinuierlich**.

   ```jsx
   import { useRef } from "react";

   function UncontrolledInput() {
     const inputRef = useRef();

     const handleClick = () => {
       alert(inputRef.current.value); // Wert direkt aus DOM
     };

     return (
       <>
         <input ref={inputRef} />
         <button onClick={handleClick}>Zeig Wert</button>
       </>
     );
   }
   ```

---

### Vergleich

| Kontrolliert                         | Unkontrolliert                           |
| ------------------------------------ | ---------------------------------------- |
| React verwaltet den Wert (State)     | DOM verwaltet den Wert                   |
| `value` + `onChange`                 | Zugriff via `ref`                        |
| Besser für Validierung & komplexe UI | Einfacher für schnelle, kleine Formulare |

---

### Zusammenfassung

* **Kontrollierte Komponenten**: Wert = State in React, Änderungen laufen über Events → **voller React-Kontrolle**.
* **Unkontrollierte Komponenten**: Wert = DOM, Zugriff über Ref → **schneller, aber weniger flexibel**.
* Best Practice: Kontrollierte Komponenten für größere UIs, unkontrollierte für einfache Fälle.

📖 Weiterführend:

* [React Offizielle Dokumentation – Forms](https://react.dev/learn/sharing-state-between-components#controlled-and-uncontrolled-components)

---

  **[⬆ Наверх](#top)**

28. ### <a name="28"></a> Was sind Default Props und PropTypes?

### Default Props

* Mit **Default Props** kann man Standardwerte für Props definieren, falls der Elternkomponente kein Wert übergeben wird.
* Praktisch, um **Fallback-Werte** sicherzustellen.

```jsx
function Button({ label }) {
  return <button>{label}</button>;
}

// Standardwert, falls `label` nicht übergeben wird
Button.defaultProps = {
  label: "Klicken"
};

export default Button;
```

→ In modernen React-Versionen (17+) werden Default Props für **Funktionskomponenten** weniger genutzt, stattdessen oft **Default-Parameter**:

```jsx
function Button({ label = "Klicken" }) {
  return <button>{label}</button>;
}
```

---

### PropTypes

* **PropTypes** ist ein Typprüfungssystem für Props zur **Laufzeit**.
* Hilft, Fehler früh zu erkennen, indem überprüft wird, ob Props den erwarteten Typ haben.

```jsx
import PropTypes from "prop-types";

function User({ name, age }) {
  return <p>{name} ist {age} Jahre alt</p>;
}

User.propTypes = {
  name: PropTypes.string.isRequired,
  age: PropTypes.number
};
```

* Wird ein falscher Typ übergeben, zeigt React im **Konsolen-Log eine Warnung**.

---

### Zusammenfassung

* **Default Props**: legen Standardwerte fest, wenn keine Props übergeben werden.
* **PropTypes**: prüfen Props-Typen **zur Laufzeit** und helfen bei der Fehlervermeidung.
* Heute oft ersetzt durch **TypeScript** für statische Typisierung.

📖 Weiterführend:

* [React Offizielle Dokumentation – Typprüfung](https://react.dev/reference/react/Component#static-defaultprops)
* [PropTypes auf npm](https://www.npmjs.com/package/prop-types)

---

  **[⬆ Наверх](#top)**

29. ### <a name="29"></a> Was ist React.memo und wofür wird es verwendet?

### React.memo

**`React.memo`** ist eine **Higher-Order-Komponente (HOC)**, die Funktionskomponenten **memoisiert**.
Das bedeutet: Eine Komponente wird **nur neu gerendert, wenn sich ihre Props ändern**.

---

### Wofür wird es verwendet?

1. **Performance-Optimierung**

   * Verhindert unnötige Re-Renders bei unveränderten Props.
   * Besonders sinnvoll bei **teuren Berechnungen** oder **großen Listen**.

2. **Vergleich der Props**

   * Standardmäßig nutzt React einen **shallow comparison** (flacher Vergleich).
   * Für komplexe Objekte kann man eine eigene Vergleichsfunktion übergeben.

---

### Beispiel

```jsx
import React, { useState } from "react";

const Child = React.memo(function Child({ value }) {
  console.log("Render:", value);
  return <p>Wert: {value}</p>;
});

export default function App() {
  const [count, setCount] = useState(0);
  const [text, setText] = useState("");

  return (
    <>
      <Child value={count} />
      <button onClick={() => setCount(count + 1)}>+1</button>
      <input value={text} onChange={e => setText(e.target.value)} />
    </>
  );
}
```

* `Child` rendert nur neu, wenn sich `value` ändert.
* Änderungen an `text` haben **keinen Einfluss** auf `Child`.

---

### Zusammenfassung

* **`React.memo`** = Memoization für Funktionskomponenten.
* Verhindert unnötige Re-Renders, wenn Props unverändert bleiben.
* Standard: **shallow comparison**, optional eigene Vergleichsfunktion.

📖 Weiterführend:

* [React Offizielle Dokumentation – React.memo](https://react.dev/reference/react/memo)

---

  **[⬆ Наверх](#top)**

30. ### <a name="30"></a> Was ist PureComponent und wie unterscheidet es sich von Component?

### PureComponent vs. Component

1. **`React.Component`**

   * Basis-Klasse für Klassenkomponenten.
   * Führt bei jedem `setState` oder neuen Props ein Re-Render durch, auch wenn sich die Werte nicht tatsächlich geändert haben.

2. **`React.PureComponent`**

   * Erweiterung von `Component`.
   * Führt **automatisch einen shallow comparison** (flachen Vergleich) von Props und State durch.
   * Rendert nur neu, wenn sich **wirklich etwas geändert hat**.

---

### Beispiel

```jsx
import React, { Component, PureComponent } from "react";

class NormalComponent extends Component {
  render() {
    console.log("NormalComponent gerendert");
    return <p>{this.props.value}</p>;
  }
}

class OptimizedComponent extends PureComponent {
  render() {
    console.log("PureComponent gerendert");
    return <p>{this.props.value}</p>;
  }
}
```

* `NormalComponent` rendert bei **jeder Aktualisierung**, auch wenn `value` gleich bleibt.
* `OptimizedComponent` rendert **nur, wenn sich `value` geändert hat**.

---

### Unterschiede im Überblick

| **Component**                         | **PureComponent**                                 |
| ------------------------------------- | ------------------------------------------------- |
| Rendert immer bei Updates             | Rendert nur bei Änderungen (shallow compare)      |
| Keine Optimierung                     | Eingebaute Performance-Optimierung                |
| Manuell `shouldComponentUpdate` nötig | `shouldComponentUpdate` automatisch implementiert |

---

### Zusammenfassung

* **Component**: rendert immer neu bei Updates.
* **PureComponent**: optimiert, rendert nur bei tatsächlichen Änderungen (shallow compare).
* Ziel: **Performance-Optimierung** bei Klassenkomponenten.

📖 Weiterführend:

* [React Offizielle Dokumentation – PureComponent](https://react.dev/reference/react/PureComponent)

---

  **[⬆ Наверх](#top)**  

31. ### <a name="31"></a> Wann sollte shouldComponentUpdate verwendet werden?

### `shouldComponentUpdate` in React

**`shouldComponentUpdate(nextProps, nextState)`** ist eine Lifecycle-Methode in **Klassenkomponenten**, die bestimmt, ob ein Re-Render stattfinden soll.
Sie gibt **true** (neu rendern) oder **false** (kein Render) zurück.

---

### Wann einsetzen?

1. **Performance-Optimierung**

   * Wenn eine Komponente sehr oft aktualisiert wird, aber die meisten Updates keine sichtbaren Änderungen im UI verursachen.
   * Durch Rückgabe von `false` können unnötige Re-Renders vermieden werden.

2. **Feinsteuerung**

   * Wenn der Standardvergleich von `PureComponent` (shallow compare) nicht ausreicht.
   * Beispiel: tiefe Objektstrukturen, die differenziert geprüft werden müssen.

---

### Beispiel

```jsx
import React, { Component } from "react";

class User extends Component {
  shouldComponentUpdate(nextProps) {
    // Nur neu rendern, wenn sich der Name geändert hat
    return nextProps.name !== this.props.name;
  }

  render() {
    console.log("Rendering:", this.props.name);
    return <p>{this.props.name}</p>;
  }
}

export default User;
```

---

### Zusammenfassung

* **`shouldComponentUpdate`** steuert, ob ein Re-Render notwendig ist.
* Sinnvoll bei **Performance-Optimierungen** und **kontrollierten Updates**.
* Heute oft ersetzt durch **PureComponent** oder **React.memo** in Funktionskomponenten.

📖 Weiterführend:

* [React Offizielle Dokumentation – shouldComponentUpdate](https://react.dev/reference/react/Component#shouldcomponentupdate)

---

  **[⬆ Наверх](#top)**

32. ### <a name="32"></a> Was ist ein ref und wann wird er eingesetzt?

### Ref in React

Ein **ref (reference)** ist ein spezielles Objekt in React, mit dem man direkt auf ein **DOM-Element** oder eine **Komponenteninstanz** zugreifen kann. Refs werden mit `useRef` (Funktionskomponenten) oder `React.createRef` (Klassenkomponenten) erstellt.

---

### Wann einsetzen?

1. **Direkter Zugriff auf DOM-Elemente**

   * Fokus setzen, Text selektieren, Scrollen steuern.

2. **Speichern von veränderlichen Werten**

   * Werte zwischen Renders behalten, ohne ein Re-Render auszulösen.

3. **Integration mit Drittbibliotheken**

   * z. B. Zugriff auf Canvas, Charts, Animationen.

---

### Beispiele

**Funktionskomponente mit `useRef`:**

```jsx
import { useRef } from "react";

function InputFocus() {
  const inputRef = useRef();

  const handleClick = () => {
    inputRef.current.focus(); // direkter DOM-Zugriff
  };

  return (
    <>
      <input ref={inputRef} type="text" />
      <button onClick={handleClick}>Fokus setzen</button>
    </>
  );
}

export default InputFocus;
```

**Persistente Werte ohne Re-Render:**

```jsx
import { useRef, useState } from "react";

function Timer() {
  const countRef = useRef(0);
  const [stateCount, setStateCount] = useState(0);

  const increment = () => {
    countRef.current += 1;      // kein Re-Render
    setStateCount(stateCount+1); // triggert Re-Render
  };

  return (
    <p>Ref: {countRef.current}, State: {stateCount}</p>
  );
}
```

---

### Zusammenfassung

* **Refs** = direkte Referenzen auf DOM-Elemente oder persistente Werte.
* Einsatz: Fokus, Scroll, Animationssteuerung, Integration mit Drittlibs, Werte speichern ohne Re-Render.
* Erstellung: `useRef` (Hooks), `createRef` (Klassen).

📖 Weiterführend:

* [React Offizielle Dokumentation – Refs](https://react.dev/learn/referencing-values-with-refs)

---

  **[⬆ Наверх](#top)**

33. ### <a name="33"></a> Was bedeutet „Lifting State Up“?

### Lifting State Up in React

**Lifting State Up** bedeutet, dass man den **State aus einer Kindkomponente in die gemeinsame Elternkomponente verlagert**, wenn mehrere Komponenten denselben Zustand benötigen.
So entsteht **eine gemeinsame Quelle der Wahrheit** (Single Source of Truth), und der Datenfluss bleibt **eindirektional**.

---

### Beispiel

```jsx
import { useState } from "react";

function TemperatureInput({ label, value, onChange }) {
  return (
    <>
      <label>{label}: </label>
      <input
        type="number"
        value={value}
        onChange={e => onChange(e.target.value)}
      />
    </>
  );
}

function Calculator() {
  const [temperature, setTemperature] = useState("");

  return (
    <>
      <TemperatureInput
        label="Celsius"
        value={temperature}
        onChange={setTemperature}
      />
      <TemperatureInput
        label="Fahrenheit"
        value={(temperature * 9) / 5 + 32}
        onChange={val => setTemperature(((val - 32) * 5) / 9)}
      />
    </>
  );
}

export default Calculator;
```

* Beide Inputs teilen sich denselben **State in der Elternkomponente**.
* Änderungen an einem Feld werden sofort im anderen reflektiert.

---

### Zusammenfassung

* **Lifting State Up** = Verschieben von State in die **Elternkomponente**, um Daten zwischen Kindern zu synchronisieren.
* Vorteile: eine gemeinsame Wahrheit, konsistenter Datenfluss, bessere Wartbarkeit.

📖 Weiterführend:

* [React Offizielle Dokumentation – Lifting State Up](https://react.dev/learn/sharing-state-between-components#lifting-state-up)

---

  **[⬆ Наверх](#top)**

34. ### <a name="34"></a> 



  **[⬆ Наверх](#top)**

35. ### <a name="35"></a> 



  **[⬆ Наверх](#top)**

36. ### <a name="36"></a> 



  **[⬆ Наверх](#top)**

37. ### <a name="37"></a> 



  **[⬆ Наверх](#top)**

38. ### <a name="38"></a> 



  **[⬆ Наверх](#top)**

39. ### <a name="39"></a> 



  **[⬆ Наверх](#top)**

40. ### <a name="40"></a> 



  **[⬆ Наверх](#top)**  

41. ### <a name="41"></a> Was sind die Phasen des Komponentenlebenszyklus?

### Phasen des Komponentenlebenszyklus (Class Components)

In React (bei **Klassenkomponenten**) besteht der **Lebenszyklus** einer Komponente aus drei Hauptphasen:

1. **Mounting (Einfügen ins DOM)**

   * Methoden:

     * `constructor()`
     * `static getDerivedStateFromProps()`
     * `render()`
     * `componentDidMount()`

2. **Updating (Aktualisierung bei Props/State-Änderungen)**

   * Methoden:

     * `static getDerivedStateFromProps()`
     * `shouldComponentUpdate()`
     * `render()`
     * `getSnapshotBeforeUpdate()`
     * `componentDidUpdate()`

3. **Unmounting (Entfernen aus dem DOM)**

   * Methode:

     * `componentWillUnmount()`

---

### Beispiel

```jsx
import React, { Component } from "react";

class Demo extends Component {
  constructor(props) {
    super(props);
    console.log("1. constructor");
    this.state = { count: 0 };
  }

  componentDidMount() {
    console.log("4. componentDidMount");
  }

  shouldComponentUpdate() {
    console.log("Update? -> true");
    return true;
  }

  componentDidUpdate() {
    console.log("componentDidUpdate");
  }

  componentWillUnmount() {
    console.log("componentWillUnmount");
  }

  render() {
    console.log("render()");
    return (
      <button onClick={() => this.setState({ count: this.state.count + 1 })}>
        {this.state.count}
      </button>
    );
  }
}

export default Demo;
```

---

### Vergleich zu Hooks

* **Mounting/Updating/Unmounting** wird heute meist mit **`useEffect`** in Funktionskomponenten abgebildet.

```jsx
import { useState, useEffect } from "react";

function Demo() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log("Mounting & Updating");
    return () => console.log("Unmounting");
  }, [count]);

  return <button onClick={() => setCount(count + 1)}>{count}</button>;
}
```

---

### Zusammenfassung

* Lebenszyklus hat drei Phasen: **Mounting, Updating, Unmounting**.
* Klassenkomponenten nutzen Methoden (`componentDidMount`, `componentDidUpdate`, `componentWillUnmount`).
* Funktionskomponenten verwenden stattdessen **Hooks (useEffect)**.

📖 Weiterführend:

* [React Offizielle Dokumentation – Lifecycle](https://react.dev/reference/react/Component)

---

  **[⬆ Наверх](#top)**

42. ### <a name="42"></a> Welche Lifecycle-Methoden gibt es in Klassenkomponenten?

### Lifecycle-Methoden in Klassenkomponenten

React-Klassenkomponenten haben verschiedene Lifecycle-Methoden, die in drei Phasen eingeteilt werden:

---

#### 1. **Mounting (Einfügen ins DOM)**

* `constructor()` → Initialisierung von State und Binding.
* `static getDerivedStateFromProps(props, state)` → selten genutzt, synchronisiert State mit Props.
* `render()` → gibt das JSX zurück.
* `componentDidMount()` → ausgeführt **nach dem ersten Render**, ideal für API-Calls oder DOM-Manipulation.

---

#### 2. **Updating (bei Props/State-Änderungen)**

* `static getDerivedStateFromProps(props, state)` → wird auch hier aufgerufen.
* `shouldComponentUpdate(nextProps, nextState)` → entscheidet, ob Re-Render nötig ist (Performance-Optimierung).
* `render()` → erneutes Rendern der Komponente.
* `getSnapshotBeforeUpdate(prevProps, prevState)` → Zugriff auf DOM vor dem Update.
* `componentDidUpdate(prevProps, prevState, snapshot)` → nach dem Rendern, gut für Netzwerkaufrufe oder DOM-Updates.

---

#### 3. **Unmounting (Entfernen aus DOM)**

* `componentWillUnmount()` → Aufräumarbeiten (Timer clearen, Event Listener entfernen).

---

#### 4. **Error Handling (seit React 16)**

* `static getDerivedStateFromError(error)` → fängt Fehler ab, bevor UI zusammenbricht.
* `componentDidCatch(error, info)` → Logging von Fehlern.

---

### Zusammenfassung

* **Mounting**: `constructor`, `getDerivedStateFromProps`, `render`, `componentDidMount`.
* **Updating**: `getDerivedStateFromProps`, `shouldComponentUpdate`, `render`, `getSnapshotBeforeUpdate`, `componentDidUpdate`.
* **Unmounting**: `componentWillUnmount`.
* **Error Handling**: `getDerivedStateFromError`, `componentDidCatch`.

📖 Weiterführend:

* [React Offizielle Dokumentation – Component API](https://react.dev/reference/react/Component)

---

  **[⬆ Наверх](#top)**

43. ### <a name="43"></a> Welche Lifecycle-Methoden sind veraltet?

### Veraltete Lifecycle-Methoden in React

Einige Lifecycle-Methoden von **Klassenkomponenten** gelten seit **React 16.3** als **deprecated** (veraltet), weil sie oft zu **Fehlern und unerwartetem Verhalten** führten.

---

### Veraltete Methoden

1. **`componentWillMount()`**

   * Wurde vor dem ersten Render ausgeführt.
   * Ersetzt durch: **`constructor`** oder **`componentDidMount`**.

2. **`componentWillReceiveProps(nextProps)`**

   * Wurde bei neuen Props aufgerufen.
   * Ersetzt durch: **`static getDerivedStateFromProps`** oder **`componentDidUpdate`**.

3. **`componentWillUpdate(nextProps, nextState)`**

   * Wurde vor einem Update aufgerufen.
   * Ersetzt durch: **`getSnapshotBeforeUpdate`** oder **`componentDidUpdate`**.

---

### UNSAFE_-Präfix

Seit React 16.3 existieren diese Methoden noch, aber mit **`UNSAFE_`-Präfix**, z. B.:

* `UNSAFE_componentWillMount`
* `UNSAFE_componentWillReceiveProps`
* `UNSAFE_componentWillUpdate`

---

### Zusammenfassung

* Veraltet: `componentWillMount`, `componentWillReceiveProps`, `componentWillUpdate`.
* Grund: sie verursachen **Side-Effects** im falschen Zeitpunkt.
* Alternative: **`getDerivedStateFromProps`, `componentDidMount`, `componentDidUpdate`, `getSnapshotBeforeUpdate`**.

📖 Weiterführend:

* [React Offizielle Dokumentation – UNSAFE Lifecycle Methods](https://react.dev/reference/react/Component#unsafe_componentwillmount)

---

  **[⬆ Наверх](#top)**

44. ### <a name="44"></a> Wie kann man Lifecycle-Methoden mit Hooks ersetzen?

### Lifecycle-Methoden → Hooks: 1:1-Ersatz und Patterns

| Klassen-Lifecycle                                             | Entsprechung mit Hooks (Funktionskomponenten)                                                                                | Hinweis                                                              |
| ------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------- |
| `constructor`                                                 | Initial-State via `useState(initial)`                                                                                        | Auch für Event-Handler-Binding nicht nötig.                          |
| `componentDidMount`                                           | `useEffect(() => { /* init */ }, [])`                                                                                        | Läuft nach dem ersten Render (commit).                               |
| `componentDidUpdate`                                          | `useEffect(() => { /* reagiert auf deps */ }, [deps])`                                                                       | Läuft nach jedem Render, wenn `deps` sich ändern.                    |
| `componentWillUnmount`                                        | Cleanup-Funktion in `useEffect`: `return () => {/* cleanup */}`                                                              | Abmelden von Listenern, Timer clearen etc.                           |
| `shouldComponentUpdate`                                       | Strukturell: `React.memo(Component)`; feingranular: `useMemo`, `useCallback`                                                 | Verhindert unnötige Re-Renders.                                      |
| `getDerivedStateFromProps`                                    | Meist **vermeiden**. Alternativen: ableiten im Render, `useMemo` für teure Ableitungen, oder `useEffect` zum Synchronisieren | Props nicht in State duplizieren, wenn möglich.                      |
| `getSnapshotBeforeUpdate` → `componentDidUpdate`              | `useLayoutEffect` + `useRef` für **Layout-Messungen** vor dem Paint; Vor-/Nachwerte per Ref speichern                        | `useLayoutEffect` läuft synchron nach DOM-Mutationen, vor dem Paint. |
| Fehlergrenzen: `getDerivedStateFromError`/`componentDidCatch` | **Kein Hook-Äquivalent**. Error Boundaries weiterhin als **Klassenkomponenten** implementieren                               | Alternativ: vorhandene Boundary-Komponenten wiederverwenden.         |

---

### Minimalbeispiele

**Mount/Update/Unmount (Effect + Cleanup)**

```jsx
import { useEffect, useState } from "react";

export default function Chat() {
  const [connected, setConnected] = useState(false);

  useEffect(() => {
    const conn = connect();       // componentDidMount / DidUpdate (deps s.u.)
    setConnected(true);
    return () => conn.disconnect(); // componentWillUnmount
  }, []); // leeres Array: nur einmal nach Mount

  return <p>{connected ? "Online" : "Offline"}</p>;
}
```

**shouldComponentUpdate → React.memo**

```jsx
import React, { useMemo } from "react";

const List = React.memo(function List({ items }) {
  const total = useMemo(() => items.reduce((s, x) => s + x.value, 0), [items]);
  return <p>Total: {total}</p>;
});

export default List;
```

**getDerivedStateFromProps vermeiden (Ableitung statt Spiegeln)**

```jsx
import { useMemo } from "react";

// Statt Prop -> State-Spiegelung:
export default function Price({ net, vatPercent }) {
  const gross = useMemo(() => net * (1 + vatPercent / 100), [net, vatPercent]);
  return <span>{gross.toFixed(2)} €</span>;
}
```

**getSnapshotBeforeUpdate → useLayoutEffect für Layout/Scroll**

```jsx
import { useLayoutEffect, useRef } from "react";

export default function AutoScroll({ messages }) {
  const listRef = useRef(null);
  const prevLen = useRef(0);

  useLayoutEffect(() => {
    const list = listRef.current;
    const nearBottom =
      list.scrollHeight - list.scrollTop - list.clientHeight < 20;

    // läuft nach DOM-Mutationen, vor dem Paint
    if (nearBottom || messages.length < prevLen.current) {
      list.scrollTop = list.scrollHeight; // „Snapshot“-artiges Verhalten
    }
    prevLen.current = messages.length;
  }, [messages]);

  return (
    <ul ref={listRef} style={{ maxHeight: 200, overflow: "auto" }}>
      {messages.map(m => <li key={m.id}>{m.text}</li>)}
    </ul>
  );
}
```

**Fehlergrenze (weiterhin Klasse)**

```jsx
import React from "react";

export class ErrorBoundary extends React.Component {
  state = { hasError: false };

  static getDerivedStateFromError() {
    return { hasError: true };
  }
  componentDidCatch(error, info) {
    console.error(error, info);
  }
  render() {
    return this.state.hasError ? <h1>Etwas ging schief.</h1> : this.props.children;
  }
}
```

---

### Zusammenfassung

* Mount/Update/Unmount: `useEffect` (mit/ohne deps) + **Cleanup**.
* Rendersteuerung: `React.memo`, `useMemo`, `useCallback`.
* Layout-kritisch: `useLayoutEffect` + `useRef`.
* `getDerivedStateFromProps` meist vermeiden (Props nicht spiegeln).
* Error Boundaries: weiterhin **Klassenkomponenten**.

📖 Weiterführend:

* React Docs: [Effects](https://react.dev/learn/synchronizing-with-effects), [useEffect](https://react.dev/reference/react/useEffect), [useLayoutEffect](https://react.dev/reference/react/useLayoutEffect), [Memoisierung](https://react.dev/learn/escape-hatches#memoizing-calculations), [React.memo](https://react.dev/reference/react/memo), [Error Boundaries](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary)
* MDN (RU): [События](https://developer.mozilla.org/ru/docs/Learn/JavaScript/Building_blocks/Events), [requestAnimationFrame](https://developer.mozilla.org/ru/docs/Web/API/window/requestAnimationFrame) (Kontext für Layout/Rendering-Zeitpunkte)

  **[⬆ Наверх](#top)**

45. ### <a name="45"></a> Was ist componentDidMount und was ist das Äquivalent mit Hooks?

### `componentDidMount` in Klassenkomponenten

* Wird **einmal nach dem ersten Render** ausgeführt, sobald die Komponente ins DOM eingefügt wurde.
* Typische Einsätze:

  * **API-Requests starten**
  * **Event-Listener registrieren**
  * **DOM-Manipulationen** (Fokus setzen etc.)

```jsx
import React, { Component } from "react";

class Demo extends Component {
  componentDidMount() {
    console.log("Komponente wurde gemountet");
    document.title = "Hallo Sergii";
  }

  render() {
    return <h1>Hallo</h1>;
  }
}
```

---

### Äquivalent mit Hooks → `useEffect`

In Funktionskomponenten übernimmt `useEffect` die Rolle von Lifecycle-Methoden.

* **Äquivalent zu `componentDidMount`:** `useEffect` mit leerem Abhängigkeitsarray `[]`.

```jsx
import { useEffect } from "react";

function Demo() {
  useEffect(() => {
    console.log("Komponente wurde gemountet");
    document.title = "Hallo Sergii";
  }, []); // leeres Array -> nur beim ersten Mount

  return <h1>Hallo</h1>;
}

export default Demo;
```

---

### Zusammenfassung

* **`componentDidMount`**: läuft einmal nach dem Einfügen ins DOM (Klassenkomponenten).
* **Hook-Äquivalent**: `useEffect(() => { ... }, [])` in Funktionskomponenten.
* Typische Nutzung: API-Calls, Event-Registrierung, DOM-Manipulation.

📖 Weiterführend:

* [React Offizielle Dokumentation – useEffect](https://react.dev/reference/react/useEffect)

---

  **[⬆ Наверх](#top)**

46. ### <a name="46"></a> 



  **[⬆ Наверх](#top)**

47. ### <a name="47"></a> 



  **[⬆ Наверх](#top)**

48. ### <a name="48"></a> 



  **[⬆ Наверх](#top)**

49. ### <a name="49"></a> 



  **[⬆ Наверх](#top)**

50. ### <a name="50"></a> 



  **[⬆ Наверх](#top)**  

51. ### <a name="51"></a> Was sind Hooks in React?

### Hooks in React

**Hooks** sind spezielle **Funktionen**, die es ermöglichen, in **Funktionskomponenten** React-Features wie **State, Lifecycle-Methoden und Context** zu nutzen – ohne Klassenkomponenten zu schreiben. Sie wurden mit **React 16.8** eingeführt.

---

### Warum Hooks?

1. Ersetzen viele Anwendungsfälle von **Klassenkomponenten**.
2. Erlauben **Wiederverwendung von Logik** (Custom Hooks).
3. Machen Code **kürzer, klarer und besser testbar**.

---

### Wichtige eingebaute Hooks

* **State**: `useState` → lokaler Zustand.
* **Lifecycle/Side Effects**: `useEffect`, `useLayoutEffect`.
* **Referenzen**: `useRef`.
* **Performance**: `useMemo`, `useCallback`.
* **Context**: `useContext`.
* **Reducer**: `useReducer` für komplexere State-Logik.

---

### Beispiel

```jsx
import { useState, useEffect } from "react";

function Counter() {
  const [count, setCount] = useState(0); // State-Hook

  useEffect(() => {
    document.title = `Zähler: ${count}`; // Effect-Hook (componentDidMount/DidUpdate)
  }, [count]);

  return (
    <>
      <p>Zähler: {count}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
    </>
  );
}

export default Counter;
```

---

### Zusammenfassung

* **Hooks = Funktionen**, die React-Features (State, Lifecycle, Context) in **Funktionskomponenten** bringen.
* Vorteil: keine Klassen mehr nötig, bessere Wiederverwendung von Logik.
* Kernhooks: `useState`, `useEffect`, `useContext`, `useRef`, `useMemo`, `useCallback`.

📖 Weiterführend:

* [React Offizielle Dokumentation – Einführung in Hooks](https://react.dev/learn/state-a-components-memory#using-hooks)

---

  **[⬆ Наверх](#top)**

52. ### <a name="52"></a> Wie funktionieren useState und useEffect?

### `useState`

* `useState` ist ein Hook, der in einer **Funktionskomponente** lokalen State speichert.
* Er liefert ein **Array mit zwei Werten**: `[aktuellerState, SetterFunktion]`.
* Änderungen über den Setter triggern ein **Re-Render** der Komponente.

```jsx
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0); // Initialwert = 0

  return (
    <>
      <p>Zähler: {count}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
    </>
  );
}
```

---

### `useEffect`

* `useEffect` ermöglicht **Side Effects** in Funktionskomponenten (z. B. API-Calls, Event-Listener, DOM-Manipulation).
* Standardmäßig läuft er **nach jedem Render**.
* Mit **Abhängigkeitsarray** kann man steuern:

  * `[]` → nur beim ersten Mount (`componentDidMount`).
  * `[deps]` → bei Änderungen der Abhängigkeiten (`componentDidUpdate`).
  * Cleanup-Funktion → beim Unmount (`componentWillUnmount`).

```jsx
import { useEffect, useState } from "react";

function Timer() {
  const [seconds, setSeconds] = useState(0);

  useEffect(() => {
    const id = setInterval(() => setSeconds(s => s + 1), 1000);

    return () => clearInterval(id); // Cleanup beim Unmount
  }, []);

  return <p>Timer: {seconds}s</p>;
}
```

---

### Zusammenfassung

* **`useState`**: lokaler State in Funktionskomponenten (`[state, setState]`).
* **`useEffect`**: verwaltet Side Effects (API, Timer, DOM), inkl. Cleanup.
* Zusammen bilden sie das Grundgerüst für State-Management und Lifecycle-Handling in React.

📖 Weiterführend:

* [React Offizielle Dokumentation – useState](https://react.dev/reference/react/useState)
* [React Offizielle Dokumentation – useEffect](https://react.dev/reference/react/useEffect)

---

  **[⬆ Наверх](#top)**

53. ### <a name="53"></a> Was macht useContext?

### `useContext` in React

* **`useContext`** ist ein Hook, der Zugriff auf den Wert eines **React Contexts** ermöglicht.
* Er ersetzt die Notwendigkeit, Props durch viele Komponenten weiterzureichen (**Prop Drilling**).
* Jede Komponente, die `useContext` nutzt, wird neu gerendert, sobald sich der Context-Wert ändert.

---

### Beispiel

```jsx
import { createContext, useContext } from "react";

// 1. Context erstellen
const ThemeContext = createContext("light");

function ThemedButton() {
  // 2. Zugriff auf den aktuellen Wert
  const theme = useContext(ThemeContext);
  return <button className={theme}>Klick mich</button>;
}

export default function App() {
  return (
    // 3. Provider legt den Wert fest
    <ThemeContext.Provider value="dark">
      <ThemedButton />
    </ThemeContext.Provider>
  );
}
```

* `ThemeContext.Provider` → stellt den Wert (`"dark"`) bereit.
* `useContext(ThemeContext)` → liest den Wert aus, ohne Props weiterzureichen.

---

### Zusammenfassung

* **`useContext`**: Hook zum direkten Zugriff auf einen Context-Wert.
* Nutzen: Vermeidet **Prop Drilling**, ideal für globale Daten (Theme, Auth, Sprache).
* Änderung des Contexts → Re-Render aller abhängigen Komponenten.

📖 Weiterführend:

* [React Offizielle Dokumentation – useContext](https://react.dev/reference/react/useContext)

---

  **[⬆ Наверх](#top)**

54. ### <a name="54"></a> Was ist useRef und wann wird es verwendet?

### `useRef` in React

* **`useRef`** ist ein Hook, der ein **veränderbares Objekt mit der Eigenschaft `.current`** zurückgibt.
* Dieses Objekt bleibt **über die gesamte Lebensdauer** der Komponente gleich.
* Änderungen an `.current` lösen **kein Re-Render** aus.

---

### Wann wird `useRef` verwendet?

1. **Direkter Zugriff auf DOM-Elemente**

   * Fokus setzen, Scroll-Position manipulieren, Integration mit Drittbibliotheken.

2. **Speichern von Werten zwischen Renders**

   * Persistente Werte behalten (z. B. Timer-ID, vorheriger Wert).

3. **Performance-Optimierung**

   * Verhindern, dass ein Wert bei jedem Render neu erzeugt wird.

---

### Beispiele

**DOM-Zugriff:**

```jsx
import { useRef } from "react";

function InputFocus() {
  const inputRef = useRef();

  const handleClick = () => {
    inputRef.current.focus(); // Zugriff auf das DOM-Element
  };

  return (
    <>
      <input ref={inputRef} type="text" />
      <button onClick={handleClick}>Fokus setzen</button>
    </>
  );
}
```

**Persistenter Wert (kein Re-Render):**

```jsx
import { useRef, useEffect } from "react";

function Timer() {
  const count = useRef(0);

  useEffect(() => {
    const id = setInterval(() => {
      count.current += 1; // Wert ändern ohne Re-Render
      console.log("Sekunden:", count.current);
    }, 1000);
    return () => clearInterval(id);
  }, []);

  return <p>Siehe Konsole</p>;
}
```

---

### Zusammenfassung

* **`useRef`** speichert eine veränderbare Referenz (`.current`) über Renders hinweg.
* Einsatz: DOM-Zugriffe, persistente Werte, Performance-Optimierung.
* Unterschied zu State: **Änderungen an `useRef` triggern kein Re-Render**.

📖 Weiterführend:

* [React Offizielle Dokumentation – useRef](https://react.dev/reference/react/useRef)

---

  **[⬆ Наверх](#top)**

55. ### <a name="55"></a> Was ist useCallback, useMemo, useReducer?

### 1. `useCallback`

* Gibt eine **memoisierte Callback-Funktion** zurück.
* Nützlich, um **unnötige Re-Renders** von Kindkomponenten zu vermeiden, die eine Callback-Prop erhalten.
* Nur neu erstellt, wenn sich die Abhängigkeiten ändern.

```jsx
import { useState, useCallback } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  const increment = useCallback(() => setCount(c => c + 1), []);
  // gleiche Funktion bleibt über Renders hinweg erhalten

  return <button onClick={increment}>{count}</button>;
}
```

---

### 2. `useMemo`

* Gibt einen **memoisierten Wert** zurück.
* Verhindert, dass **teure Berechnungen** bei jedem Render erneut ausgeführt werden.
* Nur neu berechnet, wenn sich die Abhängigkeiten ändern.

```jsx
import { useState, useMemo } from "react";

function ExpensiveCalc({ num }) {
  const result = useMemo(() => {
    console.log("Teure Berechnung...");
    return num * 2;
  }, [num]);

  return <p>Ergebnis: {result}</p>;
}
```

---

### 3. `useReducer`

* Alternative zu `useState`, besonders für **komplexe State-Logik** oder **mehrere verbundene Zustände**.
* Funktioniert ähnlich wie ein **Redux-Reducer**: `state` + `action` → neuer `state`.

```jsx
import { useReducer } from "react";

function reducer(state, action) {
  switch (action.type) {
    case "increment":
      return { count: state.count + 1 };
    case "decrement":
      return { count: state.count - 1 };
    default:
      return state;
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, { count: 0 });

  return (
    <>
      <p>Zähler: {state.count}</p>
      <button onClick={() => dispatch({ type: "increment" })}>+1</button>
      <button onClick={() => dispatch({ type: "decrement" })}>-1</button>
    </>
  );
}
```

---

### Zusammenfassung

* **`useCallback`**: memoisiert Funktionen → vermeidet unnötige Neu-Erstellungen.
* **`useMemo`**: memoisiert Werte → verhindert teure Neuberechnungen.
* **`useReducer`**: State-Management für komplexe Logik, basierend auf Reducer-Pattern.

📖 Weiterführend:

* [React Offizielle Dokumentation – useCallback](https://react.dev/reference/react/useCallback)
* [React Offizielle Dokumentation – useMemo](https://react.dev/reference/react/useMemo)
* [React Offizielle Dokumentation – useReducer](https://react.dev/reference/react/useReducer)

---

  **[⬆ Наверх](#top)**

56. ### <a name="56"></a> Wie schreibt man einen benutzerdefinierten Hook?

### Benutzerdefinierte Hooks (Custom Hooks)

Ein **Custom Hook** ist eine normale **JavaScript-Funktion**, deren Name mit **`use`** beginnt und die **React Hooks** (z. B. `useState`, `useEffect`) verwendet.
Zweck: **Wiederverwendung von Logik** in verschiedenen Komponenten.

---

### Regeln

1. Name muss mit `use...` beginnen.
2. Darf nur innerhalb von React-Komponenten oder anderen Hooks verwendet werden.
3. Muss die [Regeln der Hooks](https://react.dev/warnings/rules-of-hooks) einhalten: nur **Top-Level**, niemals in Schleifen oder Bedingungen.

---

### Beispiel – Fensterbreite beobachten

```jsx
import { useState, useEffect } from "react";

// Custom Hook
function useWindowWidth() {
  const [width, setWidth] = useState(window.innerWidth);

  useEffect(() => {
    const handleResize = () => setWidth(window.innerWidth);
    window.addEventListener("resize", handleResize);

    return () => window.removeEventListener("resize", handleResize);
  }, []);

  return width; // gibt Wert zurück
}

// Nutzung in einer Komponente
export default function App() {
  const width = useWindowWidth();

  return <p>Aktuelle Fensterbreite: {width}px</p>;
}
```

---

### Zusammenfassung

* **Custom Hook** = Funktion mit `use...`, die Hooks nutzt, um Logik wiederverwendbar zu machen.
* Vorteile: **Code-Wiederverwendung, bessere Lesbarkeit, klarere Trennung von Logik und UI**.
* Beispiel: `useWindowWidth`, `useFetch`, `useForm`.

📖 Weiterführend:

* [React Offizielle Dokumentation – Eigene Hooks](https://react.dev/learn/reusing-logic-with-custom-hooks)

---

  **[⬆ Наверх](#top)**

57. ### <a name="57"></a> Wie verhindert man eine Endlosschleife in useEffect?

### Endlosschleifen in `useEffect`

Eine Endlosschleife entsteht, wenn **State im Effect geändert** wird, ohne die Abhängigkeiten korrekt zu steuern → jeder State-Update löst erneut den Effect aus.

---

### Ursachen

1. **Fehlendes oder falsches Abhängigkeitsarray**

   ```jsx
   useEffect(() => {
     setCount(count + 1); // triggert bei jedem Render -> Endlosschleife
   }); // kein []
   ```

2. **Unnötige Abhängigkeiten**

   * Wenn Werte ins Array aufgenommen werden, die sich bei jedem Render ändern (z. B. Objekte/Funktionen).

---

### Lösungen

1. **Korrektes Abhängigkeitsarray nutzen**

   ```jsx
   useEffect(() => {
     fetchData();
   }, []); // nur beim ersten Mount
   ```

2. **Funktionsupdates für State nutzen**

   ```jsx
   useEffect(() => {
     const id = setInterval(() => {
       setCount(prev => prev + 1); // nutzt vorherigen Wert, vermeidet Endlosschleife
     }, 1000);

     return () => clearInterval(id);
   }, []);
   ```

3. **Memoization für Objekte/Funktionen**

   * `useMemo` oder `useCallback` nutzen, damit sich die Abhängigkeiten nicht bei jedem Render ändern.

   ```jsx
   const memoizedFn = useCallback(() => {
     console.log("Nur bei Bedarf neu erzeugt");
   }, []);

   useEffect(() => {
     memoizedFn();
   }, [memoizedFn]);
   ```

---

### Zusammenfassung

* Endlosschleifen entstehen durch **falsche oder fehlende Dependency Arrays** in `useEffect`.
* Lösung: korrektes Abhängigkeitsarray, funktionale Updates, Memoization (`useCallback`, `useMemo`).
* Grundregel: **nur echte Abhängigkeiten angeben** und Werte stabil halten.

📖 Weiterführend:

* [React Offizielle Dokumentation – useEffect](https://react.dev/reference/react/useEffect)

---

  **[⬆ Наверх](#top)**

58. ### <a name="58"></a> Wie implementiert man Timeout oder Interval mit Hooks?

### Timeout & Interval mit Hooks

In Funktionskomponenten werden **`setTimeout`** und **`setInterval`** zusammen mit `useEffect` und `useRef` genutzt. Wichtig: **Cleanup** im `useEffect` verhindert Speicherlecks.

---

### Timeout (`setTimeout`)

```jsx
import { useEffect, useState } from "react";

function TimeoutDemo() {
  const [message, setMessage] = useState("Warte...");

  useEffect(() => {
    const id = setTimeout(() => {
      setMessage("Fertig nach 3 Sekunden!");
    }, 3000);

    return () => clearTimeout(id); // Cleanup beim Unmount
  }, []);

  return <p>{message}</p>;
}

export default TimeoutDemo;
```

---

### Interval (`setInterval`)

```jsx
import { useEffect, useState } from "react";

function IntervalDemo() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const id = setInterval(() => {
      setCount(prev => prev + 1); // funktionales Update vermeidet Endlosschleife
    }, 1000);

    return () => clearInterval(id); // Cleanup beim Unmount
  }, []);

  return <p>Zähler: {count}</p>;
}

export default IntervalDemo;
```

---

### Zusammenfassung

* **Timeout**: `setTimeout` + `clearTimeout` in `useEffect`.
* **Interval**: `setInterval` + `clearInterval` in `useEffect`.
* Cleanup-Funktion verhindert Leaks und unerwünschte Effekte.
* Funktionale Updates (`prev => prev + 1`) sind wichtig, um Endlosschleifen zu vermeiden.

📖 Weiterführend:

* [React Offizielle Dokumentation – useEffect](https://react.dev/reference/react/useEffect)

---

  **[⬆ Наверх](#top)**

59. ### <a name="59"></a> 



  **[⬆ Наверх](#top)**

60. ### <a name="60"></a> 



  **[⬆ Наверх](#top)**

61. ### <a name="61"></a> Was ist ein Higher-Order Component (HOC)?

# Was ist ein Higher-Order Component (HOC)?

Ein **Higher-Order Component (HOC)** ist ein **Designmuster in React**,  
bei dem **eine Funktion eine Komponente nimmt und eine neue, erweiterte Komponente zurückgibt**.

---

## 🎯 Zweck eines HOC

- ✅ **Wiederverwendbare Logik** auf mehrere Komponenten anwenden  
- ✅ Komponenten **mit zusätzlichen Props, Verhalten oder Styling** erweitern  
- ✅ Trennung von Zuständigkeiten (Separation of Concerns)

---

## 📦 Definition

```js
const EnhancedComponent = withSomething(WrappedComponent);
```

➡️ `withSomething` ist das HOC, `WrappedComponent` ist die Originalkomponente.

---

## 💡 Einfaches Beispiel: `withLogger`

```jsx
function withLogger(WrappedComponent) {
  return function EnhancedComponent(props) {
    console.log('Props:', props);
    return <WrappedComponent {...props} />;
  };
}
```

### Verwendung:

```jsx
const LoggedButton = withLogger(Button);
```

➡️ Jedes Mal, wenn `LoggedButton` verwendet wird, werden die Props geloggt.

---

## 🔁 Typische Anwendungsfälle

- Zugriffsschutz (z. B. `withAuth`)
- Theming (z. B. `withTheme`)
- Logging & Analytics
- Fehlerbehandlung (`withErrorBoundary`)
- Datenanbindung (z. B. `connect()` in Redux)

---

## ⚠️ Hinweise

- HOCs **verändern nicht** die ursprüngliche Komponente, sondern **verpacken sie**
- HOC **dürfen keine Seiteneffekte beim Rendern haben**
- Der **Komponentenname sollte erhalten bleiben** (z. B. mit `displayName`), für Debugging

---

## 📝 Zusammenfassung

Ein **Higher-Order Component (HOC)** ist eine Funktion,  
die eine Komponente nimmt und **eine neue Komponente mit erweitertem Verhalten** zurückgibt.  
Sie ist ein mächtiges Werkzeug zur **Wiederverwendung von Logik und Struktur**.

---

## 🔗 Quellen

- [React Docs – Higher-Order Components](https://reactjs.org/docs/higher-order-components.html)  
- [MDN – React Komponentendesignmuster](https://developer.mozilla.org/de/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_components#higher-order-components)

  **[⬆ Наверх](#top)**

62. ### <a name="62"></a> Was ist das Render-Prop-Pattern?

# Was ist das Render-Prop-Pattern?

Das **Render-Prop-Pattern** ist ein **React-Designmuster**,  
bei dem eine Komponente eine **Funktion als Prop (render prop)** erhält,  
um **flexibel zu steuern, was gerendert werden soll**.

---

## 🎯 Zweck des Patterns

- ✅ Ermöglicht das **Teilen von wiederverwendbarer Logik**
- ✅ Gibt der Elternkomponente die **volle Kontrolle über das gerenderte UI**
- ✅ Alternative zu HOCs oder Hooks bei **logikbasiertem Code-Sharing**

---

## 📦 Struktur

```jsx
<MyComponent render={(data) => (
  <p>{data.message}</p>
)} />
```

Oder via `children`-Prop:

```jsx
<MyComponent>
  {(data) => <p>{data.message}</p>}
</MyComponent>
```

---

## 💡 Beispiel: `MouseTracker` mit Render-Prop

```jsx
function MouseTracker({ render }) {
  const [position, setPosition] = useState({ x: 0, y: 0 });

  useEffect(() => {
    const handleMove = (e) => setPosition({ x: e.clientX, y: e.clientY });
    window.addEventListener('mousemove', handleMove);
    return () => window.removeEventListener('mousemove', handleMove);
  }, []);

  return render(position);
}
```

### Verwendung:

```jsx
<MouseTracker
  render={({ x, y }) => (
    <p>Position: {x}, {y}</p>
  )}
/>
```

---

## 🔁 Vorteile gegenüber HOC

| Aspekt               | Render-Prop             | HOC                           |
|----------------------|-------------------------|--------------------------------|
| Mehrfach verwendbar  | ✅ Ja                   | ✅ Ja                          |
| Flexibel im UI       | ✅ Sehr flexibel         | ❌ Eingeschränkter UI-Zugriff |
| Komponentenbaum flach| ✅ Ja                   | ❌ Kann tiefe Wrapper erzeugen |

---

## ⚠️ Nachteile

- Kann bei vielen Ebenen zu **"Wrapper Hell"** führen (ähnlich wie HOC)
- Wird heute oft durch **Hooks ersetzt**, da diese **einfacher und lesbarer** sind

---

## 📝 Zusammenfassung

Das **Render-Prop-Pattern** ermöglicht das **Weitergeben von Logik über Funktionen als Props**.  
Die aufrufende Komponente entscheidet, **wie das UI aussehen soll**, während die Logik zentral bleibt.

---

## 🔗 Quellen

- [Render Props – React Docs](https://reactjs.org/docs/render-props.html)  
- [React Patterns – Render Props](https://reactpatterns.com/#render-callback)

  **[⬆ Наверх](#top)**

63. ### <a name="63"></a> Was ist die Context-API und wie funktioniert useContext?

# Was ist die Context-API und wie funktioniert `useContext`?

Die **Context-API** von React ist ein integrierter Mechanismus,  
um **globale Daten (z. B. Theme, Sprache, Benutzerinfos)**  
an beliebige Komponenten im Komponentenbaum **weiterzugeben**,  
**ohne Props manuell durch mehrere Ebenen zu reichen**.

---

## 🎯 Warum Context?

- ✅ Vermeidet **Prop-Drilling**  
- ✅ Ideal für **globale Zustände oder Konfigurationen**  
- ✅ Einfach zu kombinieren mit `useContext`

---

## 🧱 Bestandteile der Context-API

1. **`createContext()`** – erstellt einen neuen Kontext  
2. **`<Provider>`** – stellt einen Wert zur Verfügung  
3. **`useContext(Context)`** – liest den aktuellen Wert des Kontexts

---

## 💡 Beispiel: ThemeContext

### 1. Context erstellen:

```jsx
import { createContext } from 'react';

const ThemeContext = createContext('light'); // optionaler Default-Wert
```

---

### 2. Provider verwenden:

```jsx
function App() {
  return (
    <ThemeContext.Provider value="dark">
      <Toolbar />
    </ThemeContext.Provider>
  );
}
```

---

### 3. Zugriff mit `useContext`:

```jsx
import { useContext } from 'react';

function ThemeButton() {
  const theme = useContext(ThemeContext); // "dark"
  return <button className={theme}>Aktuelles Theme: {theme}</button>;
}
```

➡️ `ThemeButton` hat Zugriff auf den Kontextwert, ohne dass Props über `Toolbar` weitergegeben werden müssen.

---

## 📌 Wichtig zu wissen

- Jeder Context-Wert ist **nur innerhalb seines `<Provider>` sichtbar**  
- Komponenten werden **neu gerendert**, wenn sich der Context-Wert ändert  
- Context ist **nicht als globaler State-Ersatz für komplexe Logik** gedacht (→ besser: Redux, Zustand, etc.)

---

## 📝 Zusammenfassung

- Die **Context-API** erlaubt das **Teilen globaler Werte** im Komponentenbaum  
- Mit `useContext(Context)` kannst du in Funktionskomponenten **einfach auf diese Werte zugreifen**  
- Sie ist nützlich für Dinge wie **Themen, Sprache, Benutzerinfo, Feature-Flags**

---

## 🔗 Quellen

- [Context – React Docs](https://react.dev/learn/passing-data-deeply-with-context)  
- [useContext – React Docs](https://react.dev/reference/react/useContext)  
- [MDN: Context in React](https://developer.mozilla.org/de/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_components#context)

  **[⬆ Наверх](#top)**

64. ### <a name="64"></a> Was sind Portale in React?

# Was sind Portale in React?

**Portale** (engl. *Portals*) in React ermöglichen es, **Komponenten außerhalb der normalen DOM-Hierarchie**  
zu rendern – also **außerhalb des `div#root`**, aber trotzdem **vollständig von React verwaltet**.

---

## 🎯 Wann braucht man ein Portal?

- Modale Dialoge (z. B. `<Modal />`)  
- Tooltips  
- Dropdown-Menüs  
- Overlays  
- Elemente, die visuell **über anderen Komponenten liegen** müssen

➡️ Diese Elemente müssen oft **am Ende des `<body>`** gerendert werden, um korrekt zu funktionieren (z. B. Z-Index, Positionierung).

---

## 💡 Beispiel: Portal verwenden

### 1. Ziel-Element im HTML

```html
<body>
  <div id="root"></div>
  <div id="modal-root"></div> <!-- Hier wird das Portal platziert -->
</body>
```

---

### 2. Komponente mit Portal

```jsx
import { createPortal } from 'react-dom';

function Modal({ children }) {
  return createPortal(
    <div className="modal">{children}</div>,
    document.getElementById('modal-root')
  );
}
```

---

### 3. Verwendung in der App

```jsx
function App() {
  return (
    <>
      <h1>Seite</h1>
      <Modal>
        <p>Ich werde außerhalb von #root gerendert!</p>
      </Modal>
    </>
  );
}
```

➡️ Das Modal wird **optisch außerhalb** des Hauptbaums gerendert,  
aber **logisch bleibt es Teil von React** – inklusive Props, State, Events usw.

---

## 🔁 Vorteile von Portalen

| Vorteil                    | Beschreibung                                       |
|----------------------------|----------------------------------------------------|
| 🔄 Event-Bubbling bleibt   | Events funktionieren weiterhin wie gewohnt         |
| 🎯 Flexibles Layout        | Bessere Positionierung im DOM                      |
| 🔒 Kein CSS-Zusammenstoß   | Vermeidet Probleme mit `overflow: hidden`, `z-index` etc.

---

## 📝 Zusammenfassung

- Portale rendern Komponenten **außerhalb des DOM-Hierarchie der Eltern**
- Nützlich für **Modale, Tooltips, Overlays**
- Implementiert mit `ReactDOM.createPortal(element, domNode)`

---

## 🔗 Quellen

- [Portals – React Docs](https://reactjs.org/docs/portals.html)  
- [MDN: DOM-Portale und Modale](https://developer.mozilla.org/de/docs/Web/HTML/Element/dialog)

  **[⬆ Наверх](#top)**

65. ### <a name="65"></a> Was ist bedingtes Rendern (Conditional Rendering)?

# Was ist bedingtes Rendern (Conditional Rendering) in React?

**Bedingtes Rendern** bedeutet in React, dass eine Komponente **abhängig von einer Bedingung**  
**unterschiedlichen JSX-Inhalt rendert** – also **dynamisch entscheidet, was angezeigt wird**.

---

## 🎯 Anwendungsbeispiele

- Benutzer ist **eingeloggt oder nicht**
- Ladevorgang (`Loading...`) vs. Datenanzeige
- Verschiedene UI-Elemente abhängig von Status, Rollen, Berechtigungen

---

## 🔧 Methoden für bedingtes Rendern

### ✅ 1. `if`-Anweisung

```jsx
if (isLoggedIn) {
  return <Dashboard />;
} else {
  return <LoginForm />;
}
```

---

### ✅ 2. Ternärer Operator (`? :`)

```jsx
return (
  <div>
    {isLoading ? <p>Lade Daten...</p> : <DataList />}
  </div>
);
```

---

### ✅ 3. Logischer UND-Operator (`&&`)

```jsx
{hasPermission && <DeleteButton />}
```

➡️ Rendert `DeleteButton` **nur**, wenn `hasPermission === true` ist.

---

### ✅ 4. Optionales Rendering mit `null`

```jsx
{shouldShow ? <Component /> : null}
```

➡️ Wenn `shouldShow === false`, wird **gar nichts** gerendert.

---

## 📝 Zusammenfassung

**Conditional Rendering** bedeutet, dass JSX **dynamisch** auf Basis von Bedingungen  
**unterschiedlichen Inhalt rendert**.  
React unterstützt dafür mehrere Schreibweisen:  
`if`, `? :`, `&&`, Rückgabe von `null`.

---

## 🔗 Quellen

- [Conditional Rendering – React Docs](https://react.dev/learn/conditional-rendering)  
- [MDN: Bedingte Ausdrücke](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Operators/Conditional_Operator)

  **[⬆ Наверх](#top)**

66. ### <a name="66"></a> Was ist ein Error Boundary?

# Was ist ein Error Boundary in React?

Ein **Error Boundary** (Fehlergrenze) ist eine **spezielle React-Komponente**,  
die **JavaScript-Fehler** in ihrer **Kind-Komponenten-Hierarchie abfängt**,  
um zu verhindern, dass der **gesamte UI-Baum zusammenbricht**.

---

## 🎯 Zweck von Error Boundaries

- ✅ Fehler im UI **abfangen**, anzeigen und kontrolliert behandeln  
- ✅ Verhindert den **Absturz der gesamten App**  
- ✅ Zeigt stattdessen **Fallback-UI** oder eine Fehlermeldung an

---

## 📦 Wann tritt ein Fehler auf?

Error Boundaries fangen **nur Fehler während des Renderns**,  
in **Lifecycle-Methoden** und in **Konstruktoren von Klassenkomponenten** ab.

**Nicht abgefangen werden**:
- Fehler in Event-Handlern (diese müssen manuell mit `try/catch` behandelt werden)
- Fehler in `async`-Funktionen
- Fehler außerhalb des React-Baums

---

## 💡 Beispiel: Error Boundary (Klassenkomponente)

```jsx
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, info) {
    console.error('Fehler abgefangen:', error, info);
  }

  render() {
    if (this.state.hasError) {
      return <h2>Etwas ist schiefgelaufen.</h2>;
    }

    return this.props.children;
  }
}
```

---

### ✅ Verwendung:

```jsx
<ErrorBoundary>
  <ProblematicComponent />
</ErrorBoundary>
```

➡️ Wenn `ProblematicComponent` crasht, zeigt `ErrorBoundary` stattdessen die Fallback-UI.

---

## 🧪 Wann verwenden?

- Um Teile der App **abzusichern** (z. B. Seitenbereiche, Widgets)
- Um **Logs zu erfassen** (`componentDidCatch`)
- Um den Nutzer bei Fehlern **nicht allein zu lassen**

---

## 📝 Zusammenfassung

Ein **Error Boundary** ist eine **Klassenkomponente**,  
die Fehler in der React-Komponentenstruktur **abfängt und behandelt**,  
ohne dass die ganze App abstürzt.  
Sie bietet eine **Fallback-UI** und hilft bei **Debugging & Stabilität**.

---

## 🔗 Quellen

- [Error Boundaries – React Docs](https://react.dev/learn/managing-errors)  
- [MDN: Fehlerbehandlung in React](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch#handling_errors_in_react)

  **[⬆ Наверх](#top)**

67. ### <a name="67"></a> Wie funktioniert Event-Handling in React?

# Wie funktioniert Event-Handling in React?

**Event-Handling** in React funktioniert ähnlich wie in HTML/JavaScript,  
aber mit einigen **Unterschieden in Syntax und Verhalten**.

---

## 🎯 Besonderheiten in React

- React verwendet **camelCase** statt Kleinschreibung:
  - `onClick` statt `onclick`
- Event-Handler werden als **Funktionen (nicht Strings)** übergeben:
  - `{handleClick}` statt `"handleClick()"`

---

## 💡 Beispiel: Klick-Event

```jsx
function Button() {
  function handleClick() {
    alert('Button wurde geklickt!');
  }

  return <button onClick={handleClick}>Klicken</button>;
}
```

---

## 📦 Event-Objekt

React stellt ein **synthetisches Event-Objekt** (`SyntheticEvent`) bereit,  
das mit allen Browsern konsistent funktioniert.

```jsx
function Input() {
  function handleChange(e) {
    console.log('Eingegeben:', e.target.value);
  }

  return <input onChange={handleChange} />;
}
```

➡️ `e` ist das SyntheticEvent, das sich **ähnlich wie ein native DOM-Event** verhält.

---

## 🔁 Weitere Event-Beispiele

| Event         | Attribut        | Beispiel                           |
|---------------|------------------|------------------------------------|
| Klick         | `onClick`        | `<button onClick={fn} />`          |
| Eingabe       | `onChange`       | `<input onChange={fn} />`          |
| Fokus         | `onFocus`        | `<input onFocus={fn} />`           |
| Maus bewegen  | `onMouseMove`    | `<div onMouseMove={fn} />`         |
| Formular      | `onSubmit`       | `<form onSubmit={fn} />`           |
| Taste drücken | `onKeyDown`      | `<input onKeyDown={fn} />`         |

---

## ✅ Standardverhalten verhindern

```jsx
function Form() {
  function handleSubmit(e) {
    e.preventDefault(); // verhindert Seitenreload
    console.log('Formular abgesendet');
  }

  return <form onSubmit={handleSubmit}>...</form>;
}
```

---

## 📝 Zusammenfassung

- React verwendet eigene Events (`SyntheticEvent`) mit vertrauter API  
- Event-Handler werden als Funktionen mit camelCase geschrieben  
- Du kannst Standardverhalten (z. B. Form-Submit) mit `e.preventDefault()` unterdrücken

---

## 🔗 Quellen

- [Events in React – React Docs](https://react.dev/learn/responding-to-events)  
- [React Event Handling – MDN](https://developer.mozilla.org/en-US/docs/Web/Events)

  **[⬆ Наверх](#top)**

68. ### <a name="68"></a> Was ist ein synthetisches Ereignis (SyntheticEvent)?

# Was ist ein synthetisches Ereignis (SyntheticEvent) in React?

Ein **synthetisches Ereignis** (`SyntheticEvent`) ist ein von React bereitgestelltes **plattformsicheres Wrapper-Objekt**  
für native DOM-Ereignisse wie `click`, `change`, `submit`, etc.

---

## 🎯 Zweck von `SyntheticEvent`

- ✅ Einheitliches Verhalten in **allen Browsern**
- ✅ Automatisches **Event-Pooling** (früher)
- ✅ Konsistente API für alle Event-Typen
- ✅ Kombiniert die Vorteile von DOM- und Custom-Events

---

## 📦 Eigenschaften

- `SyntheticEvent` hat die **gleichen Methoden und Eigenschaften** wie ein normales DOM-Event:  
  - `e.target`, `e.preventDefault()`, `e.stopPropagation()` usw.
- Funktioniert für **alle Event-Typen**: Maus, Tastatur, Formulare, Fokus, usw.

---

## 💡 Beispiel

```jsx
function Form() {
  function handleSubmit(e) {
    e.preventDefault(); // verhindert Reload
    console.log('Eingabefeld:', e.target.elements.name.value);
  }

  return (
    <form onSubmit={handleSubmit}>
      <input name="name" />
      <button type="submit">Absenden</button>
    </form>
  );
}
```

➡️ `e` ist ein `SyntheticEvent`, nicht das native `Event`-Objekt des Browsers.

---

## ⚠️ Hinweis: Event-Pooling (früher)

Früher wurden `SyntheticEvent`-Objekte **recycelt** (Event Pooling), was bedeutete:  
Zugriff auf das Event nach dem Event-Handler war **nicht mehr möglich**.  
**Seit React 17+ ist Pooling deaktiviert.**

---

## 📝 Zusammenfassung

Ein `SyntheticEvent` ist Reacts **einheitliche Event-API**,  
die unabhängig vom Browser funktioniert und dieselbe Oberfläche wie das native DOM-Event bietet.  
Du kannst es wie gewohnt verwenden (`e.preventDefault()`, `e.target.value`, etc.).

---

## 🔗 Quellen

- [React Docs – SyntheticEvent](https://react.dev/reference/react-dom/SyntheticEvent)  
- [MDN: DOM Events Übersicht](https://developer.mozilla.org/de/docs/Web/Events)

  **[⬆ Наверх](#top)**

69. ### <a name="69"></a> Was ist props.children?

# Was ist `props.children` in React?

**`props.children`** ist eine spezielle React-Prop,  
die automatisch alle **verschachtelten Elemente (Child-Komponenten oder JSX-Inhalte)** enthält,  
die **innerhalb einer Komponente übergeben** werden.

---

## 🎯 Wozu wird `props.children` verwendet?

- ✅ Um **dynamisch Inhalte zu rendern**, die von außen übergeben werden  
- ✅ Um **Wrapper-Komponenten** (z. B. Layouts, Container) zu erstellen  
- ✅ Für **wiederverwendbare UI-Strukturen**

---

## 💡 Beispiel

```jsx
function Card(props) {
  return <div className="card">{props.children}</div>;
}

function App() {
  return (
    <Card>
      <h2>Titel</h2>
      <p>Das ist der Inhalt der Card.</p>
    </Card>
  );
}
```

➡️ Die `Card`-Komponente erhält:

```jsx
<h2>...</h2>
<p>...</p>
```

als `props.children` und rendert sie **im Inneren**.

---

## 📦 Typen von `props.children`

- Kann ein **Element**, ein **Text**, ein **Array**, `null`, `undefined` oder ein **Fragment** sein
- Du kannst `children` auch **prüfen oder filtern**, z. B. mit `React.Children`

---

## 🧪 Beispiel mit mehreren Kindern

```jsx
function Wrapper({ children }) {
  return (
    <section>
      {React.Children.map(children, (child, index) => (
        <div key={index}>{child}</div>
      ))}
    </section>
  );
}
```

➡️ So kannst du **alle `children` gezielt verarbeiten**.

---

## 📝 Zusammenfassung

- `props.children` enthält **alle JSX-Inhalte**, die **zwischen den Tags** einer Komponente übergeben werden  
- Es macht Komponenten **flexibel und wiederverwendbar**
- Typisch bei Layout-Komponenten, Dialogen, Containern

---

## 🔗 Quellen

- [React Docs – Children](https://react.dev/learn/passing-props-to-a-component#using-the-children-prop)  
- [React.Children API – React Docs](https://react.dev/reference/react/Children)

  **[⬆ Наверх](#top)**

70. ### <a name="70"></a> Was bedeutet „controlled component“ und „uncontrolled component“ bei Formularen?

# Was bedeutet „controlled component“ und „uncontrolled component“ bei Formularen in React?

In React beschreibt man Formular-Elemente wie `<input>`, `<textarea>` oder `<select>` als  
**controlled** oder **uncontrolled**, je nachdem, **wie ihr Wert verwaltet wird**.

---

## ✅ Controlled Component

Ein **controlled component** wird **vollständig durch React kontrolliert** –  
der Wert kommt aus dem **State** und wird über `onChange` aktualisiert.

### Eigenschaften:

- Wert liegt im React-State
- Änderungen erfolgen über `setState` / `useState`
- Ideal für Validierung, dynamische Formulare, zentrale Kontrolle

### Beispiel:

```jsx
function Form() {
  const [name, setName] = useState('');

  return (
    <input 
      value={name}
      onChange={(e) => setName(e.target.value)}
    />
  );
}
```

➡️ Das Eingabefeld zeigt **immer den aktuellen State-Wert**.

---

## ❌ Uncontrolled Component

Ein **uncontrolled component** verwaltet seinen Wert **intern im DOM**,  
React **greift nur über ein Ref** darauf zu – z. B. beim Absenden des Formulars.

### Eigenschaften:

- Kein React-State für den Wert
- Zugriff über `ref`
- Einfach, aber schwerer zu validieren

### Beispiel:

```jsx
function Form() {
  const inputRef = useRef();

  const handleSubmit = (e) => {
    e.preventDefault();
    alert(inputRef.current.value);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input ref={inputRef} />
      <button type="submit">Absenden</button>
    </form>
  );
}
```

➡️ Der Wert wird **nicht in React gespeichert**, sondern **aus dem DOM gelesen**.

---

## 🔁 Vergleich

| Merkmal              | Controlled                   | Uncontrolled                    |
|----------------------|------------------------------|----------------------------------|
| Datenquelle          | React-State (`useState`)     | DOM (intern)                     |
| Zugriff              | `value` + `onChange`         | `ref.current.value`              |
| Validierung          | Einfach                      | Komplizierter                    |
| Flexibilität         | Hoch                         | Gering                           |
| Initialwert          | via State                    | via `defaultValue`               |

---

## 📝 Zusammenfassung

- **Controlled Components**: React verwaltet den Formularwert → vollständig kontrollierbar
- **Uncontrolled Components**: Der Browser verwaltet den Wert → Zugriff nur über Ref
- Controlled ist der **empfohlene Standard**, besonders bei komplexen Formularen

---

## 🔗 Quellen

- [Controlled Components – React Docs](https://react.dev/learn/sharing-state-between-components#controlled-and-uncontrolled-components)  
- [Formulare in React – MDN](https://developer.mozilla.org/de/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_forms)

  **[⬆ Наверх](#top)**

71. ### <a name="71"></a> 



  **[⬆ Наверх](#top)**

72. ### <a name="72"></a> 



  **[⬆ Наверх](#top)**

73. ### <a name="73"></a> 



  **[⬆ Наверх](#top)**

74. ### <a name="74"></a> 



  **[⬆ Наверх](#top)**

75. ### <a name="75"></a> 



  **[⬆ Наверх](#top)**

76. ### <a name="76"></a> Wie führt man API-Aufrufe mit Fetch oder Axios durch?

# Wie führt man API-Aufrufe mit `fetch` oder `axios` in React durch?

In React kannst du API-Anfragen auf zwei gängige Arten durchführen:

1. Mit dem **integrierten `fetch`-API** (nativ in JavaScript)
2. Mit der **Axios-Bibliothek** (komfortabler, aber extern)

---

## ✅ 1. API-Aufruf mit `fetch`

```jsx
import { useEffect, useState } from 'react';

function UserList() {
  const [users, setUsers] = useState([]);
  const [error, setError] = useState(null);

  useEffect(() => {
    fetch('https://jsonplaceholder.typicode.com/users')
      .then((res) => {
        if (!res.ok) throw new Error('Fehler beim Laden');
        return res.json();
      })
      .then((data) => setUsers(data))
      .catch((err) => setError(err.message));
  }, []);

  if (error) return <p>Fehler: {error}</p>;
  return (
    <ul>
      {users.map((u) => (
        <li key={u.id}>{u.name}</li>
      ))}
    </ul>
  );
}
```

---

## ✅ 2. API-Aufruf mit `axios`

### Installation:

```bash
npm install axios
```

### Verwendung:

```jsx
import axios from 'axios';
import { useEffect, useState } from 'react';

function PostList() {
  const [posts, setPosts] = useState([]);
  const [error, setError] = useState(null);

  useEffect(() => {
    axios
      .get('https://jsonplaceholder.typicode.com/posts')
      .then((res) => setPosts(res.data))
      .catch((err) => setError(err.message));
  }, []);

  if (error) return <p>Fehler: {error}</p>;
  return (
    <ul>
      {posts.map((p) => (
        <li key={p.id}>{p.title}</li>
      ))}
    </ul>
  );
}
```

---

## 🔁 Vergleich: `fetch` vs. `axios`

| Merkmal             | `fetch` (nativ)              | `axios` (Bibliothek)             |
|---------------------|------------------------------|----------------------------------|
| Integriert in JS?   | ✅ Ja                         | ❌ Nein (muss installiert werden) |
| JSON automatisch?   | ❌ Nein (manuell: `.json()`) | ✅ Ja (direkt `res.data`)         |
| Fehlerbehandlung    | Manuell mit `res.ok` prüfen  | Automatisch bei HTTP-Fehler      |
| Unterstützt Abbrechen | ❌ Nur mit AbortController | ✅ Ja                             |

---

## 📝 Zusammenfassung

- Mit `fetch` und `axios` kannst du in `useEffect` **API-Daten laden**
- `fetch`: nativ, minimalistisch  
- `axios`: komfortabler, bessere Fehlerbehandlung  
- Immer Fehler abfangen (`.catch`) und Zustand (`loading`, `error`, `data`) verwalten

---

## 🔗 Quellen

- [fetch – MDN Web Docs](https://developer.mozilla.org/de/docs/Web/API/Fetch_API)
- [Axios – GitHub Docs](https://axios-http.com/docs/intro)
- [Daten in React laden – React Docs](https://react.dev/learn/you-might-not-need-an-effect#fetching-data)

  **[⬆ Наверх](#top)**

77. ### <a name="77"></a> Wie verwaltet man Lade-, Fehler- und Erfolgsstatus?

# Wie verwaltet man Lade-, Fehler- und Erfolgsstatus in React?

Beim **Abrufen von Daten (API)** ist es wichtig, den **Status** der Anfrage zu verwalten:

1. 🔄 **Ladezustand** (`isLoading`)
2. ✅ **Erfolgszustand** (Daten verfügbar)
3. ❌ **Fehlerzustand** (Fehler beim Laden)

Diese drei Zustände werden meist mit **`useState` und `useEffect`** verwaltet.

---

## 💡 Beispiel mit `fetch`

```jsx
import { useState, useEffect } from 'react';

function UserList() {
  const [users, setUsers] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    fetch('https://jsonplaceholder.typicode.com/users')
      .then((res) => {
        if (!res.ok) throw new Error('Fehler beim Laden');
        return res.json();
      })
      .then((data) => {
        setUsers(data);
        setError(null);
      })
      .catch((err) => setError(err.message))
      .finally(() => setIsLoading(false));
  }, []);

  if (isLoading) return <p>⏳ Lade Daten...</p>;
  if (error) return <p>❌ Fehler: {error}</p>;

  return (
    <ul>
      {users.map((user) => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

---

## ✅ Statusverwaltung im Überblick

| Zustand     | Variable     | Bedeutung                                 |
|-------------|--------------|--------------------------------------------|
| Ladezustand | `isLoading`  | Wird `true` beim Start der Anfrage         |
| Erfolgsdaten| `data`, `users`, etc. | Wird nach erfolgreichem Laden gesetzt |
| Fehlerzustand| `error`     | Wird gesetzt, wenn `.catch()` ausgelöst wird |

---

## 🔄 Alternativen

- Eigener **Custom Hook** (`useFetch`, `useApi`)
- **State Machine** (z. B. mit `xstate`)
- Zustand mit `useReducer` verwalten, wenn komplexer

---

## 📝 Zusammenfassung

- Nutze `useState` für `isLoading`, `error` und `data`
- Nutze `useEffect`, um Daten zu laden
- Zeige je nach Zustand: Ladeanzeige, Fehlernachricht oder Daten

---

## 🔗 Quellen

- [React: API-Daten laden – react.dev](https://react.dev/learn/you-might-not-need-an-effect#fetching-data)  
- [fetch API – MDN Docs](https://developer.mozilla.org/de/docs/Web/API/Fetch_API)

  **[⬆ Наверх](#top)**

78. ### <a name="78"></a> Wie funktioniert WebSocket mit React?

# Wie funktioniert WebSocket mit React?

**WebSockets** ermöglichen eine **bidirektionale, permanente Verbindung** zwischen Client (Browser) und Server.  
In React kannst du damit **Echtzeit-Daten** verarbeiten – z. B. für Chats, Benachrichtigungen oder Live-Dashboards.

---

## 🔄 Grundprinzip WebSocket

1. Verbindung zum Server aufbauen
2. Nachrichten senden & empfangen
3. Verbindung schließen (bei Unmount oder Fehler)

---

## 💡 Beispiel: WebSocket in React verwenden

```jsx
import { useEffect, useRef, useState } from 'react';

function WebSocketComponent() {
  const socketRef = useRef(null);
  const [messages, setMessages] = useState([]);

  useEffect(() => {
    // 1. Verbindung aufbauen
    socketRef.current = new WebSocket('wss://example.com/socket');

    // 2. Nachricht empfangen
    socketRef.current.onmessage = (event) => {
      setMessages((prev) => [...prev, event.data]);
    };

    // 3. Fehlerbehandlung
    socketRef.current.onerror = (err) => {
      console.error('WebSocket-Fehler:', err);
    };

    // 4. Aufräumen beim Unmount
    return () => {
      socketRef.current.close();
    };
  }, []);

  // Nachricht senden (z. B. beim Button-Klick)
  const sendMessage = () => {
    if (socketRef.current.readyState === WebSocket.OPEN) {
      socketRef.current.send('Hallo vom Client!');
    }
  };

  return (
    <div>
      <h3>Empfangene Nachrichten:</h3>
      <ul>
        {messages.map((msg, i) => (
          <li key={i}>{msg}</li>
        ))}
      </ul>
      <button onClick={sendMessage}>Nachricht senden</button>
    </div>
  );
}
```

---

## 🔁 Tipps für den produktiven Einsatz

- Nutze `useRef`, damit WebSocket-Verbindung **nicht bei jedem Render neu aufgebaut** wird  
- Prüfe `socket.readyState`, bevor du Nachrichten sendest  
- Verwende ggf. **Reconnect-Strategien**, falls Verbindung abbricht  
- Für große Projekte: verwalte WebSocket über `Context` oder `Redux`

---

## 📝 Zusammenfassung

- WebSocket bietet eine **dauerhafte Verbindung** zwischen React-Client und Server  
- Ideal für **Live-Kommunikation** (Chat, Echtzeitdaten)  
- In React: mit `useEffect`, `useRef` und `setState` kombinieren  
- Nicht vergessen: **Verbindung schließen** bei Unmount

---

## 🔗 Quellen

- [MDN: WebSocket API](https://developer.mozilla.org/de/docs/Web/API/WebSocket)  
- [React + WebSocket Guide – LogRocket](https://blog.logrocket.com/using-websocket-react-guide/)

  **[⬆ Наверх](#top)**

79. ### <a name="79"></a> Wie kann man Daten zwischen Komponenten weitergeben?

# Wie kann man Daten zwischen Komponenten weitergeben?

In React gibt es mehrere Wege, **Daten zwischen Komponenten** auszutauschen.  
Welcher Weg sinnvoll ist, hängt davon ab, **wie die Komponenten zueinander stehen**.

---

## 1️⃣ Parent → Child: via **Props**

Der klassische und einfachste Weg:  
Elternkomponente übergibt Daten an Kindkomponente als `props`.

```jsx
function Child({ username }) {
  return <p>Hallo, {username}!</p>;
}

function Parent() {
  return <Child username="Sergii" />;
}
```

➡️ Einfache, **unidirektionale Datenweitergabe**.

---

## 2️⃣ Child → Parent: via **Callback-Funktion als Prop**

Kindkomponente ruft eine Funktion auf, die der Elternkomponente gehört.

```jsx
function Child({ onNameChange }) {
  return <input onChange={(e) => onNameChange(e.target.value)} />;
}

function Parent() {
  const [name, setName] = useState('');
  return (
    <>
      <Child onNameChange={setName} />
      <p>Name: {name}</p>
    </>
  );
}
```

➡️ **"Lifting State Up"**: Eltern verwalten den Zustand.

---

## 3️⃣ Geschwister-Komponenten (Sibling → Sibling): via **gemeinsamen Eltern-State**

Beide Kinder greifen auf den **Zustand in der Elternkomponente** zu.

```jsx
function Input({ onChange }) {
  return <input onChange={(e) => onChange(e.target.value)} />;
}

function Display({ value }) {
  return <p>Wert: {value}</p>;
}

function Parent() {
  const [text, setText] = useState('');
  return (
    <>
      <Input onChange={setText} />
      <Display value={text} />
    </>
  );
}
```

---

## 4️⃣ Tief verschachtelte Komponenten: via **Context API**

Nutze `createContext`, `Provider` und `useContext`,  
um Daten **global im Baum** verfügbar zu machen.

```jsx
const ThemeContext = createContext();

function App() {
  return (
    <ThemeContext.Provider value="dark">
      <DeepChild />
    </ThemeContext.Provider>
  );
}

function DeepChild() {
  const theme = useContext(ThemeContext);
  return <p>Aktuelles Theme: {theme}</p>;
}
```

---

## 5️⃣ App-weite Zustände: via **State-Management** (z. B. Redux, Zustand)

Für sehr große Apps oder komplexe Interaktionen.

```jsx
// Redux: useSelector, useDispatch
// Zustand: useStore()
// Recoil, Jotai, MobX = Alternativen
```

---

## 📝 Zusammenfassung

| Beziehung          | Lösung                         |
|--------------------|---------------------------------|
| Eltern → Kind      | Props                          |
| Kind → Eltern      | Callback-Funktion als Prop     |
| Geschwister        | Gemeinsamer Eltern-State       |
| Tief verschachtelt | Context API                    |
| Global             | State-Management-Library       |

---

## 🔗 Quellen

- [React – Props](https://react.dev/learn/passing-props-to-a-component)  
- [React – State Heben](https://react.dev/learn/sharing-state-between-components)  
- [React – Context API](https://react.dev/learn/passing-data-deeply-with-context)

  **[⬆ Наверх](#top)**

80. ### <a name="80"></a> Wie macht man einen Datenabruf nur beim ersten Rendern?

# Wie macht man einen Datenabruf nur beim ersten Rendern in React?

Um eine API-Anfrage **nur einmal beim ersten Laden der Komponente** durchzuführen,  
nutzt man den Hook **`useEffect` mit leerem Abhängigkeits-Array `[]`**.

---

## 💡 Beispiel: API-Fetch beim Mount

```jsx
import { useEffect, useState } from 'react';

function UserList() {
  const [users, setUsers] = useState([]);

  useEffect(() => {
    fetch('https://jsonplaceholder.typicode.com/users')
      .then((res) => res.json())
      .then((data) => setUsers(data));
  }, []); // ← nur beim ersten Rendern!

  return (
    <ul>
      {users.map((u) => (
        <li key={u.id}>{u.name}</li>
      ))}
    </ul>
  );
}
```

---

## 📌 Erklärung

- Das leere Array `[]` bedeutet:  
  **Dieser Effekt läuft nur einmal – beim ersten Rendern (Mount)**.
- Keine erneute Ausführung bei Re-Renders oder State-Änderungen

---

## 🔁 Alternative: Async-Funktion in `useEffect`

Da `useEffect` keine `async`-Funktion direkt erlaubt:

```jsx
useEffect(() => {
  async function fetchData() {
    const res = await fetch('...');
    const data = await res.json();
    setUsers(data);
  }

  fetchData();
}, []);
```

---

## 📝 Zusammenfassung

- Verwende `useEffect(() => { ... }, [])`, um einen Effekt **nur einmal beim ersten Rendern** auszuführen  
- Ideal für **API-Anfragen, Initialdaten oder Setup-Logik**  
- Async-Aufrufe müssen in eine **innere Funktion** ausgelagert werden

---

## 🔗 Quellen

- [React Docs – useEffect](https://react.dev/reference/react/useEffect)  
- [Daten beim Mount laden – React Patterns](https://reactpatterns.com/#fetch-on-mount)

  **[⬆ Наверх](#top)**  

81. ### <a name="81"></a> Was ist das Problem bei „stale closures“ mit Hooks?

# Was ist das Problem bei „stale closures“ mit Hooks?

Ein **„stale closure“** (veraltete Funktionseinbettung) tritt auf,  
wenn eine **Funktion in einem Hook (z. B. `useEffect`, `setInterval`, `addEventListener`)**  
auf **einen veralteten Wert aus dem vorherigen Render** zugreift.

---

## 📦 Was ist eine Closure?

Eine **Closure** ist eine Funktion, die Zugriff auf Variablen aus dem **Umgebungskontext** (z. B. vorherigem Render) hat.

Wenn ein Hook eine Funktion verwendet, „merkt“ sich diese Funktion **den Zustand des Wertes zu diesem Zeitpunkt**.

---

## 💡 Beispiel: Problem mit `setInterval`

```jsx
function Timer() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const id = setInterval(() => {
      setCount(count + 1); // ❌ count ist immer 0!
    }, 1000);

    return () => clearInterval(id);
  }, []);
  
  return <p>Zähler: {count}</p>;
}
```

### 🔴 Problem:

- Die `count`-Variable ist **eingefroren (stale)** bei `0`, weil `useEffect` nur **einmal** ausgeführt wird
- Der Callback in `setInterval` „sieht“ nie die neuen `count`-Werte

---

## ✅ Lösung 1: Funktionales `setState`

```jsx
setCount((prev) => prev + 1);
```

```jsx
useEffect(() => {
  const id = setInterval(() => {
    setCount((prev) => prev + 1); // ✅ aktueller Wert
  }, 1000);

  return () => clearInterval(id);
}, []);
```

➡️ `prev` wird **zur aktuellen Version** von `count`, unabhängig vom Closure

---

## ✅ Lösung 2: useRef für aktuelle Werte

```jsx
const countRef = useRef(count);

useEffect(() => {
  countRef.current = count;
}, [count]);

useEffect(() => {
  const id = setInterval(() => {
    console.log(countRef.current); // immer aktuell
  }, 1000);

  return () => clearInterval(id);
}, []);
```

➡️ `useRef` bleibt **zwischen Renders gleich** und kann **aktualisiert** werden.

---

## 📝 Zusammenfassung

- Ein **stale closure** tritt auf, wenn eine Funktion auf **veraltete Werte** zugreift  
- Typisch bei: `setInterval`, `useEffect`, Event-Handlern  
- Lösungen:
  - ✅ Funktionales `setState`
  - ✅ `useRef` zur Speicherung aktueller Werte

---

## 🔗 Quellen

- [React Docs – useEffect Gotchas](https://react.dev/learn/synchronizing-with-effects#you-might-see-stale-values-inside-an-effect)  
- [Dan Abramov – A Complete Guide to useEffect](https://overreacted.io/a-complete-guide-to-useeffect/)

  **[⬆ Наверх](#top)**

82. ### <a name="82"></a> Wie funktioniert die Fehlerbehandlung mit try/catch in React?

# Wie funktioniert die Fehlerbehandlung mit `try/catch` in React?

In React wird `try/catch` verwendet, um **synchronen und asynchronen Code** innerhalb von Funktionen  
(z. B. Event-Handlern, `async`-Funktionen) **gezielt abzusichern**.

⚠️ `try/catch` funktioniert **nicht für Renderfehler** in JSX – dafür benötigt man **Error Boundaries**.

---

## ✅ Verwendung in Event-Handlern

```jsx
function Button() {
  const handleClick = () => {
    try {
      // synchroner Fehler
      throw new Error('Etwas ist schiefgelaufen!');
    } catch (err) {
      console.error('Fehler:', err.message);
    }
  };

  return <button onClick={handleClick}>Klick mich</button>;
}
```

---

## ✅ Verwendung in `async`-Funktionen (z. B. Daten laden)

```jsx
function DataLoader() {
  const [data, setData] = useState(null);
  const [error, setError] = useState(null);

  useEffect(() => {
    async function fetchData() {
      try {
        const res = await fetch('https://api.example.com/data');
        if (!res.ok) throw new Error('Fehler beim Abrufen');
        const json = await res.json();
        setData(json);
      } catch (err) {
        setError(err.message);
      }
    }

    fetchData();
  }, []);

  if (error) return <p>❌ Fehler: {error}</p>;
  if (!data) return <p>⏳ Lädt...</p>;
  return <pre>{JSON.stringify(data, null, 2)}</pre>;
}
```

---

## 🔴 Kein `try/catch` für Renderfehler

```jsx
function App() {
  try {
    return <ProblematicComponent />; // ❌ try/catch greift hier nicht
  } catch (e) {
    return <p>Fehler!</p>; // ❌ wird nicht erreicht
  }
}
```

➡️ React rendert **asynchron**, deshalb **fangen Error Boundaries** solche Fehler ab, nicht `try/catch`.

---

## 📝 Zusammenfassung

| Fehlerquelle      | `try/catch` geeignet? | Alternative                     |
|------------------|------------------------|---------------------------------|
| Event-Handler     | ✅ Ja                  | —                               |
| `async`-Funktionen| ✅ Ja                  | —                               |
| Renderzeit (JSX)  | ❌ Nein                | ❗ `ErrorBoundary` verwenden     |

---

## 🔗 Quellen

- [React Docs – Fehlerbehandlung](https://react.dev/learn/managing-errors)  
- [MDN – try...catch](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Statements/try...catch)

  **[⬆ Наверх](#top)**

83. ### <a name="83"></a> Wie kann man ein Mock-API oder Mock Server verwenden?

# Wie kann man ein Mock-API oder Mock Server in React verwenden?

Ein **Mock-API** oder **Mock-Server** simuliert eine echte Backend-API,  
um die Entwicklung und das Testen von Frontend-Komponenten zu ermöglichen –  
ohne auf ein echtes Backend warten zu müssen.

---

## 🎯 Vorteile

- Unabhängige Entwicklung von Frontend und Backend
- Offline arbeiten möglich
- Schnelleres Testen von UI-Logik
- Kontrolle über Antwortdaten, Fehler, Ladezeiten

---

## ✅ Möglichkeiten für Mocking

### 1️⃣ **JSON Server (lokal)**

Schneller REST-API-Mock über eine JSON-Datei.

#### 🔧 Installation:

```bash
npm install -g json-server
```

#### 📁 `db.json`

```json
{
  "users": [
    { "id": 1, "name": "Alice" },
    { "id": 2, "name": "Bob" }
  ]
}
```

#### 🚀 Starten:

```bash
json-server --watch db.json --port 4000
```

➡️ API verfügbar unter `http://localhost:4000/users`

---

### 2️⃣ **Mock Service Worker (MSW)** – empfohlen für komplexe Szenarien

Interceptet echte Requests auf Netzwerkebene → realistisch & flexibel.

#### 🔧 Installation:

```bash
npm install msw --save-dev
```

#### 📁 Beispiel-Handler:

```js
// src/mocks/handlers.js
import { rest } from 'msw';

export const handlers = [
  rest.get('/api/users', (req, res, ctx) => {
    return res(
      ctx.status(200),
      ctx.json([{ id: 1, name: 'Sergii' }, { id: 2, name: 'Anna' }])
    );
  }),
];
```

#### 🧩 Setup:

```js
// src/mocks/browser.js
import { setupWorker } from 'msw';
import { handlers } from './handlers';

export const worker = setupWorker(...handlers);
```

```js
// index.js
if (process.env.NODE_ENV === 'development') {
  const { worker } = require('./mocks/browser');
  worker.start();
}
```

---

### 3️⃣ **Online-Tools / öffentliche APIs**

- [https://reqres.in](https://reqres.in)
- [https://jsonplaceholder.typicode.com](https://jsonplaceholder.typicode.com)
- [https://mockapi.io](https://mockapi.io)

➡️ Gut für schnelles Testen ohne lokale Einrichtung

---

## 📝 Zusammenfassung

| Methode         | Geeignet für                  | Vorteile                    |
|------------------|-------------------------------|-----------------------------|
| `json-server`    | Lokale Fake-REST-API          | Schnell, einfach            |
| `msw`            | Realistisches Mocking (XHR)   | Sehr mächtig, intercepts    |
| `mockapi.io`     | Online-Testing                | Kein Setup nötig            |

---

## 🔗 Quellen

- [Mock Service Worker – offizielle Website](https://mswjs.io)  
- [JSON Server – GitHub](https://github.com/typicode/json-server)  
- [jsonplaceholder – Fake API](https://jsonplaceholder.typicode.com)

  **[⬆ Наверх](#top)**

84. ### <a name="84"></a> Wie funktioniert Suspense für Datenabfragen?

# Wie funktioniert `React.Suspense` für Datenabfragen?

`React.Suspense` erlaubt es, **asynchrone Datenladevorgänge** elegant zu behandeln,  
indem eine **Fallback-UI** (z. B. Ladeanzeige) angezeigt wird,  
solange **komponentenabhängige Daten noch nicht verfügbar** sind.

---

## ⚠️ Wichtig:

- Suspense für Daten funktioniert **nur mit speziellen Data Fetching Libraries**, z. B.:
  - **React Query (TanStack Query)**
  - **Relay**
  - oder man schreibt einen eigenen **Wrapper mit `Promise`-suspending**

---

## ✅ Beispiel mit React Query (empfohlener Weg)

### 🔧 Setup:

```bash
npm install @tanstack/react-query
```

### 📦 App mit QueryClient + Suspense:

```jsx
import {
  QueryClient,
  QueryClientProvider,
  useQuery,
} from '@tanstack/react-query';
import { Suspense } from 'react';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      suspense: true,
    },
  },
});

function Users() {
  const { data } = useQuery({
    queryKey: ['users'],
    queryFn: () =>
      fetch('https://jsonplaceholder.typicode.com/users').then((res) =>
        res.json()
      ),
  });

  return (
    <ul>
      {data.map((u) => (
        <li key={u.id}>{u.name}</li>
      ))}
    </ul>
  );
}

export default function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <Suspense fallback={<p>⏳ Lädt Benutzer...</p>}>
        <Users />
      </Suspense>
    </QueryClientProvider>
  );
}
```

---

## 🧠 Was passiert hier?

- **`Suspense`** zeigt das `fallback`, solange `Users` noch lädt.
- Sobald `useQuery` Daten geladen hat, wird `fallback` ersetzt.
- Vorteil: Kein explizites `isLoading` oder `error` nötig → cleaner Code

---

## 🔁 Alternative: Eigene Datenquelle mit `suspense`-like Verhalten

```jsx
function wrapPromise(promise) {
  let status = 'pending';
  let result;
  const suspender = promise.then(
    (r) => {
      status = 'success';
      result = r;
    },
    (e) => {
      status = 'error';
      result = e;
    }
  );

  return {
    read() {
      if (status === 'pending') throw suspender;
      if (status === 'error') throw result;
      return result;
    },
  };
}
```

➡️ Diese Technik ist eher experimentell.

---

## 📝 Zusammenfassung

- `Suspense` kann Ladezustände abfangen und Fallback anzeigen
- Für Daten: funktioniert nur mit Libraries wie **React Query** oder **Relay**
- Vorteil: **automatisches Laden + saubere Trennung von UI & Logik**

---

## 🔗 Quellen

- [React Suspense für Daten – React Docs](https://react.dev/reference/react/Suspense)  
- [TanStack Query mit Suspense](https://tanstack.com/query/latest/docs/react/guides/suspense)  
- [MDN: Promises](https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Promise)

  **[⬆ Наверх](#top)**

85. ### <a name="85"></a> 



  **[⬆ Наверх](#top)**

86. ### <a name="86"></a> 



  **[⬆ Наверх](#top)**

87. ### <a name="87"></a> 



  **[⬆ Наверх](#top)**

88. ### <a name="88"></a> 



  **[⬆ Наверх](#top)**

89. ### <a name="89"></a> 



  **[⬆ Наверх](#top)**

90. ### <a name="90"></a> 



  **[⬆ Наверх](#top)**  

91. ### <a name="91"></a> Was ist Unit-, Integration- und E2E-Testing?

# Was ist Unit-, Integration- und E2E-Testing in der Webentwicklung?

Beim Testen von Anwendungen unterscheidet man drei zentrale Testarten:  
**Unit-Tests**, **Integrationstests** und **End-to-End-Tests (E2E)**.  
Sie prüfen den Code auf verschiedenen Ebenen.

---

## ✅ 1. Unit-Testing (Einheitentest)

**Testet eine einzelne Funktion oder Komponente isoliert.**

### Ziel:
- Prüfen, ob eine **kleine logische Einheit** korrekt funktioniert

### Beispiel:

```jsx
// sum.js
export function sum(a, b) {
  return a + b;
}

// sum.test.js
import { sum } from './sum';

test('addiert zwei Zahlen korrekt', () => {
  expect(sum(2, 3)).toBe(5);
});
```

### Tools:
- **Jest**, **Vitest**, **Mocha**

---

## ✅ 2. Integrationstests

**Testet das Zusammenspiel mehrerer Einheiten.**

### Ziel:
- Sicherstellen, dass **Komponenten oder Module korrekt interagieren**

### Beispiel:

```jsx
// LoginForm.js mit Input + Button + Handler
// Integrationstest prüft, ob das Form korrekt absendet

import { render, screen, fireEvent } from '@testing-library/react';
import LoginForm from './LoginForm';

test('LoginForm ruft onSubmit mit richtigen Daten auf', () => {
  const handleSubmit = jest.fn();
  render(<LoginForm onSubmit={handleSubmit} />);

  fireEvent.change(screen.getByLabelText(/email/i), {
    target: { value: 'test@mail.com' },
  });
  fireEvent.click(screen.getByText(/einloggen/i));

  expect(handleSubmit).toHaveBeenCalledWith({
    email: 'test@mail.com',
  });
});
```

### Tools:
- **React Testing Library**, **Jest**

---

## ✅ 3. E2E-Testing (End-to-End)

**Testet die gesamte App vom Nutzer aus betrachtet (UI + Backend).**

### Ziel:
- Simulieren, wie ein **echter Benutzer** mit der App interagiert
- Test umfasst: Browser, Klicks, Navigation, API, Server

### Beispiel:

```js
// login.spec.js mit Cypress

describe('Login Flow', () => {
  it('meldet sich erfolgreich an', () => {
    cy.visit('/login');
    cy.get('input[name="email"]').type('user@mail.com');
    cy.get('input[name="password"]').type('pass123');
    cy.get('button[type="submit"]').click();
    cy.contains('Willkommen, user@mail.com');
  });
});
```

### Tools:
- **Cypress**, **Playwright**, **TestCafe**

---

## 📊 Vergleich

| Testtyp        | Umfang             | Geschwindigkeit | Stabilität | Fehlerursache erkennbar |
|----------------|--------------------|------------------|------------|--------------------------|
| Unit-Test      | Sehr klein (1 Unit)| 🟢 Sehr schnell  | 🟢 Hoch     | 🎯 Sehr präzise          |
| Integration    | Mittelgroß         | 🟡 Mittel         | 🟡 Gut      | 🎯 Meist klar            |
| E2E-Test       | Ganze App (UI/API) | 🔴 Langsam        | 🔴 Weniger stabil | ⚠️ Fehler schwerer zu debuggen |

---

## 📝 Zusammenfassung

| Testart      | Was wird getestet?                            | Tools                    |
|--------------|-----------------------------------------------|--------------------------|
| Unit         | Einzelne Funktion oder Komponente             | Jest, Vitest             |
| Integration  | Zusammenspiel mehrerer Komponenten            | React Testing Library    |
| E2E          | Gesamter Ablauf aus Sicht des Benutzers       | Cypress, Playwright      |

---

## 🔗 Quellen

- [Jest – Unit Testing](https://jestjs.io/docs/getting-started)  
- [React Testing Library](https://testing-library.com/docs/react-testing-library/intro/)  
- [Cypress E2E Testing](https://www.cypress.io)  
- [Playwright Testing](https://playwright.dev)

  **[⬆ Наверх](#top)**

92. ### <a name="92"></a> Was ist Snapshot-Testing?

# Was ist Snapshot-Testing in React?

**Snapshot-Testing** ist eine Testmethode, bei der die **Ausgabe einer Komponente** gespeichert  
und bei jedem Testlauf automatisch mit dem vorherigen **„Snapshot“** verglichen wird.  
So erkennt man unbeabsichtigte Änderungen in der UI.

---

## 🎯 Ziel

- Sicherstellen, dass sich die gerenderte Ausgabe einer Komponente **nicht unerwartet verändert**
- Ideal für **präsentationsorientierte Komponenten** (UI, Layout)

---

## 🧪 Beispiel mit Jest

```jsx
// Hello.jsx
function Hello({ name }) {
  return <h1>Hallo, {name}!</h1>;
}

export default Hello;
```

```jsx
// Hello.test.js
import { render } from '@testing-library/react';
import Hello from './Hello';

test('erstellt einen Snapshot der Hello-Komponente', () => {
  const { asFragment } = render(<Hello name="Sergii" />);
  expect(asFragment()).toMatchSnapshot();
});
```

### ➕ Beim ersten Testlauf:

Es wird eine Datei erstellt:  
`__snapshots__/Hello.test.js.snap` mit dem HTML-Output:

```txt
<document-fragment>
  <h1>Hallo, Sergii!</h1>
</document-fragment>
```

### 🔁 Bei weiteren Testläufen:

- Wenn sich der HTML-Output **ändert**, schlägt der Test fehl
- Man kann dann entscheiden:  
  - ✅ „Änderung gewollt“ → `jest -u` zum **aktualisieren**  
  - ❌ „Fehlerhaft“ → Komponente korrigieren

---

## 📦 Vorteile

- Schnell und einfach für reine UI-Komponenten
- Automatisches Erkennen von Änderungen

---

## ⚠️ Nachteile

- Snapshots können **zu groß** und **unnütz** werden, wenn man zu viele auf einmal testet
- Änderungen im Output ≠ tatsächlicher Fehler

➡️ Nicht geeignet für **Logiktests** oder dynamische Inhalte

---

## 📝 Zusammenfassung

- Snapshot-Tests vergleichen JSX-Output mit gespeicherten Referenzwerten
- Verwende `toMatchSnapshot()` z. B. mit **Jest** + **Testing Library**
- Nur sinnvoll für **statische, visuelle Komponenten**

---

## 🔗 Quellen

- [Jest – Snapshot Testing](https://jestjs.io/docs/snapshot-testing)  
- [React Testing Library – Snapshots](https://testing-library.com/docs/react-testing-library/api/#asfragment)

  **[⬆ Наверх](#top)**

93. ### <a name="93"></a> Welche Tools nutzt man für React-Tests (Jest, React Testing Library)?

# Welche Tools nutzt man für React-Tests?

In der React-Entwicklung sind die gängigsten Test-Tools:

1. **Jest** – Test-Runner + Assertion-Bibliothek  
2. **React Testing Library (RTL)** – UI-Verhalten aus Nutzersicht testen  
3. Weitere: **Vitest**, **MSW**, **Cypress**, **Playwright**

---

## ✅ 1. Jest

🛠 **Test-Runner**, **Mocking**, **Snapshot-Testing**, **Assertions**

```bash
npm install --save-dev jest
```

- Läuft JavaScript-Tests (z. B. `.test.js`)
- Unterstützt `describe`, `test`, `expect`, `beforeEach` etc.
- Integriert gut mit Babel, TypeScript und React

### Beispiel:

```js
test('addiert zwei Zahlen', () => {
  expect(2 + 2).toBe(4);
});
```

📘 [Jest Docs](https://jestjs.io/docs/getting-started)

---

## ✅ 2. React Testing Library (RTL)

🔍 Testet **Komponentenverhalten aus Sicht des Nutzers**

```bash
npm install --save-dev @testing-library/react
```

- Zugriff auf UI via `getByText`, `getByRole`, `getByLabelText`
- Kein Zugriff auf Implementierungsdetails
- Gute Best Practices durch Design

### Beispiel:

```jsx
import { render, screen } from '@testing-library/react';
import Button from './Button';

test('zeigt Buttontext korrekt an', () => {
  render(<Button>Speichern</Button>);
  expect(screen.getByText('Speichern')).toBeInTheDocument();
});
```

📘 [React Testing Library Docs](https://testing-library.com/docs/react-testing-library/intro/)

---

## ✅ 3. Vitest (Alternative zu Jest)

🚀 Schneller Test-Runner für Vite-Projekte

```bash
npm install --save-dev vitest
```

- Kompatibel mit Jest-API
- Schneller durch native ESModules

📘 [Vitest Docs](https://vitest.dev)

---

## ✅ 4. MSW (Mock Service Worker)

🧪 Simuliert echte API-Requests im Test oder Browser

```bash
npm install msw --save-dev
```

📘 [MSW Docs](https://mswjs.io)

---

## ✅ 5. Cypress / Playwright

🧭 Für **End-to-End (E2E)**-Tests im echten Browser

- Simuliert Nutzerverhalten: klicken, tippen, navigieren
- Cypress zielt auf Entwicklerfreundlichkeit
- Playwright testet auch mehrere Browser

📘 [Cypress.io](https://www.cypress.io)  
📘 [Playwright.dev](https://playwright.dev)

---

## 📝 Zusammenfassung

| Tool                   | Zweck                     | Beschreibung                              |
|------------------------|---------------------------|--------------------------------------------|
| **Jest**               | Unit + Snapshot Tests     | Test-Runner & Mocking                      |
| **React Testing Library** | Integration/Component | Testet aus Nutzersicht                     |
| **Vitest**             | Schnelle Alternative      | Besonders für Vite-Projekte                |
| **MSW**                | Mocking API               | Reale Netzwerkrequests simulieren         |
| **Cypress / Playwright** | E2E Testing             | UI-Tests im echten Browser                 |

---

## 🔗 Weitere Links

- [Testing in React – Offizielle Doku](https://react.dev/learn/testing)  
- [Testing Library – Guide](https://testing-library.com/docs/)  
- [Jest – Snapshot Testing](https://jestjs.io/docs/snapshot-testing)

  **[⬆ Наверх](#top)**

94. ### <a name="94"></a> Wie testet man Komponenten, Props und Events?

# Wie testet man Komponenten, Props und Events in React?

Beim Testen von React-Komponenten geht es darum zu prüfen, ob:

1. Die **Komponente korrekt rendert**
2. **Props richtig verwendet** werden
3. **Benutzerinteraktionen (Events)** korrekt funktionieren

Dafür nutzt man typischerweise:

- **React Testing Library** (RTL)
- **Jest** als Test-Runner

---

## ✅ 1. Komponente rendern und Inhalt testen

```jsx
import { render, screen } from '@testing-library/react';
import Greeting from './Greeting';

test('zeigt Begrüßung an', () => {
  render(<Greeting name="Sergii" />);
  expect(screen.getByText(/Hallo, Sergii/i)).toBeInTheDocument();
});
```

---

## ✅ 2. Props testen

Du testest **indirekt**, ob Props korrekt verwendet wurden –  
z. B. durch gerendeten Text oder Verhalten.

```jsx
function Title({ text }) {
  return <h1>{text}</h1>;
}

// Test
test('zeigt den Titel-Prop korrekt an', () => {
  render(<Title text="Dashboard" />);
  expect(screen.getByText('Dashboard')).toBeInTheDocument();
});
```

---

## ✅ 3. Events testen (z. B. Button-Klick)

```jsx
function Button({ onClick }) {
  return <button onClick={onClick}>Klick mich</button>;
}

// Test
import userEvent from '@testing-library/user-event';

test('ruft onClick beim Klicken auf', async () => {
  const handleClick = jest.fn();
  render(<Button onClick={handleClick} />);

  await userEvent.click(screen.getByText('Klick mich'));
  expect(handleClick).toHaveBeenCalledTimes(1);
});
```

---

## 🛠 Tools & Methoden (RTL)

| Methode                   | Beschreibung                                  |
|---------------------------|-----------------------------------------------|
| `render()`                | Rendert die Komponente für den Test           |
| `screen.getByText()`      | Findet Elemente am Bildschirm                 |
| `userEvent.click()`       | Simuliert Benutzeraktionen                    |
| `jest.fn()`               | Erstellt Mockfunktionen für Eventhandler      |
| `toBeInTheDocument()`     | Prüft, ob ein Element im DOM enthalten ist    |

---

## 📝 Zusammenfassung

| Was wird getestet?      | Wie?                            |
|-------------------------|---------------------------------|
| Komponenteninhalte      | `screen.getByText`, `render()`  |
| Props                   | Text oder Verhalten überprüfen  |
| Events (z. B. Klicks)   | `userEvent`, `jest.fn()`        |

---

## 🔗 Quellen

- [React Testing Library – Intro](https://testing-library.com/docs/react-testing-library/intro/)  
- [Jest – Mock Functions](https://jestjs.io/docs/mock-functions)  
- [React Docs – Testing UI](https://react.dev/learn/testing)

  **[⬆ Наверх](#top)**

95. ### <a name="95"></a> Wie testet man benutzerdefinierte Hooks?

# Wie testet man benutzerdefinierte Hooks in React?

Benutzerdefinierte Hooks (`useXXX`) enthalten wiederverwendbare Logik.  
Um sie zu testen, verwendet man:

- ✅ **`@testing-library/react-hooks`** (älter, eingestellt)  
- ✅ **`@testing-library/react` + eigene Testkomponente**  
- ✅ **`@testing-library/react-hooks/dom`** (aus `@tanstack/react-hooks-testing-library`)

> Der moderne Weg ist: **React-Hooks innerhalb eines Testkomponenten-Kontextes rendern**.

---

## 📦 Beispiel: Eigener Hook

```jsx
// useCounter.js
import { useState } from 'react';

export function useCounter(initial = 0) {
  const [count, setCount] = useState(initial);
  const increment = () => setCount((c) => c + 1);
  return { count, increment };
}
```

---

## ✅ Variante 1: Test mit Testkomponente (Standard mit RTL)

```jsx
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { useCounter } from './useCounter';

function TestComponent() {
  const { count, increment } = useCounter();
  return (
    <>
      <p>Count: {count}</p>
      <button onClick={increment}>+</button>
    </>
  );
}

test('useCounter erhöht den Wert', async () => {
  render(<TestComponent />);
  const button = screen.getByText('+');

  await userEvent.click(button);
  expect(screen.getByText('Count: 1')).toBeInTheDocument();
});
```

---

## ✅ Variante 2: `@testing-library/react-hooks` (wenn nötig)

```bash
npm install --save-dev @testing-library/react-hooks
```

```jsx
import { renderHook, act } from '@testing-library/react-hooks';
import { useCounter } from './useCounter';

test('useCounter funktioniert korrekt', () => {
  const { result } = renderHook(() => useCounter(0));

  expect(result.current.count).toBe(0);

  act(() => {
    result.current.increment();
  });

  expect(result.current.count).toBe(1);
});
```

> ⚠️ Diese Variante wird **nicht mehr aktiv gepflegt**.

---

## 📝 Zusammenfassung

| Methode                            | Vorteil                          |
|------------------------------------|----------------------------------|
| ✅ Eigene Test-Komponente           | Kompatibel mit `@testing-library/react` |
| ⚠️ `@testing-library/react-hooks`   | Für reine Hook-Tests (älter)     |

---

## 🔗 Quellen

- [React Testing Library – Hooks testen](https://testing-library.com/docs/example-react-hooks)  
- [React-Hooks-Test-Bibliothek – TanStack](https://github.com/TanStack/testing-react-hooks)  
- [React Docs – eigene Hooks schreiben](https://react.dev/learn/reusing-logic-with-custom-hooks)

  **[⬆ Наверх](#top)**

96. ### <a name="96"></a> 



  **[⬆ Наверх](#top)**

97. ### <a name="97"></a> 



  **[⬆ Наверх](#top)**

98. ### <a name="98"></a> 



  **[⬆ Наверх](#top)**

99. ### <a name="99"></a> 



  **[⬆ Наверх](#top)**

100. ### <a name="100"></a> 



  **[⬆ Наверх](#top)**    

101. ### <a name="101"></a> Wie funktioniert Routing in React mit react-router-dom?

# Wie funktioniert Routing in React mit `react-router-dom`?

`react-router-dom` ist die Standard-Bibliothek für **Client-seitiges Routing** in React.  
Sie ermöglicht die Navigation zwischen Seiten **ohne Neuladen** der Website.

---

## 📦 Installation

```bash
npm install react-router-dom
```

---

## 🧱 Grundkonzepte

| Komponente          | Zweck                                          |
|---------------------|-------------------------------------------------|
| `<BrowserRouter>`   | Wurzel-Router, verwendet HTML5 History API     |
| `<Routes>`          | Container für alle Routen                      |
| `<Route>`           | Definiert eine einzelne Route                  |
| `<Link>`            | Navigation ohne Seiten-Reload                  |
| `useNavigate()`     | Programmatische Navigation                     |
| `useParams()`       | Zugriff auf URL-Parameter                      |

---

## ✅ Beispiel: Basis-Routing

```jsx
import { BrowserRouter, Routes, Route, Link } from 'react-router-dom';

function Home() {
  return <h2>Startseite</h2>;
}

function About() {
  return <h2>Über uns</h2>;
}

function App() {
  return (
    <BrowserRouter>
      <nav>
        <Link to="/">Start</Link> | <Link to="/about">Über</Link>
      </nav>

      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
      </Routes>
    </BrowserRouter>
  );
}
```

---

## 📌 Dynamische Routen mit Parametern

```jsx
// URL: /user/123

function UserPage() {
  const { id } = useParams();
  return <p>User ID: {id}</p>;
}

<Routes>
  <Route path="/user/:id" element={<UserPage />} />
</Routes>
```

---

## 🚀 Navigation per Code (z. B. nach Login)

```jsx
import { useNavigate } from 'react-router-dom';

function LoginButton() {
  const navigate = useNavigate();

  const handleLogin = () => {
    // ...Login-Logik
    navigate('/dashboard'); // Weiterleitung
  };

  return <button onClick={handleLogin}>Login</button>;
}
```

---

## 🔁 Weiterleitungen

```jsx
import { Navigate } from 'react-router-dom';

<Route path="/alt" element={<Navigate to="/neu" />} />
```

---

## 📝 Zusammenfassung

- Routing wird mit `BrowserRouter`, `Routes` und `Route` umgesetzt
- Navigation per `<Link>` oder `useNavigate()`
- Dynamische Parameter via `:id` und `useParams()`
- Kein Seitenreload nötig → **Single Page Application (SPA)**

---

## 🔗 Quellen

- [React Router Doku](https://reactrouter.com/en/main/start/tutorial)  
- [MDN – Client-Side Routing](https://developer.mozilla.org/en-US/docs/Glossary/SPA)

  **[⬆ Наверх](#top)**

102. ### <a name="102"></a> Was sind die Unterschiede zwischen react-router v5 und v6?

# Was sind die Unterschiede zwischen `react-router-dom` v5 und v6?

`react-router-dom` v6 ist eine **komplett überarbeitete Version** mit  
neuem Syntax, klarerer Struktur und vereinfachter Logik.  
Hier sind die wichtigsten Unterschiede zwischen v5 und v6:

---

## 🔄 1. `<Switch>` → **`<Routes>`**

- **v5:** `<Switch>` rendert die erste passende Route  
- **v6:** `<Routes>` ersetzt `<Switch>` und **rendert nur genau eine Route**

```jsx
// v5
<Switch>
  <Route path="/about" component={About} />
</Switch>

// v6
<Routes>
  <Route path="/about" element={<About />} />
</Routes>
```

---

## ⚛️ 2. `component` vs `element`

- **v5:** `component={MyComponent}`
- **v6:** `element={<MyComponent />}` (JSX wird erwartet)

```jsx
// v5
<Route path="/home" component={Home} />

// v6
<Route path="/home" element={<Home />} />
```

---

## 🧭 3. `Redirect` → **`<Navigate />`**

- **v5:** `<Redirect to="/login" />`
- **v6:** `<Navigate to="/login" />`

```jsx
// v6 Beispiel
<Route path="*" element={<Navigate to="/" />} />
```

---

## 🧬 4. Verschachtelte Routen (Nested Routes)

- **v6** nutzt **nested `<Route>`** mit `outlet`-Konzept

```jsx
// v6
<Routes>
  <Route path="/dashboard" element={<Dashboard />}>
    <Route path="profile" element={<Profile />} />
    <Route path="settings" element={<Settings />} />
  </Route>
</Routes>
```

```jsx
// Dashboard.jsx
import { Outlet } from 'react-router-dom';
export default function Dashboard() {
  return (
    <div>
      <h1>Dashboard</h1>
      <Outlet />
    </div>
  );
}
```

---

## ⚠️ 5. `exact` ist **nicht mehr nötig**

- **v6 matcht automatisch exakt**
- In v5 war `exact` notwendig, um Überlappung zu vermeiden

```jsx
// v5
<Route exact path="/" component={Home} />

// v6
<Route path="/" element={<Home />} /> // exact implizit
```

---

## ✅ 6. Neue Features in v6

| Feature                | Beschreibung                                    |
|------------------------|-------------------------------------------------|
| `<Outlet />`           | Für Nested Routing                             |
| `useRoutes()`          | Routing mit Objekt-Definition                   |
| `createBrowserRouter`  | Für Data-Routing mit `react-router v6.4+`       |
| `Loader`, `Action`     | Neue API für Datenladen direkt in Route-Objekten|

---

## 📝 Zusammenfassung

| Unterschied         | v5                        | v6                             |
|---------------------|---------------------------|--------------------------------|
| Routencontainer     | `<Switch>`                | `<Routes>`                     |
| Komponenten         | `component`/`render`      | `element={<... />}`            |
| Weiterleitung       | `<Redirect>`              | `<Navigate>`                   |
| Nested Routes       | Manuell / kompliziert     | Mit `<Outlet>` einfach         |
| `exact`             | Manuell nötig             | Automatisch exakt              |

---

## 🔗 Quellen

- [React Router v6 Doku](https://reactrouter.com/en/main)  
- [Migration von v5 zu v6](https://reactrouter.com/en/main/start/overview#migrating-from-v5)

  **[⬆ Наверх](#top)**

103. ### <a name="103"></a> Was sind Route, Link, Navigate, Outlet?

# Was sind `Route`, `Link`, `Navigate`, `Outlet` in React Router?

Diese Komponenten stammen aus **`react-router-dom`** und bilden das Grundgerüst  
für Navigation, Seitenwechsel und Seitenstruktur in React-Anwendungen.

---

## 🔁 `Route`

Definiert, **welche Komponente bei welcher URL angezeigt wird**.

```jsx
<Route path="/about" element={<About />} />
```

- Wird innerhalb von `<Routes>` verwendet
- `path` = URL-Pfad
- `element` = JSX-Komponente, die gerendert wird

---

## 🔗 `Link`

Erstellt **einen Link**, der beim Klicken die URL **ändert**,  
ohne die Seite neu zu laden (SPA-Verhalten).

```jsx
<Link to="/about">Über uns</Link>
```

- Vergleichbar mit `<a href="..." />`, aber **Client-seitig**
- Nutzt History API intern
- Vorteil: Schnelle Navigation ohne Reload

---

## 🚀 `Navigate`

Ersetzt `<Redirect>` (aus v5).  
Wird verwendet, um **programmatisch weiterzuleiten**.

```jsx
<Route path="*" element={<Navigate to="/" />} />
```

Oder innerhalb einer Komponente:

```jsx
if (!isLoggedIn) {
  return <Navigate to="/login" />;
}
```

- Automatische Weiterleitung (z. B. nach Login, Fehler, Logout)

---

## 🧩 `Outlet`

Wird verwendet, um **geschachtelte Routen** (Nested Routes) einzufügen.

```jsx
// App.jsx
<Routes>
  <Route path="/dashboard" element={<Dashboard />}>
    <Route path="profile" element={<Profile />} />
  </Route>
</Routes>
```

```jsx
// Dashboard.jsx
import { Outlet } from 'react-router-dom';

function Dashboard() {
  return (
    <div>
      <h1>Dashboard</h1>
      <Outlet /> {/* Hier erscheint <Profile /> */}
    </div>
  );
}
```

---

## 📝 Zusammenfassung

| Element      | Funktion                                      |
|--------------|-----------------------------------------------|
| `Route`      | Definiert, welche Komponente bei welcher URL |
| `Link`       | Navigation per Klick ohne Seitenreload        |
| `Navigate`   | Programmgesteuerte Weiterleitung               |
| `Outlet`     | Platzhalter für verschachtelte Routen         |

---

## 🔗 Quellen

- [React Router – Startseite](https://reactrouter.com/en/main/start/tutorial)  
- [React Router – API Referenz](https://reactrouter.com/en/main/components/route)

  **[⬆ Наверх](#top)**

104. ### <a name="104"></a> Wie erstellt man Nested Routes?

# Wie erstellt man Nested Routes in React Router (v6)?

**Nested Routes** (geschachtelte Routen) ermöglichen es,  
eine **Hauptkomponente mit untergeordnetem Inhalt** anzuzeigen,  
z. B. ein Dashboard mit Tabs wie „Profil“, „Einstellungen“ usw.

---

## 🧱 Grundprinzip

- Verwende `<Route>` innerhalb eines anderen `<Route>`
- Platziere `<Outlet />` dort, wo die **Kind-Komponenten** erscheinen sollen

---

## ✅ Beispiel

### 🔧 Struktur

```
/dashboard
/dashboard/profile
/dashboard/settings
```

---

### 1️⃣ Routen in `App.jsx`

```jsx
import { BrowserRouter, Routes, Route } from 'react-router-dom';
import Dashboard from './pages/Dashboard';
import Profile from './pages/Profile';
import Settings from './pages/Settings';

function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/dashboard" element={<Dashboard />}>
          <Route path="profile" element={<Profile />} />
          <Route path="settings" element={<Settings />} />
        </Route>
      </Routes>
    </BrowserRouter>
  );
}
```

---

### 2️⃣ `Dashboard.jsx` – mit `<Outlet />`

```jsx
import { Outlet, Link } from 'react-router-dom';

function Dashboard() {
  return (
    <div>
      <h1>Dashboard</h1>
      <nav>
        <Link to="profile">Profil</Link> |{' '}
        <Link to="settings">Einstellungen</Link>
      </nav>
      <hr />
      <Outlet /> {/* ← hier erscheinen verschachtelte Komponenten */}
    </div>
  );
}

export default Dashboard;
```

---

### 3️⃣ Profile.jsx / Settings.jsx

```jsx
function Profile() {
  return <p>👤 Benutzerprofil</p>;
}

function Settings() {
  return <p>⚙️ Einstellungen</p>;
}
```

---

## 📝 Zusammenfassung

| Schritt       | Was passiert?                             |
|---------------|--------------------------------------------|
| `Route`-Verschachtelung | Unterseiten innerhalb eines Hauptlayouts |
| `<Outlet />`   | Platzhalter für die aktive Kind-Komponente  |
| `Link`         | Navigation innerhalb der Unterrouten        |

---

## 🔗 Quellen

- [React Router – Nested Routes](https://reactrouter.com/en/main/start/tutorial#nested-routes)  
- [React Docs – Routing](https://react.dev/learn/start-a-new-react-project#routing)

  **[⬆ Наверх](#top)**

105. ### <a name="105"></a> Wie implementiert man Redirects?

# Wie implementiert man Redirects in React Router v6?

Ein **Redirect** (Weiterleitung) bedeutet, dass ein Benutzer  
automatisch von einer Route zu einer anderen Route umgeleitet wird.

In **React Router v6** nutzt man dafür die Komponente **`<Navigate />`**.

---

## ✅ 1. Statischer Redirect über Route

```jsx
import { Routes, Route, Navigate } from 'react-router-dom';

function App() {
  return (
    <Routes>
      <Route path="/" element={<Home />} />
      <Route path="/start" element={<Navigate to="/" />} />
    </Routes>
  );
}
```

📌 `/start` → `/` automatisch weitergeleitet

---

## ✅ 2. Wildcard-Redirect (404-Fallback)

```jsx
<Route path="*" element={<Navigate to="/" />} />
```

📌 Alle unbekannten Pfade leiten zur Startseite um

---

## ✅ 3. Programmgesteuerter Redirect (z. B. nach Login)

```jsx
import { useNavigate } from 'react-router-dom';

function LoginForm() {
  const navigate = useNavigate();

  function handleLogin() {
    // ...Login-Logik
    navigate('/dashboard'); // Weiterleitung nach Login
  }

  return <button onClick={handleLogin}>Login</button>;
}
```

---

## 🔄 4. Bedingter Redirect

```jsx
function ProtectedPage({ isLoggedIn }) {
  if (!isLoggedIn) {
    return <Navigate to="/login" replace />;
  }

  return <p>Willkommen im geschützten Bereich</p>;
}
```

- `replace` verhindert, dass die Weiterleitung in den Verlauf kommt (`history.back` geht nicht zurück)

---

## 📝 Zusammenfassung

| Typ                          | Methode                      |
|------------------------------|-------------------------------|
| Statische Weiterleitung      | `<Route path="..." element={<Navigate to="..." />} />` |
| Fallback (404)               | `<Route path="*" element={<Navigate to="/" />} />` |
| Logikbasiert (z. B. Login)   | `useNavigate()` Hook         |
| Bedingt in Komponente        | `{ isLoggedIn ? ... : <Navigate /> }` |

---

## 🔗 Quellen

- [React Router – `<Navigate />`](https://reactrouter.com/en/main/components/navigate)  
- [React Router – useNavigate Hook](https://reactrouter.com/en/main/hooks/use-navigate)

  **[⬆ Наверх](#top)**

106. ### <a name="106"></a> Wie funktioniert programmgesteuerte Navigation (useNavigate)?

# Wie funktioniert programmgesteuerte Navigation mit `useNavigate`?

Mit dem **Hook `useNavigate()`** aus `react-router-dom` kannst du  
**per Code** (statt durch Klick auf einen Link) zwischen Routen navigieren.

---

## ✅ Verwendung

```jsx
import { useNavigate } from 'react-router-dom';

function LoginButton() {
  const navigate = useNavigate();

  const handleLogin = () => {
    // ✅ Login-Logik
    // 🔄 Navigation nach erfolgreichem Login
    navigate('/dashboard');
  };

  return <button onClick={handleLogin}>Login</button>;
}
```

---

## 📌 Optionen

```js
navigate('/ziel', {
  replace: true,   // ersetzt aktuellen Eintrag im Verlauf (kein Zurück möglich)
  state: { userId: 123 }, // optionaler Zustand, über `location.state` abrufbar
});
```

---

## 📥 Weitergabe von State

```jsx
navigate('/profile', { state: { userName: 'Sergii' } });
```

```jsx
// Ziel-Komponente
import { useLocation } from 'react-router-dom';

const location = useLocation();
console.log(location.state.userName); // "Sergii"
```

---

## 🔁 Dynamische Navigation mit Parametern

```jsx
navigate(`/user/${userId}`);
```

---

## 📝 Zusammenfassung

| Funktion             | Beschreibung                         |
|----------------------|--------------------------------------|
| `useNavigate()`      | Hook zum Navigieren per Code         |
| `navigate('/pfad')`  | Navigation zur Zielroute             |
| `replace: true`      | Ersetzt History-Eintrag (kein Zurück)|
| `state: {...}`       | Übergibt Daten an Zielkomponente     |

---

## 🔗 Quellen

- [React Router – useNavigate](https://reactrouter.com/en/main/hooks/use-navigate)  
- [React Router – useLocation](https://reactrouter.com/en/main/hooks/use-location)

  **[⬆ Наверх](#top)**

107. ### <a name="107"></a> 



  **[⬆ Наверх](#top)**

108. ### <a name="108"></a> 



  **[⬆ Наверх](#top)**

109. ### <a name="109"></a> 



  **[⬆ Наверх](#top)**

110. ### <a name="110"></a> 



  **[⬆ Наверх](#top)**

111. ### <a name="111"></a> Was ist Redux und wie funktioniert es?

# Was ist Redux und wie funktioniert es?

**Redux** ist eine **State-Management-Bibliothek**,  
die hilft, **globalen Zustand zentral** zu verwalten – besonders in größeren React-Apps.  
Sie basiert auf einem **Single Source of Truth** (ein globales Store-Objekt)  
und nutzt ein **unidirektionales Datenflussmodell**.

---

## 🎯 Wann ist Redux nützlich?

- Viele Komponenten müssen denselben Zustand verwenden oder verändern
- Du willst Zustand **vorhersagbar, nachvollziehbar und testbar** halten
- Du brauchst eine **klare Trennung von Logik und UI**

---

## 🧠 Grundkonzepte

| Begriff        | Beschreibung                                                                 |
|----------------|-------------------------------------------------------------------------------|
| `Store`        | Zentrale Datenquelle (globaler Zustand)                                      |
| `Action`       | Ein einfaches Objekt, das **beschreibt, was passieren soll**                 |
| `Reducer`      | Eine reine Funktion, die **neuen Zustand basierend auf Action erstellt**     |
| `Dispatch()`   | Methode, um eine Action an den Store zu senden                               |
| `Selector`     | Liest bestimmte Teile des States aus                                         |

---

## ⚙️ Beispiel: Zähler mit Redux Toolkit

### 🔧 Setup

```bash
npm install @reduxjs/toolkit react-redux
```

---

### 1️⃣ Store & Reducer

```js
// store.js
import { configureStore, createSlice } from '@reduxjs/toolkit';

const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 },
  reducers: {
    increment(state) {
      state.value += 1;
    },
    decrement(state) {
      state.value -= 1;
    },
  },
});

export const { increment, decrement } = counterSlice.actions;

export const store = configureStore({
  reducer: { counter: counterSlice.reducer },
});
```

---

### 2️⃣ Bereitstellen des Stores

```jsx
// main.jsx
import { Provider } from 'react-redux';
import { store } from './store';
import App from './App';

<Provider store={store}>
  <App />
</Provider>
```

---

### 3️⃣ Verwenden in einer Komponente

```jsx
// Counter.jsx
import { useSelector, useDispatch } from 'react-redux';
import { increment, decrement } from './store';

function Counter() {
  const count = useSelector((state) => state.counter.value);
  const dispatch = useDispatch();

  return (
    <div>
      <p>Zähler: {count}</p>
      <button onClick={() => dispatch(increment())}>+</button>
      <button onClick={() => dispatch(decrement())}>–</button>
    </div>
  );
}
```

---

## 🔁 Datenfluss

```text
UI → dispatch(action) → reducer → neuer state → UI-Update
```

---

## 📝 Zusammenfassung

| Begriff       | Funktion                              |
|---------------|----------------------------------------|
| `Store`       | Zentrale Datenhaltung                  |
| `Action`      | Ereignisbeschreibung                   |
| `Reducer`     | Verändert Zustand basierend auf Action |
| `dispatch()`  | Sendet Action an Reducer               |
| `useSelector` | Liest Daten aus dem Store              |
| `useDispatch` | Ruft Aktionen auf                      |

---

## 🔗 Quellen

- [Redux Toolkit – Offizielle Doku](https://redux-toolkit.js.org)  
- [React Redux – Einstieg](https://react-redux.js.org/introduction/getting-started)

  **[⬆ Наверх](#top)**

112. ### <a name="112"></a> Was sind Actions, Reducer und Store?

# Was sind Actions, Reducer und Store in Redux?

Diese drei Konzepte bilden das **Herzstück von Redux**.  
Sie sorgen für einen **vorhersagbaren Datenfluss** und eine **klare Trennung der Logik**.

---

## 🟩 1. **Store**

Der **Store** ist die **zentrale Datenquelle** deiner Anwendung.  
Er enthält den **globalen Zustand** (State) und stellt Methoden bereit, um:

- den Zustand zu lesen (`getState`)
- Änderungen auszulösen (`dispatch`)
- auf Änderungen zu reagieren (`subscribe`)

### Beispiel:

```js
import { configureStore } from '@reduxjs/toolkit';
import counterReducer from './counterSlice';

const store = configureStore({
  reducer: {
    counter: counterReducer,
  },
});
```

---

## 🟨 2. **Action**

Eine **Action** ist ein **JavaScript-Objekt**, das beschreibt, **was passiert ist**.  
Sie hat mindestens ein `type`-Feld.

### Beispiel:

```js
const incrementAction = { type: 'counter/increment' };
```

Mit Redux Toolkit:

```js
dispatch(increment()); // automatisch erzeugte Action
```

---

## 🟥 3. **Reducer**

Ein **Reducer** ist eine **reine Funktion**, die den neuen Zustand berechnet  
auf Basis des aktuellen Zustands + Action.

### Beispiel (klassisch):

```js
function counterReducer(state = { value: 0 }, action) {
  switch (action.type) {
    case 'counter/increment':
      return { value: state.value + 1 };
    default:
      return state;
  }
}
```

### Beispiel mit Redux Toolkit:

```js
const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 },
  reducers: {
    increment(state) {
      state.value += 1; // dank Immer.js erlaubt
    },
  },
});
```

---

## 🔁 Zusammenwirken der drei

```text
UI → dispatch(Action) → Reducer → Neuer State → Store → UI-Update
```

---

## 📝 Zusammenfassung

| Begriff     | Funktion                                      |
|-------------|-----------------------------------------------|
| **Store**   | Hält den globalen Zustand                     |
| **Action**  | Beschreibt, was passiert ist (`{ type: ... }`)|
| **Reducer** | Erzeugt neuen Zustand basierend auf Action    |

---

## 🔗 Quellen

- [Redux Grundlagen (offiziell)](https://redux.js.org/tutorials/fundamentals/part-3-state-actions-reducers)  
- [Redux Toolkit Docs](https://redux-toolkit.js.org/introduction/getting-started)

  **[⬆ Наверх](#top)**

113. ### <a name="113"></a> Wie funktioniert Redux Toolkit (createSlice, configureStore, createAsyncThunk)?

# Wie funktioniert Redux Toolkit (`createSlice`, `configureStore`, `createAsyncThunk`)?

**Redux Toolkit** ist die offizielle, empfohlene Methode zum Schreiben von Redux-Code.  
Es reduziert Boilerplate-Code und bietet moderne, einfache APIs für `Store`, `Reducer`, `Async-Logik`.

---

## 📦 Installation

```bash
npm install @reduxjs/toolkit react-redux
```

---

## 🔧 1. `createSlice` – Reducer + Actions in einem

```js
import { createSlice } from '@reduxjs/toolkit';

const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 },
  reducers: {
    increment(state) {
      state.value += 1;
    },
    decrement(state) {
      state.value -= 1;
    },
  },
});

export const { increment, decrement } = counterSlice.actions;
export default counterSlice.reducer;
```

✅ Vorteile:
- automatische Action-Erstellung (`increment`, `decrement`)
- automatische Action-Typen (`counter/increment`)

---

## 🏪 2. `configureStore` – Store erstellen

```js
import { configureStore } from '@reduxjs/toolkit';
import counterReducer from './counterSlice';

export const store = configureStore({
  reducer: {
    counter: counterReducer,
  },
});
```

- akzeptiert ein **Reducer-Objekt**
- aktiviert automatisch Redux DevTools & Middleware

---

## 🔁 3. `createAsyncThunk` – Asynchrone Logik wie API-Fetch

```js
import { createAsyncThunk } from '@reduxjs/toolkit';

export const fetchUsers = createAsyncThunk(
  'users/fetchUsers',
  async () => {
    const response = await fetch('https://jsonplaceholder.typicode.com/users');
    return await response.json();
  }
);
```

➡ Wird automatisch in `pending`, `fulfilled`, `rejected` unterteilt.

---

### In Kombination mit `extraReducers`:

```js
const usersSlice = createSlice({
  name: 'users',
  initialState: { list: [], loading: false },
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchUsers.pending, (state) => {
        state.loading = true;
      })
      .addCase(fetchUsers.fulfilled, (state, action) => {
        state.loading = false;
        state.list = action.payload;
      })
      .addCase(fetchUsers.rejected, (state) => {
        state.loading = false;
      });
  },
});
```

---

## 🧠 Verwendung im React-Komponenten

```jsx
import { useSelector, useDispatch } from 'react-redux';
import { increment } from './counterSlice';

function Counter() {
  const value = useSelector((state) => state.counter.value);
  const dispatch = useDispatch();

  return (
    <>
      <p>Zähler: {value}</p>
      <button onClick={() => dispatch(increment())}>+</button>
    </>
  );
}
```

---

## 📝 Zusammenfassung

| Funktion              | Aufgabe                                  |
|-----------------------|-------------------------------------------|
| `createSlice`         | erstellt Reducer + Actions automatisch    |
| `configureStore`      | erzeugt den Store + Middleware             |
| `createAsyncThunk`    | einfache Handhabung asynchroner Logik     |
| `extraReducers`       | Reaktion auf externe Actions (z. B. Thunks) |

---

## 🔗 Quellen

- [Redux Toolkit – Einstieg](https://redux-toolkit.js.org/introduction/getting-started)  
- [createSlice Doku](https://redux-toolkit.js.org/api/createSlice)  
- [createAsyncThunk Doku](https://redux-toolkit.js.org/api/createAsyncThunk)

  **[⬆ Наверх](#top)**

114. ### <a name="114"></a> Was ist RTK Query?

# Was ist RTK Query?

**RTK Query** ist eine leistungsstarke Erweiterung von Redux Toolkit,  
die **API-Daten abrufen, cachen, synchronisieren und verwalten** kann –  
ohne manuell Thunks, Reducer oder Actions zu schreiben.

✅ **Ziel**: API-Zugriff mit minimalem Code, integriert in den Redux Store.

---

## 🎯 Vorteile

- 🚀 Automatisches Caching, Refetching, Invalidierung
- 🧼 Weniger Boilerplate als `createAsyncThunk`
- 🔄 Automatische Lade- und Fehlerzustände (`isLoading`, `error`, etc.)
- 🧠 Integriert sich direkt in den Redux-Store

---

## 📦 Installation

```bash
npm install @reduxjs/toolkit react-redux
```

---

## ✅ Beispiel: API-Daten mit RTK Query laden

### 1️⃣ API-Slice erstellen

```js
// services/api.js
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';

export const api = createApi({
  reducerPath: 'api', // automatisch im Store
  baseQuery: fetchBaseQuery({ baseUrl: 'https://jsonplaceholder.typicode.com/' }),
  endpoints: (builder) => ({
    getUsers: builder.query({
      query: () => 'users',
    }),
  }),
});

export const { useGetUsersQuery } = api;
```

---

### 2️⃣ Store konfigurieren

```js
// store.js
import { configureStore } from '@reduxjs/toolkit';
import { api } from './services/api';

export const store = configureStore({
  reducer: {
    [api.reducerPath]: api.reducer,
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(api.middleware),
});
```

---

### 3️⃣ Verwendung in einer Komponente

```jsx
import { useGetUsersQuery } from './services/api';

function UserList() {
  const { data: users, error, isLoading } = useGetUsersQuery();

  if (isLoading) return <p>Lädt...</p>;
  if (error) return <p>Fehler beim Laden</p>;

  return (
    <ul>
      {users.map((u) => (
        <li key={u.id}>{u.name}</li>
      ))}
    </ul>
  );
}
```

---

## 🧠 Caching & Refetching

- RTK Query cached Daten automatisch
- Man kann Daten **invalidieren**, **refetchen**, **polling** aktivieren usw.

```js
getUsers: builder.query({
  query: () => 'users',
  keepUnusedDataFor: 60, // Sekunden
});
```

---

## 📝 Zusammenfassung

| Feature             | Beschreibung                                         |
|---------------------|------------------------------------------------------|
| `createApi`         | Erstellt API-Slice                                   |
| `fetchBaseQuery`    | Basiert auf `fetch()`                                |
| `useXYZQuery()`     | Auto-generierter React-Hook                          |
| `api.middleware`    | Automatische Integration in Redux-Middleware         |
| Vorteile            | Weniger Code, Caching, Refetching, isLoading, error |

---

## 🔗 Quellen

- [RTK Query – Offizielle Docs](https://redux-toolkit.js.org/rtk-query/overview)  
- [API Service mit RTK Query](https://redux-toolkit.js.org/rtk-query/usage)

  **[⬆ Наверх](#top)**

115. ### <a name="115"></a> Was ist der Unterschied zwischen Redux und der Context-API?

# Was ist der Unterschied zwischen Redux und der Context-API?

Sowohl **Redux** als auch die **React Context-API** ermöglichen es,  
**globalen Zustand** in einer Anwendung zu teilen.  
Aber sie unterscheiden sich in **Funktion**, **Skalierbarkeit** und **Zweck**.

---

## 🔍 Vergleich Redux vs Context-API

| Kriterium               | **Redux**                                     | **Context-API**                             |
|-------------------------|-----------------------------------------------|---------------------------------------------|
| 📦 Zweck                | Globales **State-Management mit Logik**       | **Einfaches Teilen** von Daten              |
| 🧠 Zustand              | komplexer, strukturiert (Slices, Reducer)     | einfacher Zustand (z. B. useState)          |
| ⚙ Middleware            | Ja (z. B. Logging, Async mit Thunks)          | Nein                                        |
| 🔁 Updates              | selektiv durch `useSelector`                  | **Alle** Children werden neu gerendert      |
| 🚀 Performance          | effizient durch Trennung von Logik & UI       | kann bei großen Apps Performance-Probleme bringen |
| 🧰 Tooling              | Redux DevTools, RTK, RTK Query                | Keine integrierten Tools                    |
| 📚 Boilerplate          | mehr (aber reduziert durch RTK)               | sehr wenig                                  |
| 🔄 Asynchronität        | `createAsyncThunk`, Middleware                 | manuell über Hooks                          |
| 👨‍👩‍👧‍👦 Zielgruppe        | mittlere bis große Anwendungen                | kleine bis mittlere Komponentenkommunikation |

---

## 📌 Wann Context-API verwenden?

- Themen wie: **Theme, Sprache, Auth-Status**
- Wenn **wenige Werte** in **vielen Komponenten** gebraucht werden
- **Kein komplexes State-Handling** nötig

---

## 📌 Wann Redux verwenden?

- **Viele voneinander abhängige Komponenten**
- Komplexe Logik: **API-Calls, Caching, Optimierung**
- Zustandslogik soll **testbar, strukturiert und erweiterbar** sein
- Zusammenarbeit im Team / skalierbare App

---

## 📝 Zusammenfassung

| React Context            | Gut für **einfache Datenweitergabe** in der App  
| Redux (+RTK)             | Ideal für **komplexes, strukturiertes State-Management**

> Die Context-API ist **kein Ersatz**, sondern eine **Alternative für bestimmte Fälle**.

---

## 🔗 Quellen

- [React Docs – Context API](https://react.dev/learn/passing-data-deeply-with-context)  
- [Redux Toolkit Docs](https://redux-toolkit.js.org)  
- [Vergleich Redux vs Context (Blog)](https://kentcdodds.com/blog/application-state-management-with-react)

  **[⬆ Наверх](#top)**

116. ### <a name="116"></a> Was ist connect() in Redux?

# Was ist `connect()` in Redux?

`connect()` ist eine **höherwertige Funktion (Higher-Order Component)**  
aus der Bibliothek **`react-redux`**, die verwendet wurde,  
um **Klassen- oder Funktionskomponenten** mit dem Redux-Store zu verbinden  
(vor Hooks wie `useSelector`, `useDispatch`).

---

## 📌 Zweck von `connect()`

- Zugriff auf den globalen Redux-State
- Dispatchen von Actions aus der Komponente
- Verbindung von **React-Komponenten mit dem Redux-Store**

---

## ✅ Syntax

```js
connect(mapStateToProps, mapDispatchToProps)(Component)
```

| Argument              | Bedeutung                                                 |
|------------------------|------------------------------------------------------------|
| `mapStateToProps`      | Welche Teile des States als Props in die Komponente kommen |
| `mapDispatchToProps`   | Welche Actions als Props verfügbar gemacht werden sollen   |

---

## 🧱 Beispiel

### 1️⃣ Redux: Actions & Reducer

```js
// counterSlice.js (klassisch ohne Toolkit)
const initialState = { value: 0 };

export function counterReducer(state = initialState, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { value: state.value + 1 };
    default:
      return state;
  }
}

export const increment = () => ({ type: 'INCREMENT' });
```

---

### 2️⃣ Komponente mit `connect()`

```jsx
import React from 'react';
import { connect } from 'react-redux';
import { increment } from './counterSlice';

function Counter({ value, increment }) {
  return (
    <div>
      <p>Wert: {value}</p>
      <button onClick={increment}>+</button>
    </div>
  );
}

const mapStateToProps = (state) => ({
  value: state.counter.value,
});

export default connect(mapStateToProps, { increment })(Counter);
```

---

## 🚫 Heute: lieber Hooks verwenden

Statt `connect()` → moderner Ansatz:

```jsx
import { useSelector, useDispatch } from 'react-redux';

function Counter() {
  const value = useSelector((state) => state.counter.value);
  const dispatch = useDispatch();

  return <button onClick={() => dispatch({ type: 'INCREMENT' })}>+</button>;
}
```

---

## 📝 Zusammenfassung

| `connect()`                   | Alte Methode zur Verbindung mit Redux-Store (HOC)       |
|------------------------------|----------------------------------------------------------|
| `mapStateToProps`            | Wählt Teile des States aus                              |
| `mapDispatchToProps`         | Bindet Action Creators an Props                         |
| ❗ Empfehlung heute           | Lieber `useSelector`, `useDispatch` (funktionale Hooks) |

---

## 🔗 Quellen

- [react-redux – `connect()` Doku](https://react-redux.js.org/api/connect)  
- [React Redux – Hooks vs connect](https://react-redux.js.org/api/hooks)

  **[⬆ Наверх](#top)**

117. ### <a name="117"></a> Was sind Middleware in Redux (z. B. redux-thunk, redux-logger)?

# Was sind Middleware in Redux (z. B. `redux-thunk`, `redux-logger`)?

**Middleware** in Redux sind **Funktionen**, die sich **zwischen `dispatch()` und dem Reducer** schalten.  
Sie ermöglichen erweiterte Funktionen wie:

- asynchrone Aktionen (z. B. API-Calls)
- Logging
- Caching
- Fehlerbehandlung

---

## 🔧 Wie funktioniert Middleware?

```text
dispatch(action) → middleware → reducer → new state
```

Middleware haben Zugriff auf:

- `dispatch`
- `getState`
- `next` (weiterführender Aufruf)
- `action`

---

## ✅ Beispiel: Eigene Middleware

```js
const loggerMiddleware = (store) => (next) => (action) => {
  console.log('Action:', action);
  const result = next(action); // zum nächsten Middleware/Reducer
  console.log('Neuer State:', store.getState());
  return result;
};
```

---

## 🧰 Gängige Middleware

### 1️⃣ `redux-thunk`

Ermöglicht es, **Funktionen statt Objekte** zu dispatchen (für Async-Logik).

```bash
npm install redux-thunk
```

```js
const fetchData = () => async (dispatch) => {
  dispatch({ type: 'FETCH_START' });
  const res = await fetch('/api');
  const data = await res.json();
  dispatch({ type: 'FETCH_SUCCESS', payload: data });
};
```

> Wird automatisch von **Redux Toolkit** mitgeliefert

---

### 2️⃣ `redux-logger`

Protokolliert alle Aktionen und State-Änderungen in der Konsole (Debugging).

```bash
npm install redux-logger
```

```js
import logger from 'redux-logger';

const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(logger),
});
```

---

### 3️⃣ Eigene Middleware integrieren

```js
const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(myMiddleware),
});
```

---

## 📝 Zusammenfassung

| Middleware       | Zweck                                    |
|------------------|-------------------------------------------|
| `redux-thunk`    | Asynchrone Logik (API, Delay, etc.)       |
| `redux-logger`   | Logging von Aktionen & Zuständen          |
| Eigene Middleware| Erweiterung von Dispatch-Logik            |

> Middleware = **flexible Erweiterung** der Redux-Funktionalität.

---

## 🔗 Quellen

- [Redux – Middleware Doku](https://redux.js.org/tutorials/fundamentals/part-4-store#middleware)  
- [redux-logger auf GitHub](https://github.com/LogRocket/redux-logger)  
- [redux-thunk – GitHub](https://github.com/reduxjs/redux-thunk)

  **[⬆ Наверх](#top)**

118. ### <a name="118"></a> Was ist createSelector und wie funktioniert Reselect?

# Was ist `createSelector` und wie funktioniert `reselect`?

**`reselect`** ist eine Bibliothek für **selektives, memoisiertes Selektieren von Zustand** in Redux.  
Das zentrale Feature ist **`createSelector()`**, mit dem du komplexe Ableitungen aus dem Store berechnen kannst –  
**nur wenn sich relevante Teile des Zustands geändert haben**.

---

## 🎯 Ziel

- Performance optimieren
- unnötige Berechnungen und Re-Renders vermeiden
- komplexe Daten aus Store ableiten (z. B. Filter, Map, Reduce)

---

## 🔧 Installation

```bash
npm install reselect
```

---

## ✅ Einfaches Beispiel mit `createSelector`

```js
import { createSelector } from 'reselect';

// Basis-Selector: roher Zugriff auf State
const selectTodos = (state) => state.todos;

// Memoisierter Selector: nur wenn todos sich ändern
export const selectCompletedTodos = createSelector(
  [selectTodos],
  (todos) => todos.filter((todo) => todo.completed)
);
```

📌 `selectCompletedTodos(state)` gibt **nur neue Werte zurück**,  
wenn sich die ursprünglichen `todos` verändert haben.

---

## 🧠 Beispiel im Redux Toolkit Setup

```js
// store.js
const initialState = {
  todos: [
    { id: 1, text: 'Lernen', completed: true },
    { id: 2, text: 'Coden', completed: false },
  ],
};

// selectors.js
import { createSelector } from 'reselect';

const selectTodos = (state) => state.todos;

export const selectIncompleteTodos = createSelector(
  [selectTodos],
  (todos) => todos.filter((t) => !t.completed)
);
```

---

## 🧪 Verwendung im Component

```jsx
import { useSelector } from 'react-redux';
import { selectIncompleteTodos } from './selectors';

function TodoList() {
  const todos = useSelector(selectIncompleteTodos);

  return (
    <ul>
      {todos.map((t) => (
        <li key={t.id}>{t.text}</li>
      ))}
    </ul>
  );
}
```

---

## 📌 Vorteile von `createSelector`

- **Memoisierung**: Caches das Ergebnis bis sich Input-Selektoren ändern
- **Komposition**: Selektoren können andere Selektoren nutzen
- **Performance**: Weniger Re-Render und Berechnungen

---

## 📝 Zusammenfassung

| Begriff           | Beschreibung                                              |
|-------------------|-----------------------------------------------------------|
| `createSelector`  | Memoisierter Selektor für abgeleiteten Zustand            |
| `reselect`        | Bibliothek für performantes Selektieren aus dem Redux-Store |
| Vorteile          | Wiederverwendbar, performant, selektiv                    |

---

## 🔗 Quellen

- [Reselect – GitHub](https://github.com/reduxjs/reselect)  
- [Redux Docs: Computing Derived Data](https://redux.js.org/usage/deriving-data-selectors)

  **[⬆ Наверх](#top)**

119. ### <a name="119"></a> Wie verbindet man Redux mit React über Hooks (useSelector, useDispatch)?

# Wie verbindet man Redux mit React über Hooks (`useSelector`, `useDispatch`)?

Statt der alten `connect()`-Funktion nutzt man in modernen React-Apps  
die **React-Redux Hooks** `useSelector` und `useDispatch`,  
um Komponenten einfach mit dem Redux-Store zu verbinden.

---

## 🧠 `useSelector`

Wird verwendet, um **Daten aus dem Redux-Store** auszulesen.

```jsx
import { useSelector } from 'react-redux';

const count = useSelector((state) => state.counter.value);
```

- Zugriff auf beliebige Teile des States
- Automatisch neu gerendert bei Änderung

---

## ⚙️ `useDispatch`

Gibt die `dispatch`-Funktion zurück, um **Actions zu senden**.

```jsx
import { useDispatch } from 'react-redux';
import { increment } from './counterSlice';

const dispatch = useDispatch();
dispatch(increment());
```

- Ideal in Event-Handlern (`onClick`, `onSubmit`, etc.)

---

## ✅ Beispiel: Counter-Komponente

```jsx
import { useSelector, useDispatch } from 'react-redux';
import { increment, decrement } from './counterSlice';

function Counter() {
  const count = useSelector((state) => state.counter.value);
  const dispatch = useDispatch();

  return (
    <div>
      <p>Wert: {count}</p>
      <button onClick={() => dispatch(increment())}>+</button>
      <button onClick={() => dispatch(decrement())}>–</button>
    </div>
  );
}
```

---

## 🔄 Vergleich: `connect()` vs Hooks

| Alt (connect)                     | Modern (Hooks)              |
|----------------------------------|-----------------------------|
| `mapStateToProps()`              | `useSelector()`             |
| `mapDispatchToProps()`           | `useDispatch()`             |
| Mehr Boilerplate                 | Weniger Code, klarer Stil   |

---

## 📝 Zusammenfassung

| Hook             | Zweck                                     |
|------------------|--------------------------------------------|
| `useSelector`    | Daten aus Redux-Store lesen                |
| `useDispatch`    | Aktionen an den Store senden (dispatch)   |
| Vorteil          | weniger Code, bessere Lesbarkeit, Flexibilität |

---

## 🔗 Quellen

- [React Redux – `useSelector`](https://react-redux.js.org/api/hooks#useselector)  
- [React Redux – `useDispatch`](https://react-redux.js.org/api/hooks#usedispatch)  
- [Redux Toolkit – Einstieg](https://redux-toolkit.js.org/introduction/getting-started)

  **[⬆ Наверх](#top)**

120. ### <a name="120"></a> 



  **[⬆ Наверх](#top)**

121. ### <a name="121"></a> 



  **[⬆ Наверх](#top)**

122. ### <a name="122"></a> 



  **[⬆ Наверх](#top)**

123. ### <a name="123"></a> 



  **[⬆ Наверх](#top)**

124. ### <a name="124"></a> 



  **[⬆ Наверх](#top)**

125. ### <a name="125"></a> 



  **[⬆ Наверх](#top)**

126. ### <a name="126"></a> 



  **[⬆ Наверх](#top)**

127. ### <a name="127"></a> 



  **[⬆ Наверх](#top)**

128. ### <a name="128"></a> 



  **[⬆ Наверх](#top)**

129. ### <a name="129"></a> 



  **[⬆ Наверх](#top)**

130. ### <a name="130"></a> 



  **[⬆ Наверх](#top)**  

131. ### <a name="131"></a> Was ist Code-Splitting?

# Was ist Code-Splitting?

**Code-Splitting** ist eine Technik, mit der du **JavaScript-Bundles in kleinere Teile aufteilst**,  
damit der Browser **nicht alles auf einmal laden muss**, sondern nur das, was wirklich gebraucht wird.

Ziel:  
🚀 **Ladezeit reduzieren**  
📦 **Initiales Bundle kleiner halten**  
📈 **Performance verbessern**

---

## 📦 Warum ist das wichtig?

Ohne Code-Splitting wird deine gesamte Anwendung als ein einziges großes JS-Bundle geladen.  
Das verlangsamt die erste Ladezeit („Initial Load“) – besonders bei großen Apps.

---

## 🚀 Wie funktioniert Code-Splitting in React?

React verwendet **`React.lazy()`** in Kombination mit **`Suspense`** für dynamisches Laden von Komponenten.

---

## ✅ Beispiel mit `React.lazy()` und `Suspense`

```jsx
import React, { Suspense } from 'react';

// Komponente wird nur bei Bedarf geladen
const LazyComponent = React.lazy(() => import('./MyComponent'));

function App() {
  return (
    <div>
      <h1>Meine App</h1>
      <Suspense fallback={<p>Lade...</p>}>
        <LazyComponent />
      </Suspense>
    </div>
  );
}
```

📌 Nur wenn `LazyComponent` wirklich gerendert wird, lädt React den zugehörigen Code.

---

## 🧩 Dynamisches Routing mit Code-Splitting

In Kombination mit `react-router-dom`:

```jsx
const Home = React.lazy(() => import('./pages/Home'));
const About = React.lazy(() => import('./pages/About'));

<Routes>
  <Route path="/" element={
    <Suspense fallback={<p>Lade Startseite...</p>}>
      <Home />
    </Suspense>
  } />
  <Route path="/about" element={
    <Suspense fallback={<p>Lade Info...</p>}>
      <About />
    </Suspense>
  } />
</Routes>
```

---

## 📁 Webpack & Vite

Code-Splitting wird meist vom **Bundler** übernommen:
- `webpack`: automatisch bei `import()`
- `vite`: unterstützt dynamisches Importieren nativ

---

## 📝 Zusammenfassung

| Begriff          | Beschreibung                                |
|------------------|---------------------------------------------|
| `React.lazy()`   | dynamisches Laden von Komponenten           |
| `Suspense`       | zeigt Fallback während des Ladens           |
| Vorteil          | schnelleres Initial-Loading                 |
| Einsatzbereiche  | große Seiten, Routen, selten genutzte Features |

---

## 🔗 Quellen

- [React – Code-Splitting](https://react.dev/learn/code-splitting)  
- [MDN – Code Splitting](https://developer.mozilla.org/en-US/docs/Glossary/Code_splitting)

  **[⬆ Наверх](#top)**

132. ### <a name="132"></a> Wie funktionieren React.lazy und Suspense?

# Wie funktionieren `React.lazy` und `Suspense`?

Mit `React.lazy()` und `Suspense` kannst du **Komponenten dynamisch (on-demand) laden**,  
anstatt sie beim Initial-Load in das Hauptbundle einzuschließen.

➡️ Das nennt man **Code-Splitting auf Komponentenebene**.

---

## 🧩 `React.lazy()`

Mit `React.lazy()` definierst du eine **dynamisch importierte Komponente**.

```jsx
const LazyComponent = React.lazy(() => import('./MyComponent'));
```

📌 Der Code von `MyComponent` wird **erst geladen**, wenn sie **wirklich gerendert** wird.

---

## ⏳ `Suspense`

Da das Laden asynchron ist, brauchst du `Suspense`,  
um einen **Fallback (z. B. Ladeanzeige)** zu zeigen, während die Komponente lädt.

```jsx
import React, { Suspense } from 'react';

function App() {
  return (
    <div>
      <h1>Meine App</h1>
      <Suspense fallback={<p>Lädt…</p>}>
        <LazyComponent />
      </Suspense>
    </div>
  );
}
```

- `fallback` zeigt die UI während des Ladevorgangs
- Der Fallback kann beliebig sein: Spinner, Skeleton, Text, etc.

---

## 📂 Beispiel mit mehreren Lazy-Komponenten

```jsx
const Home = React.lazy(() => import('./pages/Home'));
const About = React.lazy(() => import('./pages/About'));

function App() {
  return (
    <Suspense fallback={<p>Lade Seite…</p>}>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
      </Routes>
    </Suspense>
  );
}
```

---

## 📌 Einschränkungen

- `React.lazy()` funktioniert **nur für Default-Exports**  
- Bei Fehlern beim Laden solltest du **Error Boundaries** verwenden  
- Suspense funktioniert aktuell **nicht für Datenfetching ohne weitere Libs** (außer mit `React 18` + Server Components oder Libs wie `React Query`, `Relay`)

---

## 📝 Zusammenfassung

| Methode             | Beschreibung                                |
|---------------------|---------------------------------------------|
| `React.lazy()`      | dynamisches Importieren einer Komponente    |
| `Suspense`          | zeigt Fallback während Ladevorgang          |
| Vorteil             | schnelleres Initial-Loading, besseres UX    |

---

## 🔗 Quellen

- [React.dev – Code-Splitting](https://react.dev/learn/code-splitting)  
- [React.dev – `React.lazy`](https://react.dev/reference/react/lazy)  
- [React.dev – `Suspense`](https://react.dev/reference/react/Suspense)

  **[⬆ Наверх](#top)**

133. ### <a name="133"></a> Was ist Tree Shaking?

# Was ist Tree Shaking?

**Tree Shaking** ist ein Optimierungsverfahren beim **JavaScript-Bundling**,  
das **nicht verwendeten (toten) Code automatisch entfernt**  
→ dadurch wird das finale Bundle kleiner und die Ladezeit schneller.

---

## 🧠 Wie funktioniert Tree Shaking?

Tree Shaking analysiert den **Modul-Import-Baum** (Import-Tree)  
und entfernt **unbenutzte Exporte** aus ES6+ Modulen.

➡️ Voraussetzung: Der Code muss **modular** und **statisch analysierbar** sein (ES Modules).

---

## ✅ Beispiel

```js
// utils.js
export function used() {
  console.log('wird verwendet');
}

export function unused() {
  console.log('wird nie verwendet');
}

// main.js
import { used } from './utils.js';

used();
```

➡️ Beim Bundling (z. B. mit `webpack`, `vite`) wird `unused()` **eliminiert**,  
weil sie **nirgendwo verwendet wird**.

---

## 📦 Voraussetzung für Tree Shaking

| Anforderung             | Erklärung                              |
|--------------------------|-----------------------------------------|
| ✅ ES Modules (`import`) | Kein `require()` oder CommonJS          |
| ✅ statische Imports     | keine dynamischen `import(expr)`        |
| ✅ kein Side-Effect      | Modul darf keine Seiteneffekte enthalten |

---

## 📁 `package.json` mit `"sideEffects": false`

Damit der Bundler weiß, dass ein Modul **keine Nebenwirkungen hat**:

```json
{
  "name": "mein-paket",
  "sideEffects": false
}
```

➡️ Dadurch kann Tree Shaking aggressiver arbeiten.

---

## 🚫 Was wird *nicht* entfernt?

- Dynamisch importierter Code
- Code mit Seiteneffekten (`console.log`, DOM-Zugriff)
- Nicht als Modul geschriebene Dateien (CommonJS)

---

## 📝 Zusammenfassung

| Begriff        | Bedeutung                                  |
|----------------|---------------------------------------------|
| Tree Shaking   | Entfernt ungenutzten Code aus Bundles       |
| Voraussetzung  | ES Module, statische Imports, keine Side-Effects |
| Tools          | Webpack, Rollup, Vite, esbuild              |

---

## 🔗 Quellen

- [MDN – Tree Shaking](https://developer.mozilla.org/en-US/docs/Glossary/Tree_shaking)  
- [webpack – Tree Shaking](https://webpack.js.org/guides/tree-shaking/)  
- [Rollup – Tree Shaking](https://rollupjs.org/guide/en/#tree-shaking)

  **[⬆ Наверх](#top)**

134. ### <a name="134"></a> Was ist Server-Side Rendering (SSR) und Hydration?

# Was ist Server-Side Rendering (SSR) und Hydration?

**Server-Side Rendering (SSR)** ist eine Technik, bei der **React-Komponenten auf dem Server in HTML umgewandelt**  
und an den Browser gesendet werden – **bevor** JavaScript im Browser ausgeführt wird.

**Hydration** bedeutet, dass React im Browser den **interaktiven Zustand** (Events, State etc.)  
auf das **vom Server gelieferte HTML** anwendet.

---

## 📦 Warum SSR verwenden?

| Vorteil                             | Beschreibung                                           |
|-------------------------------------|--------------------------------------------------------|
| ⏱ Schnellere erste Ladezeit         | HTML ist sofort da, auch ohne JS                      |
| 🔍 Bessere SEO                      | Crawler sehen direkt fertiges HTML                    |
| 📡 Besser bei langsamen Verbindungen | Seite funktioniert teilweise, auch ohne JS sofort     |

---

## 🔁 SSR Ablauf (vereinfacht)

```text
1. Client sendet Anfrage an Server
2. Server rendert React-Komponenten → HTML
3. HTML wird an Browser gesendet
4. Browser zeigt HTML
5. React wird im Hintergrund geladen → Hydration
6. Seite wird interaktiv
```

---

## 🔧 Beispiel mit Next.js (SSR + Hydration)

```js
// pages/index.jsx
export default function Home({ name }) {
  return <h1>Hallo {name}</h1>;
}

export async function getServerSideProps() {
  return { props: { name: 'Sergii' } };
}
```

➡️ `getServerSideProps()` rendert die Seite **bei jeder Anfrage auf dem Server**.

---

## 💧 Was ist Hydration?

Nach dem Server-Render muss React im Browser:

- das **gerenderte HTML übernehmen**
- es mit **Event-Handlern und State** verbinden

➡️ Dieser Vorgang heißt **Hydration** und geschieht automatisch bei z. B. Next.js oder Remix.

---

## 🧠 Vergleich: CSR vs SSR

| Merkmal              | Client-Side Rendering (CSR)          | Server-Side Rendering (SSR)              |
|----------------------|--------------------------------------|------------------------------------------|
| Initiales HTML       | Leeres `div#root`                    | Vollständiges HTML                       |
| Ladegeschwindigkeit  | Langsamer Start                      | Schneller First Paint                    |
| SEO                  | Eingeschränkt                        | Sehr gut                                 |
| Umsetzung            | CRA, Vite                            | Next.js, Remix                           |

---

## 📝 Zusammenfassung

| Begriff       | Bedeutung                                                                |
|---------------|---------------------------------------------------------------------------|
| SSR           | React rendert HTML auf dem Server → schneller Start + bessere SEO        |
| Hydration     | React macht servergerendertes HTML im Browser interaktiv                 |
| Tools         | `Next.js`, `Remix`, `express + react-dom/server`                         |

---

## 🔗 Quellen

- [React – Rendering on the Server](https://react.dev/learn/rendering-on-the-server)  
- [Next.js – SSR](https://nextjs.org/docs/pages/building-your-application/rendering/server-side-rendering)  
- [MDN – Hydration](https://developer.mozilla.org/en-US/docs/Glossary/Hydration)

  **[⬆ Наверх](#top)**

135. ### <a name="135"></a> Wie geht man mit Hydration-Fehlern bei SSR um?

# Wie geht man mit Hydration-Fehlern bei SSR um?

**Hydration-Fehler** entstehen, wenn der HTML-Code vom Server  
nicht exakt mit dem initialen React-Render im Browser übereinstimmt.

➡️ React zeigt dann Warnungen wie:

```text
Warning: Text content did not match.
Server: "A" | Client: "B"
```

---

## 🔍 Ursachen von Hydration-Problemen

| Ursache                                  | Beschreibung                                              |
|------------------------------------------|-----------------------------------------------------------|
| 🕓 Unterschiedlicher Zustand (z. B. Datum, Zufallszahl) | Server & Client generieren unterschiedliche Inhalte        |
| 🧠 Zugriff auf `window`, `document`       | Nur im Browser verfügbar → auf dem Server Fehler          |
| 🧭 Unterschiedliches Rendering je nach Umgebung | z. B. Sprache, Zeit, Browser                              |

---

## ✅ Best Practices zur Vermeidung

### 1️⃣ **Nur im Browser ausführen** (`useEffect`)

```jsx
import { useEffect, useState } from 'react';

function ClientOnlyDate() {
  const [now, setNow] = useState(null);

  useEffect(() => {
    setNow(new Date().toLocaleTimeString());
  }, []);

  return <p>Uhrzeit: {now ?? 'Lädt...'}</p>;
}
```

> ✅ Wird **nicht** beim Server-Render ausgeführt → keine Hydration-Probleme

---

### 2️⃣ **`typeof window !== 'undefined'` prüfen**

```js
if (typeof window !== 'undefined') {
  const width = window.innerWidth;
}
```

---

### 3️⃣ **Client-Only-Komponenten auslagern**

In Next.js:

```jsx
'use client';

import dynamic from 'next/dynamic';

const NoSSRComponent = dynamic(() => import('./ClientComponent'), {
  ssr: false,
});
```

➡️ Die Komponente wird **nur im Browser** geladen und gerendert.

---

### 4️⃣ **Gleiches HTML auf Server und Client erzeugen**

- Keine `Math.random()`, `Date.now()`, `Intl`, etc. im JSX während SSR
- Vermeide bedingtes Rendering auf Basis von Umgebungen

---

## 🧪 Hydration-Fehler erkennen

- **Entwicklermodus** zeigt Warnungen in der Konsole
- Tools wie **React DevTools** und **Lighthouse** können helfen

---

## 📝 Zusammenfassung

| Problem                   | Unterschied zwischen Server-HTML und Client-Render         |
|---------------------------|------------------------------------------------------------|
| Ursachen                  | Zustand, Zeit, Zufall, Browser-APIs                        |
| Lösung                    | `useEffect`, `typeof window`, `dynamic(ssr: false)`        |
| Ziel                      | Server-HTML = Client-HTML vor Hydration                    |

---

## 🔗 Quellen

- [React – Hydration Errors](https://react.dev/reference/react-dom/client/hydrateRoot#hydration-errors)  
- [Next.js – Avoiding Hydration Mismatches](https://nextjs.org/docs/messages/react-hydration-error)  
- [MDN – Hydration](https://developer.mozilla.org/en-US/docs/Glossary/Hydration)

  **[⬆ Наверх](#top)**

136. ### <a name="136"></a> Was bedeutet Virtualisierung (z. B. mit react-window)?

# Was bedeutet Virtualisierung (z. B. mit `react-window`)?

**Virtualisierung** ist eine Technik zur **leistungsoptimierten Darstellung großer Listen**,  
indem **nur die sichtbaren Elemente** im DOM gerendert werden –  
statt Tausende gleichzeitig.

📦 Bekannte Libraries:  
- `react-window` (leicht & schnell)  
- `react-virtualized` (umfangreicher)

---

## 🧠 Warum Virtualisierung?

| Problem bei großen Listen       | Lösung durch Virtualisierung             |
|----------------------------------|------------------------------------------|
| 🚫 Langsames Rendering (1000+ DOM-Elemente) | ✅ Nur sichtbarer Bereich wird gerendert |
| 📉 Hoher Speicherverbrauch       | ✅ Geringe DOM-Last                       |
| 😵 Unnötige Repaints/Updates     | ✅ Bessere Performance                    |

---

## ✅ Beispiel mit `react-window`

### 1️⃣ Installation

```bash
npm install react-window
```

---

### 2️⃣ Code-Beispiel

```jsx
import { FixedSizeList as List } from 'react-window';

const Row = ({ index, style }) => (
  <div style={style}>Zeile #{index}</div>
);

function VirtualizedList() {
  return (
    <List
      height={300}        // sichtbare Höhe
      itemCount={1000}    // Anzahl der Elemente
      itemSize={35}       // Höhe jedes Eintrags (px)
      width="100%"        // Breite
    >
      {Row}
    </List>
  );
}
```

➡️ Nur die Elemente im sichtbaren Bereich (z. B. 10–20 Zeilen)  
werden tatsächlich ins DOM gerendert.

---

## 📌 Unterschied: Pagination vs. Virtualisierung

| Technik          | Beschreibung                              |
|------------------|-------------------------------------------|
| Pagination       | Seite für Seite, Daten werden nachgeladen |
| Virtualisierung  | Alles im Speicher, aber nur sichtbarer Teil im DOM |

---

## 📈 Vorteile

- 🚀 Schnelles Scrollen auch bei 10.000+ Einträgen
- 📦 Sehr kleine DOM-Größe
- 🔄 Reduziert Re-Renders und Speicherverbrauch

---

## 📝 Zusammenfassung

| Begriff           | Erklärung                                               |
|-------------------|----------------------------------------------------------|
| Virtualisierung   | Rendert nur sichtbare UI-Elemente                        |
| `react-window`    | Minimalistische Library für Listen-/Grid-Virtualisierung |
| Einsatzbereich    | Große Tabellen, Listen, Menüs                            |

---

## 🔗 Quellen

- [react-window – GitHub](https://github.com/bvaughn/react-window)  
- [react-window – Doku & Beispiele](https://react-window.vercel.app/)  
- [Artikel: Virtualisierung erklärt](https://blog.logrocket.com/using-react-window-for-efficient-list-rendering/)

  **[⬆ Наверх](#top)**

137. ### <a name="137"></a> Wie verhindert man unnötige Re-Renders?

# Wie verhindert man unnötige Re-Renders in React?

**Unnötige Re-Renders** entstehen, wenn eine Komponente erneut rendert,  
obwohl sich ihr sichtbarer Output nicht geändert hat.  
Das kann zu **Performance-Problemen** führen – besonders bei großen Apps.

---

## ✅ Techniken zur Optimierung

### 1️⃣ `React.memo` (für Funktionskomponenten)

Verhindert Re-Render, wenn Props **gleich bleiben**.

```jsx
const MyComponent = React.memo(function MyComponent({ name }) {
  return <p>{name}</p>;
});
```

➡️ Vergleich erfolgt **flach (shallow)** – bei komplexen Objekten ggf. manuell optimieren.

---

### 2️⃣ `useMemo` (für berechnete Werte)

Memoisiert einen Rückgabewert, wenn sich Abhängigkeiten **nicht geändert** haben.

```jsx
const expensiveValue = useMemo(() => computeHeavy(a, b), [a, b]);
```

➡️ Ideal für teure Berechnungen (Filter, Sortierung usw.)

---

### 3️⃣ `useCallback` (für stabile Funktions-Referenzen)

Verhindert, dass Funktionen bei jedem Render neu erzeugt werden.

```jsx
const handleClick = useCallback(() => {
  doSomething();
}, []);
```

➡️ Nützlich, wenn Props als Callback an `React.memo`-Komponenten übergeben werden.

---

### 4️⃣ `shouldComponentUpdate` (bei Klassenkomponenten)

Steuert manuell, ob ein Re-Render nötig ist.

```js
shouldComponentUpdate(nextProps, nextState) {
  return nextProps.value !== this.props.value;
}
```

➡️ Alternative: `PureComponent`, das das automatisch macht (flacher Vergleich).

---

### 5️⃣ Selektives `useSelector` in Redux

Vermeide globale Re-Renders durch präzise Selektoren:

```jsx
const value = useSelector((state) => state.counter.value);
```

➡️ Keine Abhängigkeit von globalem State, wenn nicht nötig.

---

### 6️⃣ Komponentenaufteilung (Component Splitting)

Teile große Komponenten in kleinere auf,  
damit nur betroffene Teile neu gerendert werden.

---

### 7️⃣ Props vermeiden, die sich ständig ändern

Beispiel:

```jsx
// Schlechter Stil: erzeugt neues Objekt bei jedem Render
<Component config={{ a: 1 }} />

// Besser: config als useMemo oder aus dem State
```

---

## 📝 Zusammenfassung

| Technik          | Zweck                                               |
|------------------|------------------------------------------------------|
| `React.memo`     | Memoisiert Funktionskomponenten                     |
| `useMemo`        | Memoisiert Rückgabewerte von Funktionen             |
| `useCallback`    | Verhindert neue Funktionsreferenzen                 |
| `shouldComponentUpdate` | Kontrolle über Updates in Klassen             |
| Genaue `useSelector`    | Vermeidet unnötige Redux-abhängige Re-Renders |

---

## 🔗 Quellen

- [React Docs – Optimizing Performance](https://react.dev/learn/optimizing-performance)  
- [React.memo – Referenz](https://react.dev/reference/react/memo)  
- [useMemo – Referenz](https://react.dev/reference/react/useMemo)  
- [useCallback – Referenz](https://react.dev/reference/react/useCallback)

  **[⬆ Наверх](#top)**

138. ### <a name="138"></a> Was ist React Transition Group?

# Was ist React Transition Group?

**React Transition Group** ist eine React-Bibliothek für **einfache Animationen und Übergänge**,  
z. B. beim Einblenden, Ausblenden oder Ändern von Komponenten im DOM.

➡️ Sie steuert **den Zeitpunkt**, wann eine Komponente in den DOM eingefügt oder entfernt wird  
und bietet dafür passende CSS-Klassen.

---

## 📦 Installation

```bash
npm install react-transition-group
```

---

## 📚 Wichtige Komponenten

| Komponente         | Zweck                                         |
|--------------------|-----------------------------------------------|
| `<Transition>`     | Kontrolle über Mount/Unmount mit Übergang     |
| `<CSSTransition>`  | Wie `<Transition>`, aber mit CSS-Klassen      |
| `<SwitchTransition>` | Übergang zwischen zwei exklusiven Komponenten |
| `<TransitionGroup>` | Sammlung mehrerer animierter Komponenten     |

---

## ✅ Beispiel mit `CSSTransition`

```jsx
import { CSSTransition } from 'react-transition-group';
import './styles.css';

function Example({ show }) {
  return (
    <CSSTransition
      in={show}
      timeout={300}
      classNames="fade"
      unmountOnExit
    >
      <div className="box">Ich werde animiert!</div>
    </CSSTransition>
  );
}
```

---

## 🎨 CSS für Animation

```css
.fade-enter {
  opacity: 0;
}
.fade-enter-active {
  opacity: 1;
  transition: opacity 300ms;
}

.fade-exit {
  opacity: 1;
}
.fade-exit-active {
  opacity: 0;
  transition: opacity 300ms;
}
```

---

## 🧠 Warum `Transition Group`?

- Nutzt **kein JavaScript-Animationstool**, sondern **CSS-Animationen**
- Arbeitet direkt mit dem React-Lifecycle (`mount`, `unmount`)
- Kompatibel mit Conditional Rendering (`{show && <Component />}`)

---

## 📝 Zusammenfassung

| Begriff              | Beschreibung                              |
|----------------------|-------------------------------------------|
| `React Transition Group` | Animation von Komponenten über Lebenszyklus |
| `CSSTransition`      | Automatisiert Klassenwechsel für CSS-Animation |
| Vorteil              | Leichtgewichtig, flexibel, kein Fremdanimationstool nötig |

---

## 🔗 Quellen

- [React Transition Group – Doku](https://reactcommunity.org/react-transition-group/)  
- [Beispiel: CSSTransition](https://reactcommunity.org/react-transition-group/css-transition)

  **[⬆ Наверх](#top)**

139. ### <a name="139"></a> Was ist React Strict Mode und welche Vorteile bietet er?

# Was ist React Strict Mode und welche Vorteile bietet er?

**`React.StrictMode`** ist eine Wrapper-Komponente von React,  
die **zusätzliche Prüfungen und Warnungen** im Entwicklungsmodus aktiviert.  
➡️ Ziel: **Fehler frühzeitig erkennen** und **zukünftige Probleme vermeiden**.

📌 Wichtig: Strict Mode **hat keine Auswirkungen im Produktions-Build**.

---

## 🧱 Verwendung

```jsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
```

---

## ✅ Vorteile und Prüfungen

| Prüfung / Verhalten                      | Beschreibung                                         |
|------------------------------------------|------------------------------------------------------|
| 🔁 Doppelte Aufrufe von Lifecycles        | z. B. `useEffect`, `constructor` → zur Fehlererkennung |
| ⚠️ Veraltete Methoden erkennen            | z. B. `componentWillMount` (nicht mehr empfohlen)    |
| 🧵 Unerwünschte Side-Effects aufdecken    | durch mehrfaches Mounten/Unmounten simuliert        |
| 🚨 Warnungen bei Legacy-API-Nutzung       | z. B. `findDOMNode()`, veraltete Context-API         |
| 🚧 Vorbereitung auf zukünftige Features   | z. B. automatische Batching oder Concurrent Mode     |

---

## 🧪 Beispiel: doppeltes `useEffect`

```jsx
useEffect(() => {
  console.log('läuft');
}, []);
```

➡️ Im Strict Mode erscheint `läuft` **zweimal in der Konsole** – aber nur im Dev-Modus.  
Das ist **beabsichtigt**, um **unsichere Nebeneffekte aufzudecken**.

---

## 📝 Zusammenfassung

| Merkmal            | Beschreibung                                           |
|--------------------|--------------------------------------------------------|
| `StrictMode`       | React-Tool zur Entwicklungssicherheit                  |
| Nur Dev-Modus      | Keine Auswirkungen auf Produktion                      |
| Vorteile           | Warnungen, doppelte Checks, frühe Fehlererkennung      |

---

## 🔗 Quellen

- [React – Strict Mode](https://react.dev/reference/react/StrictMode)  
- [React – Stricter Effects](https://react.dev/learn/strict-mode#ensuring-reusable-state)

  **[⬆ Наверх](#top)**

140. ### <a name="140"></a> Was ist Concurrent Mode und welche Probleme löst er?

# Was ist Concurrent Mode und welche Probleme löst er?

**Concurrent Mode** (in React 18 als **Concurrent Features** bezeichnet) ist ein moderner Render-Modus,  
der React erlaubt, **Rendering-Aufgaben zu unterbrechen, zu pausieren und fortzusetzen**,  
um eine **reaktionsschnellere und flüssigere Benutzeroberfläche** zu ermöglichen.

➡️ Ziel: **Asynchrones, prioritätsbasiertes und unterbrechbares Rendering**.

---

## 🧠 Probleme im traditionellen Modus

| Problem                          | Erklärung                                                  |
|----------------------------------|-------------------------------------------------------------|
| 😵 Blockierendes Rendering        | Langsame Komponenten blockieren die ganze UI               |
| 🕓 Lange Ladezeiten bei Übergängen | Kein Feedback für Nutzer bei langsamer Datenverarbeitung   |
| 😡 Kein Abbruch laufender Updates | Bei schnellen Änderungen wird trotzdem alles gerendert     |

---

## ✅ Vorteile von Concurrent Mode

| Feature                     | Beschreibung                                                   |
|-----------------------------|----------------------------------------------------------------|
| 🧵 Unterbrechbares Rendering | React kann rendering pausieren und später fortsetzen          |
| 🗂 Priorisierung             | Wichtige Updates (z. B. Eingaben) können vorgezogen werden     |
| 🪄 Automatisches Batching   | Mehrere `setState` Calls werden automatisch zusammengefasst    |
| 🌀 Übergänge (`startTransition`) | Übergänge erscheinen flüssiger, weniger „UI-Freeze“         |
| 🧪 Verbesserung für SSR + Streaming | Bessere Unterstützung für `Suspense` & Server Components |

---

## ⚙️ Aktivierung (React 18+)

Concurrent Mode ist **automatisch verfügbar** in React 18,  
wenn du **`createRoot()`** verwendest (statt `ReactDOM.render`):

```jsx
import ReactDOM from 'react-dom/client';
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);
```

---

## 🧭 Beispiel mit `startTransition`

```jsx
import { useState, startTransition } from 'react';

function Search({ items }) {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);

  const handleChange = (e) => {
    const value = e.target.value;
    setQuery(value);

    startTransition(() => {
      const filtered = items.filter((item) => item.includes(value));
      setResults(filtered);
    });
  };

  return (
    <>
      <input value={query} onChange={handleChange} />
      <ul>{results.map((r) => <li key={r}>{r}</li>)}</ul>
    </>
  );
}
```

➡️ `startTransition` markiert den Filtervorgang als **niedrige Priorität**,  
damit Eingaben ohne Verzögerung verarbeitet werden.

---

## 📝 Zusammenfassung

| Begriff           | Beschreibung                                                         |
|-------------------|----------------------------------------------------------------------|
| Concurrent Mode   | Neuer React-Modus mit unterbrechbarem, priorisiertem Rendering       |
| Vorteile          | Bessere UX, kein UI-Freeze, schnellere Reaktion auf Nutzeraktionen   |
| Tools             | `createRoot`, `startTransition`, `Suspense`, automatische Batching   |

---

## 🔗 Quellen

- [React – Concurrent Mode](https://react.dev/learn/synchronizing-with-effects#concurrent-rendering)  
- [React 18 – Neue Features](https://reactjs.org/blog/2022/03/29/react-v18.html)  
- [startTransition – API](https://react.dev/reference/react/startTransition)

  **[⬆ Наверх](#top)**  

141. ### <a name="141"></a> 



  **[⬆ Наверх](#top)**

142. ### <a name="142"></a> 



  **[⬆ Наверх](#top)**

143. ### <a name="143"></a> 



  **[⬆ Наверх](#top)**

144. ### <a name="144"></a> 



  **[⬆ Наверх](#top)**

145. ### <a name="145"></a> 



  **[⬆ Наверх](#top)**

146. ### <a name="146"></a> Was ist ein Service Worker?

# Was ist ein Service Worker?

Ein **Service Worker** ist ein **hintergrundaktives JavaScript-Skript**,  
das **zwischen der Webanwendung und dem Netzwerk** steht.  
Es läuft **außerhalb der Hauptseite**, kann Netzwerk-Anfragen abfangen,  
Antworten cachen und Funktionen wie **Offline-Unterstützung** oder **Push-Benachrichtigungen** ermöglichen.

---

## 🔧 Eigenschaften

| Merkmal              | Beschreibung                                                |
|----------------------|-------------------------------------------------------------|
| Läuft im Hintergrund | Unabhängig vom DOM und UI-Thread                            |
| Ereignisgesteuert    | Reagiert auf `fetch`, `install`, `activate`, `push` etc.   |
| Offline-fähig        | Kann Anfragen aus dem Cache bedienen                        |
| Keine direkte DOM-Zugriff | Arbeitet mit `postMessage()` zur Kommunikation        |

---

## ✅ Typische Anwendungsfälle

- 📴 Offline-Webseiten (z. B. PWA)
- ⚡️ Schnellere Ladezeiten durch Caching
- 📡 Hintergrund-Synchronisierung
- 🔔 Push-Benachrichtigungen

---

## 📁 Lebenszyklus

1. **Registrierung**

```js
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js')
    .then(() => console.log('SW registriert'))
    .catch((err) => console.error('SW Fehler', err));
}
```

2. **Installation**

```js
self.addEventListener('install', (event) => {
  console.log('Service Worker installiert');
});
```

3. **Aktivierung**

```js
self.addEventListener('activate', (event) => {
  console.log('Service Worker aktiviert');
});
```

4. **Anfragen abfangen (`fetch`)**

```js
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request)
      .then((response) => response || fetch(event.request))
  );
});
```

---

## ⚠️ Einschränkungen

| Einschränkung            | Grund                                       |
|---------------------------|---------------------------------------------|
| Nur über HTTPS            | Aus Sicherheitsgründen                      |
| Kein DOM-Zugriff          | Nur über Messaging                         |
| Komplexe Caching-Strategien | Erfordert manuelles Cache-Management     |

---

## 📝 Zusammenfassung

| Begriff         | Beschreibung                                        |
|------------------|-----------------------------------------------------|
| Service Worker   | JS-Skript im Hintergrund, kontrolliert Netzwerk     |
| Vorteil          | Offline-Funktion, schnelleres Laden, Push-Services  |
| Tools            | `navigator.serviceWorker`, `Cache API`, `fetch`     |

---

## 🔗 Quellen

- [MDN – Service Workers](https://developer.mozilla.org/de/docs/Web/API/Service_Worker_API)  
- [Google Web – Service Worker Guide](https://developer.chrome.com/docs/workbox/service-worker-overview/)  
- [Web.dev – Learn Service Workers](https://web.dev/learn/pwa/service-workers/)

  **[⬆ Наверх](#top)**

147. ### <a name="147"></a> Was ist react-helmet und wie hilft es beim SEO?

# Was ist `react-helmet` und wie hilft es beim SEO?

**`react-helmet`** ist eine React-Bibliothek, mit der du dynamisch den `<head>`-Bereich  
deiner Anwendung verwalten kannst – z. B. Titel, Meta-Tags, Open Graph Daten etc.

➡️ Besonders hilfreich für **SEO**, **Social Sharing** und **dynamische Inhalte** bei React-SPAs.

---

## 📦 Installation

```bash
npm install react-helmet
```

---

## ✅ Verwendung

```jsx
import { Helmet } from 'react-helmet';

function MyPage() {
  return (
    <>
      <Helmet>
        <title>Meine Seite – React</title>
        <meta name="description" content="Beschreibung der Seite für SEO." />
        <meta property="og:title" content="OpenGraph Titel" />
      </Helmet>
      <h1>Willkommen</h1>
    </>
  );
}
```

➡️ Die `<head>`-Elemente werden zur Laufzeit aktualisiert.

---

## 🔍 SEO-Vorteile

| Vorteil                          | Beschreibung                                      |
|----------------------------------|---------------------------------------------------|
| 🧠 Dynamischer `<title>`         | Je nach Seite oder Route individuell anpassbar    |
| 🔍 Meta-Tags optimierbar         | Bessere Sichtbarkeit bei Google, Bing usw.        |
| 📲 OpenGraph / Twitter Cards     | Attraktive Vorschauen bei Social-Media-Teilen     |
| 🌐 hreflang, Canonical etc.      | Internationale SEO / Duplicate Content vermeiden  |

---

## 🛠 Alternative für SSR-Umgebungen

Bei **Server-Side Rendering (z. B. Next.js)** wird `react-helmet` oft ersetzt durch:

- `next/head` (Next.js)
- `@remix-run/react` → `<Meta />`

➡️ Diese Lösungen integrieren sich besser mit SSR und liefern **Head-Infos direkt im initialen HTML**.

---

## 📝 Zusammenfassung

| Begriff         | Beschreibung                                       |
|------------------|----------------------------------------------------|
| `react-helmet`   | Bibliothek zur Verwaltung von `<head>`-Tags       |
| Nutzen           | Verbesserte SEO, bessere Social-Media-Darstellung |
| Typische Tags    | `<title>`, `<meta>`, OpenGraph, Canonical-Links   |

---

## 🔗 Quellen

- [react-helmet – GitHub](https://github.com/nfl/react-helmet)  
- [react-helmet – Dokumentation](https://www.npmjs.com/package/react-helmet)  
- [MDN – Meta-Tags für SEO](https://developer.mozilla.org/de/docs/Learn/HTML/Introduction_to_HTML/The_head_metadata_in_HTML)

  **[⬆ Наверх](#top)**

148. ### <a name="148"></a> Wie funktioniert Lazy Loading mit dynamic import()?

# Wie funktioniert Lazy Loading mit `dynamic import()`?

**Lazy Loading** bedeutet, dass Module oder Komponenten **erst bei Bedarf** geladen werden –  
nicht beim Initial-Load.  
Mit `dynamic import()` kannst du in JavaScript oder React **Code-Splitting** betreiben  
und so die **Ladezeit und Performance verbessern**.

---

## 📦 Syntax: `import()` als Funktion

```js
import('./modul.js').then((modul) => {
  modul.doSomething();
});
```

- Gibt ein **Promise** zurück  
- Lädt das Modul **asynchron**

---

## ✅ Verwendung in React mit `React.lazy()`

```jsx
import React, { Suspense } from 'react';

const LazyComponent = React.lazy(() => import('./MyComponent'));

function App() {
  return (
    <Suspense fallback={<p>Lädt…</p>}>
      <LazyComponent />
    </Suspense>
  );
}
```

📌 Nur wenn `LazyComponent` gerendert werden soll, wird es mit `import()` geladen.

---

## 🧠 Vorteile von Lazy Loading

| Vorteil                 | Beschreibung                                 |
|--------------------------|----------------------------------------------|
| 🚀 Schnellere Initial-Ladezeit | Nur kritischer Code wird zuerst geladen       |
| 📦 Kleineres Bundle         | Spart Speicher und Traffic                   |
| 📲 Besseres Nutzererlebnis  | Schnellerer Page Load → weniger Wartezeit     |

---

## 🌍 Beispiel: Lazy Loading bei Routen (mit `react-router`)

```jsx
const Home = React.lazy(() => import('./pages/Home'));
const About = React.lazy(() => import('./pages/About'));

<Routes>
  <Route path="/" element={
    <Suspense fallback={<p>Home lädt…</p>}>
      <Home />
    </Suspense>
  } />
  <Route path="/about" element={
    <Suspense fallback={<p>About lädt…</p>}>
      <About />
    </Suspense>
  } />
</Routes>
```

---

## ⚠️ Einschränkungen

| Einschränkung            | Beschreibung                                |
|---------------------------|---------------------------------------------|
| Nur Default-Exports       | `React.lazy()` funktioniert nur mit Default |
| Suspense erforderlich     | Ohne `Suspense` keine Anzeige beim Laden    |
| Kein SSR-Support direkt   | Nur clientseitiges Lazy Loading             |

---

## 📝 Zusammenfassung

| Begriff             | Beschreibung                                     |
|----------------------|--------------------------------------------------|
| `import()`           | Asynchrone Modul-Ladung                          |
| `React.lazy()`       | Lazy Loading von React-Komponenten               |
| Vorteil              | Code-Splitting, schnellere Ladezeit              |

---

## 🔗 Quellen

- [MDN – import()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#dynamic_imports)  
- [React – Code-Splitting mit lazy()](https://react.dev/learn/code-splitting)  
- [React – React.lazy() API](https://react.dev/reference/react/lazy)

  **[⬆ Наверх](#top)**

149. ### <a name="149"></a> Was ist ein Finite-State Machine (FSM), z. B. mit XState?

# Was ist eine Finite-State Machine (FSM), z. B. mit XState?

Eine **Finite-State Machine (FSM)** ist ein Modell zur Darstellung von **endlich vielen Zuständen**  
und den **Übergängen (Transitions)** zwischen ihnen – abhängig von bestimmten Ereignissen (Events).

➡️ In React-Anwendungen eignet sich FSM perfekt zur **klaren Zustandslogik**, z. B. für Formulare, Auth, UI-States etc.

📦 Beliebtes Tool: [`XState`](https://xstate.js.org)

---

## 🧠 Grundprinzip einer FSM

| Begriff      | Erklärung                                 |
|--------------|--------------------------------------------|
| `State`      | Ein Zustand (z. B. `idle`, `loading`)      |
| `Event`      | Auslöser für Zustandswechsel (`FETCH`, `ERROR`) |
| `Transition` | Übergang von Zustand A zu B                |
| `Initial`    | Startzustand                              |
| `Final`      | Endzustand (optional)                      |

---

## ✅ Beispiel als Objekt (XState-Syntax)

```js
import { createMachine } from 'xstate';

const fetchMachine = createMachine({
  id: 'fetch',
  initial: 'idle',
  states: {
    idle: {
      on: { FETCH: 'loading' },
    },
    loading: {
      on: {
        RESOLVE: 'success',
        REJECT: 'failure',
      },
    },
    success: {},
    failure: {
      on: { RETRY: 'loading' },
    },
  },
});
```

➡️ FSM wechselt nur **kontrolliert** zwischen definierten Zuständen.

---

## ⚛️ Verwendung mit React (`@xstate/react`)

```jsx
import { useMachine } from '@xstate/react';
import { fetchMachine } from './machines/fetchMachine';

function Fetcher() {
  const [state, send] = useMachine(fetchMachine);

  return (
    <>
      {state.matches('idle') && <button onClick={() => send('FETCH')}>Laden</button>}
      {state.matches('loading') && <p>⏳ Ladevorgang...</p>}
      {state.matches('success') && <p>✅ Erfolgreich geladen</p>}
      {state.matches('failure') && (
        <button onClick={() => send('RETRY')}>🔁 Wiederholen</button>
      )}
    </>
  );
}
```

---

## 🧭 Warum FSM in UI sinnvoll ist

| Vorteil                            | Beschreibung                                 |
|------------------------------------|----------------------------------------------|
| 💡 Klar definierte Zustände         | Kein "unbekannter" Zustand mehr              |
| 🔐 Vorhersehbares Verhalten         | Transitions nur auf erlaubte Events möglich  |
| 🔄 Wiederverwendbar & testbar       | Zustände sind unabhängig von Komponenten     |
| 🧩 Visualisierbar                   | Tools wie [XState Visualizer](https://xstate.js.org/viz/) zeigen Übergänge grafisch |

---

## 📝 Zusammenfassung

| Begriff     | Erklärung                                            |
|--------------|-------------------------------------------------------|
| FSM         | Modell zur Kontrolle von Zuständen                    |
| XState      | Library zur Definition & Ausführung von FSMs          |
| Vorteil     | Mehr Kontrolle, bessere UI-Logik, einfache Wartbarkeit|

---

## 🔗 Quellen

- [XState Docs](https://xstate.js.org/docs/)  
- [XState – React Integration](https://xstate.js.org/docs/packages/xstate-react/)  
- [MDN – Finite-State Machine](https://developer.mozilla.org/en-US/docs/Glossary/Finite-state_machine)

  **[⬆ Наверх](#top)**

150. ### <a name="150"></a> Wie kann man ein Formular mit Formik und Yup erstellen und validieren?

# Wie kann man ein Formular mit Formik und Yup erstellen und validieren?

**Formik** ist eine beliebte React-Bibliothek zur einfachen Erstellung und Verwaltung von Formularen.  
**Yup** ist ein Schema-Builder zur Validierung von Formularwerten.  
➡️ Zusammen ermöglichen sie **strukturiertes, sauberes und validiertes Formular-Handling** in React.

---

## 📦 Installation

```bash
npm install formik yup
```

---

## ✅ Beispiel: Login-Formular mit Validierung

```jsx
import { Formik, Form, Field, ErrorMessage } from 'formik';
import * as Yup from 'yup';

// ✅ Validierungsschema mit Yup
const validationSchema = Yup.object({
  email: Yup.string()
    .email('Ungültige E-Mail')
    .required('E-Mail ist erforderlich'),
  password: Yup.string()
    .min(6, 'Mindestens 6 Zeichen')
    .required('Passwort ist erforderlich'),
});

function LoginForm() {
  return (
    <Formik
      initialValues={{ email: '', password: '' }}
      validationSchema={validationSchema}
      onSubmit={(values) => {
        console.log('Formulardaten:', values);
      }}
    >
      <Form className="space-y-4">
        <div>
          <label htmlFor="email">E-Mail:</label>
          <Field name="email" type="email" className="border p-1 w-full" />
          <ErrorMessage name="email" component="div" className="text-red-600 text-sm" />
        </div>

        <div>
          <label htmlFor="password">Passwort:</label>
          <Field name="password" type="password" className="border p-1 w-full" />
          <ErrorMessage name="password" component="div" className="text-red-600 text-sm" />
        </div>

        <button type="submit" className="bg-blue-500 text-white px-4 py-2 rounded">
          Einloggen
        </button>
      </Form>
    </Formik>
  );
}
```

---

## 🧠 Was macht Formik?

| Feature              | Beschreibung                                            |
|----------------------|---------------------------------------------------------|
| `initialValues`      | Startwerte für das Formular                             |
| `validationSchema`   | Yup-Schema zur Feldvalidierung                          |
| `onSubmit`           | Funktion, die bei erfolgreichem Submit ausgeführt wird  |
| `<Field>`            | Automatisch angebundene Eingabefelder                   |
| `<ErrorMessage>`     | Zeigt Fehlermeldungen für bestimmte Felder              |

---

## 📌 Vorteile von Formik + Yup

| Vorteil               | Beschreibung                                     |
|------------------------|--------------------------------------------------|
| ✅ Trennung von Logik & UI | Validierung getrennt in Schema                  |
| 🧪 Testbare Formulare   | Zustände und Fehler leicht überprüfbar            |
| 🔁 Automatisches Reset  | Einfaches Reset bei Erfolg oder Abbruch          |
| ⚠️ Benutzerfreundliche Fehlermeldungen | Direkt unter Eingabefeldern              |

---

## 📝 Zusammenfassung

| Tool     | Zweck                          |
|----------|--------------------------------|
| Formik   | Formularzustand, Events, Submit |
| Yup      | Validierungsschema für Felder   |
| Vorteil  | Weniger Boilerplate, klare Struktur, bessere UX |

---

## 🔗 Quellen

- [Formik – Dokumentation](https://formik.org/docs/overview)  
- [Yup – Doku](https://github.com/jquense/yup)  
- [Formik + Yup Beispiel](https://formik.org/docs/guides/validation)

  **[⬆ Наверх](#top)**  

151. ### <a name="151"></a> Wie konfiguriert man ESLint und Prettier in einem React-Projekt?

# Wie konfiguriert man ESLint und Prettier in einem React-Projekt?

**ESLint** analysiert deinen Code und findet potenzielle Fehler und Stilprobleme.  
**Prettier** ist ein Code-Formatter, der für konsistente Formatierung sorgt.  
Zusammen sorgen sie für **sauberen, wartbaren Code** in React-Projekten.

---

## 📦 Schritt-für-Schritt-Anleitung

### 1️⃣ ESLint + Prettier installieren

```bash
npm install -D eslint prettier eslint-config-prettier eslint-plugin-prettier
```

### 2️⃣ ESLint für React installieren

```bash
npm install -D eslint-plugin-react eslint-plugin-react-hooks
```

Bei TypeScript zusätzlich:

```bash
npm install -D @typescript-eslint/eslint-plugin @typescript-eslint/parser
```

---

## 📁 ESLint-Konfiguration (`.eslintrc.json`)

```json
{
  "env": {
    "browser": true,
    "es2021": true
  },
  "extends": [
    "eslint:recommended",
    "plugin:react/recommended",
    "plugin:react-hooks/recommended",
    "plugin:prettier/recommended"
  ],
  "plugins": ["react", "react-hooks", "prettier"],
  "parserOptions": {
    "ecmaVersion": "latest",
    "sourceType": "module",
    "ecmaFeatures": {
      "jsx": true
    }
  },
  "rules": {
    "prettier/prettier": "error"
  },
  "settings": {
    "react": {
      "version": "detect"
    }
  }
}
```

➡️ `"plugin:prettier/recommended"` integriert Prettier automatisch in ESLint.

---

## 🧼 Prettier-Konfiguration (`.prettierrc`)

```json
{
  "semi": true,
  "singleQuote": true,
  "tabWidth": 2,
  "trailingComma": "es5",
  "printWidth": 80
}
```

---

## 🛠 Weitere Dateien

### `.eslintignore`

```
node_modules
build
dist
```

### `.prettierignore`

```
build
dist
*.svg
```

---

## 🧪 Test: ESLint und Prettier ausführen

```bash
npx eslint src --ext .js,.jsx,.ts,.tsx
npx prettier --check .
```

Oder automatisch fixen:

```bash
npx eslint src --fix
npx prettier --write .
```

---

## ⚛️ VSCode-Integration

- Erweiterungen installieren:
  - ESLint
  - Prettier – Code formatter

- In den Einstellungen (`.vscode/settings.json`):

```json
{
  "editor.formatOnSave": true,
  "editor.defaultFormatter": "esbenp.prettier-vscode"
}
```

---

## 📝 Zusammenfassung

| Tool       | Zweck                                  |
|------------|-----------------------------------------|
| ESLint     | Analyse von Code-Stil und Fehlern       |
| Prettier   | Einheitliche automatische Formatierung  |
| Vorteil    | Sauberer Code, weniger Fehler, Teamkonsistenz |

---

## 🔗 Quellen

- [ESLint – Dokumentation](https://eslint.org/docs/latest/)  
- [Prettier – Docs](https://prettier.io/docs/en/index.html)  
- [eslint-config-prettier](https://github.com/prettier/eslint-config-prettier)  
- [React ESLint Setup](https://react.dev/learn/linting)

  **[⬆ Наверх](#top)**

152. ### <a name="152"></a> Wie funktioniert dynamic import() in React (Syntax, Anwendungsfälle)?

# Wie funktioniert `dynamic import()` in React (Syntax & Anwendungsfälle)?

`dynamic import()` ist eine **JavaScript-Funktion**, mit der Module **asynchron geladen** werden können.  
In React wird diese Technik vor allem für **Lazy Loading und Code-Splitting** eingesetzt,  
um die **Initial-Ladezeit zu reduzieren** und die **Performance zu verbessern**.

---

## 📦 Syntax

```js
import('./MyComponent.js').then((modul) => {
  modul.default(); // Zugriff auf den Default-Export
});
```

- Gibt ein **Promise** zurück
- Kann überall im Code verwendet werden, z. B. in Funktionen, Event-Handlern oder Bedingungsausdrücken

---

## ✅ Verwendung mit `React.lazy()`

In React ist `React.lazy()` die empfohlene Methode für dynamisches Importieren von **Komponenten**.

```jsx
import React, { Suspense } from 'react';

const LazyComponent = React.lazy(() => import('./MyComponent'));

function App() {
  return (
    <Suspense fallback={<div>Lädt…</div>}>
      <LazyComponent />
    </Suspense>
  );
}
```

📌 Wichtig: Komponenten müssen **default-exportiert** sein.  
Das `fallback` wird während des Ladevorgangs angezeigt.

---

## 🧠 Anwendungsfälle

| Anwendungsfall           | Beschreibung                                       |
|---------------------------|----------------------------------------------------|
| 🎯 Route-basiertes Lazy Loading | Nur beim Aufruf einer Seite wird Code geladen     |
| 🧩 Große Komponenten       | Nur geladen, wenn sie benötigt werden (z. B. Modale) |
| 🌍 Sprache / i18n          | Dynamisches Nachladen von Sprachdateien            |
| 🛠 Admin-Panels            | Nur bei bestimmten Rollen laden                   |

---

## 🌍 Beispiel: Routing mit React Router

```jsx
const Home = React.lazy(() => import('./pages/Home'));
const About = React.lazy(() => import('./pages/About'));

<Routes>
  <Route path="/" element={
    <Suspense fallback={<p>Loading...</p>}>
      <Home />
    </Suspense>
  } />
  <Route path="/about" element={
    <Suspense fallback={<p>Loading...</p>}>
      <About />
    </Suspense>
  } />
</Routes>
```

---

## 📝 Zusammenfassung

| Begriff            | Beschreibung                                 |
|---------------------|----------------------------------------------|
| `import()`          | Dynamischer Modulimport, Promise-basiert     |
| `React.lazy()`      | Für Lazy Loading von Komponenten             |
| Vorteil             | Geringere Bundle-Größe, schnellerer Start    |
| Voraussetzung       | Nur für **Default-Exports** geeignet         |

---

## 🔗 Quellen

- [MDN – Dynamic import()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#dynamic_imports)  
- [React Docs – Lazy Loading](https://react.dev/learn/code-splitting)  
- [React.lazy() – API](https://react.dev/reference/react/lazy)

  **[⬆ Наверх](#top)**

153. ### <a name="153"></a> 



  **[⬆ Наверх](#top)**

154. ### <a name="154"></a> 



  **[⬆ Наверх](#top)**

155. ### <a name="155"></a> 



  **[⬆ Наверх](#top)**

156. ### <a name="156"></a> 



  **[⬆ Наверх](#top)**

157. ### <a name="157"></a> 



  **[⬆ Наверх](#top)**

158. ### <a name="158"></a> 



  **[⬆ Наверх](#top)**

159. ### <a name="159"></a> 



  **[⬆ Наверх](#top)**

160. ### <a name="160"></a> 



  **[⬆ Наверх](#top)**

161. ### <a name="161"></a> Was ist der Unterschied zwischen interface und type in TypeScript?

# Was ist der Unterschied zwischen `interface` und `type` in TypeScript?

Sowohl `interface` als auch `type` dienen in TypeScript zur **Definition von Strukturen** für Objekte,  
Funktionen oder andere Typen.  
➡️ In vielen Fällen sind sie **austauschbar**, aber es gibt **wichtige Unterschiede**.

---

## ✅ Gemeinsamkeiten

Beide können verwendet werden, um **Objektformen** zu beschreiben:

```ts
interface Person {
  name: string;
  age: number;
}

type PersonType = {
  name: string;
  age: number;
};
```

Beide können **für Funktionen** verwendet werden:

```ts
interface SayHi {
  (name: string): string;
}

type SayHiType = (name: string) => string;
```

---

## 🔍 Unterschiede im Detail

| Aspekt               | `interface`                                  | `type`                                         |
|----------------------|-----------------------------------------------|------------------------------------------------|
| Erweiterung          | `extends` – mehrfach erweiterbar             | `&` – Intersection für Kombination             |
| Zusammenführbarkeit  | ✅ Automatisches Merging                      | ❌ Kein Merging möglich                        |
| Union / Intersection | ❌ Nur über Vererbung                        | ✅ `A | B`, `A & B` möglich                    |
| Verwendung für Primitives | ❌ Nicht erlaubt                          | ✅ `type ID = string | number;`                |
| Lesbarkeit im Compiler | 👌 besser geeignet für IntelliSense         | weniger sichtbar in komplexen Typen            |

---

## 🧪 Beispiel: Interface Merging

```ts
interface User {
  name: string;
}

interface User {
  age: number;
}

// Merged automatisch zu:
const u: User = {
  name: 'Anna',
  age: 30,
};
```

Mit `type` wäre das ein Fehler:

```ts
type User = {
  name: string;
};

type User = {
  age: number;
}; // ❌ Fehler: Duplicate Identifier
```

---

## 📌 Wann welches?

| Anwendungsfall                  | Empfehlung         |
|----------------------------------|--------------------|
| Öffentliche API (Libraries)     | `interface`        |
| Kombinationen, Unions           | `type`             |
| Erweiterung von Komponenten     | `interface`        |
| Primitive oder komplexe Typkombination | `type`     |

---

## 📝 Zusammenfassung

| `interface`                     | `type`                                      |
|----------------------------------|---------------------------------------------|
| Gut für OOP & Vererbung         | Flexibel für Kombinationen & Unions         |
| Unterstützt automatische Merges | Keine Mehrfachdefinition erlaubt            |
| Empfohlen für Klassen & Props   | Empfohlen für komplexe Typdefinitionen      |

---

## 🔗 Quellen

- [TypeScript: Interfaces](https://www.typescriptlang.org/docs/handbook/interfaces.html)  
- [TypeScript: Advanced Types](https://www.typescriptlang.org/docs/handbook/advanced-types.html)  
- [Type vs Interface – offizielle Empfehlung](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#interfaces)

  **[⬆ Наверх](#top)**

162. ### <a name="162"></a> Wie typisiert man Props und State in einer funktionalen Komponente?

# Wie typisiert man Props und State in einer funktionalen Komponente (TypeScript)?

In TypeScript kannst du Props und State in funktionalen React-Komponenten mithilfe von **Generics**  
und eigenen **Interfaces oder Typen** explizit typisieren.

---

## ✅ 1. Props typisieren

```tsx
type UserProps = {
  name: string;
  age: number;
};

const UserCard: React.FC<UserProps> = ({ name, age }) => {
  return (
    <div>
      <h2>{name}</h2>
      <p>{age} Jahre alt</p>
    </div>
  );
};
```

> `React.FC<Props>` enthält automatisch `children` und `FunctionComponent`-Typisierung.

Alternativ ohne `React.FC`:

```tsx
const UserCard = ({ name, age }: UserProps) => {
  return <p>{name} ({age})</p>;
};
```

---

## ✅ 2. State typisieren mit `useState`

```tsx
import { useState } from 'react';

const Counter = () => {
  const [count, setCount] = useState<number>(0);

  return (
    <button onClick={() => setCount(count + 1)}>
      Klicks: {count}
    </button>
  );
};
```

🔸 Für komplexe State-Objekte:

```tsx
type Todo = {
  id: number;
  text: string;
  completed: boolean;
};

const TodoList = () => {
  const [todos, setTodos] = useState<Todo[]>([]);
  // todos: Array von Todo-Objekten
};
```

---

## 🧠 Best Practices

| Bereich     | Empfehlung                                      |
|-------------|-------------------------------------------------|
| Props       | Interface oder Type erstellen                   |
| State       | Typen direkt in `useState<T>()` angeben         |
| React.FC    | Optional, aber gut für automatische `children`  |

---

## 📝 Zusammenfassung

| Typisierung | Beispiel                                       |
|-------------|------------------------------------------------|
| Props       | `type Props = { name: string }`               |
| State       | `useState<number>(0)` oder `useState<Todo[]>()` |
| Vorteil     | Typsicherheit, bessere DX, Autovervollständigung |

---

## 🔗 Quellen

- [React mit TypeScript – Props & State](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example/)  
- [TypeScript: React.FC vs normales Function Props Typing](https://www.typescriptlang.org/docs/handbook/react.html)

  **[⬆ Наверх](#top)**

163. ### <a name="163"></a> Wie nutzt man Generics in React mit TypeScript (z. B. für Listen)?

# Wie nutzt man Generics in React mit TypeScript? (z. B. für Listen)

**Generics** erlauben es dir, Komponenten in React **flexibel und wiederverwendbar** zu gestalten,  
indem du den Typ der Daten **zur Laufzeit bestimmst**, ohne ihn fest zu codieren.

➡️ Besonders nützlich für **Listen, Tabellen, Formulare, Dropdowns**, u. v. m.

---

## 🧱 Beispiel: Generische `List`-Komponente

```tsx
type ListProps<T> = {
  items: T[];
  renderItem: (item: T) => React.ReactNode;
};

function List<T>({ items, renderItem }: ListProps<T>) {
  return (
    <ul>
      {items.map((item, index) => (
        <li key={index}>{renderItem(item)}</li>
      ))}
    </ul>
  );
}
```

✅ `T` ist der **generische Typ**  
✅ `items: T[]` ist ein Array beliebiger Typen  
✅ `renderItem` definiert, **wie ein Element gerendert wird**

---

## 🔍 Verwendung mit verschiedenen Typen

### 🧍 Beispiel 1: Liste von Benutzern

```tsx
type User = {
  id: number;
  name: string;
};

const users: User[] = [
  { id: 1, name: 'Anna' },
  { id: 2, name: 'Tom' },
];

<List
  items={users}
  renderItem={(user) => <span>{user.name}</span>}
/>
```

### 📦 Beispiel 2: Liste von Zahlen

```tsx
const zahlen = [1, 2, 3];

<List
  items={zahlen}
  renderItem={(n) => <strong>{n}</strong>}
/>
```

---

## 🧠 Vorteile von Generics in React

| Vorteil                   | Beschreibung                                 |
|----------------------------|----------------------------------------------|
| 🔁 Wiederverwendbarkeit    | Komponente funktioniert mit jedem Typ        |
| ✅ Typsicherheit           | Keine `any`-Typen, volle Autovervollständigung |
| 🧩 Kombinierbar mit Props  | Flexible, starke Komponenten möglich         |

---

## 📝 Zusammenfassung

| Element     | Beschreibung                                |
|-------------|---------------------------------------------|
| `T`         | Platzhalter für einen konkreten Typ         |
| `List<T>`   | Komponente mit generischem Datentyp         |
| Vorteil     | Wiederverwendbare & typsichere Komponenten  |

---

## 🔗 Quellen

- [TypeScript – Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)  
- [React + TS – Generische Komponenten](https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase#generic-components)

  **[⬆ Наверх](#top)**

164. ### <a name="164"></a> Wie typisiert man Events in React mit TypeScript (onChange, onClick, FormEvent, MouseEvent)?

# Wie typisiert man Events in React mit TypeScript?  
(z. B. `onChange`, `onClick`, `FormEvent`, `MouseEvent`)

In TypeScript kannst du Events in React präzise typisieren,  
um Typsicherheit bei Event-Handlern wie `onClick`, `onChange`, `onSubmit` usw. zu gewährleisten.

---

## ✅ Häufige Event-Typen

| Event                | Typ                                                  |
|----------------------|------------------------------------------------------|
| `onClick`            | `React.MouseEvent<HTMLButtonElement>`               |
| `onChange`           | `React.ChangeEvent<HTMLInputElement>`               |
| `onSubmit`           | `React.FormEvent<HTMLFormElement>`                  |
| `onKeyDown`          | `React.KeyboardEvent<HTMLInputElement>`             |

---

## 📦 Beispiele

### 🖱 `onClick` mit Button

```tsx
const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {
  console.log('Button geklickt');
};

<button onClick={handleClick}>Klick mich</button>
```

---

### 🔤 `onChange` mit Input-Feld

```tsx
const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
  console.log(e.target.value);
};

<input type="text" onChange={handleChange} />
```

---

### 📩 `onSubmit` bei Formular

```tsx
const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
  e.preventDefault();
  console.log('Formular abgeschickt');
};

<form onSubmit={handleSubmit}>
  <button type="submit">Senden</button>
</form>
```

---

### ⌨️ `onKeyDown` bei Texteingabe

```tsx
const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
  if (e.key === 'Enter') {
    console.log('Enter gedrückt');
  }
};

<input type="text" onKeyDown={handleKeyDown} />
```

---

## 🧠 Tipp: Generische Schreibweise (optional)

```tsx
const handleClick = <T extends HTMLElement>(
  e: React.MouseEvent<T>
) => {
  console.log(e.currentTarget);
};
```

---

## 📝 Zusammenfassung

| Event-Typ                  | React-Typ                                       |
|-----------------------------|-------------------------------------------------|
| Button-Klick (`onClick`)    | `React.MouseEvent<HTMLButtonElement>`          |
| Texteingabe (`onChange`)    | `React.ChangeEvent<HTMLInputElement>`          |
| Formular-Abgabe (`onSubmit`)| `React.FormEvent<HTMLFormElement>`             |
| Tastatur (`onKeyDown`)      | `React.KeyboardEvent<HTMLInputElement>`        |

---

## 🔗 Quellen

- [React TypeScript Cheatsheet – Events](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/events/)  
- [TypeScript Handbook – React Events](https://www.typescriptlang.org/docs/handbook/react.html)

  **[⬆ Наверх](#top)**

165. ### <a name="165"></a> Wie erstellt man einen benutzerdefinierten Hook mit TypeScript?

# Wie erstellt man einen benutzerdefinierten Hook mit TypeScript?

Ein **benutzerdefinierter Hook** (Custom Hook) ist eine Funktion,  
die React-Hooks verwendet und eine **wiederverwendbare Logik** kapselt.  
Mit TypeScript kannst du ihn **typisieren**, um Typsicherheit und Autovervollständigung zu erhalten.

---

## ✅ Beispiel: useLocalStorage-Hook

```tsx
import { useState, useEffect } from 'react';

function useLocalStorage<T>(key: string, initialValue: T) {
  const [value, setValue] = useState<T>(() => {
    try {
      const item = localStorage.getItem(key);
      return item ? (JSON.parse(item) as T) : initialValue;
    } catch (error) {
      console.warn('Fehler beim Lesen aus localStorage', error);
      return initialValue;
    }
  });

  useEffect(() => {
    try {
      localStorage.setItem(key, JSON.stringify(value));
    } catch (error) {
      console.warn('Fehler beim Schreiben in localStorage', error);
    }
  }, [key, value]);

  return [value, setValue] as const;
}
```

---

## 📦 Verwendung

```tsx
const [username, setUsername] = useLocalStorage<string>('username', 'Gast');

<input
  value={username}
  onChange={(e) => setUsername(e.target.value)}
/>
```

---

## 🔍 Erklärung

| Teil                       | Bedeutung                                     |
|----------------------------|-----------------------------------------------|
| `useLocalStorage<T>`       | Generischer Hook, der mit beliebigem Typ funktioniert |
| `initialValue: T`          | Startwert wird als Typ übergeben              |
| `as const`                 | Rückgabe-Tuple ist readonly & typensicher     |

---

## 🧠 Typische Einsatzbereiche für Custom Hooks

- `useWindowSize` – Fensterbreite/-höhe verfolgen  
- `useDebounce` – Werte verzögert weitergeben  
- `usePrevious` – Vorherigen Wert merken  
- `useForm` – Formular-Handling kapseln  
- `useFetch` – API-Daten abrufen  

---

## 📝 Zusammenfassung

| Element             | Beschreibung                            |
|---------------------|------------------------------------------|
| Custom Hook         | Wiederverwendbare Logik mit Hooks        |
| TypeScript Support  | Generische Parameter und Rückgabetypen   |
| Vorteil             | Kapselung, Typensicherheit, Wiederverwendbarkeit |

---

## 🔗 Quellen

- [React – Custom Hooks](https://react.dev/learn/reusing-logic-with-custom-hooks)  
- [TypeScript – Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)  
- [React TypeScript Cheatsheet – Custom Hooks](https://react-typescript-cheatsheet.netlify.app/docs/advanced/hooks/)

  **[⬆ Наверх](#top)**

166. ### <a name="166"></a> Wie typisiert man useReducer mit TypeScript?

# Wie typisiert man `useReducer` mit TypeScript?

`useReducer` ist ein React-Hook zur **Verwaltung komplexer Zustandslogik**.  
Mit TypeScript kannst du die **State- und Action-Typen** exakt definieren, um Typsicherheit zu garantieren.

---

## ✅ Grundstruktur mit TypeScript

```tsx
import { useReducer } from 'react';

// 1. State-Typ
type CounterState = {
  count: number;
};

// 2. Action-Typen (Union)
type CounterAction =
  | { type: 'increment' }
  | { type: 'decrement' }
  | { type: 'reset'; payload: number };

// 3. Reducer
function counterReducer(state: CounterState, action: CounterAction): CounterState {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    case 'reset':
      return { count: action.payload };
    default:
      return state;
  }
}

// 4. Verwendung
function Counter() {
  const [state, dispatch] = useReducer(counterReducer, { count: 0 });

  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: 'increment' })}>+</button>
      <button onClick={() => dispatch({ type: 'decrement' })}>−</button>
      <button onClick={() => dispatch({ type: 'reset', payload: 0 })}>Reset</button>
    </div>
  );
}
```

---

## 🧠 Was wird hier typisiert?

| Element        | Beschreibung                             |
|----------------|------------------------------------------|
| `CounterState` | Struktur des States                      |
| `CounterAction`| Mögliche Aktionen als Union-Typ          |
| `useReducer`   | bekommt typisiertes `state` und `action` |

---

## 🧩 Generischer Reducer-Hook

```tsx
function useGenericReducer<S, A>(
  reducer: (state: S, action: A) => S,
  initialState: S
): [S, React.Dispatch<A>] {
  return useReducer(reducer, initialState);
}
```

---

## 📝 Zusammenfassung

| Schritt              | Was wird gemacht                          |
|----------------------|-------------------------------------------|
| `type State`         | Definiert die Struktur des States         |
| `type Action`        | Legt alle möglichen Aktionen fest         |
| `useReducer`         | Erhält `reducer`-Funktion und Startwert   |
| Vorteil              | Saubere Trennung von Logik und UI         |

---

## 🔗 Quellen

- [React – useReducer](https://react.dev/reference/react/useReducer)  
- [TypeScript – Typisierung von useReducer](https://react-typescript-cheatsheet.netlify.app/docs/advanced/hooks/#usereducer)

  **[⬆ Наверх](#top)**

167. ### <a name="167"></a> Wie typisiert man children korrekt in React-Komponenten?

# Wie typisiert man `children` korrekt in React-Komponenten? (TypeScript)

In React ist `children` ein spezielles Prop, das automatisch übergeben wird,  
wenn **JSX-Inhalte zwischen Öffnungs- und Schließ-Tags** einer Komponente stehen.

Mit TypeScript kannst du `children` explizit typisieren, um **Typsicherheit** und **bessere Autovervollständigung** zu erhalten.

---

## ✅ Standard-Typ für `children`

```tsx
type MyComponentProps = {
  children: React.ReactNode;
};

const MyComponent = ({ children }: MyComponentProps) => {
  return <div>{children}</div>;
};
```

➡️ `React.ReactNode` erlaubt Strings, Zahlen, JSX, Arrays, `null`, `undefined` usw.

---

## 🧠 Alternativen zu `React.ReactNode`

| Typ                | Beschreibung                                         |
|--------------------|------------------------------------------------------|
| `ReactNode`        | Alles, was in JSX verwendet werden kann              |
| `ReactElement`     | Nur **ein einzelnes JSX-Element**                    |
| `JSX.Element`      | Alias für `ReactElement`                             |
| `ReactChild`       | Nur string, number, JSX.Element                      |
| `ReactNode[]`      | Nur Array von JSX (nicht `null`, `undefined` etc.)   |

---

## 📦 Beispiel mit mehreren Props

```tsx
type CardProps = {
  title: string;
  children: React.ReactNode;
};

const Card = ({ title, children }: CardProps) => (
  <div className="border p-4">
    <h2>{title}</h2>
    <div>{children}</div>
  </div>
);
```

📌 Verwendung:

```tsx
<Card title="Info">
  <p>Das ist Inhalt innerhalb von `children`.</p>
</Card>
```

---

## 🔄 Mit `React.FC` (automatisch `children` enthalten)

```tsx
const Layout: React.FC = ({ children }) => {
  return <main>{children}</main>;
};
```

➡️ Vorteil: Kein eigener Typ für `children` notwendig.  
➡️ Nachteil: `React.FC` hat Einschränkungen bei generischen Props und `defaultProps`.

---

## 📝 Zusammenfassung

| Ziel                | Empfehlung                         |
|---------------------|-------------------------------------|
| Beliebige Inhalte   | `children: React.ReactNode`         |
| Nur ein Element     | `children: React.ReactElement`      |
| Automatisch (optional) | `React.FC` verwenden             |

---

## 🔗 Quellen

- [React – Children Props](https://react.dev/learn/passing-props-to-a-component#passing-jsx)  
- [React TypeScript Cheatsheet – Children](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example/#typing-children)

  **[⬆ Наверх](#top)**

168. ### <a name="168"></a> Was ist React.FC und welche Vor- und Nachteile hat es?

# Was ist `React.FC` und welche Vor- und Nachteile hat es?

`React.FC` (oder `React.FunctionComponent`) ist ein generischer Typ in TypeScript,  
der zur Typisierung von **funktionalen Komponenten** verwendet wird.  
Er ist besonders hilfreich, wenn man **`children` automatisch typisieren** möchte.

---

## ✅ Syntax

```tsx
const MyComponent: React.FC = () => {
  return <div>Hallo</div>;
};
```

Mit Props:

```tsx
type Props = {
  title: string;
};

const Header: React.FC<Props> = ({ title, children }) => (
  <header>
    <h1>{title}</h1>
    {children}
  </header>
);
```

---

## 📦 Was bringt `React.FC`?

| Funktion                 | Beschreibung                               |
|--------------------------|--------------------------------------------|
| ✅ Automatisch `children`| Kein manuelles Hinzufügen von `children`  |
| ✅ Generische Props      | Übergabe von Typen an die Komponente       |
| ✅ Intellisense          | Automatische Vorschläge in VSCode etc.     |

---

## ⚠️ Nachteile von `React.FC`

| Problem                                 | Beschreibung                                  |
|------------------------------------------|-----------------------------------------------|
| ❌ Eingeschränkte Generics               | Komplexe Props schwer typisierbar              |
| ❌ `defaultProps` wird nicht korrekt unterstützt | TypeScript erkennt sie nicht automatisch   |
| ❌ Zwingt `children`                    | Auch wenn Komponente keine `children` erwartet |

---

## 🧠 Best Practices

| Situation                       | Empfehlung                   |
|----------------------------------|------------------------------|
| Mit `children`                  | `React.FC` ist praktisch     |
| Ohne `children`                 | Besser eigenes Props-Interface |
| Große/generische Komponenten   | Lieber eigene Typisierung     |

---

## 🔍 Vergleich mit manuellem Props-Typ

```tsx
type Props = {
  name: string;
};

const Hello = ({ name }: Props) => <p>Hallo {name}</p>;
```

➡️ Kein `children`, aber volle Kontrolle.  
➡️ Mehr Flexibilität bei Generics.

---

## 📝 Zusammenfassung

| Vorteil (`React.FC`)       | Nachteil                              |
|----------------------------|----------------------------------------|
| Automatische `children`    | Eingeschränkte Flexibilität            |
| Klarer Funktions-Typ       | Probleme mit `defaultProps` und Generics |

---

## 🔗 Quellen

- [React.FC – Diskussion auf GitHub](https://github.com/facebook/create-react-app/pull/8177)  
- [React TypeScript Cheatsheet – React.FC](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/function_components/)

  **[⬆ Наверх](#top)**

169. ### <a name="169"></a> Wie typisiert man eine Komponente mit optionalen Props?

# Wie typisiert man eine Komponente mit **optionalen Props** in TypeScript?

In TypeScript kannst du Props als **optional** deklarieren,  
indem du ein **Fragezeichen (`?`)** hinter dem Namen eines Props setzt.

---

## ✅ Beispiel mit optionalem Prop

```tsx
type ButtonProps = {
  label: string;
  color?: string; // optional
};

const Button = ({ label, color = 'blue' }: ButtonProps) => {
  return <button className={`bg-${color}-500 text-white p-2`}>{label}</button>;
};
```

📌 `color` ist optional. Wenn es nicht übergeben wird, nutzt die Komponente `"blue"` als Default.

---

## 🧠 Warum `color = 'blue'`?

Das ist der **Default-Wert** in der Funktion.  
Wird `color` nicht übergeben, verwendet React automatisch den angegebenen Fallback.

---

## 💡 Mit `React.FC` (funktioniert auch)

```tsx
type AlertProps = {
  message?: string;
};

const Alert: React.FC<AlertProps> = ({ message }) => {
  return <div>{message ?? 'Standard-Nachricht'}</div>;
};
```

---

## 🧪 Mit `children` und optionalen Props

```tsx
type CardProps = {
  title?: string;
  children: React.ReactNode;
};

const Card = ({ title, children }: CardProps) => (
  <div className="p-4 border">
    {title && <h2>{title}</h2>}
    {children}
  </div>
);
```

---

## 📝 Zusammenfassung

| Merkmal                  | Beschreibung                                 |
|--------------------------|----------------------------------------------|
| `propName?: type`        | Macht das Prop optional                      |
| `propName = value`       | Setzt einen Default-Wert innerhalb der Funktion |
| Vorteil                  | Flexible Verwendung, saubere Komponenten     |

---

## 🔗 Quellen

- [TypeScript – Optional Properties](https://www.typescriptlang.org/docs/handbook/2/objects.html#optional-properties)  
- [React TypeScript Cheatsheet – Props](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example/)

  **[⬆ Наверх](#top)**

170. ### <a name="170"></a> Wie arbeitet man mit Drittanbieter-Bibliotheken, die keine Typen enthalten?

# Wie arbeitet man mit Drittanbieter-Bibliotheken, die **keine Typen** enthalten?

Wenn eine JavaScript-Bibliothek **keine TypeScript-Typen** bereitstellt,  
kannst du sie trotzdem verwenden – mithilfe von:

1. 🧩 **@types/**-Paketen  
2. 🧨 **declare module**  
3. 🧠 Eigene Typdefinitionen schreiben  

---

## ✅ 1. Prüfen, ob es ein `@types/`-Paket gibt

Viele Bibliotheken haben ein **extern gepflegtes Typ-Paket**:

```bash
npm install --save-dev @types/lodash
```

📦 Quelle: https://github.com/DefinitelyTyped/DefinitelyTyped

---

## ❌ 2. Wenn keine Typen existieren: `declare module`

Erstelle z. B. eine Datei `src/types/thirdparty.d.ts`:

```ts
declare module 'untypisierte-lib' {
  const content: any;
  export default content;
}
```

➡️ Damit kannst du das Modul **ohne Typsicherheitsfehler** importieren:

```ts
import foo from 'untypisierte-lib';
```

---

## ✍️ 3. Eigene Typen definieren (besser als `any`)

```ts
declare module 'untypisierte-lib' {
  export function greet(name: string): string;
  export const version: string;
}
```

➡️ Nun bekommst du **Autovervollständigung & Typsicherheit** beim Import:

```ts
import { greet } from 'untypisierte-lib';
greet('Sergii');
```

---

## 🧠 Typ "any" vermeiden

```ts
import xyz from 'legacy-lib';
// schlechter Stil:
(xyz as any).doSomething(); // ⛔️ Keine Typsicherheit!
```

✅ Besser: Eigene Schnittstellen oder Typen definieren!

---

## 📝 Zusammenfassung

| Schritt                | Vorgehen                                                  |
|------------------------|-----------------------------------------------------------|
| ✅ Prüfen auf `@types/` | `npm i -D @types/libname`                                |
| 🔨 Kein Typ vorhanden   | `declare module 'lib' {}` verwenden                      |
| ✍️ Eigenes Typing       | Besser als `any`, mehr Kontrolle                         |
| 🔐 Ziel                 | Typsicherheit und bessere Entwicklererfahrung            |

---

## 🔗 Quellen

- [TypeScript – Declaration Files](https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html)  
- [DefinitelyTyped Repo](https://github.com/DefinitelyTyped/DefinitelyTyped)  
- [Using Non-TypeScript Libraries](https://www.typescriptlang.org/docs/handbook/modules.html#ambient-modules)

  **[⬆ Наверх](#top)**

171. ### <a name="171"></a> Was ist der Unterschied zwischen ESM und CommonJS?

# Was ist der Unterschied zwischen **ESM** und **CommonJS**?

**ESM (ECMAScript Modules)** und **CommonJS (CJS)** sind zwei unterschiedliche **Modulsysteme** in JavaScript.  
Sie definieren, **wie Code importiert und exportiert wird** – besonders wichtig bei der Arbeit mit Node.js und modernen Frontend-Bundlern.

---

## ✅ Übersicht

| Merkmal              | ESM                                 | CommonJS                           |
|----------------------|--------------------------------------|-------------------------------------|
| Einführung           | Offizieller JS-Standard (ES6)        | Node.js-spezifisch (älter)         |
| Syntax               | `import` / `export`                  | `require()` / `module.exports`     |
| Ausführung           | statisch analysierbar                | dynamisch zur Laufzeit             |
| Dateiendung (Node.js)| `.mjs` oder `"type": "module"`       | `.cjs` oder keine spezielle Angabe |
| Tree Shaking         | ✅ möglich                           | ❌ nicht zuverlässig                |
| Verwendung           | Frontend + modernes Node.js          | Klassisches Node.js                |

---

## 📦 Beispiel: Import / Export

### ESM

```js
// math.js
export const add = (a, b) => a + b;

// index.js
import { add } from './math.js';
```

### CommonJS

```js
// math.js
exports.add = (a, b) => a + b;

// index.js
const { add } = require('./math');
```

---

## 🔁 Interoperabilität (CJS ↔ ESM)

- In Node.js ist **Mischen möglich**, aber **kompliziert**  
- `import` kann **keine CJS-Datei mit `default`** direkt lesen  
- Viele Tools (z. B. Webpack, Vite) unterstützen **beide Formate**

---

## 🧠 Wann was nutzen?

| Situation                         | Empfehlung        |
|-----------------------------------|-------------------|
| Neues Projekt mit Bundler         | **ESM**           |
| Legacy-Node.js ohne Transpiler    | **CommonJS**      |
| Bibliothek mit Tree Shaking       | **ESM bevorzugt** |

---

## 📝 Zusammenfassung

| ESM                  | CommonJS              |
|----------------------|------------------------|
| `import/export`      | `require/module.exports` |
| Modern & standardisiert | Node.js-spezifisch (älter) |
| Tree Shaking möglich | Kein Tree Shaking      |

---

## 🔗 Quellen

- [MDN – Modules: ES6](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules)  
- [Node.js – CommonJS vs ESM](https://nodejs.org/api/esm.html)  
- [ESM vs CJS – Differences](https://blog.logrocket.com/esm-vs-commonjs-node-js/)

  **[⬆ Наверх](#top)**

172. ### <a name="172"></a> 



  **[⬆ Наверх](#top)**

173. ### <a name="173"></a> 



  **[⬆ Наверх](#top)**

174. ### <a name="174"></a> 



  **[⬆ Наверх](#top)**

175. ### <a name="175"></a> 



  **[⬆ Наверх](#top)**

176. ### <a name="176"></a> 



  **[⬆ Наверх](#top)**

177. ### <a name="177"></a> 



  **[⬆ Наверх](#top)**

178. ### <a name="178"></a> 



  **[⬆ Наверх](#top)**

179. ### <a name="179"></a> 



  **[⬆ Наверх](#top)**

180. ### <a name="180"></a> 



  **[⬆ Наверх](#top)**  

181. ### <a name="181"></a> 



  **[⬆ Наверх](#top)**

182. ### <a name="182"></a> 



  **[⬆ Наверх](#top)**

183. ### <a name="183"></a> 



  **[⬆ Наверх](#top)**

184. ### <a name="184"></a> 



  **[⬆ Наверх](#top)**

185. ### <a name="185"></a> 



  **[⬆ Наверх](#top)**

186. ### <a name="186"></a> 



  **[⬆ Наверх](#top)**

187. ### <a name="187"></a> 



  **[⬆ Наверх](#top)**

188. ### <a name="188"></a> 



  **[⬆ Наверх](#top)**

189. ### <a name="189"></a> 



  **[⬆ Наверх](#top)**

190. ### <a name="190"></a> 



  **[⬆ Наверх](#top)**  

191. ### <a name="191"></a> 



  **[⬆ Наверх](#top)**

192. ### <a name="192"></a> 



  **[⬆ Наверх](#top)**

193. ### <a name="193"></a> 



  **[⬆ Наверх](#top)**

194. ### <a name="194"></a> 



  **[⬆ Наверх](#top)**

195. ### <a name="195"></a> 



  **[⬆ Наверх](#top)**

196. ### <a name="196"></a> 



  **[⬆ Наверх](#top)**

197. ### <a name="197"></a> 



  **[⬆ Наверх](#top)**

198. ### <a name="198"></a> 



  **[⬆ Наверх](#top)**

199. ### <a name="199"></a> 



  **[⬆ Наверх](#top)**

200. ### <a name="200"></a> 



  **[⬆ Наверх](#top)**      
