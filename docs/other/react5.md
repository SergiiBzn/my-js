<a name="top"></a>

[–ù–∞ –≥–ª–∞–≤–Ω—É—é](../../README.md)

[–ü–µ—Ä–µ–π—Ç–∏ –∫ –≤–æ–ø—Ä–æ—Å–∞–º](#questions)

| ‚Ññ. | –í–æ–ø—Ä–æ—Å |
| --- | --------- |
|   | ReactJS Grundlagen |
|1 | [Was ist React und welche Probleme l√∂st es?](#1) |
|2 | [Was ist JSX und warum wird es verwendet?](#2) |
|3 | [Was ist Virtual DOM und wie funktioniert es?](#3) |
|4 | [Was ist der Unterschied zwischen React und ReactDOM?](#4) |
|5 | [Warum importieren wir React, auch wenn es scheinbar nicht benutzt wird?](#5) |
|6 | [Was ist ein React Fragment und warum ist es n√ºtzlich?](#6) |
|7 | [Was ist der Unterschied zwischen einem Element, einer Komponente und einer Instanz?](#7) |
|8 | [Was ist das Fiber-Architekturmodell in React?](#8) |
|9 | [Was bedeutet ‚ÄûBatching‚Äú in React?](#9) |
|10 | [Was ist die Rolle des key in React-Listen?](#10) |
|11 | [Wie funktioniert die Wiederverwendung von Komponenten?](#11) |
|12 | [](#12) |
|13 | [](#13) |
|14 | [](#14) |
|15 | [](#15) |
|16 | [](#16) |
|17 | [](#17) |
|18 | [](#18) |
|19 | [](#19) |
|20 | [](#20) |
|   | Komponenten, Props & State |
|21 | [Was sind Props und wozu werden sie verwendet?](#21) |
|22 | [Was ist der Unterschied zwischen Props und State?](#22) |
|23 | [Warum sind Props nur lesbar?](#23) |
|24 | [Wie funktioniert der unidirektionale Datenfluss in React?](#24) |
|25 | [Was ist State in Klassen- und Funktionskomponenten?](#25) |
|26 | [Wie funktioniert setState?](#26) |
|27 | [Was ist der Unterschied zwischen kontrollierten und unkontrollierten Komponenten?](#27) |
|28 | [Was sind Default Props und PropTypes?](#28) |
|29 | [Was ist React.memo und wof√ºr wird es verwendet?](#29) |
|30 | [Was ist PureComponent und wie unterscheidet es sich von Component?](#30) |
|31 | [Wann sollte shouldComponentUpdate verwendet werden?](#31) |
|32 | [Was ist ein ref und wann wird er eingesetzt?](#32) |
|33 | [Was bedeutet ‚ÄûLifting State Up‚Äú?](#33) |
|34 | [](#34) |
|35 | [](#35) |
|36 | [](#36) |
|37 | [](#37) |
|38 | [](#38) |
|39 | [](#39) |
|40 | [](#40) |
|   | Lebenszyklus von Komponenten |
|41 | [Was sind die Phasen des Komponentenlebenszyklus?](#41) |
|42 | [Welche Lifecycle-Methoden gibt es in Klassenkomponenten?](#42) |
|43 | [Welche Lifecycle-Methoden sind veraltet?](#43) |
|44 | [Wie kann man Lifecycle-Methoden mit Hooks ersetzen?](#44) |
|45 | [Was ist componentDidMount und was ist das √Ñquivalent mit Hooks?](#45) |
|46 | [](#46) |
|47 | [](#47) |
|48 | [](#48) |
|49 | [](#49) |
|50 | [](#50) |
|   | Hooks |
|51 | [Was sind Hooks in React?](#51) |
|52 | [Wie funktionieren useState und useEffect?](#52) |
|53 | [Was macht useContext?](#53) |
|54 | [Was ist useRef und wann wird es verwendet?](#54) |
|55 | [Was ist useCallback, useMemo, useReducer?](#55) |
|56 | [Wie schreibt man einen benutzerdefinierten Hook?](#56) |
|57 | [Wie verhindert man eine Endlosschleife in useEffect?](#57) |
|58 | [Wie implementiert man Timeout oder Interval mit Hooks?](#58) |
|59 | [](#59) |
|60 | [](#60) |
|   | React-Patterns und Konzepte |
|61 | [Was ist ein Higher-Order Component (HOC)?](#61) |
|62 | [Was ist das Render-Prop-Pattern?](#62) |
|63 | [Was ist die Context-API und wie funktioniert useContext?](#63) |
|64 | [Was sind Portale in React?](#64) |
|65 | [Was ist bedingtes Rendern (Conditional Rendering)?](#65) |
|66 | [Was ist ein Error Boundary?](#66) |
|67 | [Wie funktioniert Event-Handling in React?](#67) |
|68 | [Was ist ein synthetisches Ereignis (SyntheticEvent)?](#68) |
|69 | [Was ist props.children?](#69) |
|70 | [Was bedeutet ‚Äûcontrolled component‚Äú und ‚Äûuncontrolled component‚Äú bei Formularen?](#70) |
|71 | [](#71) |
|72 | [](#72) |
|73 | [](#73) |
|74 | [](#74) |
|75 | [](#75) |
|   | Daten & API |
|76 | [Wie f√ºhrt man API-Aufrufe mit Fetch oder Axios durch?](#76) |
|77 | [Wie verwaltet man Lade-, Fehler- und Erfolgsstatus?](#77) |
|78 | [Wie funktioniert WebSocket mit React?](#78) |
|79 | [Wie kann man Daten zwischen Komponenten weitergeben?](#79) |
|80 | [Wie macht man einen Datenabruf nur beim ersten Rendern?](#80) |
|81 | [Was ist das Problem bei ‚Äûstale closures‚Äú mit Hooks?](#81) |
|82 | [Wie funktioniert die Fehlerbehandlung mit try/catch in React?](#82) |
|83 | [Wie kann man ein Mock-API oder Mock Server verwenden?](#83) |
|84 | [Wie funktioniert Suspense f√ºr Datenabfragen?](#84) |
|85 | [](#85) |
|86 | [](#86) |
|87 | [](#87) |
|88 | [](#88) |
|89 | [](#89) |
|90 | [](#90) |
|   | Testing |
|91 | [Was ist Unit-, Integration- und E2E-Testing?](#91) |
|92 | [Was ist Snapshot-Testing?](#92) |
|93 | [Welche Tools nutzt man f√ºr React-Tests (Jest, React Testing Library)?](#93) |
|94 | [Wie testet man Komponenten, Props und Events?](#94) |
|95 | [Wie testet man benutzerdefinierte Hooks?](#95) |
|96 | [](#96) |
|97 | [](#97) |
|98 | [](#98) |
|99 | [](#99) |
|100 | [](#100) |
|   | Routing mit React Router |
|101 | [Wie funktioniert Routing in React mit react-router-dom?](#101) |
|102 | [Was sind die Unterschiede zwischen react-router v5 und v6?](#102) |
|103 | [Was sind Route, Link, Navigate, Outlet?](#103) |
|104 | [Wie erstellt man Nested Routes?](#104) |
|105 | [Wie implementiert man Redirects?](#105) |
|106 | [Wie funktioniert programmgesteuerte Navigation (useNavigate)?](#106) |
|107 | [](#107) |
|108 | [](#108) |
|109 | [](#109) |
|110 | [](#110) |
|   | Redux & Redux Toolkit |
|111 | [Was ist Redux und wie funktioniert es?](#111) |
|112 | [Was sind Actions, Reducer und Store?](#112) |
|113 | [Wie funktioniert Redux Toolkit (createSlice, configureStore, createAsyncThunk)?](#113) |
|114 | [Was ist RTK Query?](#114) |
|115 | [Was ist der Unterschied zwischen Redux und der Context-API?](#115) |
|116 | [Was ist connect() in Redux?](#116) |
|117 | [Was sind Middleware in Redux (z. B. redux-thunk, redux-logger)?](#117) |
|118 | [Was ist createSelector und wie funktioniert Reselect?](#118) |
|119 | [Wie verbindet man Redux mit React √ºber Hooks (useSelector, useDispatch)?](#119) |
|120 | [](#120) |
|121 | [](#121) |
|122 | [](#122) |
|123 | [](#123) |
|124 | [](#124) |
|125 | [](#125) |
|126 | [](#126) |
|127 | [](#127) |
|128 | [](#128) |
|129 | [](#129) |
|130 | [](#130) |
|   | Optimierung & Performance |
|131 | [Was ist Code-Splitting?](#131) |
|132 | [Wie funktionieren React.lazy und Suspense?](#132) |
|133 | [Was ist Tree Shaking?](#133) |
|134 | [Was ist Server-Side Rendering (SSR) und Hydration?](#134) |
|135 | [Wie geht man mit Hydration-Fehlern bei SSR um?](#135) |
|136 | [Was bedeutet Virtualisierung (z. B. mit react-window)?](#136) |
|137 | [Wie verhindert man unn√∂tige Re-Renders?](#137) |
|138 | [Was ist React Transition Group?](#138) |
|139 | [Was ist React Strict Mode und welche Vorteile bietet er?](#139) |
|140 | [Was ist Concurrent Mode und welche Probleme l√∂st er?](#140) |
|141 | [](#141) |
|142 | [](#142) |
|143 | [](#143) |
|144 | [](#144) |
|145 | [](#145) |
|   | Sonstiges |
|146 | [Was ist ein Service Worker?](#146) |
|147 | [Was ist react-helmet und wie hilft es beim SEO?](#147) |
|148 | [Wie funktioniert Lazy Loading mit dynamic import()?](#148) |
|149 | [Was ist ein Finite-State Machine (FSM), z. B. mit XState?](#149) |
|150 | [Wie kann man ein Formular mit Formik und Yup erstellen und validieren?](#150) |
|151 | [Wie konfiguriert man ESLint und Prettier in einem React-Projekt?](#151) |
|152 | [Wie funktioniert dynamic import() in React (Syntax, Anwendungsf√§lle)?](#152) |
|153 | [](#153) |
|154 | [](#154) |
|155 | [](#155) |
|156 | [](#156) |
|157 | [](#157) |
|158 | [](#158) |
|159 | [](#159) |
|160 | [](#160) |
|   | React + TypeScript |
|161 | [Was ist der Unterschied zwischen interface und type in TypeScript?](#161) |
|162 | [Wie typisiert man Props und State in einer funktionalen Komponente?](#162) |
|163 | [Wie nutzt man Generics in React mit TypeScript (z. B. f√ºr Listen)?](#163) |
|164 | [Wie typisiert man Events in React mit TypeScript (onChange, onClick, FormEvent, MouseEvent)?](#164) |
|165 | [Wie erstellt man einen benutzerdefinierten Hook mit TypeScript?](#165) |
|166 | [Wie typisiert man useReducer mit TypeScript?](#166) |
|167 | [Wie typisiert man children korrekt in React-Komponenten?](#167) |
|168 | [Was ist React.FC und welche Vor- und Nachteile hat es?](#168) |
|169 | [Wie typisiert man eine Komponente mit optionalen Props?](#169) |
|170 | [Wie arbeitet man mit Drittanbieter-Bibliotheken, die keine Typen enthalten?](#170) |
|171 | [Was ist der Unterschied zwischen ESM und CommonJS?](#171) |
|172 | [](#172) |
|173 | [](#173) |
|174 | [](#174) |
|175 | [](#175) |
|176 | [](#176) |
|177 | [](#177) |
|178 | [](#178) |
|179 | [](#179) |
|180 | [](#180) |
|181 | [](#181) |
|182 | [](#182) |
|183 | [](#183) |
|184 | [](#184) |
|185 | [](#185) |
|186 | [](#186) |
|187 | [](#187) |
|188 | [](#188) |
|189 | [](#189) |
|190 | [](#190) |
|191 | [](#191) |
|192 | [](#192) |
|193 | [](#193) |
|194 | [](#194) |
|195 | [](#195) |
|196 | [](#196) |
|197 | [](#197) |
|198 | [](#198) |
|199 | [](#199) |
|200 | [](#200) |



<a name="questions"></a>

## ReactJS 

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**
  
1. ### <a name="1"></a> Was ist React und welche Probleme l√∂st es?

**React** ist eine **JavaScript-Bibliothek** f√ºr den Aufbau von **User Interfaces** (UI), entwickelt von Facebook (heute Meta). Sie konzentriert sich auf die **View-Schicht** (im MVC-Pattern) und l√∂st typische Probleme moderner Frontend-Entwicklung:

### Probleme, die React l√∂st

1. **Komplexit√§t bei dynamischen UIs**

   * Klassisches DOM-Manipulieren mit `document.querySelector` oder `innerHTML` ist fehleranf√§llig und schwer zu warten.
   * React nutzt das **Virtual DOM**, um √Ñnderungen effizient zu berechnen und nur die n√∂tigen Teile des echten DOM zu aktualisieren.

2. **Wiederverwendbarkeit von UI-Logik**

   * In Vanilla JS oder jQuery ist es schwierig, UI-Elemente als eigenst√§ndige, wiederverwendbare Bausteine zu organisieren.
   * React bietet **Komponenten** (Functions oder Classes), die UI + Logik kapseln.

3. **State-Management**

   * Ohne Framework muss man Zust√§nde (z. B. Eingaben, UI-√Ñnderungen) manuell im DOM nachverfolgen.
   * React bietet ein klares **State- und Props-Konzept**: Datenfluss von oben nach unten (Top-down Data Flow) und kontrollierte Zustandsverwaltung.

4. **Lesbarkeit & Wartbarkeit**

   * Mit **JSX** verbindet React deklarative Syntax mit JavaScript, wodurch UI-Struktur dem HTML √§hnelt, aber direkt in JS geschrieben wird.
   * Dadurch wird Code strukturierter, testbarer und besser wartbar.

---

### Beispiel

```jsx
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Aktueller Wert: {count}</p>
      <button onClick={() => setCount(count + 1)}>
        Erh√∂hen
      </button>
    </div>
  );
}

export default Counter;
```

* `useState` verwaltet den Zustand.
* Bei jedem Klick wird nur der relevante Teil des DOM aktualisiert.

---

### Zusammenfassung

* **React** = Bibliothek f√ºr deklarative UI-Entwicklung.
* L√∂st Probleme: ineffiziente DOM-Manipulation, fehlende Wiederverwendbarkeit, un√ºbersichtliches State-Handling.
* Schl√ºsselkonzepte: **Virtual DOM, Komponenten, State, Props, JSX**.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Grundlagen](https://react.dev/learn)
* [MDN ‚Äì Einf√ºhrung in das DOM](https://developer.mozilla.org/ru/docs/Web/API/Document_Object_Model/Introduction)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

2. ### <a name="2"></a> Was ist JSX und warum wird es verwendet?

**JSX (JavaScript XML)** ist eine **erweiterte Syntax f√ºr JavaScript**, die es erlaubt, UI-Strukturen in einer HTML-√§hnlichen Schreibweise direkt im JavaScript-Code zu definieren. JSX wird von **Babel** oder anderen Transpilern in reines JavaScript (meist `React.createElement`) √ºbersetzt.

---

### Warum wird JSX verwendet?

1. **Deklarative UI-Beschreibung**

   * UI-Struktur sieht aus wie HTML, ist aber vollst√§ndig in JavaScript eingebettet.
   * Entwicklern f√§llt es leichter, die Logik und das UI zusammen zu lesen und zu verstehen.

2. **Verkn√ºpfung von Logik und Darstellung**

   * Man kann JavaScript-Ausdr√ºcke direkt in JSX einbetten: `{...}`.
   * Bedingte Renderings oder Schleifen lassen sich elegant integrieren.

3. **Bessere Lesbarkeit & Wartbarkeit**

   * Statt verschachtelter `React.createElement`-Aufrufe ist JSX k√ºrzer, klarer und n√§her an HTML.

---

### Beispiel

```jsx
import { useState } from "react";

function Greeting() {
  const [name, setName] = useState("Sergii");

  return (
    <div>
      <h1>Hallo, {name}!</h1> {/* JS-Ausdruck in geschweiften Klammern */}
      <button onClick={() => setName("Frontend-Dev")}>
        √Ñndern
      </button>
    </div>
  );
}

export default Greeting;
```

Ohne JSX w√ºrde derselbe Code so aussehen:

```js
import { createElement, useState } from "react";

function Greeting() {
  const [name, setName] = useState("Sergii");

  return createElement(
    "div",
    null,
    createElement("h1", null, `Hallo, ${name}!`),
    createElement(
      "button",
      { onClick: () => setName("Frontend-Dev") },
      "√Ñndern"
    )
  );
}
```

---

### Zusammenfassung

* **JSX** = Syntax-Erweiterung f√ºr JavaScript, die UI-Strukturen wie HTML aussehen l√§sst.
* Vorteile: bessere Lesbarkeit, Integration von Logik + UI, effizienteres Arbeiten mit React.
* JSX wird in reines JavaScript transpiliert.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì JSX](https://react.dev/learn/writing-markup-with-jsx)
* [MDN ‚Äì JSX (Einf√ºhrung)](https://developer.mozilla.org/ru/docs/Glossary/JSX)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

3. ### <a name="3"></a> Was ist Virtual DOM und wie funktioniert es?

**Virtual DOM (VDOM)** ist eine **leichte, virtuelle Repr√§sentation** des echten DOM im Speicher. Es dient als Zwischenschicht, um √Ñnderungen effizient zu berechnen, bevor sie im **realen DOM** angewendet werden.

---

### Funktionsweise

1. **Rendern in den Virtual DOM**

   * Wenn sich State oder Props √§ndern, erzeugt React ein **neues Virtual DOM**-Baumobjekt.

2. **Diffing-Algorithmus**

   * React vergleicht den neuen VDOM mit der vorherigen Version (Reconciliation).
   * Nur die Unterschiede (‚Äûdiff‚Äú) werden ermittelt.

3. **Minimaler Update im echten DOM**

   * React aktualisiert nur die tats√§chlich ver√§nderten Teile im **realen DOM**.
   * Dadurch sind Updates wesentlich effizienter, da direkte DOM-Manipulationen sehr teuer sind.

---

### Beispiel

```jsx
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Z√§hler: {count}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
    </div>
  );
}

export default Counter;
```

* Bei `setCount` erstellt React ein neues Virtual DOM.
* React erkennt, dass nur `<p>` sich ge√§ndert hat.
* Nur dieser Knoten im echten DOM wird neu gerendert, **nicht die gesamte Seite**.

---

### Zusammenfassung

* **Virtual DOM** = virtuelles Abbild des echten DOM.
* Ablauf: **neuer VDOM ‚Üí Diffing ‚Üí minimaler DOM-Update**.
* Vorteil: Performance, klare Trennung von Logik und DOM-Manipulation.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Reconciliation](https://react.dev/learn/render-and-commit#step-2-react-renders-your-components)
* [MDN ‚Äì DOM Einf√ºhrung](https://developer.mozilla.org/ru/docs/Web/API/Document_Object_Model/Introduction)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

4. ### <a name="4"></a> Was ist der Unterschied zwischen React und ReactDOM?

**React** ist die **Kernbibliothek**, die Werkzeuge f√ºr das **Erstellen von Komponenten, State-Management, Hooks und JSX-Verarbeitung** bereitstellt.
**ReactDOM** ist das **Rendering-Paket**, das React-Komponenten mit dem **echten DOM im Browser** verbindet.

---

### Details

1. **React**

   * Definiert, **wie** UI-Komponenten aussehen und funktionieren.
   * Enth√§lt Hooks wie `useState`, `useEffect`.
   * Ist plattformunabh√§ngig (kann auch mit React Native, ReactDOM, ReactVR genutzt werden).

2. **ReactDOM**

   * Speziell f√ºr **Web-Umgebungen** gedacht.
   * Stellt Funktionen wie `createRoot` oder `render` bereit, um React-Komponenten in den Browser zu mounten.
   * Trennt die Logik von der konkreten Rendering-Umgebung (Browser-DOM).

---

### Beispiel

```jsx
// index.jsx
import React from "react";
import { createRoot } from "react-dom/client";
import App from "./App.jsx";

const root = createRoot(document.getElementById("root"));
root.render(<App />);
```

* `React` stellt die Komponente `App` bereit.
* `ReactDOM` sorgt daf√ºr, dass diese Komponente im `<div id="root">` im Browser angezeigt wird.

---

### Zusammenfassung

* **React** = Kernbibliothek (Komponenten, State, Hooks).
* **ReactDOM** = Bindeglied zum echten Browser-DOM (Mounting, Rendering).
* Trennung erm√∂glicht, React auch au√üerhalb des Browsers (z. B. mit React Native) zu verwenden.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Einstieg](https://react.dev/learn)
* [ReactDOM API ‚Äì Offizielle Docs](https://react.dev/reference/react-dom)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

5. ### <a name="5"></a> Warum importieren wir React, auch wenn es scheinbar nicht benutzt wird?

Fr√ºher musste man in jeder Datei mit JSX immer **`import React from "react";`** schreiben, auch wenn React im Code nicht direkt benutzt wurde.
Grund: **JSX wird von Babel in `React.createElement`-Aufrufe umgewandelt**, daher war `React` im Scope notwendig.

Seit **React 17 (2020)** wurde das durch die **neue JSX-Transform** ge√§ndert:

* Der Compiler f√ºgt die n√∂tigen Funktionen automatisch hinzu.
* Deshalb muss man `import React` nicht mehr explizit einf√ºgen, wenn man nur JSX nutzt.
* In √§lteren Projekten oder Setups ohne neue Transform ist der Import weiterhin Pflicht.

---

### Beispiel ‚Äì Babel-Umwandlung

**JSX-Eingabe:**

```jsx
const element = <h1>Hallo Welt</h1>;
```

**Transpilierte Ausgabe (vor React 17):**

```js
import React from "react";

const element = React.createElement("h1", null, "Hallo Welt");
```

**Transpilierte Ausgabe (ab React 17 mit neuer JSX-Transform):**

```js
import { jsx as _jsx } from "react/jsx-runtime";

const element = _jsx("h1", { children: "Hallo Welt" });
```

---

### Zusammenfassung

* Fr√ºher: `import React` war n√∂tig, weil JSX ‚Üí `React.createElement` kompiliert wurde.
* Heute (React 17+): Dank neuer JSX-Transform meist **nicht mehr notwendig**.
* Import wird nur gebraucht, wenn man `React` direkt nutzt (z. B. `React.Children`, `React.cloneElement`).

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Neue JSX-Transform](https://react.dev/blog/2020/09/22/introducing-the-new-jsx-transform)
* [MDN ‚Äì JSX](https://developer.mozilla.org/ru/docs/Glossary/JSX)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

6. ### <a name="6"></a> Was ist ein React Fragment und warum ist es n√ºtzlich?

**React Fragment** ist ein spezieller Wrapper (`<React.Fragment>` oder Kurzschreibweise `<>...</>`), mit dem man **mehrere Elemente gruppieren** kann, **ohne zus√§tzliches DOM-Element** (wie `<div>`) zu erzeugen.

---

### Warum n√ºtzlich?

1. **Kein unn√∂tiges DOM-Markup**

   * `<div>`-Wrapper erzeugen oft ‚Äûdiv soup‚Äú und machen das DOM un√ºbersichtlich.
   * Fragmente f√ºgen nichts ins echte DOM ein.

2. **Mehrere Elemente zur√ºckgeben**

   * Eine React-Komponente darf nur **ein einziges Root-Element** zur√ºckgeben.
   * Mit Fragmenten kann man mehrere Geschwister-Elemente zur√ºckgeben.

3. **Performance & Semantik**

   * Weniger DOM-Knoten ‚Üí bessere Performance.
   * Bessere Semantik, da unn√∂tige Container-Elemente vermieden werden.

---

### Beispiel

```jsx
import React from "react";

function UserInfo() {
  return (
    <>
      <h2>Benutzername: Sergii</h2>
      <p>Rolle: Frontend-Entwickler</p>
    </>
  );
}

export default UserInfo;
```

Ohne Fragment m√ºsste man alles in ein `<div>` packen:

```jsx
function UserInfo() {
  return (
    <div>
      <h2>Benutzername: Sergii</h2>
      <p>Rolle: Frontend-Entwickler</p>
    </div>
  );
}
```

Ergebnis im DOM:

* Mit Fragment ‚Üí nur `<h2>` und `<p>`.
* Mit `<div>` ‚Üí unn√∂tiger zus√§tzlicher Container.

---

### Zusammenfassung

* **React Fragment** gruppiert mehrere Elemente ohne zus√§tzliches DOM-Tag.
* Vorteile: sauberes DOM, bessere Semantik, kein ‚Äûdiv soup‚Äú.
* Schreibweisen: `<React.Fragment>...</React.Fragment>` oder `<>...</>`.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Fragments](https://react.dev/reference/react/Fragment)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

7. ### <a name="7"></a> Was ist der Unterschied zwischen einem Element, einer Komponente und einer Instanz?

### Unterschied: Element, Komponente, Instanz

1. **React Element**

   * Ein **leichtes, unver√§nderliches Objekt**, das beschreibt, **was im UI gerendert werden soll**.
   * Wird von JSX erzeugt und dient React als Bauplan.
   * Beispiel:

   ```jsx
   const element = <h1>Hallo</h1>; // React Element
   ```

2. **React Komponente**

   * Eine **Funktion oder Klasse**, die React Elements zur√ºckgibt.
   * Definiert **wie UI-Elemente aufgebaut sind** (Logik + Struktur).
   * Beispiel:

   ```jsx
   function Greeting() {
     return <h1>Hallo Sergii</h1>;
   }
   ```

3. **Instanz einer Komponente**

   * Entsteht, wenn React eine Komponente **rendert** und im UI einsetzt.
   * Jede Verwendung von `<Greeting />` erzeugt eine neue Instanz dieser Komponente.
   * Beispiel:

   ```jsx
   function App() {
     return (
       <>
         <Greeting />   {/* Instanz 1 */}
         <Greeting />   {/* Instanz 2 */}
       </>
     );
   }
   ```

---

### Bildhafte Erkl√§rung

* **Element** = Bauplan/Zwischenschicht (JSX-Output).
* **Komponente** = Definition (Funktion/Klasse).
* **Instanz** = konkrete Auspr√§gung der Komponente im DOM.

---

### Zusammenfassung

* **Element**: unver√§nderliches Objekt, beschreibt UI.
* **Komponente**: Funktion/Klasse, die Elemente zur√ºckgibt.
* **Instanz**: konkrete gerenderte Erscheinung einer Komponente.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Rendering Elements](https://react.dev/learn/render-and-commit)
* [MDN ‚Äì Komponenten-Definition](https://developer.mozilla.org/ru/docs/Glossary/Component)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

8. ### <a name="8"></a> Was ist das Fiber-Architekturmodell in React?

### Fiber-Architekturmodell in React

**React Fiber** ist die **neue Rendering-Engine** von React (seit v16), die das alte ‚ÄûStack Reconciler‚Äú-Modell ersetzt. Ziel: **flexible, unterbrechbare Updates** im UI.

---

### Hauptideen

1. **Unterbrechbare Renderings**

   * Gro√üe UI-Updates k√∂nnen in **kleine Arbeitseinheiten** zerlegt werden.
   * React kann Rendering pausieren, priorisieren oder abbrechen, wenn wichtigere Aufgaben (z. B. User-Input) eintreffen.

2. **Priorisierung von Updates**

   * Updates erhalten eine **Priorit√§t** (z. B. Animation > Datenladen).
   * Dadurch bleibt die UI reaktionsschnell.

3. **Inkremetelles Rendern**

   * Statt den ganzen Baum auf einmal zu rendern, wird er St√ºck f√ºr St√ºck (fiberweise) bearbeitet.

---

### Aufbau

* **Fiber Node**: interner Datenknoten, der eine **Einheit der Arbeit** repr√§sentiert (z. B. eine Komponente oder ein DOM-Element).
* Jeder Fiber enth√§lt Infos wie: Typ der Komponente, Props, State, Nebenwirkungen.

---

### Beispiel (vereinfacht gedacht)

```jsx
function App() {
  return (
    <>
      <Header />
      <Content />
      <Footer />
    </>
  );
}
```

* F√ºr `Header`, `Content`, `Footer` erstellt React einzelne **Fiber-Nodes**.
* React arbeitet diese nacheinander ab, kann aber z. B. `Footer` sp√§ter fertigstellen, wenn ein **User-Klick** sofort verarbeitet werden muss.

---

### Zusammenfassung

* **Fiber** = Reacts Rendering-Engine ab v16.
* Vorteile: unterbrechbare, priorisierte und inkrementelle Renderings.
* Kernziel: **bessere Performance & User Experience** bei komplexen UIs.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Render and Commit](https://react.dev/learn/render-and-commit)
* [React Blog ‚Äì Fiber Architecture](https://reactjs.org/docs/faq-internals.html#what-is-react-fiber)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

9. ### <a name="9"></a> Was bedeutet ‚ÄûBatching‚Äú in React?

### Batching in React

**Batching** bedeutet, dass React mehrere **State-Updates** zusammenfasst und in **einem einzigen Re-Render** ausf√ºhrt, anstatt nach jedem Update sofort zu rendern. Das reduziert unn√∂tige DOM-Updates und verbessert die Performance.

---

### Details

* Standardm√§√üig werden in **Event-Handlern** (z. B. `onClick`) mehrere `setState`-Aufrufe geb√ºndelt.
* Seit **React 18** gilt ‚ÄûAutomatic Batching‚Äú auch f√ºr **Promises, setTimeout, native Events** usw.
* Ohne Batching w√ºrde jede State-√Ñnderung einzeln ein Re-Render ausl√∂sen.

---

### Beispiel

```jsx
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);
  const [text, setText] = useState("");

  function handleClick() {
    setCount(c => c + 1);
    setText("Aktualisiert");
    // Beide Updates werden in EINEM Re-Render geb√ºndelt (Batching)
  }

  return (
    <>
      <p>{count} - {text}</p>
      <button onClick={handleClick}>Update</button>
    </>
  );
}

export default Counter;
```

---

### Zusammenfassung

* **Batching** = mehrere State-Updates ‚Üí ein Re-Render.
* Vorteil: weniger DOM-Updates, bessere Performance.
* Seit React 18: **automatisches Batching √ºberall**, nicht nur in Event-Handlern.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì State Updates Batching](https://react.dev/learn/queueing-a-series-of-state-updates#batching-of-state-updates)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

10. ### <a name="10"></a> Was ist die Rolle des key in React-Listen?

### Rolle des `key` in React-Listen

**`key`** ist ein spezielles Attribut in React, das jeder Listenkomponente zugewiesen wird, um sie **eindeutig zu identifizieren**. Es hilft React beim **Diffing-Prozess** (Vergleich von altem und neuem Virtual DOM), effizient zu erkennen, welche Elemente ge√§ndert, hinzugef√ºgt oder entfernt wurden.

---

### Warum wichtig?

1. **Performance**: React muss nicht die ganze Liste neu rendern, sondern nur die betroffenen Elemente.
2. **Stabilit√§t**: `key` sorgt daf√ºr, dass Komponenteninstanzen korrekt erhalten bleiben (z. B. State in Formularfeldern).
3. **Vorhersehbarkeit**: Ohne eindeutigen Key kann es zu unerwarteten UI-Effekten kommen.

---

### Beispiel

```jsx
const users = ["Anna", "Max", "Sergii"];

function UserList() {
  return (
    <ul>
      {users.map(user => (
        <li key={user}>{user}</li> // key = eindeutiger Identifier
      ))}
    </ul>
  );
}

export default UserList;
```

**Falsch (z. B. Index als Key, nur wenn Daten wirklich stabil sind):**

```jsx
<li key={index}>{user}</li>
```

‚Üí Problematisch, wenn Elemente umsortiert oder gel√∂scht werden.

---

### Zusammenfassung

* **`key`** identifiziert Listenelemente eindeutig.
* Hilft React beim effizienten Re-Rendern und verhindert UI-Fehler.
* Best Practice: stabile, eindeutige IDs nutzen, **nicht** Array-Index.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Schl√ºssel (Keys)](https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

11. ### <a name="11"></a> Wie funktioniert die Wiederverwendung von Komponenten?

### Wiederverwendung von Komponenten in React

**Wiederverwendbarkeit** bedeutet, dass eine Komponente mehrfach in unterschiedlichen Kontexten eingesetzt werden kann, ohne ihren Code zu duplizieren. React erreicht dies durch **Props, Komposition und Children**.

---

### Hauptmechanismen

1. **Props**

   * Komponenten k√∂nnen konfigurierbar gemacht werden, indem man ihnen Daten √ºbergibt.

   ```jsx
   function Button({ label, color }) {
     return <button style={{ background: color }}>{label}</button>;
   }

   export default function App() {
     return (
       <>
         <Button label="Speichern" color="green" />
         <Button label="L√∂schen" color="red" />
       </>
     );
   }
   ```

   ‚Üí Gleiche Komponente, unterschiedliche Darstellung durch Props.

2. **Komposition**

   * Komponenten k√∂nnen andere Komponenten enthalten oder kombinieren.

   ```jsx
   function Card({ children }) {
     return <div className="card">{children}</div>;
   }

   function App() {
     return (
       <Card>
         <h2>Titel</h2>
         <p>Inhalt</p>
       </Card>
     );
   }
   ```

   ‚Üí Card ist wiederverwendbar als Container f√ºr beliebigen Inhalt.

3. **Children & Higher-Order-Komponenten / Render Props**

   * Muster, um Verhalten und Layout flexibel wiederzuverwenden.

---

### Zusammenfassung

* Wiederverwendbarkeit in React basiert auf **Props, Komposition und Children**.
* Eine Komponente kann mehrfach in verschiedenen Kontexten mit unterschiedlicher Konfiguration genutzt werden.
* Ziel: **DRY-Prinzip** (Don‚Äôt Repeat Yourself) und saubere Architektur.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Komposition vs. Vererbung](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

12. ### <a name="12"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

13. ### <a name="13"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

14. ### <a name="14"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

15. ### <a name="15"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

16. ### <a name="16"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

17. ### <a name="17"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

18. ### <a name="18"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

19. ### <a name="19"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

20. ### <a name="20"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

21. ### <a name="21"></a> Was sind Props und wozu werden sie verwendet?

### Props in React

**Props (Properties)** sind **Eingabeparameter**, die von einer Elternkomponente an eine Kindkomponente √ºbergeben werden. Sie machen Komponenten **dynamisch, wiederverwendbar und konfigurierbar**.

---

### Eigenschaften von Props

1. **Read-only** ‚Äì Props k√∂nnen innerhalb der Kindkomponente **nicht ver√§ndert** werden.
2. **Datenfluss** ‚Äì Props folgen dem **Top-down Data Flow** (von Eltern zu Kindern).
3. **Flexibilit√§t** ‚Äì erlauben es, dasselbe UI-Element mit unterschiedlichen Werten zu nutzen.

---

### Beispiel

```jsx
function Greeting({ name }) {
  return <h1>Hallo, {name}!</h1>;
}

function App() {
  return (
    <>
      <Greeting name="Sergii" />
      <Greeting name="Anna" />
    </>
  );
}

export default App;
```

* `Greeting` ist wiederverwendbar.
* `name` wird als Prop √ºbergeben und individuell gerendert.

---

### Zusammenfassung

* **Props** = unver√§nderliche Eingabeparameter f√ºr Komponenten.
* Nutzen: Datenweitergabe, Wiederverwendbarkeit, dynamisches Rendering.
* Props sind **nur lesbar** und werden von Eltern an Kinder √ºbergeben.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Props](https://react.dev/learn/passing-props-to-a-component)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

22. ### <a name="22"></a> Was ist der Unterschied zwischen Props und State?

### Unterschied zwischen **Props** und **State**

1. **Props**

   * Eingabeparameter, die eine Komponente von au√üen (Elternkomponente) erh√§lt.
   * **Unver√§nderlich** innerhalb der Kindkomponente (read-only).
   * Dienen zur **Datenweitergabe** und **Konfiguration**.

2. **State**

   * Interner Zustand einer Komponente, der sich √ºber die Zeit √§ndern kann.
   * Wird mit Hooks wie `useState` verwaltet.
   * √Ñnderungen am State l√∂sen ein **Re-Render** der Komponente aus.

---

### Beispiel

```jsx
import { useState } from "react";

function Counter({ initial }) {   // Prop
  const [count, setCount] = useState(initial); // State

  return (
    <>
      <p>Z√§hler: {count}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
    </>
  );
}

export default function App() {
  return <Counter initial={5} />; // √úbergabe per Prop
}
```

* `initial` = **Prop**, von au√üen √ºbergeben, nicht ver√§nderbar.
* `count` = **State**, geh√∂rt zur Komponente selbst und wird durch User-Interaktion ver√§ndert.

---

### Zusammenfassung

* **Props**: von au√üen, unver√§nderlich, konfigurieren Komponenten.
* **State**: intern, ver√§nderlich, speichert dynamische Daten.
* Zusammenspiel: Props geben Startwerte, State steuert dynamisches Verhalten.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Props vs State](https://react.dev/learn/state-a-components-memory)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

23. ### <a name="23"></a> Warum sind Props nur lesbar?

### Warum Props nur lesbar sind

1. **Eindirektionaler Datenfluss (Top-down Data Flow)**

   * React erzwingt, dass Daten **nur von Eltern zu Kindern** flie√üen.
   * Dadurch bleibt der Datenfluss vorhersehbar und leicht nachvollziehbar.

2. **Unver√§nderlichkeit**

   * Props sind **read-only**, weil sie von au√üen (Elternkomponente) kontrolliert werden.
   * W√ºrden Kinder Props ver√§ndern, k√∂nnte es zu **Inkonsistenzen und schwer nachvollziehbaren Fehlern** kommen.

3. **Wartbarkeit & Debugging**

   * Wenn nur die Eltern Daten √§ndern d√ºrfen, ist klar definiert, **wo Daten herkommen** und **wer sie ver√§ndert**.
   * Das erh√∂ht die Stabilit√§t gro√üer Anwendungen.

---

### Beispiel

```jsx
function Greeting({ name }) {
  // name = Prop, nicht ver√§nderbar
  return <h1>Hallo, {name}</h1>;
}

function App() {
  return <Greeting name="Sergii" />;
}
```

* `Greeting` darf `name` **nicht √ºberschreiben**.
* √Ñnderungen am Wert m√ºssen in der Elternkomponente erfolgen.

---

### Zusammenfassung

* **Props sind nur lesbar**, weil React einen klaren, eindirektionalen Datenfluss erzwingt.
* Eltern kontrollieren die Daten, Kinder konsumieren sie.
* Ergebnis: **Vorhersehbarkeit, Stabilit√§t und einfacheres Debugging**.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Props](https://react.dev/learn/passing-props-to-a-component)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

24. ### <a name="24"></a> Wie funktioniert der unidirektionale Datenfluss in React?

### Unidirektionaler Datenfluss in React

React folgt strikt dem Prinzip des **Top-down Data Flow**:

* **Elternkomponenten** geben Daten √ºber **Props** an ihre **Kindkomponenten** weiter.
* Daten flie√üen **nur in eine Richtung** (von oben nach unten).
* Kindkomponenten k√∂nnen Daten nicht direkt zur√ºckgeben, sondern nur √ºber **Callbacks/Events** √Ñnderungen an die Eltern melden.

---

### Beispiel

```jsx
import { useState } from "react";

function Child({ value, onChange }) {
  return (
    <>
      <p>Aktueller Wert: {value}</p>
      <button onClick={() => onChange(value + 1)}>+1</button>
    </>
  );
}

function Parent() {
  const [count, setCount] = useState(0);

  return <Child value={count} onChange={setCount} />;
}

export default Parent;
```

* `Parent` besitzt den **State**.
* `Child` erh√§lt `value` und `onChange` als **Props**.
* √Ñnderungen flie√üen **√ºber ein Callback** zur√ºck zur Elternkomponente.

---

### Vorteile

1. **Vorhersehbarkeit**: Es ist klar, wo Daten liegen und wie sie sich √§ndern.
2. **Wartbarkeit**: Einfacher zu debuggen, da Daten nur an einer Stelle gepflegt werden.
3. **Stabilit√§t**: Keine unkontrollierten Seiteneffekte durch bidirektionalen Fluss.

---

### Zusammenfassung

* **Unidirektionaler Datenfluss** = Daten von Eltern ‚Üí Kinder (via Props).
* Kinder melden √Ñnderungen durch **Events/Callbacks** zur√ºck.
* Ergebnis: **klare Struktur, bessere Wartbarkeit, weniger Fehler**.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Datenfluss](https://react.dev/learn/passing-props-to-a-component#how-props-flow-through-components)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

25. ### <a name="25"></a> Was ist State in Klassen- und Funktionskomponenten?

### State in React

1. **State in Klassenkomponenten**

   * Wird in einer Klasse als Objekt definiert.
   * Zugriff √ºber `this.state`, √Ñnderungen mit `this.setState()`.

   ```jsx
   import React, { Component } from "react";

   class Counter extends Component {
     constructor(props) {
       super(props);
       this.state = { count: 0 }; // State-Objekt
     }

     render() {
       return (
         <>
           <p>Z√§hler: {this.state.count}</p>
           <button onClick={() => this.setState({ count: this.state.count + 1 })}>
             +1
           </button>
         </>
       );
     }
   }

   export default Counter;
   ```

   * `this.setState()` f√ºhrt **asynchrone Updates** aus und triggert ein Re-Render.

---

2. **State in Funktionskomponenten**

   * Ab React 16.8 mit **Hooks** m√∂glich (`useState`).
   * State ist kein Objekt mehr, sondern ein beliebiger Wert (Primitive oder Objekt).

   ```jsx
   import { useState } from "react";

   function Counter() {
     const [count, setCount] = useState(0); // State-Hook

     return (
       <>
         <p>Z√§hler: {count}</p>
         <button onClick={() => setCount(count + 1)}>+1</button>
       </>
     );
   }

   export default Counter;
   ```

   * `useState` gibt ein Array `[state, updater]` zur√ºck.
   * Updates sind deklarativ und l√∂sen ein Re-Render aus.

---

### Vergleich

| Klassenkomponente              | Funktionskomponente       |
| ------------------------------ | ------------------------- |
| `this.state = { ... }`         | `const [value, setValue]` |
| √Ñnderung mit `this.setState()` | √Ñnderung mit Setter       |
| OOP-Stil                       | Funktional, Hooks         |

---

### Zusammenfassung

* **State = interner Speicher** einer Komponente, der sich √ºber die Zeit √§ndern kann.
* In **Klassen**: Objekt mit `this.state` + Updates via `setState()`.
* In **Funktionen**: `useState`-Hook mit Wert + Setter.
* √Ñnderungen triggern ein **Re-Render** der Komponente.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì State und Lifecycle](https://react.dev/learn/state-a-components-memory)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

26. ### <a name="26"></a> Wie funktioniert setState?

### Funktionsweise von `setState` in React

1. **In Klassenkomponenten**

   * `setState()` ist die Methode zum Aktualisieren des internen **State-Objekts**.
   * Updates sind **asynchron** und werden oft zusammengefasst (**Batching**).
   * `setState` kann ein **Objekt** oder eine **Funktion** akzeptieren.

   ```jsx
   this.setState({ count: this.state.count + 1 }); // Objektform
   this.setState(prev => ({ count: prev.count + 1 })); // Funktionsform (empfohlen)
   ```

2. **In Funktionskomponenten** (`useState`)

   * `setState` ist der **Updater**, den React vom Hook zur√ºckgibt.
   * √úberschreibt den alten Wert durch einen neuen.
   * Akzeptiert direkt einen Wert oder eine Funktion basierend auf dem vorherigen Wert.

   ```jsx
   const [count, setCount] = useState(0);

   setCount(count + 1);          // Wert
   setCount(prev => prev + 1);   // Funktionsform (empfohlen bei Abh√§ngigkeit vom alten Wert)
   ```

---

### Wichtige Eigenschaften

* **Asynchron**: Mehrere Aufrufe von `setState` k√∂nnen gebatcht werden.
* **Re-Render**: Jede √Ñnderung l√∂st ein erneutes Rendern der Komponente aus.
* **Funktionsform** wird bevorzugt, wenn der neue Wert vom alten abh√§ngt.

---

### Zusammenfassung

* `setState` aktualisiert den State und l√∂st ein Re-Render aus.
* In **Klassenkomponenten**: Methode mit Objekt/Funktion.
* In **Funktionskomponenten**: Setter vom `useState`-Hook.
* Updates sind **asynchron** und werden **geb√ºndelt**.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì setState](https://react.dev/reference/react/useState#updating-state-based-on-the-previous-state)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

27. ### <a name="27"></a> Was ist der Unterschied zwischen kontrollierten und unkontrollierten Komponenten?

### Unterschied: Kontrollierte vs. Unkontrollierte Komponenten

1. **Kontrollierte Komponenten**

   * Der **State der Eingabeelemente** (z. B. `input`, `textarea`, `select`) wird in React verwaltet.
   * Der Wert kommt aus dem **State** der Komponente, √Ñnderungen laufen √ºber ein Event-Handler.
   * React = **Single Source of Truth**.

   ```jsx
   import { useState } from "react";

   function ControlledInput() {
     const [value, setValue] = useState("");

     return (
       <input
         value={value} // State bestimmt den Wert
         onChange={e => setValue(e.target.value)} // React kontrolliert
       />
     );
   }
   ```

---

2. **Unkontrollierte Komponenten**

   * Der Wert wird direkt vom **DOM selbst** verwaltet.
   * Zugriff √ºber **Refs** anstatt √ºber State.
   * React kontrolliert den Wert **nicht kontinuierlich**.

   ```jsx
   import { useRef } from "react";

   function UncontrolledInput() {
     const inputRef = useRef();

     const handleClick = () => {
       alert(inputRef.current.value); // Wert direkt aus DOM
     };

     return (
       <>
         <input ref={inputRef} />
         <button onClick={handleClick}>Zeig Wert</button>
       </>
     );
   }
   ```

---

### Vergleich

| Kontrolliert                         | Unkontrolliert                           |
| ------------------------------------ | ---------------------------------------- |
| React verwaltet den Wert (State)     | DOM verwaltet den Wert                   |
| `value` + `onChange`                 | Zugriff via `ref`                        |
| Besser f√ºr Validierung & komplexe UI | Einfacher f√ºr schnelle, kleine Formulare |

---

### Zusammenfassung

* **Kontrollierte Komponenten**: Wert = State in React, √Ñnderungen laufen √ºber Events ‚Üí **voller React-Kontrolle**.
* **Unkontrollierte Komponenten**: Wert = DOM, Zugriff √ºber Ref ‚Üí **schneller, aber weniger flexibel**.
* Best Practice: Kontrollierte Komponenten f√ºr gr√∂√üere UIs, unkontrollierte f√ºr einfache F√§lle.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Forms](https://react.dev/learn/sharing-state-between-components#controlled-and-uncontrolled-components)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

28. ### <a name="28"></a> Was sind Default Props und PropTypes?

### Default Props

* Mit **Default Props** kann man Standardwerte f√ºr Props definieren, falls der Elternkomponente kein Wert √ºbergeben wird.
* Praktisch, um **Fallback-Werte** sicherzustellen.

```jsx
function Button({ label }) {
  return <button>{label}</button>;
}

// Standardwert, falls `label` nicht √ºbergeben wird
Button.defaultProps = {
  label: "Klicken"
};

export default Button;
```

‚Üí In modernen React-Versionen (17+) werden Default Props f√ºr **Funktionskomponenten** weniger genutzt, stattdessen oft **Default-Parameter**:

```jsx
function Button({ label = "Klicken" }) {
  return <button>{label}</button>;
}
```

---

### PropTypes

* **PropTypes** ist ein Typpr√ºfungssystem f√ºr Props zur **Laufzeit**.
* Hilft, Fehler fr√ºh zu erkennen, indem √ºberpr√ºft wird, ob Props den erwarteten Typ haben.

```jsx
import PropTypes from "prop-types";

function User({ name, age }) {
  return <p>{name} ist {age} Jahre alt</p>;
}

User.propTypes = {
  name: PropTypes.string.isRequired,
  age: PropTypes.number
};
```

* Wird ein falscher Typ √ºbergeben, zeigt React im **Konsolen-Log eine Warnung**.

---

### Zusammenfassung

* **Default Props**: legen Standardwerte fest, wenn keine Props √ºbergeben werden.
* **PropTypes**: pr√ºfen Props-Typen **zur Laufzeit** und helfen bei der Fehlervermeidung.
* Heute oft ersetzt durch **TypeScript** f√ºr statische Typisierung.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Typpr√ºfung](https://react.dev/reference/react/Component#static-defaultprops)
* [PropTypes auf npm](https://www.npmjs.com/package/prop-types)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

29. ### <a name="29"></a> Was ist React.memo und wof√ºr wird es verwendet?

### React.memo

**`React.memo`** ist eine **Higher-Order-Komponente (HOC)**, die Funktionskomponenten **memoisiert**.
Das bedeutet: Eine Komponente wird **nur neu gerendert, wenn sich ihre Props √§ndern**.

---

### Wof√ºr wird es verwendet?

1. **Performance-Optimierung**

   * Verhindert unn√∂tige Re-Renders bei unver√§nderten Props.
   * Besonders sinnvoll bei **teuren Berechnungen** oder **gro√üen Listen**.

2. **Vergleich der Props**

   * Standardm√§√üig nutzt React einen **shallow comparison** (flacher Vergleich).
   * F√ºr komplexe Objekte kann man eine eigene Vergleichsfunktion √ºbergeben.

---

### Beispiel

```jsx
import React, { useState } from "react";

const Child = React.memo(function Child({ value }) {
  console.log("Render:", value);
  return <p>Wert: {value}</p>;
});

export default function App() {
  const [count, setCount] = useState(0);
  const [text, setText] = useState("");

  return (
    <>
      <Child value={count} />
      <button onClick={() => setCount(count + 1)}>+1</button>
      <input value={text} onChange={e => setText(e.target.value)} />
    </>
  );
}
```

* `Child` rendert nur neu, wenn sich `value` √§ndert.
* √Ñnderungen an `text` haben **keinen Einfluss** auf `Child`.

---

### Zusammenfassung

* **`React.memo`** = Memoization f√ºr Funktionskomponenten.
* Verhindert unn√∂tige Re-Renders, wenn Props unver√§ndert bleiben.
* Standard: **shallow comparison**, optional eigene Vergleichsfunktion.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì React.memo](https://react.dev/reference/react/memo)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

30. ### <a name="30"></a> Was ist PureComponent und wie unterscheidet es sich von Component?

### PureComponent vs. Component

1. **`React.Component`**

   * Basis-Klasse f√ºr Klassenkomponenten.
   * F√ºhrt bei jedem `setState` oder neuen Props ein Re-Render durch, auch wenn sich die Werte nicht tats√§chlich ge√§ndert haben.

2. **`React.PureComponent`**

   * Erweiterung von `Component`.
   * F√ºhrt **automatisch einen shallow comparison** (flachen Vergleich) von Props und State durch.
   * Rendert nur neu, wenn sich **wirklich etwas ge√§ndert hat**.

---

### Beispiel

```jsx
import React, { Component, PureComponent } from "react";

class NormalComponent extends Component {
  render() {
    console.log("NormalComponent gerendert");
    return <p>{this.props.value}</p>;
  }
}

class OptimizedComponent extends PureComponent {
  render() {
    console.log("PureComponent gerendert");
    return <p>{this.props.value}</p>;
  }
}
```

* `NormalComponent` rendert bei **jeder Aktualisierung**, auch wenn `value` gleich bleibt.
* `OptimizedComponent` rendert **nur, wenn sich `value` ge√§ndert hat**.

---

### Unterschiede im √úberblick

| **Component**                         | **PureComponent**                                 |
| ------------------------------------- | ------------------------------------------------- |
| Rendert immer bei Updates             | Rendert nur bei √Ñnderungen (shallow compare)      |
| Keine Optimierung                     | Eingebaute Performance-Optimierung                |
| Manuell `shouldComponentUpdate` n√∂tig | `shouldComponentUpdate` automatisch implementiert |

---

### Zusammenfassung

* **Component**: rendert immer neu bei Updates.
* **PureComponent**: optimiert, rendert nur bei tats√§chlichen √Ñnderungen (shallow compare).
* Ziel: **Performance-Optimierung** bei Klassenkomponenten.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì PureComponent](https://react.dev/reference/react/PureComponent)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

31. ### <a name="31"></a> Wann sollte shouldComponentUpdate verwendet werden?

### `shouldComponentUpdate` in React

**`shouldComponentUpdate(nextProps, nextState)`** ist eine Lifecycle-Methode in **Klassenkomponenten**, die bestimmt, ob ein Re-Render stattfinden soll.
Sie gibt **true** (neu rendern) oder **false** (kein Render) zur√ºck.

---

### Wann einsetzen?

1. **Performance-Optimierung**

   * Wenn eine Komponente sehr oft aktualisiert wird, aber die meisten Updates keine sichtbaren √Ñnderungen im UI verursachen.
   * Durch R√ºckgabe von `false` k√∂nnen unn√∂tige Re-Renders vermieden werden.

2. **Feinsteuerung**

   * Wenn der Standardvergleich von `PureComponent` (shallow compare) nicht ausreicht.
   * Beispiel: tiefe Objektstrukturen, die differenziert gepr√ºft werden m√ºssen.

---

### Beispiel

```jsx
import React, { Component } from "react";

class User extends Component {
  shouldComponentUpdate(nextProps) {
    // Nur neu rendern, wenn sich der Name ge√§ndert hat
    return nextProps.name !== this.props.name;
  }

  render() {
    console.log("Rendering:", this.props.name);
    return <p>{this.props.name}</p>;
  }
}

export default User;
```

---

### Zusammenfassung

* **`shouldComponentUpdate`** steuert, ob ein Re-Render notwendig ist.
* Sinnvoll bei **Performance-Optimierungen** und **kontrollierten Updates**.
* Heute oft ersetzt durch **PureComponent** oder **React.memo** in Funktionskomponenten.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì shouldComponentUpdate](https://react.dev/reference/react/Component#shouldcomponentupdate)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

32. ### <a name="32"></a> Was ist ein ref und wann wird er eingesetzt?

### Ref in React

Ein **ref (reference)** ist ein spezielles Objekt in React, mit dem man direkt auf ein **DOM-Element** oder eine **Komponenteninstanz** zugreifen kann. Refs werden mit `useRef` (Funktionskomponenten) oder `React.createRef` (Klassenkomponenten) erstellt.

---

### Wann einsetzen?

1. **Direkter Zugriff auf DOM-Elemente**

   * Fokus setzen, Text selektieren, Scrollen steuern.

2. **Speichern von ver√§nderlichen Werten**

   * Werte zwischen Renders behalten, ohne ein Re-Render auszul√∂sen.

3. **Integration mit Drittbibliotheken**

   * z. B. Zugriff auf Canvas, Charts, Animationen.

---

### Beispiele

**Funktionskomponente mit `useRef`:**

```jsx
import { useRef } from "react";

function InputFocus() {
  const inputRef = useRef();

  const handleClick = () => {
    inputRef.current.focus(); // direkter DOM-Zugriff
  };

  return (
    <>
      <input ref={inputRef} type="text" />
      <button onClick={handleClick}>Fokus setzen</button>
    </>
  );
}

export default InputFocus;
```

**Persistente Werte ohne Re-Render:**

```jsx
import { useRef, useState } from "react";

function Timer() {
  const countRef = useRef(0);
  const [stateCount, setStateCount] = useState(0);

  const increment = () => {
    countRef.current += 1;      // kein Re-Render
    setStateCount(stateCount+1); // triggert Re-Render
  };

  return (
    <p>Ref: {countRef.current}, State: {stateCount}</p>
  );
}
```

---

### Zusammenfassung

* **Refs** = direkte Referenzen auf DOM-Elemente oder persistente Werte.
* Einsatz: Fokus, Scroll, Animationssteuerung, Integration mit Drittlibs, Werte speichern ohne Re-Render.
* Erstellung: `useRef` (Hooks), `createRef` (Klassen).

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Refs](https://react.dev/learn/referencing-values-with-refs)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

33. ### <a name="33"></a> Was bedeutet ‚ÄûLifting State Up‚Äú?

### Lifting State Up in React

**Lifting State Up** bedeutet, dass man den **State aus einer Kindkomponente in die gemeinsame Elternkomponente verlagert**, wenn mehrere Komponenten denselben Zustand ben√∂tigen.
So entsteht **eine gemeinsame Quelle der Wahrheit** (Single Source of Truth), und der Datenfluss bleibt **eindirektional**.

---

### Beispiel

```jsx
import { useState } from "react";

function TemperatureInput({ label, value, onChange }) {
  return (
    <>
      <label>{label}: </label>
      <input
        type="number"
        value={value}
        onChange={e => onChange(e.target.value)}
      />
    </>
  );
}

function Calculator() {
  const [temperature, setTemperature] = useState("");

  return (
    <>
      <TemperatureInput
        label="Celsius"
        value={temperature}
        onChange={setTemperature}
      />
      <TemperatureInput
        label="Fahrenheit"
        value={(temperature * 9) / 5 + 32}
        onChange={val => setTemperature(((val - 32) * 5) / 9)}
      />
    </>
  );
}

export default Calculator;
```

* Beide Inputs teilen sich denselben **State in der Elternkomponente**.
* √Ñnderungen an einem Feld werden sofort im anderen reflektiert.

---

### Zusammenfassung

* **Lifting State Up** = Verschieben von State in die **Elternkomponente**, um Daten zwischen Kindern zu synchronisieren.
* Vorteile: eine gemeinsame Wahrheit, konsistenter Datenfluss, bessere Wartbarkeit.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Lifting State Up](https://react.dev/learn/sharing-state-between-components#lifting-state-up)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

34. ### <a name="34"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

35. ### <a name="35"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

36. ### <a name="36"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

37. ### <a name="37"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

38. ### <a name="38"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

39. ### <a name="39"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

40. ### <a name="40"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

41. ### <a name="41"></a> Was sind die Phasen des Komponentenlebenszyklus?

### Phasen des Komponentenlebenszyklus (Class Components)

In React (bei **Klassenkomponenten**) besteht der **Lebenszyklus** einer Komponente aus drei Hauptphasen:

1. **Mounting (Einf√ºgen ins DOM)**

   * Methoden:

     * `constructor()`
     * `static getDerivedStateFromProps()`
     * `render()`
     * `componentDidMount()`

2. **Updating (Aktualisierung bei Props/State-√Ñnderungen)**

   * Methoden:

     * `static getDerivedStateFromProps()`
     * `shouldComponentUpdate()`
     * `render()`
     * `getSnapshotBeforeUpdate()`
     * `componentDidUpdate()`

3. **Unmounting (Entfernen aus dem DOM)**

   * Methode:

     * `componentWillUnmount()`

---

### Beispiel

```jsx
import React, { Component } from "react";

class Demo extends Component {
  constructor(props) {
    super(props);
    console.log("1. constructor");
    this.state = { count: 0 };
  }

  componentDidMount() {
    console.log("4. componentDidMount");
  }

  shouldComponentUpdate() {
    console.log("Update? -> true");
    return true;
  }

  componentDidUpdate() {
    console.log("componentDidUpdate");
  }

  componentWillUnmount() {
    console.log("componentWillUnmount");
  }

  render() {
    console.log("render()");
    return (
      <button onClick={() => this.setState({ count: this.state.count + 1 })}>
        {this.state.count}
      </button>
    );
  }
}

export default Demo;
```

---

### Vergleich zu Hooks

* **Mounting/Updating/Unmounting** wird heute meist mit **`useEffect`** in Funktionskomponenten abgebildet.

```jsx
import { useState, useEffect } from "react";

function Demo() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log("Mounting & Updating");
    return () => console.log("Unmounting");
  }, [count]);

  return <button onClick={() => setCount(count + 1)}>{count}</button>;
}
```

---

### Zusammenfassung

* Lebenszyklus hat drei Phasen: **Mounting, Updating, Unmounting**.
* Klassenkomponenten nutzen Methoden (`componentDidMount`, `componentDidUpdate`, `componentWillUnmount`).
* Funktionskomponenten verwenden stattdessen **Hooks (useEffect)**.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Lifecycle](https://react.dev/reference/react/Component)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

42. ### <a name="42"></a> Welche Lifecycle-Methoden gibt es in Klassenkomponenten?

### Lifecycle-Methoden in Klassenkomponenten

React-Klassenkomponenten haben verschiedene Lifecycle-Methoden, die in drei Phasen eingeteilt werden:

---

#### 1. **Mounting (Einf√ºgen ins DOM)**

* `constructor()` ‚Üí Initialisierung von State und Binding.
* `static getDerivedStateFromProps(props, state)` ‚Üí selten genutzt, synchronisiert State mit Props.
* `render()` ‚Üí gibt das JSX zur√ºck.
* `componentDidMount()` ‚Üí ausgef√ºhrt **nach dem ersten Render**, ideal f√ºr API-Calls oder DOM-Manipulation.

---

#### 2. **Updating (bei Props/State-√Ñnderungen)**

* `static getDerivedStateFromProps(props, state)` ‚Üí wird auch hier aufgerufen.
* `shouldComponentUpdate(nextProps, nextState)` ‚Üí entscheidet, ob Re-Render n√∂tig ist (Performance-Optimierung).
* `render()` ‚Üí erneutes Rendern der Komponente.
* `getSnapshotBeforeUpdate(prevProps, prevState)` ‚Üí Zugriff auf DOM vor dem Update.
* `componentDidUpdate(prevProps, prevState, snapshot)` ‚Üí nach dem Rendern, gut f√ºr Netzwerkaufrufe oder DOM-Updates.

---

#### 3. **Unmounting (Entfernen aus DOM)**

* `componentWillUnmount()` ‚Üí Aufr√§umarbeiten (Timer clearen, Event Listener entfernen).

---

#### 4. **Error Handling (seit React 16)**

* `static getDerivedStateFromError(error)` ‚Üí f√§ngt Fehler ab, bevor UI zusammenbricht.
* `componentDidCatch(error, info)` ‚Üí Logging von Fehlern.

---

### Zusammenfassung

* **Mounting**: `constructor`, `getDerivedStateFromProps`, `render`, `componentDidMount`.
* **Updating**: `getDerivedStateFromProps`, `shouldComponentUpdate`, `render`, `getSnapshotBeforeUpdate`, `componentDidUpdate`.
* **Unmounting**: `componentWillUnmount`.
* **Error Handling**: `getDerivedStateFromError`, `componentDidCatch`.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Component API](https://react.dev/reference/react/Component)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

43. ### <a name="43"></a> Welche Lifecycle-Methoden sind veraltet?

### Veraltete Lifecycle-Methoden in React

Einige Lifecycle-Methoden von **Klassenkomponenten** gelten seit **React 16.3** als **deprecated** (veraltet), weil sie oft zu **Fehlern und unerwartetem Verhalten** f√ºhrten.

---

### Veraltete Methoden

1. **`componentWillMount()`**

   * Wurde vor dem ersten Render ausgef√ºhrt.
   * Ersetzt durch: **`constructor`** oder **`componentDidMount`**.

2. **`componentWillReceiveProps(nextProps)`**

   * Wurde bei neuen Props aufgerufen.
   * Ersetzt durch: **`static getDerivedStateFromProps`** oder **`componentDidUpdate`**.

3. **`componentWillUpdate(nextProps, nextState)`**

   * Wurde vor einem Update aufgerufen.
   * Ersetzt durch: **`getSnapshotBeforeUpdate`** oder **`componentDidUpdate`**.

---

### UNSAFE_-Pr√§fix

Seit React 16.3 existieren diese Methoden noch, aber mit **`UNSAFE_`-Pr√§fix**, z. B.:

* `UNSAFE_componentWillMount`
* `UNSAFE_componentWillReceiveProps`
* `UNSAFE_componentWillUpdate`

---

### Zusammenfassung

* Veraltet: `componentWillMount`, `componentWillReceiveProps`, `componentWillUpdate`.
* Grund: sie verursachen **Side-Effects** im falschen Zeitpunkt.
* Alternative: **`getDerivedStateFromProps`, `componentDidMount`, `componentDidUpdate`, `getSnapshotBeforeUpdate`**.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì UNSAFE Lifecycle Methods](https://react.dev/reference/react/Component#unsafe_componentwillmount)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

44. ### <a name="44"></a> Wie kann man Lifecycle-Methoden mit Hooks ersetzen?

### Lifecycle-Methoden ‚Üí Hooks: 1:1-Ersatz und Patterns

| Klassen-Lifecycle                                             | Entsprechung mit Hooks (Funktionskomponenten)                                                                                | Hinweis                                                              |
| ------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------- |
| `constructor`                                                 | Initial-State via `useState(initial)`                                                                                        | Auch f√ºr Event-Handler-Binding nicht n√∂tig.                          |
| `componentDidMount`                                           | `useEffect(() => { /* init */ }, [])`                                                                                        | L√§uft nach dem ersten Render (commit).                               |
| `componentDidUpdate`                                          | `useEffect(() => { /* reagiert auf deps */ }, [deps])`                                                                       | L√§uft nach jedem Render, wenn `deps` sich √§ndern.                    |
| `componentWillUnmount`                                        | Cleanup-Funktion in `useEffect`: `return () => {/* cleanup */}`                                                              | Abmelden von Listenern, Timer clearen etc.                           |
| `shouldComponentUpdate`                                       | Strukturell: `React.memo(Component)`; feingranular: `useMemo`, `useCallback`                                                 | Verhindert unn√∂tige Re-Renders.                                      |
| `getDerivedStateFromProps`                                    | Meist **vermeiden**. Alternativen: ableiten im Render, `useMemo` f√ºr teure Ableitungen, oder `useEffect` zum Synchronisieren | Props nicht in State duplizieren, wenn m√∂glich.                      |
| `getSnapshotBeforeUpdate` ‚Üí `componentDidUpdate`              | `useLayoutEffect` + `useRef` f√ºr **Layout-Messungen** vor dem Paint; Vor-/Nachwerte per Ref speichern                        | `useLayoutEffect` l√§uft synchron nach DOM-Mutationen, vor dem Paint. |
| Fehlergrenzen: `getDerivedStateFromError`/`componentDidCatch` | **Kein Hook-√Ñquivalent**. Error Boundaries weiterhin als **Klassenkomponenten** implementieren                               | Alternativ: vorhandene Boundary-Komponenten wiederverwenden.         |

---

### Minimalbeispiele

**Mount/Update/Unmount (Effect + Cleanup)**

```jsx
import { useEffect, useState } from "react";

export default function Chat() {
  const [connected, setConnected] = useState(false);

  useEffect(() => {
    const conn = connect();       // componentDidMount / DidUpdate (deps s.u.)
    setConnected(true);
    return () => conn.disconnect(); // componentWillUnmount
  }, []); // leeres Array: nur einmal nach Mount

  return <p>{connected ? "Online" : "Offline"}</p>;
}
```

**shouldComponentUpdate ‚Üí React.memo**

```jsx
import React, { useMemo } from "react";

const List = React.memo(function List({ items }) {
  const total = useMemo(() => items.reduce((s, x) => s + x.value, 0), [items]);
  return <p>Total: {total}</p>;
});

export default List;
```

**getDerivedStateFromProps vermeiden (Ableitung statt Spiegeln)**

```jsx
import { useMemo } from "react";

// Statt Prop -> State-Spiegelung:
export default function Price({ net, vatPercent }) {
  const gross = useMemo(() => net * (1 + vatPercent / 100), [net, vatPercent]);
  return <span>{gross.toFixed(2)} ‚Ç¨</span>;
}
```

**getSnapshotBeforeUpdate ‚Üí useLayoutEffect f√ºr Layout/Scroll**

```jsx
import { useLayoutEffect, useRef } from "react";

export default function AutoScroll({ messages }) {
  const listRef = useRef(null);
  const prevLen = useRef(0);

  useLayoutEffect(() => {
    const list = listRef.current;
    const nearBottom =
      list.scrollHeight - list.scrollTop - list.clientHeight < 20;

    // l√§uft nach DOM-Mutationen, vor dem Paint
    if (nearBottom || messages.length < prevLen.current) {
      list.scrollTop = list.scrollHeight; // ‚ÄûSnapshot‚Äú-artiges Verhalten
    }
    prevLen.current = messages.length;
  }, [messages]);

  return (
    <ul ref={listRef} style={{ maxHeight: 200, overflow: "auto" }}>
      {messages.map(m => <li key={m.id}>{m.text}</li>)}
    </ul>
  );
}
```

**Fehlergrenze (weiterhin Klasse)**

```jsx
import React from "react";

export class ErrorBoundary extends React.Component {
  state = { hasError: false };

  static getDerivedStateFromError() {
    return { hasError: true };
  }
  componentDidCatch(error, info) {
    console.error(error, info);
  }
  render() {
    return this.state.hasError ? <h1>Etwas ging schief.</h1> : this.props.children;
  }
}
```

---

### Zusammenfassung

* Mount/Update/Unmount: `useEffect` (mit/ohne deps) + **Cleanup**.
* Rendersteuerung: `React.memo`, `useMemo`, `useCallback`.
* Layout-kritisch: `useLayoutEffect` + `useRef`.
* `getDerivedStateFromProps` meist vermeiden (Props nicht spiegeln).
* Error Boundaries: weiterhin **Klassenkomponenten**.

üìñ Weiterf√ºhrend:

* React Docs: [Effects](https://react.dev/learn/synchronizing-with-effects), [useEffect](https://react.dev/reference/react/useEffect), [useLayoutEffect](https://react.dev/reference/react/useLayoutEffect), [Memoisierung](https://react.dev/learn/escape-hatches#memoizing-calculations), [React.memo](https://react.dev/reference/react/memo), [Error Boundaries](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary)
* MDN (RU): [–°–æ–±—ã—Ç–∏—è](https://developer.mozilla.org/ru/docs/Learn/JavaScript/Building_blocks/Events), [requestAnimationFrame](https://developer.mozilla.org/ru/docs/Web/API/window/requestAnimationFrame) (Kontext f√ºr Layout/Rendering-Zeitpunkte)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

45. ### <a name="45"></a> Was ist componentDidMount und was ist das √Ñquivalent mit Hooks?

### `componentDidMount` in Klassenkomponenten

* Wird **einmal nach dem ersten Render** ausgef√ºhrt, sobald die Komponente ins DOM eingef√ºgt wurde.
* Typische Eins√§tze:

  * **API-Requests starten**
  * **Event-Listener registrieren**
  * **DOM-Manipulationen** (Fokus setzen etc.)

```jsx
import React, { Component } from "react";

class Demo extends Component {
  componentDidMount() {
    console.log("Komponente wurde gemountet");
    document.title = "Hallo Sergii";
  }

  render() {
    return <h1>Hallo</h1>;
  }
}
```

---

### √Ñquivalent mit Hooks ‚Üí `useEffect`

In Funktionskomponenten √ºbernimmt `useEffect` die Rolle von Lifecycle-Methoden.

* **√Ñquivalent zu `componentDidMount`:** `useEffect` mit leerem Abh√§ngigkeitsarray `[]`.

```jsx
import { useEffect } from "react";

function Demo() {
  useEffect(() => {
    console.log("Komponente wurde gemountet");
    document.title = "Hallo Sergii";
  }, []); // leeres Array -> nur beim ersten Mount

  return <h1>Hallo</h1>;
}

export default Demo;
```

---

### Zusammenfassung

* **`componentDidMount`**: l√§uft einmal nach dem Einf√ºgen ins DOM (Klassenkomponenten).
* **Hook-√Ñquivalent**: `useEffect(() => { ... }, [])` in Funktionskomponenten.
* Typische Nutzung: API-Calls, Event-Registrierung, DOM-Manipulation.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì useEffect](https://react.dev/reference/react/useEffect)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

46. ### <a name="46"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

47. ### <a name="47"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

48. ### <a name="48"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

49. ### <a name="49"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

50. ### <a name="50"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

51. ### <a name="51"></a> Was sind Hooks in React?

### Hooks in React

**Hooks** sind spezielle **Funktionen**, die es erm√∂glichen, in **Funktionskomponenten** React-Features wie **State, Lifecycle-Methoden und Context** zu nutzen ‚Äì ohne Klassenkomponenten zu schreiben. Sie wurden mit **React 16.8** eingef√ºhrt.

---

### Warum Hooks?

1. Ersetzen viele Anwendungsf√§lle von **Klassenkomponenten**.
2. Erlauben **Wiederverwendung von Logik** (Custom Hooks).
3. Machen Code **k√ºrzer, klarer und besser testbar**.

---

### Wichtige eingebaute Hooks

* **State**: `useState` ‚Üí lokaler Zustand.
* **Lifecycle/Side Effects**: `useEffect`, `useLayoutEffect`.
* **Referenzen**: `useRef`.
* **Performance**: `useMemo`, `useCallback`.
* **Context**: `useContext`.
* **Reducer**: `useReducer` f√ºr komplexere State-Logik.

---

### Beispiel

```jsx
import { useState, useEffect } from "react";

function Counter() {
  const [count, setCount] = useState(0); // State-Hook

  useEffect(() => {
    document.title = `Z√§hler: ${count}`; // Effect-Hook (componentDidMount/DidUpdate)
  }, [count]);

  return (
    <>
      <p>Z√§hler: {count}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
    </>
  );
}

export default Counter;
```

---

### Zusammenfassung

* **Hooks = Funktionen**, die React-Features (State, Lifecycle, Context) in **Funktionskomponenten** bringen.
* Vorteil: keine Klassen mehr n√∂tig, bessere Wiederverwendung von Logik.
* Kernhooks: `useState`, `useEffect`, `useContext`, `useRef`, `useMemo`, `useCallback`.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Einf√ºhrung in Hooks](https://react.dev/learn/state-a-components-memory#using-hooks)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

52. ### <a name="52"></a> Wie funktionieren useState und useEffect?

### `useState`

* `useState` ist ein Hook, der in einer **Funktionskomponente** lokalen State speichert.
* Er liefert ein **Array mit zwei Werten**: `[aktuellerState, SetterFunktion]`.
* √Ñnderungen √ºber den Setter triggern ein **Re-Render** der Komponente.

```jsx
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0); // Initialwert = 0

  return (
    <>
      <p>Z√§hler: {count}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
    </>
  );
}
```

---

### `useEffect`

* `useEffect` erm√∂glicht **Side Effects** in Funktionskomponenten (z. B. API-Calls, Event-Listener, DOM-Manipulation).
* Standardm√§√üig l√§uft er **nach jedem Render**.
* Mit **Abh√§ngigkeitsarray** kann man steuern:

  * `[]` ‚Üí nur beim ersten Mount (`componentDidMount`).
  * `[deps]` ‚Üí bei √Ñnderungen der Abh√§ngigkeiten (`componentDidUpdate`).
  * Cleanup-Funktion ‚Üí beim Unmount (`componentWillUnmount`).

```jsx
import { useEffect, useState } from "react";

function Timer() {
  const [seconds, setSeconds] = useState(0);

  useEffect(() => {
    const id = setInterval(() => setSeconds(s => s + 1), 1000);

    return () => clearInterval(id); // Cleanup beim Unmount
  }, []);

  return <p>Timer: {seconds}s</p>;
}
```

---

### Zusammenfassung

* **`useState`**: lokaler State in Funktionskomponenten (`[state, setState]`).
* **`useEffect`**: verwaltet Side Effects (API, Timer, DOM), inkl. Cleanup.
* Zusammen bilden sie das Grundger√ºst f√ºr State-Management und Lifecycle-Handling in React.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì useState](https://react.dev/reference/react/useState)
* [React Offizielle Dokumentation ‚Äì useEffect](https://react.dev/reference/react/useEffect)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

53. ### <a name="53"></a> Was macht useContext?

### `useContext` in React

* **`useContext`** ist ein Hook, der Zugriff auf den Wert eines **React Contexts** erm√∂glicht.
* Er ersetzt die Notwendigkeit, Props durch viele Komponenten weiterzureichen (**Prop Drilling**).
* Jede Komponente, die `useContext` nutzt, wird neu gerendert, sobald sich der Context-Wert √§ndert.

---

### Beispiel

```jsx
import { createContext, useContext } from "react";

// 1. Context erstellen
const ThemeContext = createContext("light");

function ThemedButton() {
  // 2. Zugriff auf den aktuellen Wert
  const theme = useContext(ThemeContext);
  return <button className={theme}>Klick mich</button>;
}

export default function App() {
  return (
    // 3. Provider legt den Wert fest
    <ThemeContext.Provider value="dark">
      <ThemedButton />
    </ThemeContext.Provider>
  );
}
```

* `ThemeContext.Provider` ‚Üí stellt den Wert (`"dark"`) bereit.
* `useContext(ThemeContext)` ‚Üí liest den Wert aus, ohne Props weiterzureichen.

---

### Zusammenfassung

* **`useContext`**: Hook zum direkten Zugriff auf einen Context-Wert.
* Nutzen: Vermeidet **Prop Drilling**, ideal f√ºr globale Daten (Theme, Auth, Sprache).
* √Ñnderung des Contexts ‚Üí Re-Render aller abh√§ngigen Komponenten.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì useContext](https://react.dev/reference/react/useContext)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

54. ### <a name="54"></a> Was ist useRef und wann wird es verwendet?

### `useRef` in React

* **`useRef`** ist ein Hook, der ein **ver√§nderbares Objekt mit der Eigenschaft `.current`** zur√ºckgibt.
* Dieses Objekt bleibt **√ºber die gesamte Lebensdauer** der Komponente gleich.
* √Ñnderungen an `.current` l√∂sen **kein Re-Render** aus.

---

### Wann wird `useRef` verwendet?

1. **Direkter Zugriff auf DOM-Elemente**

   * Fokus setzen, Scroll-Position manipulieren, Integration mit Drittbibliotheken.

2. **Speichern von Werten zwischen Renders**

   * Persistente Werte behalten (z. B. Timer-ID, vorheriger Wert).

3. **Performance-Optimierung**

   * Verhindern, dass ein Wert bei jedem Render neu erzeugt wird.

---

### Beispiele

**DOM-Zugriff:**

```jsx
import { useRef } from "react";

function InputFocus() {
  const inputRef = useRef();

  const handleClick = () => {
    inputRef.current.focus(); // Zugriff auf das DOM-Element
  };

  return (
    <>
      <input ref={inputRef} type="text" />
      <button onClick={handleClick}>Fokus setzen</button>
    </>
  );
}
```

**Persistenter Wert (kein Re-Render):**

```jsx
import { useRef, useEffect } from "react";

function Timer() {
  const count = useRef(0);

  useEffect(() => {
    const id = setInterval(() => {
      count.current += 1; // Wert √§ndern ohne Re-Render
      console.log("Sekunden:", count.current);
    }, 1000);
    return () => clearInterval(id);
  }, []);

  return <p>Siehe Konsole</p>;
}
```

---

### Zusammenfassung

* **`useRef`** speichert eine ver√§nderbare Referenz (`.current`) √ºber Renders hinweg.
* Einsatz: DOM-Zugriffe, persistente Werte, Performance-Optimierung.
* Unterschied zu State: **√Ñnderungen an `useRef` triggern kein Re-Render**.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì useRef](https://react.dev/reference/react/useRef)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

55. ### <a name="55"></a> Was ist useCallback, useMemo, useReducer?

### 1. `useCallback`

* Gibt eine **memoisierte Callback-Funktion** zur√ºck.
* N√ºtzlich, um **unn√∂tige Re-Renders** von Kindkomponenten zu vermeiden, die eine Callback-Prop erhalten.
* Nur neu erstellt, wenn sich die Abh√§ngigkeiten √§ndern.

```jsx
import { useState, useCallback } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  const increment = useCallback(() => setCount(c => c + 1), []);
  // gleiche Funktion bleibt √ºber Renders hinweg erhalten

  return <button onClick={increment}>{count}</button>;
}
```

---

### 2. `useMemo`

* Gibt einen **memoisierten Wert** zur√ºck.
* Verhindert, dass **teure Berechnungen** bei jedem Render erneut ausgef√ºhrt werden.
* Nur neu berechnet, wenn sich die Abh√§ngigkeiten √§ndern.

```jsx
import { useState, useMemo } from "react";

function ExpensiveCalc({ num }) {
  const result = useMemo(() => {
    console.log("Teure Berechnung...");
    return num * 2;
  }, [num]);

  return <p>Ergebnis: {result}</p>;
}
```

---

### 3. `useReducer`

* Alternative zu `useState`, besonders f√ºr **komplexe State-Logik** oder **mehrere verbundene Zust√§nde**.
* Funktioniert √§hnlich wie ein **Redux-Reducer**: `state` + `action` ‚Üí neuer `state`.

```jsx
import { useReducer } from "react";

function reducer(state, action) {
  switch (action.type) {
    case "increment":
      return { count: state.count + 1 };
    case "decrement":
      return { count: state.count - 1 };
    default:
      return state;
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, { count: 0 });

  return (
    <>
      <p>Z√§hler: {state.count}</p>
      <button onClick={() => dispatch({ type: "increment" })}>+1</button>
      <button onClick={() => dispatch({ type: "decrement" })}>-1</button>
    </>
  );
}
```

---

### Zusammenfassung

* **`useCallback`**: memoisiert Funktionen ‚Üí vermeidet unn√∂tige Neu-Erstellungen.
* **`useMemo`**: memoisiert Werte ‚Üí verhindert teure Neuberechnungen.
* **`useReducer`**: State-Management f√ºr komplexe Logik, basierend auf Reducer-Pattern.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì useCallback](https://react.dev/reference/react/useCallback)
* [React Offizielle Dokumentation ‚Äì useMemo](https://react.dev/reference/react/useMemo)
* [React Offizielle Dokumentation ‚Äì useReducer](https://react.dev/reference/react/useReducer)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

56. ### <a name="56"></a> Wie schreibt man einen benutzerdefinierten Hook?

### Benutzerdefinierte Hooks (Custom Hooks)

Ein **Custom Hook** ist eine normale **JavaScript-Funktion**, deren Name mit **`use`** beginnt und die **React Hooks** (z. B. `useState`, `useEffect`) verwendet.
Zweck: **Wiederverwendung von Logik** in verschiedenen Komponenten.

---

### Regeln

1. Name muss mit `use...` beginnen.
2. Darf nur innerhalb von React-Komponenten oder anderen Hooks verwendet werden.
3. Muss die [Regeln der Hooks](https://react.dev/warnings/rules-of-hooks) einhalten: nur **Top-Level**, niemals in Schleifen oder Bedingungen.

---

### Beispiel ‚Äì Fensterbreite beobachten

```jsx
import { useState, useEffect } from "react";

// Custom Hook
function useWindowWidth() {
  const [width, setWidth] = useState(window.innerWidth);

  useEffect(() => {
    const handleResize = () => setWidth(window.innerWidth);
    window.addEventListener("resize", handleResize);

    return () => window.removeEventListener("resize", handleResize);
  }, []);

  return width; // gibt Wert zur√ºck
}

// Nutzung in einer Komponente
export default function App() {
  const width = useWindowWidth();

  return <p>Aktuelle Fensterbreite: {width}px</p>;
}
```

---

### Zusammenfassung

* **Custom Hook** = Funktion mit `use...`, die Hooks nutzt, um Logik wiederverwendbar zu machen.
* Vorteile: **Code-Wiederverwendung, bessere Lesbarkeit, klarere Trennung von Logik und UI**.
* Beispiel: `useWindowWidth`, `useFetch`, `useForm`.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Eigene Hooks](https://react.dev/learn/reusing-logic-with-custom-hooks)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

57. ### <a name="57"></a> Wie verhindert man eine Endlosschleife in useEffect?

### Endlosschleifen in `useEffect`

Eine Endlosschleife entsteht, wenn **State im Effect ge√§ndert** wird, ohne die Abh√§ngigkeiten korrekt zu steuern ‚Üí jeder State-Update l√∂st erneut den Effect aus.

---

### Ursachen

1. **Fehlendes oder falsches Abh√§ngigkeitsarray**

   ```jsx
   useEffect(() => {
     setCount(count + 1); // triggert bei jedem Render -> Endlosschleife
   }); // kein []
   ```

2. **Unn√∂tige Abh√§ngigkeiten**

   * Wenn Werte ins Array aufgenommen werden, die sich bei jedem Render √§ndern (z. B. Objekte/Funktionen).

---

### L√∂sungen

1. **Korrektes Abh√§ngigkeitsarray nutzen**

   ```jsx
   useEffect(() => {
     fetchData();
   }, []); // nur beim ersten Mount
   ```

2. **Funktionsupdates f√ºr State nutzen**

   ```jsx
   useEffect(() => {
     const id = setInterval(() => {
       setCount(prev => prev + 1); // nutzt vorherigen Wert, vermeidet Endlosschleife
     }, 1000);

     return () => clearInterval(id);
   }, []);
   ```

3. **Memoization f√ºr Objekte/Funktionen**

   * `useMemo` oder `useCallback` nutzen, damit sich die Abh√§ngigkeiten nicht bei jedem Render √§ndern.

   ```jsx
   const memoizedFn = useCallback(() => {
     console.log("Nur bei Bedarf neu erzeugt");
   }, []);

   useEffect(() => {
     memoizedFn();
   }, [memoizedFn]);
   ```

---

### Zusammenfassung

* Endlosschleifen entstehen durch **falsche oder fehlende Dependency Arrays** in `useEffect`.
* L√∂sung: korrektes Abh√§ngigkeitsarray, funktionale Updates, Memoization (`useCallback`, `useMemo`).
* Grundregel: **nur echte Abh√§ngigkeiten angeben** und Werte stabil halten.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì useEffect](https://react.dev/reference/react/useEffect)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

58. ### <a name="58"></a> Wie implementiert man Timeout oder Interval mit Hooks?

### Timeout & Interval mit Hooks

In Funktionskomponenten werden **`setTimeout`** und **`setInterval`** zusammen mit `useEffect` und `useRef` genutzt. Wichtig: **Cleanup** im `useEffect` verhindert Speicherlecks.

---

### Timeout (`setTimeout`)

```jsx
import { useEffect, useState } from "react";

function TimeoutDemo() {
  const [message, setMessage] = useState("Warte...");

  useEffect(() => {
    const id = setTimeout(() => {
      setMessage("Fertig nach 3 Sekunden!");
    }, 3000);

    return () => clearTimeout(id); // Cleanup beim Unmount
  }, []);

  return <p>{message}</p>;
}

export default TimeoutDemo;
```

---

### Interval (`setInterval`)

```jsx
import { useEffect, useState } from "react";

function IntervalDemo() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const id = setInterval(() => {
      setCount(prev => prev + 1); // funktionales Update vermeidet Endlosschleife
    }, 1000);

    return () => clearInterval(id); // Cleanup beim Unmount
  }, []);

  return <p>Z√§hler: {count}</p>;
}

export default IntervalDemo;
```

---

### Zusammenfassung

* **Timeout**: `setTimeout` + `clearTimeout` in `useEffect`.
* **Interval**: `setInterval` + `clearInterval` in `useEffect`.
* Cleanup-Funktion verhindert Leaks und unerw√ºnschte Effekte.
* Funktionale Updates (`prev => prev + 1`) sind wichtig, um Endlosschleifen zu vermeiden.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì useEffect](https://react.dev/reference/react/useEffect)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

59. ### <a name="59"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

60. ### <a name="60"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

61. ### <a name="61"></a> Was ist ein Higher-Order Component (HOC)?

### Higher-Order Component (HOC)

Ein **Higher-Order Component (HOC)** ist eine **Funktion**, die eine Komponente entgegennimmt und eine **neue erweiterte Komponente** zur√ºckgibt.
HOCs sind ein **Pattern zur Wiederverwendung von Logik** zwischen Komponenten.

---

### Merkmale

* HOC = **`Component => NewComponent`**.
* Trennung von **Logik** und **Darstellung**.
* Typisch f√ºr: Code-Wiederverwendung, Cross-Cutting Concerns (z. B. Auth, Logging).

---

### Beispiel

```jsx
import React from "react";

// HOC: nimmt Komponente, liefert neue zur√ºck
function withLogger(WrappedComponent) {
  return function Enhanced(props) {
    console.log("Props:", props);
    return <WrappedComponent {...props} />;
  };
}

// Nutzung
function Button({ label }) {
  return <button>{label}</button>;
}

const LoggedButton = withLogger(Button);

export default function App() {
  return <LoggedButton label="Klick mich" />;
}
```

* `withLogger` erweitert `Button` um Logging.
* `Button` selbst bleibt unver√§ndert, Wiederverwendung bleibt m√∂glich.

---

### Zusammenfassung

* **HOC** = Funktion, die eine Komponente um zus√§tzliche Logik erweitert.
* Typische Verwendung: **Code-Sharing, Auth, Logging, Daten-Handling**.
* Heute oft ersetzt durch **Hooks** oder **Render Props**.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì HOCs](https://react.dev/learn/reusing-logic-with-higher-order-components)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

62. ### <a name="62"></a> Was ist das Render-Prop-Pattern?

### Render-Prop-Pattern

Ein **Render-Prop** ist ein **Pattern in React**, bei dem eine Komponente eine **Funktion als Prop** erh√§lt, die bestimmt, **was gerendert wird**.
Damit k√∂nnen Komponenten **Logik wiederverwenden**, ohne UI starr vorzugeben.

---

### Merkmale

* ‚ÄûProp‚Äú = eine **Funktion**, die React-Elemente zur√ºckgibt.
* Trennung von **Logik** (in der Container-Komponente) und **Darstellung** (durch die Render-Prop-Funktion).
* Alternative zu HOCs f√ºr **Code-Wiederverwendung**.

---

### Beispiel

```jsx
import { useState } from "react";

// Container-Komponente mit Render-Prop
function MouseTracker({ render }) {
  const [pos, setPos] = useState({ x: 0, y: 0 });

  return (
    <div
      style={{ height: "200px", border: "1px solid black" }}
      onMouseMove={e => setPos({ x: e.clientX, y: e.clientY })}
    >
      {render(pos)} {/* Render-Prop entscheidet, was angezeigt wird */}
    </div>
  );
}

// Nutzung
export default function App() {
  return (
    <MouseTracker
      render={({ x, y }) => (
        <p>Cursor bei ({x}, {y})</p>
      )}
    />
  );
}
```

* `MouseTracker` enth√§lt die **Logik (onMouseMove)**.
* Das UI wird flexibel durch `render` definiert.

---

### Zusammenfassung

* **Render-Prop-Pattern**: Komponente erh√§lt eine **Funktion als Prop**, die JSX zur√ºckgibt.
* Vorteil: **Wiederverwendbare Logik** + flexible Darstellung.
* Wird heute oft durch **Custom Hooks** ersetzt.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Render Props](https://react.dev/learn/passing-props-to-a-component#passing-render-props)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

63. ### <a name="63"></a> Was ist die Context-API und wie funktioniert useContext?

### Context-API in React

Die **Context-API** ist ein Mechanismus, um **globale Daten** (z. B. Theme, Auth-Status, Sprache) bereitzustellen, **ohne Prop Drilling** durch viele Ebenen.
Sie besteht aus drei Teilen:

1. `createContext(defaultValue)` ‚Äì erstellt einen Context.
2. `Provider` ‚Äì stellt den Wert f√ºr Kinder bereit.
3. `useContext` ‚Äì liest den Wert direkt in einer Kindkomponente aus.

---

### Funktionsweise von `useContext`

* `useContext(MyContext)` greift auf den **n√§chstgelegenen Provider-Wert** zu.
* √Ñndert sich der Context-Wert, werden alle abh√§ngigen Komponenten neu gerendert.
* Ohne Provider wird der **defaultValue** genutzt.

---

### Beispiel

```jsx
import { createContext, useContext } from "react";

// 1. Context erstellen
const ThemeContext = createContext("light");

function ThemedButton() {
  // 2. Zugriff auf den Wert
  const theme = useContext(ThemeContext);
  return <button className={theme}>Thema: {theme}</button>;
}

export default function App() {
  return (
    // 3. Provider umschlie√üt die Kinder
    <ThemeContext.Provider value="dark">
      <ThemedButton />
    </ThemeContext.Provider>
  );
}
```

* `App` definiert den Wert `"dark"`.
* `ThemedButton` greift mit `useContext(ThemeContext)` darauf zu.

---

### Zusammenfassung

* **Context-API** = globale Datenverwaltung ohne Prop Drilling.
* **`useContext`** = Hook zum direkten Zugriff auf Context-Werte.
* Vorteil: einfache Verteilung globaler Zust√§nde, Nachteil: viele Re-Renders bei gro√üen B√§umen ‚Üí oft mit **Memoization/State-Management-Libs** kombiniert.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Context](https://react.dev/reference/react/useContext)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

64. ### <a name="64"></a> Was sind Portale in React?

### Portale in React

Ein **Portal** in React erm√∂glicht es, **JSX-Inhalte au√üerhalb der DOM-Hierarchie der Elternkomponente** zu rendern.
Man kann damit UI-Elemente (z. B. Modals, Tooltips, Overlays) direkt in einen **anderen DOM-Knoten** einf√ºgen.

---

### Funktionsweise

* `ReactDOM.createPortal(child, container)`
* `child` = React-Element(e), die gerendert werden sollen.
* `container` = Zielknoten im DOM, au√üerhalb des Standard-Root-Elements.

---

### Beispiel

```jsx
import { useState } from "react";
import { createPortal } from "react-dom";

function Modal({ children, onClose }) {
  return createPortal(
    <div className="modal">
      <div className="content">{children}</div>
      <button onClick={onClose}>Schlie√üen</button>
    </div>,
    document.getElementById("modal-root") // anderer DOM-Knoten
  );
}

export default function App() {
  const [open, setOpen] = useState(false);

  return (
    <>
      <button onClick={() => setOpen(true)}>Modal √∂ffnen</button>
      {open && <Modal onClose={() => setOpen(false)}>Hallo aus dem Portal!</Modal>}
    </>
  );
}
```

* In `index.html` muss ein zus√§tzlicher Knoten vorhanden sein:

```html
<div id="root"></div>
<div id="modal-root"></div>
```

---

### Zusammenfassung

* **Portale** = M√∂glichkeit, Inhalte in einen **anderen DOM-Knoten** zu rendern.
* Typische Anwendungsf√§lle: **Modals, Tooltips, Overlays**.
* API: `ReactDOM.createPortal(child, container)`.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Portals](https://react.dev/reference/react-dom/createPortal)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

65. ### <a name="65"></a> Was ist bedingtes Rendern (Conditional Rendering)?

### Bedingtes Rendern in React

**Conditional Rendering** bedeutet, dass eine Komponente **UI-Elemente abh√§ngig von Bedingungen** rendert ‚Äì √§hnlich wie `if/else` in JavaScript.
Damit kann React **unterschiedliche Inhalte** anzeigen, je nach State, Props oder Logik.

---

### Beispiele

**1. If/Else √ºber tern√§ren Operator:**

```jsx
function Greeting({ isLoggedIn }) {
  return (
    <div>
      {isLoggedIn ? <h1>Willkommen zur√ºck!</h1> : <h1>Bitte einloggen</h1>}
    </div>
  );
}
```

**2. Bedingte Anzeige mit `&&`:**

```jsx
function Notification({ unread }) {
  return (
    <div>
      <h2>Postfach</h2>
      {unread > 0 && <p>Du hast {unread} ungelesene Nachrichten.</p>}
    </div>
  );
}
```

**3. R√ºckgabe von `null`:**

```jsx
function Warning({ show }) {
  if (!show) return null; // nichts rendern
  return <p>Achtung!</p>;
}
```

---

### Zusammenfassung

* **Conditional Rendering** = UI abh√§ngig von Bedingungen.
* M√∂glichkeiten: **Ternary Operator, `&&`, `if/else`, `null`**.
* Typische F√§lle: Auth, Ladezustand, Fehleranzeige.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Conditional Rendering](https://react.dev/learn/conditional-rendering)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

66. ### <a name="66"></a> Was ist ein Error Boundary?

### Error Boundary in React

Ein **Error Boundary** ist eine **Klassenkomponente**, die **JavaScript-Fehler** in ihrem Kind-Baum abf√§ngt und eine **Fallback-UI** anzeigt, anstatt dass die gesamte Anwendung abst√ºrzt.

---

### Eigenschaften

* Error Boundaries fangen **Render-Fehler**, Fehler in **Lifecycle-Methoden** und in **Konstruktoren von Kind-Komponenten** ab.
* Sie fangen **keine Fehler** in Event-Handlern, asynchronem Code (z. B. `setTimeout`) oder Server-Code.
* Wichtige Methoden:

  * `static getDerivedStateFromError(error)` ‚Üí aktualisiert State f√ºr Fallback-UI.
  * `componentDidCatch(error, info)` ‚Üí Logging oder Error-Reporting.

---

### Beispiel

```jsx
import React from "react";

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError() {
    return { hasError: true };
  }

  componentDidCatch(error, info) {
    console.error("Fehler abgefangen:", error, info);
  }

  render() {
    if (this.state.hasError) {
      return <h2>Etwas ist schiefgelaufen.</h2>;
    }
    return this.props.children;
  }
}

// Nutzung
function BuggyComponent() {
  throw new Error("Crash!");
}

export default function App() {
  return (
    <ErrorBoundary>
      <BuggyComponent />
    </ErrorBoundary>
  );
}
```

---

### Zusammenfassung

* **Error Boundary** = Klassenkomponente, die Fehler abf√§ngt und Fallback-UI rendert.
* Methoden: `getDerivedStateFromError`, `componentDidCatch`.
* Einsatz: Schutz vor UI-Crashs, Logging, bessere User Experience.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Error Boundaries](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

67. ### <a name="67"></a> Wie funktioniert Event-Handling in React?

### Event-Handling in React

* Events in React funktionieren √§hnlich wie in DOM, sind aber in eine **synthetische Event-Schicht** (Synthetic Events) eingebettet.
* Dadurch sind Events in allen Browsern **konsistent**.
* Event-Handler werden als **CamelCase-Props** √ºbergeben (z. B. `onClick` statt `onclick`).
* Statt Strings wird eine **Funktion** √ºbergeben.

---

### Beispiel

```jsx
function Button() {
  function handleClick(event) {
    console.log("Geklickt!", event.type);
  }

  return (
    <button onClick={handleClick}>
      Klick mich
    </button>
  );
}

export default Button;
```

* `onClick={handleClick}` ‚Üí Funktion wird als Callback √ºbergeben.
* Das Event-Objekt (`event`) ist ein **SyntheticEvent** mit gleichen Methoden wie beim DOM-Event (`preventDefault`, `stopPropagation`).

---

### Besondere Punkte

1. **Event-Bindung mit Arrow Functions**

   ```jsx
   <button onClick={() => console.log("Inline-Handler")}>Click</button>
   ```

2. **`this`-Binding bei Klassen**
   In Klassenkomponenten muss man Methoden oft im Konstruktor binden oder Arrow Functions verwenden.

3. **Event Delegation**
   React h√§ngt Events **nicht direkt am DOM-Element**, sondern am Root-Knoten (`document`), was Performance optimiert.

---

### Zusammenfassung

* Event-Handling in React basiert auf **Synthetic Events** f√ºr Browser-Konsistenz.
* Syntax: **CamelCase**-Props + Callback-Funktion.
* Vorteile: einheitliches API, Event Delegation, bekannte DOM-Methoden (`preventDefault`, `stopPropagation`).

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Events](https://react.dev/learn/responding-to-events)
* [MDN ‚Äì Einf√ºhrung in DOM-Events (RU)](https://developer.mozilla.org/ru/docs/Learn/JavaScript/Building_blocks/Events)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

68. ### <a name="68"></a> Was ist ein synthetisches Ereignis (SyntheticEvent)?

### SyntheticEvent in React

Ein **SyntheticEvent** ist eine von React bereitgestellte **Wrapper-Schicht um native DOM-Events**.
Es sorgt f√ºr **Browser-Konsistenz** und stellt in allen Umgebungen die gleiche API bereit.

---

### Eigenschaften

* Enth√§lt die gleichen Methoden wie native Events: `preventDefault()`, `stopPropagation()`.
* Funktioniert in allen Browsern gleich ‚Üí kein spezielles Polyfill n√∂tig.
* Events werden aus Performance-Gr√ºnden **gepoolt** (nach der Event-Callback-Ausf√ºhrung sind die Eigenschaften auf `null` gesetzt).

  * Falls man das Event **asynchron** nutzen will, muss man `event.persist()` aufrufen.

---

### Beispiel

```jsx
function Form() {
  function handleSubmit(e) {
    e.preventDefault(); // SyntheticEvent mit DOM-API
    console.log("Formular gesendet!");
  }

  return (
    <form onSubmit={handleSubmit}>
      <button type="submit">Absenden</button>
    </form>
  );
}
```

**Asynchrone Nutzung:**

```jsx
function InputLogger() {
  function handleChange(e) {
    e.persist(); // Event bleibt erhalten
    setTimeout(() => console.log(e.target.value), 1000);
  }

  return <input onChange={handleChange} />;
}
```

---

### Zusammenfassung

* **SyntheticEvent** = React-Wrapper um native DOM-Events.
* Vorteil: **einheitliches Event-System, Cross-Browser-Kompatibilit√§t, Performance durch Event-Pooling**.
* Bei asynchroner Nutzung: `event.persist()`.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì SyntheticEvent](https://react.dev/reference/react/SyntheticEvent)
* [MDN ‚Äì DOM Events](https://developer.mozilla.org/ru/docs/Web/API/Event)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

69. ### <a name="69"></a> Was ist props.children?

### `props.children` in React

* **`props.children`** ist eine **spezielle Prop**, die automatisch alle **verschachtelten Inhalte (Child-Elemente)** einer Komponente enth√§lt.
* Damit lassen sich **Wrapper- oder Layout-Komponenten** flexibel gestalten, ohne vorher zu wissen, was darin steht.

---

### Beispiel

```jsx
function Card({ children }) {
  return <div className="card">{children}</div>;
}

export default function App() {
  return (
    <Card>
      <h2>Titel</h2>
      <p>Das ist Inhalt innerhalb von Card</p>
    </Card>
  );
}
```

* `props.children` enth√§lt hier `<h2>...</h2>` und `<p>...</p>`.
* Card kann beliebige Inhalte aufnehmen, ohne diese fest im Code zu definieren.

---

### Zusammenfassung

* **`props.children`** = Container f√ºr verschachtelte Inhalte einer Komponente.
* Einsatz: Wrapper-, Layout- und Container-Komponenten.
* Vorteil: **maximale Flexibilit√§t** und Wiederverwendung von UI-Strukturen.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Children](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

70. ### <a name="70"></a> Was bedeutet ‚Äûcontrolled component‚Äú und ‚Äûuncontrolled component‚Äú bei Formularen?

### Controlled Components

* Bei einer **controlled component** verwaltet **React den Wert** eines Formularelements √ºber den **State**.
* Der Wert wird durch `value`-Prop gesetzt und √ºber `onChange` aktualisiert.
* React = **Single Source of Truth**.

```jsx
import { useState } from "react";

function ControlledInput() {
  const [text, setText] = useState("");

  return (
    <input
      value={text}
      onChange={e => setText(e.target.value)}
    />
  );
}
```

---

### Uncontrolled Components

* Bei einer **uncontrolled component** verwaltet das **DOM selbst den Wert**.
* React greift √ºber eine **Ref** auf den aktuellen Wert zu.
* Weniger Code, aber weniger Kontrolle durch React.

```jsx
import { useRef } from "react";

function UncontrolledInput() {
  const inputRef = useRef();

  const handleSubmit = () => {
    alert(inputRef.current.value); // Wert direkt aus DOM
  };

  return (
    <>
      <input ref={inputRef} />
      <button onClick={handleSubmit}>Absenden</button>
    </>
  );
}
```

---

### Vergleich

| Controlled                       | Uncontrolled                  |
| -------------------------------- | ----------------------------- |
| React verwaltet den Wert (State) | DOM verwaltet den Wert        |
| `value` + `onChange`             | Zugriff via `ref`             |
| Bessere Validierung & Kontrolle  | Einfachere schnelle Umsetzung |

---

### Zusammenfassung

* **Controlled Component**: Wert im React-State, volle Kontrolle.
* **Uncontrolled Component**: Wert im DOM, Zugriff via Ref.
* Best Practice: Controlled f√ºr komplexe Formulare, Uncontrolled f√ºr einfache F√§lle.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Controlled vs. Uncontrolled](https://react.dev/learn/sharing-state-between-components#controlled-and-uncontrolled-components)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

71. ### <a name="71"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

72. ### <a name="72"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

73. ### <a name="73"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

74. ### <a name="74"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

75. ### <a name="75"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

76. ### <a name="76"></a> Wie f√ºhrt man API-Aufrufe mit Fetch oder Axios durch?

### API-Aufrufe in React mit **Fetch** und **Axios**

In React f√ºhrt man API-Requests meist in **`useEffect`** aus, damit sie nach dem Rendern starten.
Der Response wird im **State** gespeichert.

---

### Mit **Fetch**

```jsx
import { useState, useEffect } from "react";

function Users() {
  const [users, setUsers] = useState([]);

  useEffect(() => {
    fetch("https://jsonplaceholder.typicode.com/users")
      .then(res => res.json())
      .then(data => setUsers(data))
      .catch(err => console.error(err));
  }, []); // nur einmal beim Mount

  return (
    <ul>
      {users.map(u => <li key={u.id}>{u.name}</li>)}
    </ul>
  );
}
```

---

### Mit **Axios**

```jsx
import { useState, useEffect } from "react";
import axios from "axios";

function Users() {
  const [users, setUsers] = useState([]);

  useEffect(() => {
    axios.get("https://jsonplaceholder.typicode.com/users")
      .then(res => setUsers(res.data))
      .catch(err => console.error(err));
  }, []);

  return (
    <ul>
      {users.map(u => <li key={u.id}>{u.name}</li>)}
    </ul>
  );
}
```

---

### Unterschiede **Fetch vs. Axios**

* **Fetch**: eingebaut im Browser, aber kein automatisches JSON-Parsing f√ºr Fehler.
* **Axios**: externe Bibliothek, komfortabler (automatisches JSON, Timeouts, Interceptors).

---

### Zusammenfassung

* API-Aufrufe in React mit **`useEffect` + State** umsetzen.
* **Fetch** = native API, minimalistisch.
* **Axios** = komfortabler, mit Extras wie Interceptors.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Daten abrufen](https://react.dev/learn/synchronizing-with-effects#fetching-data)
* [MDN ‚Äì Fetch API (RU)](https://developer.mozilla.org/ru/docs/Web/API/Fetch_API)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

77. ### <a name="77"></a> Wie verwaltet man Lade-, Fehler- und Erfolgsstatus?

### Lade-, Fehler- und Erfolgsstatus verwalten (Patterns)

**Grundidee:** Status als **endlichen Automat** modellieren (`'idle' | 'loading' | 'success' | 'error'`) und **UI zustandsbasiert** rendern.

---

### Minimal-Pattern mit Fetch + `useEffect`

```jsx
import { useEffect, useState } from "react";

export default function Users() {
  const [status, setStatus] = useState("idle");     // 'idle' | 'loading' | 'success' | 'error'
  const [data, setData] = useState(null);
  const [error, setError] = useState(null);

  useEffect(() => {
    const ctrl = new AbortController();
    const load = async () => {
      try {
        setStatus("loading");
        const res = await fetch("https://jsonplaceholder.typicode.com/users", { signal: ctrl.signal });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const json = await res.json();
        setData(json);
        setStatus("success");
      } catch (e) {
        if (e.name !== "AbortError") {
          setError(e);
          setStatus("error");
        }
      }
    };
    load();
    return () => ctrl.abort(); // Cleanup verhindert Setzen nach Unmount
  }, []);

  if (status === "loading") return <p>Laden‚Ä¶</p>;
  if (status === "error") return <p>Fehler: {error.message}</p>;
  if (status === "success") {
    return <ul>{data.map(u => <li key={u.id}>{u.name}</li>)}</ul>;
  }
  return <button onClick={() => { /* optional: Lazy-Load triggern */ }}>Daten laden</button>;
}
```

**Wichtig**

* **Ein Statusfeld** statt mehrerer Booleans (verhindert inkonsistente Kombinationen).
* **AbortController** f√ºr Abbruch bei Unmount/Neuladen.
* **Fehlerpr√ºfung** (`!res.ok`) vor `res.json()`.

---

### Reusable: kleiner `useAsync`-Hook

```jsx
import { useEffect, useRef, useState } from "react";

export function useAsync(fn, deps = []) {
  const [state, setState] = useState({ status: "idle", data: null, error: null });
  const mounted = useRef(true);

  useEffect(() => {
    mounted.current = true;
    const run = async () => {
      setState({ status: "loading", data: null, error: null });
      try {
        const data = await fn();
        if (mounted.current) setState({ status: "success", data, error: null });
      } catch (err) {
        if (mounted.current) setState({ status: "error", data: null, error: err });
      }
    };
    run();
    return () => { mounted.current = false; };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, deps);

  return state; // {status, data, error}
}

// Nutzung
// const { status, data, error } = useAsync(() => fetch("/api").then(r => r.json()), []);
```

---

### UI-Muster

* **Skeleton/Spinner** bei `loading`.
* **Retry-Button** bei `error` (neuen Fetch triggern).
* **Disabled/ARIA** w√§hrend `loading` (Barrierefreiheit).
* **Optimistic UI**/Rollback bei Mutationen (separater Status je Mutation).

---

### Zusammenfassung

* Status als **disjunkte Zust√§nde** modellieren; UI rein **zustandsgetrieben** rendern.
* Netzwerkcode in `useEffect` (mit **Cleanup/Abort**), Fehler fr√ºh pr√ºfen.
* F√ºr Wiederverwendung: **Custom Hook** (`useAsync`) oder Libraries (z. B. React Query/SWR).

üìñ Weiterf√ºhrend:

* React Docs: [Synchronizing with Effects](https://react.dev/learn/synchronizing-with-effects), [Conditional Rendering](https://react.dev/learn/conditional-rendering)
* MDN (RU): [Fetch API](https://developer.mozilla.org/ru/docs/Web/API/Fetch_API), [AbortController](https://developer.mozilla.org/ru/docs/Web/API/AbortController)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

78. ### <a name="78"></a> Wie funktioniert WebSocket mit React?

### WebSocket mit React: Grundlagen & Pattern

**Idee:** In React √∂ffnest du die Verbindung in einem **Effect**, h√§ltst die Socket-Instanz in einem **Ref**, registrierst **Event-Handler**, und r√§umst im **Cleanup** wieder auf. State speichert eingehende Daten.

---

### Minimalbeispiel (Empfangen & Senden)

```jsx
import { useEffect, useRef, useState, useCallback } from "react";

export default function Chat() {
  const [messages, setMessages] = useState([]);
  const [connected, setConnected] = useState(false);
  const socketRef = useRef(null);

  // Verbindung aufbauen
  useEffect(() => {
    const ws = new WebSocket("wss://echo.websocket.events"); // Demo-Endpoint
    socketRef.current = ws;

    ws.addEventListener("open", () => setConnected(true));
    ws.addEventListener("message", (e) => {
      // optional JSON.parse(e.data)
      setMessages((prev) => [...prev, String(e.data)]);
    });
    ws.addEventListener("close", () => setConnected(false));
    ws.addEventListener("error", () => setConnected(false));

    return () => {
      ws.close(); // Cleanup beim Unmount
    };
  }, []);

  // Stabiler send()-Callback
  const sendMessage = useCallback((text) => {
    const ws = socketRef.current;
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(text);
    }
  }, []);

  return (
    <>
      <p>Status: {connected ? "verbunden" : "getrennt"}</p>
      <button onClick={() => sendMessage("Hallo WebSocket!")}>Senden</button>
      <ul>{messages.map((m, i) => <li key={i}>{m}</li>)}</ul>
    </>
  );
}
```

---

### Robuster Custom Hook mit Reconnect & Backoff

```jsx
import { useEffect, useRef, useState, useCallback } from "react";

export function useWebSocket(url, { reconnect = true, maxDelay = 8000 } = {}) {
  const wsRef = useRef(null);
  const [readyState, setReadyState] = useState(WebSocket.CLOSED);
  const [lastMessage, setLastMessage] = useState(null);
  const retryRef = useRef(0);
  const timerRef = useRef(null);

  const connect = useCallback(() => {
    const ws = new WebSocket(url);
    wsRef.current = ws;

    ws.onopen = () => {
      setReadyState(ws.readyState);
      retryRef.current = 0; // Reset Backoff
    };
    ws.onmessage = (e) => setLastMessage(e.data);
    ws.onerror = () => {};
    ws.onclose = () => {
      setReadyState(WebSocket.CLOSED);
      if (reconnect) {
        const delay = Math.min(1000 * 2 ** retryRef.current++, maxDelay);
        timerRef.current = setTimeout(connect, delay);
      }
    };
    setReadyState(ws.readyState);
  }, [url, reconnect, maxDelay]);

  useEffect(() => {
    connect();
    return () => {
      reconnect = false; // eslint-disable-line no-param-reassign
      clearTimeout(timerRef.current);
      wsRef.current?.close();
    };
  }, [connect]);

  const send = useCallback((data) => {
    const ws = wsRef.current;
    if (ws?.readyState === WebSocket.OPEN) ws.send(data);
  }, []);

  return { readyState, lastMessage, send };
}
```

**Nutzung:**

```jsx
import { useEffect, useState } from "react";
import { useWebSocket } from "./useWebSocket.js";

export default function Ticker() {
  const { readyState, lastMessage, send } = useWebSocket("wss://echo.websocket.events");
  const [log, setLog] = useState([]);

  useEffect(() => {
    if (lastMessage != null) setLog((l) => [...l, String(lastMessage)]);
  }, [lastMessage]);

  return (
    <>
      <p>State: {readyState === WebSocket.OPEN ? "OPEN" : readyState}</p>
      <button onClick={() => send(JSON.stringify({ ping: Date.now() }))}>Ping</button>
      <ul>{log.map((x, i) => <li key={i}>{x}</li>)}</ul>
    </>
  );
}
```

---

### Best Practices

* **`useRef`** f√ºr die Socket-Instanz (ver√§ndert sich ohne Re-Render).
* **Cleanup** im `useEffect` ‚Üí `ws.close()`.
* **Nachrichtenformat**: JSON verwenden (`JSON.stringify/parse`), Versionierung des Payloads beachten.
* **Reconnect** mit **exponentiellem Backoff**; bei Auth-Sockets (JWT) Token-Refresh einplanen.
* **Sicherheit**: `wss://`, serverseitige Origin/Rate-Limits, Heartbeats/Pings f√ºr Keep-Alive.
* **Zustandsmodell**: UI klar zwischen `OPEN/CONNECTING/CLOSING/CLOSED` unterscheiden.

---

### Zusammenfassung

* WebSocket in React: **√∂ffnen im `useEffect`**, **Instanz in `useRef`**, **Event-Handler registrieren**, **Cleanup** beim Unmount.
* Senden √ºber stabilen **`useCallback`**; f√ºr Wiederverwendung **Custom Hook** mit Reconnect/Backoff bauen.
* JSON-Payloads, Fehler-/Statushandling und Sicherheit ber√ºcksichtigen.

üìñ Weiterf√ºhrend:

* React Docs: [Effects](https://react.dev/learn/synchronizing-with-effects)
* MDN (RU): [WebSocket API](https://developer.mozilla.org/ru/docs/Web/API/WebSockets_API), [WebSocket](https://developer.mozilla.org/ru/docs/Web/API/WebSocket)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

79. ### <a name="79"></a> Wie kann man Daten zwischen Komponenten weitergeben?

### Datenfluss zwischen Komponenten in React

**1) Eltern ‚Üí Kind: √ºber Props**

```jsx
function Child({ title }) {
  return <h2>{title}</h2>;
}

export default function Parent() {
  return <Child title="Hallo, Sergii" />;
}
```

**2) Kind ‚Üí Eltern: √ºber Callback-Props (Bottom-up Events)**

```jsx
import { useState } from "react";

function Child({ onChange }) {
  return <button onClick={() => onChange("Neuer Wert")}>Senden</button>;
}

export default function Parent() {
  const [val, setVal] = useState("");
  return (
    <>
      <Child onChange={setVal} />
      <p>Empfangen: {val}</p>
    </>
  );
}
```

**3) Geschwister-Komponenten:** **Lifting State Up** (gemeinsamer Eltern-State)

```jsx
import { useState } from "react";

function A({ value, onChange }) {
  return <button onClick={() => onChange(value + 1)}>A+1</button>;
}
function B({ value }) { return <p>B sieht: {value}</p>; }

export default function Parent() {
  const [n, setN] = useState(0);
  return (
    <>
      <A value={n} onChange={setN} />
      <B value={n} />
    </>
  );
}
```

**4) Global/√ºber viele Ebenen:** **Context-API (`useContext`)** ‚Äì vermeidet Prop Drilling

```jsx
import { createContext, useContext } from "react";

const AuthContext = createContext({ user: null });

function UserTag() {
  const { user } = useContext(AuthContext);
  return <span>{user?.name ?? "Gast"}</span>;
}

export default function App() {
  return (
    <AuthContext.Provider value={{ user: { name: "Sergii" } }}>
      <UserTag />
    </AuthContext.Provider>
  );
}
```

**5) Fortgeschritten (optional):**

* **URL/Router** (z. B. Query-/Path-Parameter), **State-Management-Libs** (Redux, Zustand), **Events** (selten), **Server State** (React Query/SWR).
* **Refs** via `forwardRef` f√ºr imperativen Zugriff, **nicht** f√ºr allgemeinen Datenfluss.

---

### Zusammenfassung

* Standard: **Props** (Top-down) und **Callbacks** (Bottom-up).
* **Geschwister** teilen Daten √ºber **Lifting State Up**.
* **Context** f√ºr globale/weit gestreute Daten.
* Bei komplexen F√§llen: **Router/State-Management/Server-State** erg√§nzen.

üìñ Weiterf√ºhrend:

* React Docs: [Props weitergeben](https://react.dev/learn/passing-props-to-a-component), [State teilen & Lifting State Up](https://react.dev/learn/sharing-state-between-components), [Context & useContext](https://react.dev/reference/react/useContext)
* MDN (RU): [–í–µ–±-—Å–æ–±—ã—Ç–∏—è (–æ–±–∑–æ—Ä)](https://developer.mozilla.org/ru/docs/Learn/JavaScript/Building_blocks/Events)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

80. ### <a name="80"></a> Wie macht man einen Datenabruf nur beim ersten Rendern?

### Datenabruf nur beim ersten Render (Mount)

**Pattern:** `useEffect` mit **leerem Abh√§ngigkeitsarray `[]`**.
Hinweis: In **React 18** ruft der Dev-Mode (Strict Mode) Effekte absichtlich **zweimal** auf (Mount ‚Üí Cleanup ‚Üí Mount) zur Fehlererkennung. In Production nur einmal. Nutze **AbortController** oder eine **Ref-Garde**, um Doppel-Requests zu vermeiden.

```jsx
import { useEffect, useState, useRef } from "react";

export default function UsersOnce() {
  const [users, setUsers] = useState([]);
  const [status, setStatus] = useState("idle"); // 'idle' | 'loading' | 'success' | 'error'
  const fetchedRef = useRef(false); // sch√ºtzt vor Doppel-Fetch im Dev-Mode

  useEffect(() => {
    if (fetchedRef.current) return;    // schon geladen? -> abbrechen
    fetchedRef.current = true;

    const ctrl = new AbortController();
    const load = async () => {
      try {
        setStatus("loading");
        const res = await fetch("https://jsonplaceholder.typicode.com/users", {
          signal: ctrl.signal,
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();
        setUsers(data);
        setStatus("success");
      } catch (e) {
        if (e.name !== "AbortError") setStatus("error");
      }
    };

    load();
    return () => ctrl.abort(); // Cleanup verhindert Leaks/SetState-after-unmount
  }, []); // nur beim (ersten) Mount

  if (status === "loading") return <p>Laden‚Ä¶</p>;
  if (status === "error") return <p>Fehler beim Laden.</p>;
  return <ul>{users.map(u => <li key={u.id}>{u.name}</li>)}</ul>;
}
```

**Alternativen/Erg√§nzungen**

* **Idempotenter Request** (Server akzeptiert wiederholte Calls ohne Seiteneffekt).
* **Datenbibliotheken** wie React Query/SWR cachen & deduplizieren Requests automatisch.

---

### Zusammenfassung

* ‚ÄûNur einmal laden‚Äú: `useEffect(() => {...}, [])`.
* In React 18 dev kann der Effekt doppelt laufen ‚Üí **`AbortController`** oder **Ref-Garde** nutzen.
* Cleanup im Effekt verhindert Speicherlecks und Fehlzust√§nde.

üìñ Weiterf√ºhrend:

* React Docs: [Effects & Abh√§ngigkeiten](https://react.dev/learn/synchronizing-with-effects)
* React Docs: [useEffect API](https://react.dev/reference/react/useEffect)
* MDN (RU): [Fetch API](https://developer.mozilla.org/ru/docs/Web/API/Fetch_API), [AbortController](https://developer.mozilla.org/ru/docs/Web/API/AbortController)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

81. ### <a name="81"></a> Was ist das Problem bei ‚Äûstale closures‚Äú mit Hooks?

### ‚ÄûStale Closures‚Äú in React Hooks

Ein **stale closure** tritt auf, wenn eine Funktion innerhalb einer Komponente auf **veraltete Variablenwerte** zugreift, weil sie an den Zustand **gebunden wurde, der zum Zeitpunkt der Definition g√ºltig war** ‚Äì nicht am aktuellen State/Prop.

---

### Beispiel (Problem)

```jsx
import { useEffect, useState } from "react";

function Timer() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const id = setInterval(() => {
      // ‚ùå stale closure: 'count' ist immer 0
      setCount(count + 1);
    }, 1000);

    return () => clearInterval(id);
  }, []); // [] ‚Üí Effekt l√§uft nur einmal, count ist ‚Äûeingefroren‚Äú

  return <p>{count}</p>;
}
```

* `count` im Callback bleibt **immer 0**, weil das Closure aus dem ersten Render eingefroren ist.
* Ergebnis: Z√§hler bleibt bei `1` stehen.

---

### L√∂sungen

1. **Funktionale Updates verwenden**

   ```jsx
   setCount(prev => prev + 1); // aktueller Wert garantiert
   ```

   ```jsx
   useEffect(() => {
     const id = setInterval(() => setCount(prev => prev + 1), 1000);
     return () => clearInterval(id);
   }, []);
   ```

2. **Abh√§ngigkeiten korrekt setzen**

   ```jsx
   useEffect(() => {
     console.log("Neuer Count:", count);
   }, [count]); // aktualisiert bei jedem Count
   ```

3. **useRef f√ºr mutable Werte**

   * Wenn man Werte **lesen, aber kein Re-Render ausl√∂sen** m√∂chte.

---

### Zusammenfassung

* **Stale closure** = Callback in Hook verwendet **veraltete Variablenwerte**.
* Ursache: Closures binden Werte aus dem Render-Zeitpunkt.
* L√∂sung: **funktionale Updates (`prev => ...`)**, korrekte **Dependencies** oder **Refs**.

üìñ Weiterf√ºhrend:

* [React Docs ‚Äì useEffect & Closures](https://react.dev/learn/synchronizing-with-effects#what-to-do-when-you-disagree-with-the-linter)
* [Dan Abramov ‚Äì A Complete Guide to useEffect](https://overreacted.io/a-complete-guide-to-useeffect/)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

82. ### <a name="82"></a> Wie funktioniert die Fehlerbehandlung mit try/catch in React?

### Fehlerbehandlung mit `try...catch` in React

1. **In Event-Handlern**

* Fehler k√∂nnen direkt mit `try...catch` abgefangen werden.
* Das verhindert, dass die App abst√ºrzt.

```jsx
function Form() {
  function handleSubmit(e) {
    e.preventDefault();
    try {
      throw new Error("Ups!");
    } catch (err) {
      console.error("Fehler im Event:", err.message);
    }
  }

  return <form onSubmit={handleSubmit}><button>Absenden</button></form>;
}
```

---

2. **In asynchronem Code (z. B. Fetch, Axios)**

* `try...catch` funktioniert nur in `async`-Funktionen.
* Alternative: `.catch()` bei Promises.

```jsx
import { useEffect, useState } from "react";

function DataFetcher() {
  const [data, setData] = useState(null);
  const [error, setError] = useState(null);

  useEffect(() => {
    async function load() {
      try {
        const res = await fetch("https://jsonplaceholder.typicode.com/users");
        if (!res.ok) throw new Error("HTTP-Fehler " + res.status);
        const json = await res.json();
        setData(json);
      } catch (err) {
        setError(err);
      }
    }
    load();
  }, []);

  if (error) return <p>Fehler: {error.message}</p>;
  if (!data) return <p>Laden...</p>;
  return <ul>{data.map(u => <li key={u.id}>{u.name}</li>)}</ul>;
}
```

---

3. **Nicht m√∂glich: Render-Phase/Lifecycle**

* Fehler im **Rendern von Komponenten** oder in **Hooks** k√∂nnen mit `try...catch` **nicht** abgefangen werden.
* Daf√ºr braucht man **Error Boundaries** (`getDerivedStateFromError`, `componentDidCatch`).

---

### Zusammenfassung

* **`try...catch`** funktioniert in Event-Handlern und asynchronem Code (z. B. `fetch`).
* In der Render-Phase reicht `try...catch` nicht ‚Üí dort braucht man **Error Boundaries**.
* Best Practice: **`try...catch` f√ºr asynchrone Logik**, **Error Boundaries f√ºr UI-Absturz-Schutz**.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Error Boundaries](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary)
* [MDN ‚Äì try...catch (RU)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/try...catch)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

83. ### <a name="83"></a> Wie kann man ein Mock-API oder Mock Server verwenden?

### Mock-API / Mock Server in React: g√§ngige Optionen

#### 1) **MSW ‚Äì Mock Service Worker** (empfohlen: realit√§tsnah im Browser & Node)

* Interceptet **`fetch`/`XHR`** auf Netzwerkebene, kein Code-√Ñndern in Komponenten.
* Funktioniert in **Dev**, **Storybook** und **Tests (Jest/Vitest)**.

```js
// src/mocks/handlers.js
import { http, HttpResponse } from "msw";

export const handlers = [
  http.get("/api/users", () => HttpResponse.json([
    { id: 1, name: "Sergii" },
    { id: 2, name: "Anna" },
  ])),
];

// src/mocks/browser.js
import { setupWorker } from "msw/browser";
import { handlers } from "./handlers.js";
export const worker = setupWorker(...handlers);

// src/main.jsx
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import App from "./App.jsx";

async function enableMocking() {
  if (import.meta.env.DEV) {
    const { worker } = await import("./mocks/browser.js");
    await worker.start({ onUnhandledRequest: "bypass" });
  }
}
enableMocking();

createRoot(document.getElementById("root")).render(
  <StrictMode><App /></StrictMode>
);
```

```jsx
// Normales Fetching bleibt unver√§ndert
import { useEffect, useState } from "react";

export default function Users() {
  const [users, setUsers] = useState([]);
  useEffect(() => {
    fetch("/api/users").then(r => r.json()).then(setUsers);
  }, []);
  return <ul>{users.map(u => <li key={u.id}>{u.name}</li>)}</ul>;
}
```

**Vorteile:** keine Codever√§nderung am Fetching, gleiche API wie Produktion, ideal f√ºr UI-Entwicklung & Tests.

---

#### 2) **JSON Server** (schneller REST-Mock via Datei)

* Startet in Sekunden eine REST-API aus `db.json`.

```json
// db.json
{
  "users": [
    { "id": 1, "name": "Sergii" },
    { "id": 2, "name": "Anna" }
  ]
}
```

```bash
# Installation & Start
npm i -D json-server
npx json-server --watch db.json --port 4000
```

```jsx
// React: ganz normal fetchen
import { useEffect, useState } from "react";

export default function Users() {
  const [users, setUsers] = useState([]);
  useEffect(() => {
    fetch("http://localhost:4000/users").then(r => r.json()).then(setUsers);
  }, []);
  return <ul>{users.map(u => <li key={u.id}>{u.name}</li>)}</ul>;
}
```

**Vorteile:** echte REST-URLs, unterst√ºtzt Filter/Queries, ideal f√ºr Team-Prototyping.
**Hinweis:** CORS/Port beachten; ggf. Proxy in Vite/CRA konfigurieren.

---

#### 3) **MirageJS** (in-app Mock-Server)

* Startet einen **virtuellen Server im Browser**, definiert Routen/Models in JS.

```js
// src/server.js
import { createServer } from "miragejs";

export function makeServer() {
  return createServer({
    routes() {
      this.namespace = "api";
      this.get("/users", () => [
        { id: "1", name: "Sergii" },
        { id: "2", name: "Anna" },
      ]);
    },
  });
}

// src/main.jsx
import { makeServer } from "./server.js";
if (import.meta.env.DEV) makeServer();
```

**Vorteile:** komplexere Szenarien (Beziehungen, Statuscodes) ohne externen Prozess.

---

### Mocking im **Test** (Jest/Vitest) ‚Äì minimal

* Entweder **MSW (Node-Adapter)** oder **Fetch mocken**:

```js
// __tests__/users.test.js
import { render, screen, waitFor } from "@testing-library/react";
import Users from "../Users.jsx";

global.fetch = vi.fn(() =>
  Promise.resolve({ ok: true, json: () => Promise.resolve([{ id: 1, name: "Sergii" }]) })
);

test("rendert Nutzerliste", async () => {
  render(<Users />);
  await waitFor(() => screen.getByText("Sergii"));
});
```

---

### Wann welche L√∂sung?

* **MSW:** realit√§tsnah, ‚Äûnetzwerkgetreu‚Äú, Dev & Test ‚Äì **Standard-Empfehlung**.
* **JSON Server:** schnell, eigenst√§ndiger REST-Endpunkt, gut f√ºr Teams/Backend-Entkopplung.
* **MirageJS:** alles in einem Bundle, m√§chtig f√ºr komplexe Fake-Backends.

---

### Zusammenfassung

* Mocking-Optionen: **MSW** (Intercept), **JSON Server** (echter Dev-Server), **MirageJS** (in-app).
* React-Code bleibt idR unver√§ndert; Mock-Schicht ersetzt/bedient die API.
* F√ºr Tests: **MSW (Node)** oder gezieltes **Fetch-Mocking**.

üìñ Weiterf√ºhrend:

* React Docs: [Daten holen mit Effects](https://react.dev/learn/synchronizing-with-effects)
* MDN (RU): [Fetch API](https://developer.mozilla.org/ru/docs/Web/API/Fetch_API)
* MSW: [https://mswjs.io](https://mswjs.io)
* JSON Server: [https://github.com/typicode/json-server](https://github.com/typicode/json-server)
* MirageJS: [https://miragejs.com](https://miragejs.com)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

84. ### <a name="84"></a> Wie funktioniert Suspense f√ºr Datenabfragen?

### Suspense f√ºr Datenabfragen in React

**Suspense** ist ein React-Feature, das es erm√∂glicht, eine **Fallback-UI (z. B. Spinner)** anzuzeigen, solange Daten noch nicht geladen sind.
Anstatt den Ladezustand selbst mit `useState`/`useEffect` zu managen, ‚Äûwartet‚Äú React, bis ein Promise **resolved** ist, und zeigt in der Zwischenzeit den Fallback an.

---

### Grundprinzip

* Eine Komponente ‚Äûwirft‚Äú (`throw`) ein Promise w√§hrend des Renderns.
* React erkennt dies und zeigt den `fallback` aus `<Suspense>` an.
* Sobald das Promise resolved ist, rendert React die eigentliche UI.

---

### Einfaches Beispiel (Simulation)

```jsx
import { Suspense } from "react";

// Hilfsfunktion: "Ressource" mit read()
function fetchData() {
  let status = "pending";
  let result;
  const suspender = fetch("https://jsonplaceholder.typicode.com/users")
    .then(r => r.json())
    .then(
      res => {
        status = "success";
        result = res;
      },
      err => {
        status = "error";
        result = err;
      }
    );

  return {
    read() {
      if (status === "pending") throw suspender; // l√∂st Suspense aus
      if (status === "error") throw result;      // l√∂st Error Boundary aus
      return result;
    }
  };
}

const resource = fetchData();

function UserList() {
  const users = resource.read(); // wartet √ºber Suspense
  return (
    <ul>
      {users.map(u => <li key={u.id}>{u.name}</li>)}
    </ul>
  );
}

export default function App() {
  return (
    <Suspense fallback={<p>Lade Nutzer...</p>}>
      <UserList />
    </Suspense>
  );
}
```

---

### Typische moderne Nutzung

* React-Team empfiehlt **React Query**, **Relay** oder **Next.js (App Router)** ‚Üí diese Libraries integrieren Suspense.
* Suspense selbst liefert nur den **UI-Mechanismus** ‚Äì kein Fetch- oder Cache-System.

---

### Zusammenfassung

* **Suspense** zeigt Fallback-UI, solange Daten noch nicht geladen sind.
* Funktioniert, indem Komponenten w√§hrend des Renderns ein **Promise werfen**.
* F√ºr echte Projekte: in Kombination mit Libraries wie **React Query, Relay, Next.js**.

üìñ Weiterf√ºhrend:

* [React Offizielle Dokumentation ‚Äì Suspense f√ºr Datenabfragen](https://react.dev/reference/react/Suspense#suspense-for-data-fetching)
* [React Docs ‚Äì Asynchronous Rendering](https://react.dev/learn/suspense)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

85. ### <a name="85"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

86. ### <a name="86"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

87. ### <a name="87"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

88. ### <a name="88"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

89. ### <a name="89"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

90. ### <a name="90"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

91. ### <a name="91"></a> Was ist Unit-, Integration- und E2E-Testing?

**Unit-, Integrations- und End-to-End-Testing (E2E)** sind verschiedene Testebenen in der Softwareentwicklung, auch im Frontend mit ReactJS.

---

### **1. Unit-Testing**

* Testet **einzelne, isolierte Einheiten** (z. B. Funktionen, React-Komponenten).
* Ziel: Sicherstellen, dass eine kleine Funktionalit√§t unabh√§ngig korrekt funktioniert.

**Beispiel:**

```jsx
// add.js
export function add(a, b) {
  return a + b;
}

// add.test.js (Jest)
import { add } from "./add.js";

test("addiert zwei Zahlen korrekt", () => {
  expect(add(2, 3)).toBe(5);
});
```

---

### **2. Integration-Testing**

* Testet das **Zusammenspiel mehrerer Einheiten** (z. B. Komponente + API-Aufruf + State).
* Ziel: Pr√ºfen, ob die Integration der Teile korrekt funktioniert.

**Beispiel mit React Testing Library:**

```jsx
// Greeting.jsx
import { useState, useEffect } from "react";

export function Greeting({ name }) {
  const [message, setMessage] = useState("");

  useEffect(() => {
    setMessage(`Hallo, ${name}!`);
  }, [name]);

  return <h1>{message}</h1>;
}

// Greeting.test.js
import { render, screen } from "@testing-library/react";
import { Greeting } from "./Greeting.jsx";

test("zeigt eine Begr√º√üung basierend auf Props", () => {
  render(<Greeting name="Sergii" />);
  expect(screen.getByText("Hallo, Sergii!")).toBeInTheDocument();
});
```

---

### **3. End-to-End-Testing (E2E)**

* Testet die **gesamte Anwendung** aus Sicht des Benutzers.
* Simuliert echte Interaktionen im Browser (z. B. Klicks, Navigation, Formulare).
* Tools: **Cypress**, **Playwright**.

**Beispiel mit Cypress:**

```js
// e2e.spec.js
describe("Login Flow", () => {
  it("erlaubt einem Nutzer, sich einzuloggen", () => {
    cy.visit("/login");
    cy.get("input[name=username]").type("testuser");
    cy.get("input[name=password]").type("secret");
    cy.get("button[type=submit]").click();
    cy.url().should("include", "/dashboard");
    cy.contains("Willkommen, testuser");
  });
});
```

---

### **Zusammenfassung**

* **Unit-Test:** Testet einzelne Funktionen/Komponenten isoliert.
* **Integration-Test:** Testet Zusammenspiel mehrerer Teile.
* **E2E-Test:** Testet die komplette Anwendung wie ein echter Benutzer.

üìñ Quellen:

* [React Testing Library](https://testing-library.com/docs/react-testing-library/intro)
* [MDN Testing](https://developer.mozilla.org/ru/docs/Learn/Tools_and_testing/Testing_client-side_JavaScript)
* [React Docs: Testing](https://react.dev/learn/testing)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

92. ### <a name="92"></a> Was ist Snapshot-Testing?

**Snapshot-Testing** ist eine Testmethode, bei der der **gerenderte Output einer Komponente** gespeichert (als Snapshot-Datei) und bei sp√§teren Testl√§ufen mit der aktuellen Ausgabe verglichen wird.
Wenn sich die Ausgabe ver√§ndert, schl√§gt der Test fehl ‚Äì au√üer man akzeptiert die neue Version des Snapshots.

---

### **Beispiel mit Jest + React Testing Library**

```jsx
// Button.jsx
export function Button({ label }) {
  return <button>{label}</button>;
}

// Button.test.js
import { render } from "@testing-library/react";
import { Button } from "./Button.jsx";

test("Button Snapshot", () => {
  const { asFragment } = render(<Button label="Klick mich" />);
  expect(asFragment()).toMatchSnapshot();
});
```

‚û°Ô∏è Beim ersten Lauf erstellt Jest eine **Snapshot-Datei** (`__snapshots__/Button.test.js.snap`).
‚û°Ô∏è Bei sp√§teren L√§ufen wird verglichen, ob die gerenderte Ausgabe noch identisch ist.

---

### **Vorteile**

* Schnell, einfach zu implementieren.
* Erkennt ungewollte √Ñnderungen im UI.

### **Nachteile**

* Kann zu **falschen Alarmen** f√ºhren, wenn sich die UI oft √§ndert.
* Snapshots k√∂nnen gro√ü und un√ºbersichtlich werden.
* Empfohlen nur f√ºr **stabile, UI-relevante Komponenten**.

---

### **Zusammenfassung**

* Snapshot-Tests speichern den UI-Output und vergleichen ihn mit zuk√ºnftigen Versionen.
* Praktisch f√ºr UI-Regressionstests, aber vorsichtig einsetzen.

üìñ Quellen:

* [React Docs ‚Äì Testing UI](https://react.dev/learn/testing)
* [Jest: Snapshot Testing](https://jestjs.io/docs/snapshot-testing)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

93. ### <a name="93"></a> Welche Tools nutzt man f√ºr React-Tests (Jest, React Testing Library)?

### **Tools f√ºr React-Tests**

#### **1. Jest**

* Test-Runner und Assertions-Bibliothek.
* Standard-Tool im React-√ñkosystem.
* Unterst√ºtzt **Unit-, Integration- und Snapshot-Tests**.
* Features: Mocking von Modulen, Timer, Snapshots.

**Beispiel:**

```js
// sum.js
export function sum(a, b) {
  return a + b;
}

// sum.test.js
import { sum } from "./sum.js";

test("addiert zwei Zahlen", () => {
  expect(sum(2, 3)).toBe(5);
});
```

---

#### **2. React Testing Library (RTL)**

* Baut auf Jest auf.
* Fokus: **Testen wie der Nutzer die App erlebt** (DOM-Queries statt Implementationsdetails).
* Nutzt Queries wie `getByText`, `getByRole`, `getByLabelText`.

**Beispiel:**

```jsx
// Greeting.jsx
export function Greeting({ name }) {
  return <h1>Hallo, {name}!</h1>;
}

// Greeting.test.js
import { render, screen } from "@testing-library/react";
import { Greeting } from "./Greeting.jsx";

test("zeigt Begr√º√üung an", () => {
  render(<Greeting name="Sergii" />);
  expect(screen.getByText("Hallo, Sergii!")).toBeInTheDocument();
});
```

---

#### **3. Erg√§nzende Tools**

* **Cypress / Playwright** ‚Üí E2E-Tests.
* **MSW (Mock Service Worker)** ‚Üí API-Calls mocken.
* **Vitest** ‚Üí Alternative zu Jest (schneller, Vite-basiert).

---

### **Zusammenfassung**

* **Jest**: Test-Runner, Assertions, Snapshots.
* **React Testing Library**: Nutzt DOM-Queries, testet die App wie ein Benutzer.
* **Weitere Tools**: Cypress, Playwright, MSW f√ºr komplexere Szenarien.

üìñ Quellen:

* [Jest Docs](https://jestjs.io/)
* [React Testing Library](https://testing-library.com/docs/react-testing-library/intro)
* [React Docs: Testing](https://react.dev/learn/testing)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

94. ### <a name="94"></a> Wie testet man Komponenten, Props und Events?

### Komponenten, Props und Events testen (React + RTL + Jest)

#### **1) Komponenten-Render**

* Ziel: Render funktioniert, relevantes UI ist sichtbar.

```jsx
// Counter.jsx
import { useState } from "react";
export function Counter({ initial = 0 }) {
  const [count, setCount] = useState(initial);
  return (
    <div>
      <h1 aria-label="count">{count}</h1>
      <button onClick={() => setCount(c => c + 1)}>+1</button>
    </div>
  );
}
```

```jsx
// Counter.test.jsx
import { render, screen } from "@testing-library/react";
import { Counter } from "./Counter.jsx";

test("rendert √úberschrift und Button", () => {
  render(<Counter />);
  expect(screen.getByRole("heading", { name: /0/i })).toBeInTheDocument(); // via Rolle
  expect(screen.getByRole("button", { name: "+1" })).toBeInTheDocument();
});
```

#### **2) Props testen**

* Ziel: Ausgabe/Verhalten entspricht √ºbergebenen Props (Text, Attribute, ARIA, initialer State).

```jsx
import { render, screen } from "@testing-library/react";
import { Counter } from "./Counter.jsx";

test("nutzt initial-Prop f√ºr Startwert", () => {
  render(<Counter initial={5} />);
  expect(screen.getByLabelText("count")).toHaveTextContent("5");
});
```

Weitere Prop-Beispiele:

```jsx
// Button.jsx
export function Button({ label, disabled }) {
  return <button disabled={disabled}>{label}</button>;
}

// Button.test.jsx
import { render, screen } from "@testing-library/react";
import { Button } from "./Button.jsx";

test("zeigt Label und disabled-Attribut", () => {
  render(<Button label="Speichern" disabled />);
  expect(screen.getByRole("button", { name: "Speichern" })).toBeDisabled();
});
```

#### **3) Events & Callback-Props**

* Ziel: Nutzerinteraktionen (Click, Tastatur, Eingabe) und aufgerufene Callback-Props.
* Empfehlung: **@testing-library/user-event** (realistischere Interaktionen als `fireEvent`).

```jsx
// Toggle.jsx
export function Toggle({ onChange }) {
  return (
    <label>
      <input type="checkbox" onChange={(e) => onChange(e.target.checked)} />
      Aktiv
    </label>
  );
}
```

```jsx
// Toggle.test.jsx (Jest/Vitest: jest.fn() bzw. vi.fn())
import { render, screen } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import { Toggle } from "./Toggle.jsx";

test("ruft onChange mit richtigem Wert auf", async () => {
  const onChange = jest.fn();
  render(<Toggle onChange={onChange} />);
  await userEvent.click(screen.getByRole("checkbox"));
  expect(onChange).toHaveBeenCalledWith(true);
});
```

**Formulare/Controlled Components:**

```jsx
// Search.jsx
import { useState } from "react";
export function Search({ onSubmit }) {
  const [q, setQ] = useState("");
  return (
    <form onSubmit={(e) => { e.preventDefault(); onSubmit(q); }}>
      <label htmlFor="q">Suche</label>
      <input id="q" value={q} onChange={(e) => setQ(e.target.value)} />
      <button type="submit">Suchen</button>
    </form>
  );
}
```

```jsx
// Search.test.jsx
import { render, screen } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import { Search } from "./Search.jsx";

test("√ºbermittelt eingegebenen Wert", async () => {
  const onSubmit = jest.fn();
  render(<Search onSubmit={onSubmit} />);
  await userEvent.type(screen.getByLabelText("Suche"), "react testing");
  await userEvent.click(screen.getByRole("button", { name: /suchen/i }));
  expect(onSubmit).toHaveBeenCalledWith("react testing");
});
```

#### **4) Asynchrone Effekte & `findBy*`**

* Ziel: Auf UI warten, das nach einem Effekt/Fetch erscheint.

```jsx
// Greeting.jsx
import { useEffect, useState } from "react";
export function Greeting({ load }) {
  const [text, setText] = useState("L√§dt...");
  useEffect(() => { load().then((t) => setText(t)); }, [load]);
  return <p>{text}</p>;
}
```

```jsx
// Greeting.test.jsx
import { render, screen } from "@testing-library/react";
import { Greeting } from "./Greeting.jsx";

test("wartet auf geladenen Text", async () => {
  const load = jest.fn().mockResolvedValue("Hallo Sergii!");
  render(<Greeting load={load} />);
  expect(await screen.findByText("Hallo Sergii!")).toBeInTheDocument(); // wartet async
});
```

#### **5) Best Practices (kurz)**

* Teste **sichtbares Verhalten**, nicht Implementierungsdetails (keine internen States mocken).
* Nutze **Rollen/Label** statt `getByTestId`, wo m√∂glich (Barrierefreiheit).
* **user-event** statt `fireEvent` f√ºr realistische Interaktionen.
* F√ºr HTTP: **MSW** zum Mocken statt globaler Fetch-Mocks.
* Kleine, fokussierte Tests; sprechende Queries.

---

### **Zusammenfassung**

* **Komponenten**: mit RTL `render` + DOM-Queries pr√ºfen.
* **Props**: √ºbergeben und UI/Attribute/ARIA validieren.
* **Events**: mit `user-event` Interaktionen ausl√∂sen; Callback-Props mit `jest.fn()`/`vi.fn()` verifizieren.
* **Async**: `findBy*` nutzen, auf UI-Ergebnis warten.

**Quellen:**

* React Docs ‚Äì Testing: [https://react.dev/learn/testing](https://react.dev/learn/testing)
* RTL ‚Äì Intro & Queries: [https://testing-library.com/docs/react-testing-library/intro](https://testing-library.com/docs/react-testing-library/intro)
* MDN (RU) ‚Äì –°–æ–±—ã—Ç–∏—è / –§–æ—Ä–º—ã / –î–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å: [https://developer.mozilla.org/ru/](https://developer.mozilla.org/ru/)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

95. ### <a name="95"></a> Wie testet man benutzerdefinierte Hooks?

### Benutzerdefinierte Hooks testen (Strategien + Beispiele)

#### **Strategie**

* **Indirekt (empfohlen):** Komponente testen, die den Hook nutzt ‚áí realistisch und weniger an Implementierungsdetails gebunden. ([testing-library.com][1])
* **Direkt:** Hook isoliert mit `renderHook` testen (React Testing Library). Nutze `act` f√ºr State-Updates und `waitFor`/`findBy*` f√ºr Async. ([testing-library.com][1])

---

### **1) Reiner Logik-Hook (synchron) mit `renderHook`**

```js
// useCounter.js
import { useState, useCallback } from "react";

export function useCounter(initial = 0) {
  const [count, setCount] = useState(initial);
  const inc = useCallback(() => setCount(c => c + 1), []);
  const reset = useCallback(() => setCount(initial), [initial]);
  return { count, inc, reset };
}
```

```js
// useCounter.test.js
import { renderHook, act } from "@testing-library/react";
import { useCounter } from "./useCounter.js";

test("incrementiert und resetet korrekt", () => {
  const { result } = renderHook(() => useCounter(5));
  act(() => result.current.inc());
  expect(result.current.count).toBe(6);
  act(() => result.current.reset());
  expect(result.current.count).toBe(5);
});
```

`renderHook` ist Teil der RTL-API; `act` b√ºndelt ausstehende Updates vor Assertions. ([testing-library.com][1])

---

### **2) Datenabholender Hook (asynchron) mit MSW**

```js
// useUser.js
import { useEffect, useState } from "react";

export function useUser(id) {
  const [state, setState] = useState({ data: null, error: null, loading: true });

  useEffect(() => {
    let cancelled = false;
    fetch(`/api/users/${id}`)
      .then(r => r.json())
      .then(data => !cancelled && setState({ data, error: null, loading: false }))
      .catch(err => !cancelled && setState({ data: null, error: err, loading: false }));
    return () => { cancelled = true; };
  }, [id]);

  return state;
}
```

```js
// useUser.test.js  (vereinfachte MSW-Nutzung)
import { renderHook, waitFor } from "@testing-library/react";
import { setupServer } from "msw/node";
import { rest } from "msw";
import { useUser } from "./useUser.js";

const server = setupServer(
  rest.get("/api/users/:id", (req, res, ctx) =>
    res(ctx.json({ id: req.params.id, name: "Sergii" }))
  )
);

beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());

test("liefert Daten und beendet Loading", async () => {
  const { result } = renderHook(() => useUser(1));
  await waitFor(() => expect(result.current.loading).toBe(false));
  expect(result.current.data).toEqual({ id: "1", name: "Sergii" });
  expect(result.current.error).toBeNull();
});
```

MSW mockt HTTP realistisch auf Netzwerkebene; mit RTL wartest du per `waitFor` auf das UI/Ergebnis. ([Chip Cullen][2])

---

### **3) Hook mit Context/Providern: `wrapper` nutzen**

```js
// useAuth.js
import { createContext, useContext } from "react";
const AuthContext = createContext(null);
export function AuthProvider({ children, user }) {
  return <AuthContext.Provider value={user}>{children}</AuthContext.Provider>;
}
export function useAuth() {
  const user = useContext(AuthContext);
  if (!user) throw new Error("No auth");
  return user;
}
```

```jsx
// useAuth.test.jsx
import { renderHook } from "@testing-library/react";
import { AuthProvider, useAuth } from "./useAuth.jsx";

test("liest Nutzer aus Context via wrapper", () => {
  const wrapper = ({ children }) => <AuthProvider user={{ id: 1 }}>{children}</AuthProvider>;
  const { result } = renderHook(() => useAuth(), { wrapper });
  expect(result.current).toEqual({ id: 1 });
});
```

`renderHook` unterst√ºtzt einen `wrapper`, um Provider/Router/QueryClient einzubinden. ([testing-library.com][1])

---

### **Best Practices (kurz)**

* Wenn m√∂glich, **indirekt √ºber Komponenten testen**; `renderHook` vor allem f√ºr Bibliotheks-Hooks bzw. komplexe Logik. ([testing-library.com][1])
* **Keine Implementierungsdetails mocken**; teste beobachtbares Verhalten. Nutze DOM-Queries/Benutzerfluss in Komponententests. ([testing-library.com][1])
* F√ºr User-Interaktionen **`@testing-library/user-event`** statt `fireEvent`. ([testing-library.com][3])
* F√ºr asynchrone Updates `act`/`waitFor`/`findBy*` verwenden. ([react.dev][4])

---

### **Zusammenfassung**

* **Zwei Wege:** indirekt √ºber Komponenten (bevorzugt) oder direkt mit `renderHook`.
* **Async:** mit MSW HTTP mocken, mit `waitFor`/`findBy*` auf Ergebnisse warten.
* **Context:** `wrapper` im `renderHook` f√ºr Provider nutzen.

**Quellen / Weiterlesen:**

* React Testing Library API (`renderHook`, `wrapper`): ([testing-library.com][1])
* React Docs ‚Äì `act`: ([react.dev][4])
* MDN (RU) ‚Äì –æ—Å–Ω–æ–≤—ã/—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–ª–∏–µ–Ω—Ç—Å–∫–æ–≥–æ JS: ([MDN Web Docs][5])
* Testing Library ‚Äì `user-event`:

[1]: https://testing-library.com/docs/react-testing-library/api/ "API | Testing Library"
[2]: https://chipcullen.com/mocking-fetch-requests-in-react-testing-library-tests/?utm_source=chatgpt.com "How to mock fetch requests in React Testing Librarty tests"
[3]: https://testing-library.com/docs/user-event/intro/?utm_source=chatgpt.com "Introduction"
[4]: https://react.dev/reference/react/act?utm_source=chatgpt.com "React"
[5]: https://developer.mozilla.org/ru/docs/Web/JavaScript?utm_source=chatgpt.com "JavaScript | MDN - Mozilla"

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

96. ### <a name="96"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

97. ### <a name="97"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

98. ### <a name="98"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

99. ### <a name="99"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

100. ### <a name="100"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**    

101. ### <a name="101"></a> Wie funktioniert Routing in React mit react-router-dom?

### Routing in React mit **react-router-dom**

#### **Grundprinzip**

* Routing in React ist **Client-Side-Routing**: kein vollst√§ndiges Reload der Seite, sondern UI-Austausch basierend auf der URL.
* `react-router-dom` stellt Komponenten und Hooks bereit, um Pfade mit React-Komponenten zu verbinden.
* Kernkomponenten:

  * `<BrowserRouter>` ‚Äì stellt den Router-Context bereit.
  * `<Routes>` ‚Äì Container f√ºr definierte Routen.
  * `<Route>` ‚Äì verbindet Pfad (`path`) mit UI (`element`).
  * `<Link>` / `<NavLink>` ‚Äì Navigation ohne Page-Reload.
  * `useNavigate` ‚Äì Navigation programmatisch.
  * `useParams` ‚Äì Zugriff auf URL-Parameter.
  * `useLocation` ‚Äì Zugriff auf aktuelle URL.

---

### **1) Basisrouting**

```jsx
// App.jsx
import { BrowserRouter, Routes, Route, Link } from "react-router-dom";
import { Home } from "./Home.jsx";
import { About } from "./About.jsx";

export default function App() {
  return (
    <BrowserRouter>
      <nav>
        <Link to="/">Start</Link> | <Link to="/about">√úber uns</Link>
      </nav>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
      </Routes>
    </BrowserRouter>
  );
}
```

---

### **2) Dynamische Routen + useParams**

```jsx
// User.jsx
import { useParams } from "react-router-dom";

export function User() {
  const { id } = useParams();
  return <h2>User ID: {id}</h2>;
}

// App.jsx
<Route path="/user/:id" element={<User />} />
```

Aufruf `http://localhost:3000/user/42` ‚Üí zeigt `User ID: 42`.

---

### **3) Programmatische Navigation**

```jsx
// Login.jsx
import { useNavigate } from "react-router-dom";

export function Login() {
  const navigate = useNavigate();
  function handleLogin() {
    // ... Auth-Logik
    navigate("/dashboard");
  }
  return <button onClick={handleLogin}>Einloggen</button>;
}
```

---

### **4) Verschachtelte Routen**

```jsx
// Dashboard.jsx
import { Outlet, Link } from "react-router-dom";

export function Dashboard() {
  return (
    <div>
      <h1>Dashboard</h1>
      <Link to="stats">Statistiken</Link>
      <Outlet /> {/* zeigt verschachtelte Route */}
    </div>
  );
}

// App.jsx
<Routes>
  <Route path="/dashboard" element={<Dashboard />}>
    <Route path="stats" element={<h2>Stats-Seite</h2>} />
  </Route>
</Routes>
```

---

### **5) Fehlerseite / Catch-All**

```jsx
<Route path="*" element={<h2>Seite nicht gefunden</h2>} />
```

---

### **Zusammenfassung**

* `react-router-dom` implementiert **Client-Side-Routing**.
* Wichtigste Bausteine: `<BrowserRouter>`, `<Routes>`, `<Route>`.
* **Navigation:** `<Link>`/`useNavigate`.
* **Dynamische Daten:** `useParams`, `useLocation`.
* **Strukturierung:** verschachtelte Routen mit `<Outlet>`.

üìñ Quellen:

* [React Router ‚Äì Doku](https://reactrouter.com/en/main)
* [React Docs: Adding React Router](https://react.dev/learn/adding-react-router)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

102. ### <a name="102"></a> Was sind die Unterschiede zwischen react-router v5 und v6?

### Unterschiede zwischen **react-router v5** und **v6**

#### 1) **`<Switch>` ‚Üí `<Routes>`** (Best-Match statt Reihenfolge)

* v5: `<Switch>` rendert die **erste** passende Route.
* v6: `<Routes>` w√§hlt anhand **bester √úbereinstimmung**; verschachtelte/relative Routen sind der Standard. ([React Router][1])

```jsx
// v5
import { BrowserRouter, Switch, Route } from "react-router-dom";
<BrowserRouter>
  <Switch>
    <Route exact path="/" component={Home} />
    <Route path="/users/:id" component={User} />
  </Switch>
</BrowserRouter>

// v6
import { BrowserRouter, Routes, Route } from "react-router-dom";
<BrowserRouter>
  <Routes>
    <Route path="/" element={<Home />} />
    <Route path="/users/:id" element={<User />} />
  </Routes>
</BrowserRouter>
```

#### 2) **`element` statt `component`/`render`**

* v5: `<Route component={Home} />` oder `render`.
* v6: `<Route element={<Home/>} />` ‚Äì klarere Props und bessere Typisierung. ([React Router][1])

#### 3) **Navigation: `useNavigate` statt `useHistory`**

* v5: `useHistory().push|replace|go`.
* v6: `useNavigate()`; `navigate("/x", { replace: true, state })`. ([React Router][1])

```jsx
// v5
import { useHistory } from "react-router-dom";
const history = useHistory();
history.replace("/dashboard");

// v6
import { useNavigate } from "react-router-dom";
const navigate = useNavigate();
navigate("/dashboard", { replace: true });
```

#### 4) **Redirect: `<Redirect>` ‚Üí `<Navigate>`**

* v5: `<Redirect to="/login" />` (oft in `<Switch>`).
* v6: `<Navigate to="/login" replace />`. ([React Router][1])

```jsx
// v6
import { Navigate } from "react-router-dom";
<Route path="/" element={<Navigate to="/login" replace />} />
```

#### 5) **`exact` entf√§llt**

* v5: h√§ufig `exact` n√∂tig.
* v6: **exaktes Matching standardm√§√üig**, `NavLink exact` wurde zu `end`. ([React Router][1])

#### 6) **Relative & verschachtelte Routen + `<Outlet>`**

* v6: Routen/Links sind **relativ**; echte **Nesting-Struktur** an einer Stelle definierbar. ([React Router][1])

```jsx
import { Route } from "react-router-dom";
<Route path="/dashboard" element={<Dashboard />}>
  <Route path="stats" element={<Stats />} />
</Route>
```

#### 7) **Hooks & API-√Ñnderungen**

* `useRouteMatch` ‚Üí `useMatch`, `activeClassName/activeStyle` in `NavLink` entfernt; State an `<Link>` separat per `state` √ºbergeben. ([React Router][1])

#### 8) **Data APIs (ab v6.4+)** ‚Äì optionaler neuer Modus

* **Loader/Action**-basierter Datenfluss (`createBrowserRouter`, `RouterProvider`), deklaratives Laden/Mutieren mit Revalidierung. (Neu in v6, existiert nicht in v5.) ([React Router][2])

```jsx
// v6.4+ Data Router
import { createBrowserRouter, RouterProvider } from "react-router-dom";
const router = createBrowserRouter([{ path: "/", element: <Home/>, loader: loadHome }]);
<RouterProvider router={router} />;
```

---

### Zusammenfassung

* **Routes/element** ersetzen **Switch/component/render**; Matching ist **exakt per Default**.
* **useNavigate/Navigate** statt **useHistory/Redirect**.
* **Relative & verschachtelte Routen** mit `<Outlet>`; mehrere API-Bereinigungen.
* **Data Router (v6.4+)** bringt Loader/Actions f√ºr deklaratives Datenladen/-schreiben.

**Quellen:**

* React Router ‚Äì *Upgrading from v5*: ([React Router][1])
* React Router ‚Äì *Modes/Data (Loader/Action)*: ([React Router][2])
* React Router ‚Äì *Data Loading* (Loader): ([React Router][3])
* React Docs ‚Äì *Adding React Router*: ([React Router][4])

[1]: https://reactrouter.com/6.30.1/upgrading/v5 "Upgrading from v5 v6.30.1 | React Router"
[2]: https://reactrouter.com/start/modes?utm_source=chatgpt.com "Picking a Mode"
[3]: https://reactrouter.com/start/framework/data-loading?utm_source=chatgpt.com "Data Loading"
[4]: https://reactrouter.com/?utm_source=chatgpt.com "React Router Official Documentation"

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

103. ### <a name="103"></a> Was sind Route, Link, Navigate, Outlet?

### **Route, Link, Navigate, Outlet in react-router-dom**

#### **1) `<Route>`**

* Verbindet **URL-Pfad** mit einem React-Element.
* Wird innerhalb von `<Routes>` verwendet.
* Unterst√ºtzt statische und dynamische Pfade (`/user/:id`).

```jsx
import { Routes, Route } from "react-router-dom";
<Routes>
  <Route path="/" element={<Home />} />
  <Route path="/user/:id" element={<User />} />
</Routes>
```

---

#### **2) `<Link>`**

* Erzeugt eine **Navigation ohne Page-Reload** (Client-Side Navigation).
* Ersetzt `<a href="...">`, um Single Page Application Verhalten zu erhalten.

```jsx
import { Link } from "react-router-dom";
<nav>
  <Link to="/">Startseite</Link>
  <Link to="/about">√úber uns</Link>
</nav>
```

---

#### **3) `<Navigate>`**

* Dient zum **Weiterleiten/Redirecten**.
* Typisch f√ºr Login-Weiterleitungen oder gesch√ºtzte Routen.

```jsx
import { Navigate } from "react-router-dom";
function ProtectedRoute({ user }) {
  if (!user) return <Navigate to="/login" replace />;
  return <Dashboard />;
}
```

---

#### **4) `<Outlet>`**

* Platzhalter f√ºr **verschachtelte Routen**.
* Zeigt die **Child-Komponente** einer Route an.

```jsx
import { Routes, Route, Outlet, Link } from "react-router-dom";

function Dashboard() {
  return (
    <div>
      <h1>Dashboard</h1>
      <Link to="stats">Stats</Link>
      <Outlet /> {/* Child-Route wird hier angezeigt */}
    </div>
  );
}

<Routes>
  <Route path="/dashboard" element={<Dashboard />}>
    <Route path="stats" element={<h2>Statistiken</h2>} />
  </Route>
</Routes>
```

---

### **Zusammenfassung**

* **Route**: definiert, welche Komponente bei einem Pfad angezeigt wird.
* **Link**: erm√∂glicht Navigation ohne Seitenreload.
* **Navigate**: leitet programmatisch/automatisch weiter.
* **Outlet**: zeigt Inhalte von verschachtelten Routen an.

üìñ Quellen:

* [React Router ‚Äì Route](https://reactrouter.com/en/main/components/route)
* [React Router ‚Äì Link](https://reactrouter.com/en/main/components/link)
* [React Router ‚Äì Navigate](https://reactrouter.com/en/main/components/navigate)
* [React Router ‚Äì Outlet](https://reactrouter.com/en/main/components/outlet)

---
  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

104. ### <a name="104"></a> Wie erstellt man Nested Routes?

### Nested Routes in **react-router-dom v6**

#### **Grundidee**

* Verschachtelte Routen = Hierarchie von Routen (Eltern ‚Üî Kind).
* Eltern-Route definiert **Layout** oder Container.
* Kind-Routen werden mit `<Outlet>` an der Stelle gerendert, wo der Eltern-Content Platz l√§sst.

---

### **1) Basisstruktur**

```jsx
// App.jsx
import { BrowserRouter, Routes, Route, Link, Outlet } from "react-router-dom";

function Layout() {
  return (
    <div>
      <h1>Dashboard</h1>
      <nav>
        <Link to="overview">√úbersicht</Link> |{" "}
        <Link to="settings">Einstellungen</Link>
      </nav>
      <Outlet /> {/* Kind-Route wird hier angezeigt */}
    </div>
  );
}

function Overview() {
  return <h2>√úbersichtsseite</h2>;
}

function Settings() {
  return <h2>Einstellungen</h2>;
}

export default function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/dashboard" element={<Layout />}>
          <Route path="overview" element={<Overview />} />
          <Route path="settings" element={<Settings />} />
        </Route>
      </Routes>
    </BrowserRouter>
  );
}
```

üëâ Aufruf:

* `/dashboard/overview` ‚Üí rendert `<Layout>` + `<Overview>`
* `/dashboard/settings` ‚Üí rendert `<Layout>` + `<Settings>`

---

### **2) Index-Routen**

* Default-Child, wenn kein weiterer Pfad angegeben ist.

```jsx
<Route path="/dashboard" element={<Layout />}>
  <Route index element={<h2>Willkommen im Dashboard</h2>} />
  <Route path="overview" element={<Overview />} />
</Route>
```

üëâ `/dashboard` zeigt den Index-Content an.

---

### **3) Mehrstufiges Nesting**

* Kinder k√∂nnen selbst wieder Eltern sein ‚Üí beliebige Tiefe m√∂glich.

```jsx
<Route path="/dashboard" element={<Layout />}>
  <Route path="settings" element={<Settings />}>
    <Route path="profile" element={<h3>Profil-Einstellungen</h3>} />
    <Route path="security" element={<h3>Sicherheits-Einstellungen</h3>} />
  </Route>
</Route>
```

üëâ `/dashboard/settings/profile`

---

### **Zusammenfassung**

* **`<Route>` in Route verschachteln.**
* **`<Outlet>`** = Platzhalter im Parent.
* **Index-Route** = Default-Child.
* Mehrstufig m√∂glich durch erneutes Nesting.

üìñ Quellen:

* [React Router ‚Äì Nested Routes](https://reactrouter.com/en/main/start/tutorial#nested-routes)
* [React Docs: Routing mit Outlet](https://react.dev/learn/adding-react-router#nested-routes)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

105. ### <a name="105"></a> Wie implementiert man Redirects?

### Redirects in **react-router-dom v6**

#### **1) Mit `<Navigate>`**

* Wird als **Element** in einer Route oder direkt im JSX gerendert.
* Ersetzt `<Redirect>` aus v5.
* Props: `to` (Ziel), `replace` (verhindert neuen History-Eintrag), `state` (extra Daten).

```jsx
import { Routes, Route, Navigate } from "react-router-dom";

function App() {
  return (
    <Routes>
      <Route path="/" element={<Home />} />
      <Route path="/old" element={<Navigate to="/new" replace />} />
      <Route path="/new" element={<NewPage />} />
    </Routes>
  );
}
```

üëâ Aufruf `/old` ‚Üí Redirect nach `/new`.

---

#### **2) Innerhalb von Komponenten**

* N√ºtzlich bei **Auth-Checks** oder **Bedingungen**.

```jsx
import { Navigate } from "react-router-dom";

function ProtectedRoute({ user }) {
  if (!user) {
    return <Navigate to="/login" replace state={{ from: "/dashboard" }} />;
  }
  return <Dashboard />;
}
```

---

#### **3) Programmatisch mit `useNavigate`**

* Ideal f√ºr Weiterleitungen nach einem Event (z. B. Login).

```jsx
import { useNavigate } from "react-router-dom";

function Login() {
  const navigate = useNavigate();

  function handleLogin() {
    // ... Auth-Logik
    navigate("/dashboard", { replace: true });
  }

  return <button onClick={handleLogin}>Einloggen</button>;
}
```

---

### **Zusammenfassung**

* **`<Navigate>`**: deklarative Redirects in Routen/JSX.
* **`useNavigate`**: programmatische Redirects in Events/Logik.
* **`replace`**: verhindert zus√§tzliche History-Eintr√§ge.

üìñ Quellen:

* [React Router ‚Äì Navigate](https://reactrouter.com/en/main/components/navigate)
* [React Router ‚Äì useNavigate](https://reactrouter.com/en/main/hooks/use-navigate)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

106. ### <a name="106"></a> Wie funktioniert programmgesteuerte Navigation (useNavigate)?

### Programmgesteuerte Navigation mit **`useNavigate`**

#### **Grundidee**

* `useNavigate` ist ein Hook aus **react-router-dom v6**.
* Er ersetzt `useHistory` aus v5.
* Liefert eine Funktion `navigate`, mit der man **per Code** zu einer Route wechseln kann.
* Typische Anwendungsf√§lle: **Login-Weiterleitung, Logout, Form-Submit, Guarded Routes**.

---

### **1) Basisbeispiel**

```jsx
import { useNavigate } from "react-router-dom";

export function Login() {
  const navigate = useNavigate();

  function handleLogin() {
    // ‚Ä¶ Authentifizierung erfolgreich
    navigate("/dashboard"); // zur Dashboard-Seite wechseln
  }

  return <button onClick={handleLogin}>Login</button>;
}
```

---

### **2) Mit Optionen (`replace`, `state`)**

```jsx
function Logout() {
  const navigate = useNavigate();

  function handleLogout() {
    // Session l√∂schen
    navigate("/login", { replace: true, state: { message: "Bitte erneut einloggen" } });
  }

  return <button onClick={handleLogout}>Logout</button>;
}
```

* `replace: true` ‚Üí ersetzt aktuellen History-Eintrag (kein "Zur√ºck"-Button m√∂glich).
* `state` ‚Üí Daten an n√§chste Route √ºbergeben (`useLocation()` abrufbar).

---

### **3) Relative Navigation**

```jsx
function UserMenu() {
  const navigate = useNavigate();

  return (
    <button onClick={() => navigate("settings")}>
      Zu den Einstellungen
    </button>
  );
}
```

üëâ Wenn UserMenu unter `/dashboard` eingebettet ist ‚Üí Navigiert zu `/dashboard/settings`.

---

### **4) Zur√ºck / Vorw√§rts**

```jsx
function BackButton() {
  const navigate = useNavigate();
  return <button onClick={() => navigate(-1)}>Zur√ºck</button>; // -1 = history.back()
}
```

---

### **Zusammenfassung**

* `useNavigate()` gibt eine Funktion zur√ºck, die Navigation **per Code** erm√∂glicht.
* **Syntax:** `navigate(path, { replace, state })`.
* Unterst√ºtzt **absolute/relative Pfade** und **numerische Werte** f√ºr History.
* N√ºtzlich f√ºr Auth-Redirects, After-Submit, Guards.

üìñ Quellen:

* [React Router ‚Äì useNavigate](https://reactrouter.com/en/main/hooks/use-navigate)
* [React Docs: Routing](https://react.dev/learn/adding-react-router)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

107. ### <a name="107"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

108. ### <a name="108"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

109. ### <a name="109"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

110. ### <a name="110"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

111. ### <a name="111"></a> Was ist Redux und wie funktioniert es?

### Redux ‚Äì Was es ist und wie es funktioniert

#### **Definition**

* **Redux** ist eine **State-Management-Bibliothek** f√ºr JavaScript-Apps, oft mit React genutzt.
* Grundidee: Es gibt **eine zentrale State-Quelle (Store)**, auf die alle Komponenten zugreifen k√∂nnen.
* √Ñnderungen passieren nur √ºber **Actions** und **Reducer** ‚áí Vorhersagbarkeit & Nachvollziehbarkeit.

---

#### **Kernprinzipien**

1. **Single Source of Truth**

   * Gesamter globaler State liegt in einem einzigen **Store**.

2. **State ist read-only**

   * State wird nicht direkt ver√§ndert, sondern √ºber **Actions** beschrieben.

3. **√Ñnderungen durch pure Reducer**

   * Reducer sind **pure functions**, die alten State + Action ‚Üí neuen State berechnen.

---

#### **Ablauf**

1. Komponente l√∂st eine **Action** aus (z. B. `{ type: "INCREMENT" }`).
2. Diese Action geht an den **Reducer**.
3. Der Reducer berechnet den **neuen State** und speichert ihn im Store.
4. Komponenten, die mit dem Store verbunden sind, werden automatisch **neu gerendert**.

---

#### **Codebeispiel**

```js
// store.js
import { createStore } from "redux";

// Reducer (pure function)
function counterReducer(state = { value: 0 }, action) {
  switch (action.type) {
    case "INCREMENT":
      return { value: state.value + 1 };
    case "DECREMENT":
      return { value: state.value - 1 };
    default:
      return state;
  }
}

// Store erstellen
export const store = createStore(counterReducer);
```

```jsx
// Counter.jsx
import { useSelector, useDispatch } from "react-redux";
import { Provider } from "react-redux";
import { store } from "./store.js";

function Counter() {
  const count = useSelector(state => state.value);
  const dispatch = useDispatch();

  return (
    <div>
      <p>Z√§hler: {count}</p>
      <button onClick={() => dispatch({ type: "INCREMENT" })}>+1</button>
      <button onClick={() => dispatch({ type: "DECREMENT" })}>-1</button>
    </div>
  );
}

// App.jsx
export default function App() {
  return (
    <Provider store={store}>
      <Counter />
    </Provider>
  );
}
```

---

#### **Zusammenfassung**

* Redux = zentrales **State-Management** mit klarem Datenfluss.
* Drei Prinzipien: **ein Store**, **State nur √ºber Actions ver√§nderbar**, **Reducer als pure functions**.
* Vorteile: **Vorhersagbarkeit, Debugging, Skalierbarkeit**.

üìñ Quellen:

* [Redux Docs ‚Äì Einf√ºhrung](https://redux.js.org/introduction/getting-started)
* [React Redux](https://react-redux.js.org/)
* [MDN ‚Äì State Management](https://developer.mozilla.org/ru/docs/Glossary/State_management)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

112. ### <a name="112"></a> Was sind Actions, Reducer und Store?

### Actions, Reducer und Store in **Redux**

#### **1) Actions**

* **Plain JavaScript Objects**, die beschreiben, **was passieren soll**.
* M√ºssen ein `type`-Feld haben (string, eindeutig).
* K√∂nnen zus√§tzliche Daten enthalten (`payload`).

```js
// Beispiel-Action
{ type: "INCREMENT" }
{ type: "ADD_TODO", payload: { id: 1, text: "React lernen" } }
```

---

#### **2) Reducer**

* **Pure Function**: `(state, action) ‚Üí newState`.
* Entscheidet anhand des `action.type`, wie der **neue State** aussieht.
* Darf State nicht direkt mutieren, sondern muss **immutabel** arbeiten.

```js
// reducer.js
function counterReducer(state = { value: 0 }, action) {
  switch (action.type) {
    case "INCREMENT":
      return { value: state.value + 1 };
    case "DECREMENT":
      return { value: state.value - 1 };
    default:
      return state;
  }
}
```

---

#### **3) Store**

* Der **zentrale Container** f√ºr den State.
* Enth√§lt Methoden:

  * `getState()` ‚Äì aktuellen State lesen
  * `dispatch(action)` ‚Äì Action an Reducer senden
  * `subscribe(listener)` ‚Äì auf √Ñnderungen reagieren

```js
import { createStore } from "redux";
import counterReducer from "./reducer.js";

// Store erstellen
const store = createStore(counterReducer);

// State auslesen
console.log(store.getState()); // { value: 0 }

// Action dispatchen
store.dispatch({ type: "INCREMENT" });
console.log(store.getState()); // { value: 1 }
```

---

### **Zusammenfassung**

* **Actions**: Beschreiben *was* passiert (Objekte).
* **Reducer**: Reine Funktionen, berechnen den *neuen State* basierend auf Actions.
* **Store**: H√§lt den State, verwaltet den Datenfluss (`getState`, `dispatch`, `subscribe`).

üìñ Quellen:

* [Redux Docs ‚Äì Core Concepts](https://redux.js.org/introduction/core-concepts)
* [React Redux Docs](https://react-redux.js.org/introduction/quick-start)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

113. ### <a name="113"></a> Wie funktioniert Redux Toolkit (createSlice, configureStore, createAsyncThunk)?

### Redux Toolkit (RTK) ‚Äì moderne Art, Redux zu nutzen

Redux Toolkit ist die **offizielle, empfohlene Methode**, Redux-Code zu schreiben.
Es reduziert Boilerplate und vereinfacht die Arbeit mit Actions, Reducern und Async-Logik.

---

## **1) `createSlice`**

* B√ºndelt **State**, **Reducer** und automatisch generierte **Actions** in einem "Slice".
* Spart das manuelle Erstellen von Action-Objekten und Action-Creators.

```js
// counterSlice.js
import { createSlice } from "@reduxjs/toolkit";

const counterSlice = createSlice({
  name: "counter",
  initialState: { value: 0 },
  reducers: {
    increment: (state) => { state.value += 1 },   // erlaubt direkte Mutation (immer noch immutable dank Immer)
    decrement: (state) => { state.value -= 1 },
    addBy: (state, action) => { state.value += action.payload }
  }
});

export const { increment, decrement, addBy } = counterSlice.actions;
export default counterSlice.reducer;
```

üëâ Generiert automatisch:

* Reducer-Funktion (`counterSlice.reducer`)
* Action Creators (`increment()`, `decrement()`, `addBy(5)`)

---

## **2) `configureStore`**

* Erstellt den zentralen Store.
* Integriert automatisch **Redux DevTools** und Middleware (z. B. Thunk).

```js
// store.js
import { configureStore } from "@reduxjs/toolkit";
import counterReducer from "./counterSlice.js";

export const store = configureStore({
  reducer: {
    counter: counterReducer
  }
});
```

---

## **3) `createAsyncThunk`**

* F√ºr **asynchrone Logik** (z. B. API-Aufrufe).
* Generiert automatisch Pending/ Fulfilled/ Rejected-Actions.

```js
// usersSlice.js
import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";

// Async-Action
export const fetchUsers = createAsyncThunk("users/fetchUsers", async () => {
  const res = await fetch("https://jsonplaceholder.typicode.com/users");
  return res.json();
});

const usersSlice = createSlice({
  name: "users",
  initialState: { list: [], status: "idle", error: null },
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchUsers.pending, (state) => {
        state.status = "loading";
      })
      .addCase(fetchUsers.fulfilled, (state, action) => {
        state.status = "succeeded";
        state.list = action.payload;
      })
      .addCase(fetchUsers.rejected, (state, action) => {
        state.status = "failed";
        state.error = action.error.message;
      });
  }
});

export default usersSlice.reducer;
```

---

## **4) Nutzung in Komponenten**

```jsx
// Counter.jsx
import { useSelector, useDispatch } from "react-redux";
import { increment, addBy } from "./counterSlice.js";
import { fetchUsers } from "./usersSlice.js";

export function Counter() {
  const count = useSelector((state) => state.counter.value);
  const dispatch = useDispatch();

  return (
    <div>
      <p>Z√§hler: {count}</p>
      <button onClick={() => dispatch(increment())}>+1</button>
      <button onClick={() => dispatch(addBy(5))}>+5</button>
      <button onClick={() => dispatch(fetchUsers())}>Load Users</button>
    </div>
  );
}
```

---

### **Zusammenfassung**

* **`createSlice`**: Definiert State + Reducer + Actions in einer kompakten Form.
* **`configureStore`**: Vereinfacht Store-Setup mit DevTools + Middleware.
* **`createAsyncThunk`**: Standardweg f√ºr asynchrone Logik, generiert automatisch Pending/Fulfilled/Rejected-Actions.
* RTK macht Redux-Code **k√ºrzer, lesbarer und weniger fehleranf√§llig**.

üìñ Quellen:

* [Redux Toolkit ‚Äì Getting Started](https://redux-toolkit.js.org/introduction/getting-started)
* [Redux Toolkit ‚Äì createSlice](https://redux-toolkit.js.org/api/createSlice)
* [Redux Toolkit ‚Äì createAsyncThunk](https://redux-toolkit.js.org/api/createAsyncThunk)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

114. ### <a name="114"></a> Was ist RTK Query?

### RTK Query ‚Äì was es ist und wie es funktioniert

#### **Definition**

* **RTK Query** ist ein offizielles Zusatzmodul von **Redux Toolkit**.
* Es bietet ein **integriertes Data-Fetching und Caching-System** f√ºr API-Anfragen.
* Ziel: Weniger Boilerplate bei Server-Requests und State-Handling (Loading, Error, Cache).

---

#### **Kernfeatures**

* Automatisches **Caching & Refetching** von Daten.
* Generiert automatisch **Hooks** f√ºr Queries (GET) und Mutations (POST/PUT/DELETE).
* Integriert sich nahtlos in Redux Toolkit (`configureStore`).
* Spart den Einsatz von zus√§tzlichen Libraries wie Axios + Redux Thunk + eigene Loading/Error-States.

---

#### **1) API-Slice erstellen**

```js
// services/api.js
import { createApi, fetchBaseQuery } from "@reduxjs/toolkit/query/react";

export const api = createApi({
  reducerPath: "api", // wird automatisch im Store registriert
  baseQuery: fetchBaseQuery({ baseUrl: "https://jsonplaceholder.typicode.com" }),
  endpoints: (builder) => ({
    getUsers: builder.query({
      query: () => "/users"
    }),
    addUser: builder.mutation({
      query: (newUser) => ({
        url: "/users",
        method: "POST",
        body: newUser
      })
    })
  })
});

export const { useGetUsersQuery, useAddUserMutation } = api;
```

---

#### **2) Store einrichten**

```js
// store.js
import { configureStore } from "@reduxjs/toolkit";
import { api } from "./services/api.js";

export const store = configureStore({
  reducer: {
    [api.reducerPath]: api.reducer
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(api.middleware)
});
```

---

#### **3) Nutzung in Komponenten**

```jsx
// Users.jsx
import { useGetUsersQuery, useAddUserMutation } from "./services/api.js";

export function Users() {
  const { data, error, isLoading } = useGetUsersQuery();
  const [addUser] = useAddUserMutation();

  if (isLoading) return <p>L√§dt...</p>;
  if (error) return <p>Fehler: {error.message}</p>;

  return (
    <div>
      <ul>
        {data.map((user) => (
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>
      <button onClick={() => addUser({ name: "Sergii" })}>Neuer User</button>
    </div>
  );
}
```

---

### **Zusammenfassung**

* **RTK Query** = Data-Fetching- und Cache-L√∂sung f√ºr Redux Toolkit.
* Stellt automatisch **Hooks** (`useGetXQuery`, `useAddXMutation`) bereit.
* Handhabt **Loading, Error, Refetch, Cache** automatisch.
* Vereinfacht API-Integration erheblich.

üìñ Quellen:

* [Redux Toolkit ‚Äì RTK Query Overview](https://redux-toolkit.js.org/rtk-query/overview)
* [Redux Toolkit ‚Äì API Reference](https://redux-toolkit.js.org/rtk-query/api/createApi)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

115. ### <a name="115"></a> Was ist der Unterschied zwischen Redux und der Context-API?

### Unterschied zwischen **Redux** und **React Context API**

#### **1) Zweck**

* **Context API**:

  * React-eigene L√∂sung, um **Props-Drilling** zu vermeiden.
  * Gut f√ºr **einfaches, globales Teilen von Daten** (z. B. Theme, Auth-Status, Sprache).

* **Redux**:

  * Vollwertige **State-Management-Bibliothek**.
  * Geeignet f√ºr **komplexe, ver√§nderliche globale States** mit klarer Struktur (Actions, Reducer, Middleware).

---

#### **2) Datenfluss & Architektur**

* **Context API**:

  * Basiert auf **Provider/Consumer**-Pattern.
  * Kein eingebautes Konzept von Actions oder Reducern ‚Äì reine Werteweitergabe.

* **Redux**:

  * Strenger **unidirektionaler Datenfluss**: Action ‚Üí Reducer ‚Üí Store ‚Üí UI.
  * Erm√∂glicht **Zeitreisen (DevTools), Middleware (z. B. Logging, Async)**.

---

#### **3) Skalierung**

* **Context API**:

  * Einfach, aber bei **h√§ufigen State-√Ñnderungen** oder **gro√üen Apps** kann es Performance-Probleme geben (Re-Renders aller Consumer).
  * Keine integrierte Debugging- oder DevTools-Unterst√ºtzung.

* **Redux**:

  * Entwickelt f√ºr **gr√∂√üere Anwendungen** mit vielen State-√Ñnderungen.
  * Performance-optimiert, integrierte **Redux DevTools**, bessere Testbarkeit.

---

#### **4) Beispiel**

**Context API** (Theme):

```jsx
const ThemeContext = React.createContext("light");

function App() {
  return (
    <ThemeContext.Provider value="dark">
      <Toolbar />
    </ThemeContext.Provider>
  );
}
```

**Redux** (Counter):

```js
// reducer.js
function counterReducer(state = { value: 0 }, action) {
  switch (action.type) {
    case "INCREMENT": return { value: state.value + 1 };
    default: return state;
  }
}
```

---

### **Zusammenfassung**

* **Context API**: Einfach, ideal f√ºr **statische oder selten wechselnde Daten**.
* **Redux**: Komplexer, ideal f√ºr **gro√üe Apps mit viel dynamischem State, Middleware, Debugging**.
* Man kann beide auch **kombinieren** (z. B. Redux im Store, Context f√ºr UI-Settings).

üìñ Quellen:

* [React Docs ‚Äì Context](https://react.dev/reference/react/Context)
* [Redux Docs ‚Äì Core Concepts](https://redux.js.org/introduction/core-concepts)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

116. ### <a name="116"></a> Was ist connect() in Redux?

### `connect()` in Redux

#### **Definition**

* `connect()` ist eine **Higher-Order-Component (HOC)** aus der Bibliothek **react-redux** (klassisches API).
* Sie verbindet eine React-Komponente mit dem **Redux-Store**, sodass die Komponente State lesen und Actions dispatchen kann.
* Heute wird es oft durch die Hooks **`useSelector`** und **`useDispatch`** ersetzt, bleibt aber in Legacy-Code weit verbreitet.

---

#### **Syntax**

```js
connect(mapStateToProps, mapDispatchToProps)(Component)
```

* **`mapStateToProps(state)`** ‚Üí bestimmt, welche Teile des Redux-States als Props in die Komponente gehen.
* **`mapDispatchToProps(dispatch)`** ‚Üí bestimmt, welche Actions als Props verf√ºgbar sind.

---

#### **Beispiel**

```jsx
// Counter.jsx
import React from "react";
import { connect } from "react-redux";

function Counter({ count, increment }) {
  return (
    <div>
      <p>Z√§hler: {count}</p>
      <button onClick={increment}>+1</button>
    </div>
  );
}

// State ‚Üí Props
const mapStateToProps = (state) => ({
  count: state.value
});

// Dispatch ‚Üí Props
const mapDispatchToProps = (dispatch) => ({
  increment: () => dispatch({ type: "INCREMENT" })
});

// Komponente mit Store verbinden
export default connect(mapStateToProps, mapDispatchToProps)(Counter);
```

üëâ Ergebnis:

* `count` und `increment` werden als Props an `Counter` √ºbergeben.
* Beim Klick wird `dispatch({ type: "INCREMENT" })` ausgef√ºhrt.

---

#### **Zusammenfassung**

* `connect()` = HOC, das React-Komponenten mit Redux verbindet.
* Nutzt `mapStateToProps` und `mapDispatchToProps`, um State und Actions als Props bereitzustellen.
* Heute meist durch **Hooks (`useSelector`, `useDispatch`)** ersetzt, aber in √§lterem Code noch sehr wichtig.

üìñ Quellen:

* [React Redux ‚Äì connect()](https://react-redux.js.org/api/connect)
* [Redux Docs ‚Äì React Integration](https://redux.js.org/introduction/using-react-redux)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

117. ### <a name="117"></a> Was sind Middleware in Redux (z. B. redux-thunk, redux-logger)?

### Middleware in Redux

#### **Definition**

* **Middleware** sind **Funktionen**, die zwischen `dispatch(action)` und dem Moment laufen, in dem die Action den **Reducer** erreicht.
* Sie erm√∂glichen es, den **Datenfluss in Redux zu erweitern oder zu ver√§ndern**.
* Typische Anwendungsf√§lle: **Asynchronit√§t, Logging, API-Calls, Fehlerbehandlung**.

---

#### **Funktionsweise**

Middleware ist eine Funktion mit der Signatur:

```js
const middleware = store => next => action => {
  // Vor der Weitergabe: z. B. loggen, async-Logik, abfangen
  console.log("Action:", action);

  // Action weiterreichen
  return next(action);
};
```

* **`store`**: Zugriff auf `dispatch` und `getState`.
* **`next`**: leitet die Action an die n√§chste Middleware oder den Reducer weiter.
* **`action`**: die aktuelle Action.

---

#### **Beispiele**

**1) redux-thunk (Async-Logik)**

* Erlaubt es, **Funktionen** statt reiner Objekte zu dispatchen.
* Ideal f√ºr API-Calls oder komplexe Logik.

```js
// Thunk-Action Creator
export const fetchUsers = () => async (dispatch) => {
  dispatch({ type: "users/loading" });
  try {
    const res = await fetch("/api/users");
    const data = await res.json();
    dispatch({ type: "users/success", payload: data });
  } catch (err) {
    dispatch({ type: "users/error", payload: err.message });
  }
};
```

üëâ Ohne Thunk w√§ren nur **synchron Actions** m√∂glich.

---

**2) redux-logger (Logging)**

* Middleware, die automatisch **Actions und State-√Ñnderungen** in der Konsole loggt.

```js
import { createStore, applyMiddleware } from "redux";
import logger from "redux-logger";
import thunk from "redux-thunk";

const store = createStore(rootReducer, applyMiddleware(thunk, logger));
```

üëâ Praktisch beim Debuggen, zeigt alte State ‚Üí Action ‚Üí neuer State.

---

#### **Zusammenfassung**

* **Middleware = Erweiterung des Dispatch-Prozesses.**
* Standard-Usecases: **Async (`redux-thunk`)**, **Logging (`redux-logger`)**, **Fehler-Handling**, **Analytics**.
* Mit Redux Toolkit (`configureStore`) lassen sich Middleware einfach hinzuf√ºgen.

üìñ Quellen:

* [Redux Docs ‚Äì Middleware](https://redux.js.org/understanding/history-and-design/middleware)
* [Redux Thunk](https://github.com/reduxjs/redux-thunk)
* [Redux Logger](https://github.com/LogRocket/redux-logger)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

118. ### <a name="118"></a> Was ist createSelector und wie funktioniert Reselect?

### **Reselect & createSelector in Redux**

#### **Problemstellung**

* In Redux braucht man oft **abgeleitete Daten** aus dem Store (z. B. Filter, Berechnungen).
* Ohne Optimierung wird bei jedem `mapStateToProps` oder `useSelector` **alles neu berechnet**, auch wenn sich relevante Teile nicht ge√§ndert haben ‚Üí unn√∂tige Re-Renders.

---

#### **Reselect**

* **Reselect** ist eine Bibliothek f√ºr **Memoization von Selektoren**.
* Ein *Selector* ist eine Funktion, die Daten aus dem Redux-Store ausw√§hlt.
* Vorteil: Selektoren werden **nur neu berechnet**, wenn sich die relevanten Input-Werte √§ndern.

---

#### **`createSelector`**

* Zentrale Funktion von Reselect.
* Syntax:

```js
createSelector(inputSelectors..., resultFunc)
```

* **inputSelectors**: Funktionen, die Teilbereiche des States zur√ºckgeben.
* **resultFunc**: wird nur ausgef√ºhrt, wenn sich einer der Input-Werte √§ndert.

---

#### **Beispiel**

```js
// state.todos = [{id:1, text:"React lernen", completed:false}, ...]

// 1. Input-Selectoren
const selectTodos = (state) => state.todos;
const selectFilter = (state) => state.filter;

// 2. Memoized Selector mit Reselect
import { createSelector } from "reselect";

export const selectVisibleTodos = createSelector(
  [selectTodos, selectFilter],
  (todos, filter) => {
    console.log("Selector neu berechnet!");
    switch (filter) {
      case "completed":
        return todos.filter((t) => t.completed);
      case "active":
        return todos.filter((t) => !t.completed);
      default:
        return todos;
    }
  }
);
```

üëâ `selectVisibleTodos(state)` berechnet nur dann neu, wenn sich `state.todos` oder `state.filter` √§ndern.
üëâ Verhindert Performance-Probleme bei gro√üen States.

---

#### **Nutzung in Komponenten**

```jsx
import { useSelector } from "react-redux";
import { selectVisibleTodos } from "./selectors.js";

function TodoList() {
  const todos = useSelector(selectVisibleTodos);
  return (
    <ul>
      {todos.map((t) => (
        <li key={t.id}>{t.text}</li>
      ))}
    </ul>
  );
}
```

---

### **Zusammenfassung**

* **Reselect**: Library f√ºr **Memoization von Selektoren**.
* **`createSelector`**: erstellt Selektoren, die nur bei relevanten State-√Ñnderungen neu berechnen.
* Vorteil: **Performance** und **Vermeidung unn√∂tiger Re-Renders**.

üìñ Quellen:

* [Reselect Docs](https://github.com/reduxjs/reselect)
* [Redux Docs ‚Äì Reselect](https://redux.js.org/usage/deriving-data-selectors#creating-memoized-selectors-with-reselect)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

119. ### <a name="119"></a> Wie verbindet man Redux mit React √ºber Hooks (useSelector, useDispatch)?

### React + Redux via Hooks: **`useSelector`** und **`useDispatch`**

#### **1) Store bereitstellen (`<Provider>`)**

```jsx
// main.jsx
import React from "react";
import { createRoot } from "react-dom/client";
import { Provider } from "react-redux";
import { store } from "./store.js";
import App from "./App.jsx";

createRoot(document.getElementById("root")).render(
  <Provider store={store}>
    <App />
  </Provider>
);
```

```js
// store.js (RTK empfohlen)
import { configureStore, createSlice } from "@reduxjs/toolkit";

const counterSlice = createSlice({
  name: "counter",
  initialState: { value: 0 },
  reducers: {
    increment: (state) => { state.value += 1; },
    addBy: (state, action) => { state.value += action.payload; }
  }
});

export const { increment, addBy } = counterSlice.actions;

export const store = configureStore({
  reducer: { counter: counterSlice.reducer }
});
```

---

#### **2) Globalen State lesen: `useSelector`**

* Liest Daten **reaktiv** aus dem Store (re-rendert bei √Ñnderungen des ausgew√§hlten Teilzustands).
* Selektor sollte **so klein wie m√∂glich** sein.

```jsx
// CounterView.jsx
import { useSelector } from "react-redux";

export function CounterView() {
  const value = useSelector((state) => state.counter.value);
  return <p>Wert: {value}</p>;
}
```

> Tipp: F√ºr komplexe Ableitungen **memoisierte Selektoren** (Reselect `createSelector`) nutzen.

---

#### **3) Aktionen ausl√∂sen: `useDispatch`**

* Gibt die `dispatch`-Funktion zur√ºck, um Actions zu senden (sync oder async).

```jsx
// CounterControls.jsx
import { useDispatch } from "react-redux";
import { increment, addBy } from "./store.js";

export function CounterControls() {
  const dispatch = useDispatch();

  return (
    <div>
      <button onClick={() => dispatch(increment())}>+1</button>
      <button onClick={() => dispatch(addBy(5))}>+5</button>
    </div>
  );
}
```

---

#### **4) Async-Dispatch (Thunk/RTK)**

```js
// thunks.js
export const fetchAndAdd = () => async (dispatch) => {
  const res = await fetch("/api/value");
  const { delta } = await res.json();
  dispatch(addBy(delta));
};
```

```jsx
// AsyncButton.jsx
import { useDispatch } from "react-redux";
import { fetchAndAdd } from "./thunks.js";

export function AsyncButton() {
  const dispatch = useDispatch();
  return <button onClick={() => dispatch(fetchAndAdd())}>Server +</button>;
}
```

---

#### **5) Performance-Hinweise (kurz)**

* Selektiere **kleine Slices**: `useSelector(s => s.counter.value)` statt ganzen State.
* F√ºr berechnete Werte **Reselect** verwenden.
* Bei Bedarf `useSelector(selector, shallowEqual)` f√ºr flache Vergleichsoptimierung.
* In gro√üen Apps: **RTK**-Struktur + Feature-Slices.

---

### **Zusammenfassung**

* `<Provider store>` stellt React den Redux-Store bereit.
* **`useSelector`** liest reaktiv Teilzust√§nde aus dem Store.
* **`useDispatch`** sendet Actions (auch Thunks) an den Store.
* F√ºr Performance: kleine Selektoren, Reselect, RTK-Struktur.

**Quellen / Weiterlesen:**

* React Redux Hooks: [https://react-redux.js.org/api/hooks](https://react-redux.js.org/api/hooks)
* Redux Toolkit: [https://redux-toolkit.js.org/introduction/getting-started](https://redux-toolkit.js.org/introduction/getting-started)
* React Docs (State-Management-√úbersicht): [https://react.dev/learn/scaling-up-with-reducer-and-context](https://react.dev/learn/scaling-up-with-reducer-and-context)
* MDN (RU) ‚Äì State-Management-Grundlagen: [https://developer.mozilla.org/ru/docs/Glossary/State_management](https://developer.mozilla.org/ru/docs/Glossary/State_management)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

120. ### <a name="120"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

121. ### <a name="121"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

122. ### <a name="122"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

123. ### <a name="123"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

124. ### <a name="124"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

125. ### <a name="125"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

126. ### <a name="126"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

127. ### <a name="127"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

128. ### <a name="128"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

129. ### <a name="129"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

130. ### <a name="130"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

131. ### <a name="131"></a> Was ist Code-Splitting?

### **Code-Splitting in React**

#### **Definition**

* **Code-Splitting** bedeutet, den JavaScript-Code einer App in **kleinere Bundles** aufzuteilen.
* Statt beim Start die **gesamte App** zu laden, werden nur die **n√∂tigen Teile** geladen.
* Ziel: **Performance** verbessern (schnelleres Initial-Loading, geringere Bundle-Gr√∂√üe).

---

#### **Warum wichtig?**

* Gro√üe SPAs enthalten oft viele Seiten/Features, die nicht sofort gebraucht werden.
* Ohne Code-Splitting: Alles wird im Haupt-Bundle geb√ºndelt ‚Üí lange Ladezeit.
* Mit Code-Splitting: **Lazy Loading** von Routen, Komponenten oder Libraries.

---

#### **1) React.lazy + Suspense**

* Standardmethode in React f√ºr **komponentenbasiertes Code-Splitting**.

```jsx
import React, { Suspense, lazy } from "react";

const About = lazy(() => import("./About.jsx")); // Lazy Load

function App() {
  return (
    <div>
      <Suspense fallback={<p>L√§dt...</p>}>
        <About /> {/* wird nur geladen, wenn ben√∂tigt */}
      </Suspense>
    </div>
  );
}
```

üëâ `About.jsx` wird erst geladen, wenn die Komponente gerendert wird.

---

#### **2) Routing mit Code-Splitting**

```jsx
import { BrowserRouter, Routes, Route } from "react-router-dom";
import { Suspense, lazy } from "react";

const Home = lazy(() => import("./Home.jsx"));
const Dashboard = lazy(() => import("./Dashboard.jsx"));

export default function App() {
  return (
    <BrowserRouter>
      <Suspense fallback={<h2>L√§dt...</h2>}>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/dashboard" element={<Dashboard />} />
        </Routes>
      </Suspense>
    </BrowserRouter>
  );
}
```

---

#### **3) Dynamisches Import()**

* Basis f√ºr Code-Splitting (funktioniert ohne React).
* Webpack/Vite erzeugt automatisch **separate Bundles**.

```js
// Beispiel
button.addEventListener("click", async () => {
  const { calculate } = await import("./math.js");
  console.log(calculate(2, 3));
});
```

---

#### **Tools/Build**

* In React-Apps meist via **Webpack** oder **Vite** konfiguriert (automatisch mit `import()`).
* **Bundle Analyzer** hilft, gro√üe Pakete zu identifizieren.

---

### **Zusammenfassung**

* Code-Splitting = **Aufteilen des Bundles**, um Ladezeiten zu optimieren.
* React bietet **React.lazy + Suspense** f√ºr Komponenten und **Lazy Routing**.
* Build-Tools wie Webpack/Vite nutzen `import()` f√ºr dynamisches Laden.

üìñ Quellen:

* [React Docs ‚Äì Code-Splitting](https://react.dev/reference/react/lazy)
* [MDN ‚Äì import()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/import)
* [Webpack ‚Äì Code Splitting](https://webpack.js.org/guides/code-splitting/)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

132. ### <a name="132"></a> Wie funktionieren React.lazy und Suspense?

### **React.lazy & Suspense**

#### **React.lazy**

* `React.lazy()` erm√∂glicht **Lazy Loading von Komponenten**.
* Statt die Komponente direkt zu importieren, wird sie nur geladen, wenn sie wirklich gebraucht wird.
* Syntax: `const Component = React.lazy(() => import("./Component.jsx"));`
* Funktioniert nur f√ºr **Default Exports**.

---

#### **Suspense**

* `Suspense` ist ein **Wrapper**, der angibt, was angezeigt wird, solange eine Lazy-Komponente noch geladen wird.
* Muss die Lazy-Komponenten umschlie√üen.
* Prop: `fallback` ‚Üí UI w√§hrend des Ladens.

---

#### **Beispiel**

```jsx
import React, { lazy, Suspense } from "react";

// Lazy Loading
const About = lazy(() => import("./About.jsx"));
const Dashboard = lazy(() => import("./Dashboard.jsx"));

export default function App() {
  return (
    <div>
      <h1>Meine App</h1>
      <Suspense fallback={<p>L√§dt...</p>}>
        <About />
        <Dashboard />
      </Suspense>
    </div>
  );
}
```

üëâ `About` und `Dashboard` werden erst dann geladen, wenn sie gerendert werden.

---

#### **Lazy Loading mit Routing**

```jsx
import { BrowserRouter, Routes, Route } from "react-router-dom";
import { Suspense, lazy } from "react";

const Home = lazy(() => import("./Home.jsx"));
const Profile = lazy(() => import("./Profile.jsx"));

export default function App() {
  return (
    <BrowserRouter>
      <Suspense fallback={<h2>Seite l√§dt...</h2>}>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/profile" element={<Profile />} />
        </Routes>
      </Suspense>
    </BrowserRouter>
  );
}
```

---

### **Zusammenfassung**

* **`React.lazy`**: Definiert Komponenten, die erst bei Bedarf geladen werden (Lazy Loading).
* **`Suspense`**: Zeigt ein **Fallback-UI**, bis die Lazy-Komponente fertig geladen ist.
* Vorteil: **Code-Splitting** und bessere Performance.

üìñ Quellen:

* [React Docs ‚Äì `React.lazy`](https://react.dev/reference/react/lazy)
* [React Docs ‚Äì `Suspense`](https://react.dev/reference/react/Suspense)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

133. ### <a name="133"></a> Was ist Tree Shaking?

### **Tree Shaking in React/JavaScript**

#### **Definition**

* **Tree Shaking** = Prozess beim Bundling (z. B. mit Webpack, Rollup, Vite), bei dem **ungenutzter Code automatisch entfernt** wird.
* Ziel: **kleinere Bundle-Gr√∂√üe** ‚Üí bessere Performance.
* Funktioniert durch **statische Analyse** von ES6 **`import`/`export`**.

---

#### **Wie es funktioniert**

* Bundler untersucht, welche **Exporte wirklich importiert/genutzt** werden.
* Alles, was **nicht verwendet** wird, wird aus dem finalen Bundle entfernt.
* Voraussetzung:

  * ES Modules (`import`/`export`), **keine CommonJS (`require`)**.
  * Code muss **side-effect-free** sein oder in `package.json` `"sideEffects": false` deklarieren.

---

#### **Beispiel**

```js
// utils.js
export function add(a, b) { return a + b; }
export function subtract(a, b) { return a - b; }

// app.js
import { add } from "./utils.js";

console.log(add(2, 3));
```

üëâ Ergebnis-Bundle enth√§lt nur `add`, **`subtract` wird entfernt**.

---

#### **React-spezifisch**

* Hilft, nur die tats√§chlich genutzten **Komponenten, Hooks oder Funktionen** ins Bundle zu packen.
* Wichtig beim Import von **Utility-Bibliotheken** wie lodash, date-fns, Material UI.

  * Statt `import _ from "lodash";` besser: `import debounce from "lodash/debounce";`

---

#### **Zusammenfassung**

* **Tree Shaking** entfernt ungenutzten Code beim Bundling.
* Nutzt **statische ES6-Imports/Exports**.
* F√ºhrt zu **kleineren, schnelleren Bundles**.

üìñ Quellen:

* [MDN ‚Äì Tree shaking](https://developer.mozilla.org/ru/docs/Glossary/Tree_shaking)
* [Webpack ‚Äì Tree Shaking](https://webpack.js.org/guides/tree-shaking/)
* [Rollup ‚Äì Tree Shaking](https://rollupjs.org/introduction/#tree-shaking)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

134. ### <a name="134"></a> Was ist Server-Side Rendering (SSR) und Hydration?

### **Server-Side Rendering (SSR) und Hydration**

#### **Server-Side Rendering (SSR)**

* Bei **SSR** wird die React-App bereits **auf dem Server in HTML gerendert** und an den Browser geschickt.
* Vorteil:

  * **Schnellere First Paint** (User sieht sofort Inhalt, auch ohne JS).
  * **SEO-freundlich**, da Suchmaschinen HTML direkt lesen k√∂nnen.
* Nachteil:

  * Mehr Serverlast, komplexere Infrastruktur.

**Beispiel (Next.js ‚Äì SSR-Page):**

```jsx
// pages/index.jsx
export async function getServerSideProps() {
  const res = await fetch("https://api.example.com/data");
  const data = await res.json();
  return { props: { data } };
}

export default function Home({ data }) {
  return <h1>{data.title}</h1>;
}
```

---

#### **Hydration**

* Prozess, bei dem **React im Browser das bereits gerenderte HTML √ºbernimmt** und interaktiv macht.
* Der Server liefert statisches HTML ‚Üí React f√ºgt **Event-Handler & State-Management** hinzu.
* Ohne Hydration w√§re die Seite nur ‚Äûtotes‚Äú HTML.

**Hydration im Browser (React 18):**

```jsx
import { createRoot, hydrateRoot } from "react-dom/client";
import App from "./App.jsx";

// hydrateRoot √ºbernimmt vom Server gerendertes HTML
hydrateRoot(document.getElementById("root"), <App />);
```

---

#### **Zusammenhang**

1. Server rendert React-Komponenten zu HTML ‚Üí schickt HTML an den Client.
2. Browser zeigt sofort Inhalt (SEO + schnelle Ladezeit).
3. React **hydriert**: bindet Event-Handler an vorhandenes DOM ‚Üí Seite wird interaktiv.

---

### **Zusammenfassung**

* **SSR**: Rendern von React-Komponenten zu HTML auf dem Server ‚Üí schneller, SEO-freundlich.
* **Hydration**: Reaktivieren der serverseitig gerenderten HTML-Struktur durch React im Client.
* Typisch umgesetzt mit Frameworks wie **Next.js** oder **Remix**.

üìñ Quellen:

* [React Docs ‚Äì Hydration](https://react.dev/reference/react-dom/client/hydrateRoot)
* [Next.js Docs ‚Äì SSR](https://nextjs.org/docs/basic-features/pages#server-side-rendering)
* [MDN ‚Äì Server-Side Rendering](https://developer.mozilla.org/ru/docs/Glossary/Server-side_rendering)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

135. ### <a name="135"></a> Wie geht man mit Hydration-Fehlern bei SSR um?

### **Hydration-Fehler bei SSR: Ursachen & L√∂sungen**

#### **Typische Ursachen**

* **Nicht-deterministisches Rendering**: `Date.now()`, `Math.random()`, `new Date().toLocaleString()` ‚Üí Server/Client unterscheiden sich.
* **Zugriff auf Browser-APIs beim Rendern**: `window`, `document` auf dem Server.
* **Instabile IDs**: selbst generierte IDs unterscheiden sich auf Server/Client.
* **Falscher Einstiegspunkt**: `createRoot` statt **`hydrateRoot`**. ([react.dev][1])

---

#### **Grundregeln zur Vermeidung**

1. **Gleiches Markup auf Server & Client erzeugen**

   * Keine zuf√§lligen/zeitabh√§ngigen Werte im Render-Pfad.
   * Falls n√∂tig: Platzhalter rendern und sp√§ter im Client aktualisieren.

   ```jsx
   // Uhrzeit nur clientseitig aktualisieren
   import { useEffect, useState } from "react";

   export function Time() {
     const [time, setTime] = useState("‚Äî"); // stabil auf Server & initialem Client-Render
     useEffect(() => {
       setTime(new Date().toLocaleTimeString());
     }, []);
     return <span>{time}</span>;
   }
   ```

   ([MDN Web Docs][2])

2. **SSR-sichere IDs verwenden: `useId()`**

   * Generiert **konsistente** IDs auf Server und Client.

   ```jsx
   import { useId } from "react";
   export function Field() {
     const id = useId();
     return (
       <>
         <label htmlFor={id}>Name</label>
         <input id={id} />
       </>
     );
   }
   ```

   ([react.dev][3])

3. **Hydrieren, nicht neu mounten**

   * Im Client **`hydrateRoot`** statt `createRoot` nutzen.

   ```jsx
   import { hydrateRoot } from "react-dom/client";
   import App from "./App.jsx";
   hydrateRoot(document.getElementById("root"), <App />);
   ```

   ([react.dev][1])

4. **Browser-API-Zugriffe verschieben**

   * Zugriff auf `window`/`document` nur in Effekten:

   ```jsx
   import { useEffect, useState } from "react";
   export function WidthInfo() {
     const [w, setW] = useState(null);
     useEffect(() => setW(window.innerWidth), []);
     return <p>Breite: {w ?? "‚Äî"}</p>;
   }
   ```

   ([MDN Web Docs][2])

5. **Bekannte, bewusst unterschiedliche Inhalte d√§mpfen**

   * F√ºr seltene Sonderf√§lle: `suppressHydrationWarning` **sparsam** einsetzen.

   ```jsx
   <span suppressHydrationWarning>{/* server: "‚Äî", client: "12:34" */}</span>
   ```

   > Escape-Hatch, nur eine Ebene tief wirksam. ([legacy.reactjs.org][4])

6. **Suspense gezielt nutzen**

   * Datenabh√§ngige UI in **Suspense-Boundaries** kapseln; React hydriert priorisiert entlang der Interaktionspfade.

   ```jsx
   import { Suspense } from "react";
   <Suspense fallback={<p>L√§dt‚Ä¶</p>}>
     <Comments /> 
   </Suspense>
   ```

   ([react.dev][1])

---

#### **Debug-Checkliste**

* **Warnung lesen**: Welche Stelle mismatched?
* **Server vs. Client-Markup vergleichen** (View Source vs. DevTools Elements).
* **Zeit/Zufall/Locale** im Renderpfad? ‚Üí in `useEffect`.
* **IDs stabil?** ‚Üí `useId()`.
* **Start-API korrekt?** ‚Üí `hydrateRoot` verwenden. ([react.dev][1])

---

### **Zusammenfassung**

* Hydration-Fehler entstehen, wenn **Initial-HTML (Server)** ‚â† **erster Client-Render** ist.
* L√∂sung: deterministisch rendern, Browser-APIs in Effekte verlagern, **`useId()`**, **`hydrateRoot`**, im Ausnahmefall `suppressHydrationWarning`.
* SSR korrekt einbinden und bei dynamischen Teilen mit **Effekten/Suspense** arbeiten.

**Quellen:**

* React ‚Äì **`hydrateRoot`**: react.dev/reference/react-dom/client/hydrateRoot ([react.dev][1])
* React ‚Äì **`useId`**: react.dev/reference/react/useId ([react.dev][3])
* React ‚Äì **`createRoot` (Hinweis zu SSR)**: react.dev/reference/react-dom/client/createRoot ([react.dev][5])
* React (Legacy) ‚Äì **`suppressHydrationWarning`**: legacy.reactjs.org/docs/dom-elements.html ([legacy.reactjs.org][4])
* MDN ‚Äì **SSR (Glossar)**: developer.mozilla.org ¬ª Glossary ¬ª SSR ([MDN Web Docs][2])

[1]: https://react.dev/reference/react-dom/client/hydrateRoot?utm_source=chatgpt.com "hydrateRoot"
[2]: https://developer.mozilla.org/en-US/docs/Glossary/SSR?utm_source=chatgpt.com "Server-side rendering (SSR) - Glossary - MDN"
[3]: https://react.dev/reference/react/useId?utm_source=chatgpt.com "useId"
[4]: https://legacy.reactjs.org/docs/dom-elements.html?utm_source=chatgpt.com "DOM Elements"
[5]: https://react.dev/reference/react-dom/client/createRoot?utm_source=chatgpt.com "createRoot"

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

136. ### <a name="136"></a> Was bedeutet Virtualisierung (z. B. mit react-window)?

### **Virtualisierung in React (z. B. mit `react-window`)**

#### **Definition**

* **Virtualisierung** bedeutet, dass bei langen Listen oder Tabellen **nur die aktuell sichtbaren Elemente** im DOM gerendert werden.
* Unsichtbare Elemente werden nicht gerendert ‚Üí **deutlich bessere Performance** bei gro√üen Datenmengen.
* Typische Libraries: **`react-window`**, **`react-virtualized`**.

---

#### **Problem ohne Virtualisierung**

* 10 000 Listeneintr√§ge ‚Üí alle werden ins DOM geschrieben.
* Folgen: langsamer Render, hoher Speicherverbrauch, Scroll-Ruckler.

---

#### **L√∂sung mit Virtualisierung**

* Nur die **sichtbaren Elemente + kleiner Buffer** werden gerendert.
* Beim Scrollen rendert React die **n√§chsten Elemente nach**, alte verschwinden wieder.

---

#### **Beispiel mit `react-window`**

```jsx
import { FixedSizeList as List } from "react-window";

const Row = ({ index, style }) => (
  <div style={style}>Eintrag #{index}</div>
);

export default function App() {
  return (
    <List
      height={200}     // sichtbare H√∂he (px)
      itemCount={1000} // Anzahl Elemente
      itemSize={35}    // H√∂he pro Element
      width={300}      // Breite
    >
      {Row}
    </List>
  );
}
```

üëâ Obwohl `itemCount={1000}`, werden nur so viele Items gerendert, wie in `height / itemSize` passen (z. B. 200/35 ‚âà 6 Items).

---

#### **Zus√§tzliche Features**

* **DynamicSizeList** ‚Üí Elemente mit variabler H√∂he.
* **Windowing in Tabellen** (z. B. `react-virtualized`).
* **Infinite Loading** (Daten beim Scroll nachladen).

---

### **Zusammenfassung**

* Virtualisierung = **Rendern nur sichtbarer UI-Elemente** statt ganzer Listen/Tabellen.
* Vorteil: **Performance**, weniger DOM-Nodes, fl√ºssiges Scrolling.
* `react-window` ist eine schlanke Library daf√ºr, `react-virtualized` bietet mehr Features.

üìñ Quellen:

* [react-window GitHub](https://github.com/bvaughn/react-window)
* [React Docs ‚Äì Rendering Lists](https://react.dev/learn/rendering-lists)
* [MDN ‚Äì Virtualization (Glossary)](https://developer.mozilla.org/ru/docs/Glossary/Virtualization)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

137. ### <a name="137"></a> Wie verhindert man unn√∂tige Re-Renders?

### **Strategien gegen unn√∂tige Re-Renders in React**

#### **1) Komponenten memoisieren**

* **`React.memo`** verhindert Re-Render, wenn sich Props **shallow** nicht √§ndern.
* F√ºr teure Berechnungen: zus√§tzlich **`useMemo`**.

```jsx
// Child.jsx
import React from "react";
export const Child = React.memo(function Child({ value }) {
  console.log("render child");
  return <div>{value}</div>;
});
```

üìñ React.memo: [react.dev/reference/react/memo](https://react.dev/reference/react/memo)

---

#### **2) Stabile Callback-Referenzen**

* **Inline-Funktionen** erzeugen bei jedem Render neue Referenzen ‚Üí Child rendert neu.
* **`useCallback`** macht Handler-Referenzen stabil.

```jsx
// Parent.jsx
import { useState, useCallback } from "react";
import { Child } from "./Child.jsx";

export default function Parent() {
  const [count, setCount] = useState(0);
  const inc = useCallback(() => setCount(c => c + 1), []); // stabile Referenz
  return (
    <>
      <button onClick={inc}>+1</button>
      <Child value={count} />
    </>
  );
}
```

üìñ useCallback: [react.dev/reference/react/useCallback](https://react.dev/reference/react/useCallback)

---

#### **3) Teure Berechnungen memoisieren**

* Nur neu berechnen, wenn **Dependencies** sich √§ndern.

```jsx
import { useMemo } from "react";
function List({ items, q }) {
  const filtered = useMemo(
    () => items.filter(i => i.includes(q)),
    [items, q]
  );
  return <ul>{filtered.map(i => <li key={i}>{i}</li>)}</ul>;
}
```

üìñ useMemo: [react.dev/reference/react/useMemo](https://react.dev/reference/react/useMemo)

---

#### **4) State nahe am Nutzer der Daten platzieren**

* **State colocation**: Globaler/zu hoher State bewirkt Re-Renders in zu vielen Komponenten.
* Hebe State **nur so weit hoch**, wie n√∂tig; nutze **Context sparsam**.
  üìñ State & Skalierung: [react.dev/learn/scaling-up-with-reducer-and-context](https://react.dev/learn/scaling-up-with-reducer-and-context)

---

#### **5) Context korrekt verwenden**

* **Context-Value stabil halten** (nicht bei jedem Render neues Objekt/Funktion).

```jsx
import { createContext, useMemo } from "react";
export const AuthCtx = createContext(null);

function AuthProvider({ user, login, logout, children }) {
  const value = useMemo(() => ({ user, login, logout }), [user, login, logout]);
  return <AuthCtx.Provider value={value}>{children}</AuthCtx.Provider>;
}
```

üìñ Context: [react.dev/reference/react/Context](https://react.dev/reference/react/Context)

---

#### **6) Listen: stabile Keys & Item-Komponenten memoisieren**

* **Stabile `key`** (keine Indizes bei ver√§nderlichen Listen).
* Item als **`React.memo`** + Props minimal halten.

```jsx
const Row = React.memo(function Row({ item }) {
  return <li>{item.name}</li>;
});
function List({ items }) {
  return <ul>{items.map(it => <Row key={it.id} item={it} />)}</ul>;
}
```

üìñ Listen & Keys: [react.dev/learn/rendering-lists](https://react.dev/learn/rendering-lists)

---

#### **7) Redux/State-Manager optimieren**

* **`useSelector`**: nur **kleine Slices** selektieren; optional `shallowEqual`.
* **Reselect `createSelector`**: abgeleitete Daten **memoisieren**.

```js
// selector.js
import { createSelector } from "reselect";
const selectTodos = s => s.todos;
const selectFilter = s => s.filter;
export const selectVisible = createSelector(
  [selectTodos, selectFilter],
  (todos, f) => (f === "done" ? todos.filter(t => t.done) : todos)
);
```

```jsx
import { useSelector } from "react-redux";
import { selectVisible } from "./selector.js";
const todos = useSelector(selectVisible);
```

üìñ Reselect: [redux.js.org/usage/deriving-data-selectors](https://redux.js.org/usage/deriving-data-selectors) ‚Ä¢ React-Redux Hooks: [react-redux.js.org/api/hooks](https://react-redux.js.org/api/hooks)

---

#### **8) Vermeide unn√∂tige Re-Renders durch Prop-Identit√§t**

* **Objekte/Arrays** nicht ad hoc erstellen ‚Üí mit `useMemo` stabilisieren.

```jsx
const options = useMemo(() => ({ dense: true }), []); // statt {} inline
<Child options={options} />
```

---

#### **9) Virtualisierung f√ºr gro√üe Listen**

* Render nur sichtbarer Items (z. B. **`react-window`**) ‚Üí weniger DOM & weniger Updates.
  üìñ react-window: [github.com/bvaughn/react-window](https://github.com/bvaughn/react-window)

---

#### **10) Sonstiges**

* **Keine unn√∂tigen Re-Renders forcieren**: State nur setzen, wenn sich Werte wirklich √§ndern.
* **Event-Handler entkoppeln** (nicht in Props neue Lambdas, wenn vermeidbar).
* **Production-Build** nutzen (Entwicklungsmodus rendert strenger).
  üìñ Performance-Optimierung: [react.dev/learn/escape-hatches#optimizing-performance](https://react.dev/learn/escape-hatches#optimizing-performance)

---

### **Zusammenfassung**

* **Memoisierung** (React.memo, useMemo, useCallback) + **stabile Referenzen**.
* **State colocation** & **sparsame Context-Nutzung**.
* **Reselect** bei globalem State, **stabile Keys** in Listen, **Virtualisierung** f√ºr gro√üe Datenmengen.
* Nur notwendige Props/States √§ndern; Produktionsbuild verwenden.

**Quellen:**

* React Docs: `memo`, `useMemo`, `useCallback`, Context, Listen/Keys, Performance ‚Äì [react.dev](https://react.dev/)
* Reselect/Selectoren ‚Äì [redux.js.org](https://redux.js.org/usage/deriving-data-selectors)
* MDN (RU) ‚Äì –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –≤–µ–±-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π: [developer.mozilla.org/ru/](https://developer.mozilla.org/ru/)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

138. ### <a name="138"></a> Was ist React Transition Group?

### **React Transition Group**

#### **Definition**

* **React Transition Group** ist eine kleine Zusatzbibliothek f√ºr React, die **Animationen und Transitionen beim Mounten, Unmounten oder √Ñndern von Komponenten** erm√∂glicht.
* Sie selbst enth√§lt **keine Animations-Implementierung**, sondern stellt nur **Lifecycle-Hooks und Klassen** bereit, um CSS-Transitions oder JS-Animationen auszuf√ºhren.

---

#### **Kernkomponenten**

1. **`<Transition>`**

   * Kontrolliert Mount/Unmount einer einzelnen Komponente.
   * Zust√§nde: `entering`, `entered`, `exiting`, `exited`.

2. **`<CSSTransition>`**

   * Wie `<Transition>`, aber mit automatischem Hinzuf√ºgen/Entfernen von **CSS-Klassen**.
   * Erwartet vordefinierte CSS-Klassen wie `.fade-enter`, `.fade-enter-active`.

3. **`<TransitionGroup>`**

   * Container f√ºr eine **Liste von Transition-Komponenten** (z. B. animierte Listen-Elemente).

---

#### **Beispiel mit `<CSSTransition>`**

```jsx
// App.jsx
import { CSSTransition } from "react-transition-group";
import { useState } from "react";
import "./styles.css";

export default function App() {
  const [visible, setVisible] = useState(false);

  return (
    <div>
      <button onClick={() => setVisible(v => !v)}>Toggle</button>
      <CSSTransition
        in={visible}
        timeout={300}
        classNames="fade"
        unmountOnExit
      >
        <div className="box">Hallo!</div>
      </CSSTransition>
    </div>
  );
}
```

**CSS (`styles.css`)**

```css
.fade-enter {
  opacity: 0;
}
.fade-enter-active {
  opacity: 1;
  transition: opacity 300ms;
}
.fade-exit {
  opacity: 1;
}
.fade-exit-active {
  opacity: 0;
  transition: opacity 300ms;
}
```

üëâ Wenn `visible` wechselt, wird die Box mit sanftem Fade-In/Fade-Out animiert.

---

#### **Mit `<TransitionGroup>` (Listenanimation)**

```jsx
import { TransitionGroup, CSSTransition } from "react-transition-group";

function TodoList({ items }) {
  return (
    <TransitionGroup component="ul">
      {items.map(item => (
        <CSSTransition key={item.id} timeout={300} classNames="fade">
          <li>{item.text}</li>
        </CSSTransition>
      ))}
    </TransitionGroup>
  );
}
```

üëâ Elemente erscheinen/verschwinden mit Transitionen, wenn Items zur Liste hinzugef√ºgt oder entfernt werden.

---

### **Zusammenfassung**

* **React Transition Group** = Bibliothek f√ºr **Animations-Lifecycle beim Mount/Unmount**.
* Hauptkomponenten: **`Transition`**, **`CSSTransition`**, **`TransitionGroup`**.
* Nutzt CSS-Klassen oder JS-Hooks f√ºr flexible Animationen.
* Besonders n√ºtzlich f√ºr **Einstiegs-/Ausstiegsanimationen** von Komponenten und Listen.

üìñ Quellen:

* [React Transition Group ‚Äì GitHub](https://github.com/reactjs/react-transition-group)
* [CSSTransition API](https://reactcommunity.org/react-transition-group/css-transition)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

139. ### <a name="139"></a> Was ist React Strict Mode und welche Vorteile bietet er?

### **React Strict Mode**

#### **Definition**

* **`<React.StrictMode>`** ist eine Wrapper-Komponente von React, die beim Entwickeln zus√§tzliche **Checks und Warnungen** aktiviert.
* Er hat **keine Auswirkung auf das Produktions-Build**, sondern nur in **Development Mode**.

---

#### **Wichtige Funktionen**

1. **Doppelte Ausf√ºhrung bestimmter Methoden**

   * Lifecycle-Methoden, `useEffect`-Cleanup + Initial-Run werden **zweimal aufgerufen**, um **Nebenwirkungen sichtbar** zu machen.
   * Ziel: Probleme fr√ºhzeitig erkennen.

2. **Warnungen f√ºr unsichere Patterns**

   * Veraltete Lifecycle-Methoden (z. B. `componentWillMount`).
   * Legacy-APIs, die in zuk√ºnftigen Versionen entfernt werden.

3. **Highlighting von Nebenwirkungen**

   * Zeigt an, wenn Code **nicht pure** ist (z. B. doppeltes Setzen von State im Render-Prozess).

4. **Vorbereitung auf zuk√ºnftige Features**

   * Hilft, Apps kompatibel mit **Concurrent Rendering** und anderen neuen React-Features zu halten.

---

#### **Beispiel**

```jsx
import React from "react";
import { createRoot } from "react-dom/client";
import App from "./App.jsx";

createRoot(document.getElementById("root")).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
```

üëâ Hierdurch laufen im Dev-Modus zus√§tzliche Checks, aber im Production-Build bleibt nur `<App />`.

---

#### **Vorteile**

* Fr√ºhzeitige Erkennung von **fehleranf√§lligen Code-Stellen**.
* Bereitet auf **zuk√ºnftige React-Versionen** vor.
* Verbessert **Code-Qualit√§t** durch Warnungen √ºber unsichere Patterns.

---

### **Zusammenfassung**

* **Strict Mode** = Entwicklungswerkzeug, aktiviert zus√§tzliche Checks & Warnungen.
* Hilft, **Nebenwirkungen, veraltete APIs und unsichere Patterns** zu erkennen.
* Hat **keinen Einfluss** auf Performance oder Verhalten in Produktion.

üìñ Quellen:

* [React Docs ‚Äì Strict Mode](https://react.dev/reference/react/StrictMode)
* [MDN ‚Äì Entwicklungsmodi](https://developer.mozilla.org/ru/docs/Learn/Tools_and_testing/Understanding_client-side_tools/Development_and_production)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

140. ### <a name="140"></a> Was ist Concurrent Mode und welche Probleme l√∂st er?

### **Concurrent Mode in React**

#### **Definition**

* **Concurrent Mode** (seit React 18: Teil von **Concurrent Rendering**) ist ein Rendering-Modus, der React erlaubt, **Rendering-Aufgaben zu unterbrechen, zu priorisieren und wieder aufzunehmen**, anstatt sie blockierend auszuf√ºhren.
* Dadurch bleibt die UI **responsiv**, auch wenn gro√üe Updates oder viele State-√Ñnderungen passieren.

---

#### **Probleme im alten (synchronen) Modus**

* Vor React 18: **Rendering war synchron und blockierend**.
* Wenn eine Komponente viel rendern musste, war die **UI eingefroren** ‚Üí Buttons reagierten erst nach Abschluss des Renderings.
* Keine M√∂glichkeit, Updates nach **Priorit√§t** (z. B. User-Eingaben vor Hintergrund-Rendering) zu behandeln.

---

#### **L√∂sungen durch Concurrent Mode**

1. **Interruptible Rendering**

   * Lange Render-Aufgaben k√∂nnen unterbrochen werden, um **wichtigere Tasks** (z. B. Eingabe des Users) sofort auszuf√ºhren.

2. **Priorisierung von Updates**

   * React entscheidet: User-Interaktionen ‚Üí hoch priorisiert, Hintergrund-Tasks ‚Üí niedriger.

3. **Start/Stop/Resume**

   * React kann Rendering **pausieren und sp√§ter fortsetzen**, ohne UI-Fehler.

4. **Bessere User Experience**

   * UI bleibt **reaktiv**, auch bei Daten-Fetching, komplexem State oder Animationen.

---

#### **Beispiel: Transition Updates (React 18)**

```jsx
import { useState, useTransition } from "react";

export default function Search() {
  const [query, setQuery] = useState("");
  const [list, setList] = useState([]);
  const [isPending, startTransition] = useTransition();

  function handleChange(e) {
    const q = e.target.value;
    setQuery(q);

    // teures Update ‚Üí als √úbergangs-Update markieren
    startTransition(() => {
      const results = Array(20000)
        .fill()
        .map((_, i) => q + i);
      setList(results);
    });
  }

  return (
    <>
      <input value={query} onChange={handleChange} />
      {isPending && <p>Loading‚Ä¶</p>}
      <ul>{list.map((item, i) => <li key={i}>{item}</li>)}</ul>
    </>
  );
}
```

üëâ Hier bleibt das **Input reaktiv**, auch wenn das Rendering der Liste viel Zeit kostet.

---

#### **Zusammenfassung**

* **Concurrent Mode = interruptibles, priorisiertes Rendering.**
* L√∂st Probleme von **blockierendem synchronem Rendering**.
* Vorteile: **bessere Performance, reaktive UI, User-Eingaben bleiben fl√ºssig**.
* Eingef√ºhrt in **React 18** (Features wie `useTransition`, `startTransition`).

üìñ Quellen:

* [React Docs ‚Äì Concurrent Rendering](https://react.dev/learn/synchronizing-with-effects#concurrent-rendering)
* [React Docs ‚Äì startTransition](https://react.dev/reference/react/startTransition)
* [MDN ‚Äì Rendering Performance](https://developer.mozilla.org/ru/docs/Web/Performance)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

141. ### <a name="141"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

142. ### <a name="142"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

143. ### <a name="143"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

144. ### <a name="144"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

145. ### <a name="145"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

146. ### <a name="146"></a> Was ist ein Service Worker?

### **Service Worker**

#### **Definition**

* Ein **Service Worker** ist ein spezielles **JavaScript-Skript**, das **zwischen Browser und Netzwerk** arbeitet.
* Er l√§uft **unabh√§ngig vom Hauptthread** (separat im Hintergrund) und kann **Netzwerkanfragen abfangen, cachen und Push-Events verarbeiten**.
* Wird h√§ufig f√ºr **Progressive Web Apps (PWA)** eingesetzt.

---

#### **Funktionen**

1. **Offline-Funktionalit√§t**

   * Anfragen k√∂nnen aus einem lokalen Cache beantwortet werden ‚Üí App funktioniert auch ohne Internet.

2. **Caching & Performance**

   * Ressourcen (HTML, CSS, JS, Bilder) werden zwischengespeichert ‚Üí schnellere Ladezeiten.

3. **Hintergrundprozesse**

   * Push Notifications, Background Sync, Updates im Hintergrund.

4. **Netzwerkkontrolle**

   * Kann Requests umleiten, Antworten modifizieren oder Netzwerkstrategien (z. B. ‚ÄûCache First‚Äú) umsetzen.

---

#### **Lebenszyklus**

1. **Registration** ‚Üí Service Worker wird im Browser registriert.
2. **Installation** ‚Üí wird installiert (Assets in Cache legen).
3. **Activation** ‚Üí √ºbernimmt Kontrolle √ºber Seiten, alte SW-Versionen werden ersetzt.
4. **Event Handling** ‚Üí h√∂rt auf Events (`fetch`, `push`, `sync`).

---

#### **Beispiel: Service Worker registrieren**

```js
// index.js
if ("serviceWorker" in navigator) {
  navigator.serviceWorker.register("/sw.js").then(() => {
    console.log("Service Worker registriert!");
  });
}
```

**sw.js**

```js
self.addEventListener("install", (event) => {
  event.waitUntil(
    caches.open("v1").then((cache) =>
      cache.addAll(["/", "/index.html", "/styles.css", "/app.js"])
    )
  );
});

self.addEventListener("fetch", (event) => {
  event.respondWith(
    caches.match(event.request).then((response) => response || fetch(event.request))
  );
});
```

üëâ Ergebnis: Die App l√§dt im Offline-Modus aus dem Cache.

---

#### **Zusammenfassung**

* **Service Worker** = Hintergrundskript im Browser.
* Aufgaben: **Offline-Unterst√ºtzung, Caching, Push-Events, Performance**.
* Wichtiger Bestandteil von **PWAs**.

üìñ Quellen:

* [MDN ‚Äì Service Worker API](https://developer.mozilla.org/ru/docs/Web/API/Service_Worker_API)
* [Google Web.dev ‚Äì Service Workers](https://web.dev/learn/pwa/service-workers/)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

147. ### <a name="147"></a> Was ist react-helmet und wie hilft es beim SEO?

### **react-helmet**

#### **Definition**

* **react-helmet** ist eine React-Bibliothek, mit der man **Meta-Informationen im `<head>`** einer Seite dynamisch verwalten kann.
* Typische Beispiele: **Seitentitel (`<title>`), Meta-Tags (Description, Keywords), Open Graph (Social Media Preview), Canonical Links**.

---

#### **Problemstellung**

* In einer **SPA (Single Page Application)** gibt es meist nur eine einzige `index.html`.
* Standardm√§√üig ist `<head>` statisch, √§ndert sich also nicht bei Navigation.
* F√ºr **SEO** und **Social Media Previews** ist es aber wichtig, pro Seite individuelle Meta-Tags zu haben.

---

#### **L√∂sung mit react-helmet**

* Jede Komponente kann eigene Head-Tags definieren.
* Beim Rendern werden diese Tags in das `<head>`-Element der Seite eingef√ºgt oder ersetzt.

**Beispiel:**

```jsx
import { Helmet } from "react-helmet";

export default function About() {
  return (
    <>
      <Helmet>
        <title>√úber uns ‚Äì Meine App</title>
        <meta name="description" content="Infos √ºber unser Unternehmen und Team" />
        <meta property="og:title" content="√úber uns" />
        <meta property="og:type" content="website" />
      </Helmet>
      <h1>√úber uns</h1>
    </>
  );
}
```

üëâ Wenn der User `/about` besucht, wird der Seitentitel und die Description angepasst.

---

#### **SEO-Vorteile**

1. **Einzigartige Titel und Descriptions pro Route** ‚Üí bessere Indexierung durch Suchmaschinen.
2. **Open Graph / Twitter Cards** ‚Üí optimierte Darstellung beim Teilen in sozialen Netzwerken.
3. **Canonical URLs** ‚Üí Vermeidung von Duplicate Content.
4. **Dynamisches Head-Management** ‚Üí wichtig bei SSR (z. B. Next.js oder React mit Server Rendering).

---

### **Zusammenfassung**

* **react-helmet** = Library zum dynamischen Verwalten von `<head>`-Meta-Tags in React-Apps.
* Hilft beim **SEO** durch einzigartige Titel, Meta-Descriptions, OG-Tags pro Seite.
* Besonders wichtig bei **SPAs mit Routing und SSR**.

üìñ Quellen:

* [react-helmet GitHub](https://github.com/nfl/react-helmet)
* [MDN ‚Äì Meta-Tags](https://developer.mozilla.org/ru/docs/Learn/HTML/Introduction_to_HTML/The_head_metadata_in_HTML)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

148. ### <a name="148"></a> Wie funktioniert Lazy Loading mit dynamic import()?

### **Lazy Loading mit `dynamic import()` in React/JavaScript**

#### **Definition**

* `import()` ist ein **dynamischer ES2020-Operator**, der ein Modul **zur Laufzeit** l√§dt (asynchron).
* Er gibt ein **Promise** zur√ºck, das das Modul-Objekt enth√§lt.
* Vorteil: Code wird **nur geladen, wenn er wirklich ben√∂tigt wird** ‚Üí kleinere initiale Bundle-Gr√∂√üe, schnelleres Laden.

---

#### **1) Basis in JavaScript**

```js
// normales Import (statisch, alles im Haupt-Bundle):
import { add } from "./math.js";

// dynamic import (lazy, erzeugt eigenes Bundle):
button.addEventListener("click", async () => {
  const { add } = await import("./math.js");
  console.log(add(2, 3));
});
```

üëâ `math.js` wird erst geladen, wenn der Button geklickt wird.

---

#### **2) Lazy Loading in React mit `React.lazy`**

* React nutzt `import()` unter der Haube f√ºr **Code-Splitting von Komponenten**.

```jsx
import React, { Suspense, lazy } from "react";

// Lazy Component
const About = lazy(() => import("./About.jsx"));

export default function App() {
  return (
    <div>
      <h1>Meine App</h1>
      <Suspense fallback={<p>L√§dt‚Ä¶</p>}>
        <About /> {/* wird erst beim Rendern geladen */}
      </Suspense>
    </div>
  );
}
```

üëâ `About.jsx` landet in einem **separaten Chunk** und wird erst geladen, wenn die Route/Komponente gebraucht wird.

---

#### **3) Lazy Loading bei Routing**

```jsx
import { BrowserRouter, Routes, Route } from "react-router-dom";
import { lazy, Suspense } from "react";

const Home = lazy(() => import("./Home.jsx"));
const Profile = lazy(() => import("./Profile.jsx"));

export default function App() {
  return (
    <BrowserRouter>
      <Suspense fallback={<h2>Seite l√§dt‚Ä¶</h2>}>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/profile" element={<Profile />} />
        </Routes>
      </Suspense>
    </BrowserRouter>
  );
}
```

üëâ Nur die besuchte Route wird geladen (z. B. `/profile` l√§dt `Profile.jsx`).

---

#### **4) Dynamische Bedingungen**

Man kann auch Module abh√§ngig von Bedingungen laden:

```js
async function loadLocale(lang) {
  if (lang === "de") {
    return import("./i18n/de.js");
  } else {
    return import("./i18n/en.js");
  }
}
```

---

### **Zusammenfassung**

* **`import()`** = dynamischer ES2020-Operator f√ºr Lazy Loading von Modulen.
* React nutzt es mit **`React.lazy` + `Suspense`** f√ºr **Code-Splitting und Lazy Loading von Komponenten**.
* Vorteil: kleinere Bundles, schnelleres Initial-Loading, bessere Performance.

üìñ Quellen:

* [React Docs ‚Äì React.lazy](https://react.dev/reference/react/lazy)
* [MDN ‚Äì import()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/import)
* [Webpack ‚Äì Code Splitting](https://webpack.js.org/guides/code-splitting/)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

149. ### <a name="149"></a> Was ist ein Finite-State Machine (FSM), z. B. mit XState?

### **Finite-State Machine (FSM)**

#### **Definition**

* Eine **Finite-State Machine (endliche Zustandsmaschine)** ist ein Modell, das eine Logik durch **eine endliche Anzahl von Zust√§nden** beschreibt.
* Ein System kann sich **immer nur in genau einem Zustand befinden** und durch **Events/Transitions** in andere Zust√§nde wechseln.
* Beispiel: Ampel ‚Üí Zust√§nde: `Rot`, `Gr√ºn`, `Gelb`; Events: `TIMER abgelaufen`.

---

#### **Hauptprinzipien**

1. **States (Zust√§nde)** ‚Äì definieren, in welchem ‚ÄûModus‚Äú sich das System befindet.
2. **Events** ‚Äì externe Eingaben, die einen Zustandswechsel ausl√∂sen.
3. **Transitions** ‚Äì beschreiben, wie ein State auf ein Event reagiert.
4. **Initial State** ‚Äì Startzustand der Maschine.

---

#### **Beispiel mit XState**

XState ist eine Library zur Implementierung von FSMs (und Statecharts) in JavaScript/React.

```js
import { createMachine, interpret } from "xstate";

// 1. State Machine definieren
const toggleMachine = createMachine({
  id: "toggle",
  initial: "inactive",
  states: {
    inactive: {
      on: { TOGGLE: "active" }
    },
    active: {
      on: { TOGGLE: "inactive" }
    }
  }
});

// 2. Interpreter starten
const service = interpret(toggleMachine).start();

console.log(service.state.value); // "inactive"
service.send("TOGGLE");
console.log(service.state.value); // "active"
```

üëâ Die Maschine hat zwei States (`inactive`, `active`) und ein Event `TOGGLE`.

---

#### **FSM in React mit XState**

```jsx
import { useMachine } from "@xstate/react";
import { createMachine } from "xstate";

const lightMachine = createMachine({
  id: "light",
  initial: "green",
  states: {
    green: { on: { NEXT: "yellow" } },
    yellow: { on: { NEXT: "red" } },
    red: { on: { NEXT: "green" } }
  }
});

export function TrafficLight() {
  const [state, send] = useMachine(lightMachine);

  return (
    <div>
      <h1>Aktuell: {state.value}</h1>
      <button onClick={() => send("NEXT")}>Weiter</button>
    </div>
  );
}
```

üëâ `state.value` zeigt den aktuellen Zustand (`green`, `yellow`, `red`), `send("NEXT")` wechselt den Zustand.

---

#### **Vorteile**

* **Vorhersagbares Verhalten**: keine unkontrollierten √úberg√§nge.
* **Visualisierung m√∂glich** (XState bietet Diagramme).
* **Weniger Bugs**: Zust√§nde und √úberg√§nge sind explizit.
* **Asynchronit√§t & komplexe Logik** lassen sich klar modellieren.

---

### **Zusammenfassung**

* **FSM** = System mit endlich vielen Zust√§nden, immer in genau einem Zustand, Wechsel √ºber Events.
* **XState**: JS-Library, um FSMs/Statecharts in Code und React-Komponenten abzubilden.
* Vorteil: **klare Struktur, bessere Wartbarkeit, weniger unvorhersehbare Fehler**.

üìñ Quellen:

* [XState Docs](https://xstate.js.org/docs/)
* [MDN ‚Äì Zustandsmaschine (FSM)](https://developer.mozilla.org/ru/docs/Glossary/State_machine)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

150. ### <a name="150"></a> Wie kann man ein Formular mit Formik und Yup erstellen und validieren?

### Formular mit **Formik** & **Yup** erstellen und validieren

#### 1) Installation (kurz)

```bash
npm i formik yup
```

---

#### 2) Schema-Validierung mit **Yup**

```js
// validation.js
import * as Yup from "yup";

export const signupSchema = Yup.object({
  name: Yup.string().min(2, "Mind. 2 Zeichen").required("Pflichtfeld"),
  email: Yup.string().email("Ung√ºltige E-Mail").required("Pflichtfeld"),
  password: Yup.string().min(8, "Mind. 8 Zeichen").required("Pflichtfeld"),
  terms: Yup.bool().oneOf([true], "Bitte AGB akzeptieren"),
});
```

---

#### 3) Formular mit **Formik-Komponente**

```jsx
// SignupForm.jsx
import { Formik, Form, Field, ErrorMessage } from "formik";
import { signupSchema } from "./validation.js";

export default function SignupForm() {
  return (
    <Formik
      initialValues={{ name: "", email: "", password: "", terms: false }}
      validationSchema={signupSchema}
      onSubmit={async (values, { setSubmitting, resetForm }) => {
        try {
          // API-Call simulieren
          await new Promise(r => setTimeout(r, 600));
          console.log("Submit:", values);
          resetForm();
        } finally {
          setSubmitting(false);
        }
      }}
      validateOnBlur
      validateOnChange
    >
      {({ isSubmitting, isValid, dirty }) => (
        <Form noValidate>
          <label htmlFor="name">Name</label>
          <Field id="name" name="name" />
          <ErrorMessage name="name" component="div" />

          <label htmlFor="email">E-Mail</label>
          <Field id="email" name="email" type="email" />
          <ErrorMessage name="email" component="div" />

          <label htmlFor="password">Passwort</label>
          <Field id="password" name="password" type="password" />
          <ErrorMessage name="password" component="div" />

          <label>
            <Field type="checkbox" name="terms" /> AGB akzeptieren
          </label>
          <ErrorMessage name="terms" component="div" />

          <button type="submit" disabled={isSubmitting || !dirty || !isValid}>
            {isSubmitting ? "Sende‚Ä¶" : "Registrieren"}
          </button>
        </Form>
      )}
    </Formik>
  );
}
```

---

#### 4) Alternative: **`useFormik`** (mehr Kontrolle)

```jsx
// LoginForm.jsx
import { useFormik } from "formik";
import * as Yup from "yup";

const schema = Yup.object({
  email: Yup.string().email("Ung√ºltig").required("Pflicht"),
  password: Yup.string().min(8, "‚â•8").required("Pflicht"),
});

export function LoginForm() {
  const formik = useFormik({
    initialValues: { email: "", password: "" },
    validationSchema: schema,
    onSubmit: async (values, helpers) => {
      // Beispiel: Fehler vom Server mappen
      try {
        // await api.login(values)
      } catch (e) {
        helpers.setFieldError("email", "E-Mail unbekannt");
      } finally {
        helpers.setSubmitting(false);
      }
    },
  });

  const { handleSubmit, handleChange, handleBlur, values, errors, touched, isSubmitting } = formik;

  return (
    <form noValidate onSubmit={handleSubmit}>
      <input
        name="email"
        value={values.email}
        onChange={handleChange}
        onBlur={handleBlur}
        placeholder="E-Mail"
      />
      {touched.email && errors.email && <div>{errors.email}</div>}

      <input
        type="password"
        name="password"
        value={values.password}
        onChange={handleChange}
        onBlur={handleBlur}
        placeholder="Passwort"
      />
      {touched.password && errors.password && <div>{errors.password}</div>}

      <button type="submit" disabled={isSubmitting}>Login</button>
    </form>
  );
}
```

---

#### 5) Tipps / Patterns (kurz)

* **Abh√§ngige Felder**: mit `Yup.when()` Bedingungen bauen.
* **Async-Serverfehler**: `setFieldError`, `setErrors`, `setStatus`.
* **Performance**: `validateOnChange` deaktivieren oder Debounce; `<Field>` statt selbstverwaltetem Input.
* **HTML5 + ARIA**: `noValidate` nutzen, eigene Fehlermeldungen anzeigen; Labels/`aria-*` setzen.

---

### Zusammenfassung

* **Formik** verwaltet Formular-State, Touched, Submit und Fehlermeldungen;
* **Yup** liefert das deklarative Validierungs-Schema;
* Zusammenspiel: `validationSchema` + `Formik` (oder `useFormik`) ‚Üí saubere, skalierbare Formulare mit synchroner/async Validierung.

**Quellen / Weiterlesen**

* Formik Docs ‚Äì Basics & API: [https://formik.org/docs/overview](https://formik.org/docs/overview)
* Yup Docs ‚Äì API & Schema: [https://github.com/jquense/yup](https://github.com/jquense/yup)
* React Docs ‚Äì Formulare: [https://react.dev/learn/forms](https://react.dev/learn/forms)
* MDN (RU) ‚Äì –§–æ—Ä–º—ã –∏ –≤–∞–ª–∏–¥–∞—Ü–∏—è: [https://developer.mozilla.org/ru/docs/Learn/Forms](https://developer.mozilla.org/ru/docs/Learn/Forms)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

151. ### <a name="151"></a> Wie konfiguriert man ESLint und Prettier in einem React-Projekt?

### ESLint + Prettier in einem React-Projekt (Vite/CRA, JS & TS)

#### 1) Pakete installieren

```bash
# JavaScript
npm i -D eslint prettier eslint-config-prettier eslint-plugin-prettier \
eslint-plugin-react eslint-plugin-react-hooks eslint-plugin-jsx-a11y

# TypeScript (optional)
npm i -D @typescript-eslint/parser @typescript-eslint/eslint-plugin
```

---

#### 2) ESLint konfigurieren (`.eslintrc.json`)

**JavaScript**

```json
{
  "env": { "browser": true, "es2023": true },
  "extends": [
    "eslint:recommended",
    "plugin:react/recommended",
    "plugin:react-hooks/recommended",
    "plugin:jsx-a11y/recommended",
    "plugin:prettier/recommended"  // schaltet Format-Regeln ab + meldet Prettier-Diffs
  ],
  "parserOptions": { "ecmaVersion": "latest", "sourceType": "module" },
  "settings": { "react": { "version": "detect" } },
  "rules": {
    "react/react-in-jsx-scope": "off"
  }
}
```

**TypeScript** (falls TS genutzt)

```json
{
  "env": { "browser": true, "es2023": true },
  "parser": "@typescript-eslint/parser",
  "extends": [
    "eslint:recommended",
    "plugin:react/recommended",
    "plugin:@typescript-eslint/recommended",
    "plugin:react-hooks/recommended",
    "plugin:jsx-a11y/recommended",
    "plugin:prettier/recommended"
  ],
  "parserOptions": { "ecmaVersion": "latest", "sourceType": "module" },
  "settings": { "react": { "version": "detect" } },
  "rules": {
    "react/react-in-jsx-scope": "off"
  }
}
```

> `plugin:prettier/recommended` umfasst `eslint-config-prettier` (deaktiviert kollidierende ESLint-Formatregeln) und meldet Prettier-Abweichungen als ESLint-Fehler.

---

#### 3) Prettier konfigurieren (`.prettierrc`)

```json
{
  "singleQuote": true,
  "semi": true,
  "trailingComma": "all",
  "printWidth": 100
}
```

**Ignorieren (optional)**
`.eslintignore`

```
dist/
node_modules/
```

`.prettierignore`

```
dist/
node_modules/
```

---

#### 4) N√ºtzliche NPM-Skripte (`package.json`)

```json
{
  "scripts": {
    "lint": "eslint \"src/**/*.{js,jsx,ts,tsx}\"",
    "lint:fix": "eslint \"src/**/*.{js,jsx,ts,tsx}\" --fix",
    "format": "prettier --check .",
    "format:write": "prettier --write ."
  }
}
```

---

#### 5) VS Code (optional, komfortabel) ‚Äì `.vscode/settings.json`

```json
{
  "editor.formatOnSave": true,
  "editor.defaultFormatter": "esbenp.prettier-vscode",
  "eslint.validate": ["javascript", "javascriptreact", "typescript", "typescriptreact"],
  "eslint.codeActionsOnSave.rules": { "source.fixAll.eslint": true }
}
```

---

#### 6) Beispiel: ESM-Import & React-Datei (wird von ESLint/Prettier gepr√ºft)

```jsx
// App.jsx
import { useState } from 'react';

export default function App() {
  const [count, setCount] = useState(0);
  return (
    <main>
      <h1>Hallo React</h1>
      <button onClick={() => setCount(c => c + 1)}>+1 ({count})</button>
    </main>
  );
}
```

---

### Zusammenfassung

* **ESLint** pr√ºft Codequalit√§t/Best Practices; **Prettier** formatiert.
* Konflikte vermeiden durch **`plugin:prettier/recommended`**.
* Skripte: `npm run lint`, `lint:fix`, `format`, `format:write`.
* F√ºr TS: `@typescript-eslint/parser` + `@typescript-eslint/eslint-plugin` erg√§nzen.

**Quellen / Weiterlesen**

* React Docs ‚Äì Editor/Tools & Hooks-Regeln: [https://react.dev/learn/editor-setup](https://react.dev/learn/editor-setup)
* MDN (RU) ‚Äì –ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –∫–∞—á–µ—Å—Ç–≤–∞ –∫–æ–¥–∞ / ESLint: [https://developer.mozilla.org/ru/docs/Learn/Tools_and_testing/Understanding_client-side_tools/Code_quality_tools](https://developer.mozilla.org/ru/docs/Learn/Tools_and_testing/Understanding_client-side_tools/Code_quality_tools)
* ESLint ‚Äì Getting Started: [https://eslint.org/docs/latest/use/getting-started](https://eslint.org/docs/latest/use/getting-started)
* Prettier ‚Äì Options & Integration: [https://prettier.io/docs/en/](https://prettier.io/docs/en/)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

152. ### <a name="152"></a> Wie funktioniert dynamic import() in React (Syntax, Anwendungsf√§lle)?

### **Dynamic `import()` in React**

#### **Definition**

* `import()` ist ein **dynamischer ES2020-Operator**, der Module **asynchron zur Laufzeit** l√§dt.
* R√ºckgabewert: ein **Promise**, das das Modul-Objekt liefert.
* Wird von Bundlern (Vite, Webpack) genutzt, um **Code-Splitting** automatisch zu erzeugen.

---

#### **1) Syntax (Basis in JavaScript)**

```js
// Statischer Import (alles im Hauptbundle)
import { add } from "./math.js";

// Dynamischer Import (Lazy Loading, eigener Chunk)
async function loadMath() {
  const { add } = await import("./math.js");
  console.log(add(2, 3));
}
```

üëâ `math.js` wird nur geladen, wenn `loadMath()` aufgerufen wird.

---

#### **2) In React mit `React.lazy`**

* Dynamischer Import wird f√ºr **Lazy Loading von Komponenten** genutzt.
* Funktioniert nur mit **Default Exports**.

```jsx
import { Suspense, lazy } from "react";

// Lazy Import
const About = lazy(() => import("./About.jsx"));

export default function App() {
  return (
    <Suspense fallback={<p>L√§dt‚Ä¶</p>}>
      <About />
    </Suspense>
  );
}
```

üëâ `About.jsx` wird in einem separaten Bundle geladen, nur wenn `<About />` gerendert wird.

---

#### **3) Routing mit Lazy Loading**

```jsx
import { BrowserRouter, Routes, Route } from "react-router-dom";
import { lazy, Suspense } from "react";

const Home = lazy(() => import("./Home.jsx"));
const Profile = lazy(() => import("./Profile.jsx"));

export default function App() {
  return (
    <BrowserRouter>
      <Suspense fallback={<h2>Seite l√§dt‚Ä¶</h2>}>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/profile" element={<Profile />} />
        </Routes>
      </Suspense>
    </BrowserRouter>
  );
}
```

üëâ Nur die Route, die aufgerufen wird, l√§dt ihre Komponente.

---

#### **4) Dynamisch abh√§ngige Imports**

Man kann `import()` auch mit Bedingungen nutzen, z. B. f√ºr i18n:

```js
async function loadLocale(lang) {
  if (lang === "de") {
    return import("./i18n/de.js");
  } else {
    return import("./i18n/en.js");
  }
}
```

---

#### **5) Anwendungsf√§lle**

* **Code-Splitting** (Teile der App erst laden, wenn n√∂tig).
* **Lazy Loading von Komponenten oder Routen**.
* **Feature Flags** (Features nur bei Bedarf laden).
* **Internationalisierung** (Sprachpakete dynamisch).
* **Gro√üe Libraries** (z. B. Charts, nur bei Nutzung laden).

---

### **Zusammenfassung**

* `import()` l√§dt Module **on-demand** und erzeugt durch Bundler eigene Chunks.
* In React wird es oft mit **`React.lazy` + `Suspense`** f√ºr **Lazy Loading von Komponenten** kombiniert.
* Typische Anwendungsf√§lle: **Routen, Feature-Splitting, Libraries, i18n**.

üìñ Quellen:

* [React Docs ‚Äì React.lazy](https://react.dev/reference/react/lazy)
* [MDN ‚Äì import()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/import)
* [Webpack ‚Äì Code Splitting](https://webpack.js.org/guides/code-splitting/)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

153. ### <a name="153"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

154. ### <a name="154"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

155. ### <a name="155"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

156. ### <a name="156"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

157. ### <a name="157"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

158. ### <a name="158"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

159. ### <a name="159"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

160. ### <a name="160"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

161. ### <a name="161"></a> Was ist der Unterschied zwischen interface und type in TypeScript?

### **Unterschied zwischen `interface` und `type` in TypeScript**

#### **1) Gemeinsamkeiten**

* Beide k√∂nnen **Strukturen von Objekten** beschreiben.
* Beide unterst√ºtzen **Vererbung** (extends / Intersection).

```ts
interface User {
  id: number;
  name: string;
}

type UserType = {
  id: number;
  name: string;
};
```

üëâ In vielen F√§llen sind `interface` und `type` austauschbar.

---

#### **2) Unterschiede**

**a) Erweiterbarkeit (Declaration Merging)**

* **`interface`** kann **mehrfach deklariert und zusammengef√ºhrt** werden.
* **`type`** ist **geschlossen** ‚Äì eine Deklaration pro Name.

```ts
// Interfaces k√∂nnen "gemergt" werden:
interface Person { name: string; }
interface Person { age: number; }

// Ergibt:
const p: Person = { name: "Sergii", age: 34 };
```

```ts
// Types k√∂nnen NICHT gemergt werden:
type Car = { brand: string };
// type Car = { year: number }; // ‚ùå Fehler: Duplicate identifier
```

---

**b) Erweiterung / Zusammensetzen**

* **Interface**: `extends` f√ºr Vererbung.
* **Type**: `&` (Intersection) f√ºr Kombination.

```ts
interface A { a: string; }
interface B extends A { b: number; }

type X = { x: string };
type Y = X & { y: number };
```

---

**c) Komplexere Typen**

* **`type`** kann auch **Union**, **Primitives**, **Mapped Types** usw. definieren.
* **`interface`** nur Objekte / Klassenstrukturen.

```ts
// Union nur mit type m√∂glich
type Status = "success" | "error" | "loading";
```

---

**d) Klassen**

* Interfaces eignen sich besonders, um **Klassenvertr√§ge** zu definieren.

```ts
interface Flyable {
  fly(): void;
}

class Bird implements Flyable {
  fly() { console.log("Fliegt"); }
}
```

---

#### **3) Empfehlung (Best Practices)**

* **`interface`** ‚Üí bevorzugt f√ºr **Objekt- und Klassen-APIs**, besonders wenn erweiterbar sein soll (Library/Public API).
* **`type`** ‚Üí f√ºr **Unions, Primitives, komplexe Konstrukte**, oder wenn Features wie **Mapped/Conditional Types** gebraucht werden.

---

### **Zusammenfassung**

* **Interface**: f√ºr **Objekt- und Klassenstrukturen**, unterst√ºtzt **Declaration Merging** und ist erweiterbar.
* **Type**: universeller, kann auch **Union, Primitives, Mapped Types** beschreiben, aber nicht mehrfach deklariert werden.
* **Faustregel**:

  * `interface` = API-Vertr√§ge, OOP-nah.
  * `type` = flexible Typ-Konstrukte.

üìñ Quellen:

* [TypeScript Docs ‚Äì Interfaces](https://www.typescriptlang.org/docs/handbook/interfaces.html)
* [TypeScript Docs ‚Äì Type Aliases](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-aliases)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

162. ### <a name="162"></a> Wie typisiert man Props und State in einer funktionalen Komponente?

### **Props & State in funktionalen React-Komponenten (TypeScript)**

#### **1) Props typisieren**

* Mit `type` oder `interface`.
* `children` i. d. R. als `React.ReactNode`.

```tsx
// Greeting.tsx
import { type ReactNode } from 'react';

type GreetingProps = {
  name: string;
  age?: number;                 // optional
  onHello?: (to: string) => void;
  children?: ReactNode;         // UI als Kind
};

export function Greeting({ name, age = 18, onHello, children }: GreetingProps) {
  return (
    <section>
      <h1>Hallo, {name} ({age})</h1>
      <button onClick={() => onHello?.(name)}>Sagen</button>
      {children}
    </section>
  );
}
```

> Hinweis: `React.FC` ist **nicht n√∂tig**; `children` explizit typisieren ist klarer.

---

#### **2) State typisieren mit `useState`**

* Meist **inferenz**; bei komplexen/nullable Typen **Generics** nutzen.

```tsx
import { useState } from 'react';

export function Counter() {
  const [count, setCount] = useState(0);                 // number wird inferiert
  const [tag, setTag] = useState<string | null>(null);   // expliziter Union-Typ
  const [user, setUser] = useState<{ id: string; name: string } | null>(null);

  return (
    <>
      <p>{count} ‚Äì {tag ?? '‚Äî'}</p>
      <button onClick={() => setCount(c => c + 1)}>+1</button>
      <button onClick={() => setTag('react')}>Set Tag</button>
      <button onClick={() => setUser({ id: '1', name: 'Sergii' })}>Login</button>
    </>
  );
}
```

---

#### **3) Ereignisse & Handler korrekt typisieren**

```tsx
import { type ChangeEvent, type FormEvent } from 'react';

type SearchProps = { onSubmit: (q: string) => void };

export function Search({ onSubmit }: SearchProps) {
  const [q, setQ] = useState('');

  function handleChange(e: ChangeEvent<HTMLInputElement>) {
    setQ(e.target.value);
  }
  function handleSubmit(e: FormEvent<HTMLFormElement>) {
    e.preventDefault();
    onSubmit(q);
  }

  return (
    <form onSubmit={handleSubmit}>
      <input value={q} onChange={handleChange} />
      <button type="submit">Suchen</button>
    </form>
  );
}
```

---

#### **4) Komplexerer State: `useReducer` (empfohlen bei Logik)**

```tsx
import { useReducer } from 'react';

type State = { value: number };
type Action = { type: 'inc' } | { type: 'add'; payload: number };

function reducer(state: State, action: Action): State {
  switch (action.type) {
    case 'inc':  return { value: state.value + 1 };
    case 'add':  return { value: state.value + action.payload };
  }
}

export function Calc() {
  const [state, dispatch] = useReducer(reducer, { value: 0 });
  return (
    <>
      <p>Wert: {state.value}</p>
      <button onClick={() => dispatch({ type: 'inc' })}>+1</button>
      <button onClick={() => dispatch({ type: 'add', payload: 5 })}>+5</button>
    </>
  );
}
```

---

#### **5) Generische Props (z. B. Listen)**

```tsx
type ListProps<T> = {
  items: T[];
  renderItem: (item: T) => React.ReactNode;
};

export function List<T>({ items, renderItem }: ListProps<T>) {
  return <ul>{items.map((it, i) => <li key={i}>{renderItem(it)}</li>)}</ul>;
}
```

---

### **Zusammenfassung**

* **Props**: mit `type`/`interface`; `children` als `React.ReactNode`.
* **State**: `useState` (Inferenz, bei Unions Generics), bei komplexer Logik **`useReducer`**.
* **Events**: spezifische DOM-Event-Typen (`ChangeEvent<HTMLInputElement>`, `FormEvent<HTMLFormElement>`).
* **Kein `React.FC` n√∂tig**; explizite Props sind klarer.

**Quellen / Weiterlesen**

* React Docs ‚Äì TypeScript & React: [https://react.dev/learn/typescript](https://react.dev/learn/typescript)
* React Docs ‚Äì Events & Formulare: [https://react.dev/learn/forms](https://react.dev/learn/forms)
* TypeScript Handbook ‚Äì Everyday Types & Functions: [https://www.typescriptlang.org/docs/handbook/2/everyday-types.html](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

163. ### <a name="163"></a> Wie nutzt man Generics in React mit TypeScript (z. B. f√ºr Listen)?

### **Generics in React mit TypeScript (f√ºr Listen & mehr)**

#### **1) Generische List-Komponente**

* `T` beschreibt den Item-Typ.
* `renderItem` gibt die Darstellung vor.
* `getKey` sorgt f√ºr stabile Keys.

```tsx
// List.tsx
import { type ReactNode } from 'react';

type ListProps<T> = {
  items: T[];
  renderItem: (item: T, index: number) => ReactNode;
  getKey: (item: T, index: number) => string | number;
};

export function List<T>({ items, renderItem, getKey }: ListProps<T>) {
  return (
    <ul>
      {items.map((it, i) => (
        <li key={getKey(it, i)}>{renderItem(it, i)}</li>
      ))}
    </ul>
  );
}
```

**Verwendung (Typinferenz):**

```tsx
// App.tsx
import { List } from './List';

type User = { id: string; name: string };

const users: User[] = [
  { id: 'u1', name: 'Sergii' },
  { id: 'u2', name: 'Alex' },
];

export default function App() {
  return (
    <List
      items={users}
      getKey={(u) => u.id}
      renderItem={(u) => <span>{u.name}</span>}
    />
  );
}
```

---

#### **2) Generische Select-Komponente (Constraint)**

* Mit `extends` sicherstellen, dass Items eine `id` besitzen.

```tsx
type WithId = { id: string | number };

type SelectProps<T extends WithId> = {
  items: T[];
  value: T['id'] | null;
  onChange: (id: T['id']) => void;
  renderLabel: (item: T) => string;
};

export function Select<T extends WithId>({
  items, value, onChange, renderLabel,
}: SelectProps<T>) {
  return (
    <select value={value ?? ''} onChange={(e) => onChange(e.target.value)}>
      <option value="" disabled>Bitte w√§hlen</option>
      {items.map((it) => (
        <option key={it.id} value={it.id}>
          {renderLabel(it)}
        </option>
      ))}
    </select>
  );
}
```

---

#### **3) Generischer Hook (`useAsync`)**

* R√ºckgabetyp h√§ngt vom Funktions-Resultat ab.

```tsx
import { useEffect, useState } from 'react';

type AsyncState<T> = { data: T | null; error: Error | null; loading: boolean };

export function useAsync<T>(fn: () => Promise<T>, deps: unknown[] = []) {
  const [state, setState] = useState<AsyncState<T>>({
    data: null, error: null, loading: true,
  });

  useEffect(() => {
    let cancelled = false;
    setState({ data: null, error: null, loading: true });
    fn()
      .then((data) => !cancelled && setState({ data, error: null, loading: false }))
      .catch((err: Error) => !cancelled && setState({ data: null, error: err, loading: false }));
    return () => { cancelled = true; };
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, deps);

  return state;
}
```

**Verwendung:**

```tsx
type Post = { id: number; title: string };

function Posts() {
  const { data, loading, error } = useAsync<Post[]>(() =>
    fetch('/api/posts').then((r) => r.json()),
  , []);
  if (loading) return <p>L√§dt‚Ä¶</p>;
  if (error) return <p>Fehler: {error.message}</p>;
  return (
    <List
      items={data ?? []}
      getKey={(p) => p.id}
      renderItem={(p) => <article>{p.title}</article>}
    />
  );
}
```

---

#### **4) Forwarding Refs mit Generics**

* Elementtyp generisch halten, z. B. `HTMLButtonElement`.

```tsx
import { forwardRef } from 'react';

type BtnProps<T extends HTMLElement = HTMLButtonElement> = {
  as?: 'button' | 'a';
} & React.ComponentPropsWithoutRef<'button'>;

export const Btn = forwardRef<HTMLButtonElement, BtnProps>(function Btn(
  { as = 'button', ...rest }, ref,
) {
  if (as === 'a') {
    // @ts-expect-error vereinfachtes Beispiel
    return <a {...rest} ref={ref} />;
  }
  return <button {...rest} ref={ref} />;
});
```

---

#### **5) Best Practices (kurz)**

* **Keine** `React.FC` f√ºr generische Komponenten verwenden (erschwert Generics & `defaultProps`/`children`).
* Typen **nahe am Einsatz** halten (Props/State) und **Constraints** (`extends`) nutzen.
* **Explizite Typargumente** nur, wenn Inferenz nicht ausreicht: `<List<User> ‚Ä¶ />`.

---

### **Zusammenfassung**

* Generics erm√∂glichen **wiederverwendbare, typsichere** Komponenten/Hooks.
* Kernmuster: `List<T>`, `Select<T extends WithId>`, `useAsync<T>`.
* Nutzen: bessere **Inferenz**, robuste **Constraints**, weniger **Casting**.

**Quellen / Weiterlesen**

* React + TypeScript (offizielle Hinweise): [https://react.dev/learn/typescript](https://react.dev/learn/typescript)
* TypeScript Generics (Handbook): [https://www.typescriptlang.org/docs/handbook/2/generics.html](https://www.typescriptlang.org/docs/handbook/2/generics.html)
* TS in React-Komponenten (Everyday Types/Functions): [https://www.typescriptlang.org/docs/handbook/2/everyday-types.html](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

164. ### <a name="164"></a> Wie typisiert man Events in React mit TypeScript (onChange, onClick, FormEvent, MouseEvent)?

### **Events in React mit TypeScript typisieren**

> React nutzt **Synthetic Events**. Die Typen liegen unter `React.*Event<HTMLElementType>`.

---

#### **1) `onChange` (Textfeld, Checkbox, Select)**

```tsx
import { useState, type ChangeEvent } from 'react';

export function ProfileForm() {
  const [name, setName] = useState('');
  const [newsletter, setNewsletter] = useState(false);

  // Variante A: inline mit Generics
  const handleName = (e: React.ChangeEvent<HTMLInputElement>) => {
    setName(e.currentTarget.value);
  };

  // Variante B: vordefinierter Alias
  const handleNewsletter = (e: ChangeEvent<HTMLInputElement>) => {
    setNewsletter(e.currentTarget.checked);
  };

  return (
    <form>
      <input value={name} onChange={handleName} />
      <label>
        <input type="checkbox" checked={newsletter} onChange={handleNewsletter} />
        Newsletter
      </label>

      <select onChange={(e: React.ChangeEvent<HTMLSelectElement>) =>
        console.log(e.currentTarget.value)
      }>
        <option value="de">DE</option>
        <option value="en">EN</option>
      </select>
    </form>
  );
}
```

---

#### **2) `onClick` (MouseEvent)**

```tsx
export function Buttons() {
  const onPrimaryClick = (e: React.MouseEvent<HTMLButtonElement>) => {
    e.preventDefault(); // erlaubt
    console.log('ClientX:', e.clientX);
  };
  return <button onClick={onPrimaryClick}>Klick</button>;
}
```

---

#### **3) Formular-Submit (`FormEvent`)**

```tsx
import { type FormEvent, useState } from 'react';

export function Login() {
  const [email, setEmail] = useState('');
  const onSubmit = (e: FormEvent<HTMLFormElement>) => {
    e.preventDefault();            // verhindert Reload
    // ... submit logic
  };
  return (
    <form onSubmit={onSubmit} noValidate>
      <input
        type="email"
        value={email}
        onChange={(e: React.ChangeEvent<HTMLInputElement>) => setEmail(e.currentTarget.value)}
      />
      <button type="submit">Anmelden</button>
    </form>
  );
}
```

---

#### **4) Tastatur-Events (`KeyboardEvent`)**

```tsx
export function Search() {
  const onKey = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter') {
      console.log('Suche:', e.currentTarget.value);
    }
  };
  return <input onKeyDown={onKey} placeholder="Tippe und Enter‚Ä¶" />;
}
```

---

#### **5) Datei-Upload (Target richtig typisieren)**

```tsx
export function Uploader() {
  const onFile = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.currentTarget.files?.[0];
    if (file) console.log(file.name);
  };
  return <input type="file" onChange={onFile} />;
}
```

---

#### **6) Event-Handler als Prop typisieren**

```tsx
type ItemProps = {
  onRemove: (e: React.MouseEvent<HTMLButtonElement>) => void;
};
export function Item({ onRemove }: ItemProps) {
  return <button onClick={onRemove}>Remove</button>;
}
```

---

#### **7) N√ºtzliche Patterns**

* **`e.currentTarget`** statt `e.target` nutzen ‚Üí korrekt getypt.
* F√ºr generische DOM-Props: `React.ComponentProps<'button'>` etc.
* Touch/Pointer: `React.TouchEvent<HTMLElement>`, `React.PointerEvent<HTMLElement>`.

---

### **Zusammenfassung**

* `onChange`: `React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>`.
* `onClick`: `React.MouseEvent<HTMLButtonElement|HTMLDivElement>`.
* `onSubmit`: `React.FormEvent<HTMLFormElement>`.
* `onKeyDown`: `React.KeyboardEvent<HTMLInputElement>`.
* Immer `currentTarget` verwenden; Handler-Props klar typisieren.

**Quellen / Weiterlesen**

* React Docs ‚Äì Events (TS-Beispiele): [https://react.dev/learn/typescript](https://react.dev/learn/typescript)
* React Docs ‚Äì Formulare & Events: [https://react.dev/learn/forms](https://react.dev/learn/forms)
* MDN (RU) ‚Äì –°–æ–±—ã—Ç–∏—è DOM –∏ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã —Å–æ–±—ã—Ç–∏–π: [https://developer.mozilla.org/ru/](https://developer.mozilla.org/ru/)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

165. ### <a name="165"></a> Wie erstellt man einen benutzerdefinierten Hook mit TypeScript?

### **Benutzerdefinierter Hook mit TypeScript ‚Äì Vorgehen & Beispiele**

#### **Grundregeln**

* **Name mit `use‚Ä¶`**, intern React-Hooks verwenden.
* **Eingaben/Outputs typisieren** (Generics f√ºr wiederverwendbare Hooks).
* **Seiteneffekte** sauber aufr√§umen (Cleanup), Errors klar modellieren.

---

### **1) Sync-Logik: `useToggle` (einfacher State-Hook)**

```tsx
// useToggle.ts
import { useCallback, useState } from 'react';

export function useToggle(initial = false) {
  const [on, setOn] = useState<boolean>(initial);
  const toggle = useCallback(() => setOn(v => !v), []);
  const setTrue = useCallback(() => setOn(true), []);
  const setFalse = useCallback(() => setOn(false), []);
  return { on, toggle, setTrue, setFalse } as const; // readonly Tupel/Objekt
}
```

**Verwendung:**

```tsx
// Switch.tsx
import { useToggle } from './useToggle';

export function Switch() {
  const { on, toggle } = useToggle();
  return <button aria-pressed={on} onClick={toggle}>{on ? 'On' : 'Off'}</button>;
}
```

---

### **2) Generic + Async: `useAsync` (Fetch/Promise steuern)**

```tsx
// useAsync.ts
import { useEffect, useRef, useState } from 'react';

export type AsyncState<T> = {
  data: T | null;
  error: Error | null;
  loading: boolean;
};

export function useAsync<T>(
  fn: () => Promise<T>,
  deps: unknown[] = [],
  { immediate = true } = {}
) {
  const [state, setState] = useState<AsyncState<T>>({
    data: null, error: null, loading: immediate,
  });
  const abortRef = useRef<AbortController | null>(null);

  useEffect(() => {
    if (!immediate) return;
    abortRef.current?.abort();
    const controller = new AbortController();
    abortRef.current = controller;

    setState(s => ({ ...s, loading: true, error: null }));
    fn()
      .then((data) => {
        if (!controller.signal.aborted) {
          setState({ data, error: null, loading: false });
        }
      })
      .catch((err: unknown) => {
        if (!controller.signal.aborted) {
          const error = err instanceof Error ? err : new Error(String(err));
          setState({ data: null, error, loading: false });
        }
      });

    return () => controller.abort();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, deps);

  return state;
}
```

**Verwendung (Generics werden inferiert):**

```tsx
// Posts.tsx
import { useAsync } from './useAsync';

type Post = { id: number; title: string };

export function Posts() {
  const { data, loading, error } = useAsync<Post[]>(
    () => fetch('/api/posts').then(r => r.json()),
    []
  );

  if (loading) return <p>L√§dt‚Ä¶</p>;
  if (error)   return <p>Fehler: {error.message}</p>;

  return (
    <ul>
      {data?.map(p => <li key={p.id}>{p.title}</li>)}
    </ul>
  );
}
```

---

### **3) Formular-Helper: `useFormField<T>` (kontrollierte Inputs)**

```tsx
// useFormField.ts
import { useCallback, useState } from 'react';

export function useFormField<T>(initial: T) {
  const [value, setValue] = useState<T>(initial);
  const onChange = useCallback(
    (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
      const target = e.currentTarget;
      setValue((target as HTMLInputElement).type === 'checkbox'
        ? ((target as HTMLInputElement).checked as unknown as T)
        : (target.value as unknown as T));
    }, []);
  return { value, setValue, onChange };
}
```

**Verwendung:**

```tsx
// ProfileForm.tsx
import { useFormField } from './useFormField';

export function ProfileForm() {
  const name = useFormField<string>('');
  const news = useFormField<boolean>(false);

  return (
    <form>
      <input value={name.value} onChange={name.onChange} placeholder="Name" />
      <label>
        <input type="checkbox" checked={news.value} onChange={news.onChange} />
        Newsletter
      </label>
    </form>
  );
}
```

---

### **Best Practices (kurz)**

* **API definieren**: klare Param/Return-Typen; `as const` f√ºr readonly R√ºckgaben.
* **Generics** nutzen, wenn **Input/Output variabel** ist.
* **Abbruch-Logik** (AbortController) f√ºr Fetch-Hooks.
* **Keine** React-Hooks **konditional** aufrufen; **Abh√§ngigkeiten** vollst√§ndig halten.

---

### **Zusammenfassung**

* Benutzerdefinierte Hooks kapseln Logik; mit **TypeScript** werden Ein-/Ausgaben typsicher.
* **Sync-Hooks** (State/Callbacks) + **Async-Hooks** (Promise, Fetch) mit **Generics** und sauberem Cleanup.
* Gute Typen + klare API ‚áí **wiederverwendbar, robust, interview-tauglich**.

**Quellen / Weiterlesen**

* React Docs ‚Äì Custom Hooks: [https://react.dev/learn/reusing-logic-with-custom-hooks](https://react.dev/learn/reusing-logic-with-custom-hooks)
* React + TypeScript: [https://react.dev/learn/typescript](https://react.dev/learn/typescript)
* MDN (RU) ‚Äì AbortController (Fetch abbrechen): [https://developer.mozilla.org/ru/docs/Web/API/AbortController](https://developer.mozilla.org/ru/docs/Web/API/AbortController)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

166. ### <a name="166"></a> Wie typisiert man useReducer mit TypeScript?

### **`useReducer` mit TypeScript typisieren**

#### **1) Grundidee**

* Typen f√ºr **State** und **Action** definieren (oft als **discriminated union**).
* Der **Reducer** ist eine pure Funktion: `(state: State, action: Action) => State`.
* `useReducer<State, Action>(reducer, initialState, init?)` l√§sst sich vollst√§ndig typisieren.

---

#### **2) Discriminated Union f√ºr Actions**

```tsx
// counter.ts
export type CounterState = { value: number };

export type CounterAction =
  | { type: 'inc' }
  | { type: 'add'; payload: number }
  | { type: 'reset' };

export function counterReducer(state: CounterState, action: CounterAction): CounterState {
  switch (action.type) {
    case 'inc':
      return { value: state.value + 1 };
    case 'add':
      return { value: state.value + action.payload };
    case 'reset':
      return { value: 0 };
    default:
      // Exhaustiveness-Check (nie erreichbar, h√§lt Union vollst√§ndig)
      const _exhaustive: never = action;
      return state;
  }
}
```

---

#### **3) Nutzung in einer Komponente**

```tsx
// Counter.tsx
import { useReducer } from 'react';
import { counterReducer, type CounterState, type CounterAction } from './counter';

const initial: CounterState = { value: 0 };

export default function Counter() {
  const [state, dispatch] = useReducer<typeof counterReducer, CounterState>(
    counterReducer,
    initial
  );
  // dispatch ist automatisch auf CounterAction typisiert

  return (
    <div>
      <p>Wert: {state.value}</p>
      <button onClick={() => dispatch({ type: 'inc' })}>+1</button>
      <button onClick={() => dispatch({ type: 'add', payload: 5 })}>+5</button>
      <button onClick={() => dispatch({ type: 'reset' })}>Reset</button>
    </div>
  );
}
```

> Hinweis: H√§ufig reicht `const [state, dispatch] = useReducer(counterReducer, initial);`
> TypeScript leitet `State` und `Action` dann vom Reducer ab.

---

#### **4) Lazy-Initialization (dritter Parameter)**

```tsx
type InitArg = number; // z. B. startValue aus Props/URL
function init(start: InitArg): CounterState {
  return { value: start };
}

export default function CounterLazy({ start = 10 }: { start?: number }) {
  const [state, dispatch] = useReducer(counterReducer, start, init);
  return (
    <>
      <p>{state.value}</p>
      <button onClick={() => dispatch({ type: 'inc' })}>+1</button>
    </>
  );
}
```

---

#### **5) Komplexere Beispiele: Form-Reducer**

```tsx
type FormState = { name: string; email: string; submitting: boolean; error?: string };
type FormAction =
  | { type: 'change'; field: 'name' | 'email'; value: string }
  | { type: 'submit' }
  | { type: 'success' }
  | { type: 'failure'; error: string };

function formReducer(state: FormState, action: FormAction): FormState {
  switch (action.type) {
    case 'change':
      return { ...state, [action.field]: action.value };
    case 'submit':
      return { ...state, submitting: true, error: undefined };
    case 'success':
      return { ...state, submitting: false };
    case 'failure':
      return { ...state, submitting: false, error: action.error };
  }
}
```

```tsx
// Form.tsx
import { useReducer } from 'react';

const initialForm: FormState = { name: '', email: '', submitting: false };

export function Form() {
  const [state, dispatch] = useReducer(formReducer, initialForm);

  async function handleSubmit(e: React.FormEvent<HTMLFormElement>) {
    e.preventDefault();
    dispatch({ type: 'submit' });
    try {
      // await api.save(state)
      dispatch({ type: 'success' });
    } catch (err) {
      const message = err instanceof Error ? err.message : String(err);
      dispatch({ type: 'failure', error: message });
    }
  }

  return (
    <form onSubmit={handleSubmit}>
      <input
        value={state.name}
        onChange={(e) => dispatch({ type: 'change', field: 'name', value: e.currentTarget.value })}
      />
      <input
        value={state.email}
        onChange={(e) => dispatch({ type: 'change', field: 'email', value: e.currentTarget.value })}
      />
      <button disabled={state.submitting} type="submit">
        {state.submitting ? 'Sende‚Ä¶' : 'Speichern'}
      </button>
      {state.error && <p>Fehler: {state.error}</p>}
    </form>
  );
}
```

---

#### **6) Best Practices**

* **Discriminated Unions** mit `type`-Feld ‚Üí sichere Switches & Autovervollst√§ndigung.
* **Exhaustiveness-Checks** (`never`) im `default`-Fall sch√ºtzen vor vergessenen Actions.
* **Reducer bleibt synchron & pure**; Async-Logik au√üerhalb (z. B. im Event-Handler/Thunk).
* Typen exportieren (State/Action), um **`dispatch`** automatisch korrekt zu inferieren.

---

### **Zusammenfassung**

* `useReducer` wird typisiert √ºber **State-** und **Action-Typen** (idealerweise als **discriminated union**).
* Reducer: `(state: State, action: Action) => State`; `dispatch` ist automatisch **`(action: Action) => void`**.
* Lazy-Init √ºber dritten Parameter; komplexe F√§lle (Form, Wizard) profitieren von klaren Action-Typen.

**Quellen / Weiterlesen**

* React Docs ‚Äì Reducer & TypeScript: [https://react.dev/learn/typescript](https://react.dev/learn/typescript)
* React Docs ‚Äì `useReducer`: [https://react.dev/reference/react/useReducer](https://react.dev/reference/react/useReducer)
* TypeScript Handbook ‚Äì Union & Discriminated Unions: [https://www.typescriptlang.org/docs/handbook/2/narrowing.html#discriminated-unions](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#discriminated-unions)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

167. ### <a name="167"></a> Wie typisiert man children korrekt in React-Komponenten?

### **Children in React mit TypeScript korrekt typisieren**

#### **1) Der Standardfall: beliebige UI als `React.ReactNode`**

```tsx
// Card.tsx
import { type ReactNode } from 'react';

type CardProps = {
  title: string;
  children?: ReactNode; // Text, Elemente, Fragmente, Arrays, null, etc.
};

export function Card({ title, children }: CardProps) {
  return (
    <section aria-label={title}>
      <h2>{title}</h2>
      {children}
    </section>
  );
}
```

> `ReactNode` ist der √ºbliche, flexible Typ f√ºr `children`.

---

#### **2) Kurzform: `PropsWithChildren<T>`**

```tsx
// Panel.tsx
import { type PropsWithChildren } from 'react';

type PanelBase = { variant?: 'info' | 'warning' };

export function Panel({ variant = 'info', children }: PropsWithChildren<PanelBase>) {
  return <div data-variant={variant}>{children}</div>;
}
```

> `PropsWithChildren<T>` f√ºgt `children?: ReactNode` zu deinen Props hinzu.

---

#### **3) Genaue Einschr√§nkung: bestimmter Elementtyp**

```tsx
// List.tsx ‚Äì nur <li>-√§hnliche Kinder zulassen
import { type ReactElement } from 'react';

type ListProps = {
  children: ReactElement<HTMLLIElement> | ReactElement<HTMLLIElement>[];
};

export function List({ children }: ListProps) {
  return <ul>{children}</ul>;
}
```

> `ReactElement<HTMLLIElement>` erzwingt konkrete DOM-Elemente als Kind(er).

---

#### **4) Einzelnes Kind: `ReactElement` (kein Array/Fragment)**

```tsx
// OnlyChild.tsx
import { Children, isValidElement, type ReactElement } from 'react';

type OnlyChildProps = { children: ReactElement };

export function OnlyChild({ children }: OnlyChildProps) {
  // Optional: Laufzeit-Check
  if (!isValidElement(children)) throw new Error('Exactly one valid child required');
  return <div className="only-child">{children}</div>;
}
```

---

#### **5) Render-Prop / Function as Child**

```tsx
// DataProvider.tsx
import { type ReactNode } from 'react';

type DataProviderProps<T> = {
  data: T;
  children: (value: T) => ReactNode; // Funktionskind
};

export function DataProvider<T>({ data, children }: DataProviderProps<T>) {
  return <>{children(data)}</>;
}

// Verwendung
// <DataProvider data={{name:'Sergii'}}>{(d) => <span>{d.name}</span>}</DataProvider>
```

---

#### **6) `children` weiterreichen (Wrapper-Komponenten)**

```tsx
// Box.tsx
import { type PropsWithChildren, type HTMLAttributes } from 'react';

type BoxProps = PropsWithChildren<HTMLAttributes<HTMLDivElement>>;

export function Box({ children, ...rest }: BoxProps) {
  return <div {...rest}>{children}</div>;
}
```

> Praktisch, wenn du native HTML-Props + `children` akzeptieren willst.

---

#### **7) `JSX.Element` vs. `ReactNode` vs. `ReactElement` (Kurzvergleich)**

* **`ReactNode`**: alles Renderbare (string, number, `ReactElement`, `null`, `undefined`, Arrays, Fragmente).
* **`ReactElement`**: konkretes React-Element (z. B. `<div />`), ggf. mit Typ-Param f√ºr Host-Elemente.
* **`JSX.Element`**: Ergebnis eines JSX-Ausdrucks (meist deckungsgleich mit `ReactElement`), **nicht** f√ºr Text/`null`/Arrays geeignet.

> F√ºr flexible `children`: **`ReactNode`**. F√ºr **ein einzelnes Element**: `ReactElement`/`JSX.Element`.

---

#### **8) Optionalit√§t, Default und Performance**

```tsx
type SectionProps = {
  header?: React.ReactNode;   // optionales "Slot"-Kind
  children?: React.ReactNode; // `?` wenn nicht zwingend
};

export function Section({ header, children }: SectionProps) {
  return (
    <section>
      {header ?? <h3>Ohne Titel</h3>}
      {children}
    </section>
  );
}
```

* Optional mit `?`.
* Kein `React.FC` n√∂tig (macht `children` implizit optional und erschwert Generics).
* Bei teuren Baumstrukturen ggf. `React.memo` auf die Kind-Komponente anwenden.

---

### **Zusammenfassung**

* Standard: **`children?: React.ReactNode`** oder **`PropsWithChildren<T>`**.
* F√ºr **ein einzelnes** Kind: **`ReactElement`/`JSX.Element`**. F√ºr **bestimmte Typen**: `ReactElement<HTMLXElement>` oder eigene Komponenten-Typen.
* **Render-Props** als `(value) => ReactNode` typisieren; f√ºr HTML-Wrapper **native Props + `PropsWithChildren`** kombinieren.

**Quellen / Weiterlesen**

* React Docs ‚Äì TypeScript in React: [https://react.dev/learn/typescript](https://react.dev/learn/typescript)
* React Docs ‚Äì Children & Composition: [https://react.dev/learn/passing-props-to-a-component](https://react.dev/learn/passing-props-to-a-component)
* MDN (RU) ‚Äì JSX/–¢–∏–ø—ã –∏ –æ—Å–Ω–æ–≤—ã TS: [https://developer.mozilla.org/ru/](https://developer.mozilla.org/ru/)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

168. ### <a name="168"></a> Was ist React.FC und welche Vor- und Nachteile hat es?

### **React.FC in TypeScript**

#### **Definition**

* `React.FC` (oder `React.FunctionComponent`) ist ein **vordefinierter generischer Typ** in `@types/react`.
* Signatur (verk√ºrzt):

```ts
type FC<P = {}> = FunctionComponent<P>;
interface FunctionComponent<P = {}> {
  (props: PropsWithChildren<P>): ReactElement | null;
  propTypes?: WeakValidationMap<P>;
  defaultProps?: Partial<P>;
  displayName?: string;
}
```

üëâ Bedeutet: Jede Komponente bekommt automatisch **`children?: ReactNode`** und gibt **`ReactElement | null`** zur√ºck.

---

#### **Beispiel mit React.FC**

```tsx
import { type FC } from 'react';

type GreetingProps = { name: string };

const Greeting: FC<GreetingProps> = ({ name, children }) => (
  <h1>
    Hallo {name}! {children}
  </h1>
);

export default Greeting;
```

---

#### **Vorteile**

1. ‚úÖ K√ºrzere Schreibweise f√ºr Props + Children.

   ```ts
   const C: React.FC<{ title: string }> = ({ title, children }) => ...
   ```
2. ‚úÖ `children` automatisch enthalten (kein extra Typ notwendig).
3. ‚úÖ IDE-Autovervollst√§ndigung f√ºr **`displayName`, `propTypes`, `defaultProps`**.

---

#### **Nachteile**

1. ‚ùå **Immer `children` enthalten** ‚Äì auch wenn die Komponente gar keine Kinder akzeptiert ‚Üí **API verwirrend**.
2. ‚ùå **Generics eingeschr√§nkt** ‚Äì `React.FC<MyGeneric<T>>` macht es schwerer, Typen korrekt zu inferieren.
3. ‚ùå **defaultProps Problem** ‚Äì funktioniert seit React 18 mit TS nicht sauber (`defaultProps`-Typen werden nicht richtig gemerged).
4. ‚ùå Etwas **weniger explizit** ‚Äì man sieht in den Props nicht sofort, ob `children` erlaubt sind.
5. ‚ùå Die R√ºckgabe wird auf `ReactElement | null` fixiert ‚Üí kein breiteres Typing (z. B. `string | number`).

---

#### **Empfohlene Alternative**

```tsx
type GreetingProps = {
  name: string;
  children?: React.ReactNode; // explizit und nur wenn n√∂tig
};

export function Greeting({ name, children }: GreetingProps) {
  return <h1>Hallo {name}! {children}</h1>;
}
```

üëâ Besser kontrollierbar, flexibler f√ºr Generics und ohne versteckte Typen.

---

### **Zusammenfassung**

* **`React.FC`**: Typ f√ºr Funktionskomponenten mit Props + implizitem `children`.
* Vorteile: **kurz, einfach, autocompletion**.
* Nachteile: **unn√∂tige children, schwache Generics, defaultProps-Bug**.
* **Best Practice heute**: **Props explizit typisieren**, kein `React.FC` ‚Äì au√üer man will schnell eine kleine Komponente mit Children bauen.

**Quellen / Weiterlesen**

* React + TS Cheatsheets: [https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/function_components/](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/function_components/)
* React Docs ‚Äì TypeScript: [https://react.dev/learn/typescript](https://react.dev/learn/typescript)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

169. ### <a name="169"></a> Wie typisiert man eine Komponente mit optionalen Props?

### **Komponenten mit optionalen Props in TypeScript**

#### **1) Optional √ºber `?`**

```tsx
type ButtonProps = {
  label: string;
  disabled?: boolean;      // optional
  onClick?: () => void;    // optional
};

export function Button({ label, disabled = false, onClick }: ButtonProps) {
  return (
    <button disabled={disabled} onClick={onClick}>
      {label}
    </button>
  );
}
```

üëâ `disabled` kann weggelassen werden, Standardwert = `false`.

---

#### **2) Mit Default-Parametern**

```tsx
type GreetingProps = {
  name?: string;
};

export function Greeting({ name = "Gast" }: GreetingProps) {
  return <h1>Hallo {name}</h1>;
}
```

üëâ Default-Werte im Destructuring sind der √ºbliche Weg in TS/React.

---

#### **3) Kombination mit Children**

```tsx
import { type ReactNode } from "react";

type CardProps = {
  title?: string;
  children?: ReactNode;
};

export function Card({ title, children }: CardProps) {
  return (
    <section>
      {title && <h2>{title}</h2>}
      {children}
    </section>
  );
}
```

---

#### **4) Unterschied: `?` vs. `Partial<T>`**

* **`?`** ‚Üí selektiv optionale Props.
* **`Partial<T>`** ‚Üí alle Props optional.

```tsx
type FormProps = { name: string; email: string };
type FormPropsOptional = Partial<FormProps>; 
// { name?: string; email?: string }
```

---

#### **5) Generics mit optionalen Props**

```tsx
type ListProps<T> = {
  items: T[];
  renderItem: (item: T) => React.ReactNode;
  emptyFallback?: React.ReactNode;  // optional
};

export function List<T>({ items, renderItem, emptyFallback }: ListProps<T>) {
  if (items.length === 0) return <>{emptyFallback ?? "Keine Daten"}</>;
  return <ul>{items.map(renderItem)}</ul>;
}
```

---

### **Zusammenfassung**

* Optionale Props ‚Üí mit `?` oder `Partial<T>`.
* Default-Werte direkt im Destructuring setzen.
* `children` auch optional machen, wenn nicht immer n√∂tig.
* **Faustregel**: Props explizit optional machen (`?`), nur in speziellen F√§llen `Partial<T>` verwenden.

**Quellen / Weiterlesen**

* React Docs ‚Äì TypeScript: [https://react.dev/learn/typescript](https://react.dev/learn/typescript)
* TS Handbook ‚Äì Utility Types (`Partial<T>`): [https://www.typescriptlang.org/docs/handbook/utility-types.html#partialtype](https://www.typescriptlang.org/docs/handbook/utility-types.html#partialtype)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

170. ### <a name="170"></a> Wie arbeitet man mit Drittanbieter-Bibliotheken, die keine Typen enthalten?

### **Mit Drittanbieter-Bibliotheken ohne Typen arbeiten (TypeScript)**

#### **1) Pr√ºfen: Gibt es Community-Typen? (`@types/*`)**

```bash
npm i -D @types/packagename
```

* Falls vorhanden, sofort nutzen (aktualisieren, wenn inkompatibel).
* Typische TS-Flags f√ºr Interop:

```json
// tsconfig.json
{
  "compilerOptions": {
    "esModuleInterop": true,
    "skipLibCheck": true
  }
}
```

---

#### **2) Minimal-Typen selbst deklarieren (`.d.ts`)**

* F√ºr Pakete ohne Typen eine **Ambient Declaration** anlegen.

```ts
// types/untyped-lib.d.ts
declare module 'untyped-lib' {
  export function doThing(input: string): Promise<number>;
  export interface Options { verbose?: boolean }
  export default function main(opts?: Options): void;
}
```

**Nutzung:**

```ts
import main, { doThing } from 'untyped-lib';
await doThing('hello');
main({ verbose: true });
```

> Vorteil: Nur das **ben√∂tigte API** typisieren (inkrementell), statt alles.

---

#### **3) Schnelle √úberbr√ºckung: gezieltes `any`/`unknown` kapseln**

```ts
// lib/facade.ts
// Intern ‚Äûunsafe‚Äú, nach au√üen ‚Äûsafe‚Äú API
// eslint-disable-next-line @typescript-eslint/no-explicit-any
import rawAnyLib from 'untyped-lib';

type Result = { id: string; name: string };

export async function getSafe(): Promise<Result> {
  const r: unknown = await (rawAnyLib as any).fetch(); // nur hier ‚Äûany‚Äú
  // Narrowing:
  if (isResult(r)) return r;
  throw new Error('Bad shape');
}

function isResult(x: unknown): x is Result {
  return !!x && typeof x === 'object'
    && typeof (x as any).id === 'string'
    && typeof (x as any).name === 'string';
}
```

> Pattern: **Fassade**/Wrapper baut Typ-Sicherheit am Rand auf.

---

#### **4) Module Augmentation (API erweitern/erg√§nzen)**

* Wenn Basistypen existieren, aber etwas fehlt:

```ts
// types/augment-express.d.ts
import 'express';
declare module 'express-serve-static-core' {
  interface Request {
    user?: { id: string; roles: string[] };
  }
}
```

---

#### **5) JSDoc-Typen f√ºr JS-Libs oder Migrationsphase**

* In JS-Dateien mit `// @ts-check` + JSDoc typisieren:

```js
// @ts-check
/**
 * @typedef {{id: string, name: string}} User
 */

/**
 * @param {string} url
 * @returns {Promise<User>}
 */
export async function fetchUser(url) {
  const res = await fetch(url);
  return /** @type {User} */ (await res.json());
}
```

`tsconfig.json`:

```json
{ "compilerOptions": { "checkJs": true }, "include": ["src", "types"] }
```

---

#### **6) Runtime-Validierung + Typ-Inference (robust)**

* Mit Zod/Valibot Formate **zur Laufzeit pr√ºfen** + Typen ableiten:

```ts
import { z } from 'zod';

const User = z.object({ id: z.string(), name: z.string() });
type User = z.infer<typeof User>;

export async function safeFetch(u: string): Promise<User> {
  const json = await fetch(u).then(r => r.json());
  return User.parse(json); // throws bei falschem Shape
}
```

---

#### **7) Edge-Cases: CJS/ESM, Default vs. Named**

```ts
// CommonJS-Only-Paket
import pkg from 'cjs-only-lib';        // mit "esModuleInterop": true
// oder
import * as pkgNS from 'cjs-only-lib'; // ohne esModuleInterop
```

* Falls Default/Named unklar ist, in der `.d.ts` **genau festlegen**.

---

#### **8) Projekt-Tipps**

* **Ordner `types/`** anlegen, in `tsconfig.json` inkludieren:

```json
{ "include": ["src", "types"] }
```

* **Schrittweise vorgehen**: erst die **ben√∂tigten** Funktionen tippen.
* **Tests** (z. B. mit Vitest/Jest) + **Runtime-Checks** f√ºr kritische Pfade.

---

### **Zusammenfassung**

* Zuerst `@types/*` pr√ºfen; sonst **eigene `.d.ts`** schreiben (minimal & inkrementell).
* Unsichere APIs **in einer Fassade kapseln**, optional mit **Runtime-Validierung**.
* **Module Augmentation** f√ºr fehlende Erweiterungen; **JSDoc** hilfreich in JS-Dateien.
* TS-Interop-Flags (`esModuleInterop`, `skipLibCheck`) pragmatisch einsetzen.

**Quellen / Weiterlesen**

* MDN (RU) ‚Äì TypeScript √úberblick & Tools: [https://developer.mozilla.org/ru/docs/Glossary/TypeScript](https://developer.mozilla.org/ru/docs/Glossary/TypeScript)
* React Docs ‚Äì TypeScript in React: [https://react.dev/learn/typescript](https://react.dev/learn/typescript)
* (Weiterf√ºhrend) TypeScript Handbook ‚Äì Declaration Files & Module Augmentation: [https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html](https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

171. ### <a name="171"></a> Was ist der Unterschied zwischen ESM und CommonJS?

### **Unterschied: ESM (ECMAScript Modules) vs. CommonJS**

#### **1) Herkunft**

* **CommonJS (CJS)**

  * Altes Node.js-Standardmodul-System.
  * Wurde entwickelt, bevor ES6 offiziell Module einf√ºhrte.
  * Dateien meist mit `.cjs` oder `.js`.

* **ESM (ECMAScript Modules)**

  * Offizieller Standard seit **ES2015 (ES6)**.
  * Wird im Browser **und** in modernen Node.js-Versionen nativ unterst√ºtzt.
  * Dateien meist mit `.mjs` oder `.js` (wenn `package.json` ‚Üí `"type": "module"`).

---

#### **2) Syntax**

**CommonJS**

```js
// exportieren
const sum = (a, b) => a + b;
module.exports = sum;

// importieren
const sum = require('./sum');
console.log(sum(2, 3));
```

**ESM**

```js
// exportieren
export function sum(a, b) { return a + b; }
export default function multiply(a, b) { return a * b; }

// importieren
import multiply, { sum } from './math.js';
console.log(sum(2, 3), multiply(2, 3));
```

---

#### **3) Laden und Ausf√ºhrung**

* **CJS**

  * **Synchrones** Laden (`require`) ‚Üí problematisch im Browser.
  * L√§uft nur in Node.js ohne Bundler/Transpiler.

* **ESM**

  * **Asynchrones** Laden (`import`/`export`).
  * Funktioniert im Browser nativ mit `<script type="module">`.
  * Tree Shaking m√∂glich ‚Üí kleinere Bundles.

---

#### **4) Kompatibilit√§t**

* In Node.js:

  * `"type": "module"` in `package.json` ‚Üí `.js` als ESM interpretiert.
  * `"type": "commonjs"` (oder Standard) ‚Üí `.js` als CommonJS interpretiert.
  * Man kann `.cjs` (CJS) und `.mjs` (ESM) parallel nutzen.

* Mischen ist kompliziert:

  * **CJS ‚Üí ESM importieren**: geht nur √ºber `import()` (dynamic import).
  * **ESM ‚Üí CJS importieren**: via `require` nur eingeschr√§nkt m√∂glich.

---

#### **5) Features**

| Merkmal               | CommonJS (`require`)        | ESM (`import/export`)      |
| --------------------- | --------------------------- | -------------------------- |
| Standardisierung      | Node.js-spezifisch          | ECMA-Standard (ES2015)     |
| Ladeverhalten         | synchron                    | asynchron                  |
| Syntax                | `module.exports`, `require` | `export`, `import`         |
| Tree Shaking          | ‚ùå nicht m√∂glich             | ‚úÖ m√∂glich                  |
| Verwendung im Browser | ‚ùå nur mit Bundler           | ‚úÖ `<script type="module">` |

---

#### **6) Beispiel im Browser (nur ESM)**

```html
<script type="module">
  import { sum } from './math.js';
  console.log(sum(4, 5));
</script>
```

---

### **Zusammenfassung**

* **CommonJS**: √§lteres Node.js-System, `require/module.exports`, synchron, kein Tree Shaking.
* **ESM**: offizieller Standard, `import/export`, asynchron, unterst√ºtzt Tree Shaking, funktioniert im Browser und Node.js.
* Heute gilt: **ESM bevorzugen**, CommonJS nur f√ºr Legacy/√§ltere Packages.

**Quellen / Weiterlesen**

* Node.js Docs ‚Äì [Modules: CommonJS vs ESM](https://nodejs.org/api/modules.html)
* MDN (RU) ‚Äì [ES-Modules](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Modules)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

172. ### <a name="172"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

173. ### <a name="173"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

174. ### <a name="174"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

175. ### <a name="175"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

176. ### <a name="176"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

177. ### <a name="177"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

178. ### <a name="178"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

179. ### <a name="179"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

180. ### <a name="180"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

181. ### <a name="181"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

182. ### <a name="182"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

183. ### <a name="183"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

184. ### <a name="184"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

185. ### <a name="185"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

186. ### <a name="186"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

187. ### <a name="187"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

188. ### <a name="188"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

189. ### <a name="189"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

190. ### <a name="190"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

191. ### <a name="191"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

192. ### <a name="192"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

193. ### <a name="193"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

194. ### <a name="194"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

195. ### <a name="195"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

196. ### <a name="196"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

197. ### <a name="197"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

198. ### <a name="198"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

199. ### <a name="199"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

200. ### <a name="200"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**      
