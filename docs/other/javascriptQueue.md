## new reality JS

### Table of Contents

| No. | Questions |
|---- | ---------
|1  | [Способы создания объектов в JavaScript](#1) |
|2  | [Что такое цепочка прототипов?](#2)|
|3  | [В чем разница между Call, Apply и Bind](#3)|
|4  | [Что такое JSON и его общие операции](#4)|
|5  | [Какова цель метода массива slice](#5)|
|6  | [Какова цель метода массива splice](#6)|
|7  | [В чем разница между slice и splice](#7)|
|8  | [Как вы сравниваете Object и Map](#8)|
|9  | [В чем разница между операторами == и ===](#9)|
|10 | [Что такое лямбда или стрелочные функции](#10)|
|11 | [Что такое функция первого класса](#11)|
|12 | [Что такое функция первого порядка](#12)|
|13 | [Что такое функция высшего порядка](#13)|
|14 | [Что такое унарная функция](#14)|
|15 | [Что такое каррирующая функция](#15)|
|16 | [Что такое чистая функция](#16)|
|17 | [Какова цель ключевого слова let](#17)|
|18 | [В чем разница между let и var](#18)|
|19 | [В чем причина выбора имени let в качестве ключевого слова](#19)|
|20 | [Как повторно объявить переменные в блоке switch без ошибки](#20)|
|21 | [Что такое временная мертвая зона](#21)|
|22 | [Что такое IIFE (выражение немедленно вызываемой функции)](#22)|
|23 | [Как вы декодируете или кодируете URL-адрес в JavaScript?](#23)|
|24 | [Что такое мемоизация](#24)|
|25 | [Что такое Подъем](#25)|
|26 | [Что такое классы в ES6](#26)|
|27 | [Что такое замыкания](#27)|
|28 | [Что такое модули](#28)|
|29 | [Зачем нужны модули](#29)|
|30 | [Что такое область видимости в javascript](#30)|
|31 | [Что такое service worker](#31)|
|32 | [Как вы манипулируете DOM с помощью service worker](#32)|
|33 | [Как вы повторно используете информацию при перезапуске service worker](#33)|
|34 | [Что такое IndexedDB](#34)|
|35 | [Что такое web storage](#35)|
|36 | [Что такое post message](#36)|
|37 | [Что такое cookie](#37)|
|38 | [Зачем нужны Cookie](#38)|
|39 | [Каковы параметры в файле cookie](#39)|
|40 | [Как удалить cookie](#40)|
|41 | [В чем разница между файлами cookie, local storage and session storage](#41)|
|42 | [В чем основное различие между localStorage and sessionStorage](#42)|
|43 | [Как получить доступ к веб-хранилищу (web storage)](#43)|
|44 | [Какие методы доступны в session storage](#44)|
|45 | [Что такое storage event и его обработчик событий](#45)|
|46 | [Зачем тебе нужно web storage](#46)|
|47 | [Как вы проверяете поддержку браузера web storage](#47)|
|48 | [Как вы проверяете поддержку браузера workers](#48)|
|49 | [Приведите пример web worker](#49)|
|50 | [Каковы ограничения web workers в DOM](#50)|
|51 | [Что такое promise](#51)|
|52 | [Зачем вам нужен promise](#52)|
|53 | [Каковы три состояния promise](#53)|
|54 | [Что такое callback function](#54)|
|55 | [Зачем нам нужны callbacks](#55)|
|56 | [Что такое callback hell](#56)|
|57 | [Что такое server-sent events](#57)|
|58 | [Как вы получаете уведомления о событиях server-sent event](#58)|
|59 | [Как вы проверяете поддержку браузером событий server-sent events](#59)|
|60 | [Какие события доступны для событий server sent](#60)|
|61 | [Каковы основные правила promise](#61)|
|62 | [Что такое callback in callback](#62)|
|63 | [Что такое цепочка promise](#63)|
|64 | [Что такое promise.all](#64)|
|65 | [Какова цель метода race в promise](#65)|
|66 | [Что такое строгий режим в javascript? (strict mode)](#66)|
|67 | [Зачем нам нужно strict mode](#67)|
|68 | [Как вы объявляете strict mode](#68)|
|69 | [Какова цель двойного восклицательного знака](#69)|
|70 | [Какова цель оператора удаления](#70)|
|71 | [Что такое оператор typeof](#71)|
|72 | [Что такое undefined свойство](#72)|
|73 | [Что такое значение null](#73)|
|74 | [В чем разница между null и undefined](#74)|
|75 | [Что тако eval](#75)|
|76 | [В чем разница между window и document](#76)|
|77 | [Как вы получаете доступ к history в javascript](#77)|
|78 | [Как определить, включена клавиша Caps Lock или нет?](#78)|
|79 | [Что такое isNaN](#79)|
|80 | [В чем разница между undeclared и undefined переменными](#80)|
|81 | [Что такое глобальные переменные](#81)|
|82 | [Какие проблемы с глобальными переменными](#82)|
|83 | [Что такое свойство NaN](#83)|
|84 | [Какова цель функции isFinite](#84)
|85 | [Что такое поток событий? (event flow)](#85)|
|86 | [Что такое event bubbling](#86)|
|87 | [Что такое захват событий? (event capturing)](#87)|
|88 | [Как отправить форму с помощью JavaScript](#88)|
|89 | [Как найти сведения об операционной системе](#89)|
|90 | [В чем разница между document load и DOMContentLoaded событиями](#90)|
|91 | [В чем разница между native, host и user objects](#91)|
|92 | [Какие инструменты или методы используются для отладки кода JavaScript](#92)|
|93 | [Каковы плюсы и минусы promises над callbacks](#93)|
|94 | [В чем разница между атрибутом и свойством](#94)|
|95 | [Что такое same-origin policy](#95)|
|96 | [Какова цель void 0](#96)|
|97 | [Является ли JavaScript компилируемым или интерпретируемым языком](#97)|
|98 | [Является ли JavaScript языком с учетом регистра](#98)|
|99 | [Есть ли какая-либо связь между Java и JavaScript](#99)|
|100| [Что такое события](#100)|
|101| [Кто создал javascript](#101)|
|102| [Какая польза от метода preventDefault](#102)|
|103| [Какая польза от метода stopPropagation](#103)|
|104| [Каковы шаги, связанные с возвратом false](#104)|
|105| [Что такое BOM](#105)|
|106| [Какая польза от setTimeout](#106)|
|107| [Какая польза от setInterval](#107)|
|108| [Почему JavaScript рассматривается как однопоточный язык](#108)|
|109| [Что такое event delegation](#109)|
|110| [Что такое ECMAScript](#110)|
|111| [Что такое JSON](#111)|
|112| [Каковы синтаксические правила JSON](#112)|
|113| [Какова цель JSON stringify](#113)|
|114| [Как вы parse JSON строку](#114)|
|115| [Зачем вам JSON](#115)|
|116| [Что такое PWAs](#116)|
|117| [Какова цель метода clearTimeout](#117)|
|118| [Какова цель метода clearInterval](#118)|
|119| [Как вы перенаправляете новую страницу в javascript](#119)|
|120| [Как проверить, содержит ли строка подстроку](#120)|
|121| [Как вы проверяете электронную почту в javascript](#121)|
|122| [Как вы получаете текущий URL-адрес с помощью javascript](#122)|
|123| [What are the various url properties of location object](#123)|
|124| [Как получить значения строки запроса в javascript](#124)|
|125| [Как проверить, существует ли ключ в объекте](#125)|
|126| [Как вы перебираете или перечисляете объект javascript](#126)|
|127| [Как вы тестируете пустой объект](#127)|
|128| [Что такое объект аргументов](#128)|
|129| [Как сделать первую букву строки прописной](#129)|
|130| [Каковы плюсы и минусы цикла for](#130)|
|131| [Как вы отображаете текущую дату в javascript](#131)|
|132| [Как вы сравниваете два объекта даты](#132)|
|133| [Как проверить, начинается ли строка с другой строки](#133)|
|134| [Как обрезать строку в javascript](#134)|
|135| [Как добавить пару ключ-значение в javascript](#135)|
|136| [Представляет ли запись '!--' специальный оператор](#136)|
|137| [Как вы назначаете значения по умолчанию для переменных](#137)|
|138| [Как вы определяете многострочные строки](#138)|
|139| [Что такое app shell model](#139)|
|140| [Можем ли мы определить свойства для функций](#140)|
|141| [Как найти количество параметров, ожидаемых функцией](#141)|
|142| [Что такое polyfill](#142)|
|143| [Что такое операторы break и continue](#143)|
|144| [Что такое JS-метки](#144)|
|145| [Каковы преимущества размещения объявлений (declarations) наверху](#145)|
|146| [Каковы преимущества инициализации переменных](#146)|
|147| [Каковы рекомендации по созданию нового объекта](#147)|
|148| [Как вы определяете массивы JSON](#148)|
|149| [Как вы генерируете случайные целые числа](#149)|
|150| [Можете ли вы написать функцию случайных целых чисел для печати целых чисел в диапазоне](#150)|
|151| [Что такое tree shaking](#151)|
|152| [Для чего нужно tree shaking](#152)|
|153| [Рекомендуется ли использовать eval](#153)|
|154| [Что такое регулярное выражение, RegExp](#154)|
|155| [Какие строковые методы доступны в регулярном выражении](#155)|
|156| [Что такое модификаторы в регулярном выражении](#156)|
|157| [Что такое шаблоны регулярных выражений](#157)|
|158| [Что такое объект RegExp](#158)|
|159| [Как вы ищете строку для шаблона](#159)|
|160| [Какова цель метода exec](#160)|
|161| [Как изменить стиль HTML-элемента](#161)|
|162| [Каким будет результат 1+2+'3'](#162)|
|163| [Что такое debugger statement](#163)|
|164| [Какова цель точек останова в отладке](#164)|
|165| [Могу ли я использовать зарезервированные слова в качестве идентификаторов](#165)|
|166| [Как определить мобильный браузер](#166)|
|167| [Как определить мобильный браузер без регулярного выражения](#167)|
|168| [Как получить ширину и высоту изображения с помощью JS](#168)|
|169| [Как сделать синхронный HTTP-запрос](#169)|
|170| [Как сделать асинхронный HTTP-запрос](#170)|
|171| [Как вы конвертируете дату в другой часовой пояс в javascript](#171)|
|172| [Какие свойства используются для получения размера окна](#172)|
|173| [Что такое условный оператор в javascript](#173)|
|174| [Можете ли вы применить chaining к условному оператору](#174)|
|175| [Какие есть способы выполнить javascript после загрузки страницы](#175)|
|176| [В чем разница между proto и prototype](#176)|
|177| [Приведите пример, где вам действительно нужна точка с запятой](#177)|
|178| [Что такое метод заморозк](#178)|
|179| [В чем суть метода заморозки](#179)|
|180| [Почему мне нужно использовать метод замораживания](#180)|
|181| [Как определить языковые предпочтения браузера](#181)|
|182| [Как преобразовать строку в заглавный регистр с помощью javascript](#182)|
|183| [Как вы обнаруживаете, что JavaScript отключен на странице](#183)|
|184| [Какие различные операторы поддерживаются javascript](#184)|
|185| [Что такое rest параметр](#185)|
|186| [Что произойдет, если вы не используете параметр rest в качестве последнего аргумента](#186)|
|187| [Какие побитовые операторы доступны в javascript](#187)|
|188| [Что такое spread оператор](#188)|
|189| [Как определить, заморожен объект или нет?](#189)|
|190| [Как вы определяете два одинаковых значения или не используете объект](#190)|
|191| [Какова цель использования объекта - это метод](#191)|
|192| [Как вы копируете свойства с одного объекта на другой](#192)|
|193| [Каковы применения метода assign](#193)|
|194| [Что такое proxy object](#194)|
|195| [Какова цель метода seal](#195)|
|196| [Каковы применения метода seal](#196)|
|197| [В чем разница между методами freeze и seal](#197)|
|198| [Как определить, запечатан объект или нет?](#198)|
|199| [Как получить перечисляемые пары ключ-значение](#199)|
|200| [В чем основное различие между методами Object.values и Object.entries](#200)|
|201| [Как получить список ключей любого объекта](#201)|
|202| [Как вы создаете объект с прототипом](#202)|
|203| [Что такое WeakSet](#203)|
|204| [Каковы различия между WeakSet и Set](#204)|
|205| [Перечислите коллекцию методов, доступных в WeakSet](#205)|
|206| [Что такое WeakMap](#206)|
|207| [Каковы различия между WeakMap и Map](#207)|
|208| [Перечислите коллекцию методов, доступных на WeakMap](#208)|
|209| [Какова цель uneval](#209)|
|210| [Как вы кодируете URL](#210)|
|211| [Как вы декодируете URL](#211)|
|212| [Как распечатать содержимое веб-страницы](#212)|
|213| [В чем разница между uneval и eval](#213)|
|214| [Что такое анонимная функция](#214)|
|215| [Каков порядок приоритета между локальными и глобальными переменными](#215)|
|216| [Что такое аксессоры javascript](#216)|
|217| [Как вы определяете свойство в конструкторе объектов](#217)|
|218| [В чем разница между get и defineProperty](#218)|
|219| [В чем преимущества геттеров и сеттеров](#219)|
|220| [Могу ли я добавить геттеры и сеттеры, используя метод defineProperty](#220)|
|221| [Каково назначение switch-case](#221)|
|222| [Каких соглашений следует придерживаться при использовании swtich case](#222)|
|223| [Что такое примитивные типы данных](#223)|
|224| [Какие существуют способы доступа к свойствам объекта](#224)|
|225| [Каковы правила параметров функции](#225)|
|226| [Что такое объект ошибки](#226)|
|227| [Когда вы получаете синтаксическую ошибку](#227)|
|228| [Каковы разные имена ошибок из объекта ошибки](#228)|
|229| [Каковы различные утверждения в обработке ошибок](#229)|
|230| [Какие два типа циклов в javascript](#230)|
|231| [Что такое nodejs](#231)|
|232| [Что такое объект Intl](#232)|
|233| [Как вы выполняете форматирование даты и времени для конкретного языка](#233)|
|234| [Что такое итератор](#234)|
|235| [Как работает синхронная итерация](#235)|
|236| [Что такое цикл событий(event loop)](#236)|
|237| [Что такое стек вызовов (call stack)](#237)|
|238| [Что такое очередь событий (event queue)](#238)|
|239| [Что такое декоратор](#239)|
|240| [Каковы свойства объекта Intl](#240)|
|241| [Что такое унарный оператор](#241)|
|242| [Как сортировать элементы в массиве](#242)|
|243| [Какова цель compareFunction при сортировке массивов](#243)|
|244| [Как вы reversing массив](#244)|
|245| [Как найти минимальное и максимальное значение в массиве](#245)|
|246| [Как найти минимальное и максимальное значения без Math функций](#246)|
|247| [Что такое empty statement и его цель](#247)|
|248| [Как получить метаданные модуля](#248)|
|249| [Что такое запятая operator](#249)|
|250| [В чем преимущество оператора запятой](#250)|
|251| [Что такое typescript](#251)|
|252| [В чем разница между javascript и typescript](#252)|
|253| [Каковы преимущества typescript перед javascript](#253)|
|254| [Что такое инициализатор объекта](#254)|
|255| [Что такое constructor method](#255)|
|256| [Что произойдет, если вы напишете конструктор более одного раза в классе](#256)|
|257| [Как вы вызываете конструктор родительского класса](#257)|
|258| [Как получить прототип объекта](#258)|
|259| [Что произойдет, если я передам строковый тип для метода getPrototype](#259)|
|260| [Как вы устанавливаете прототип одного объекта для другого](#260)|
|261| [Как вы проверяете, может ли объект быть расширяемым или нет?](#261)|
|262| [Как предотвратить расширение объекта](#262)|
|263| [Какие существуют способы сделать объект нерасширяемым?](#263)|
|264| [Как определить несколько свойств объекта](#264)|
|265| [Что такое MEAN в javascript](#265)|
|266| [Что такое обфускация в javascript? (Obfuscation)](#266)|
|267| [Зачем тебе нужна Obfuscation](#267)|
|268| [Что такое минификация](#268)|
|269| [В чем преимущества минификации](#269)|
|270| [В чем разница межд обфускацией и шифрованием? Obfuscation и Encryption](#270)|
|271| [Какие общие инструменты используются для минификации](#271)|
|272| [Как вы выполняете проверку формы с помощью javascript](#272)|
|273| [Как вы выполняете проверку формы без javascript](#273)|
|274| [Какие методы DOM доступны для проверки ограничений](#274)|
|275| [Каковы доступные свойства DOM проверки ограничений](#275)|
|276| [Каков список свойств валидности](#276)|
|277| [Приведите пример использования свойства rangeOverflow](#277)|
|278| [Доступна ли функция enums в javascript](#278)|
|279| [Что такое enum? (перечисление)](#279)|
|280| [Как перечислить все свойства объекта](#280)|
|281| [Как получить дескрипторы свойств объекта](#281)|
|282| [Какие атрибуты предоставляет дескриптор свойства](#282)|
|283| [Как вы extend classes](#283)|
|284| [Как изменить URL без перезагрузки страницы](#284)|
|285| [Как проверить, содержит ли массив определенное значение или нет?](#285)|
|286| [Как вы сравниваете скалярные массивы](#286)|
|287| [Как получить значение из параметров get](#287)|
|288| [Как вы печатаете числа с запятыми в качестве разделителей тысяч](#288)|
|289| [В чем разница между java и javascript](#289)|
|290| [Поддерживает ли javascript пространство имен](#290)|
|291| [Как вы объявляете пространство имен](#291)|
|292| [Как вы вызываете код javascript в iframe с родительской страницы](#292)|
|293| [Как получить смещение часового пояса от даты](#293)|
|294| [Как вы загружаете файлы CSS и JS динамически](#294)|
|295| [Какие существуют способы поиска HTML-элементов в DOM?](#295)|
|296| [Что такое jQuery](#296)|
|297| [Что такое JavaScript-движок V8](#297)|
|298| [Почему мы называем javascript динамическим языком](#298)|
|299| [Что такое void operator](#299)|
|300| [Как поставить курсор на ожидание](#300)|
|301| [Как создать бесконечный цикл](#301)|
|302| [Почему вам нужно избегать с statement](#302)|
|303| [Каков результат of below for loops](#303)|
|304| [Перечислите некоторые функции ES6](#304)|
|305| [Что такое ES6](#305)|
|306| [Могу ли я повторно объявить переменные let и const](#306)|
|307| [const переменная делает значение неизменным](#307)|
|308| [Что такое параметры по умолчанию](#308)|
|309| [Что такое шаблонные литералы](#309)|
|310| [Как вы пишете многострочные строки в литералах шаблона](#310)|
|311| [Что такое вложенные шаблоны](#311)|
|312| [Что такое шаблоны с тегами](#312)|
|313| [Что такое необработанные строки](#313)|
|314| [Что такое деструктуризация](#314)|
|315| [Каковы значения по умолчанию в деструктуризации](#315)|
|316| [Как поменять местами переменные в деструктуризации](#316)|
|317| [Что такое расширенные литералы объектов](#317)|
|318| [Что такое динамический импорт](#318)|
|319| [Каковы варианты использования динамического импорта](#319)|
|320| [Что такое типизированные массивы](#320)|
|321| [В чем преимущества загрузчиков модулей](#321)|
|322| [Что такое сопоставление](#322)|
|323| [Что такое for...of statement](#323)|
|324| [Каков результат нижеприведенного массива операторов spread](#324)|
|325| [Является ли PostMessage безопасным](#325)|
|326| [Каковы проблемы с целевым источником сообщения в качестве подстановочного знака?](#326)|
|327| [Как избежать получения почтовых сообщений от злоумышленников](#327)|
|328| [Могу ли я полностью избежать использования postMessages](#328)|
|329| [Является ли postMessages синхронным](#329)|
|330| [Какой парадигмой является Javascript](#330)|
|331| [В чем разница между внутренним и внешним javascript](#331)|
|332| [Является ли JavaScript быстрее, чем скрипт на стороне сервера? server side script](#332)|
|333| [Как узнать статус checkbox](#333)|
|334| [Какова цель оператора двойной тильды](#334)|
|335| [Как вы конвертируете символ в код ASCII](#335)|
|336| [Что такое ArrayBuffer](#336)|
|337| [Каков результат приведенного ниже строкового выражения](#337)|
|338| [Какова цель объекта Error](#338)|
|339| [Какова цель объекта EvalError](#339)|
|340| [Каков список ошибок случаев, выбрасываемых из нестрогого режима в строгий режим](#340)|
|341| [Все ли объекты имеют прототипы](#341)|
|342| [В чем разница между параметром и аргументом](#342)|
|343| [Какова цель some метода в массивах](#343)|
|344| [Как вы объединяете два или более массива](#344)|
|345| [В чем разница между поверхностной и глубокой копией? Shallow and Deep copy](#345)|
|346| [Как вы создаете определенное количество копий строки](#346)|
|347| [Как вы возвращаете все совпадающие строки с регулярным выражением](#347)|
|348| [Как обрезать строку в начале или в конце](#348)|
|349| [Каков результат приведенного ниже оператора консоли с унарным оператором](#349)|
|350| [Использует ли javascript миксины](#350)|
|351| [Что такое функция thunk](#351)|
|352| [Что такое асинхронный thunks](#352)|
|353| [Каков результат нижеприведенных вызовов функций](#353)|
|354| [Как удалить все разрывы строк из строки](#354)|
|355| [В чем разница между reflow и repaint](#355)|
|356| [Что происходит с отрицанием массива](#356)|
|357| [Что произойдет, если мы добавим два массива](#357)|
|358| [Каков результат аддитивного оператора добавления к ложным значениям](#358)|
|359| [Как вы создаете собственную строку, используя специальные символы](#359)|
|360| [Как удалить ложные значения из массива](#360)|
|361| [Как получить уникальные значения массива](#361)|
|362| [Что такое деструктуризация псевдонимов? aliases](#362)|
|363| [Как вы сопоставляете значения массива без использования метода map](#363)|
|364| [Как очистить массив](#364)|
|365| [Как вы округляете числа до определенных десятичных знаков](#365)|
|366| [Как проще всего преобразовать массив в объект](#366)|
|367| [Как вы создаете массив с некоторыми данными](#367)|
|368| [Что такое placeholders из объекта консоли](#368)|
|369| [Можно ли добавить CSS в консольные сообщения](#369)|
|370| [Какова цель метода dir консольного объекта](#370)|
|371| [Можно ли отлаживать элементы HTML в консоли](#371)|
|372| [Как вы отображаете данные в табличном формате с помощью объекта консоли](#372)|
|373| [Как вы проверяете, является ли аргумент числом или нет](#373)|
|374| [Как создать кнопку копирования в буфер обмена](#374)|
|375| [Как быстро получить метку времени](#375)|
|376| [Как вы сглаживаете многомерные массивы](#376)|
|377| [Какая самая простая проверка нескольких условий](#377)|
|378| [Как вы захватываете кнопку возврата браузера](#378)|
|379| [Как отключить правый клик на веб-странице](#379)|
|380| [Что такое объекты-оболочки](#380)|
|381| [Что тако AJAX](#381)|
|382| [Каковы различные способы работы с асинхронным кодом](#382)|
|383| [Как отменить fetch request](#383)|
|384| [Что такое web speech API](#384)|
|385| [Что такое минимальное регулирование времени ожидания](#385)|
|386| [Как вы реализуете нулевой тайм-аут в современных браузерах](#386)|
|387| [Что такое задачи в цикле событий](#387)|
|388| [Что такое микрозадачи](#388)|
|389| [Чем отличаются циклы событий](#389)|
|390| [Какова цель queueMicrotask](#390)|
|391| [Как вы используете библиотеки javascript в файле typescript](#391)|
|392| [В чем разница между promises and observables? (обещаниями и наблюдаемыми)](#392)|
|393| [Что такое heap](#393)|
|394| [Что такое event table](#394)|
|395| [Что такое очередь микрозадач](#395)|
|396| [В чем разница между shim и polyfill](#396)|
|397| [Как определить примитивный или не примитивный тип значения](#397)|
|398| [Что такое babel](#398)|
|399| [Является ли Node.js полностью однопоточным?](#399)|
|400| [Каковы общие случаи использования observables](#400)|
|401| [Что такое RxJS](#401)|
|402| [В чем разница между Function constructor and function declaration](#402)|
|403| [Что такое короткое замыкание? Short circuit condition](#403)|
|404| [Как проще всего изменить размер массива](#404)|
|405| [Что такое наблюдаемый? observable](#405)|
|406| [В чем разница между function и class declarations](#406)|
|407| [Что такое асинхронная функция](#407)|
|408| [Как не допустить, чтобы promises проглатывали errors?](#408)|
|409| [Что такое deno](#409)|
|410| [Как сделать объект итерируемым в javascript?](#410)|
|411| [Что такое Proper Tail Call](#411)|
|412| [Как вы проверяете, является ли объект promise или нет](#412)|
|413| [Как определить, вызывается ли функция как конструктор](#413)|
|414| [В чем разница между объектом arguments и параметром rest?](#414)|
|415| [В чем разница между оператором spread и rest параметром](#415)|
|416| [Какие бывают виды генераторов](#416)|
|417| [Что такое встроенные итерации](#417)|
|418| [Каковы различия между for...of и for...in statements](#418)|
|419| [Как вы определяете экземплярные и неэкземплярные свойства](#419)|
|420| [В чем разница между isNaN и Number.isNaN?](#420)|
|421| [Как вызвать IIFE без лишних скобок?](#421)|
|422| [Можно ли использовать выражения в switch cases?](#422)|
|423| [Каков самый простой способ игнорировать promise errors?](#423)|
|424| [Как оформить вывод консоли с помощью CSS?](#424)|
|425| [Что такое нулевой оператор объединения (??)?](#425)|
|426| [Как вы группируете и вкладываете консольный вывод?](#426)|
|427| [В чем разница между плотными и разреженными массивами? dense and sparse arrays?](#427)|
|428| [Какие существуют способы создания разреженных массивов? sparse arrays?](#428)|

1. ### <a name="1"></a> Способы создания объектов в JavaScript

   Существует множество способов создания объектов в javascript, как показано ниже.

   1. **Конструктор объекта:**

      Самый простой способ создать пустой объект — использовать конструктор объектов. В настоящее время этот подход не рекомендуется.

      ```javascript
      var object = new Object();
      ```

   2. **Метод создания объекта:**

      Метод create класса Object создает новый объект, передавая объект-прототип в качестве параметра.

      ```javascript
      var object = Object.create(null);
      ```

   3. **Синтаксис литерала объекта:**

      Синтаксис литерала объекта эквивалентен методу create, когда он передает значение null в качестве параметра.

      ```javascript
      var object = {};
      ```

   4. **Конструктор функций:**

      Создайте любую функцию и примените новый оператор для создания экземпляров объекта,

      ```javascript
      function Person(name){
         this.name=name;
         this.age=21;
      }
      var object = new Person("Sudheer");
      ```

   5. **Конструктор функций с прототипом:**

      Это похоже на конструктор функций, но он использует прототип для своих свойств и методов.

      ```javascript
      function Person(){}
      Person.prototype.name = "Sudheer";
      var object = new Person();
      ```

      Это эквивалентно экземпляру, созданному с помощью метода создания объекта с прототипом функции, а затем вызову этой функции с экземпляром и параметрами в качестве аргументов.

      ```javascript
      function func {};

      new func(x, y, z);
      ```

      **(OR)**

      ```javascript
      // Create a new instance using function prototype.
      var newInstance = Object.create(func.prototype)

      // Call the function
      var result = func.call(newInstance, x, y, z),

      // If the result is a non-null object then use it otherwise just use the new instance.
      console.log(result && typeof result === 'object' ? result : newInstance);
      ```

   6. **Синтаксис класса ES6:**

      ES6 представляет функцию класса для создания объектов

      ```javascript
      class Person {
         constructor(name) {
            this.name = name;
         }
      }

      var object = new Person("Sudheer");
      ```

   7. **Одиночный шаблон:**

      Синглтон — это объект, который может быть создан только один раз. Повторные вызовы его конструктора возвращают один и тот же экземпляр, и таким образом можно гарантировать, что они случайно не создадут несколько экземпляров.

      ```javascript
      var object = new function(){
         this.name = "Sudheer";
      }
      ```

      **[⬆ Back to Top](#table-of-contents)**

2. ### <a name="2"></a> Что такое цепочка прототипов?

    **Связывание прототипов** используется для создания новых типов объектов на основе существующих. Это похоже на наследование в языке, основанном на классах.
    
     Прототип экземпляра объекта доступен через свойство **Object.getPrototypeOf(object)** или **__proto__**, тогда как прототип функции конструктора доступен через **Object.prototype**.

    ![Screenshot](images/prototype_chain.png)

    **[⬆ Back to Top](#table-of-contents)**

3. ### <a name="3"></a> В чем разница между Call, Apply и Bind

    Разницу между Call, Apply и Bind можно объяснить с помощью приведенных ниже примеров.

    **Call:** Метод call() вызывает функцию с заданным значением this и аргументами, предоставленными один за другим.

    ```javascript
    var employee1 = {firstName: 'John', lastName: 'Rodson'};
    var employee2 = {firstName: 'Jimmy', lastName: 'Baily'};

    function invite(greeting1, greeting2) {
        console.log(greeting1 + ' ' + this.firstName + ' ' + this.lastName+ ', '+ greeting2);
    }

    invite.call(employee1, 'Hello', 'How are you?'); // Hello John Rodson, How are you?
    invite.call(employee2, 'Hello', 'How are you?'); // Hello Jimmy Baily, How are you?
    ```

    **Apply:** вызывает функцию с заданным значением this и позволяет передавать аргументы в виде массива.

    ```javascript
    var employee1 = {firstName: 'John', lastName: 'Rodson'};
    var employee2 = {firstName: 'Jimmy', lastName: 'Baily'};

    function invite(greeting1, greeting2) {
        console.log(greeting1 + ' ' + this.firstName + ' ' + this.lastName+ ', '+ greeting2);
    }

    invite.apply(employee1, ['Hello', 'How are you?']); // Hello John Rodson, How are you?
    invite.apply(employee2, ['Hello', 'How are you?']); // Hello Jimmy Baily, How are you?
    ```

    **bind:** возвращает новую функцию, позволяющую передавать любое количество аргументов

    ```javascript
    var employee1 = {firstName: 'John', lastName: 'Rodson'};
    var employee2 = {firstName: 'Jimmy', lastName: 'Baily'};

    function invite(greeting1, greeting2) {
        console.log(greeting1 + ' ' + this.firstName + ' ' + this.lastName+ ', '+ greeting2);
    }

    var inviteEmployee1 = invite.bind(employee1);
    var inviteEmployee2 = invite.bind(employee2);
    inviteEmployee1('Hello', 'How are you?'); // Hello John Rodson, How are you?
    inviteEmployee2('Hello', 'How are you?'); // Hello Jimmy Baily, How are you?
    ```

    Call and apply довольно взаимозаменяемы. Оба немедленно выполняют текущую функцию. Вам нужно решить, что проще отправить: массив или список аргументов, разделенных запятыми. Вы можете запомнить, обработав Call для **запятой** (разделенный список), а Apply для **Array**.
    
    Принимая во внимание, что Bind создает новую функцию, у которой this будет установлен на первый параметр, переданный в bind().

    **[⬆ Back to Top](#table-of-contents)**

4. ### <a name="4"></a> Что такое JSON и его общие операции

    **JSON** — это текстовый формат данных, следующий синтаксису объекта JavaScript, популяризированный Дугласом Крокфордом. Это полезно, когда вы хотите передавать данные по сети, и это в основном просто текстовый файл с расширением .json и типом MIME application/json.

    **Parsing:** Преобразование строки в нативный объект

    ```javascript
    JSON.parse(text)
    ```

    **Stringification:** преобразование собственного объекта в строку, чтобы его можно было передавать по сети.

    ```javascript
    JSON.stringify(object)
    ```

    **[⬆ Back to Top](#table-of-contents)**

5. ### <a name="5"></a> Какова цель метода массива slice

    Метод **slice()** возвращает выбранные элементы в массиве как новый объект массива. Он выбирает элементы, начиная с заданного начального аргумента и заканчивая заданным необязательным конечным аргументом, не включая последний элемент. Если вы опустите второй аргумент, он будет выбран до конца.
    
    Некоторые из примеров этого метода:

    ```javascript
    let arrayIntegers = [1, 2, 3, 4, 5];
    let arrayIntegers1 = arrayIntegers.slice(0,2); // returns [1,2]
    let arrayIntegers2 = arrayIntegers.slice(2,3); // returns [3]
    let arrayIntegers3 = arrayIntegers.slice(4); //returns [5]
    ```

    **Примечание.** Метод Slice не изменяет исходный массив, но возвращает подмножество в виде нового массива.

    **[⬆ Back to Top](#table-of-contents)**

6. ### <a name="6"></a> Какова цель метода массива splice

    Метод **splice()** используется для добавления/удаления элементов в/из массива, а затем возвращает удаленный элемент. Первый аргумент указывает позицию массива для вставки или удаления, тогда как необязательный второй аргумент указывает количество элементов, которые необходимо удалить. Каждый дополнительный аргумент добавляется в массив.
    
    Некоторые из примеров этого метода:

    ```javascript
    let arrayIntegersOriginal1 = [1, 2, 3, 4, 5];
    let arrayIntegersOriginal2 = [1, 2, 3, 4, 5];
    let arrayIntegersOriginal3 = [1, 2, 3, 4, 5];

    let arrayIntegers1 = arrayIntegersOriginal1.splice(0,2); // returns [1, 2]; original array: [3, 4, 5]
    let arrayIntegers2 = arrayIntegersOriginal2.splice(3); // returns [4, 5]; original array: [1, 2, 3]
    let arrayIntegers3 = arrayIntegersOriginal3.splice(3, 1, "a", "b", "c"); //returns [4]; original array: [1, 2, 3, "a", "b", "c", 5]
    ```

    **Примечание.** Метод Splice изменяет исходный массив и возвращает удаленный массив.

    **[⬆ Back to Top](#table-of-contents)**

7. ### <a name="7"></a> В чем разница между slice и splice

    Некоторые из основных отличий в табличной форме

     | Slice | Splice |
     |---- | ---------
     | Не изменяет исходный массив (неизменяемый) | Изменяет исходный массив (изменяемый) |
     | Возвращает подмножество исходного массива | Возвращает удаленные элементы в виде массива |
     | Используется для выбора элементов из массива | Используется для вставки или удаления элементов в/из массива|

    **[⬆ Back to Top](#table-of-contents)**

8. ### <a name="8"></a> Как вы сравниваете Object и Map

   **Объекты** аналогичны **Map** в том, что обе позволяют вам устанавливать ключи в значения, извлекать эти значения, удалять ключи и определять, сохранено ли что-то в ключе. По этой причине объекты исторически использовались в качестве карт. Но есть важные отличия, которые делают использование карты предпочтительнее в определенных случаях.

    1. Ключами объекта являются строки и символы, тогда как для карты они могут быть любыми значениями, включая функции, объекты и любые примитивы.
    2. Ключи в Map упорядочены, а ключи, добавленные в объект, - нет. Таким образом, при итерации по нему объект Map возвращает ключи в порядке вставки.
    3. Вы можете легко получить размер Map с помощью свойства размера, в то время как количество свойств в объекте должно быть определено вручную.
    4. Map является итерируемой и, таким образом, может быть итерирована напрямую, тогда как итерация над Объектом требует получения его ключей каким-то образом и итерации по ним.
    5. Объект имеет прототип, поэтому на карте есть ключи по умолчанию, которые могут столкнуться с вашими ключами, если вы не будете осторожны. Начиная с ES5 это можно обойти, используя map = Object.create(null), но это делается редко.
    6. Map может работать лучше в сценариях, связанных с частым добавлением и удалением пар ключей.


    **[⬆ Back to Top](#table-of-contents)**

9. ### <a name="9"></a> В чем разница между операторами == и ===

    JavaScript обеспечивает как строгое (===, !==), так и преобразование типа (==, !=) сравнение на равенство. Строгие операторы учитывают тип переменной, в то время как нестрогие операторы выполняют исправление/преобразование типа на основе значений переменных. Строгие операторы следуют приведенным ниже условиям для разных типов:
    1. Две строки строго равны, если они имеют одинаковую последовательность символов, одинаковую длину и одинаковые символы в соответствующих позициях.
    2. Два числа строго равны, когда они численно равны. т. е. с одинаковым числовым значением.
       Здесь есть два частных случая,
       1. NaN ничему не равен, в том числе и NaN.
       2. Положительные и отрицательные нули равны друг другу.
    3. Два логических операнда строго равны, если оба истинны или оба ложны.
    4. Два объекта строго равны, если они относятся к одному и тому же объекту.
    5. Типы Null и Undefined не равны с ===, но равны с ==. то есть,
        null===undefined --> false, но null==undefined --> true

    Некоторые из примеров, которые охватывают вышеуказанные случаи,

    ```javascript
    0 == false   // true
    0 === false  // false
    1 == "1"     // true
    1 === "1"    // false
    null == undefined // true
    null === undefined // false
    '0' == false // true
    '0' === false // false
    []==[] or []===[] //false, refer different objects in memory
    {}=={} or {}==={} //false, refer different objects in memory
    ```

    **[⬆ Back to Top](#table-of-contents)**

10. ### <a name="10"></a> Что такое лямбда или стрелочные функции

    Стрелочная функция — это более короткий синтаксис функционального выражения и не имеет собственного **this, arguments, super или new.target**. Эти функции лучше всего подходят для функций, не являющихся методами, и их нельзя использовать в качестве конструкторов.

    **[⬆ Back to Top](#table-of-contents)**

11. ### <a name="11"></a> Что такое функция первого класса

    В Javascript функции являются объектами первого класса. Функции первого класса означают, что функции на этом языке обрабатываются как любая другая переменная.

    Например, в таком языке функция может быть передана в качестве аргумента другим функциям, может быть возвращена другой функцией и может быть присвоена как значение переменной. Например, в приведенном ниже примере функции обработчика, назначенные прослушивателю

    ```javascript
    const handler = () => console.log ('This is a click handler function');
    document.addEventListener ('click', handler);
    ```

    **[⬆ Back to Top](#table-of-contents)**

12. ### <a name="12"></a> Что такое функция первого порядка

    Функция первого порядка — это функция, которая не принимает другую функцию в качестве аргумента и не возвращает функцию в качестве возвращаемого значения.

    ```javascript
    const firstOrder = () => console.log ('I am a first order function!');
    ```

    **[⬆ Back to Top](#table-of-contents)**

13. ### <a name="13"></a> Что такое функция высшего порядка

    Функция высшего порядка — это функция, которая принимает другую функцию в качестве аргумента или возвращает функцию в качестве возвращаемого значения, или и то, и другое.

    ```javascript
    const firstOrderFunc = () => console.log ('Hello, I am a First order function');
    const higherOrder = ReturnFirstOrderFunc => ReturnFirstOrderFunc();
    higherOrder(firstOrderFunc);
    ```

    **[⬆ Back to Top](#table-of-contents)**

14. ### <a name="14"></a> Что такое унарная функция

    Унарная функция (т.е. монадическая) — это функция, которая принимает ровно один аргумент. Он обозначает один аргумент, принимаемый функцией.
    
    Возьмем пример унарной функции,

    ```javascript
    const unaryFunction = a => console.log (a + 10); // Add 10 to the given argument and display the value
    ```

    **[⬆ Back to Top](#table-of-contents)**

15. ### <a name="15"></a> Что такое каррирующая функция

    Каррирование — это процесс преобразования функции с несколькими аргументами в последовательность функций, каждая из которых имеет только один аргумент. Каррирование названо в честь математика **Хаскелла Карри**. Применяя каррирование, n-арная функция превращается в унарную.
    
     Давайте рассмотрим пример n-арной функции и того, как она превращается в функцию каррирования,

    ```javascript
    const multiArgFunction = (a, b, c) => a + b + c;
    console.log(multiArgFunction(1,2,3));// 6
    
    const curryUnaryFunction = a => b => c => a + b + c;
    curryUnaryFunction (1); // returns a function: b => c =>  1 + b + c
    curryUnaryFunction (1) (2); // returns a function: c => 3 + c
    curryUnaryFunction (1) (2) (3); // returns the number 6
    ```

    Каррированные функции отлично подходят для улучшения **повторного использования кода** и **функциональной композиции**.

    **[⬆ Back to Top](#table-of-contents)**

16. ### <a name="16"></a> Что такое чистая функция

    **Чистая функция** — это функция, возвращаемое значение которой определяется только ее аргументами без каких-либо побочных эффектов. т. е. если вы вызываете функцию с одними и теми же аргументами «n» раз и «n» раз в приложении, она всегда будет возвращать одно и то же значение.
    
    Давайте возьмем пример, чтобы увидеть разницу между чистыми и нечистыми функциями,

    ```javascript
    //Impure
    let numberArray = [];
    const impureAddNumber = number => numberArray.push(number);
    //Pure
    const pureAddNumber = number => argNumberArray =>
      argNumberArray.concat([number]);

    //Display the results
    console.log (impureAddNumber(6)); // returns 1
    console.log (numberArray); // returns [6]
    console.log (pureAddNumber(7) (numberArray)); // returns [6, 7]
    console.log (numberArray); // returns [6]
    ```

    Согласно приведенным выше фрагментам кода, функция **Push** нечиста сама по себе, изменяя массив и возвращая индекс числа push, который не зависит от значения параметра. В то время как **Concat**, с другой стороны, берет массив и объединяет его с другим массивом, создавая совершенно новый массив без побочных эффектов. Кроме того, возвращаемое значение представляет собой конкатенацию предыдущего массива.
    
    Помните, что чистые функции важны, поскольку они упрощают модульное тестирование без каких-либо побочных эффектов и необходимости внедрения зависимостей. Они также избегают тесной связи и усложняют взлом вашего приложения, поскольку не имеют побочных эффектов. Эти принципы объединяются с концепцией **неизменяемости** ES6, отдавая предпочтение **const** использованию **let**.

    **[⬆ Back to Top](#table-of-contents)**

17. ### <a name="17"></a> Какова цель ключевого слова let

    Оператор `let` объявляет **локальную переменную области блока**. Следовательно, переменные, определенные с помощью ключевого слова let, ограничены областью действия блока, инструкции или выражения, в которых они используются. Принимая во внимание, что переменные, объявленные с помощью ключевого слова `var`, используются для определения переменной глобально или локально для всей функции, независимо от области действия блока.
    
    Давайте возьмем пример, чтобы продемонстрировать использование,

    ```javascript
    let counter = 30;
    if (counter === 30) {
      let counter = 31;
      console.log(counter); // 31
    }
    console.log(counter); // 30 (because the variable in if block won't exist here)
    ```

    **[⬆ Back to Top](#table-of-contents)**

18. ### <a name="18"></a> В чем разница между let и var

    Вы можете перечислить различия в табличном формате

    | var | let |
    |---- | ---------
    | Он был доступен с самого начала JavaScript | Представлено как часть ES6 |
    | Он имеет область действия | Он имеет блочную область видимости |
    | Переменные будут подняты | Поднят, но не инициализирован |

    Давайте возьмем пример, чтобы увидеть разницу,

    ```javascript
    function userDetails(username) {
       if(username) {
         console.log(salary); // undefined due to hoisting
         console.log(age); // ReferenceError: Cannot access 'age' before initialization
         let age = 30;
         var salary = 10000;
       }
       console.log(salary); //10000 (accessible to due function scope)
       console.log(age); //error: age is not defined(due to block scope)
    }
    userDetails('John');
    ```

    **[⬆ Back to Top](#table-of-contents)**

19. ### <a name="19"></a> В чем причина выбора имени let в качестве ключевого слова

    `let` — это математическое выражение, которое было принято ранними языками программирования, такими как **Scheme** и **Basic**. Оно было заимствовано из десятков других языков, в которых `let` уже используется как традиционное ключевое слово, максимально близкое к `var`.

    **[⬆ Back to Top](#table-of-contents)**

20. ### <a name="20"></a> Как повторно объявить переменные в блоке switch без ошибки

    Если вы попытаетесь повторно объявить переменные в «блоке переключения», это вызовет ошибки, потому что блок только один. Например, приведенный ниже блок кода вызывает синтаксическую ошибку, как показано ниже:

    ```javascript
    let counter = 1;
    switch(x) {
      case 0:
        let name;
        break;

      case 1:
        let name; // SyntaxError for redeclaration.
        break;
    }
    ```

    Чтобы избежать этой ошибки, вы можете создать вложенный блок внутри предложения case и создать новую лексическую среду с областью действия блока.

    ```javascript
    let counter = 1;
        switch(x) {
          case 0: {
            let name;
            break;
          }
          case 1: {
            let name; // No SyntaxError for redeclaration.
            break;
          }
        }
    ```

    **[⬆ Back to Top](#table-of-contents)**

21. ### <a name="21"></a> Что такое временная мертвая зона

    Временная мертвая зона — это поведение в JavaScript, возникающее при объявлении переменной с ключевыми словами let и const, но не с var. В ECMAScript 6 доступ к переменной `let` или `const` до ее объявления (в пределах ее области действия) вызывает ошибку ReferenceError. Промежуток времени, когда это происходит, между созданием привязки переменной и ее объявлением, называется временной мертвой зоной.
    
    Давайте посмотрим на это поведение на примере,

    ```javascript
    function somemethod() {
      console.log(counter1); // undefined
      console.log(counter2); // ReferenceError
      var counter1 = 1;
      let counter2 = 2;
    }
    ```

    **[⬆ Back to Top](#table-of-contents)**

22. ### <a name="22"></a> Что такое IIFE (выражение немедленно вызываемой функции)

    IIFE (Immediately Invoked Function Expression) — это функция JavaScript, которая запускается, как только она определена. Подпись будет такой, как показано ниже:

    ```javascript
    (function ()
        {
          // logic here
        }
     )
    ();
    ```

    Основной причиной использования IIFE является обеспечение конфиденциальности данных, поскольку любые переменные, объявленные в IIFE, недоступны для внешнего мира. т. е. если вы попытаетесь получить доступ к переменным с помощью IIFE, он выдаст ошибку, как показано ниже:

    ```javascript
    (function ()
            {
              var message = "IIFE";
              console.log(message);
            }
     )
    ();
    console.log(message); //Error: message is not defined
    ```

    **[⬆ Back to Top](#table-of-contents)**

23. ### <a name="23"></a> Как вы декодируете или кодируете URL-адрес в JavaScript?

    Функция `encodeURL()` используется для кодирования URL. Эта функция требует строку URL в качестве параметра и возвращает эту закодированную строку.
    Функция `decodeURI()` используется для расшифровки URL. Эта функция требует в качестве параметра закодированную строку URL и возвращает эту декодированную строку.

     **Примечание.** Если вы хотите закодировать такие символы, как `/ ? : @ & = + $ #`, тогда вам нужно использовать `encodeURLComponent()`.

     ```javascript
     let uri = "employeeDetails?name=john&occupation=manager";
     let encoded_uri = encodeURI(uri);
     let decoded_uri = decodeURI(encoded_uri);
     ```

    **[⬆ Back to Top](#table-of-contents)**

24. ### <a name="24"></a> Что такое мемоизация

    Мемоизация — это метод программирования, который пытается повысить производительность функции за счет кэширования ее ранее вычисленных результатов. Каждый раз, когда вызывается мемоизированная функция, ее параметры используются для индексации кеша. Если данные присутствуют, то их можно вернуть, не выполняя всю функцию. В противном случае функция выполняется, а затем результат добавляется в кеш.
    Давайте возьмем пример добавления функции с мемоизацией,

    ```javascript
    const memoizAddition = () => {
      let cache = {};
     return (value) => {
      if (value in cache) {
       console.log('Fetching from cache');
       return cache[value]; // Here, cache.value cannot be used as property name starts with the number which is not a valid JavaScript  identifier. Hence, can only be accessed using the square bracket notation.
      }
      else {
       console.log('Calculating result');
       let result = value + 20;
       cache[value] = result;
       return result;
      }
     }
    }
    // returned function from memoizAddition
    const addition = memoizAddition();
    console.log(addition(20)); //output: 40 calculated
    console.log(addition(20)); //output: 40 cached
    ```

    **[⬆ Back to Top](#table-of-contents)**

25. ### <a name="25"></a> Что такое Hoisting

    Подъем — это механизм JavaScript, в котором объявления переменных и функций перемещаются в верхнюю часть своей области видимости перед выполнением кода. Помните, что JavaScript поднимает только объявления, а не инициализацию.
    Возьмем простой пример подъема переменных,

    ```javascript
    console.log(message); //output : undefined
    var message = 'The variable Has been hoisted';
    ```

    Приведенный выше код выглядит так, как показано ниже для интерпретатора,

    ```javascript
    var message;
    console.log(message);
    message = 'The variable Has been hoisted';
    ```

    **[⬆ Back to Top](#table-of-contents)**

26. ### <a name="26"></a> Что такое классы в ES6

    В ES6 классы Javascript в первую очередь являются синтаксическим сахаром по сравнению с существующим в JavaScript наследованием на основе прототипов.
    Например, наследование на основе прототипа, записанное в функциональном выражении, как показано ниже:

    ```javascript
    function Bike(model,color) {
        this.model = model;
        this.color = color;
    }

    Bike.prototype.getDetails = function() {
        return this.model + ' bike has' + this.color + ' color';
    };
    ```

    В то время как классы ES6 могут быть определены как альтернатива

    ```javascript
    class Bike{
      constructor(color, model) {
        this.color= color;
        this.model= model;
      }

      getDetails() {
        return this.model + ' bike has' + this.color + ' color';
      }
    }
    ```

    **[⬆ Back to Top](#table-of-contents)**

27. ### <a name="27"></a> Что такое замыкания

    Замыкание — это комбинация функции и лексического окружения, в котором эта функция была объявлена. т. е. это внутренняя функция, которая имеет доступ к внешним или внешним переменным функции. Закрытие имеет три цепи прицела
    
    1. Собственная область видимости, в которой переменные определены между фигурными скобками.
    2. Переменные внешней функции
    3. Глобальные переменные
    
    Давайте возьмем пример концепции закрытия,

    ```javascript
    function Welcome(name){
      var greetingInfo = function(message){
       console.log(message+' '+name);
      }
    return greetingInfo;
    }
    var myFunction = Welcome('John');
    myFunction('Welcome '); //Output: Welcome John
    myFunction('Hello Mr.'); //output: Hello Mr.John
    ```

    В соответствии с приведенным выше кодом внутренняя функция (т. е. GreetingInfo) имеет доступ к переменным в области действия внешней функции (т. е. Welcome) даже после возврата внешней функции.

    **[⬆ Back to Top](#table-of-contents)**

28. ### <a name="28"></a> Что такое модули

    Модули относятся к небольшим единицам независимого повторно используемого кода, а также служат основой для многих шаблонов проектирования JavaScript. Большинство модулей JavaScript экспортируют литерал объекта, функцию или конструктор.

    **[⬆ Back to Top](#table-of-contents)**

29. ### <a name="29"></a> Зачем нужны модули

    Ниже приведен список преимуществ использования модулей в экосистеме javascript.
    1. Ремонтопригодность
    2. Повторное использование
    3. Пространство имен

    **[⬆ Back to Top](#table-of-contents)**

30. ### <a name="30"></a> Что такое область видимости в javascript

    Область видимости — это доступность переменных, функций и объектов в определенной части вашего кода во время выполнения. Другими словами, область видимости определяет видимость переменных и других ресурсов в областях вашего кода.

    **[⬆ Back to Top](#table-of-contents)**

31. ### <a name="31"></a> Что такое service worker

    Service worker — это в основном сценарий (файл JavaScript), который работает в фоновом режиме, отдельно от веб-страницы и предоставляет функции, которые не требуют веб-страницы или взаимодействия с пользователем. Некоторыми из основных функций сервис-воркеров являются богатый автономный опыт (разработка первых веб-приложений в автономном режиме), периодическая фоновая синхронизация, push-уведомления, перехват и обработка сетевых запросов и программное управление кешем ответов.

    **[⬆ Back to Top](#table-of-contents)**

32. ### <a name="32"></a> Как вы манипулируете DOM с помощью service worker

    Сервисный работник не может получить прямой доступ к DOM. Но он может взаимодействовать со страницами, которыми он управляет, отвечая на сообщения, отправленные через интерфейс postMessage, и эти страницы могут манипулировать DOM.

    **[⬆ Back to Top](#table-of-contents)**

33. ### <a name="33"></a> Как вы повторно используете информацию при перезапуске service worker

    Проблема с сервис-воркером заключается в том, что он завершается, когда не используется, и перезапускается, когда он в следующий раз понадобится, поэтому вы не можете полагаться на глобальное состояние в обработчиках onfetch и onmessage сервис-воркера. В этом случае сервисные работники будут иметь доступ к API IndexedDB для сохранения и повторного использования при перезапусках.

    **[⬆ Back to Top](#table-of-contents)**

34. ### <a name="34"></a> Что такое IndexedDB

    IndexedDB — это низкоуровневый API для хранения на стороне клиента больших объемов структурированных данных, включая файлы и большие двоичные объекты. Этот API использует индексы для обеспечения высокопроизводительного поиска этих данных.

    **[⬆ Back to Top](#table-of-contents)**

35. ### <a name="35"></a> Что такое web storage

   Веб-хранилище — это API, предоставляющий механизм, с помощью которого браузеры могут хранить пары «ключ-значение» локально в браузере пользователя гораздо более интуитивным способом, чем использование файлов cookie. Веб-хранилище предоставляет два механизма для хранения данных на клиенте.
    1. **Local storage:** оно хранит данные для текущего источника без даты истечения срока действия.
    2. **Session storage:** оно хранит данные для одного сеанса, и данные теряются при закрытии вкладки браузера.

    **[⬆ Back to Top](#table-of-contents)**

36. ### <a name="36"></a> Что такое post message

    Post message — это метод, обеспечивающий связь между объектами Window (т. е. между страницей и всплывающим окном, которое она породила, или между страницей и iframe, встроенным в нее). Как правило, сценариям на разных страницах разрешен доступ друг к другу тогда и только тогда, когда страницы следуют политике одного и того же источника (т. е. страницы используют один и тот же протокол, номер порта и хост).

    **[⬆ Back to Top](#table-of-contents)**

37. ### <a name="37"></a> Что такое cookie

    Файл cookie — это фрагмент данных, который хранится на вашем компьютере и к которому может получить доступ ваш браузер. Файлы cookie сохраняются в виде пар ключ/значение.
    Например, вы можете создать файл cookie с именем пользователя, как показано ниже:

    ```javascript
    document.cookie = "username=John";
    ```

    ![Screenshot](images/cookie.png)

    **[⬆ Back to Top](#table-of-contents)**

38. ### <a name="38"></a> Зачем нужны Cookie

    Файлы cookie используются для запоминания информации о профиле пользователя (например, имени пользователя). В основном это включает в себя два шага,
    1. Когда пользователь посещает веб-страницу, профиль пользователя может быть сохранен в файле cookie.
    2. Когда пользователь в следующий раз посещает страницу, файл cookie запоминает профиль пользователя.

    **[⬆ Back to Top](#table-of-contents)**

39. ### <a name="39"></a> Каковы параметры в файле cookie

    Для файла cookie доступно несколько следующих вариантов,
    1. По умолчанию файл cookie удаляется при закрытии браузера, но вы можете изменить это поведение, установив дату истечения срока действия (в формате UTC).

    ```javascript
    document.cookie = "username=John; expires=Sat, 8 Jun 2019 12:00:00 UTC";
    ```

    1. По умолчанию файл cookie принадлежит текущей странице. Но вы можете указать браузеру, к какому пути относится файл cookie, используя параметр пути.

    ```javascript
    document.cookie = "username=John; path=/services";
    ```

    **[⬆ Back to Top](#table-of-contents)**

40. ### <a name="40"></a> Как удалить cookie

    Вы можете удалить файл cookie, установив дату истечения срока действия как прошедшую дату. В этом случае вам не нужно указывать значение cookie.
    Например, вы можете удалить файл cookie имени пользователя на текущей странице, как показано ниже.

    ```javascript
    document.cookie = "username=; expires=Fri, 07 Jun 2019 00:00:00 UTC; path=/;";
    ```

    **Примечание.** Вам следует определить параметр пути к файлу cookie, чтобы убедиться, что вы удаляете нужный файл cookie. Некоторые браузеры не позволяют удалить файл cookie, если вы не укажете параметр пути.

    **[⬆ Back to Top](#table-of-contents)**

41. ### <a name="41"></a> В чем разница между файлами cookie, local storage and session storage

   Ниже приведены некоторые различия между файлами cookie, локальным хранилищем и хранилищем сеансов.

    | Feature | Cookie | Local storage | Session storage |
    |---- | --------- | ----- | ----- |
    | Доступ на стороне клиента или сервера | Как на стороне сервера, так и на стороне клиента | только на стороне клиента | только на стороне клиента |
    | Срок службы | В соответствии с параметром Expires | до удаления | пока вкладка не закрыта |
    | поддержка SSL | Поддерживается | Не поддерживается | Не поддерживается |
    | Максимальный размер данных | 4 КБ | 5 МБ | 5 МБ |

    **[⬆ Back to Top](#table-of-contents)**

42. ### <a name="42"></a> В чем основное различие между localStorage and sessionStorage

    LocalStorage аналогичен SessionStorage, но сохраняет данные даже при закрытии и повторном открытии браузера (т. е. у него нет срока действия), тогда как в sessionStorage данные очищаются при завершении сеанса страницы.

    **[⬆ Back to Top](#table-of-contents)**

43. ### <a name="43"></a> Как получить доступ к веб-хранилищу (web storage)

    Объект Window реализует объекты WindowLocalStorage и WindowSessionStorage, которые имеют свойства localStorage (window.localStorage) и sessionStorage (window.sessionStorage) соответственно. Эти свойства создают экземпляр объекта «Хранилище», с помощью которого можно устанавливать, извлекать и удалять элементы данных для определенного домена и типа хранилища (сессионного или локального).
    Например, вы можете читать и записывать объекты локального хранилища, как показано ниже.

    ```javascript
    localStorage.setItem('logo', document.getElementById('logo').value);
    localStorage.getItem('logo');
    ```

    **[⬆ Back to Top](#table-of-contents)**

44. ### <a name="44"></a> Какие методы доступны в session storage

    Хранилище сеанса предоставляет методы для чтения, записи и очистки данных сеанса.

    ```javascript
    // Save data to sessionStorage
    sessionStorage.setItem('key', 'value');

    // Get saved data from sessionStorage
    let data = sessionStorage.getItem('key');

    // Remove saved data from sessionStorage
    sessionStorage.removeItem('key');

    // Remove all saved data from sessionStorage
    sessionStorage.clear();
    ```

    **[⬆ Back to Top](#table-of-contents)**

45. ### <a name="45"></a> Что такое storage event и его обработчик событий

    StorageEvent — это событие, которое срабатывает при изменении области хранения в контексте другого документа. Принимая во внимание, что свойство onstorage — это EventHandler для обработки событий хранилища.
    Синтаксис будет таким, как показано ниже

    ```javascript
     window.onstorage = functionRef;
    ```

    Давайте рассмотрим пример использования обработчика событий onstorage, который регистрирует ключ хранилища и его значения.

    ```javascript
    window.onstorage = function(e) {
      console.log('The ' + e.key +
        ' key has been changed from ' + e.oldValue +
        ' to ' + e.newValue + '.');
    };
    ```

    **[⬆ Back to Top](#table-of-contents)**

46. ### <a name="46"></a> Зачем тебе нужно web storage

    Веб-хранилище более безопасно, и большие объемы данных можно хранить локально, не влияя на производительность веб-сайта. Также информация никогда не передается на сервер. Следовательно, это более рекомендуемый подход, чем файлы cookie.

    **[⬆ Back to Top](#table-of-contents)**

47. ### <a name="47"></a> Как вы проверяете поддержку браузера web storage

    Перед использованием веб-хранилища необходимо проверить поддержку браузером localStorage и sessionStorage.

    ```javascript
    if (typeof(Storage) !== "undefined") {
      // Code for localStorage/sessionStorage.
    } else {
      // Sorry! No Web Storage support..
    }
    ```

    **[⬆ Back to Top](#table-of-contents)**

48. ### <a name="48"></a> Как вы проверяете поддержку браузера workers

    Вам необходимо проверить поддержку браузера для веб-воркеров, прежде чем использовать его.

    ```javascript
    if (typeof(Worker) !== "undefined") {
      // code for Web worker support.
    } else {
      // Sorry! No Web Worker support..
    }
    ```

    **[⬆ Back to Top](#table-of-contents)**

49. ### <a name="49"></a> Приведите пример web worker

    Вам необходимо выполнить следующие шаги, чтобы начать использовать веб-воркеров для примера подсчета
    1. Создайте файл Web Worker: вам нужно написать сценарий для увеличения значения счетчика. Назовем его counter.js

    ```javascript
    let i = 0;

    function timedCount() {
      i = i + 1;
      postMessage(i);
      setTimeout("timedCount()",500);
    }

    timedCount();
    ```

    Здесь метод postMessage() используется для отправки сообщения обратно на HTML-страницу.
    1. Создайте объект веб-воркеров: вы можете создать объект веб-воркеров, проверив поддержку браузера. Назовем этот файл как web_worker_example.js

    ```javascript
    if (typeof(w) == "undefined") {
      w = new Worker("counter.js");
    }
    ```

    и мы можем получать сообщения от веб-воркер

    ```javascript
    w.onmessage = function(event){
      document.getElementById("message").innerHTML = event.data;
    };
    ```

    1. Завершить работу веб-воркера:
    Веб-воркеры будут продолжать прослушивать сообщения (даже после завершения внешнего сценария) до тех пор, пока он не будет завершен. Вы можете использовать метод terminate(), чтобы прекратить прослушивание сообщений.

    ```javascript
    w.terminate();
    ```

    1. Повторно используйте веб-воркер: если вы установите для рабочей переменной значение undefined, вы можете повторно использовать код

    ```javascript
    w = undefined;
    ```

    **[⬆ Back to Top](#table-of-contents)**

50. ### <a name="50"></a> Каковы ограничения web workers в DOM

    WebWorkers не имеют доступа к нижеприведенным объектам javascript, поскольку они определены во внешних файлах.
    1. Оконный объект
    2. Объект документа
    3. Родительский объект

    **[⬆ Back to Top](#table-of-contents)**

51. ### <a name="51"></a> Что такое promise

    Промис — это объект, который когда-нибудь в будущем может создать одно значение либо с разрешенным значением, либо с причиной, по которой оно не разрешено (например, сетевая ошибка). Он будет находиться в одном из трех возможных состояний: выполнено, отклонено или находится в ожидании.

    Синтаксис создания Promise выглядит следующим образом:

    ```javascript
        const promise = new Promise(function(resolve, reject) {
          // promise description
        })
    ```

    Использование обещания будет следующим:

    ```javascript
    const promise = new Promise(resolve => {
      setTimeout(() => {
        resolve("I'm a Promise!");
      }, 5000);
    }, reject => {

    });

    promise.then(value => console.log(value));
    ```

    Поток действий обещания будет таким, как показано ниже:

    ![Screenshot](images/promises.png)

    **[⬆ Back to Top](#table-of-contents)**

52. ### <a name="52"></a> Зачем вам нужен promise

    Промисы используются для обработки асинхронных операций. Они обеспечивают альтернативный подход к обратным вызовам, уменьшая ад обратных вызовов и создавая более чистый код.

    **[⬆ Back to Top](#table-of-contents)**

53. ### <a name="53"></a> Каковы три состояния promise

    Promise имеют три состояния:
    1. **Pending:** Это начальное состояние промиса перед началом операции.
    2. **Fulfilled:** Это состояние указывает на то, что указанная операция была завершена.
    3. **Rejected:** Это состояние означает, что операция не завершена. В этом случае будет выдано значение ошибки.

    **[⬆ Back to Top](#table-of-contents)**

54. ### <a name="54"></a> Что такое callback function

    Функция обратного вызова — это функция, которая передается в другую функцию в качестве аргумента. Эта функция вызывается внутри внешней функции для завершения действия.
    Давайте рассмотрим простой пример использования функции обратного вызова.

    ```javascript
    function callbackFunction(name) {
      console.log('Hello ' + name);
    }

    function outerFunction(callback) {
      let name = prompt('Please enter your name.');
      callback(name);
    }

    outerFunction(callbackFunction);
    ```

    **[⬆ Back to Top](#table-of-contents)**

55. ### <a name="55"></a> Зачем нам нужны callbacks

    Обратные вызовы необходимы, потому что javascript — это язык, управляемый событиями. Это означает, что вместо ожидания ответа javascript будет продолжать выполняться, прослушивая другие события.
    Давайте возьмем пример с первой функцией, вызывающей вызов API (симулируемой setTimeout), и следующей функцией, которая регистрирует сообщение.

    ```javascript
    function firstFunction(){
      // Simulate a code delay
      setTimeout( function(){
        console.log('First function called');
      }, 1000 );
    }
    function secondFunction(){
      console.log('Second function called');
    }
    firstFunction();
    secondFunction();

    Output
    // Second function called
    // First function called
    ```

    Как видно из вывода, javascript не дождался ответа первой функции, и был выполнен оставшийся блок кода. Таким образом, обратные вызовы используются таким образом, чтобы гарантировать, что определенный код не будет выполняться до тех пор, пока другой код не завершит выполнение.

    **[⬆ Back to Top](#table-of-contents)**

56. ### <a name="56"></a> Что такое callback hell

    Callback Hell — это антишаблон с несколькими вложенными обратными вызовами, который затрудняет чтение и отладку кода при работе с асинхронной логикой. Ад обратного вызова выглядит следующим образом:

    ```javascript
    async1(function(){
        async2(function(){
            async3(function(){
                async4(function(){
                    ....
                });
            });
        });
    });
    ```

    **[⬆ Back to Top](#table-of-contents)**

57. ### <a name="57"></a> Что такое server-sent events

    Server-sent events (SSE), — это технология отправки сервером, позволяющая браузеру получать автоматические обновления с сервера через HTTP-соединение, не прибегая к опросу. Это односторонний канал связи — события передаются только от сервера к клиенту. Это использовалось в обновлениях Facebook/Twitter, обновлениях цен на акции, новостных лентах и ​​т. д.

    **[⬆ Back to Top](#table-of-contents)**

58. ### <a name="58"></a> Как вы получаете уведомления о событиях server-sent event

    Объект EventSource используется для получения уведомлений о событиях, отправленных сервером. Например, вы можете получать сообщения с сервера, как показано ниже:

    ```javascript
    if(typeof(EventSource) !== "undefined") {
      var source = new EventSource("sse_generator.js");
      source.onmessage = function(event) {
        document.getElementById("output").innerHTML += event.data + "<br>";
      };
    }
    ```

    **[⬆ Back to Top](#table-of-contents)**

59. ### <a name="59"></a> Как вы проверяете поддержку браузером событий server-sent events

    Вы можете выполнить поддержку браузера для событий, отправленных сервером, прежде чем использовать его, как показано ниже:

    ```javascript
    if(typeof(EventSource) !== "undefined") {
      // Server-sent events supported. Let's have some code here!
    } else {
      // No server-sent events supported
    }
    ```

    **[⬆ Back to Top](#table-of-contents)**

60. ### <a name="60"></a> Какие события доступны для событий server sent

   Ниже приведен список событий, доступных для событий, отправленных сервером.
    | Event | Description |
    |---- | ---------
    | onopen | Используется при открытии соединения с сервером |
    | onmessage | Это событие используется при получении сообщения |
    | onerror | Это происходит, когда возникает ошибка|

    **[⬆ Back to Top](#table-of-contents)**

61. ### <a name="61"></a> Каковы основные правила promise

    Обещание должно соответствовать определенному набору правил,
    1. Promise — это объект, предоставляющий стандартный метод `.then()`
    2. Незавершенное обещание может перейти в состояние выполнено или отклонено.
    3. Выполненное или отклоненное обещание урегулировано и не должно переходить в какое-либо другое состояние.
    4. После того, как обещание выполнено, значение не должно меняться.

    **[⬆ Back to Top](#table-of-contents)**

62. ### <a name="62"></a> Что такое callback in callback

    Вы можете вложить один обратный вызов в другой обратный вызов, чтобы выполнять действия последовательно одно за другим. Это известно как обратные вызовы в обратных вызовах.

    ```javascript
    loadScript('/script1.js', function(script) {
       console.log('first script is loaded');

      loadScript('/script2.js', function(script) {

        console.log('second script is loaded');

        loadScript('/script3.js', function(script) {

            console.log('third script is loaded');
          // after all scripts are loaded
        });

      })

    });
    ```

    **[⬆ Back to Top](#table-of-contents)**

63. ### <a name="63"></a> Что такое цепочка promise

    Процесс выполнения последовательности асинхронных задач одна за другой с использованием промисов известен как цепочка промисов. Давайте возьмем пример цепочки промисов для вычисления конечного результата,

    ```javascript
    new Promise(function(resolve, reject) {

      setTimeout(() => resolve(1), 1000);

    }).then(function(result) {

      console.log(result); // 1
      return result * 2;

    }).then(function(result) {

      console.log(result); // 2
      return result * 3;

    }).then(function(result) {

      console.log(result); // 6
      return result * 4;

    });
    ```

    В приведенных выше обработчиках результат передается в цепочку обработчиков .then() с приведенным ниже рабочим процессом:
    1. Первоначальный промис разрешается за 1 секунду,
    2. После этого вызывается обработчик `.then`, который регистрирует результат(1) и затем возвращает промис со значением результата * 2.
    3. После этого значение передается следующему обработчику `.then`, регистрируя результат(2) и возвращая промис с результатом * 3.
    4. Наконец, значение передается последнему обработчику `.then` путем регистрации результата (6) и возврата обещания с результатом * 4.

    **[⬆ Back to Top](#table-of-contents)**

64. ### <a name="64"></a> Что такое promise.all

    Promise.all — это промис, который принимает массив промисов в качестве входных данных (итерируемый), и он разрешается, когда все промисы разрешаются или любое из них отклоняется. Например, синтаксис метода promise.all приведен ниже:

    ```javascript
    Promise.all([Promise1, Promise2, Promise3]) .then(result) => {   console.log(result) }) .catch(error => console.log(`Error in promises ${error}`))
    ```

    **Примечание.** Помните, что порядок промисов (вывод результата) поддерживается в соответствии с порядком ввода.

    **[⬆ Back to Top](#table-of-contents)**

65. ### <a name="65"></a> Какова цель метода race в promise

    Метод Promise.race() вернет экземпляр обещания, которое сначала разрешено или отклонено. Давайте возьмем пример метода race(), где promise2 разрешается первым.

    ```javascript
    var promise1 = new Promise(function(resolve, reject) {
        setTimeout(resolve, 500, 'one');
    });
    var promise2 = new Promise(function(resolve, reject) {
        setTimeout(resolve, 100, 'two');
    });

    Promise.race([promise1, promise2]).then(function(value) {
      console.log(value); // "two" // Both promises will resolve, but promise2 is faster
    });
    ```

    **[⬆ Back to Top](#table-of-contents)**

66. ### <a name="66"></a> Что такое строгий режим в javascript? (strict mode)

    Строгий режим — это новая функция ECMAScript 5, которая позволяет поместить программу или функцию в «строгий» рабочий контекст. Таким образом, он предотвращает выполнение определенных действий и создает больше исключений. Буквальное выражение «use strict» указывает браузеру использовать код javascript в строгом режиме.

    **[⬆ Back to Top](#table-of-contents)**

67. ### <a name="67"></a> Зачем нам нужно strict mode

    Строгий режим полезен для написания «безопасного» JavaScript, уведомляя «плохой синтаксис» о реальных ошибках. Например, он исключает случайное создание глобальной переменной путем выдачи ошибки, а также выдает ошибку при присвоении недоступному для записи свойству, свойству только для получения, несуществующему свойству, несуществующей переменной или не- существующий объект.

    **[⬆ Back to Top](#table-of-contents)**

68. ### <a name="68"></a> Как вы объявляете strict mode

    Строгий режим объявляется добавлением «use strict»; в начало скрипта или функции.
    Если он объявлен в начале скрипта, он имеет глобальную область действия.

    ```javascript
    "use strict";
    x = 3.14; // This will cause an error because x is not declared
    ```

    и если вы объявляете внутри функции, она имеет локальную область видимости

    ```javascript
    x = 3.14;       // This will not cause an error.
    myFunction();

    function myFunction() {
      "use strict";
      y = 3.14;   // This will cause an error
    }
    ```

    **[⬆ Back to Top](#table-of-contents)**

69. ### <a name="69"></a> Какова цель двойного восклицательного знака

    Двойной восклицательный знак или отрицание (!!) гарантирует, что результирующий тип является логическим. Если оно было ложным (например, 0, null, undefined и т. д.), оно будет ложным, иначе — истинным.
    Например, вы можете проверить версию IE, используя это выражение, как показано ниже:

    ```javascript
    let isIE8 = false;
    isIE8 = !! navigator.userAgent.match(/MSIE 8.0/);
    console.log(isIE8); // returns true or false
    ```

    Если вы не используете это выражение, оно возвращает исходное значение.

    ```javascript
    console.log(navigator.userAgent.match(/MSIE 8.0/));  // returns either an Array or null
    ```

    **Примечание.** Выражение !! не является оператором, а просто в два раза больше ! оператор.

    **[⬆ Back to Top](#table-of-contents)**

70. ### <a name="70"></a> Какова цель оператора удаления

    Ключевое слово delete используется для удаления свойства, а также его значения.

    ```javascript
    var user= {name: "John", age:20};
    delete user.age;

    console.log(user); // {name: "John"}
    ```

    **[⬆ Back to Top](#table-of-contents)**

71. ### <a name="71"></a> Что такое оператор typeof

    Вы можете использовать оператор JavaScript typeof, чтобы найти тип переменной JavaScript. Он возвращает тип переменной или выражения.

    ```javascript
    typeof "John Abraham"     // Returns "string"
    typeof (1 + 2)        // Returns "number"
    ```

    **[⬆ Back to Top](#table-of-contents)**

72. ### <a name="72"></a> Что такое undefined свойство

    Свойство undefined указывает, что переменной не присвоено значение или она вообще не объявлена. Тип неопределенного значения также не определен.

    ```javascript
    var user;    // Value is undefined, type is undefined
    console.log(typeof(user)) //undefined
    ```

    Любую переменную можно очистить, установив для нее значение undefined.

    ```javascript
    user = undefined
    ```

    **[⬆ Back to Top](#table-of-contents)**

73. ### <a name="73"></a> Что такое значение null

    Значение null представляет преднамеренное отсутствие какого-либо значения объекта. Это одно из примитивных значений JavaScript. Тип нулевого значения — объект.
    Вы можете очистить переменную, установив значение null.

    ```javascript
    var user = null;
    console.log(typeof(user)) //object
    ```

    **[⬆ Back to Top](#table-of-contents)**

74. ### <a name="74"></a> В чем разница между null и undefined

   Ниже приведены основные различия между null и undefined,

    | Null | Undefined |
    |---- | -----------|
    | Это значение присваивания, которое указывает, что переменная не указывает ни на какой объект. | Это не значение присваивания, когда переменная была объявлена, но еще не получила значение. |
    | Тип null - это объект | Тип undefined не определен |
    | Нулевое значение — это примитивное значение, представляющее нулевую, пустую или несуществующую ссылку. | Значение undefined — это примитивное значение, используемое, когда переменной не присвоено значение.|
    | Указывает на отсутствие значения переменной | Указывает на отсутствие самой переменной |
    | Преобразуется в ноль (0) при выполнении примитивных операций | Преобразовано в NaN при выполнении примитивных операций |

   **[⬆ Back to Top](#table-of-contents)**

75. ### <a name="75"></a> Что тако eval

    Функция eval() оценивает код JavaScript, представленный в виде строки. Строка может быть выражением JavaScript, переменной, оператором или последовательностью операторов.

    ```javascript
    console.log(eval('1 + 2')); //  3
    ```

    **[⬆ Back to Top](#table-of-contents)**

76. ### <a name="76"></a> В чем разница между window и document

   Ниже приведены основные различия между окном и документом.

    | Window | Document |
    |---- | ---------
    | Это корневой элемент любой веб-страницы | Это прямой потомок объекта окна. Это также известно как объектная модель документа (DOM) |
    | По умолчанию объект окна доступен неявно на странице | Вы можете получить к нему доступ через window.document или document. |
    | Он имеет такие методы, как alert(), confirm() и такие свойства, как document, location | Он предоставляет такие методы, как getElementById, getElementsByTagName, createElement и т. д. |

   **[⬆ Back to Top](#table-of-contents)**

77. ### <a name="77"></a> Как вы получаете доступ к history в javascript

    Объект window.history содержит историю браузера. Вы можете загрузить предыдущий и следующий URL-адреса в истории, используя методы back() и next().

    ```javascript
    function goBack() {
      window.history.back()
    }
    function goForward() {
      window.history.forward()
    }
    ```

    *Примечание.** Вы также можете получить доступ к истории без префикса окна.

    **[⬆ Back to Top](#table-of-contents)**

78. ### <a name="78"></a> Как определить, включена клавиша Caps Lock или нет?

    `mouseEvent getModifierState()` используется для возврата логического значения, указывающего, активирована ли указанная клавиша-модификатор или нет. Такие модификаторы, как CapsLock, ScrollLock и NumLock, активируются при нажатии на них и деактивируются при повторном нажатии.
    
    Давайте возьмем элемент ввода для определения включения/выключения CapsLock на примере:
    
    ```html
        <input type="password" onmousedown="enterInput(event)">
          
        <p id="feedback"></p>
          
        <script>
        function enterInput(e) {
          var flag = e.getModifierState("CapsLock");
          if(flag) {
              document.getElementById("feedback").innerHTML = "CapsLock activated";
              
          } else {
              document.getElementById("feedback").innerHTML = "CapsLock not activated";
          }
        }
        </script>
    ```

    **[⬆ Back to Top](#table-of-contents)**

79. ### <a name="79"></a> Что такое isNaN

    Функция isNaN() используется для определения того, является ли значение недопустимым числом (Not-a-Number) или нет. т. е. эта функция возвращает значение true, если значение равно NaN. В противном случае он возвращает ложь.

    ```javascript
    isNaN('Hello') //true
    isNaN('100') //false
    ```

    **[⬆ Back to Top](#table-of-contents)**

80. ### <a name="80"></a> В чем разница между undeclared и undefined переменными

   Ниже приведены основные различия между необъявленными и неопределенными переменными.

    | undeclared | undefined |
    |---- | ---------
    | Эти переменные не существуют в программе и не объявлены | Эти переменные объявлены в программе, но им не присвоено никакого значения |
    | Если вы попытаетесь прочитать значение необъявленной переменной, то возникнет ошибка времени выполнения | Если вы попытаетесь прочитать значение неопределенной переменной, будет возвращено неопределенное значение. |

   **[⬆ Back to Top](#table-of-contents)**

81. ### <a name="81"></a> Что такое глобальные переменные

    Глобальные переменные — это те, которые доступны по всей длине кода без какой-либо области видимости. Ключевое слово var используется для объявления локальной переменной, но если вы его опустите, оно станет глобальной переменной.

    ```javascript
    msg = "Hello" // var is missing, it becomes global variable
    ```

    **[⬆ Back to Top](#table-of-contents)**

82. ### <a name="82"></a> Какие проблемы с глобальными переменными

    Проблема с глобальными переменными заключается в конфликте имен переменных локальной и глобальной области видимости. Также трудно отлаживать и тестировать код, использующий глобальные переменные.

    **[⬆ Back to Top](#table-of-contents)**

83. ### <a name="83"></a> Что такое свойство NaN

    Свойство NaN — это глобальное свойство, представляющее значение «не число». т. е. указывает, что значение не является допустимым числом. NaN очень редко используется в программе, но в некоторых случаях его можно использовать в качестве возвращаемого значения.

    ```javascript
    Math.sqrt(-1)
    parseInt("Hello")
    ```

    **[⬆ Back to Top](#table-of-contents)**

84. ### <a name="84"></a> Какова цель функции isFinite

    Функция isFinite() используется для определения того, является ли число конечным допустимым числом. Он возвращает false, если значение равно +infinity, -infinity или NaN (Not-a-Number), в противном случае возвращает true.

    ```javascript
    isFinite(Infinity);  // false
    isFinite(NaN);       // false
    isFinite(-Infinity); // false

    isFinite(100);         // true
    ```

    **[⬆ Back to Top](#table-of-contents)**

85. ### <a name="85"></a> Что такое поток событий? (event flow)

   Event flow (Поток событий) — это порядок, в котором события приходят на веб-страницу. Когда вы щелкаете элемент, который вложен в различные другие элементы, прежде чем ваш щелчок действительно достигнет места назначения или целевого элемента, он должен сначала инициировать событие щелчка для каждого из своих родительских элементов, начиная сверху с объекта глобального окна.
    Есть два пути потока событий
    1. Сверху вниз (захват событий)
    2. Снизу вверх (пузырьковое отображение событий)

   **[⬆ Back to Top](#table-of-contents)**

86. ### <a name="86"></a> Что такое event bubbling

   Всплытие (Event bubbling) событий — это тип распространения событий, при котором событие сначала запускается для самого внутреннего целевого элемента, а затем последовательно запускается для предков (родителей) целевого элемента в той же иерархии вложенности, пока не достигнет самого внешнего элемента DOM.

   **[⬆ Back to Top](#table-of-contents)**

87. ### <a name="87"></a> Что такое захват событий? (event capturing)

   Захват события — это тип распространения события, при котором событие сначала захватывается самым внешним элементом, а затем последовательно запускается для потомков (дочерних элементов) целевого элемента в той же иерархии вложенности, пока не достигнет самого внутреннего элемента DOM.

   **[⬆ Back to Top](#table-of-contents)**

88. ### <a name="88"></a> Как отправить форму с помощью JavaScript

    Вы можете отправить форму, используя `document.forms[0].submit()`. Вся информация ввода формы отправляется с использованием обработчика события onsubmit.

    ```javascript
    function submit() {
        document.forms[0].submit();
    }
    ```

    **[⬆ Back to Top](#table-of-contents)**

89. ### <a name="89"></a> Как найти сведения об операционной системе

    Объект window.navigator содержит информацию об ОС браузера посетителя. Некоторые свойства ОС доступны в свойствах платформы,

    ```javascript
    console.log(navigator.platform);
    ```

    **[⬆ Back to Top](#table-of-contents)**

90. ### <a name="90"></a> В чем разница между document load и DOMContentLoaded событиями

    Событие `DOMContentLoaded` запускается, когда исходный HTML-документ полностью загружен и проанализирован, не дожидаясь завершения загрузки ресурсов (таблиц стилей, изображений и подфреймов). Принимая во внимание, что событие загрузки запускается, когда вся страница загружена, включая все зависимые ресурсы (таблицы стилей, изображения).

    **[⬆ Back to Top](#table-of-contents)**

91. ### <a name="91"></a> В чем разница между native, host и user objects

   `Native objects` — это объекты, которые являются частью языка JavaScript, определенного спецификацией ECMAScript. Например, основные объекты String, Math, RegExp, Object, Function и т. д., определенные в спецификации ECMAScript.
    `Host objects` — это объекты, предоставляемые браузером или средой выполнения (Node). Например, окно, XmlHttpRequest, узлы DOM и т. д. считаются хост-объектами.
    `User objects` — это объекты, определенные в коде javascript. Например, объекты пользователя, созданные для информации профиля.

   **[⬆ Back to Top](#table-of-contents)**

92. ### <a name="92"></a> Какие инструменты или методы используются для отладки кода JavaScript

    Вы можете использовать приведенные ниже инструменты или методы для отладки javascript.
    1. Chrome DevTools
    2. оператор отладчика
    3. Старый добрый оператор console.log

    **[⬆ Back to Top](#table-of-contents)**

93. ### <a name="93"></a> Каковы плюсы и минусы promises над callbacks

    Ниже приведен список плюсов и минусов promises по сравнению с callbacks.

    **Плюсы:**
    1. Это позволяет избежать ада обратных вызовов, который не читается
    2. Легко написать последовательный асинхронный код с помощью .then()
    3. Простота написания параллельного асинхронного кода с помощью Promise.all()
    4. Решает некоторые распространенные проблемы обратных вызовов (вызывать обратный вызов слишком поздно, слишком рано, много раз и проглатывать ошибки/исключения)

    **Минусы:**
    1. Это делает небольшой сложный код
    2. Вам нужно загрузить полифилл, если ES6 не поддерживается

    **[⬆ Back to Top](#table-of-contents)**

94. ### <a name="94"></a> В чем разница между атрибутом и свойством

    Атрибуты определяются в разметке HTML, тогда как свойства определяются в DOM. Например, приведенный ниже HTML-элемент имеет 2 типа атрибута и значение,

    ```javascript
    <input type="text" value="Name:">
    ```

    Вы можете получить значение атрибута, как показано ниже,

    ```javascript
    const input = document.querySelector('input');
    console.log(input.getAttribute('value')); // Good morning
    console.log(input.value); // Good morning
    ```

    И после того, как вы измените значение текстового поля на «Добрый вечер», оно становится таким

    ```javascript
    console.log(input.getAttribute('value')); // Good morning
    console.log(input.value); // Good evening
    ```

    **[⬆ Back to Top](#table-of-contents)**

95. ### <a name="95"></a> Что такое same-origin policy

    Политика одного и того же источника — это политика, запрещающая JavaScript выполнять запросы через границы домена. Источник определяется как комбинация схемы URI, имени хоста и номера порта. Если вы включите эту политику, она не позволит вредоносному сценарию на одной странице получить доступ к конфиденциальным данным на другой веб-странице с помощью объектной модели документа (DOM).

    **[⬆ Back to Top](#table-of-contents)**

96. ### <a name="96"></a> Какова цель void 0

    Void(0) используется для предотвращения обновления страницы. Это будет полезно для устранения нежелательного побочного эффекта, поскольку будет возвращено неопределенное примитивное значение. Он обычно используется для документов HTML, в которых используется href="JavaScript:Void(0);" внутри элемента ```<a>```. т. е. когда вы щелкаете ссылку, браузер загружает новую страницу или обновляет ту же страницу. Но это поведение будет предотвращено с помощью этого выражения.
    Например, приведенная ниже ссылка уведомляет о сообщении без перезагрузки страницы.

    ```javascript
    <a href="JavaScript:void(0);" onclick="alert('Well done!')">Click Me!</a>
    ```

    **[⬆ Back to Top](#table-of-contents)**

97. ### <a name="97"></a> Является ли JavaScript компилируемым или интерпретируемым языком

    JavaScript — это интерпретируемый язык, а не компилируемый. Интерпретатор в браузере читает код JavaScript, интерпретирует каждую строку и запускает его. В настоящее время современные браузеры используют технологию, известную как компиляция Just-In-Time (JIT), которая компилирует JavaScript в исполняемый байт-код непосредственно перед запуском.

    **[⬆ Back to Top](#table-of-contents)**

98. ### <a name="98"></a> Является ли JavaScript языком с учетом регистра

    Да, JavaScript — это язык, чувствительный к регистру. Ключевые слова языка, переменные, имена функций и объектов, а также любые другие идентификаторы всегда должны быть набраны с постоянным использованием заглавных букв.

    **[⬆ Back to Top](#table-of-contents)**

99. ### <a name="99"></a> Есть ли какая-либо связь между Java и JavaScript

    Нет, это совершенно два разных языка программирования и не имеют ничего общего друг с другом. Но оба они являются языками объектно-ориентированного программирования и, как и многие другие языки, следуют аналогичному синтаксису для основных функций (если, иначе, для, переключать, прерывать, продолжать и т. д.).

    **[⬆ Back to Top](#table-of-contents)**

100. ### <a name="100"></a> Что такое события

     События — это «вещи», которые происходят с элементами HTML. Когда JavaScript используется на HTML-страницах, JavaScript может «реагировать» на эти события. Некоторые из примеров событий HTML:

     1. Веб-страница завершила загрузку
     2. Поле ввода было изменено
     3. Кнопка была нажата

     Опишем поведение события клика для элемента кнопки,

     ```javascript
     <!doctype html>
     <html>
      <head>
        <script>
          function greeting() {
            alert('Hello! Good morning');
          }
        </script>
      </head>
      <body>
        <button type="button" onclick="greeting()">Click me</button>
      </body>
     </html>
     ```

     **[⬆ Back to Top](#table-of-contents)**

101. ### <a name="101"></a> Кто создал javascript

     JavaScript был создан Бренданом Эйхом в 1995 году, когда он работал в Netscape Communications. Первоначально он был разработан под названием «Mocha», но позже язык был официально назван «LiveScript», когда он впервые появился в бета-версиях Netscape.

     **[⬆ Back to Top](#table-of-contents)**

102. ### <a name="102"></a> Какая польза от метода preventDefault

     Метод preventDefault() отменяет событие, если оно может быть отменено, что означает, что действие или поведение по умолчанию, относящееся к событию, не произойдет. Например, запретить отправку формы при нажатии на кнопку отправки и запретить открытие URL-адреса страницы при нажатии на гиперссылку — вот некоторые распространенные варианты использования.

     ```javascript
     document.getElementById("link").addEventListener("click", function(event){
      event.preventDefault();
     });
     ```

     **Примечание.** Помните, что не все мероприятия можно отменить.

     **[⬆ Back to Top](#table-of-contents)**

103. ### <a name="103"></a> Какая польза от метода stopPropagation

     Метод stopPropagation используется для предотвращения всплытия события в цепочке событий. Например, приведенные ниже вложенные элементы div с методом stopPropagation предотвращают распространение события по умолчанию при нажатии на вложенный элемент div (Div1).

     ```javascript
     <p>Click DIV1 Element</p>
     <div onclick="secondFunc()">DIV 2
       <div onclick="firstFunc(event)">DIV 1</div>
     </div>

     <script>
     function firstFunc(event) {
       alert("DIV 1");
       event.stopPropagation();
     }

     function secondFunc() {
       alert("DIV 2");
     }
     </script>
     ```

     **[⬆ Back to Top](#table-of-contents)**

104. ### <a name="104"></a> Каковы шаги, связанные с возвратом false

     Оператор return false в обработчиках событий выполняет следующие шаги:

     1. Сначала он останавливает действие или поведение браузера по умолчанию.
     2. Это предотвращает распространение события в DOM
     3. Останавливает выполнение обратного вызова и немедленно возвращается при вызове.

     **[⬆ Back to Top](#table-of-contents)**

105. ### <a name="105"></a> Что такое BOM

     Объектная модель браузера (BOM) позволяет JavaScript «общаться» с браузером. Он состоит из объектов навигатора, истории, экрана, местоположения и документа, которые являются дочерними элементами окна. Объектная модель браузера не стандартизирована и может изменяться в зависимости от разных браузеров.

     ![Screenshot](images/bom.png)

     **[⬆ Back to Top](#table-of-contents)**

106. ### <a name="106"></a> Какая польза от setTimeout

     Метод setTimeout() используется для вызова функции или вычисления выражения по истечении заданного количества миллисекунд. Например, давайте зарегистрируем сообщение через 2 секунды, используя метод setTimeout,

     ```javascript
     setTimeout(function(){ console.log("Good morning"); }, 2000);
     ```

     **[⬆ Back to Top](#table-of-contents)**

107. ### <a name="107"></a> Какая польза от setInterval

     Метод setInterval() используется для вызова функции или вычисления выражения с заданными интервалами (в миллисекундах). Например, давайте зарегистрируем сообщение через 2 секунды, используя метод setInterval,

     ```javascript
     setInterval(function(){ console.log("Good morning"); }, 2000);
     ```

     **[⬆ Back to Top](#table-of-contents)**

108. ### <a name="108"></a> Почему JavaScript рассматривается как однопоточный язык

     JavaScript — это однопоточный язык. Потому что спецификация языка не позволяет программисту писать код так, чтобы интерпретатор мог выполнять его части параллельно в нескольких потоках или процессах. В то время как такие языки, как java, go, C++, могут создавать многопоточные и многопроцессорные программы.

     **[⬆ Back to Top](#table-of-contents)**

109. ### <a name="109"></a> Что такое event delegation

     Делегирование событий — это метод прослушивания событий, при котором вы делегируете родительский элемент в качестве прослушивателя всех событий, происходящих внутри него.

     Например, если вы хотите обнаружить изменения полей внутри определенной формы, вы можете использовать технику делегирования событий,

     ```javascript
     var form = document.querySelector('#registration-form');

     // Listen for changes to fields inside the form
     form.addEventListener('input', function (event) {

     // Log the field that was changed
     console.log(event.target);

     }, false);
     ```

     **[⬆ Back to Top](#table-of-contents)**

110. ### <a name="110"></a> Что такое ECMAScript

     ECMAScript — это язык сценариев, лежащий в основе JavaScript. ECMAScript стандартизирован Международной организацией по стандартизации ECMA в спецификациях ECMA-262 и ECMA-402. Первая редакция ECMAScript была выпущена в 1997 году.

     **[⬆ Back to Top](#table-of-contents)**

111. ### <a name="111"></a> Что такое JSON

     JSON (обозначение объектов JavaScript) — это облегченный формат, который используется для обмена данными. Он основан на подмножестве языка JavaScript в том, как объекты создаются в JavaScript.

     **[⬆ Back to Top](#table-of-contents)**

112. ### <a name="112"></a> Каковы синтаксические правила JSON

     Ниже приведен список правил синтаксиса JSON.
     1. Данные находятся в парах имя/значение
     2. Данные разделены запятыми
     3. Фигурные скобки содержат объекты
     4. Квадратные скобки содержат массивы

     **[⬆ Back to Top](#table-of-contents)**

113. ### <a name="113"></a> Какова цель JSON stringify

     При отправке данных на веб-сервер данные должны быть в строковом формате. Вы можете добиться этого, преобразовав объект JSON в строку с помощью метода stringify().

     ```javascript
     var userJSON = {'name': 'John', age: 31}
     var userString = JSON.stringify(user);
     console.log(userString); //"{"name":"John","age":31}"
     ```

     **[⬆ Back to Top](#table-of-contents)**

114. ### <a name="114"></a> Как вы parse JSON строку

     При получении данных с веб-сервера данные всегда имеют строковый формат. Но вы можете преобразовать это строковое значение в объект javascript, используя метод parse().

     ```javascript
     var userString = '{"name":"John","age":31}';
     var userJSON = JSON.parse(userString);
     console.log(userJSON);// {name: "John", age: 31}
     ```

     **[⬆ Back to Top](#table-of-contents)**

115. ### <a name="115"></a> Зачем вам JSON

     При обмене данными между браузером и сервером данные могут быть только текстовыми. Поскольку JSON является только текстовым, его можно легко отправлять на сервер и с сервера и использовать в качестве формата данных на любом языке программирования.

     **[⬆ Back to Top](#table-of-contents)**

116. ### <a name="116"></a> Что такое PWAs

     Прогрессивные веб-приложения (PWA) — это тип мобильных приложений, доставляемых через Интернет и созданных с использованием распространенных веб-технологий, включая HTML, CSS и JavaScript. Эти PWA развертываются на серверах, доступны через URL-адреса и индексируются поисковыми системами.

     **[⬆ Back to Top](#table-of-contents)**

117. ### <a name="117"></a> Какова цель метода clearTimeout

     Функция clearTimeout() используется в javascript для очистки времени ожидания, которое было установлено функцией setTimeout() до этого. т. е. возвращаемое значение функции setTimeout() сохраняется в переменной и передается в функцию clearTimeout() для сброса таймера.

     Например, приведенный ниже метод setTimeout используется для отображения сообщения через 3 секунды. Этот тайм-аут можно сбросить с помощью метода clearTimeout().

     ```javascript
     <script>
     var msg;
     function greeting() {
        alert('Good morning');
     }
     function start() {
       msg =setTimeout(greeting, 3000);

     }

     function stop() {
         clearTimeout(msg);
     }
     </script>
     ```

     **[⬆ Back to Top](#table-of-contents)**

118. ### <a name="118"></a> Какова цель метода clearInterval

     Функция clearInterval() используется в javascript для очистки интервала, установленного функцией setInterval(). т. е. возвращаемое значение, возвращаемое функцией setInterval(), сохраняется в переменной и передается в функцию clearInterval() для очистки интервала.

     Например, приведенный ниже метод setInterval используется для отображения сообщения каждые 3 секунды. Этот интервал можно очистить методом clearInterval().

     ```javascript
     <script>
     var msg;
     function greeting() {
        alert('Good morning');
     }
     function start() {
       msg = setInterval(greeting, 3000);

     }

     function stop() {
         clearInterval(msg);
     }
     </script>
     ```

     **[⬆ Back to Top](#table-of-contents)**

119. ### <a name="119"></a> Как вы перенаправляете новую страницу в javascript

     В ванильном javascript вы можете перенаправить на новую страницу, используя свойство `location` объекта окна. Синтаксис будет следующим:

     ```javascript
     function redirect() {
        window.location.href = 'newPage.html';
     }
     ```

     **[⬆ Back to Top](#table-of-contents)**

120. ### <a name="120"></a> Как проверить, содержит ли строка подстроку

     Есть 3 возможных способа проверить, содержит ли строка подстроку или нет,
     1. **Использование включает:** ES6 предоставил метод `String.prototype.includes` для проверки строки, содержащей подстроку.

     ```javascript
     var mainString = "hello", subString = "hell";
     mainString.includes(subString)
     ```

     1. **Использование indexOf:** В среде ES5 или более ранней версии вы можете использовать `String.prototype.indexOf`, который возвращает индекс подстроки. Если значение индекса не равно -1, то это означает, что подстрока существует в основной строке.

     ```javascript
     var mainString = "hello", subString = "hell";
     mainString.indexOf(subString) !== -1
     ```

     1. **Использование регулярных выражений:** Расширенное решение использует метод проверки регулярных выражений (`RegExp.test`), который позволяет проверять соответствие регулярным выражениям.

     ```javascript
     var mainString = "hello", regex = /hell/;
     regex.test(mainString)
     ```

     **[⬆ Back to Top](#table-of-contents)**

121. ### <a name="121"></a> Как вы проверяете электронную почту в javascript

     Вы можете проверить электронную почту в javascript, используя регулярные выражения. Рекомендуется выполнять проверки на стороне сервера, а не на стороне клиента. Потому что javascript можно отключить на стороне клиента.

     ```javascript
     function validateEmail(email) {
         var re = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
         return re.test(String(email).toLowerCase());
     }
     ```

     **[⬆ Back to Top](#table-of-contents)**

     The above regular expression accepts unicode characters.

122. ### <a name="122"></a> Как вы получаете текущий URL-адрес с помощью javascript

     Вы можете использовать выражение `window.location.href`, чтобы получить текущий путь URL-адреса, и вы также можете использовать то же выражение для обновления URL-адреса. Вы также можете использовать `document.URL` только для чтения, но это решение имеет проблемы в FF.

     ```javascript
     console.log('location.href', window.location.href); // Returns full URL
     ```

     **[⬆ Back to Top](#table-of-contents)**

123. ### <a name="123"></a> Каковы различные свойства URL-адреса объекта местоположения

     Приведенные ниже свойства объекта «Местоположение» можно использовать для доступа к компонентам URL-адреса страницы.
     1. href — весь URL
     2. protocol - протокол URL
     3. host — имя хоста и порт URL-адреса.
     4. hostname  — имя хоста URL
     5. port  — номер порта в URL-адресе.
     6. pathname — путь к URL-адресу.
     7. search — часть запроса URL-адреса.
     8. hash — якорная часть URL-адреса.

     **[⬆ Back to Top](#table-of-contents)**

124. ### <a name="124"></a> Как получить значения строки запроса в javascript

     Вы можете использовать URLSearchParams для получения значений строки запроса в javascript. Давайте посмотрим на пример, чтобы получить значение кода клиента из строки запроса URL,

     ```javascript
     const urlParams = new URLSearchParams(window.location.search);
     const clientCode = urlParams.get('clientCode');
     ```

     **[⬆ Back to Top](#table-of-contents)**

125. ### <a name="125"></a> Как проверить, существует ли ключ в объекте

     Вы можете проверить, существует ли ключ в объекте или нет, используя три подхода:

     1. **Использование оператора in:** Вы можете использовать оператор in независимо от того, существует ключ в объекте или нет.

     ```javascript
     "key" in obj
     ```

     и Если вы хотите проверить, не существует ли ключ, не забудьте использовать круглые скобки,

     ```javascript
     !("key" in obj)
     ```

     1. **Использование метода hasOwnProperty:** Вы можете использовать `hasOwnProperty` для проверки свойств экземпляра объекта (а не унаследованных свойств).
     ```javascript
     obj.hasOwnProperty("key") // true
     ```

     1. **Использование неопределенного сравнения:** Если вы обращаетесь к несуществующему свойству объекта, результат не определен. Давайте сравним свойства с неопределенными, чтобы определить существование свойства.

     ```javascript
     const user = {
       name: 'John'
     };

     console.log(user.name !== undefined);     // true
     console.log(user.nickName !== undefined); // false
     ```

     **[⬆ Back to Top](#table-of-contents)**

126. ### <a name="126"></a> Как вы перебираете или перечисляете объект javascript

     Вы можете использовать цикл «for-in» для циклического прохождения объекта javascript. Вы также можете убедиться, что ключ, который вы получаете, является фактическим свойством объекта, а не взят из прототипа, используя метод hasOwnProperty.

     ```javascript
     var object = {
         "k1": "value1",
         "k2": "value2",
         "k3": "value3"
     };

     for (var key in object) {
         if (object.hasOwnProperty(key)) {
             console.log(key + " -> " + object[key]); // k1 -> value1 ...
         }
     }
     ```

     **[⬆ Back to Top](#table-of-contents)**

127. ### <a name="127"></a> Как вы тестируете пустой объект

     Существуют разные решения, основанные на версиях ECMAScript.
     1. **Использование записей объекта (ECMA 7+):** Вы можете использовать длину записей объекта вместе с типом конструктора.

     ```javascript
     Object.entries(obj).length === 0 && obj.constructor === Object // Since date object length is 0, you need to check constructor check as well
     ```

     1. **Использование ключей объекта (ECMA 5+):** Вы можете использовать длину ключей объекта вместе с типом конструктора.

     ```javascript
     Object.keys(obj).length === 0 && obj.constructor === Object // Since date object length is 0, you need to check constructor check as well
     ```

     1. **Использование for-in с hasOwnProperty (Pre-ECMA 5):** Вы можете использовать цикл for-in вместе с hasOwnProperty.

     ```javascript
     function isEmpty(obj) {
       for(var prop in obj) {
         if(obj.hasOwnProperty(prop)) {
           return false;
         }
       }

       return JSON.stringify(obj) === JSON.stringify({});
     }
     ```

     **[⬆ Back to Top](#table-of-contents)**

128. ### <a name="128"></a> Что такое объект аргументов

     Объект arguments — это объект типа Array, доступный внутри функций, который содержит значения аргументов, переданных этой функции. Например, давайте посмотрим, как использовать объект arguments внутри функции sum,

     ```javascript
     function sum() {
         var total = 0;
         for (var i = 0, len = arguments.length; i < len; ++i) {
             total += arguments[i];
         }
         return total;
     }

     sum(1, 2, 3) // returns 6
     ```

     **Примечание.** Вы не можете применять методы массива к объекту аргументов. Но вы можете преобразовать в обычный массив, как показано ниже.

     ```javascript
     var argsArray = Array.prototype.slice.call(arguments);
     ```

     **[⬆ Back to Top](#table-of-contents)**

129. ### <a name="129"></a> Как сделать первую букву строки прописной

     Вы можете создать функцию, которая использует цепочку строковых методов, таких как charAt, toUpperCase и методы slice, для создания строки с первой буквой в верхнем регистре.

     ```javascript
     function capitalizeFirstLetter(string) {
         return string.charAt(0).toUpperCase() + string.slice(1);
     }
     ```

     **[⬆ Back to Top](#table-of-contents)**

130. ### <a name="130"></a> Каковы плюсы и минусы цикла for

     Цикл for — это часто используемый синтаксис итерации в javascript. У него есть как плюсы, так и минусы
     
     #### Плюсы
     1. Работает в любой среде
     2. Вы можете использовать инструкции break и continue для управления потоком

     #### Минусы
     1. Слишком многословно
     2. Императив
     3. Вы можете столкнуться с единичными ошибками

     **[⬆ Back to Top](#table-of-contents)**

131. ### <a name="131"></a> Как вы отображаете текущую дату в javascript

     Вы можете использовать `new Date()` для создания нового объекта Date, содержащего текущую дату и время. Например, давайте отобразим текущую дату в формате мм/дд/гггг.

     ```javascript
     var today = new Date();
     var dd = String(today.getDate()).padStart(2, '0');
     var mm = String(today.getMonth() + 1).padStart(2, '0'); //January is 0!
     var yyyy = today.getFullYear();

     today = mm + '/' + dd + '/' + yyyy;
     document.write(today);
     ```

     **[⬆ Back to Top](#table-of-contents)**

132. ### <a name="132"></a> Как вы сравниваете два объекта даты

     Вам нужно использовать метод date.getTime() для сравнения значений даты вместо операторов сравнения (операторы ==, !=, === и !==)

     ```javascript
     var d1 = new Date();
     var d2 = new Date(d1);
     console.log(d1.getTime() === d2.getTime()); //True
     console.log(d1 === d2); // False
     ```

     **[⬆ Back to Top](#table-of-contents)**

133. ### <a name="133"></a> Как проверить, начинается ли строка с другой строки

     Вы можете использовать метод `String.prototype.startsWith()` ECMAScript 6, чтобы проверить, начинается ли строка с другой строки или нет. Но пока поддерживается не во всех браузерах. Давайте посмотрим на пример, чтобы увидеть это использование,

     ```javascript
     "Good morning".startsWith("Good"); // true
     "Good morning".startsWith("morning"); // false
     ```

     **[⬆ Back to Top](#table-of-contents)**

134. ### <a name="134"></a> Как обрезать строку в javascript

     JavaScript предоставил метод обрезки для строковых типов, чтобы обрезать любые пробелы, присутствующие в начале или конце строки.

     ```javascript
     "  Hello World   ".trim(); //Hello World
     ```

     Если ваш браузер (<IE9) не поддерживает этот метод, вы можете использовать приведенный ниже полифилл.

     ```javascript
     if (!String.prototype.trim) {
         (function() {
             // Make sure we trim BOM and NBSP
             var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
             String.prototype.trim = function() {
                 return this.replace(rtrim, '');
             };
         })();
     }
     ```

     **[⬆ Back to Top](#table-of-contents)**

135. ### <a name="135"></a> Как добавить пару ключ-значение в javascript

     Есть два возможных решения для добавления новых свойств к объекту. Давайте возьмем простой объект, чтобы объяснить эти решения.

     ```javascript
     var object = {
         key1: value1,
         key2: value2
     };
     ```

     1. **Использование записи через точку:** Это решение полезно, когда вы знаете имя свойства.

     ```javascript
     object.key3 = "value3";
     ```

     1. **Использование квадратных скобок:** Это решение полезно, когда имя свойства определяется динамически.

     ```javascript
     obj["key3"] = "value3";
     ```

     **[⬆ Back to Top](#table-of-contents)**

136. ### <a name="136"></a> Представляет ли запись '!--' специальный оператор

     Нет, это не специальный оператор. Но это комбинация 2-х стандартных операторов друг за другом,
     1. Логическое не (!)
     2. Декремент префикса (--)

     Сначала значение уменьшается на единицу, а затем проверяется, равно ли оно нулю или нет для определения истинного/ложного значения.

     **[⬆ Back to Top](#table-of-contents)**

137. ### <a name="137"></a> Как вы назначаете значения по умолчанию для переменных

     Вы можете использовать логический оператор или оператор `||` в выражении присваивания, чтобы задать значение по умолчанию. Синтаксис выглядит следующим образом:

     ```javascript
     var a = b || c;
     ```

     Согласно приведенному выше выражению, переменная 'a' получит значение 'c' только в том случае, если 'b' является ложным (если имеет значение null, false, undefined, 0, пустая строка или NaN), в противном случае 'a' получит значение 'c'. значение «б».
     
     **[⬆ Back to Top](#table-of-contents)**

138. ### <a name="138"></a> Как вы определяете многострочные строки

     Вы можете определить многострочные строковые литералы, используя символ '\\', за которым следует разделитель строки.

     ```javascript
     var str = "This is a \
     very lengthy \
     sentence!";
     ```

     Но если у вас есть пробел после символа '\\', код будет выглядеть точно так же, но вызовет SyntaxError.

     **[⬆ Back to Top](#table-of-contents)**

139. ### <a name="139"></a> Что такое app shell model

     App shell model (или оболочка приложения) — это один из способов создания прогрессивного веб-приложения, которое надежно и мгновенно загружается на экраны ваших пользователей, аналогично тому, что вы видите в нативных приложениях. Это полезно для быстрого вывода исходного HTML на экран без сети.

     **[⬆ Back to Top](#table-of-contents)**

140. ### <a name="140"></a> Можем ли мы определить свойства для функций

     Да, мы можем определить свойства для функций, потому что функции также являются объектами.

     ```javascript
     fn = function(x) {
        //Function code goes here
     }

     fn.name = "John";

     fn.profile = function(y) {
       //Profile code goes here
     }
     ```

     **[⬆ Back to Top](#table-of-contents)**

141. ### <a name="141"></a> Как найти количество параметров, ожидаемых функцией

     Вы можете использовать синтаксис `function.length`, чтобы найти количество параметров, ожидаемых функцией. Давайте рассмотрим пример функции `sum` для вычисления суммы чисел,

     ```javascript
     function sum(num1, num2, num3, num4){
         return num1 + num2 + num3 + num4;
     }
     sum.length // 4 is the number of parameters expected.
     ```

     **[⬆ Back to Top](#table-of-contents)**

142. ### <a name="142"></a> Что такое polyfill

     Полифил — это фрагмент кода JS, используемый для обеспечения современных функций в старых браузерах, которые изначально не поддерживают его. Например, полифилл подключаемого модуля Silverlight можно использовать для имитации функциональности элемента HTML Canvas в Microsoft Internet Explorer 7.

     **[⬆ Back to Top](#table-of-contents)**

143. ### <a name="143"></a> Что такое операторы break и continue

     Оператор break используется для «выхода» из цикла. т. е. он прерывает цикл и продолжает выполнение кода после цикла.

     ```javascript
     for (i = 0; i < 10; i++) {
       if (i === 5) { break; }
       text += "Number: " + i + "<br>";
     }
     ```

     Оператор continue используется для «перепрыгивания» одной итерации в цикле. т. е. он прерывает одну итерацию (в цикле), если возникает указанное условие, и продолжает следующую итерацию в цикле.

     ```javascript
     for (i = 0; i < 10; i++) {
         if (i === 5) { continue; }
         text += "Number: " + i + "<br>";
     }
     ```

     **[⬆ Back to Top](#table-of-contents)**

144. ### <a name="144"></a> Что такое JS-label

     Оператор label позволяет нам называть циклы и блоки в JavaScript. Затем мы можем использовать эти метки, чтобы вернуться к коду позже. Например, приведенный ниже код с метками позволяет избежать печати чисел, когда они одинаковы.

     ```javascript
     var i, j;

     loop1:
     for (i = 0; i < 3; i++) {
        loop2:
        for (j = 0; j < 3; j++) {
           if (i === j) {
              continue loop1;
           }
           console.log('i = ' + i + ', j = ' + j);
        }
     }

     // Output is:
     //   "i = 1, j = 0"
     //   "i = 2, j = 0"
     //   "i = 2, j = 1"
     ```

     **[⬆ Back to Top](#table-of-contents)**

145. ### <a name="145"></a> Каковы преимущества размещения объявлений (declarations) наверху

     Рекомендуется хранить все объявления в начале каждого скрипта или функции. Преимущества этого заключаются в том,
     1. Дает более чистый код
     2. Он предоставляет единое место для поиска локальных переменных
     3. Легко избежать нежелательных глобальных переменных
     4. Снижает вероятность нежелательных повторных заявлений

     **[⬆ Back to Top](#table-of-contents)**

146. ### <a name="146"></a> Каковы преимущества инициализации переменных

     Рекомендуется инициализировать переменные из-за следующих преимуществ:
     1. Это дает более чистый код
     2. Он предоставляет единое место для инициализации переменных
     3. Избегайте неопределенных значений в коде

     **[⬆ Back to Top](#table-of-contents)**

147. ### <a name="147"></a> Каковы рекомендации по созданию нового объекта

     Рекомендуется избегать создания новых объектов с помощью `new Object()`. Вместо этого вы можете инициализировать значения на основе их типа для создания объектов.
     1. Назначьте {} вместо нового объекта ()
     2. Назначьте "" вместо новой строки ()
     3. Назначьте 0 вместо нового номера ()
     4. Назначьте false вместо new Boolean()
     5. Назначьте [] вместо нового массива ()
     6. Назначьте /()/ вместо нового RegExp()
     7. Назначьте функцию (){} вместо новой функции ()

     Вы можете определить их в качестве примера,

     ```javascript
     var v1 = {};
     var v2 = "";
     var v3 = 0;
     var v4 = false;
     var v5 = [];
     var v6 = /()/;
     var v7 = function(){};
     ```

     **[⬆ Back to Top](#table-of-contents)**

148. ### <a name="148"></a> Как вы определяете массивы JSON

     Массивы JSON записываются в квадратных скобках, а массивы содержат объекты javascript. Например, массив пользователей JSON будет таким, как показано ниже:

     ```javascript
     "users":[
       {"firstName":"John", "lastName":"Abrahm"},
       {"firstName":"Anna", "lastName":"Smith"},
       {"firstName":"Shane", "lastName":"Warn"}
     ]
     ```

     **[⬆ Back to Top](#table-of-contents)**

149. ### <a name="149"></a> Как вы генерируете случайные целые числа

     Вы можете использовать Math.random() с Math.floor() для возврата случайных целых чисел. Например, если вы хотите генерировать случайные целые числа от 1 до 10, коэффициент умножения должен быть равен 10.

     ```javascript
     Math.floor(Math.random() * 10) + 1;     // returns a random integer from 1 to 10
     Math.floor(Math.random() * 100) + 1;     // returns a random integer from 1 to 100
     ```

     **Примечание.** Math.random() возвращает случайное число от 0 (включительно) до 1 (исключительно).

     **[⬆ Back to Top](#table-of-contents)**

150. ### <a name="150"></a> Можете ли вы написать функцию случайных целых чисел для печати целых чисел в диапазоне

     Да, вы можете создать правильную случайную функцию для возврата случайного числа между минимумом и максимумом (оба включены)

     ```javascript
     function randomInteger(min, max) {
       return Math.floor(Math.random() * (max - min + 1) ) + min;
     }
     randomInteger(1, 100); // returns a random integer from 1 to 100
     randomInteger(1, 1000); // returns a random integer from 1 to 1000
     ```

     **[⬆ Back to Top](#table-of-contents)**

151. ### <a name="151"></a> Что такое tree shaking

     Встряхивание дерева — это форма устранения мертвого кода. Это означает, что неиспользуемые модули не будут включены в пакет во время процесса сборки, и для этого он опирается на статическую структуру синтаксиса модуля ES2015 (т. е. импорт и экспорт). Первоначально это было популяризировано сборщиком модулей ES2015 `rollup`.

     **[⬆ Back to Top](#table-of-contents)**

152. ### <a name="152"></a> Для чего нужно tree shaking

     Tree Shaking может значительно уменьшить размер кода в любом приложении. т. е. чем меньше кода мы отправляем по сети, тем более производительным будет приложение. Например, если мы просто хотим создать приложение «Hello World» с использованием фреймворков SPA, это займет около нескольких МБ, но с помощью встряхивания дерева его размер можно уменьшить до нескольких сотен КБ. Встряхивание дерева реализовано в сборщиках Rollup и Webpack.

     **[⬆ Back to Top](#table-of-contents)**

153. ### <a name="153"></a> Рекомендуется ли использовать eval

     Нет, он позволяет запускать произвольный код, что вызывает проблему безопасности. Как мы знаем, функция eval() используется для запуска текста как кода. В большинстве случаев в его использовании нет необходимости.

     **[⬆ Back to Top](#table-of-contents)**

154. ### <a name="154"></a> Что такое регулярное выражение, RegExp

     Регулярное выражение — это последовательность символов, формирующая шаблон поиска. Вы можете использовать этот шаблон поиска для поиска данных в тексте. Их можно использовать для выполнения всех типов операций текстового поиска и замены текста. Давайте теперь посмотрим на формат синтаксиса,

     ```javascript
     /pattern/modifiers;
     ```

     Например, регулярное выражение или шаблон поиска с нечувствительным к регистру именем пользователя будет таким:

     ```javascript
     /John/i
     ```

     **[⬆ Back to Top](#table-of-contents)**

155. ### <a name="155"></a> Какие строковые методы доступны в регулярном выражении

     Регулярные выражения имеют два строковых метода: search() и replace().
     Метод search() использует выражение для поиска совпадения и возвращает позицию совпадения.

     ```javascript
     var msg = "Hello John";
     var n = msg.search(/John/i); // 6
     ```

     Метод replace() используется для возврата модифицированной строки, в которой заменяется шаблон.

     ```javascript
     var msg = "Hello John";
     var n = msg.replace(/John/i, "Buttler"); // Hello Buttler
     ```

     **[⬆ Back to Top](#table-of-contents)**

156. ### <a name="156"></a> Что такое модификаторы в регулярном выражении

      Модификаторы можно использовать для выполнения нечувствительного к регистру и глобального поиска. Давайте перечислим некоторые из модификаторов,

      | Модификатор | Описание |
      |---- | ---------
      | i | Выполнить сопоставление без учета регистра |
      | g | Выполнить глобальное совпадение, а не останавливаться на первом совпадении |
      | m | Выполнить многострочное сопоставление|

      Давайте возьмем пример глобального модификатора,

      ```javascript
      var text = "Learn JS one by one";
      var pattern = /one/g;
      var result = text.match(pattern); // one,one
      ```

      **[⬆ Back to Top](#table-of-contents)**

157. ### <a name="157"></a> Что такое шаблоны регулярных выражений

     Регулярные выражения предоставляют группу шаблонов для сопоставления символов. В основном они делятся на 3 типа,
     1. **Квадратные скобки**. Они используются для поиска диапазона символов.
        Например, ниже приведены некоторые варианты использования,
        1. [abc]: используется для поиска любого символа в квадратных скобках (a,b,c).
        2. [0-9]: используется для поиска любой цифры в скобках.
        3. (a|b): используется для поиска любой из альтернатив, разделенных символом |
     2. **Метасимволы:** это символы с особым значением.
        Например, ниже приведены некоторые варианты использования,
        1. \\d: Используется для поиска цифры
        2. \\s: используется для поиска символа пробела.
        3. \\b: используется для поиска соответствия в начале или конце слова.
     3. **Квантификаторы:** они полезны для определения количества.
        Например, ниже приведены некоторые варианты использования,
        1. n+: используется для поиска совпадений для любой строки, содержащей хотя бы один n
        2. n*: используется для поиска совпадений для любой строки, содержащей ноль или более вхождений n.
        3. n?: используется для поиска совпадений для любой строки, содержащей ноль или одно вхождение n.

     **[⬆ Back to Top](#table-of-contents)**

158. ### <a name="158"></a> Что такое объект RegExp

     Объект RegExp — это объект регулярного выражения с предопределенными свойствами и методами. Давайте посмотрим на простое использование объекта RegExp,

     ```javascript
     var regexp = new RegExp('\\w+');
     console.log(regexp);
     // expected output: /\w+/
     ```

     **[⬆ Back to Top](#table-of-contents)**

159. ### <a name="159"></a> Как вы ищете строку для шаблона

     Вы можете использовать метод регулярного выражения test() для поиска в строке шаблона и возврата true или false в зависимости от результата.

     ```javascript
     var pattern = /you/;
     console.log(pattern.test("How are you?")); //true
     ```

     **[⬆ Back to Top](#table-of-contents)**

160. ### <a name="160"></a> Какова цель метода exec

     Цель метода exec аналогична методу test, но он выполняет поиск совпадения в указанной строке и возвращает массив результатов или null вместо возврата true/false.

     ```javascript
     var pattern = /you/;
     console.log(pattern.exec("How are you?")); //["you", index: 8, input: "How are you?", groups: undefined]
     ```

     **[⬆ Back to Top](#table-of-contents)**

161. ### <a name="161"></a> Как изменить стиль HTML-элемента

     Вы можете изменить встроенный стиль или имя класса элемента HTML, используя javascript
     1. **Используя свойство стиля:** Вы можете изменить встроенный стиль, используя свойство стиля.

     ```javascript
     document.getElementById("title").style.fontSize = "30px";
     ```

     1. **Используя свойство ClassName:** Легко изменить класс элемента, используя свойство className.

     ```javascript
      document.getElementById("title").className = "custom-title";
      ```

     **[⬆ Back to Top](#table-of-contents)**

162. ### <a name="162"></a> Каким будет результат 1+2+'3'

     Вывод будет `33`. Поскольку «1» и «2» являются числовыми значениями, результатом первых двух цифр будет числовое значение «3». Следующая цифра является значением строкового типа, потому что добавление числового значения «3» и значения строкового типа «3» будет просто значением конкатенации «33».

     **[⬆ Back to Top](#table-of-contents)**

163. ### <a name="163"></a> Что такое debugger statement

     Оператор отладчика вызывает любые доступные функции отладки, такие как установка точки останова. Если функции отладки недоступны, этот оператор не действует.
     Например, в приведенную ниже функцию был вставлен оператор отладчика. Так
     выполнение приостанавливается в операторе отладчика точно так же, как точка останова в исходном коде скрипта.

     ```javascript
     function getProfile() {
     // code goes here
     debugger;
     // code goes here
     }
     ```

     **[⬆ Back to Top](#table-of-contents)**

164. ### <a name="164"></a> Какова цель точек останова в отладке

     Вы можете установить точки останова в коде javascript после выполнения оператора отладчика и появления всплывающего окна отладчика. В каждой точке останова javascript останавливает выполнение и позволяет вам проверить значения JavaScript. После проверки значений вы можете возобновить выполнение кода с помощью кнопки воспроизведения.

     **[⬆ Back to Top](#table-of-contents)**

165. ### <a name="165"></a> Могу ли я использовать зарезервированные слова в качестве идентификаторов

     Нет, вы не можете использовать зарезервированные слова в качестве переменных, меток, имен объектов или функций. Давайте рассмотрим один простой пример,

     ```javascript
     var else = "hello"; // Uncaught SyntaxError: Unexpected token else
     ```

     **[⬆ Back to Top](#table-of-contents)**

166. ### <a name="166"></a> Как определить мобильный браузер

     Вы можете использовать регулярное выражение, которое возвращает значение true или false в зависимости от того, просматривает ли пользователь мобильный телефон.

     ```javascript
     window.mobilecheck = function() {
       var mobileCheck = false;
       (function(a){if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4))) mobileCheck = true;})(navigator.userAgent||navigator.vendor||window.opera);
       return mobileCheck;
     };
     ```

     **[⬆ Back to Top](#table-of-contents)**

167. ### <a name="167"></a> Как определить мобильный браузер без регулярного выражения

     Вы можете обнаружить мобильные браузеры, просто просмотрев список устройств и проверив, соответствует ли пользовательский агент чему-либо. Это альтернативное решение для использования RegExp,

     ```javascript
     function detectmob() {
      if( navigator.userAgent.match(/Android/i)
      || navigator.userAgent.match(/webOS/i)
      || navigator.userAgent.match(/iPhone/i)
      || navigator.userAgent.match(/iPad/i)
      || navigator.userAgent.match(/iPod/i)
      || navigator.userAgent.match(/BlackBerry/i)
      || navigator.userAgent.match(/Windows Phone/i)
      ){
         return true;
       }
      else {
         return false;
       }
     }
     ```

     **[⬆ Back to Top](#table-of-contents)**

168. ### <a name="168"></a> Как получить ширину и высоту изображения с помощью JS

     Вы можете программно получить изображение и проверить размеры (ширину и высоту) с помощью Javascript.

     ```javascript
     var img = new Image();
     img.onload = function() {
       console.log(this.width + 'x' + this.height);
     }
     img.src = 'http://www.google.com/intl/en_ALL/images/logo.gif';
     ```

     **[⬆ Back to Top](#table-of-contents)**

169. ### <a name="169"></a> Как сделать синхронный HTTP-запрос

     Браузеры предоставляют объект XMLHttpRequest, который можно использовать для выполнения синхронных HTTP-запросов из JavaScript.

     ```javascript
     function httpGet(theUrl)
     {
         var xmlHttpReq = new XMLHttpRequest();
         xmlHttpReq.open( "GET", theUrl, false ); // false for synchronous request
         xmlHttpReq.send( null );
         return xmlHttpReq.responseText;
     }
     ```

     **[⬆ Back to Top](#table-of-contents)**

170. ### <a name="170"></a> Как сделать асинхронный HTTP-запрос

     Браузеры предоставляют объект XMLHttpRequest, который можно использовать для выполнения асинхронных HTTP-запросов из JavaScript, передав третий параметр как true.

     ```javascript
     function httpGetAsync(theUrl, callback)
     {
         var xmlHttpReq = new XMLHttpRequest();
         xmlHttpReq.onreadystatechange = function() {
             if (xmlHttpReq.readyState == 4 && xmlHttpReq.status == 200)
                 callback(xmlHttpReq.responseText);
         }
         xmlHttp.open("GET", theUrl, true); // true for asynchronous
         xmlHttp.send(null);
     }
     ```

     **[⬆ Back to Top](#table-of-contents)**

171. ### <a name="171"></a> Как вы конвертируете дату в другой часовой пояс в javascript

     Вы можете использовать метод toLocaleString() для преобразования дат из одного часового пояса в другой. Например, давайте преобразуем текущую дату в часовой пояс британского английского, как показано ниже:

     ```javascript
     console.log(event.toLocaleString('en-GB', { timeZone: 'UTC' })); //29/06/2019, 09:56:00
     ```

     **[⬆ Back to Top](#table-of-contents)**

172. ### <a name="172"></a> Какие свойства используются для получения размера окна

     Вы можете использовать свойства innerWidth, innerHeight, clientWidth, clientHeight окон, элементов документа и объектов тела документа, чтобы найти размер окна. Давайте используем их комбинацию этих свойств для расчета размера окна или документа,

     ```javascript
     var width = window.innerWidth
     || document.documentElement.clientWidth
     || document.body.clientWidth;

     var height = window.innerHeight
     || document.documentElement.clientHeight
     || document.body.clientHeight;
     ```

     **[⬆ Back to Top](#table-of-contents)**

173. ### <a name="173"></a> Что такое тернарный оператор в javascript

     Условный (тернарный) оператор — единственный оператор JavaScript, который принимает три операнда и действует как сокращение для операторов if.
     
     ```javascript
     var isAuthenticated = false;
     console.log(isAuthenticated ? 'Hello, welcome' : 'Sorry, you are not authenticated'); //Sorry, you are not authenticated
     ```

     **[⬆ Back to Top](#table-of-contents)**

174. ### <a name="174"></a> Можете ли вы применить chaining к тернарному оператору

     Да, вы можете применять цепочку к условным операторам, подобно цепочке if … else if … else if … else. Синтаксис будет таким, как показано ниже,

     ```javascript
     function traceValue(someParam) {
         return condition1 ? value1
              : condition2 ? value2
              : condition3 ? value3
              : value4;
     }

     // Приведенный выше условный оператор эквивалентен:

     function traceValue(someParam) {
         if (condition1) { return value1; }
         else if (condition2) { return value2; }
         else if (condition3) { return value3; }
         else { return value4; }
     }
     ```

     **[⬆ Back to Top](#table-of-contents)**

175. ### <a name="175"></a> Какие есть способы выполнить javascript после загрузки страницы

     Вы можете выполнить javascript после загрузки страницы разными способами,
     1. **window.onload:**

     ```javascript
     window.onload = function ...
     ```

     1. **document.onload:**

     ```javascript
     document.onload = function ...
     ```

     1. **body onload:**

     ```javascript
     <body onload="script();">
     ```

     **[⬆ Back to Top](#table-of-contents)**

176. ### <a name="176"></a> В чем разница между proto и prototype

     Объект `__proto__` — это фактический объект, который используется в цепочке поиска для разрешения методов и т. д. Тогда как `prototype` — это объект, который используется для построения `__proto__` при создании объекта с new

     ```javascript
     ( new Employee ).__proto__ === Employee.prototype;
     ( new Employee ).prototype === undefined;
     ```

     **[⬆ Back to Top](#table-of-contents)**

177. ### <a name="177"></a> Приведите пример, где вам действительно нужна точка с запятой

     В JavaScript рекомендуется использовать точку с запятой после каждого оператора. Например, в приведенном ниже случае он выдает ошибку «.. не является функцией» во время выполнения из-за отсутствия точки с запятой.

     ```javascript
     // define a function
     var fn = function () {
         //...
     } // semicolon missing at this line

     // then execute some code inside a closure
     (function () {
         //...
     })();
     ```

     и это будет интерпретироваться как

     ```javascript
     var fn = function () {
         //...
     }(function () {
         //...
     })();
     ```

     В этом случае мы передаем вторую функцию в качестве аргумента первой функции, а затем пытаемся вызвать результат вызова первой функции как функцию. Следовательно, вторая функция завершится ошибкой "... не является функцией" во время выполнения.

     **[⬆ Back to Top](#table-of-contents)**

178. ### <a name="178"></a> Что такое метод заморозк

     Метод **freeze()** используется для замораживания объекта. Замораживание объекта не позволяет добавлять к объекту новые свойства, предотвращает удаление и предотвращает изменение перечислимости, конфигурируемости или возможности записи существующих свойств. т. е. возвращает переданный объект и не создает замороженную копию.

     ```javascript
     const obj = {
       prop: 100
     };

     Object.freeze(obj);
     obj.prop = 200; // Throws an error in strict mode

     console.log(obj.prop); //100
     ```

     **Примечание.** Это вызывает TypeError, если переданный аргумент не является объектом.

     **[⬆ Back to Top](#table-of-contents)**

179. ### <a name="179"></a> В чем суть метода заморозки

     Ниже приведены основные преимущества использования метода заморозки.

     1. Используется для замораживания объектов и массивов.
     2. Он используется, чтобы сделать объект неизменным.

     **[⬆ Back to Top](#table-of-contents)**

180. ### <a name="180"></a> Почему мне нужно использовать метод замораживания

     В объектно-ориентированной парадигме существующий API содержит определенные элементы, которые не предназначены для расширения, изменения или повторного использования вне их текущего контекста. Следовательно, оно работает как «финальное» ключевое слово, которое используется в различных языках.

     **[⬆ Back to Top](#table-of-contents)**

181. ### <a name="181"></a> Как определить языковые предпочтения браузера

     Вы можете использовать объект навигатора для определения предпочтения языка браузера, как показано ниже:

     ```javascript
     var language = navigator.languages && navigator.languages[0] || // Chrome / Firefox
                    navigator.language ||   // All browsers
                    navigator.userLanguage; // IE <= 10

     console.log(language);
     ```

     **[⬆ Back to Top](#table-of-contents)**

182. ### <a name="182"></a> Как преобразовать строку в заглавный регистр с помощью javascript

     Заглавный регистр означает, что первая буква каждого слова заглавная. Вы можете преобразовать строку в заглавный регистр, используя приведенную ниже функцию:

     ```javascript
         function toTitleCase(str) {
             return str.replace(
                 /\w\S*/g,
                 function(txt) {
                     return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
                 }
             );
         }
         toTitleCase("good morning john"); // Good Morning John
     ```

     **[⬆ Back to Top](#table-of-contents)**

183. ### <a name="183"></a> Как вы обнаруживаете, что JavaScript отключен на странице

     Вы можете использовать тег `<noscript>`, чтобы определить, отключен или нет javascript. Блок кода внутри `<noscript>` выполняется, когда JavaScript отключен, и обычно используется для отображения альтернативного контента, когда страница создается на JavaScript.

     ```javascript
     <script type="javascript">
         // JS related code goes here
     </script>
     <noscript>
         <a href="next_page.html?noJS=true">JavaScript is disabled in the page. Please click Next Page</a>
     </noscript>
     ```

     **[⬆ Back to Top](#table-of-contents)**

184. ### <a name="184"></a> Какие различные операторы поддерживаются javascript

     Оператор способен манипулировать (математическими и логическими вычислениями) определенным значением или операндом. Существуют различные операторы, поддерживаемые JavaScript, как показано ниже:
     1. **Арифметические операторы:** включает + (сложение), – (вычитание), * (умножение), / (деление), % (модуль), + + (приращение) и – – (уменьшение).
     2. **Операторы сравнения:** Включает ==(Равно),!= (Не равно), ===(Равно с типом), > (Больше),> = (Больше или равно),< ( Меньше чем),<= (Меньше или равно)
     3. **Логические операторы:** включают &&(логическое И),||(логическое ИЛИ),!(логическое НЕ)
     4. **Операторы присваивания:** Включает = (оператор присваивания), += (оператор сложения и присваивания), – = (оператор вычитания и присваивания), *= (умножение и присваивание), /= (деление и присваивание), %= (модули и назначение)
     5. **Тернарные операторы:** включает условный (: ?) оператор.
     6. **Оператор typeof:** Используется для определения типа переменной. Синтаксис выглядит как `тип переменной`

     **[⬆ Back to Top](#table-of-contents)**

185. ### <a name="185"></a> Что такое rest параметр

     Параметр Rest — это улучшенный способ обработки параметров функции, который позволяет нам представлять неопределенное количество аргументов в виде массива. Синтаксис будет таким, как показано ниже,

     ```javascript
     function f(a, b, ...theArgs) {
       // ...
     }
     ```

     Например, давайте возьмем пример суммы для расчета динамического количества параметров,

     ```javascript
     function total(…args){
     let sum = 0;
     for(let i of args){
     sum+=i;
     }
     return sum;
     }
     console.log(fun(1,2)); //3
     console.log(fun(1,2,3)); //6
     console.log(fun(1,2,3,4)); //13
     console.log(fun(1,2,3,4,5)); //15
     ```

     **Примечание.** Параметр Rest добавляется в ES2015 или ES6.
     
     **[⬆ Back to Top](#table-of-contents)**

186. ### <a name="186"></a> Что произойдет, если вы не используете параметр rest в качестве последнего аргумента

     Параметр rest должен быть последним аргументом, так как его задача — собрать все оставшиеся аргументы в массив. Например, если вы определяете функцию, как показано ниже, это не имеет никакого смысла и вызовет ошибку.

     ```javascript
     function someFunc(a,…b,c){
     //You code goes here
     return;
     }
     ```

     **[⬆ Back to Top](#table-of-contents)**

187. ### <a name="187"></a> Какие побитовые операторы доступны в javascript

     Ниже приведен список побитовых логических операторов, используемых в JavaScript.
     1. Побитовое И (&)
     2. Побитовое ИЛИ ( | )
     3. Побитовое исключающее ИЛИ (^)
     4. Побитовое НЕ (~)
     5. Сдвиг влево ( << )
     6. Знак, распространяющий сдвиг вправо ( >> )
     7. Заполнить нулями Правый Shift ( >>> )

     **[⬆ Back to Top](#table-of-contents)**

188. ### <a name="188"></a> Что такое spread оператор

     Оператор Spread позволяет расширять итерируемые объекты (массивы/объекты/строки) до отдельных аргументов/элементов. Давайте возьмем пример, чтобы увидеть это поведение,

     ```javascript
     function calculateSum(x, y, z) {
       return x + y + z;
     }

     const numbers = [1, 2, 3];

     console.log(calculateSum(...numbers)); // 6
     ```

     **[⬆ Back to Top](#table-of-contents)**

189. ### <a name="189"></a> Как определить, заморожен объект или нет?

     Метод Object.isFrozen() используется для определения того, заморожен ли объект или нет. Объект заморожен, если выполняются все приведенные ниже условия.
     1. Если он не расширяемый.
     2. Если все его свойства не настраиваются.
     3. Если все его свойства данных недоступны для записи.
     Использование будет следующим,

     ```javascript
     const object = {
        property: 'Welcome JS world'
     };
     Object.freeze(object);
     console.log(Object.isFrozen(object));
     ```

     **[⬆ Back to Top](#table-of-contents)**

190. ### <a name="190"></a> Как вы определяете два одинаковых значения или не используете объект

     Метод Object.is() определяет, являются ли два значения одним и тем же значением. Например, использование с различными типами значений будет,

     ```javascript
     Object.is('hello', 'hello');     // true
     Object.is(window, window);   // true
     Object.is([], []) // false
     ```

     Два значения считаются одинаковыми, если выполняется одно из следующих условий:
      1. оба не определены
      2. оба нулевые
      3. оба верны или оба ложны
      4. обе строки одинаковой длины с одинаковыми символами в одном порядке
      5. оба объекта одинаковы (означает, что оба объекта имеют одинаковую ссылку)
      6. оба числа и
         оба +0
         оба -0
         оба NaN
         оба ненулевые и оба не NaN, и оба имеют одинаковое значение.

     **[⬆ Back to Top](#table-of-contents)**

191. ### <a name="191"></a> Какова цель использования объекта - это метод

     Вот некоторые из применений метода is объекта Object:
     1. Используется для сравнения двух строк.
     2. Используется для сравнения двух чисел.
     3. Используется для сравнения полярности двух чисел.
     4. Используется для сравнения двух объектов.

     **[⬆ Back to Top](#table-of-contents)**

192. ### <a name="192"></a> Как вы копируете свойства с одного объекта на другой

     Вы можете использовать метод Object.assign(), который используется для копирования значений и свойств из одного или нескольких исходных объектов в целевой объект. Он возвращает целевой объект, свойства и значения которого скопированы из целевого объекта. Синтаксис будет таким, как показано ниже,

     ```javascript
     Object.assign(target, ...sources)
     ```

     Возьмем пример с одним источником и одним целевым объектом,

     ```javascript
     const target = { a: 1, b: 2 };
     const source = { b: 3, c: 4 };

     const returnedTarget = Object.assign(target, source);

     console.log(target); // { a: 1, b: 3, c: 4 }

     console.log(returnedTarget); // { a: 1, b: 3, c: 4 }
     ```

     Как видно из приведенного выше кода, существует общее свойство (`b`) от источника к цели, поэтому его значение было перезаписано.

     **[⬆ Back to Top](#table-of-contents)**

193. ### <a name="193"></a> Каковы применения метода assign

     Ниже приведены некоторые из основных применений метода Object.assign(),

     1. Используется для клонирования объекта.
     2. Используется для объединения объектов с одинаковыми свойствами.

     **[⬆ Back to Top](#table-of-contents)**

194. ### <a name="194"></a> Что такое proxy object

     Объект Proxy используется для определения пользовательского поведения для основных операций, таких как поиск свойств, назначение, перечисление, вызов функций и т. д. Синтаксис будет следующим:

     ```javascript
     var p = new Proxy(target, handler);
     ```

     Возьмем пример прокси-объекта,
     
     ```javascript
     var handler = {
         get: function(obj, prop) {
             return prop in obj ?
                 obj[prop] :
                 100;
         }
     };

     var p = new Proxy({}, handler);
     p.a = 10;
     p.b = null;

     console.log(p.a, p.b); // 10, null
     console.log('c' in p, p.c); // false, 100
     ```

     В приведенном выше коде используется обработчик `get`, который определяет поведение прокси-сервера при выполнении над ним операции.

     **[⬆ Back to Top](#table-of-contents)**

195. ### <a name="195"></a> Какова цель метода seal

     Метод **Object.seal()** используется для запечатывания объекта, предотвращая добавление к нему новых свойств и помечая все существующие свойства как ненастраиваемые. Но значения существующих свойств все еще могут быть изменены, пока они доступны для записи. Давайте посмотрим на приведенный ниже пример, чтобы понять больше о методе seal().

     ```javascript
      const object = {
         property: 'Welcome JS world'
      };
      Object.seal(object);
      object.property = 'Welcome to object world';
      console.log(Object.isSealed(object)); // true
      delete object.property; // You cannot delete when sealed
      console.log(object.property); //Welcome to object world
     ```

     **[⬆ Back to Top](#table-of-contents)**

196. ### <a name="196"></a> Каковы применения метода seal

     Ниже приведены основные области применения метода Object.seal(),
     1. Используется для запечатывания объектов и массивов.
     2. Он используется, чтобы сделать объект неизменным.

     **[⬆ Back to Top](#table-of-contents)**

197. ### <a name="197"></a> В чем разница между методами freeze и seal

     Если объект замораживается с помощью метода Object.freeze(), то его свойства становятся неизменяемыми и в них нельзя внести изменения, тогда как если объект запечатывается с помощью метода Object.seal(), то изменения могут быть внесены в существующие свойства объекта.

     **[⬆ Back to Top](#table-of-contents)**

198. ### <a name="198"></a> Как определить, запечатан объект или нет?

     Метод Object.isSealed() используется для определения того, запечатан объект или нет. Объект запечатан, если выполняются все перечисленные ниже условия.
     1. Если он не расширяемый.
     2. Если все его свойства не настраиваются.
     3. Если он не съемный (но не обязательно незаписываемый).
     Посмотрим в действии
     
     ```javascript
     const object = {
     property: 'Hello, Good morning'
     };

     Object.seal(object); // Using seal() method to seal the object

     console.log(Object.isSealed(object));      // checking whether the object is sealed or not
     ```

     **[⬆ Back to Top](#table-of-contents)**

199. ### <a name="199"></a> Как получить перечисляемые пары ключ-значение

     Метод Object.entries() используется для возврата массива собственных перечислимых пар свойств со строковыми ключами [ключ, значение] данного объекта в том же порядке, что и в цикле for...in. Давайте посмотрим на функциональность метода object.entries() на примере.

     ```javascript
     const object = {
       a: 'Good morning',
       b: 100
     };

     for (let [key, value] of Object.entries(object)) {
       console.log(`${key}: ${value}`); // a: 'Good morning'
                                        // b: 100
     }
     ```

     **Примечание.** Порядок не гарантируется в соответствии с определением объекта.

     **[⬆ Back to Top](#table-of-contents)**

200. ### <a name="200"></a> В чем основное различие между методами Object.values и Object.entries

     Поведение метода Object.values() аналогично методу Object.entries(), но вместо пар [ключ, значение] он возвращает массив значений.

     ```javascript
      const object = {
        a: 'Good morning',
        b: 100
      };

      for (let value of Object.values(object)) {
        console.log(`${value}`); // 'Good morning'
                                     100
      }
     ```

     **[⬆ Back to Top](#table-of-contents)**

201. ### <a name="201"></a> Как получить список ключей любого объекта

     Вы можете использовать метод Object.keys(), который используется для возврата массива имен собственных свойств данного объекта в том же порядке, что и в обычном цикле. Например, вы можете получить ключи пользовательского объекта,
     
     ```javascript
     const user = {
       name: 'John',
       gender: 'male',
       age: 40
     };

     console.log(Object.keys(user)); //['name', 'gender', 'age']
     ```

     **[⬆ Back to Top](#table-of-contents)**

202. ### <a name="202"></a> Как вы создаете объект с прототипом

     Метод Object.create() используется для создания нового объекта с указанным объектом-прототипом и свойствами. т. е. он использует существующий объект в качестве прототипа вновь созданного объекта. Он возвращает новый объект с указанным объектом-прототипом и свойствами.

     ```javascript
      const user = {
        name: 'John',
        printInfo: function () {
          console.log(`My name is ${this.name}.`);
        }
      };

      const admin = Object.create(user);

      admin.name = "Nick"; // Remember that "name" is a property set on "admin" but not on "user" object

      admin.printInfo(); // My name is Nick
     ```

     **[⬆ Back to Top](#table-of-contents)**

203. ### <a name="203"></a> Что такое WeakSet

     WeakSet используется для хранения набора слабо удерживаемых объектов (слабых ссылок). Синтаксис будет следующим:

     ```javascript
     new WeakSet([iterable]);
     ```

     Давайте посмотрим на приведенный ниже пример, чтобы объяснить его поведение,

     ```javascript
     var ws = new WeakSet();
     var user = {};
     ws.add(user);
     ws.has(user);    // true
     ws.delete(user); // removes user from the set
     ws.has(user);    // false, user has been removed
     ```

     **[⬆ Back to Top](#table-of-contents)**

204. ### <a name="204"></a> Каковы различия между WeakSet и Set

     Основное отличие состоит в том, что ссылки на объекты в Set являются сильными, а ссылки на объекты в WeakSet — слабыми. т. е. объект в WeakSet может быть удален сборщиком мусора, если на него нет другой ссылки.
     Другие отличия,
     1. Наборы могут хранить любое значение, тогда как WeakSets могут хранить только наборы объектов.
     2. WeakSet не имеет свойства size в отличие от Set
     3. WeakSet не имеет таких методов, как clear, keys, values, entry, forEach.
     4. WeakSet не является итерируемым.

     **[⬆ Back to Top](#table-of-contents)**

205. ### <a name="205"></a> Перечислите коллекцию методов, доступных в WeakSet

     Ниже приведен список методов, доступных в WeakSet,
     
     1. add(value): к слабому набору добавляется новый объект с заданным значением
     2. delete(value): удаляет значение из коллекции WeakSet.
     3. has(value): возвращает true, если значение присутствует в коллекции WeakSet, в противном случае возвращает false.
     
     Давайте посмотрим на функциональность всех вышеперечисленных методов на примере,

     ```javascript
     var weakSetObject = new WeakSet();
     var firstObject = {};
     var secondObject = {};
     // add(value)
     weakSetObject.add(firstObject);
     weakSetObject.add(secondObject);
     console.log(weakSetObject.has(firstObject)); //true
     weakSetObject.delete(secondObject);
     ```

     **[⬆ Back to Top](#table-of-contents)**

206. ### <a name="206"></a> Что такое WeakMap

     Объект WeakMap представляет собой набор пар ключ/значение, в котором на ключи слабо ссылаются. В этом случае ключи должны быть объектами, а значения могут быть произвольными значениями. Синтаксис выглядит следующим образом:

     ```javascript
     new WeakMap([iterable])
     ```

     Давайте посмотрим на приведенный ниже пример, чтобы объяснить его поведение,

     ```javascript
      var ws = new WeakMap();
      var user = {};
      ws.set(user);
      ws.has(user);    // true
      ws.delete(user); // removes user from the map
      ws.has(user);    // false, user has been removed
     ```

     **[⬆ Back to Top](#table-of-contents)**

207. ### <a name="207"></a> Каковы различия между WeakMap и Map

     Основное отличие состоит в том, что ссылки на ключевые объекты в Map являются сильными, а ссылки на ключевые объекты в WeakMap — слабыми. т. е. ключевой объект в WeakMap может быть удален сборщиком мусора, если на него нет другой ссылки.
     Другие отличия,
     1. Maps могут хранить любой тип ключей, тогда как WeakMaps могут хранить только наборы ключевых объектов.
     2. WeakMap не имеет свойства size в отличие от Map
     3. В WeakMap нет таких методов, как clear, keys, values, entry, forEach.
     4. WeakMap не является итерируемым.

     **[⬆ Back to Top](#table-of-contents)**

208. ### <a name="208"></a> Перечислите коллекцию методов, доступных на WeakMap

     Ниже приведен список методов, доступных на WeakMap,
     1. set(key, value): устанавливает значение ключа в объекте WeakMap. Возвращает объект WeakMap.
     2. delete(key): Удаляет любое значение, связанное с ключом.
     3. has(key): возвращает логическое значение, утверждающее, было ли значение связано с ключом в объекте WeakMap или нет.
     4. get(key): возвращает значение, связанное с ключом, или значение undefined, если его нет.
     Давайте посмотрим на функциональность всех вышеперечисленных методов на примере,

     ```javascript
     var weakMapObject = new WeakMap();
     var firstObject = {};
     var secondObject = {};
     // set(key, value)
     weakMapObject.set(firstObject, 'John');
     weakMapObject.set(secondObject, 100);
     console.log(weakMapObject.has(firstObject)); //true
     console.log(weakMapObject.get(firstObject)); // John
     weakMapObject.delete(secondObject);
     ```

     **[⬆ Back to Top](#table-of-contents)**

209. ### <a name="209"></a> Какова цель uneval

     uneval() — это встроенная функция, которая используется для создания строкового представления исходного кода объекта. Это функция верхнего уровня и не связана ни с каким объектом. Давайте посмотрим на приведенный ниже пример, чтобы узнать больше о его функциональности,

     ```javascript
     var a = 1;
     uneval(a); // returns a String containing 1
     uneval(function user() {}); // returns "(function user(){})"
     ```

     **[⬆ Back to Top](#table-of-contents)**

210. ### <a name="210"></a> Как вы кодируете URL

     Функция encodeURI() используется для кодирования полного URI, содержащего специальные символы, за исключением символов (, / ? : @ & = + $ #).

     ```javascript
     var uri = 'https://mozilla.org/?x=шеллы';
     var encoded = encodeURI(uri);
     console.log(encoded); // https://mozilla.org/?x=%D1%88%D0%B5%D0%BB%D0%BB%D1%8B
     ```

     **[⬆ Back to Top](#table-of-contents)**

211. ### <a name="211"></a> Как вы декодируете URL

     Функция decodeURI() используется для декодирования универсального идентификатора ресурса (URI), ранее созданного функцией encodeURI().

     ```javascript
      var uri = 'https://mozilla.org/?x=шеллы';
      var encoded = encodeURI(uri);
      console.log(encoded); // https://mozilla.org/?x=%D1%88%D0%B5%D0%BB%D0%BB%D1%8B
     try {
       console.log(decodeURI(encoded)); // "https://mozilla.org/?x=шеллы"
     } catch(e) { // catches a malformed URI
       console.error(e);
     }
     ```

     **[⬆ Back to Top](#table-of-contents)**

212. ### <a name="212"></a> Как распечатать содержимое веб-страницы

     Объект окна предоставил метод print(), который используется для печати содержимого текущего окна. Откроется диалоговое окно «Печать», в котором можно выбрать различные параметры печати. Давайте посмотрим на использование метода печати в примере,

     ```html
        <input type="button" value="Print" onclick="window.print()" />
     ```

     **Примечание.** В большинстве браузеров он будет заблокирован, пока открыто диалоговое окно печати.

     **[⬆ Back to Top](#table-of-contents)**

213. ### <a name="213"></a> В чем разница между uneval и eval

     Функция `uneval` возвращает исходный код данного объекта; тогда как функция eval делает обратное, оценивая этот исходный код в другой области памяти. Давайте посмотрим на пример, чтобы прояснить разницу,

     ```javascript
     var msg = uneval(function greeting() { return 'Hello, Good morning'; });
     var greeting = eval(msg);
     greeting(); // returns "Hello, Good morning"
     ```

     **[⬆ Back to Top](#table-of-contents)**

214. ### <a name="214"></a> Что такое анонимная функция

     Анонимная функция — это функция без имени! Анонимные функции обычно назначаются имени переменной или используются в качестве функции обратного вызова. Синтаксис будет таким, как показано ниже,

     ```javascript
     function (optionalParameters) {
       //do something
     }

     const myFunction = function(){ //Anonymous function assigned to a variable
       //do something
     };

     [1, 2, 3].map(function(element){ //Anonymous function used as a callback function
       //do something
     });
     ```

     Давайте посмотрим на приведенную выше анонимную функцию в примере,

     ```javascript
     var x = function (a, b) {return a * b};
     var z = x(5, 10);
     console.log(z); // 50
     ```

     **[⬆ Back to Top](#table-of-contents)**

215. ### <a name="215"></a> Каков порядок приоритета между локальными и глобальными переменными

     Локальная переменная имеет приоритет над глобальной переменной с таким же именем. Давайте посмотрим на это поведение на примере.

     ```javascript
     var msg = "Good morning";
     function greeting() {
        msg = "Good Evening";
        console.log(msg);
     }
     greeting();
     ```

     **[⬆ Back to Top](#table-of-contents)**

216. ### <a name="216"></a> Что такое аксессоры javascript

     ECMAScript 5 представил средства доступа к объектам javascript или вычисляемые свойства через геттеры и сеттеры. Getters использует ключевое слово get, тогда как Setters использует ключевое слово set.

     ```javascript
     var user = {
       firstName: "John",
       lastName : "Abraham",
       language : "en",
       get lang() {
         return this.language;
       }
       set lang(lang) {
       this.language = lang;
       }
     };
     console.log(user.lang); // getter access lang as en
     user.lang = 'fr';
     console.log(user.lang); // setter used to set lang as fr
     ```

     **[⬆ Back to Top](#table-of-contents)**

217. ### <a name="217"></a> Как вы определяете свойство в конструкторе объектов

     Статический метод Object.defineProperty() используется для определения нового свойства непосредственно в объекте или изменения существующего свойства объекта и возвращает объект. Давайте посмотрим на пример, чтобы узнать, как определить свойство,

     ```javascript
     const newObject = {};

     Object.defineProperty(newObject, 'newProperty', {
       value: 100,
       writable: false
     });

     console.log(newObject.newProperty); // 100

     newObject.newProperty = 200; // It throws an error in strict mode due to writable setting

     ```

     **[⬆ Back to Top](#table-of-contents)**

218. ### <a name="218"></a> В чем разница между get и defineProperty

     Оба имеют аналогичные результаты, пока вы не используете классы. Если вы используете `get`, свойство будет определено в прототипе объекта, тогда как при использовании `Object.defineProperty()` свойство будет определено в экземпляре, к которому оно применяется.

     **[⬆ Back to Top](#table-of-contents)**

219. ### <a name="219"></a> В чем преимущества геттеров и сеттеров

     Ниже приведен список преимуществ геттеров и сеттеров,
     1. Они обеспечивают более простой синтаксис
     2. Они используются для определения вычисляемых свойств или методов доступа в JS.
     3. Полезно для обеспечения отношения эквивалентности между свойствами и методами.
     4. Они могут обеспечить лучшее качество данных
     5. Полезно для работы за кулисами с инкапсулированной логикой.

     **[⬆ Back to Top](#table-of-contents)**

220. ### <a name="220"></a> Могу ли я добавить геттеры и сеттеры, используя метод defineProperty

     Да, вы можете использовать метод Object.defineProperty() для добавления геттеров и сеттеров. Например, в приведенном ниже объекте счетчика используются свойства увеличения, уменьшения, добавления и вычитания,

     ```javascript
     var obj = {counter : 0};

     // Define getters
     Object.defineProperty(obj, "increment", {
       get : function () {this.counter++;}
     });
     Object.defineProperty(obj, "decrement", {
       get : function () {this.counter--;}
     });

     // Define setters
     Object.defineProperty(obj, "add", {
       set : function (value) {this.counter += value;}
     });
     Object.defineProperty(obj, "subtract", {
       set : function (value) {this.counter -= value;}
     });

     obj.add = 10;
     obj.subtract = 5;
     console.log(obj.increment); //6
     console.log(obj.decrement); //5
     ```

     **[⬆ Back to Top](#table-of-contents)**

221. ### <a name="221"></a> Каково назначение switch-case

     Оператор switch case в JavaScript используется для принятия решений. В некоторых случаях использование оператора switch case будет более удобным, чем использование оператора if-else. Синтаксис будет таким, как показано ниже,

     ```javascript
     switch (expression)
     {
         case value1:
             statement1;
             break;
         case value2:
             statement2;
             break;
         .
         .
         case valueN:
             statementN;
             break;
         default:
             statementDefault;
     }
     ```

     Приведенный выше оператор многоканальной ветвления обеспечивает простой способ диспетчеризации выполнения в разные части кода на основе значения выражения.

     **[⬆ Back to Top](#table-of-contents)**

222. ### <a name="222"></a> Каких соглашений следует придерживаться при использовании swtich case

     Ниже приведен список соглашений, которые следует соблюдать,
     1. Выражение может быть числового или строкового типа.
     2. Для выражения не допускаются повторяющиеся значения.
     3. Оператор по умолчанию является необязательным. Если выражение, переданное в switch, не совпадает ни с одним значением case, то будет выполнен оператор в case по умолчанию.
     4. Оператор break используется внутри переключателя для завершения последовательности операторов.
     5. Оператор break необязателен. Но если он опущен, выполнение продолжится в следующем случае.

     **[⬆ Back to Top](#table-of-contents)**

223. ### <a name="223"></a> Что такое примитивные типы данных

     Примитивный тип данных — это данные, имеющие примитивное значение (у которого нет ни свойств, ни методов). Существует 7 типов примитивных типов данных.
     
     1. string
     2. number
     3. boolean
     4. null
     5. undefined
     6. bigint
     7. symbol

     **[⬆ Back to Top](#table-of-contents)**

224. ### <a name="224"></a> Какие существуют способы доступа к свойствам объекта

     Существует 3 возможных способа доступа к свойству объекта.
     1. **Точка:** для доступа к свойствам используется точка.

     ```javascript
     objectName.property
     ```

     1. **Квадратные скобки:** Квадратные скобки используются для доступа к свойствам.

     ```javascript
     objectName["property"]
     ```

     1. **Обозначение выражений:** используется выражение в квадратных скобках.

     ```javascript
     objectName[expression]
     ```

     **[⬆ Back to Top](#table-of-contents)**

225. ### <a name="225"></a> Каковы правила параметров функции

     Функции JavaScript следуют приведенным ниже правилам для параметров,
     1. В определениях функций не указаны типы данных для параметров.
     2. Не выполнять проверку типов переданных аргументов.
     3. Не проверять количество полученных аргументов.
     т. е. приведенная ниже функция следует приведенным выше правилам,

     ```javascript
     function functionName(parameter1, parameter2, parameter3) {
       console.log(parameter1); // 1
     }
     functionName(1);
     ```

     **[⬆ Back to Top](#table-of-contents)**

226. ### <a name="226"></a> Что такое объект ошибки

     Объект ошибки — это встроенный объект ошибки, который предоставляет информацию об ошибке при возникновении ошибки. У него есть два свойства: имя и сообщение. Например, приведенная ниже функция регистрирует сведения об ошибках,

     ```javascript
     try {
       greeting("Welcome");
     }
     catch(err) {
       console.log(err.name + "<br>" + err.message);
     }
     ```

     **[⬆ Back to Top](#table-of-contents)**

227. ### <a name="227"></a> Когда вы получаете синтаксическую ошибку

     SyntaxError возникает, если вы пытаетесь оценить код с синтаксической ошибкой. Например, приведенная ниже отсутствующая кавычка для параметра функции вызывает синтаксическую ошибку.

     ```javascript
     try {
       eval("greeting('welcome)");   // Missing ' will produce an error
     }
     catch(err) {
       console.log(err.name);
     }
     ```

     **[⬆ Back to Top](#table-of-contents)**

228. ### <a name="228"></a> Каковы разные имена ошибок из объекта ошибки

     Существует 6 различных типов имен ошибок, возвращаемых из объекта ошибки,
     | Имя ошибки | Описание |
     |---- | ---------
     | EvalError | Произошла ошибка в функции eval() |
     | Ошибка диапазона | Произошла ошибка с номером "вне диапазона" |
     | Ошибка ссылки | Ошибка из-за недопустимой ссылки|
     | Синтаксическая ошибка | Ошибка из-за синтаксической ошибки|
     | ошибка типа | Ошибка из-за ошибки типа |
     | URIОшибка | Ошибка из-за encodeURI() |

     **[⬆ Back to Top](#table-of-contents)**

229. ### <a name="229"></a> Каковы различные утверждения в обработке ошибок

     Ниже приведен список операторов, используемых при обработке ошибок.
     1. **try:** Этот оператор используется для проверки блока кода на наличие ошибок.
     2. **catch:** Этот оператор используется для обработки ошибки.
     3. **throw:** Этот оператор используется для создания пользовательских ошибок.
     4. **finally:** Этот оператор используется для выполнения кода после try and catch независимо от результата.

     **[⬆ Back to Top](#table-of-contents)**

230. ### <a name="230"></a> Какие два типа циклов в javascript

     1. **Контролируемые циклы входа:** В этом типе цикла условие тестирования проверяется перед входом в тело цикла. Например, в эту категорию входят For Loop и While Loop.
     2. **Контролируемые циклы выхода:** В этом типе цикла условие тестирования проверяется или оценивается в конце тела цикла.

     **[⬆ Back to Top](#table-of-contents)**

231. ### <a name="231"></a> Что такое nodejs

     Node.js — это серверная платформа, созданная на основе среды выполнения Chrome JavaScript для простого создания быстрых и масштабируемых сетевых приложений. Это основанная на событиях, неблокирующая, асинхронная среда выполнения ввода-вывода, которая использует механизм Google V8 JavaScript и библиотеку libuv.

     **[⬆ Back to Top](#table-of-contents)**

232. ### <a name="232"></a> Что такое объект Intl

     Объект Intl — это пространство имен для API интернационализации ECMAScript, которое обеспечивает сравнение строк с учетом языка, форматирование чисел, а также форматирование даты и времени. Он обеспечивает доступ к нескольким конструкторам и функциям, зависящим от языка.

     **[⬆ Back to Top](#table-of-contents)**

233. ### <a name="233"></a> Как вы выполняете форматирование даты и времени для конкретного языка

     Вы можете использовать объект `Intl.DateTimeFormat`, который является конструктором для объектов, которые позволяют форматировать дату и время с учетом языка. Давайте посмотрим на это поведение на примере,

     ```javascript
     var date = new Date(Date.UTC(2019, 07, 07, 3, 0, 0));
     console.log(new Intl.DateTimeFormat('en-GB').format(date)); // 07/08/2019
     console.log(new Intl.DateTimeFormat('en-AU').format(date)); // 07/08/2019
     ```

     **[⬆ Back to Top](#table-of-contents)**

234. ### <a name="234"></a> Что такое итератор

     Итератор — это объект, который определяет последовательность и возвращаемое значение после его завершения. Он реализует протокол Iterator с методом `next()`, который возвращает объект с двумя свойствами: `value` (следующее значение в последовательности) и `done` (что верно, если последнее значение в последовательности было использовано). ).

     **[⬆ Back to Top](#table-of-contents)**

235. ### <a name="235"></a> Как работает синхронная итерация

     Синхронная итерация была введена в ES6 и работает со следующим набором компонентов:

     **Iterable:** Это объект, который можно перебирать с помощью метода, ключ которого — Symbol.iterator.
     **Итератор:** Это объект, возвращаемый вызовом `[Symbol.iterator]()` для итерируемого объекта. Этот объект итератора оборачивает каждый итерируемый элемент в объект и возвращает его с помощью метода `next()` один за другим.
     **IteratorResult:** Это объект, возвращаемый методом `next()`. Объект содержит два свойства; свойство `value` содержит повторяющийся элемент, а свойство `done` определяет, является ли этот элемент последним или нет.

     Давайте продемонстрируем синхронную итерацию с массивом, как показано ниже:

     ```javascript
     const iterable = ['one', 'two', 'three'];
     const iterator = iterable[Symbol.iterator]();
     console.log(iterator.next());  // { value: 'one', done: false }
     console.log(iterator.next());  // { value: 'two', done: false }
     console.log(iterator.next());  // { value: 'three', done: false }
     console.log(iterator.next());  // { value: 'undefined, done: true }
     ```

     **[⬆ Back to Top](#table-of-contents)**

236. ### <a name="236"></a> Что такое цикл событий(event loop)

     Цикл событий — это очередь функций обратного вызова. Когда выполняется асинхронная функция, функция обратного вызова помещается в очередь. Механизм JavaScript не начинает обработку цикла событий, пока асинхронная функция не завершит выполнение кода.
     **Примечание.** Это позволяет Node.js выполнять неблокирующие операции ввода-вывода, даже если JavaScript является однопоточным.

     **[⬆ Back to Top](#table-of-contents)**

237. ### <a name="237"></a> Что такое стек вызовов (call stack)

     Стек вызовов — это структура данных для интерпретаторов javascript, позволяющая отслеживать вызовы функций в программе. Он имеет два основных действия,
     1. Всякий раз, когда вы вызываете функцию для ее выполнения, вы помещаете ее в стек.
     2. Всякий раз, когда выполнение завершается, функция извлекается из стека.

     Давайте возьмем пример и его представление состояния в формате диаграммы.

     ```javascript
     function hungry() {
        eatFruits();
     }
     function eatFruits() {
        return "I'm eating fruits";
     }

     // Invoke the `hungry` function
     hungry();
     ```

     Приведенный выше код обрабатывается в стеке вызовов, как показано ниже:
     1. Добавьте функцию `hungry()` в список стека вызовов и выполните код.
     2. Добавьте функцию `eatFruits()` в список стека вызовов и выполните код.
     3. Удалите функцию `eatFruits()` из нашего списка вызовов.
     4. Удалите функцию `hungry()` из списка стека вызовов, так как элементов больше нет.

     ![Screenshot](images/call-stack.png)

     **[⬆ Back to Top](#table-of-contents)**

238. ### <a name="238"></a> Что такое очередь событий (event queue)

     **[⬆ Back to Top](#table-of-contents)**

239. ### <a name="239"></a> Что такое декоратор

     Декоратор — это выражение, результатом которого является функция, принимающая цель, имя и дескриптор декоратора в качестве аргументов. Кроме того, он необязательно возвращает дескриптор декоратора для установки на целевой объект. Давайте определим декоратор администратора для пользовательского класса во время разработки,

     ```javascript
     function admin(isAdmin) {
        return function(target) {
            target.isAdmin = isAdmin;
        }
     }

     @admin(true)
     class User() {
     }
     console.log(User.isAdmin); //true

      @admin(false)
      class User() {
      }
      console.log(User.isAdmin); //false
     ```

     **[⬆ Back to Top](#table-of-contents)**

240. ### <a name="240"></a> Каковы свойства объекта Intl

     Ниже приведен список свойств, доступных для объекта Intl,
      1. **Collator:** это объекты, которые позволяют сравнивать строки с учетом языка.
      2. **DateTimeFormat:** это объекты, которые позволяют форматировать дату и время с учетом языка.
      3. **ListFormat:** это объекты, которые позволяют форматировать список с учетом языка.
      4. **NumberFormat:** объекты, которые позволяют форматировать числа с учетом языка.
      5. **PluralRules:** объекты, которые включают форматирование с учетом множественного числа и языковые правила для множественного числа.
      6. **RelativeTimeFormat:** объекты, которые позволяют форматировать относительное время с учетом языка.

     **[⬆ Back to Top](#table-of-contents)**

241. ### <a name="241"></a> Что такое унарный оператор

     Унарный (+) оператор используется для преобразования переменной в число. Если переменную нельзя преобразовать, она все равно станет числом, но со значением NaN. Давайте посмотрим на это поведение в действии.

     ```javascript
     var x = "100";
     var y = + x;
     console.log(typeof x, typeof y); // string, number

     var a = "Hello";
     var b = + a;
     console.log(typeof a, typeof b, b); // string, number, NaN
     ```

     **[⬆ Back to Top](#table-of-contents)**

242. ### <a name="242"></a> Как сортировать элементы в массиве

     Метод sort() используется для сортировки элементов массива на месте и возвращает отсортированный массив. Пример использования будет таким, как показано ниже:

     ```javascript
     var months = ["Aug", "Sep", "Jan", "June"];
     months.sort();
     console.log(months); //  ["Aug", "Jan", "June", "Sep"]
     ```

     **[⬆ Back to Top](#table-of-contents)**

243. ### <a name="243"></a> Какова цель compareFunction при сортировке массивов

     Функция сравнения используется для определения порядка сортировки. Если он опущен, элементы массива преобразуются в строки, а затем сортируются в соответствии со значением кодовой точки Unicode для каждого символа. Давайте возьмем пример, чтобы увидеть использование compareFunction,

     ```javascript
     let numbers = [1, 2, 5, 3, 4];
     numbers.sort((a, b) => b - a);
     console.log(numbers); // [5, 4, 3, 2, 1]
     ```

     **[⬆ Back to Top](#table-of-contents)**

244. ### <a name="244"></a> Как вы reversing массив

     Вы можете использовать метод reverse(), чтобы поменять местами элементы в массиве. Этот метод полезен для сортировки массива в порядке убывания. Давайте посмотрим на использование метода reverse() в примере,

     ```javascript
     let numbers = [1, 2, 5, 3, 4];
     numbers.sort((a, b) => b - a);
     numbers.reverse();
     console.log(numbers); // [1, 2, 3, 4 ,5]
     ```

     **[⬆ Back to Top](#table-of-contents)**

245. ### <a name="245"></a> Как найти минимальное и максимальное значение в массиве

     Вы можете использовать методы `Math.min` и `Math.max` для переменных массива, чтобы найти минимальный и максимальный элементы в массиве. Давайте создадим две функции для поиска минимального и максимального значения в массиве,

     ```javascript
     var marks = [50, 20, 70, 60, 45, 30];
     function findMin(arr) {
       return Math.min.apply(null, arr);
     }
     function findMax(arr) {
       return Math.max.apply(null, arr);
     }

     console.log(findMin(marks));
     console.log(findMax(marks));
     ```

     **[⬆ Back to Top](#table-of-contents)**

246. ### <a name="246"></a> Как найти минимальное и максимальное значения без Math функций

     Вы можете написать функции, которые перебирают массив, сравнивая каждое значение с самым низким или самым высоким значением, чтобы найти минимальное и максимальное значения. Давайте создадим эти функции для поиска минимального и максимального значений,

     ```javascript
      var marks = [50, 20, 70, 60, 45, 30];
      function findMin(arr) {
        var length = arr.length
        var min = Infinity;
        while (length--) {
          if (arr[length] < min) {
            min = arr[len];
          }
        }
        return min;
      }

      function findMax(arr) {
        var length = arr.length
        var max = -Infinity;
        while (len--) {
          if (arr[length] > max) {
            max = arr[length];
          }
        }
        return max;
      }

      console.log(findMin(marks));
      console.log(findMax(marks));
     ```

     **[⬆ Back to Top](#table-of-contents)**

247. ### <a name="247"></a> Что такое empty statement и его цель

     Пустой оператор представляет собой точку с запятой (;), указывающую, что оператор не будет выполняться, даже если синтаксис JavaScript этого требует. Так как нет действия с пустым оператором, вы можете подумать, что его использование гораздо меньше, но пустой оператор иногда полезен, когда вы хотите создать цикл с пустым телом. Например, вы можете инициализировать массив нулевыми значениями, как показано ниже:

     ```javascript
     // Initialize an array a
     for(int i=0; i < a.length; a[i++] = 0) ;
     ```

     **[⬆ Back to Top](#table-of-contents)**

248. ### <a name="248"></a> Как получить метаданные модуля

     Вы можете использовать объект `import.meta`, который является мета-свойством, предоставляющим контекстно-зависимые метаданные модулю JavaScript. Он содержит информацию о текущем модуле, например URL-адрес модуля. В браузерах вы можете получить метаданные, отличные от NodeJS.

     ```javascript
     <script type="module" src="welcome-module.js"></script>
     console.log(import.meta); // { url: "file:///home/user/welcome-module.js" }
     ```

     **[⬆ Back to Top](#table-of-contents)**

249. ### <a name="249"></a> Что такое запятая operator

     Оператор запятая используется для оценки каждого из своих операндов слева направо и возвращает значение последнего операнда. Это полностью отличается от использования запятых в массивах, объектах, аргументах и ​​параметрах функций. Например, использование числовых выражений будет следующим:

     ```javascript
     var x = 1;
     x = (x++, x);

     console.log(x); // 2
     ```

     **[⬆ Back to Top](#table-of-contents)**

250. ### <a name="250"></a> В чем преимущество оператора запятой

     Обычно он используется для включения нескольких выражений в место, где требуется одно выражение. Одним из распространенных применений этого оператора запятой является предоставление нескольких параметров в цикле for. Например, в приведенном ниже цикле for используется несколько выражений в одном месте с использованием оператора запятой,

     ```javascript
     for (var a = 0, b =10; a <= 10; a++, b--)
     ```

     Вы также можете использовать оператор запятой в операторе return, где он обрабатывается перед возвратом.

     ```javascript
     function myFunction() {
        var a = 1;
        return (a += 10, a); // 11
     }
     ```

     **[⬆ Back to Top](#table-of-contents)**

251. ### <a name="251"></a> Что такое typescript

      TypeScript — это типизированный расширенный набор JavaScript, созданный Microsoft, который добавляет необязательные типы, классы, async/await и многие другие функции и компилируется в простой JavaScript. Angular полностью построен на TypeScript и используется в качестве основного языка. Вы можете установить его глобально как

      ```bash
      npm install -g typescript
      ```

      Давайте посмотрим на простой пример использования TypeScript,

      ```typescript
      function greeting(name: string): string {
         return "Hello, " + name;
      }

      let user = "Sudheer";

      console.log(greeting(user));
      ```

      Метод приветствия допускает в качестве аргумента только строковый тип.

      **[⬆ Back to Top](#table-of-contents)**

252. ### <a name="252"></a> В чем разница между javascript и typescript

     Ниже приведен список различий между javascript и typescript,

     | функция | Typescript | JavaScript |
     |---- | --------- | ----
     | Языковая парадигма | Объектно-ориентированный язык программирования | Скриптовый язык |
     | Поддержка ввода | Поддерживает статическую типизацию | Он имеет динамическую типизацию |
     | Модули | Поддерживается | Не поддерживается |
     | Интерфейс | Он имеет концепцию интерфейсов | Не поддерживает интерфейсы |
     | Дополнительные параметры | Функции поддерживают необязательные параметры | Нет поддержки необязательных параметров для функций |

     **[⬆ Back to Top](#table-of-contents)**

253. ### <a name="253"></a> Каковы преимущества typescript перед javascript

     Ниже приведены некоторые преимущества машинописного текста по сравнению с javascript.
     1. TypeScript может находить ошибки времени компиляции только во время разработки и обеспечивает меньшее количество ошибок времени выполнения. Принимая во внимание, что javascript - это интерпретируемый язык.
     2. TypeScript является строго типизированным или поддерживает статическую типизацию, что позволяет проверять правильность типов во время компиляции. Это недоступно в javascript.
     3. Компилятор TypeScript может компилировать файлы .ts в ES3, ES4 и ES5, в отличие от функций JavaScript ES6, которые могут не поддерживаться в некоторых браузерах.

     **[⬆ Back to Top](#table-of-contents)**

254. ### <a name="254"></a> Что такое инициализатор объекта

     Инициализатор объекта — это выражение, описывающее инициализацию объекта. Синтаксис этого выражения представлен в виде разделенного запятыми списка из нуля или более пар имен свойств и связанных значений объекта, заключенных в фигурные скобки ({}). Это также известно как буквальное обозначение. Это один из способов создания объекта.

     ```javascript
     var initObject = {a: 'John', b: 50, c: {}};

     console.log(initObject.a); // John
     ```

     **[⬆ Back to Top](#table-of-contents)**

255. ### <a name="255"></a> Что такое constructor method

     Метод конструктора — это специальный метод для создания и инициализации объекта, созданного внутри класса. Если вы не укажете метод конструктора, будет использоваться конструктор по умолчанию. Пример использования конструктора будет таким, как показано ниже:

     ```javascript
     class Employee {
       constructor() {
         this.name = "John";
       }
     }

     var employeeObject = new Employee();

     console.log(employeeObject.name); // John
     ```

     **[⬆ Back to Top](#table-of-contents)**

256. ### <a name="256"></a> Что произойдет, если вы напишете конструктор более одного раза в классе

     «Конструктор» в классе — это специальный метод, и он должен быть определен только один раз в классе. т. е. если вы напишете метод конструктора более одного раза в классе, он вызовет ошибку SyntaxError.

     ```javascript
      class Employee {
        constructor() {
          this.name = "John";
        }
        constructor() {   //  Uncaught SyntaxError: A class may only have one constructor
          this.age = 30;
        }
      }

      var employeeObject = new Employee();

      console.log(employeeObject.name);
     ```

     **[⬆ Back to Top](#table-of-contents)**

257. ### <a name="257"></a> Как вы вызываете конструктор родительского класса

     Вы можете использовать ключевое слово super для вызова конструктора родительского класса. Помните, что `super()` должен быть вызван перед использованием ссылки 'this'. В противном случае это вызовет ошибку ссылки. Давайте использовать его,

     ```javascript
     class Square extends Rectangle {
       constructor(length) {
         super(length, length);
         this.name = 'Square';
       }

       get area() {
         return this.width * this.height;
       }

       set area(value) {
         this.area = value;
       }
     }
     ```

     **[⬆ Back to Top](#table-of-contents)**

258. ### <a name="258"></a> Как получить прототип объекта

     Вы можете использовать метод Object.getPrototypeOf(obj) для возврата прототипа указанного объекта. то есть значение внутреннего свойства «прототип». Если унаследованных свойств нет, возвращается значение null.

     ```javascript
     const newPrototype = {};
     const newObject = Object.create(newPrototype);

     console.log(Object.getPrototypeOf(newObject) === newPrototype); // true
     ```

     **[⬆ Back to Top](#table-of-contents)**

259. ### <a name="259"></a> Что произойдет, если я передам строковый тип для метода getPrototype

     В ES5 будет выдано исключение TypeError, если параметр obj не является объектом. Принимая во внимание, что в ES2015 параметр будет приведен к «Объекту».

     ```javascript
     // ES5
     Object.getPrototypeOf('James'); // TypeError: "James" is not an object
     // ES2015
     Object.getPrototypeOf('James'); // String.prototype
     ```

     **[⬆ Back to Top](#table-of-contents)**

260. ### <a name="260"></a> Как вы устанавливаете прототип одного объекта для другого

     Вы можете использовать метод `Object.setPrototypeOf()`, который устанавливает прототип (т. е. внутреннее свойство `Prototype`) указанного объекта на другой объект или нуль. Например, если вы хотите установить прототип квадратного объекта в прямоугольный объект, это будет следующим образом:

     ```javascript
     Object.setPrototypeOf(Square.prototype, Rectangle.prototype);
     Object.setPrototypeOf({}, null);
     ```

     **[⬆ Back to Top](#table-of-contents)**

261. ### <a name="261"></a> Как вы проверяете, может ли объект быть расширяемым или нет?

     Метод Object.isExtensible() используется для определения того, является ли объект расширяемым или нет. т. е. могут ли к нему добавляться новые свойства или нет.

     ```javascript
     const newObject = {};
     console.log(Object.isExtensible(newObject)); //true
     ```

     **Примечание.** По умолчанию все объекты расширяемы. т. е. новые свойства могут быть добавлены или изменены.

     **[⬆ Back to Top](#table-of-contents)**

262. ### <a name="262"></a> Как предотвратить расширение объекта

     Метод Object.preventExtensions() используется для предотвращения добавления новых свойств к объекту. Другими словами, это предотвращает будущие расширения объекта. Давайте посмотрим на использование этого свойства,

     ```javascript
     const newObject = {};
     Object.preventExtensions(newObject); // NOT extendable

     try {
       Object.defineProperty(newObject, 'newProperty', { // Adding new property
         value: 100
       });
     } catch (e) {
       console.log(e); // TypeError: Cannot define property newProperty, object is not extensible
     }
     ```

     **[⬆ Back to Top](#table-of-contents)**

263. ### <a name="263"></a> Какие существуют способы сделать объект нерасширяемым?

     Вы можете пометить объект как нерасширяемый тремя способами:
     1. Object.preventExtensions
     2. Объект.seal
     3. Объект.freeze

     ```javascript
     var newObject = {};

     Object.preventExtensions(newObject); // Prevent objects are non-extensible
     Object.isExtensible(newObject); // false

     var sealedObject = Object.seal({}); // Sealed objects are non-extensible
     Object.isExtensible(sealedObject); // false

     var frozenObject = Object.freeze({}); // Frozen objects are non-extensible
     Object.isExtensible(frozenObject); // false
     ```

     **[⬆ Back to Top](#table-of-contents)**

264. ### <a name="264"></a> Как определить несколько свойств объекта

     Метод Object.defineProperties() используется для определения новых или изменения существующих свойств непосредственно в объекте и возврата объекта. Давайте определим несколько свойств для пустого объекта,

     ```javascript
     const newObject = {};

     Object.defineProperties(newObject, {
       newProperty1: {
         value: 'John',
         writable: true
       },
       newProperty2: {}
     });
     ```

     **[⬆ Back to Top](#table-of-contents)**

265. ### <a name="265"></a> Что такое MEAN в javascript

     Стек MEAN (MongoDB, Express, AngularJS и Node.js) — это самый популярный технологический стек программного обеспечения JavaScript с открытым исходным кодом, доступный для создания динамических веб-приложений, где вы можете писать как серверную, так и клиентскую части веб-проекта. полностью на JavaScript.

     **[⬆ Back to Top](#table-of-contents)**

266. ### <a name="266"></a> Что такое обфускация в javascript? (Obfuscation)

     Обфускация — это преднамеренное действие по созданию запутанного кода javascript (т. е. исходного или машинного кода), который трудно понять людям. Это что-то похожее на шифрование, но машина может понять код и выполнить его.
     Давайте посмотрим на приведенную ниже функцию перед запутыванием,

     ```javascript
     function greeting() {
        console.log('Hello, welcome to JS world');
     }
     ```

     И после обфускации кода он будет выглядеть так, как показано ниже:

     ```javascript
     eval(function(p,a,c,k,e,d){e=function(c){return c};if(!''.replace(/^/,String)){while(c--){d[c]=k[c]||c}k=[function(e){return d[e]}];e=function(){return'\\w+'};c=1};while(c--){if(k[c]){p=p.replace(new RegExp('\\b'+e(c)+'\\b','g'),k[c])}}return p}('2 1(){0.3(\'4, 7 6 5 8\')}',9,9,'console|greeting|function|log|Hello|JS|to|welcome|world'.split('|'),0,{}))
     ```

     **[⬆ Back to Top](#table-of-contents)**

267. ### <a name="267"></a> Зачем тебе нужна Obfuscation

     Ниже приведены несколько причин обфускации,
     1. Размер кода будет уменьшен. Таким образом, передача данных между сервером и клиентом будет быстрой.
     2. Он скрывает бизнес-логику от внешнего мира и защищает код от посторонних.
     3. Обратный инжиниринг — это очень сложно
     4. Время загрузки будет уменьшено

     **[⬆ Back to Top](#table-of-contents)**

268. ### <a name="268"></a> Что такое минификация

     Минификация — это процесс удаления всех ненужных символов (пустые пробелы удаляются), а переменные будут переименованы без изменения их функциональности. Это также тип обфускации.

     **[⬆ Back to Top](#table-of-contents)**

269. ### <a name="269"></a> В чем преимущества минификации

     Обычно рекомендуется использовать минификацию для интенсивного трафика и интенсивных требований к ресурсам. Это уменьшает размер файлов с нижеуказанными преимуществами,
     1. Уменьшает время загрузки веб-страницы
     2. Экономит пропускную способность

     **[⬆ Back to Top](#table-of-contents)**

270. ### <a name="270"></a> В чем разница межд обфускацией и шифрованием? Obfuscation и Encryption

     Ниже приведены основные различия между обфускацией и шифрованием.

     | Особенность | Обфускация | Шифрование |
     |---- | --------- | ----
     | Определение | Изменение формы любых данных в любой другой форме | Изменение формы информации на нечитаемый формат с помощью ключа |
     | Ключ для расшифровки | Его можно расшифровать без ключа | Требуется |
     | Целевой формат данных | Он будет преобразован в сложную форму | Преобразование в нечитаемый формат |

     **[⬆ Back to Top](#table-of-contents)**

271. ### <a name="271"></a> Какие общие инструменты используются для минификации

     Существует множество онлайн/офлайн-инструментов для минимизации файлов javascript,
     1. Google's Closure Compiler
     2. UglifyJS2
     3. jsmin
     4. javascript-minifier.com/
     5. Prettydiff.com

     **[⬆ Back to Top](#table-of-contents)**

272. ### <a name="272"></a> Как вы выполняете проверку формы с помощью javascript

     JavaScript можно использовать для проверки формы HTML. Например, если поле формы пусто, функция должна уведомить об этом и вернуть false, чтобы предотвратить отправку формы.
     Давайте выполним вход пользователя в html-форме,

     ```html
     <form name="myForm" onsubmit="return validateForm()" method="post">
     User name: <input type="text" name="uname">
     <input type="submit" value="Submit">
     </form>
     ```

     И проверка входа пользователя ниже,

     ```javascript
     function validateForm() {
       var x = document.forms["myForm"]["uname"].value;
       if (x == "") {
         alert("The username shouldn't be empty");
         return false;
       }
     }
     ```

     **[⬆ Back to Top](#table-of-contents)**

273. ### <a name="273"></a> Как вы выполняете проверку формы без javascript

     Вы можете автоматически выполнять проверку HTML-формы без использования javascript. Проверка включена путем применения атрибута `required`, чтобы предотвратить отправку формы, когда ввод пуст.

     ```html
     <form method="post">
       <input type="text" name="uname" required>
       <input type="submit" value="Submit">
     </form>
     ```

     **Примечание.** Автоматическая проверка формы не работает в Internet Explorer 9 и более ранних версиях.

     **[⬆ Back to Top](#table-of-contents)**

274. ### <a name="274"></a> Какие методы DOM доступны для проверки ограничений

     Приведенные ниже методы DOM доступны для проверки ограничений на недопустимый ввод,
     1. checkValidity(): возвращает true, если входной элемент содержит достоверные данные.
     2. setCustomValidity(): используется для установки свойства validationMessage элемента ввода.
     Давайте возьмем форму входа пользователя с проверкой DOM.

     ```javascript
     function myFunction() {
       var userName = document.getElementById("uname");
       if (!userName.checkValidity()) {
         document.getElementById("message").innerHTML = userName.validationMessage;
       } else {
         document.getElementById("message").innerHTML = "Entered a valid username";
       }
     }
     ```

     **[⬆ Back to Top](#table-of-contents)**

275. ### <a name="275"></a> Каковы доступные свойства DOM проверки ограничений

     Ниже приведен список некоторых доступных свойств DOM проверки ограничений,

     1. validity: предоставляет список логических свойств, связанных с действительностью элемента ввода.
     2. validationMessage: отображает сообщение, когда действительность ложна.
     3. willValidate: указывает, будет ли элемент ввода проверен или нет.

     **[⬆ Back to Top](#table-of-contents)**

276. ### <a name="276"></a> Каков список свойств валидности

     Свойство допустимости входного элемента предоставляет набор свойств, связанных с достоверностью данных.

     1. customError: возвращает true, если установлено пользовательское сообщение о допустимости.
     2. patternMismatch: возвращает true, если значение элемента не соответствует его атрибуту шаблона.
     3. rangeOverflow: возвращает true, если значение элемента больше его атрибута max.
     4. rangeUnderflow: возвращает true, если значение элемента меньше его минимального атрибута.
     5. stepMismatch: возвращает true, если значение элемента недопустимо в соответствии с атрибутом шага.
     6. tooLong: возвращает true, если значение элемента превышает его атрибут maxLength.
     7. typeMismatch: возвращает true, если значение элемента недопустимо в соответствии с атрибутом типа.
     8. valueMissing: возвращает true, если элемент с обязательным атрибутом не имеет значения.
     9. valid: возвращает true, если значение элемента допустимо.

     **[⬆ Back to Top](#table-of-contents)**

277. ### <a name="277"></a> Приведите пример использования свойства rangeOverflow

     Если значение элемента больше, чем его максимальный атрибут, то свойство rangeOverflow возвращает значение true. Например, при отправке формы ниже возникает ошибка, если значение больше 100,

     ```html
     <input id="age" type="number" max="100">
     <button onclick="myOverflowFunction()">OK</button>
     ```

     ```javascript
     function myOverflowFunction() {
       if (document.getElementById("age").validity.rangeOverflow) {
         alert("The mentioned age is not allowed");
       }
     }
     ```

     **[⬆ Back to Top](#table-of-contents)**

278. ### <a name="278"></a> Доступна ли функция enums в javascript

     Нет, javascript изначально не поддерживает перечисления. Но существуют различные решения для их имитации, даже если они не обеспечивают точных эквивалентов. Например, вы можете использовать заморозку или печать на объекте,

     ```javascript
     var DaysEnum = Object.freeze({"monday":1, "tuesday":2, "wednesday":3, ...})
     ```

     **[⬆ Back to Top](#table-of-contents)**

279. ### <a name="279"></a> Что такое enum? (перечисление)

     Перечисление — это тип, ограничивающий переменные одним значением из предопределенного набора констант. В JavaScript нет перечислений, но машинописный текст обеспечивает встроенную поддержку перечислений.

     ```javascript
     enum Color {
      RED, GREEN, BLUE
     }
     ```

     **[⬆ Back to Top](#table-of-contents)**

280. ### <a name="280"></a> Как перечислить все свойства объекта

     Вы можете использовать метод Object.getOwnPropertyNames(), который возвращает массив всех свойств, найденных непосредственно в данном объекте. Давайте использовать его в примере,

     ```javascript
     const newObject = {
       a: 1,
       b: 2,
       c: 3
     };

     console.log(Object.getOwnPropertyNames(newObject));  ["a", "b", "c"]
     ```

     **[⬆ Back to Top](#table-of-contents)**

281. ### <a name="281"></a> Как получить дескрипторы свойств объекта

     Вы можете использовать метод Object.getOwnPropertyDescriptors(), который возвращает все собственные дескрипторы свойств данного объекта. Пример использования этого метода приведен ниже,

     ```javascript
      const newObject = {
        a: 1,
        b: 2,
        c: 3
      };
     const descriptorsObject = Object.getOwnPropertyDescriptors(newObject);
     console.log(descriptorsObject.a.writable); //true
     console.log(descriptorsObject.a.configurable); //true
     console.log(descriptorsObject.a.enumerable); //true
     console.log(descriptorsObject.a.value); // 1
     ```

     **[⬆ Back to Top](#table-of-contents)**

282. ### <a name="282"></a> Какие атрибуты предоставляет дескриптор свойства

     Дескриптор свойства — это запись, которая имеет следующие атрибуты.
     1. значение: значение, связанное со свойством
     2. writeble: определяет, можно ли изменить значение, связанное со свойством, или нет.
     3. configurable: возвращает true, если тип этого дескриптора свойства может быть изменен и если свойство может быть удалено из соответствующего объекта.
     4. enumerable: определяет, появляется ли свойство при перечислении свойств соответствующего объекта или нет.
     5. set: функция, которая служит установщиком для свойства.
     6. get: функция, которая служит получателем свойства.

     **[⬆ Back to Top](#table-of-contents)**

283. ### <a name="283"></a> Как вы наследуете classes

     Ключевое слово `extends` используется в объявлениях/выражениях класса для создания класса, который является потомком другого класса. Его можно использовать для подкласса пользовательских классов, а также встроенных объектов. Синтаксис будет таким, как показано ниже,

     ```javascript
     class ChildClass extends ParentClass { ... }
     ```

     Давайте возьмем пример подкласса Square из родительского класса Polygon,

     ```javascript
      class Square extends Rectangle {
        constructor(length) {
          super(length, length);
          this.name = 'Square';
        }

        get area() {
          return this.width * this.height;
        }

        set area(value) {
          this.area = value;
        }
      }
     ```

     **[⬆ Back to Top](#table-of-contents)**

284. ### <a name="284"></a> Как изменить URL без перезагрузки страницы

     Свойство `window.location.url` будет полезно для изменения URL-адреса, но оно перезагружает страницу. HTML5 представил методы `history.pushState()` и `history.replaceState()`, которые позволяют добавлять и изменять записи истории соответственно. Например, вы можете использовать pushState, как показано ниже:

     ```javascript
     window.history.pushState('page2', 'Title', '/page2.html');
     ```

     **[⬆ Back to Top](#table-of-contents)**

285. ### <a name="285"></a> Как проверить, содержит ли массив определенное значение или нет?

     Метод `Array#includes()` используется для определения того, содержит ли массив определенное значение среди своих элементов, возвращая значение true или false. Давайте рассмотрим пример поиска элемента (числового и строкового) в массиве.

     ```javascript
     var numericArray = [1, 2, 3, 4];
     console.log(numericArray.includes(3)); // true

     var stringArray = ['green', 'yellow', 'blue'];
     console.log(stringArray.includes('blue')); //true
     ```

     **[⬆ Back to Top](#table-of-contents)**

286. ### <a name="286"></a> Как вы сравниваете скалярные массивы

     Вы можете использовать длину и каждый метод массивов для сравнения двух скалярных (сравненных напрямую с использованием ===) массивов. Комбинация этих выражений может дать ожидаемый результат,

     ```javascript
     const arrayFirst = [1,2,3,4,5];
     const arraySecond = [1,2,3,4,5];
     console.log(arrayFirst.length === arraySecond.length && arrayFirst.every((value, index) => value === arraySecond[index])); // true
     ````

     Если вы хотите сравнивать массивы независимо от порядка, вам следует отсортировать их заранее,

     ```javascript
     const arrayFirst = [2,3,1,4,5];
     const arraySecond = [1,2,3,4,5];
     console.log(arrayFirst.length === arraySecond.length && arrayFirst.sort().every((value, index) => value === arraySecond[index])); //true
     ````

     **[⬆ Back to Top](#table-of-contents)**

287. ### <a name="287"></a> Как получить значение из параметров get

     Объект `new URL()` принимает строку URL-адреса, а свойство `searchParams` этого объекта можно использовать для доступа к параметрам получения. Помните, что вам может понадобиться использовать polyfill или `window.location` для доступа к URL-адресу в старых браузерах (включая IE).

     ```javascript
     let urlString = "http://www.some-domain.com/about.html?x=1&y=2&z=3"; //window.location.href
     let url = new URL(urlString);
     let parameterZ = url.searchParams.get("z");
     console.log(parameterZ); // 3
     ```

     **[⬆ Back to Top](#table-of-contents)**

288. ### <a name="288"></a> Как вы печатаете числа с запятыми в качестве разделителей тысяч

     Вы можете использовать метод `Number.prototype.toLocaleString()`, который возвращает строку с языковым представлением, таким как разделитель тысяч, валюта и т. д. этого числа.

     ```javascript
     function convertToThousandFormat(x){
       return x.toLocaleString(); // 12,345.679
     }

     console.log(convertToThousandFormat(12345.6789));
     ```

     **[⬆ Back to Top](#table-of-contents)**

289. ### <a name="289"></a> В чем разница между java и javascript

     Оба являются совершенно не связанными языками программирования и не имеют никакого отношения между ними. Java статически типизирована, скомпилирована, работает на собственной виртуальной машине. Принимая во внимание, что Javascript динамически типизируется, интерпретируется и работает в среде браузера и nodejs. Давайте посмотрим на основные различия в табличном формате,
     | Особенность | Java | JavaScript |
     |---- | ---- | -----
     | Напечатано | Это строго типизированный язык | Это язык с динамической типизацией |
     | Парадигма | Объектно-ориентированное программирование | Программирование на основе прототипов |
     | Обзор | Область действия блока | Область действия |
     | параллелизм | Поток на основе | на основе событий |
     | Память | Использует больше памяти | Использует меньше памяти. Следовательно, он будет использоваться для веб-страниц |

     **[⬆ Back to Top](#table-of-contents)**

290. ### <a name="290"></a> Поддерживает ли javascript пространство имен

     JavaScript не поддерживает пространство имен по умолчанию. Поэтому, если вы создаете какой-либо элемент (функцию, метод, объект, переменную), он становится глобальным и загрязняет глобальное пространство имен. Давайте возьмем пример определения двух функций без какого-либо пространства имен,

     ```javascript
     function func1() {
         console.log("This is a first definition");

     }
     function func1() {
         console.log("This is a second definition");
     }
     func1(); // This is a second definition
     ```

     Он всегда вызывает второе определение функции. В этом случае пространство имен решит проблему конфликта имен.

     **[⬆ Back to Top](#table-of-contents)**

291. ### <a name="291"></a> Как вы объявляете пространство имен

     Несмотря на то, что в JavaScript нет пространств имен, мы можем использовать Objects, IIFE для создания пространств имен.
     1. **Использование литеральной записи объекта:** Давайте обернем переменные и функции внутри литерала объекта, который действует как пространство имен. После этого вы можете получить к ним доступ, используя обозначение объекта

     ```javascript
     var namespaceOne = {
        function func1() {
            console.log("This is a first definition");
        }
     }
     var namespaceTwo = {
          function func1() {
              console.log("This is a second definition");
          }
      }
     namespaceOne.func1(); // This is a first definition
     namespaceTwo.func1(); // This is a second definition
     ```

     1. **Использование IIFE (немедленно вызываемое функциональное выражение):** Внешняя пара круглых скобок IIFE создает локальную область действия для всего кода внутри нее и делает анонимную функцию функциональным выражением. Благодаря этому вы можете создать одну и ту же функцию в двух разных функциональных выражениях, чтобы действовать как пространство имен.

     ```javascript
     (function() {
      function fun1(){
        console.log("This is a first definition");
        } fun1();
     }());

     (function() {
         function fun1(){
            console.log("This is a second definition");
        } fun1();
      }());
     ```

     1. **Использование блока и объявления let/const:** В ECMAScript 6 вы можете просто использовать блок и объявление let, чтобы ограничить область действия переменной блоком.

     ```javascript
      {
       let myFunction= function fun1(){
       console.log("This is a first definition");
       }
       myFunction();
      }
       //myFunction(): ReferenceError: myFunction is not defined.

      {
       let myFunction= function fun1(){
       console.log("This is a second definition");
       }
       myFunction();
      }
       //myFunction(): ReferenceError: myFunction is not defined.
     ```

     **[⬆ Back to Top](#table-of-contents)**

292. ### <a name="292"></a> Как вы вызываете код javascript в iframe с родительской страницы

     Первоначально необходимо получить доступ к iFrame с помощью `document.getElementBy` или `window.frames`. После этого свойство `contentWindow` iFrame дает доступ для targetFunction.

     ```javascript
     document.getElementById('targetFrame').contentWindow.targetFunction();
     window.frames[0].frameElement.contentWindow.targetFunction(); // Accessing iframe this way may not work in latest versions chrome and firefox

     ```

     **[⬆ Back to Top](#table-of-contents)**

293. ### <a name="293"></a> Как получить смещение часового пояса от даты

     Вы можете использовать метод `getTimezoneOffset` объекта даты. Этот метод возвращает разницу часовых поясов в минутах от текущей локали (настройки хост-системы) до UTC.

     ```javascript
     var offset = new Date().getTimezoneOffset();
     console.log(offset); // -480
     ```

     **[⬆ Back to Top](#table-of-contents)**

294. ### <a name="294"></a> Как вы загружаете файлы CSS и JS динамически

     Вы можете создать как ссылку, так и элементы скрипта в DOM и добавить их как дочерние элементы к тегу заголовка. Давайте создадим функцию для добавления ресурсов сценария и стиля, как показано ниже:

     ```javascript
     function loadAssets(filename, filetype) {
       if (filetype == "css") { // External CSS file
            var fileReference = document.createElement("link")
            fileReference.setAttribute("rel", "stylesheet");
            fileReference.setAttribute("type", "text/css");
            fileReference.setAttribute("href", filename);
       } else if (filetype == "js") { // External JavaScript file
            var fileReference = document.createElement('script');
            fileReference.setAttribute("type", "text/javascript");
            fileReference.setAttribute("src", filename);
       }
       if (typeof fileReference != "undefined")
            document.getElementsByTagName("head")[0].appendChild(fileReference)
      }
     ```

     **[⬆ Back to Top](#table-of-contents)**

295. ### <a name="295"></a> Какие существуют способы поиска HTML-элементов в DOM?

     Если вы хотите получить доступ к любому элементу на HTML-странице, вам нужно начать с доступа к объекту документа. Позже вы можете использовать любой из следующих методов, чтобы найти элемент HTML,
     1. document.getElementById(id): находит элемент по идентификатору
     2. document.getElementsByTagName(name): находит элемент по имени тега
     3. document.getElementsByClassName(name): находит элемент по имени класса

     **[⬆ Back to Top](#table-of-contents)**

296. ### <a name="296"></a> Что такое jQuery

     jQuery — это популярная кросс-браузерная библиотека JavaScript, которая обеспечивает обход объектной модели документа (DOM), обработку событий, анимацию и взаимодействие AJAX, сводя к минимуму расхождения между браузерами. Он широко известен своей философией «Пиши меньше, делай больше». Например, вы можете отобразить приветственное сообщение при загрузке страницы с помощью jQuery, как показано ниже:

     ```javascript
     $(document).ready(function(){ // It selects the document and apply the function on page load
         alert('Welcome to jQuery world');
     });
     ```

     **Примечание.** Вы можете скачать его с официального сайта jquery или установить с CDN, например, с Google.

     **[⬆ Back to Top](#table-of-contents)**

297. ### <a name="297"></a> Что такое JavaScript-движок V8

     V8 — это высокопроизводительный движок JavaScript с открытым исходным кодом, используемый браузером Google Chrome, написанный на C++. Он также используется в проекте node.js. Он реализует ECMAScript и WebAssembly и работает в системах Windows 7 или более поздних версий, macOS 10.12+ и Linux, использующих процессоры x64, IA-32, ARM или MIPS.
     **Примечание.** Он может работать автономно или может быть встроен в любое приложение C++.

     **[⬆ Back to Top](#table-of-contents)**

298. ### <a name="298"></a> Почему мы называем javascript динамическим языком

     JavaScript является свободно типизированным или динамическим языком, потому что переменные в JavaScript напрямую не связаны с каким-либо конкретным типом значения, и любой переменной можно присвоить/переназначить значения всех типов.

     ```javascript
     let age = 50;    // age is a number now
     age  = 'old'; // age is a string now
     age  = true;  // age is a boolean
     ```

     **[⬆ Back to Top](#table-of-contents)**

299. ### <a name="299"></a> Что такое void operator

     Оператор `void` оценивает данное выражение, а затем возвращает значение undefined (т. е. без возврата значения). Синтаксис будет таким, как показано ниже,

     ```javascript
     void (expression)
     void expression
     ```

     Давайте отобразим сообщение без перенаправления или перезагрузки

     ```javascript
     <a href="javascript:void(alert('Welcome to JS world'))">Click here to see a message</a>
     ```

     **Примечание.** Этот оператор часто используется для получения неопределенного примитивного значения с помощью "void(0)".

     **[⬆ Back to Top](#table-of-contents)**

300. ### <a name="300"></a> Как поставить курсор на ожидание

     Курсор можно настроить на ожидание в JavaScript с помощью свойства «cursor». Давайте выполним это поведение при загрузке страницы, используя приведенную ниже функцию.

     ```javascript
     function myFunction() {
     window.document.body.style.cursor = "wait";
     }
     ```

     и эта функция вызывается при загрузке страницы

     ```html
     <body onload="myFunction()">
     ```

     **[⬆ Back to Top](#table-of-contents)**

301. ### <a name="301"></a> Как создать бесконечный цикл

     Вы можете создавать бесконечные циклы, используя циклы for и while без использования каких-либо выражений. Конструкция или синтаксис цикла for является лучшим подходом с точки зрения инструментов ESLint и оптимизатора кода,

     ```javascript
     for (;;) {}
     while(true) {
     }
     ```

     **[⬆ Back to Top](#table-of-contents)**

302. ### <a name="302"></a> Почему вам нужно избегать с statement

     Оператор with в JavaScript был предназначен для записи повторяющихся обращений к объектам. Таким образом, это может помочь уменьшить размер файла за счет уменьшения необходимости повторять длинную ссылку на объект без снижения производительности. Давайте возьмем пример, где он используется, чтобы избежать избыточности при доступе к объекту несколько раз.

     ```javascript
     a.b.c.greeting   = 'welcome';
     a.b.c.age = 32;
     ```

     Using `with` it turns this into:

     ```javascript
     with(a.b.c) {
             greeting   = "welcome";
             age = 32;
     }
     ```

     Но этот оператор with создает проблемы с производительностью, поскольку невозможно предсказать, будет ли аргумент ссылаться на реальную переменную или на свойство внутри аргумента with.

     **[⬆ Back to Top](#table-of-contents)**

303. ### <a name="303"></a> Каков результат of below for loops

     ```javascript
     for (var i = 0; i < 4; i++) { // global scope
       setTimeout(() => console.log(i));
     }

     for (let i = 0; i < 4; i++) { // block scope
       setTimeout(() => console.log(i));
     }
     ```

     Выход вышеприведенных циклов for равен 4 4 4 4 и 0 1 2 3.
     
     **Объяснение:** Из-за очереди событий/цикла javascript функция обратного вызова `setTimeout` вызывается после выполнения цикла. Поскольку переменная i объявлена ​​с ключевым словом `var`, она стала глобальной переменной, и значение было равно 4, используя итерацию, когда вызывается функция времени `setTimeout`. Следовательно, выход первого цикла равен «4 4 4 4».
     
     В то время как во втором цикле переменная i объявлена ​​как ключевое слово `let`, она становится переменной области блока и содержит новое значение (0, 1, 2 3) для каждой итерации. Следовательно, выход первого цикла равен «0 1 2 3».

     **[⬆ Back to Top](#table-of-contents)**

304. ### <a name="304"></a> Перечислите некоторые функции ES6

     Ниже приведен список некоторых новых функций ES6,
     1. Поддержка констант или неизменяемых переменных
     2. Поддержка блочной области для переменных, констант и функций
     3. Стрелочные функции
     4. Параметры по умолчанию
     5. Параметры отдыха и спреда
     6. Шаблонные литералы
     7. Многострочные строки
     8. Деструктивное назначение
     9. Расширенные литералы объектов
     10. Обещания
     11. Классы
     12. Модули

     **[⬆ Back to Top](#table-of-contents)**

305. ### <a name="305"></a> Что такое ES6

     ES6 — это шестое издание языка javascript, выпущенное в июне 2015 года. Первоначально он был известен как ECMAScript 6 (ES6), а затем переименован в ECMAScript 2015. Почти все современные браузеры поддерживают ES6, но для старых браузеров существует множество транспиляторов. , например Babel.js и т. д.

     **[⬆ Back to Top](#table-of-contents)**

306. ### <a name="306"></a> Могу ли я повторно объявить переменные let и const

     Нет, вы не можете повторно объявить переменные let и const. Если вы это сделаете, он выдает ошибку ниже

     ```bash
     Uncaught SyntaxError: Identifier 'someVariable' has already been declared
     ```

     **Объяснение:** Объявление переменной с ключевым словом `var` относится к области действия функции, и переменная обрабатывается так, как если бы она была объявлена ​​в верхней части включающей области действия из-за функции подъема. Таким образом, все множественные объявления, вносящие вклад в одну и ту же поднятую переменную, без каких-либо ошибок. Давайте рассмотрим пример повторного объявления переменных в одной и той же области видимости для переменных var и let/const.

     ```javascript
     var name = 'John';
     function myFunc() {
         var name = 'Nick';
         var name = 'Abraham'; // Re-assigned in the same function block
         alert(name); // Abraham
     }
     myFunc();
     alert(name); // John
     ```

     Множественное объявление с блочной областью действия выдает синтаксическую ошибку,

     ```javascript
     let name = 'John';
     function myFunc() {
         let name = 'Nick';
         let name = 'Abraham'; // Uncaught SyntaxError: Identifier 'name' has already been declared
         alert(name);
     }

     myFunc();
     alert(name);
     ```

     **[⬆ Back to Top](#table-of-contents)**

307. ### <a name="307"></a> const переменная делает значение неизменным

     Нет, константная переменная не делает значение неизменным. Но он запрещает последующие назначения (т.е. вы можете объявить с назначением, но не можете назначить другое значение позже)

     ```javascript
     const userList = [];
     userList.push('John'); // Can mutate even though it can't re-assign
     console.log(userList); // ['John']
     ```

     **[⬆ Back to Top](#table-of-contents)**

308. ### <a name="308"></a> Что такое параметры по умолчанию

     В E5 нам нужно полагаться на логические операторы ИЛИ для обработки значений параметров функции по умолчанию. Принимая во внимание, что в ES6 функция параметров функции по умолчанию позволяет инициализировать параметры со значениями по умолчанию, если значение не передано или не определено. Давайте сравним поведение с примерами,

     ```javascript
     //ES5
     var calculateArea = function(height, width) {
        height =  height || 50;
        width = width || 60;

        return width * height;
     }
     console.log(calculateArea()); //300
     ```

     Параметры по умолчанию упрощают инициализацию,

     ```javascript
     //ES6
     var calculateArea = function(height = 50, width = 60) {
        return width * height;
     }

     console.log(calculateArea()); //300
     ```

     **[⬆ Back to Top](#table-of-contents)**

309. ### <a name="309"></a> Что такое шаблонные литералы

     Литералы шаблонов или строки шаблонов — это строковые литералы, допускающие встроенные выражения. Они заключаются в символ обратной галочки (`) вместо двойных или одинарных кавычек.
     В E6 эта функция позволяет использовать динамические выражения, как показано ниже:

     ```javascript
     var greeting = `Welcome to JS World, Mr. ${firstName} ${lastName}.`
     ```

     В ES5 вам нужна строка разрыва, как показано ниже,

     ```javascript
     var greeting = 'Welcome to JS World, Mr. ' + firstName + ' ' + lastName.`
     ```

     **Примечание.** С литералами шаблонов можно использовать многострочные строки и функции интерполяции строк.

     **[⬆ Back to Top](#table-of-contents)**

310. ### <a name="310"></a> Как вы пишете многострочные строки в литералах шаблона

     В ES5 вам пришлось бы использовать escape-символы новой строки ('\\n') и символы конкатенации (+), чтобы получить многострочные строки.

     ```javascript
     console.log('This is string sentence 1\n' +
     'This is string sentence 2');
     ```

     Принимая во внимание, что в ES6 вам не нужно упоминать какой-либо символ последовательности новой строки,

     ```javascript
     console.log(`This is string sentence
     'This is string sentence 2`);
     ```

     **[⬆ Back to Top](#table-of-contents)**

311. ### <a name="311"></a> Что такое вложенные шаблоны

     Шаблон вложения — это функция, поддерживаемая синтаксисом литералов шаблона, позволяющая использовать внутренние обратные кавычки внутри заполнителя ${} в шаблоне. Например, приведенный ниже вложенный шаблон используется для отображения значков на основе разрешений пользователя, тогда как внешний шаблон проверяет тип платформы,

     ```javascript
     const iconStyles = `icon ${ isMobilePlatform() ? '' :
      `icon-${user.isAuthorized ? 'submit' : 'disabled'}` }`;
     ```

     Вы также можете написать приведенный выше вариант использования без вложенных функций шаблона. Однако функция шаблона вложения более компактна и удобочитаема.

     ```javascript
     //Without nesting templates
      const iconStyles = `icon ${ isMobilePlatform() ? '' :
       (user.isAuthorized ? 'icon-submit' : 'icon-disabled'}`;
     ```

     **[⬆ Back to Top](#table-of-contents)**

312. ### <a name="312"></a> Что такое шаблоны с тегами

     Шаблоны с тегами — это расширенная форма шаблонов, в которых теги позволяют анализировать литералы шаблонов с помощью функции. Функция тега принимает первый параметр в виде массива строк, а остальные параметры — в виде выражений. Эта функция также может возвращать обработанные строки на основе параметров. Давайте посмотрим на использование этого помеченного шаблона поведения набора навыков ИТ-специалиста в организации.

     ```javascript
     var user1 = 'John';
     var skill1 = 'JavaScript';
     var experience1 = 15;

     var user2 = 'Kane';
     var skill2 = 'JavaScript';
     var experience2 = 5;

     function myInfoTag(strings, userExp, experienceExp, skillExp) {
       var str0 = strings[0]; // "Mr/Ms. "
       var str1 = strings[1]; // " is a/an "
       var str2 = strings[2]; // "in"

       var expertiseStr;
       if (experienceExp > 10){
         expertiseStr = 'expert developer';
       } else if(skillExp > 5 && skillExp <= 10) {
         expertiseStr = 'senior developer';
       } else {
         expertiseStr = 'junior developer';
       }

       return `${str0}${userExp}${str1}${expertiseStr}${str2}${skillExp}`;
     }

     var output1 = myInfoTag`Mr/Ms. ${ user1 } is a/an ${ experience1 } in ${skill1}`;
     var output2 = myInfoTag`Mr/Ms. ${ user2 } is a/an ${ experience2 } in ${skill2}`;

     console.log(output1);// Mr/Ms. John is a/an expert developer in JavaScript
     console.log(output2);// Mr/Ms. Kane is a/an junior developer in JavaScript
     ```

     **[⬆ Back to Top](#table-of-contents)**

313. ### <a name="313"></a> Что такое необработанные строки

      ES6 предоставляет функцию необработанных строк с использованием метода `String.raw()`, который используется для получения необработанной строковой формы строк шаблона. Эта функция позволяет получить доступ к необработанным строкам в том виде, в каком они были введены, без обработки управляющих последовательностей. Например, использование будет следующим:

      ```javascript
      var calculationString = String.raw `The sum of numbers is \n${1+2+3+4}!`;
      console.log(calculationString); // The sum of numbers is 10
      ```

      Если вы не используете необработанные строки, последовательность символов новой строки будет обрабатываться путем отображения вывода в несколько строк.

      ```javascript
      var calculationString = `The sum of numbers is \n${1+2+3+4}!`;
      console.log(calculationString);
      // The sum of numbers is
      // 10
      ```

      Кроме того, необработанное свойство доступно в первом аргументе функции тега.

      ```javascript
      function tag(strings) {
         console.log(strings.raw[0]);
      }
      ```

      **[⬆ Back to Top](#table-of-contents)**

314. ### <a name="314"></a> Что такое деструктуризация

     Деструктурирующее присваивание — это выражение JavaScript, позволяющее распаковывать значения из массивов или свойства объектов в отдельные переменные.
     Давайте получим значения месяца из массива, используя присваивание деструктурирования

     ```javascript
     var [one, two, three] = ['JAN', 'FEB', 'MARCH'];

     console.log(one); // "JAN"
     console.log(two); // "FEB"
     console.log(three); // "MARCH"
     ```

     и вы можете получить пользовательские свойства объекта, используя присваивание деструктуризации,

     ```javascript
     var {name, age} = {name: 'John', age: 32};

     console.log(name); // John
     console.log(age); // 32
     ```

     **[⬆ Back to Top](#table-of-contents)**

315. ### <a name="315"></a> Каковы значения по умолчанию в деструктуризации

     Переменной может быть присвоено значение по умолчанию, когда значение, извлеченное из массива или объекта, не определено во время назначения деструктурирования. Это помогает избежать установки значений по умолчанию отдельно для каждого назначения. Давайте возьмем пример как для массивов, так и для объектов,

     **Деструктуризация массивов:**

     ```javascript
     var x, y, z;

     [x=2, y=4, z=6] = [10];
     console.log(x); // 10
     console.log(y); // 4
     console.log(z); // 6
     ```

     **Деструктуризация объектов:**

     ```javascript
     var {x=2, y=4, z=6} = {x: 10};

     console.log(x); // 10
     console.log(y); // 4
     console.log(z); // 6
     ```

     **[⬆ Back to Top](#table-of-contents)**

316. ### <a name="316"></a> Как поменять местами переменные в деструктуризации

     Если вы не используете деструктурирующее присваивание, для замены двух значений требуется временная переменная. В то время как при использовании функции деструктурирования два значения переменных могут быть заменены местами в одном выражении деструктурирования. Давайте поменяем местами две числовые переменные в присваивании деструктуризации массива,

     ```javascript
     var x = 10, y = 20;

     [x, y] = [y, x];
     console.log(x); // 20
     console.log(y); // 10
     ```

     **[⬆ Back to Top](#table-of-contents)**

317. ### <a name="317"></a> Что такое расширенные литералы объектов

     Литералы объектов упрощают быстрое создание объектов со свойствами внутри фигурных скобок. Например, он обеспечивает более короткий синтаксис для определения общего свойства объекта, как показано ниже.

     ```javascript
     //ES6
     var x = 10, y = 20
     obj = { x, y }
     console.log(obj); // {x: 10, y:20}
     //ES5
     var x = 10, y = 20
     obj = { x : x, y : y}
     console.log(obj); // {x: 10, y:20}
     ```

     **[⬆ Back to Top](#table-of-contents)**

318. ### <a name="318"></a> Что такое динамический импорт

     Динамический импорт с использованием синтаксиса функции `import()` позволяет нам загружать модули по запросу, используя промисы или синтаксис async/await. В настоящее время эта функция находится в [предложении stage4] (https://github.com/tc39/proposal-dynamic-import). Основным преимуществом динамического импорта является уменьшение размеров нашего пакета, ответа размера/полезной нагрузки на наши запросы и общее улучшение взаимодействия с пользователем.
     Синтаксис динамического импорта будет следующим:

     ```javascript
     import('./Module').then(Module => Module.method());
     ```

     **[⬆ Back to Top](#table-of-contents)**

319. ### <a name="319"></a> Каковы варианты использования динамического импорта

     Ниже приведены некоторые примеры использования динамического импорта вместо статического.
     1. Импортируйте модуль по требованию или условно. Например, если вы хотите загрузить полифилл в устаревшем браузере

     ```javascript
     if (isLegacyBrowser()) {
         import(···)
         .then(···);
     }
     ```

     1. Вычислите спецификатор модуля во время выполнения. Например, вы можете использовать его для интернационализации.

     ```javascript
     import(`messages_${getLocale()}.js`).then(···);
     ```

     1. Импортируйте модуль из обычного скрипта вместо модуля.

     **[⬆ Back to Top](#table-of-contents)**

320. ### <a name="320"></a> Что такое типизированные массивы

     Типизированные массивы — это подобные массиву объекты из ECMAScript 6 API для обработки двоичных данных. JavaScript предоставляет 8 типов типизированных массивов,

     1. Int8Array: массив 8-битных целых чисел со знаком.
     2. Int16Array: массив 16-битных целых чисел со знаком.
     3. Int32Array: массив 32-битных целых чисел со знаком.
     4. Uint8Array: массив 8-битных целых чисел без знака.
     5. Uint16Array: массив 16-битных целых чисел без знака.
     6. Uint32Array: массив 32-битных целых чисел без знака.
     7. Float32Array: массив 32-битных чисел с плавающей запятой.
     8. Float64Array: массив 64-битных чисел с плавающей запятой.

     Например, вы можете создать массив 8-битных целых чисел со знаком, как показано ниже.

     ```javascript
     const a = new Int8Array();
     // You can pre-allocate n bytes
     const bytes = 1024
     const a = new Int8Array(bytes)
     ```

     **[⬆ Back to Top](#table-of-contents)**

321. ### <a name="321"></a> В чем преимущества загрузчиков модулей

     Загрузчики модулей предоставляют следующие функции:
     1. Dynamic loading
     2. State isolation
     3. Global namespace isolation
     4. Compilation hooks
     5. Nested virtualization

     **[⬆ Back to Top](#table-of-contents)**

322. ### <a name="322"></a> Что такое сопоставление

     Сопоставление используется для сортировки набора строк и поиска в наборе строк. Он параметризован локалью и поддерживает Unicode. Возьмем функции сравнения и сортировки,
     1. **Сравнение:**

     ```javascript
     var list = [ "ä", "a", "z" ]; // In German,  "ä" sorts with "a" Whereas in Swedish, "ä" sorts after "z"
     var l10nDE = new Intl.Collator("de");
     var l10nSV = new Intl.Collator("sv");
     console.log(l10nDE.compare("ä", "z") === -1); // true
     console.log(l10nSV.compare("ä", "z") === +1); // true
     ```

     1. **Сортировка:**

     ```javascript
     var list = [ "ä", "a", "z" ]; // In German,  "ä" sorts with "a" Whereas in Swedish, "ä" sorts after "z"
     var l10nDE = new Intl.Collator("de");
     var l10nSV = new Intl.Collator("sv");
     console.log(list.sort(l10nDE.compare)) // [ "a", "ä", "z" ]
     console.log(list.sort(l10nSV.compare)) // [ "a", "z", "ä" ]
     ```

     **[⬆ Back to Top](#table-of-contents)**

323. ### <a name="323"></a> Что такое for...of statement

     Оператор for...of создает цикл, перебирающий итерируемые объекты или элементы, такие как встроенные String, Array, массивоподобные объекты (такие как аргументы или NodeList), TypedArray, Map, Set и пользовательские итерируемые объекты. Основное использование оператора for...of для массивов будет следующим:

     ```javascript
     let arrayIterable = [10, 20, 30, 40, 50];

     for (let value of arrayIterable) {
       value ++;
       console.log(value); // 11 21 31 41 51
     }
     ```

     **[⬆ Back to Top](#table-of-contents)**

324. ### <a name="324"></a> Каков результат нижеприведенного массива операторов spread

     ```javascript
     [...'John Resig']
     ```

     Выход массива ['J', 'o', 'h', 'n', '', 'R', 'e', ​​'s', 'i', 'g']
     **Объяснение:** Строка является итерируемым типом, и оператор распространения в массиве сопоставляет каждый символ итерируемого элемента с одним элементом. Следовательно, каждый символ строки становится элементом массива.

     **[⬆ Back to Top](#table-of-contents)**

325. ### <a name="325"></a> Является ли PostMessage безопасным

     Да, сообщения postMessage можно считать очень безопасными, если программист/разработчик тщательно проверяет происхождение и источник прибывающего сообщения. Но если вы попытаетесь отправить/получить сообщение, не проверив его источник, это приведет к атакам межсайтового скриптинга.

     **[⬆ Back to Top](#table-of-contents)**

326. ### <a name="326"></a> Каковы проблемы с целевым источником сообщения в качестве подстановочного знака?

     Второй аргумент метода postMessage указывает, какому источнику разрешено получать сообщение. Если вы используете подстановочный знак «*» в качестве аргумента, любой источник может получить сообщение. В этом случае окно отправителя не может узнать, находится ли целевое окно в целевом источнике при отправке сообщения. Если целевое окно было перемещено к другому источнику, другой источник получит данные. Следовательно, это может привести к XSS-уязвимостям.

     ```javascript
     targetWindow.postMessage(message, '*');
     ```

     **[⬆ Back to Top](#table-of-contents)**

327. ### <a name="327"></a> Как избежать получения почтовых сообщений от злоумышленников

     Поскольку прослушиватель прослушивает любое сообщение, злоумышленник может обмануть приложение, отправив сообщение из источника злоумышленника, что создаст впечатление, что получатель получил сообщение из фактического окна отправителя. Вы можете избежать этой проблемы, проверив происхождение сообщения на стороне получателя, используя атрибут «message.origin». Например, давайте проверим происхождение отправителя [http://www.some-sender.com](http://www.some-sender.com) на стороне получателя [www.some-receiver.com](www.some -receiver.com),

     ```javascript
     //Listener on http://www.some-receiver.com/
     window.addEventListener("message", function(message){
         if(/^http://www\.some-sender\.com$/.test(message.origin)){
              console.log('You received the data from valid sender', message.data);
        }
     });
     ```

     **[⬆ Back to Top](#table-of-contents)**

328. ### <a name="328"></a> Могу ли я полностью избежать использования postMessages

     Вы не можете полностью (или на 100%) избежать использования postMessages. Несмотря на то, что ваше приложение не использует postMessage с учетом рисков, многие сторонние скрипты используют postMessage для связи со сторонней службой. Таким образом, ваше приложение может использовать postMessage без вашего ведома.

     **[⬆ Back to Top](#table-of-contents)**

329. ### <a name="329"></a> Является ли postMessages синхронным

     Сообщения postMessage синхронны в браузере IE8, но асинхронны в IE9 и всех других современных браузерах (например, IE9+, Firefox, Chrome, Safari). Из-за такого асинхронного поведения мы используем механизм обратного вызова при возврате сообщения postMessage.

     **[⬆ Back to Top](#table-of-contents)**

330. ### <a name="330"></a> Какой парадигмой является Javascript

     JavaScript — это мультипарадигмальный язык, поддерживающий императивное/процедурное программирование, объектно-ориентированное программирование и функциональное программирование. JavaScript поддерживает объект

     **[⬆ Back to Top](#table-of-contents)**

331. ### <a name="331"></a> В чем разница между внутренним и внешним javascript

     **Внутренний JavaScript:** Это исходный код внутри тега script.
     **Внешний JavaScript:** Исходный код хранится во внешнем файле (хранится с расширением .js) и упоминается в теге.

     **[⬆ Back to Top](#table-of-contents)**

332. ### <a name="332"></a> Является ли JavaScript быстрее, чем скрипт на стороне сервера? server side script

     Да, JavaScript быстрее, чем скрипт на стороне сервера. Поскольку JavaScript является скриптом на стороне клиента, он не требует помощи веб-сервера для своих вычислений. Таким образом, JavaScript всегда быстрее, чем любой серверный скрипт, такой как ASP, PHP и т. д.

     **[⬆ Back to Top](#table-of-contents)**

333. ### <a name="333"></a> Как узнать статус checkbox

     Вы можете применить свойство `checked` к выбранному флажку в DOM. Если значение равно `True`, это означает, что флажок установлен, в противном случае он не отмечен. Например, к приведенному ниже элементу флажка HTML можно получить доступ с помощью javascript, как показано ниже:

     ```html
       <input type="checkbox" name="checkboxname" value="Agree"> Agree the conditions<br>
     ```

     ```javascript
     console.log(document.getElementById(‘checkboxname’).checked); // true or false
     ```

     **[⬆ Back to Top](#table-of-contents)**

334. ### <a name="334"></a> Какова цель оператора двойной тильды

     Оператор двойной тильды (~ ~) известен как побитовый оператор двойного НЕ. Этот оператор будет более быстрой заменой Math.floor().

     **[⬆ Back to Top](#table-of-contents)**

335. ### <a name="335"></a> Как вы конвертируете символ в код ASCII

     Вы можете использовать метод String.prototype.charCodeAt() для преобразования строковых символов в числа ASCII. Например, давайте найдем код ASCII для первой буквы строки «ABC»,

     ```javascript
     "ABC".charCodeAt(0) // returns 65
     ```

     В то время как метод `String.fromCharCode()` преобразует числа в равные символы ASCII.

     ```javascript
     String.fromCharCode(65,66,67); // returns 'ABC'
     ```

     **[⬆ Back to Top](#table-of-contents)**

336. ### <a name="336"></a> Что такое ArrayBuffer

     Объект ArrayBuffer используется для представления универсального буфера необработанных двоичных данных фиксированной длины. Вы можете создать его, как показано ниже,

     ```javascript
     let buffer = new ArrayBuffer(16); // create a buffer of length 16
     alert(buffer.byteLength); // 16
     ```

     Чтобы манипулировать ArrayBuffer, нам нужно использовать объект «представление».

     ```javascript
     //Create a DataView referring to the buffer
      let view = new DataView(buffer);
     ```

     **[⬆ Back to Top](#table-of-contents)**

337. ### <a name="337"></a> Каков результат приведенного ниже строкового выражения

     ```javascript
     console.log("Welcome to JS world"[0])
     ```

     Результат приведенного выше выражения — «W».
     **Объяснение:** Обозначение скобок с определенным индексом в строке возвращает символ в определенном месте. Следовательно, он возвращает символ "W" строки. Поскольку это не поддерживается в IE7 и более ранних версиях, вам может потребоваться использовать метод .charAt() для получения желаемого результата.

     **[⬆ Back to Top](#table-of-contents)**

338. ### <a name="338"></a> Какова цель объекта Error

     Конструктор Error создает объект ошибки, и экземпляры объектов ошибок выбрасываются при возникновении ошибок во время выполнения. Объект Error также можно использовать в качестве базового объекта для определяемых пользователем исключений. Синтаксис объекта ошибки будет таким, как показано ниже:

     ```javascript
     new Error([message[, fileName[, lineNumber]]])
     ```

     Вы можете создавать пользовательские исключения или ошибки, используя объект Error в блоке try...catch, как показано ниже:

     ```javascript
     try {
       if(withdraw > balance)
       throw new Error("Oops! You don't have enough balance");
     } catch (e) {
       console.log(e.name + ': ' + e.message);
     }
     ```

     **[⬆ Back to Top](#table-of-contents)**

339. ### <a name="339"></a> Какова цель объекта EvalError

     Объект EvalError указывает на ошибку, связанную с глобальной функцией eval(). Несмотря на то, что это исключение больше не генерируется JavaScript, объект EvalError остается для совместимости. Синтаксис этого выражения будет таким, как показано ниже:

     ```javascript
     new EvalError([message[, fileName[, lineNumber]]])
     ```

     Вы можете сбросить EvalError с помощью блока try...catch, как показано ниже:

     ```javascript
     try {
       throw new EvalError('Eval function error', 'someFile.js', 100);
     } catch (e) {
       console.log(e.message, e.name, e.fileName);              // "Eval function error", "EvalError", "someFile.js"
     ```

     **[⬆ Back to Top](#table-of-contents)**

340. ### <a name="340"></a> Каков список ошибок случаев, выбрасываемых из нестрогого режима в строгий режим

     Когда вы применяете «использовать строго»; синтаксис, некоторые из приведенных ниже случаев вызовут SyntaxError перед выполнением скрипта
     1. Когда вы используете восьмеричный синтаксис

     ```javascript
     var n = 022;
     ```

     1. Использование оператора with
     2. Когда вы используете оператор удаления для имени переменной
     3. Использование eval или arguments в качестве имени переменной или аргумента функции
     4. Когда вы используете недавно зарезервированные ключевые слова
     5. Когда вы объявляете функцию в блоке

     ```javascript
     if (someCondition) { function f() {} }
     ```

     Следовательно, ошибки из приведенных выше случаев помогают избежать ошибок в средах разработки/производства.

     **[⬆ Back to Top](#table-of-contents)**

341. ### <a name="341"></a> Все ли объекты имеют прототипы

     Нет. Все объекты имеют прототипы, за исключением базового объекта, созданного пользователем, или объекта, созданного с использованием ключевого слова new.

     **[⬆ Back to Top](#table-of-contents)**

342. ### <a name="342"></a> В чем разница между параметром и аргументом

     Параметр — это имя переменной определения функции, тогда как аргумент представляет собой значение, присваиваемое функции при ее вызове. Объясним это простой функцией

     ```javascript
     function myFunction(parameter1, parameter2, parameter3) {
       console.log(arguments[0]) // "argument1"
       console.log(arguments[1]) // "argument2"
       console.log(arguments[2]) // "argument3"
     }
     myFunction("argument1", "argument2", "argument3")
     ```

     **[⬆ Back to Top](#table-of-contents)**

343. ### <a name="343"></a> Какова цель some метода в массивах

     Метод some() используется для проверки того, проходит ли хотя бы один элемент в массиве проверку, реализованную предоставленной функцией. Метод возвращает логическое значение. Давайте возьмем пример для проверки любых нечетных элементов,

     ```javascript
     var array = [1, 2, 3, 4, 5, 6 ,7, 8, 9, 10];

     var odd = element => element % 2 !== 0;

     console.log(array.some(odd)); // true (the odd element exists)
     ```

     **[⬆ Back to Top](#table-of-contents)**

344. ### <a name="344"></a> Как вы объединяете два или более массива

     Метод concat() используется для объединения двух или более массивов, возвращая новый массив, содержащий все элементы. Синтаксис будет таким, как показано ниже,

     ```javascript
     array1.concat(array2, array3, ..., arrayX)
     ```

     Давайте рассмотрим пример конкатенации массива с массивами овощей и фруктов,

     ```javascript
       var veggies = ["Tomato", "Carrot", "Cabbage"];
       var fruits = ["Apple", "Orange", "Pears"];
       var veggiesAndFruits = veggies.concat(fruits);
       console.log(veggiesAndFruits); // Tomato, Carrot, Cabbage, Apple, Orange, Pears
     ```

     **[⬆ Back to Top](#table-of-contents)**

345. ### <a name="345"></a> В чем разница между поверхностной и глубокой копией? Shallow and Deep copy

      Есть два способа скопировать объект,

      **Поверхностная копия:**
      Поверхностная копия — это побитовая копия объекта. Создается новый объект, который имеет точную копию значений исходного объекта. Если какие-либо поля объекта являются ссылками на другие объекты, копируются только адреса ссылок, т. е. копируется только адрес памяти.

      **Пример**

      ```javascript
      var empDetails = {
        name: "John", age: 25, expertise: "Software Developer"
      }
      ```

      создать дубликат

      ```javascript
      var empDetailsShallowCopy = empDetails    //Shallow copying!
      ```

      если мы изменим какое-то значение свойства в дубликате следующим образом:

      ```javascript
      empDetailsShallowCopy.name = "Johnson"
      ```

      Приведенный выше оператор также изменит имя empDetails, так как у нас есть неглубокая копия. Это означает, что мы также теряем исходные данные.

      **Глубокое копирование:**
      Глубокая копия копирует все поля и создает копии динамически выделенной памяти, на которую указывают поля. Глубокая копия возникает, когда объект копируется вместе с объектами, на которые он ссылается.

      **Пример**

      ```javascript
      var empDetails = {
        name: "John", age: 25, expertise: "Software Developer"
      }
      ```

      Создайте глубокую копию, используя свойства исходного объекта в новую переменную.

      ```javascript
      var empDetailsDeepCopy = {
        name: empDetails.name,
        age: empDetails.age,
        expertise: empDetails.expertise
      }
      ```

      Теперь, если вы измените `empDetailsDeepCopy.name`, это повлияет только на `empDetailsDeepCopy`, а не на `empDetails`

      **[⬆ Back to Top](#table-of-contents)**

346. ### <a name="346"></a> Как вы создаете определенное количество копий строки

     Метод `repeat()` используется для создания и возврата новой строки, содержащей указанное количество копий строки, для которой он был вызван, объединенных вместе. Помните, что этот метод был добавлен в спецификацию ECMAScript 2015.
     Давайте возьмем пример строки Hello, чтобы повторить ее 4 раза,

     ```javascript
     'Hello'.repeat(4);  // 'HelloHelloHelloHello'
     ```

347. ### <a name="347"></a> Как вы возвращаете все совпадающие строки с регулярным выражением

     Метод matchAll() можно использовать для возврата итератора всех результатов, совпадающих со строкой и регулярным выражением. Например, приведенный ниже пример возвращает массив совпадающих строковых результатов с регулярным выражением,

     ```javascript
     let regexp = /Hello(\d?))/g;
     let greeting = 'Hello1Hello2Hello3';

     let greetingList = [...greeting.matchAll(regexp)];

     console.log(greetingList[0]); //Hello1
     console.log(greetingList[1]); //Hello2
     console.log(greetingList[2]); //Hello3
     ```

     **[⬆ Back to Top](#table-of-contents)**

348. ### <a name="348"></a> Как обрезать строку в начале или в конце

     Метод `trim` прототипа строки используется для обрезки с обеих сторон строки. Но если вы хотите обрезать особенно начало или конец строки, вы можете использовать методы `trimStart/trimLeft` и `trimEnd/trimRight`. Давайте посмотрим на пример этих методов в приветственном сообщении,

     ```javascript
     var greeting = '   Hello, Goodmorning!   ';

     console.log(greeting); // "   Hello, Goodmorning!   "
     console.log(greeting.trimStart()); // "Hello, Goodmorning!   "
     console.log(greeting.trimLeft()); // "Hello, Goodmorning!   "

     console.log(greeting.trimEnd()); // "   Hello, Goodmorning!"
     console.log(greeting.trimRight()); // "   Hello, Goodmorning!"
     ```

     **[⬆ Back to Top](#table-of-contents)**

349. ### <a name="349"></a> Каков результат приведенного ниже оператора консоли с унарным оператором

     Давайте возьмем оператор консоли с унарным оператором, как показано ниже,

     ```javascript
     console.log(+ 'Hello');
     ```

     Вывод приведенного выше оператора журнала консоли возвращает NaN. Поскольку перед элементом стоит унарный оператор, интерпретатор JavaScript попытается преобразовать этот элемент в числовой тип. Поскольку преобразование завершается ошибкой, значение инструкции приводит к значению NaN.

     **[⬆ Back to Top](#table-of-contents)**

350. ### <a name="350"></a> Использует ли javascript миксины

     Mixin — это общий термин объектно-ориентированного программирования — это класс, содержащий методы, которые могут использоваться другими классами без необходимости наследовать от него. В JavaScript мы можем наследовать только от одного объекта. т.е. Для объекта может быть только один `[[prototype]]`.

     Но иногда нам требуется расширить более одного, чтобы преодолеть это, мы можем использовать Mixin, который помогает копировать методы в прототип другого класса.
     
     Скажем, например, у нас есть два класса «Пользователь» и «Чистая комната». Предположим, нам нужно добавить функциональность `CleanRoom` к `User`, чтобы пользователь мог убирать комнату по требованию. Вот где появляется концепция, называемая миксинами. 

     ```javascript
     // mixin
     let cleanRoomMixin = {
          cleanRoom() {
          alert(`Hello ${this.name}, your room is clean now`);
     },
     sayBye() {
          alert(`Bye ${this.name}`);
     }
     };

     // usage:
     class User {
          constructor(name) {
               this.name = name;
          }
     }

     // copy the methods
     Object.assign(User.prototype, cleanRoomMixin);

     // now User can clean the room
     new User("Dude").cleanRoom(); // Hello Dude, your room is clean now!
     ```

     **[⬆ Back to Top](#table-of-contents)**

351. ### <a name="351"></a> Что такое функция thunk

     Преобразователь (thunk) — это просто функция, которая задерживает оценку значения. Он не принимает никаких аргументов, но возвращает значение всякий раз, когда вы вызываете преобразователь. т. е. используется не для выполнения сейчас, а когда-нибудь в будущем. Возьмем синхронный пример,

     ```javascript
     const add = (x,y) => x + y;

     const thunk = () => add(2,3);

     thunk() // 5
     ```

     **[⬆ Back to Top](#table-of-contents)**

352. ### <a name="352"></a> Что такое асинхронный thunks

     Асинхронные thunks полезны для выполнения сетевых запросов. Давайте посмотрим на пример сетевых запросов,

     ```javascript
     function fetchData(fn){
       fetch('https://jsonplaceholder.typicode.com/todos/1')
       .then(response => response.json())
       .then(json => fn(json))
     }

     const asyncThunk = function (){
        return fetchData(function getData(data){
           console.log(data)
       })
     }

     asyncThunk()
     ```

     Функция `getData` не будет вызываться немедленно, а будет вызываться только тогда, когда данные будут доступны из конечной точки API. Функция setTimeout также используется для того, чтобы сделать наш код асинхронным. Лучшим примером в реальном времени является библиотека управления состоянием redux, которая использует асинхронные преобразователи для задержки действий для отправки.

     **[⬆ Back to Top](#table-of-contents)**

353. ### <a name="353"></a> Каков результат нижеприведенных вызовов функций

     **Фрагмент кода:**

     ```javascript
     const circle = {
       radius: 20,
       diameter() {
         return this.radius * 2;
       },
       perimeter: () => 2 * Math.PI * this.radius
     };
     ```

     console.log(circle.diameter());
     console.log(circle.perimeter());

     **Вывод:**

     Выход 40 и NaN. Помните, что диаметр — это обычная функция, тогда как значение периметра — это стрелочная функция. Ключевое слово `this` обычной функции (т. е. диаметр) относится к окружающей области, которая является классом (т. е. объектом Shape). Принимая во внимание, что это ключевое слово функции периметра относится к окружающей области, которая является объектом окна. Поскольку у оконных объектов нет свойства радиуса, он возвращает неопределенное значение, а кратное числовому значению возвращает значение NaN.

     **[⬆ Back to Top](#table-of-contents)**

354. ### <a name="354"></a> Как удалить все разрывы строк из строки

     Самый простой подход — использовать регулярные выражения для обнаружения и замены новых строк в строке. В этом случае мы используем функцию замены вместе со строкой для замены, которая в нашем случае является пустой строкой.

     ```javascript
     function remove_linebreaks( var message ) {
         return message.replace( /[\r\n]+/gm, "" );
     }
     ```

     В приведенном выше выражении g и m обозначают глобальные и многострочные флаги.

     **[⬆ Back to Top](#table-of-contents)**

355. ### <a name="355"></a> В чем разница между reflow и repaint

     *Перерисовка* происходит, когда вносятся изменения, влияющие на видимость элемента, но не на его макет. Примеры этого включают контур, видимость или цвет фона. *Перекомпоновка* включает в себя изменения, влияющие на макет части страницы (или всей страницы). Изменение размера окна браузера, изменение шрифта, изменение содержимого (например, ввод текста пользователем), использование методов JavaScript, включающих вычисляемые стили, добавление или удаление элементов из DOM и изменение классов элементов — вот некоторые из вещей, которые могут вызвать перекомпоновку. Перекомпоновка элемента вызывает последующую перекомпоновку всех дочерних и родительских элементов, а также любых элементов, следующих за ним в DOM.

     A *repaint* occurs when changes are made which affect the visibility of an element, but not its layout. Examples of this include outline, visibility, or background color. A *reflow* involves changes that affect the layout of a portion of the page (or the whole page). Resizing the browser window, changing the font, content changing (such as user typing text), using JavaScript methods involving computed styles, adding or removing elements from the DOM, and changing an element's classes are a few of the things that can trigger reflow. Reflow of an element causes the subsequent reflow of all child and ancestor elements as well as any elements following it in the DOM.

      **[⬆ Back to Top](#table-of-contents)**

356. ### <a name="356"></a> Что происходит с отрицанием массива

     Отрицание массива с помощью символа `!` приведет к преобразованию массива в логическое значение. Поскольку массивы считаются правдивыми, поэтому отрицание вернет «ложь».

     ```javascript
     console.log(![]); // false
     ```

     **[⬆ Back to Top](#table-of-contents)**

357. ### <a name="357"></a> Что произойдет, если мы добавим два массива

     Если вы добавите два массива вместе, они будут преобразованы в строки и объединены. Например, результат добавления массивов будет таким, как показано ниже:

     ```javascript
     console.log(['a'] + ['b']);  // "ab"
     console.log([] + []); // ""
     console.log(![] + []); // "false", because ![] returns false.
     ```

     **[⬆ Back to Top](#table-of-contents)**

358. ### <a name="358"></a> Каков результат аддитивного оператора добавления к ложным значениям

     Если вы добавляете оператор сложения (+) к ложным значениям (null, undefined, NaN, false, ""), ложное значение преобразуется в нулевое числовое значение. Давайте отобразим их в консоли браузера, как показано ниже:

     ```javascript
     console.log(+null); // 0
     console.log(+undefined);// NaN
     console.log(+false); // 0
     console.log(+NaN); // NaN
     console.log(+""); // 0
     ```

     **[⬆ Back to Top](#table-of-contents)**

359. ### <a name="359"></a> Как вы создаете собственную строку, используя специальные символы

     Строка self может быть сформирована комбинацией символов `[]()!+`. Вы должны помнить следующие соглашения, чтобы достичь этого шаблона.
     1. Поскольку массивы являются истинными значениями, отрицание массивов даст ложь: ![] === ложь
     2. Согласно правилам приведения JavaScript, сложение массивов вместе приведет к их преобразованию в строку: [] + [] === ""
     3. Добавление массива с оператором + преобразует массив в false, отрицание сделает его истинным, и, наконец, преобразование результата даст значение «1»: +(!(+[])) === 1

     Применяя приведенные выше правила, мы можем вывести следующие условия

     ```javascript
     ![] + [] === "false"
     +!+[] === 1
     ```

     Теперь шаблон символа будет создан, как показано ниже:

     ```javascript
           s               e               l               f
      ^^^^^^^^^^^^^   ^^^^^^^^^^^^^   ^^^^^^^^^^^^^   ^^^^^^^^^^^^^

      (![] + [])[3] + (![] + [])[4] + (![] + [])[2] + (![] + [])[0]
      ^^^^^^^^^^^^^   ^^^^^^^^^^^^^   ^^^^^^^^^^^^^   ^^^^^^^^^^^^^
     (![] + [])[+!+[]+!+[]+!+[]] +
     (![] + [])[+!+[]+!+[]+!+[]+!+[]] +
     (![] + [])[+!+[]+!+[]] +
     (![] + [])[+[]]
     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     (![]+[])[+!+[]+!+[]+!+[]]+(![]+[])[+!+[]+!+[]+!+[]+!+[]]+(![]+[])[+!+[]+!+[]]+(![]+[])[+[]]
     ```

     **[⬆ Back to Top](#table-of-contents)**

360. ### <a name="360"></a> Как удалить ложные значения из массива

     Вы можете применить метод фильтра к массиву, передав логическое значение в качестве параметра. Таким образом, он удаляет все ложные значения (0, undefined, null, false и "") из массива.

     ```javascript
     const myArray = [false, null, 1,5, undefined]
     myArray.filter(Boolean); // [1, 5] // is same as myArray.filter(x => x);
     ```

     **[⬆ Back to Top](#table-of-contents)**

361. ### <a name="361"></a> Как получить уникальные значения массива

     Вы можете получить уникальные значения массива с помощью комбинации синтаксиса `Set` и выражения rest/spread(...).

     ```javascript
     console.log([...new Set([1, 2, 4, 4, 3])]); // [1, 2, 4, 3]
     ```

     **[⬆ Back to Top](#table-of-contents)**

362. ### <a name="362"></a> Что такое деструктуризация псевдонимов? aliases

     Иногда вы хотели бы иметь деструктурированную переменную с именем, отличным от имени свойства. В этом случае вы будете использовать `: newName`, чтобы указать имя для переменной. Этот процесс называется деструктурированием псевдонимов.

     ```javascript
     const obj = { x: 1 };
     // Grabs obj.x as as { otherName }
     const { x: otherName } = obj;
     ```

     **[⬆ Back to Top](#table-of-contents)**

363. ### <a name="363"></a> Как вы сопоставляете значения массива без использования метода map

     Вы можете отобразить значения массива, не используя метод `map`, просто используя метод `from` массива. Сопоставим названия городов из массива Country,

     ```javascript
     const countries = [
         { name: 'India', capital: 'Delhi' },
         { name: 'US', capital: 'Washington' },
         { name: 'Russia', capital: 'Moscow' },
         { name: 'Singapore', capital: 'Singapore' },
         { name: 'China', capital: 'Beijing' },
         { name: 'France', capital: 'Paris' },
     ];

     const cityNames = Array.from(countries, ({ capital}) => capital);
     console.log(cityNames); // ['Delhi, 'Washington', 'Moscow', 'Singapore', 'Beijing', 'Paris']
     ```

     **[⬆ Back to Top](#table-of-contents)**

364. ### <a name="364"></a> Как очистить массив

     Вы можете быстро очистить массив, установив длину массива равной нулю.

     ```javascript
     let cities = ['Singapore', 'Delhi', 'London'];
     cities.length = 0; // cities becomes []
     ```

     **[⬆ Back to Top](#table-of-contents)**

365. ### <a name="365"></a> Как вы округляете числа до определенных десятичных знаков

     Вы можете округлять числа до определенного числа знаков после запятой, используя метод toFixed из собственного javascript.

     ```javascript
     let pie = 3.141592653;
     pie = pie.toFixed(3); // 3.142
     ```

     **[⬆ Back to Top](#table-of-contents)**

366. ### <a name="366"></a> Как проще всего преобразовать массив в объект

     Вы можете преобразовать массив в объект с теми же данными, используя оператор распространения (...).

     ```javascript
     var fruits = ["banana", "apple", "orange", "watermelon"];
     var fruitsObject = {...fruits};
     console.log(fruitsObject); // {0: "banana", 1: "apple", 2: "orange", 3: "watermelon"}
     ```

     **[⬆ Back to Top](#table-of-contents)**

367. ### <a name="367"></a> Как вы создаете массив с некоторыми данными

     Вы можете создать массив с некоторыми данными или массив с теми же значениями, используя метод `fill`.

     ```javascript
     var newArray = new Array(5).fill("0");
     console.log(newArray); // ["0", "0", "0", "0", "0"]
     ```

     **[⬆ Back to Top](#table-of-contents)**

368. ### <a name="368"></a> Что такое placeholders из объекта консоли

     Ниже приведен список заполнителей, доступных из объекта консоли,
     1. %o — принимает объект,
     2. %s — принимает строку,
     3. %d — используется для десятичного или целого числа.
     
     Эти заполнители могут быть представлены в console.log, как показано ниже.

     ```javascript
     const user = { "name":"John", "id": 1, "city": "Delhi"};
     console.log("Hello %s, your details %o are available in the object form", "John", user); // Hello John, your details {name: "John", id: 1, city: "Delhi"} are available in object
     ```

     **[⬆ Back to Top](#table-of-contents)**

369. ### <a name="369"></a> Можно ли добавить CSS в консольные сообщения

     Да, вы можете применять стили CSS к консольным сообщениям, аналогичным html-тексту на веб-странице.

     ```javascript
     console.log('%c The text has blue color, with large font and red background', 'color: blue; font-size: x-large; background: red');
     ```

     Текст будет отображаться, как показано ниже,
     ![Screenshot](images/console-css.png)

     **Примечание.** К консольным сообщениям можно применять все стили CSS.

     **[⬆ Back to Top](#table-of-contents)**

370. ### <a name="370"></a> Какова цель метода dir консольного объекта

     `console.dir()` используется для отображения интерактивного списка свойств указанного объекта JavaScript в формате JSON.

     ```javascript
     const user = { "name":"John", "id": 1, "city": "Delhi"};
     console.dir(user);
     ```

     Объект пользователя, отображаемый в представлении JSON
     ![Screenshot](images/console-dir.png)

     **[⬆ Back to Top](#table-of-contents)**

371. ### <a name="371"></a> Можно ли отлаживать элементы HTML в консоли

     Да, можно получать и отлаживать HTML-элементы в консоли так же, как и при проверке элементов.

     ```javascript
     const element = document.getElementsByTagName("body")[0];
     console.log(element);
     ```

     Он печатает элемент HTML в консоли,
     
     ![Screenshot](images/console-html.png)

     **[⬆ Back to Top](#table-of-contents)**

372. ### <a name="372"></a> Как вы отображаете данные в табличном формате с помощью объекта консоли

     `console.table()` используется для отображения данных в консоли в табличном формате для визуализации сложных массивов или объектов.

     ```js
     const users = [{ "name":"John", "id": 1, "city": "Delhi"}, { "name":"Max", "id": 2, "city": "London"}, { "name":"Rod", "id": 3, "city": "Paris"} ];
     console.table(users);
     ```

     Данные визуализируются в виде таблицы,
     
     ![Screenshot](images/console-table.png)
     **Не:** Помните, что `console.table()` не поддерживается в IE.

     **[⬆ Back to Top](#table-of-contents)**

373. ### <a name="373"></a> Как вы проверяете, является ли аргумент числом или нет

     Комбинация методов IsNaN и isFinite используется для подтверждения того, является ли аргумент числом или нет.

     ```javascript
     function isNumber(n){
         return !isNaN(parseFloat(n)) && isFinite(n);
     }
     ```

     **[⬆ Back to Top](#table-of-contents)**

374. ### <a name="374"></a> Как создать кнопку копирования в буфер обмена

     Вам нужно выбрать содержимое (используя метод .select()) элемента ввода и выполнить команду копирования с помощью execCommand (т.е. execCommand('copy')). Вы также можете выполнять другие системные команды, такие как вырезание и вставка.

     ```javascript
     document.querySelector("#copy-button").onclick = function() {
       // Select the content
       document.querySelector("#copy-input").select();
       // Copy to the clipboard
       document.execCommand('copy');
     };
     ```

     **[⬆ Back to Top](#table-of-contents)**

375. ### <a name="375"></a> Как быстро получить метку времени (timestamp)

     You can use `new Date().getTime()` to get the current timestamp. There is an alternative shortcut to get the value.

     ```javascript
     console.log(+new Date());
     console.log(Date.now());
     ```

     **[⬆ Back to Top](#table-of-contents)**

376. ### <a name="376"></a> Как вы сглаживаете многомерные массивы 

     Сглаживание двумерных массивов с помощью оператора Spread тривиально.

     ```javascript
     const biDimensionalArr = [11, [22, 33], [44, 55], [66, 77], 88, 99];
     const flattenArr = [].concat(...biDimensionalArr); // [11, 22, 33, 44, 55, 66, 77, 88, 99]
     ```

     Но вы можете заставить его работать с многомерными массивами с помощью рекурсивных вызовов,

     ```javascript
     function flattenMultiArray(arr) {
         const flattened = [].concat(...arr);
         return flattened.some(item => Array.isArray(item)) ? flattenMultiArray(flattened) : flattened;
      }
     const multiDimensionalArr = [11, [22, 33], [44, [55, 66, [77, [88]], 99]]];
     const flatArr = flattenMultiArray(multiDimensionalArr); // [11, 22, 33, 44, 55, 66, 77, 88, 99]
     ```

     **[⬆ Back to Top](#table-of-contents)**

377. ### <a name="377"></a> Какая самая простая проверка нескольких условий

     Вы можете использовать `indexOf` для сравнения ввода с несколькими значениями вместо проверки каждого значения как одного условия.

     ```javascript
     // Verbose approach
     if (input === 'first' || input === 1 || input === 'second' || input === 2) {
       someFunction();
     }
     // Shortcut
     if (['first', 1, 'second', 2].indexOf(input) !== -1) {
       someFunction();
     }
     ```

     **[⬆ Back to Top](#table-of-contents)**

378. ### <a name="378"></a> Как вы захватываете кнопку возврата браузера

     Метод `window.onbeforeunload` используется для захвата событий кнопки «Назад» в браузере. Это полезно для предупреждения пользователей о потере текущих данных.

     ```javascript
      window.onbeforeunload = function() {
         alert("You work will be lost");
      };
     ```

     **[⬆ Back to Top](#table-of-contents)**

379. ### <a name="379"></a> Как отключить правый клик на веб-странице

     Щелчок правой кнопкой мыши на странице можно отключить, вернув false из атрибута oncontextmenu элемента body.

     ```html
     <body oncontextmenu="return false;">
     ```

     **[⬆ Back to Top](#table-of-contents)**

380. ### <a name="380"></a> Что такое объекты-оболочки

     Примитивные значения, такие как строка, число и логическое значение, не имеют свойств и методов, но они временно преобразуются или приводятся к объекту (объекту-оболочке), когда вы пытаетесь выполнить над ними действия. Например, если вы примените метод toUpperCase() к примитивному строковому значению, он не выдаст ошибку, а вернет строку в верхнем регистре.

     ```javascript
     let name = "john";

     console.log(name.toUpperCase());  // Behind the scenes treated as console.log(new String(name).toUpperCase());
     ```

     т. е. каждый примитив, кроме null и undefined, имеет объекты-оболочки, а список объектов-оболочек - это String, Number, Boolean, Symbol и BigInt.

     **[⬆ Back to Top](#table-of-contents)**

381. ### <a name="381"></a> Что тако AJAX

     AJAX означает асинхронный JavaScript и XML и представляет собой группу связанных технологий (HTML, CSS, JavaScript, XMLHttpRequest API и т. д.), используемых для асинхронного отображения данных. т.е. мы можем отправлять данные на сервер и получать данные с сервера без перезагрузки веб-страницы.

     **[⬆ Back to Top](#table-of-contents)**

382. ### <a name="382"></a> Каковы различные способы работы с асинхронным кодом

     Ниже приведен список различных способов работы с асинхронным кодом.
     1. Callbacks
     2. Promises
     3. Async/await
     4. Third-party libraries such as async.js,bluebird etc

     **[⬆ Back to Top](#table-of-contents)**

383. ### <a name="383"></a> Как отменить fetch request

     До недавнего времени одним из недостатков нативных промисов было отсутствие прямого способа отменить запрос на выборку. Но новый `AbortController` из спецификации js позволяет вам использовать сигнал для прерывания одного или нескольких вызовов выборки.
     Основной процесс отмены запроса на выборку будет таким, как показано ниже:
     1. Создайте экземпляр AbortController.
     2. Получите свойство сигнала экземпляра и передайте сигнал в качестве опции выборки для сигнала.
     3. Вызовите свойство AbortController Abort, чтобы отменить все выборки, использующие этот сигнал.
     Например, давайте передадим один и тот же сигнал нескольким вызовам fetch, и все запросы с этим сигналом будут отменены.

     ```javascript
     const controller = new AbortController();
     const { signal } = controller;

     fetch("http://localhost:8000", { signal }).then(response => {
         console.log(`Request 1 is complete!`);
     }).catch(e => {
         if(e.name === "AbortError") {
             // We know it's been canceled!
         }
     });

     fetch("http://localhost:8000", { signal }).then(response => {
         console.log(`Request 2 is complete!`);
     }).catch(e => {
          if(e.name === "AbortError") {
              // We know it's been canceled!
           }
     });

     // Wait 2 seconds to abort both requests
     setTimeout(() => controller.abort(), 2000);
     ```

     **[⬆ Back to Top](#table-of-contents)**

384. ### <a name="384"></a> Что такое web speech API

     Web speech API используется для того, чтобы современные браузеры могли распознавать и синтезировать речь (т. е. голосовые данные в веб-приложениях). Этот API был представлен сообществом W3C в 2012 году. Он состоит из двух основных частей:
     1. **Распознавание речи (асинхронное распознавание речи или преобразование речи в текст):** оно позволяет распознавать голосовой контекст из аудиовхода и реагировать соответствующим образом. Доступ к нему осуществляется через интерфейс SpeechRecognition.
     В приведенном ниже примере показано, как использовать этот API для получения текста из речи,

     ```javascript
     window.SpeechRecognition = window.webkitSpeechRecognition || window.SpeechRecognition;  // webkitSpeechRecognition for Chrome and SpeechRecognition for FF
     const recognition = new window.SpeechRecognition();
     recognition.onresult = (event) => { // SpeechRecognitionEvent type
       const speechToText = event.results[0][0].transcript;
       console.log(speechToText);
     }
     recognition.start();
     ```

     В этом API браузер будет запрашивать у вас разрешение на использование вашего микрофона.
     1. **SpeechSynthesis (преобразование текста в речь):** он позволяет распознавать голосовой контекст из аудиовхода и отвечать на него. Доступ к нему осуществляется через интерфейс SpeechSynthesis.
     Например, приведенный ниже код используется для получения голоса/речи из текста,

     ```javascript
     if('speechSynthesis' in window){
         var speech = new SpeechSynthesisUtterance('Hello World!');
         speech.lang = 'en-US';
         window.speechSynthesis.speak(speech);
     }
     ```

     Приведенные выше примеры можно протестировать в консоли разработчика браузера chrome(33+).
     **Примечание.** Этот API все еще находится в стадии разработки и доступен только в браузерах Chrome и Firefox (конечно, в Chrome реализована только спецификация).
     
     **[⬆ Back to Top](#table-of-contents)**

385. ### <a name="385"></a> Что такое минимальное регулирование времени ожидания

     И браузер, и среда javascript NodeJS регулируют скорость с минимальной задержкой, превышающей 0 мс. Это означает, что даже установка задержки в 0 мс не произойдет мгновенно.
     **Браузеры:** они имеют минимальную задержку 4 мс. Этот дроссель возникает, когда последовательные вызовы запускаются из-за вложенности обратного вызова (определенная глубина) или после определенного количества последовательных интервалов.
     Примечание. В старых браузерах минимальная задержка составляет 10 мс.
     **Nodejs:** минимальная задержка составляет 1 мс. Это происходит, когда задержка больше 2147483647 или меньше 1.
     Лучшим примером, объясняющим такое поведение регулирования тайм-аута, является приведенный ниже фрагмент кода.

     ```javascript
     function runMeFirst() {
         console.log('My script is initialized');
     }
     setTimeout(runMeFirst, 0);
     console.log('Script loaded');
     ```

     и вывод будет в

     ```cmd
     Script loaded
     My script is initialized
     ```

     Если вы не используете `setTimeout`, порядок журналов будет последовательным.

     ```javascript
     function runMeFirst() {
        console.log('My script is initialized');
     }
     runMeFirst();
     console.log('Script loaded');
     ```

     и вывод будет в

     ```cmd
     My script is initialized
     Script loaded
     ```

     **[⬆ Back to Top](#table-of-contents)**

386. ### <a name="386"></a> Как вы реализуете нулевой тайм-аут в современных браузерах

     Вы не можете использовать setTimeout(fn, 0) для немедленного выполнения кода из-за минимальной задержки более 0 мс. Но вы можете использовать window.postMessage() для достижения такого поведения.

     **[⬆ Back to Top](#table-of-contents)**

387. ### <a name="387"></a> Что такое tasks в цикле событий

     Task — это любой код/программа javascript, запуск которой запланирован с помощью стандартных механизмов, таких как первоначальный запуск программы, запуск обратного вызова события или запуск интервала или тайм-аута. Все эти задачи планируются в очереди задач.
     Ниже приведен список вариантов использования для добавления задач в очередь задач,
     1. Когда новая программа javascript выполняется непосредственно из консоли или с помощью элемента ```<script>```, задача будет добавлена ​​в очередь задач.
     2. Когда событие срабатывает, обратный вызов события добавляется в очередь задач.
     3. При достижении setTimeout или setInterval соответствующий обратный вызов добавляется в очередь задач.

     **[⬆ Back to Top](#table-of-contents)**

388. ### <a name="388"></a> Что такое микрозадачи

     Микрозадача — это код javascript, который необходимо выполнить сразу после завершения текущей выполняемой задачи/микрозадачи. Они носят блокирующий характер. т. е. основной поток будет заблокирован до тех пор, пока очередь микрозадач не станет пустой.
     Основными источниками микрозадач являются Promise.resolve, Promise.reject, MutationObservers, IntersectionObservers и т. д.

     **Примечание.** Все эти микрозадачи обрабатываются в одном витке цикла событий.
     **[⬆ Back to Top](#table-of-contents)**

389. ### <a name="389"></a> Чем отличаются циклы событий

     **[⬆ Back to Top](#table-of-contents)**

390. ### <a name="390"></a> Какова цель queueMicrotask

     **[⬆ Back to Top](#table-of-contents)**

391. ### <a name="391"></a> Как вы используете библиотеки javascript в файле typescript

     Известно, что не все библиотеки или фреймворки JavaScript имеют файлы объявлений TypeScript. Но если вы все еще хотите использовать библиотеки или фреймворки в наших файлах TypeScript без ошибок компиляции, единственным решением является ключевое слово `declare` вместе с объявлением переменной. Например, давайте представим, что у вас есть библиотека под названием customLibrary, которая не имеет объявления TypeScript и имеет пространство имен под названием customLibrary в глобальном пространстве имен. Вы можете использовать эту библиотеку в машинописном коде, как показано ниже:

     ```javascript
     declare var customLibrary;
     ```

     Во время выполнения машинописный текст предоставит тип переменной customLibrary как любой тип. Другая альтернатива без использования ключевого слова declare приведена ниже.

     ```javascript
     var customLibrary: any;
     ```

     **[⬆ Back to Top](#table-of-contents)**

392. ### <a name="392"></a> В чем разница между promises and observables? (обещаниями и наблюдаемыми)

     Некоторые из основных отличий в табличной форме

     | Promises | Observables |
     |---- | ---------
     | Выдает только одно значение за раз | Выдает несколько значений за определенный период времени (поток значений от 0 до нескольких) |
     | Нетерпеливый по своей природе; они будут вызваны немедленно | Ленивый по натуре; они требуют подписки для вызова |
     | Обещание всегда асинхронно, даже если оно разрешается немедленно | Observable может быть как синхронным, так и асинхронным |
     | Не предоставляет никаких операторов | Предоставляет такие операторы, как map, forEach, filter, reduce, retry и retryWhen и т. д. |
     | Нельзя отменить | Отменено методом unsubscribe() |

     **[⬆ Back to Top](#table-of-contents)**

393. ### <a name="393"></a> Что такое heap (куча)

     Куча (или куча памяти) — это место в памяти, где хранятся объекты, когда мы определяем переменные. т. е. это место, где происходят все выделения и освобождения памяти. И куча, и стек вызовов — это два контейнера среды выполнения JS.
     Всякий раз, когда среда выполнения сталкивается с переменными и объявлениями функций в коде, она сохраняет их в куче.

     ![Screenshot](images/heap.png)

     **[⬆ Back to Top](#table-of-contents)**

394. ### <a name="394"></a> Что такое event table

     Таблица событий — это структура данных, которая хранит и отслеживает все события, которые будут выполняться асинхронно, например, через какой-то интервал времени или после разрешения некоторых запросов API. т. е. всякий раз, когда вы вызываете функцию setTimeout или вызываете асинхронную операцию, она добавляется в таблицу событий.
     Он не выполняет функции сам по себе. Основная цель таблицы событий — отслеживать события и отправлять их в очередь событий, как показано на диаграмме ниже.

     ![Screenshot](images/event-table.png)

     **[⬆ Back to Top](#table-of-contents)**

395. ### <a name="395"></a> Что такое очередь микрозадач

     Очередь микрозадач — это новая очередь, в которой все задачи, инициированные объектами-обещаниями, обрабатываются перед очередью обратного вызова.
     Очередь микрозадач обрабатывается перед следующими заданиями рендеринга и рисования. Но если эти микрозадачи выполняются долго, то это приводит к ухудшению зрения.

     **[⬆ Back to Top](#table-of-contents)**

396. ### <a name="396"></a> В чем разница между shim и polyfill

     Shim — это библиотека, которая переносит новый API в старую среду, используя только средства этой среды. Это не обязательно ограничивается веб-приложением. Например, es5-shim.js используется для эмуляции функций ES5 в старых браузерах (в основном до IE9).
     Принимая во внимание, что polyfill — это часть кода (или плагин), который предоставляет технологию, которую вы, разработчик, ожидаете от браузера изначально.
     Проще говоря, полифилл — это прокладка для API браузера.

     **[⬆ Back to Top](#table-of-contents)**

397. ### <a name="397"></a> Как определить примитивный или не примитивный тип значения

     В JavaScript к примитивным типам относятся логические, строковые, числовые, BigInt, null, Symbol и undefined. В то время как непримитивные типы включают в себя Objects. Но вы можете легко идентифицировать их с помощью функции ниже,

     ```javascript
     var myPrimitive = 30;
     var myNonPrimitive = {};
     function isPrimitive(val) {
         return Object(val) !== val;
     }

     isPrimitive(myPrimitive);
     isPrimitive(myNonPrimitive);
     ```

     Если значение является примитивным типом данных, конструктор Object создает новый объект-оболочку для значения. Но если значение является непримитивным типом данных (объектом), конструктор объекта даст тот же объект.

     **[⬆ Back to Top](#table-of-contents)**

398. ### <a name="398"></a> Что такое babel

     Babel — это транспилятор JavaScript для преобразования кода ECMAScript 2015+ в обратно совместимую версию JavaScript в текущих и более старых браузерах или средах. Некоторые из основных функций перечислены ниже,
     1. Синтаксис преобразования
     2. Функции Polyfill, отсутствующие в вашей целевой среде (с использованием @babel/polyfill)
     3. Преобразования исходного кода (или codemods)

     **[⬆ Back to Top](#table-of-contents)**

399. ### <a name="399"></a> Является ли Node.js полностью однопоточным?

     Node является однопоточным, но некоторые функции, включенные в стандартную библиотеку Node.js (например, функции модуля fs), не являются однопоточными. т. е. их логика выполняется за пределами одного потока Node.js для повышения скорости и производительности программы.

     **[⬆ Back to Top](#table-of-contents)**

400. ### <a name="400"></a> Каковы общие случаи использования observables

     Некоторые из наиболее распространенных вариантов использования observables — это веб-сокеты с push-уведомлениями, изменениями пользовательского ввода, повторяющимися интервалами и т. д.

     **[⬆ Back to Top](#table-of-contents)**

401. ### <a name="401"></a> Что такое RxJS

     RxJS (Reactive Extensions for JavaScript) — это библиотека для реализации реактивного программирования с использованием наблюдаемых объектов, которая упрощает создание асинхронного кода или кода на основе обратного вызова. Он также предоставляет служебные функции для создания и работы с наблюдаемыми.

     **[⬆ Back to Top](#table-of-contents)**

402. ### <a name="402"></a> В чем разница между Function constructor and function declaration

     Функции, созданные с помощью `Конструктора функций`, не создают закрытие своих контекстов создания, но они всегда создаются в глобальной области. т. е. функция может обращаться только к своим локальным переменным и глобальным переменным области видимости. В то время как объявления функций также могут обращаться к внешним переменным функции (замыканиям).

     Давайте посмотрим на эту разницу на примере,

     **Конструктор функций:**

     ```javascript
     var a = 100;
     function createFunction() {
         var a = 200;
         return new Function('return a;');
     }
     console.log(createFunction()()); // 100
     ```

     **Function declaration:**

     ```javascript
     var a = 100;
     function createFunction() {
         var a = 200;
         return function func() {
             return a;
         }
     }
     console.log(createFunction()()); // 200
     ```

     **[⬆ Back to Top](#table-of-contents)**

403. ### <a name="403"></a> Что такое короткое замыкание? Short circuit condition

     Условия короткого замыкания предназначены для сжатого способа написания простых операторов if. Продемонстрируем сценарий на примере. Если вы хотите войти на портал с условием аутентификации, выражение будет выглядеть следующим образом:

     ```javascript
     if (authenticate) {
        loginToPorta();
     }
     ```

     Поскольку логические операторы javascript оцениваются слева направо, приведенное выше выражение можно упростить с помощью логического оператора &&.

     ```javascript
     authenticate && loginToPorta();
     ```

     **[⬆ Back to Top](#table-of-contents)**

404. ### <a name="404"></a> Как проще всего изменить размер массива

     Свойство длины массива полезно для быстрого изменения размера или очистки массива. Давайте применим свойство длины к числовому массиву, чтобы изменить количество элементов с 5 на 2,

     ```javascript
     var array = [1, 2, 3, 4, 5];
     console.log(array.length); // 5

     array.length = 2;
     console.log(array.length); // 2
     console.log(array); // [1,2]
     ```

     и массив тоже можно очистить

     ```javascript
     var array = [1, 2, 3, 4, 5];
     array.length = 0;
     console.log(array.length); // 0
     console.log(array); // []
     ```

     **[⬆ Back to Top](#table-of-contents)**

405. ### <a name="405"></a> Что такое наблюдаемый? observable

     Observable — это, по сути, функция, которая может возвращать поток значений либо синхронно, либо асинхронно наблюдателю с течением времени. Потребитель может получить значение, вызвав метод `subscribe()`.
     Давайте посмотрим на простой пример Observable

     ```javascript
     import { Observable } from 'rxjs';

     const observable = new Observable(observer => {
       setTimeout(() => {
         observer.next('Message from a Observable!');
       }, 3000);
     });

     observable.subscribe(value => console.log(value));
     ```

     ![Screenshot](images/observables.png)

     **Примечание.** Наблюдаемые объекты еще не являются частью языка JavaScript, но их предлагается добавить в язык.

     **[⬆ Back to Top](#table-of-contents)**

406. ### <a name="406"></a> В чем разница между function и class declarations

     Основное различие между объявлениями функций и объявлениями классов заключается в «подъеме». Поднимаются объявления функций, но не объявления классов.

     **Classes:**

     ```javascript
     const user = new User(); // ReferenceError

     class User {}
     ```

     **Constructor Function:**

     ```javascript
      const user = new User(); // No error

      function User() {
      }
     ```

     **[⬆ Back to Top](#table-of-contents)**

407. ### <a name="407"></a> Что такое асинхронная функция

     Асинхронная функция — это функция, объявленная с ключевым словом `async`, которая позволяет писать асинхронное поведение на основе промисов в более чистом стиле, избегая цепочек промисов. Эти функции могут содержать ноль или более выражений ожидания.

     Давайте возьмем приведенный ниже пример асинхронной функции,

     ```javascript
     async function logger() {

       let data = await fetch('http://someapi.com/users'); // pause until fetch returns
       console.log(data)
     }
     logger();
     ```

     По сути, это синтаксический сахар над обещаниями и генераторами ES2015.

     **[⬆ Back to Top](#table-of-contents)**

408. ### <a name="408"></a> Как не допустить, чтобы promises проглатывали errors?

     При использовании асинхронного кода обещания ES6 в JavaScript могут значительно упростить вашу жизнь без пирамиды обратных вызовов и обработки ошибок в каждой второй строке. Но у промисов есть несколько подводных камней, и самая большая из них — проглатывание ошибок по умолчанию.

     Допустим, вы ожидаете вывести ошибку на консоль для всех следующих случаев:

      ```javascript
      Promise.resolve('promised value').then(function() {
            throw new Error('error');
      });

      Promise.reject('error value').catch(function() {
            throw new Error('error');
      });

      new Promise(function(resolve, reject) {
            throw new Error('error');
      });
      ```

      Но есть много современных сред JavaScript, которые не выводят никаких ошибок. Вы можете решить эту проблему по-разному,

     1. **Добавьте блок catch в конце каждой цепочки:** Вы можете добавить блок catch в конец каждой из ваших цепочек промисов.

         ```javascript
         Promise.resolve('promised value').then(function() {
             throw new Error('error');
         }).catch(function(error) {
           console.error(error.stack);
         });
          ```

        Но печатать для каждой цепочки промисов довольно сложно и многословно.

     2. **Добавить метод done:** Вы можете заменить блоки then и catch первого решения на метод done.

         ```javascript
         Promise.resolve('promised value').done(function() {
             throw new Error('error');
         });
         ```

        Допустим, вы хотите получить данные с помощью HTTP, а затем выполнить асинхронную обработку полученных данных. Вы можете написать блок `done`, как показано ниже,

         ```javascript
         getDataFromHttp()
           .then(function(result) {
             return processDataAsync(result);
           })
           .done(function(processed) {
             displayData(processed);
           });
         ```

         В будущем, если API библиотеки обработки изменится на синхронный, вы можете удалить блок «done», как показано ниже:

         ```javascript
          getDataFromHttp()
            .then(function(result) {
              return displayData(processDataAsync(result));
            })
         ```

         а затем вы забыли добавить блок `done` к блоку `then`, что приводит к скрытым ошибкам.

     3. **Продление обещаний ES6 от Bluebird:**
         Bluebird расширяет API обещаний ES6, чтобы избежать проблемы во втором решении. В этой библиотеке есть обработчик onRejection «по умолчанию», который выводит все ошибки из отклоненных промисов в stderr. После установки вы можете обрабатывать необработанные отказы

         ```javascript
         Promise.onPossiblyUnhandledRejection(function(error){
             throw error;
         });
         ```

         и отмените отказ, просто обработайте его пустым уловом

         ```javascript
         Promise.reject('error value').catch(function() {});
         ```

     **[⬆ Back to Top](#table-of-contents)**

409. ### <a name="409"></a> Что такое deno

     Deno — это простая, современная и безопасная среда выполнения для JavaScript и TypeScript, использующая движок JavaScript V8 и язык программирования Rust.

     **[⬆ Back to Top](#table-of-contents)**

410. ### <a name="410"></a> Как сделать объект итерируемым в javascript?

     По умолчанию простые объекты не являются итерируемыми. Но вы можете сделать объект итерируемым, определив для него свойство `Symbol.iterator`.

     Продемонстрируем это на примере,

     ```javascript
     const collection = {
       one: 1,
       two: 2,
       three: 3,
       [Symbol.iterator]() {
         const values = Object.keys(this);
         let i = 0;
         return {
           next: () => {
             return {
               value: this[values[i++]],
               done: i > values.length
             }
           }
         };
       }
     };

     const iterator = collection[Symbol.iterator]();

     console.log(iterator.next());    // → {value: 1, done: false}
     console.log(iterator.next());    // → {value: 2, done: false}
     console.log(iterator.next());    // → {value: 3, done: false}
     console.log(iterator.next());    // → {value: undefined, done: true}
     ```

     Вышеупомянутый процесс можно упростить, используя функцию генератора,

     ```javascript
      const collection = {
        one: 1,
        two: 2,
        three: 3,
        [Symbol.iterator]: function * () {
          for (let key in this) {
            yield this[key];
          }
        }
      };
      const iterator = collection[Symbol.iterator]();
      console.log(iterator.next());    // {value: 1, done: false}
      console.log(iterator.next());    // {value: 2, done: false}
      console.log(iterator.next());    // {value: 3, done: false}
      console.log(iterator.next());    // {value: undefined, done: true}
     ```

     **[⬆ Back to Top](#table-of-contents)**

411. ### <a name="411"></a> Что такое Proper Tail Call

     Во-первых, мы должны знать о хвостовом вызове, прежде чем говорить о «Правильном хвостовом вызове». Хвостовой вызов — это вызов подпрограммы или функции, выполняемый как последнее действие вызывающей функции. Принимая во внимание, что **Правильный хвостовой вызов (PTC)** — это метод, при котором программа или код не будут создавать дополнительные кадры стека для рекурсии, когда вызов функции является хвостовым вызовом.

     Например, приведенная ниже классическая или головная рекурсия факториальной функции использует стек для каждого шага. Каждый шаг должен быть обработан до `n * factorial(n - 1)`

     ```javascript
     function factorial(n) {
       if (n === 0) {
         return 1
       }
       return n * factorial(n - 1)
     }
     console.log(factorial(5)); //120
     ```

     Но если вы используете функции хвостовой рекурсии, они продолжают передавать все необходимые данные вниз по рекурсии, не полагаясь на стек.

     ```javascript
     function factorial(n, acc = 1) {
       if (n === 0) {
         return acc
       }
       return factorial(n - 1, n * acc)
     }
     console.log(factorial(5)); //120
     ```

     Приведенный выше шаблон возвращает тот же результат, что и первый. Но аккумулятор отслеживает итог как аргумент, не используя стековую память при рекурсивных вызовах.

     **[⬆ Back to Top](#table-of-contents)**

412. ### <a name="412"></a> Как вы проверяете, является ли объект promise или нет

      Если вы не знаете, является ли значение обещанием или нет, оберните значение как `Promise.resolve(value)`, которое возвращает обещание

      ```javascript
         function isPromise(object){
            if(Promise && Promise.resolve){
            return Promise.resolve(object) == object;
            }else{
            throw "Promise not supported in your environment"
            }
         }

         var i = 1;
         var promise = new Promise(function(resolve,reject){
            resolve()
         });

         console.log(isPromise(i)); // false
         console.log(isPromise(promise)); // true
      ```

      Другой способ — проверить тип обработчика `.then()`

      ```javascript
      function isPromise(value) {
         return Boolean(value && typeof value.then === 'function');
      }
      var i = 1;
      var promise = new Promise(function(resolve,reject){
         resolve()
      });

      console.log(isPromise(i)) // false
      console.log(isPromise(promise)); // true
      ```

      **[⬆ Back to Top](#table-of-contents)**

413. ### <a name="413"></a> Как определить, вызывается ли функция как конструктор

      Вы можете использовать псевдосвойство `new.target`, чтобы определить, была ли функция вызвана как конструктор (используя оператор new) или как обычный вызов функции.

      1. Если конструктор или функция вызывается с помощью оператора new, new.target возвращает ссылку на конструктор или функцию.
      2. Для вызовов функций new.target не определен.

      ```javascript
      function Myfunc() {
         if (new.target) {
            console.log('called with new');
         } else {
            console.log('not called with new');
         }
      }

      new Myfunc(); // called with new
      Myfunc(); // not called with new
      Myfunc.call({}); not called with new
      ```

     **[⬆ Back to Top](#table-of-contents)**

414. ### <a name="414"></a> В чем разница между объектом arguments и параметром rest?

     Есть три основных различия между объектом arguments и остальными параметрами.

     1. Объект arguments похож на массив, но не на массив. Тогда как остальные параметры являются экземплярами массива.
     2. Объект arguments не поддерживает такие методы, как sort, map, forEach или pop. Тогда как эти методы могут быть использованы в остальных параметрах.
     3. Остальные параметры — это только те, которым не присвоено отдельное имя, а объект arguments содержит все переданные функции аргументы

     **[⬆ Back to Top](#table-of-contents)**

415. ### <a name="415"></a> В чем разница между оператором spread и rest параметром

     Параметр Rest собирает все оставшиеся элементы в массив. В то время как оператор Spread позволяет расширять итерации (массивы/объекты/строки) до отдельных аргументов/элементов. т. е. параметр Rest противоположен оператору спреда.

     **[⬆ Back to Top](#table-of-contents)**

416. ### <a name="416"></a> Какие бывают виды генераторов

     Есть пять видов генераторов,

     1. **Generator function declaration:**

         ```javascript
          function* myGenFunc() {
               yield 1;
               yield 2;
               yield 3;
          }
          const genObj = myGenFunc();
         ```

     2. **Generator function expressions:**

        ```javascript
        const myGenFunc = function* () {
               yield 1;
               yield 2;
               yield 3;
        };
        const genObj = myGenFunc();
        ```

     3. **Определения методов генератора в литералах объектов:**

        ```javascript
         const myObj = {
             * myGeneratorMethod() {
                yield 1;
                yield 2;
                yield 3;
             }
         };
         const genObj = myObj.myGeneratorMethod();
        ```

     4. **Определения метода генератора в классе:**

        ```javascript
          class MyClass {
             * myGeneratorMethod() {
                yield 1;
                yield 2;
                yield 3;
             }
          }
          const myObject = new MyClass();
          const genObj = myObject.myGeneratorMethod();
        ```

     5. **Генератор как вычисляемое свойство:**

        ```javascript
        const SomeObj = {
          *[Symbol.iterator] () {
            yield 1;
            yield 2;
            yield 3;
          }
        }

        console.log(Array.from(SomeObj)); // [ 1, 2, 3 ]
        ```

     **[⬆ Back to Top](#table-of-contents)**

417. ### <a name="417"></a> Что такое встроенные итерации

   Ниже приведен список встроенных итераций в javascript
   
      1. Массивы и типизированные массивы
      2. Строки: итерация по каждому символу или кодовым точкам Unicode.
      3. Карты: итерация по парам ключ-значение
      4. Наборы: перебирает их элементы
      5. arguments: подобная массиву специальная переменная в функциях.
      6. Коллекция DOM, такая как NodeList
      
     **[⬆ Back to Top](#table-of-contents)**

418. ### <a name="418"></a> Каковы различия между for...of и for...in statements

     Операторы for...in и for...of перебирают структуры данных js. Единственная разница заключается в том, что они повторяют:

     1. for..in перебирает все перечисляемые ключи свойств объекта
     2. for..of перебирает значения итерируемого объекта.

     Поясним эту разницу на примере,

     ```javascript
     let arr = ['a', 'b', 'c'];

     arr.newProp = 'newVlue';

     // key are the property keys
     for (let key in arr) {
       console.log(key);
     }

     // value are the property values
     for (let value of arr) {
       console.log(value);
     }
     ```

     Поскольку цикл for..in перебирает ключи объекта, первый цикл регистрирует 0, 1, 2 и newProp при переборе объекта массива. Цикл for..of перебирает значения структуры данных arr и записывает a, b, c в консоль.

     **[⬆ Back to Top](#table-of-contents)**

419. ### <a name="419"></a> Как вы определяете экземплярные и неэкземплярные свойства

     Свойства экземпляра должны быть определены внутри методов класса. Например, свойства имени и возраста определяют инсайдерский конструктор, как показано ниже:

     ```javascript
     class Person {
       constructor(name, age) {
         this.name = name;
         this.age = age;
       }
     }
     ```

     Но свойства данных Static(class) и прототипа должны быть определены вне объявления ClassBody. Давайте назначим значение возраста для класса Person, как показано ниже:

     ```javascript
     Person.staticAge = 30;
     Person.prototype.prototypeAge = 40;
     ```

     **[⬆ Back to Top](#table-of-contents)**

420. ### <a name="420"></a> В чем разница между isNaN и Number.isNaN?

     1. **isNaN**: глобальная функция `isNaN` преобразует аргумент в число и возвращает значение true, если результирующее значение равно NaN.
     2. **Number.isNaN**: этот метод не преобразует аргумент. Но он возвращает true, если тип — число, а значение — NaN.

     Давайте посмотрим разницу на примере,

     ```javascript
     isNaN(‘hello’);   // true
     Number.isNaN('hello'); // false
     ```
     
     **[⬆ Back to Top](#table-of-contents)**
     
421. ### <a name="421"></a> Как вызвать IIFE без лишних скобок?

     Для немедленно вызываемых функциональных выражений (IIFE) требуется пара круглых скобок, чтобы обернуть функцию, содержащую набор операторов.
     ```js
     (function(dt) { 
        console.log(dt.toLocaleTimeString()); 
      })(new Date()); 
     ```
     Поскольку и IIFE, и оператор void отбрасывают результат выражения, вы можете избежать дополнительных скобок, используя `void operator` для IIFE, как показано ниже:
     ```js
      void function(dt) { 
        console.log(dt.toLocaleTimeString()); 
      }(new Date()); 
     ```
     
     **[⬆ Back to Top](#table-of-contents)**

422. ### <a name="422"></a> Можно ли использовать выражения в switch cases?

     Возможно, вы видели выражения, используемые в условиях переключения, но их также можно использовать для случаев переключения, назначив истинное значение для условия переключения. Давайте посмотрим на погодные условия на основе температуры в качестве примера,
     ```js
     const weather = function getWeather(temp) {
        switch(true) {
            case temp < 0: return 'freezing';
            case temp < 10: return 'cold';
            case temp < 24: return 'cool';
            default: return 'unknown';
        }
        }(10);
     ```
     
     **[⬆ Back to Top](#table-of-contents)**
         
423. ### <a name="423"></a> Каков самый простой способ игнорировать promise errors?   

     Самый простой и безопасный способ игнорировать ошибки промисов — это аннулировать эту ошибку. Этот подход также удобен для ESLint.
     
     ```js
     await promise.catch(e => void e);
     ```
     **[⬆ Back to Top](#table-of-contents)**
     
424. ### <a name="424"></a> Как оформить вывод консоли с помощью CSS?

     Вы можете добавить стили CSS к выводу консоли, используя спецификатор содержимого формата CSS %c. Сообщение строки консоли может быть добавлено после спецификатора и стиля CSS в другом аргументе. Давайте напечатаем текст красного цвета, используя console.log и спецификатор CSS, как показано ниже:
     ```js
     console.log("%cThis is a red text", "color:red");
     ```
    
     Также можно добавить больше стилей для содержимого. Например, размер шрифта может быть изменен для приведенного выше текста.
     ```js
     console.log("%cThis is a red text with bigger font", "color:red; font-size:20px");
     ```
     **[⬆ Back to Top](#table-of-contents)**
     
425. ### <a name="425"></a> Что такое нулевой оператор объединения (??)

     Это логический оператор, который возвращает свой правый операнд, когда его левый операнд равен нулю или не определен, и в противном случае возвращает свой левый операнд. Это можно противопоставить логическому оператору ИЛИ (||), который возвращает правый операнд, если левый операнд является любым ложным значением, а не только нулевым или неопределенным.

     ```js
     console.log(null ?? true); // true
     console.log(false ?? true); // false
     console.log(undefined ?? true); // true
     ```

     **[⬆ Back to Top](#table-of-contents)**

426. ### <a name="426"></a> Как вы группируете и вкладываете консольный вывод?

     `console.group()` можно использовать для группировки связанных сообщений журнала, чтобы иметь возможность легко читать журналы и использовать console.groupEnd() для закрытия группы. Наряду с этим, вы также можете вкладывать группы, что позволяет выводить сообщения в иерархическом порядке.

     Например, если вы регистрируете данные пользователя:

     ```js
     console.group('User Details');
     console.log('name: Sudheer Jonna');
     console.log('job: Software Developer');

     // Nested Group
     console.group('Address');
     console.log('Street: Commonwealth');
     console.log('City: Los Angeles');
     console.log('State: California');

     console.groupEnd();
     ```
     Вы также можете использовать `console.groupCollapsed()` вместо `console.group()`, если вы хотите, чтобы группы были свернуты по умолчанию.
         
     **[⬆ Back to Top](#table-of-contents)**

427. ### <a name="427"></a> В чем разница между плотными и разреженными массивами? dense and sparse arrays?

     Элементы массива, содержащие элементы в каждом индексе, начиная с первого (0) до последнего (array.length - 1), называются плотным массивом. Принимая во внимание, что если хотя бы один элемент отсутствует в каком-либо индексе, массив называется разреженным.

     Давайте посмотрим на два типа массивов ниже,

     ```js
     const avengers = ['Ironman', 'Hulk', 'CaptainAmerica'];
     console.log(avengers[0]); // 'Ironman'
     console.log(avengers[1]); // 'Hulk'
     console.log(avengers[2]); // 'CaptainAmerica'
     console.log(avengers.length); // 3

     const justiceLeague = ['Superman', 'Aquaman', ,'Batman'];
     console.log(justiceLeague[0]); // 'Superman'
     console.log(justiceLeague[1]); // 'Aquaman'
     console.log(justiceLeague[2]); // undefined
     console.log(justiceLeague[3]); // 'Batman'
     console.log(justiceLeague.length); // 4
     ```

     **[⬆ Back to Top](#table-of-contents)**

428. ### <a name="428"></a> Какие существуют способы создания разреженных массивов? sparse arrays?

     Существует 4 разных способа создания разреженных массивов в JavaScript.

     1. **Литерал массива:** не указывать значение при использовании литерала массива. 
          ```js
          const justiceLeague = ['Superman', 'Aquaman', ,'Batman'];
          console.log(justiceLeague); // ['Superman', 'Aquaman', empty ,'Batman']
          ```
     2. **Конструктор Array():** Вызов массива (длина) или нового массива (длина)
          ```js
          const array = Array(3);
          console.log(array); // [empty, empty ,empty]
          ```
     3. **Операция удаления:** использование оператора удаления массива[индекс] в массиве.
          ```js
          const justiceLeague = ['Superman', 'Aquaman', 'Batman'];
          delete justiceLeague[1];
          console.log(justiceLeague); // ['Superman', empty, ,'Batman']
          ```
     4. **Свойство увеличения длины:** Свойство увеличения длины массива.
          ```js
          const justiceLeague = ['Superman', 'Aquaman', 'Batman'];
          justiceLeague.length = 5;
          console.log(justiceLeague); // ['Superman', 'Aquaman', 'Batman', empty, empty]
          ```
     **[⬆ Back to Top](#table-of-contents)**


### Coding Exercise

#### 1. What is the output of below code

```javascript
var car = new Vehicle("Honda", "white", "2010", "UK");
console.log(car);

function Vehicle(model, color, year, country) {
    this.model = model;
    this.color = color;
    this.year = year;
    this.country = country;
}
```

- 1: Undefined
- 2: ReferenceError
- 3: null
- 4: {model: "Honda", color: "white", year: "2010", country: "UK"}

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 4

   The function declarations are hoisted similar to any variables. So the placement for `Vehicle` function declaration doesn't make any difference.

</p>
</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 2. What is the output of below code

```javascript
function foo() {
    let x = y = 0;
    x++;
    y++;
    return x;
}

console.log(foo(), typeof x, typeof y);
```

- 1: 1, undefined and undefined
- 2: ReferenceError: X is not defined
- 3: 1, undefined and number
- 4: 1, number and number

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 3

Of course the return value of `foo()` is 1 due to the increment operator. But the statement `let x = y = 0` declares a local variable x. Whereas y declared as a global variable accidentally. This statement is equivalent to,

```javascript
 let x;
 window.y = 0;
 x = window.y;
```

Since the block scoped variable x is undefined outside of the function, the type will be undefined too. Whereas the global variable `y` is available outside the function, the value is 0 and type is number.
</p>
</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 3. What is the output of below code

```javascript
function main(){
   console.log('A');
   setTimeout(
      function print(){ console.log('B'); }
   ,0);
   console.log('C');
}
main();
```

- 1: A, B and C
- 2: B, A and C
- 3: A and C
- 4: A, C and B

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 4

The statements order is based on the event loop mechanism. The order of statements follows the below order,

1. At first, the main function is pushed to the stack.
2. Then the browser pushes the fist statement of the main function( i.e, A's console.log) to the stack, executing and popping out immediately.
3. But `setTimeout` statement moved to Browser API to apply the delay for callback.
4. In the meantime, C's console.log added to stack, executed and popped out.
5. The callback of `setTimeout` moved from Browser API to message queue.
6. The `main` function popped out from stack because there are no statements to execute
7. The callback moved from message queue to the stack since the stack is empty.
8. The console.log for B is added to the stack and display on the console.

</p>
</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 4. What is the output of below equality check

```javascript
console.log(0.1 + 0.2 === 0.3);
```

- 1: false
- 2: true

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 1

This is due to the float point math problem. Since the floating point numbers are encoded in binary format, the addition operations on them lead to rounding errors. Hence, the comparison of floating points doesn't give expected results.
You can find more details about the explanation here [0.30000000000000004.com/](https://0.30000000000000004.com/)

</p>
</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 5. What is the output of below code

```javascript
var y = 1;
  if (function f(){}) {
    y += typeof f;
  }
  console.log(y);
```

- 1: 1function
- 2: 1object
- 3: ReferenceError
- 4: 1undefined

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 4

The main points in the above code snippets are,

1. You can see function expression instead function declaration inside if statement. So it always returns true.
2. Since it is not declared(or assigned) anywhere, f is undefined and typeof f is undefined too.

In other words, it is same as

```javascript
var y = 1;
  if ('foo') {
    y += typeof f;
  }
  console.log(y);
```

**Note:** It returns 1object for MS Edge browser
</p>
</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 6. What is the output of below code

```javascript
function foo() {
  return
  {
    message: "Hello World"
  };
}
console.log(foo());
```

- 1: Hello World
- 2: Object {message: "Hello World"}
- 3: Undefined
- 4: SyntaxError

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 3

This is a semicolon issue. Normally semicolons are optional in JavaScript. So if there are any statements(in this case, return) missing semicolon, it is automatically inserted immediately. Hence, the function returned as undefined.

Whereas if the opening curly brace is along with the return keyword then the function is going to be returned as expected.

```javascript
function foo() {
  return {
    message: "Hello World"
  };
}
console.log(foo()); // {message: "Hello World"}
```

</p>
</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 7. What is the output of below code

```javascript
var myChars = ['a', 'b', 'c', 'd']
delete myChars[0];
console.log(myChars);
console.log(myChars[0]);
console.log(myChars.length);
```

- 1: [empty, 'b', 'c', 'd'], empty, 3
- 2: [null, 'b', 'c', 'd'], empty, 3
- 3: [empty, 'b', 'c', 'd'], undefined, 4
- 4: [null, 'b', 'c', 'd'], undefined, 4

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 3

The `delete` operator will delete the object property but it will not reindex the array or change its length. So the number or elements or length of the array won't be changed.
If you try to print myChars then you can observe that it doesn't set an undefined value, rather the property is removed from the array. The newer versions of Chrome use `empty` instead of `undefined` to make the difference a bit clearer.
</p>
</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 8. What is the output of below code in latest Chrome

```javascript
var array1 = new Array(3);
console.log(array1);

var array2 = [];
array2[2] = 100;
console.log(array2);

var array3 = [,,,];
console.log(array3);
```

- 1: [undefined × 3], [undefined × 2, 100], [undefined × 3]
- 2: [empty × 3], [empty × 2, 100], [empty × 3]
- 3: [null × 3], [null × 2, 100], [null × 3]
- 4: [], [100], []

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 2

The latest chrome versions display `sparse array`(they are filled with holes) using this empty x n notation. Whereas the older versions have undefined x n notation.
**Note:** The latest version of FF displays `n empty slots` notation.
</p>
</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 9. What is the output of below code

```javascript
const obj = {
  prop1: function() { return 0 },
  prop2() { return 1 },
  ['prop' + 3]() { return 2 }
}

console.log(obj.prop1());
console.log(obj.prop2());
console.log(obj.prop3());
```

- 1: 0, 1, 2
- 2: 0, { return 1 }, 2
- 3: 0, { return 1 }, { return 2 }
- 4: 0, 1, undefined

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 1

ES6 provides method definitions and property shorthands for objects. So both prop2 and prop3 are treated as regular function values.
</p>
</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 10. What is the output of below code

```javascript
console.log(1 < 2 < 3);
console.log(3 > 2 > 1);
```

- 1: true, true
- 2: true, false
- 3: SyntaxError, SyntaxError,
- 4: false, false

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 2

The important point is that if the statement contains the same operators(e.g, < or >) then it can be evaluated from left to right.
The first statement follows the below order,

1. console.log(1 < 2 < 3);
2. console.log(true < 3);
3. console.log(1 < 3); // True converted as `1` during comparison
4. True

Whereas the second statement follows the below order,

1. console.log(3 > 2 > 1);
2. console.log(true > 1);
3. console.log(1 > 1); // False converted as `0` during comparison
4. False

</p>
</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 11. What is the output of below code in non-strict mode

```javascript
function printNumbers(first, second, first) {
  console.log(first, second, first);
}
printNumbers(1, 2, 3);
```

- 1: 1, 2, 3
- 2: 3, 2, 3
- 3: SyntaxError: Duplicate parameter name not allowed in this context
- 4: 1, 2, 1

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 2

In non-strict mode, the regular JavaScript functions allow duplicate named parameters. The above code snippet has duplicate parameters on 1st and 3rd parameters.
The value of the first parameter is mapped to the third argument which is passed to the function. Hence, the 3rd argument overrides the first parameter.

**Note:** In strict mode, duplicate parameters will throw a Syntax Error.
</p>
</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 12. What is the output of below code

```javascript
const printNumbersArrow = (first, second, first) => {
  console.log(first, second, first);
}
printNumbersArrow(1, 2, 3);
```

- 1: 1, 2, 3
- 2: 3, 2, 3
- 3: SyntaxError: Duplicate parameter name not allowed in this context
- 4: 1, 2, 1

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 3

Unlike regular functions, the arrow functions doesn't not allow duplicate parameters in either strict or non-strict mode. So you can see `SyntaxError` in the console.
</p>
</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 13. What is the output of below code

```javascript
const arrowFunc = () => arguments.length;
console.log(arrowFunc(1, 2, 3));
```

- 1: ReferenceError: arguments is not defined
- 2: 3
- 3: undefined
- 4: null

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 1

Arrow functions do not have an `arguments, super, this, or new.target` bindings. So any reference to `arguments` variable tries to resolve to a binding in a lexically enclosing environment. In this case, the arguments variable is not defined outside of the arrow function. Hence, you will receive a reference error.

Where as the normal function provides the number of arguments passed to the function

```javascript
const func = function () {
                    return arguments.length;
                    }
console.log(func(1, 2, 3));
```

But If you still want to use an arrow function then rest operator on arguments provides the expected arguments

```javascript
const arrowFunc = (...args) => args.length;
console.log(arrowFunc(1, 2, 3));
```

</p>
</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 14. What is the output of below code

```javascript
console.log( String.prototype.trimLeft.name === 'trimLeft' );
console.log( String.prototype.trimLeft.name === 'trimStart' );
```

- 1: True, False
- 2: False, True

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 2

In order to be consistent with functions like `String.prototype.padStart`, the standard method name for trimming the whitespaces is considered as `trimStart`. Due to web web compatibility reasons, the old method name 'trimLeft' still acts as an alias for 'trimStart'. Hence, the prototype for 'trimLeft' is always 'trimStart'
</p>
</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 15. What is the output of below code

```javascript
console.log(Math.max());
```

- 1: undefined
- 2: Infinity
- 3: 0
- 4: -Infinity

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 4

-Infinity is the initial comparant because almost every other value is bigger. So when no arguments are provided, -Infinity is going to be returned.
**Note:** Zero number of arguments is a valid case.
</p>
</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 16. What is the output of below code

```javascript
console.log(10 == [10]);
console.log(10 == [[[[[[[10]]]]]]]);
```

- 1: True, True
- 2: True, False
- 3: False, False
- 4: False, True

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 1
As per the comparison algorithm in the ECMAScript specification(ECMA-262), the above expression converted into JS as below
```javascript
10 === Number([10].valueOf().toString()) // 10
```
So it doesn't matter about number brackets([]) around the number, it is always converted to a number in the expression.
</p>
</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 17. What is the output of below code

```javascript
console.log(10 + '10');
console.log(10 - '10');
```

- 1: 20, 0
- 2: 1010, 0
- 3: 1010, 10-10
- 4: NaN, NaN

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 2

The concatenation operator(+) is applicable for both number and string types. So if any operand is string type then both operands concatenated as strings. Whereas subtract(-) operator tries to convert the operands as number type.
</p>
</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 18. What is the output of below code

```javascript
console.log([0] == false);
if([0]) {
console.log("I'm True");
} else {
console.log("I'm False");
}

```

- 1: True, I'm True
- 2: True, I'm False
- 3: False, I'm True
- 4: False, I'm False

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 1

In comparison operators, the expression `[0]` converted to Number([0].valueOf().toString()) which is resolved to false. Whereas `[0]` just becomes a truthy value without any conversion because there is no comparison operator.
</p>
</details>

#### 19. What is the output of below code

```javascript
console.log([1, 2] + [3, 4]);
```

- 1: [1,2,3,4]
- 2: [1,2][3,4]
- 3: SyntaxError
- 4: 1,23,4

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 4

The + operator is not meant or defined for arrays. So it converts arrays into strings and concatenates them.
</p>
</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 20. What is the output of below code

```javascript
const numbers = new Set([1, 1, 2, 3, 4]);
console.log(numbers);

const browser = new Set('Firefox');
console.log(browser);
```

- 1: {1, 2, 3, 4}, {"F", "i", "r", "e", "f", "o", "x"}
- 2: {1, 2, 3, 4}, {"F", "i", "r", "e", "o", "x"}
- 3: [1, 2, 3, 4], ["F", "i", "r", "e", "o", "x"]
- 4: {1, 1, 2, 3, 4}, {"F", "i", "r", "e", "f", "o", "x"}

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 1

Since `Set` object is a collection of unique values, it won't allow duplicate values in the collection. At the same time, it is case sensitive data structure.
</p>
</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 21. What is the output of below code

```javascript
console.log(NaN === NaN);
```

- 1: True
- 2: False

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 2

JavaScript follows IEEE 754 spec standards. As per this spec, NaNs are never equal for floating-point numbers.
</p>
</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 22. What is the output of below code

```javascript
let numbers = [1, 2, 3, 4, NaN];
console.log(numbers.indexOf(NaN));
```

- 1: 4
- 2: NaN
- 3: SyntaxError
- 4: -1

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 4

The `indexOf` uses strict equality operator(===) internally and `NaN === NaN` evaluates to false. Since indexOf won't be able to find NaN inside an array, it returns -1 always.
But you can use `Array.prototype.findIndex` method to find out the index of NaN in an array or You can use `Array.prototype.includes` to check if NaN is present in an array or not.

```javascript
let numbers = [1, 2, 3, 4, NaN];
console.log(numbers.findIndex(Number.isNaN)); // 4

console.log(numbers.includes(NaN)); // true
```

</p>
</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 23. What is the output of below code

```javascript
let [a, ...b,] = [1, 2, 3, 4, 5];
console.log(a, b);
```

- 1: 1, [2, 3, 4, 5]
- 2: 1, {2, 3, 4, 5}
- 3: SyntaxError
- 4: 1, [2, 3, 4]

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 3

When using rest parameters, trailing commas are not allowed and will throw a SyntaxError.
If you remove the trailing comma then it displays 1st answer

```javascript
let [a, ...b] = [1, 2, 3, 4, 5];
console.log(a, b); // 1, [2, 3, 4, 5]
```

</p>
</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 25. What is the output of below code

```javascript
async function func() {
   return 10;
}
console.log(func());
```

- 1: Promise {\<fulfilled\>: 10}
- 2: 10
- 3: SyntaxError
- 4: Promise {\<rejected\>: 10}

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 1

Async functions always return a promise. But even if the return value of an async function is not explicitly a promise, it will be implicitly wrapped in a promise. The above async function is equivalent to below expression,

```javascript
function func() {
   return Promise.resolve(10)
}
```
</p>
</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 26. What is the output of below code

```javascript
async function func() {
   await 10;
}
console.log(func());
```

- 1: Promise {\<fulfilled\>: 10}
- 2: 10
- 3: SyntaxError
- 4: Promise {\<resolved\>: undefined}

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 4

The await expression returns value 10 with promise resolution and the code after each await expression can be treated as existing in a `.then` callback. In this case, there is no return expression at the end of the function. Hence, the default return value of `undefined` is returned as the resolution of the promise.  The above async function is equivalent to below expression,

```javascript
function func() {
   return Promise.resolve(10).then(() => undefined)
}
```
</p>
</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 27. What is the output of below code

```javascript
function delay() {
  return new Promise(resolve => setTimeout(resolve, 2000));
}

async function delayedLog(item) {
  await delay();
  console.log(item);
}

async function processArray(array) {
  array.forEach(item => {
    await delayedLog(item);
  })
}

processArray([1, 2, 3, 4]);
```

- 1: SyntaxError
- 2: 1, 2, 3, 4
- 3: 4, 4, 4, 4
- 4: 4, 3, 2, 1

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 1

Even though “processArray” is an async function, the anonymous function that we use for `forEach` is synchronous. If you use await inside a synchronous function then it throws a syntax error.
</p>

</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 28. What is the output of below code

```javascript
function delay() {
  return new Promise(resolve => setTimeout(resolve, 2000));
}

async function delayedLog(item) {
  await delay();
  console.log(item);
}

async function process(array) {
  array.forEach(async (item) => {
    await delayedLog(item);
  });
  console.log('Process completed!');
}
process([1, 2, 3, 5]);
```




- 1: 1 2 3 5 and Process completed!
- 2: 5 5 5 5 and Process completed!
- 3: Process completed! and 5 5 5 5
- 4: Process completed! and 1 2 3 5

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 4

The forEach method will not wait until all items are finished but it just runs the tasks and goes next. Hence, the last statement is displayed first followed by a sequence of promise resolutions.

But you control the array sequence using for..of loop,

```javascript
async function processArray(array) {
  for (const item of array) {
    await delayedLog(item);
  }
  console.log('Process completed!');
}
```

</p>
</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 29. What is the output of below code

```javascript
var set = new Set();
set.add("+0").add("-0").add(NaN).add(undefined).add(NaN);;
console.log(set);
```

- 1: Set(4) {"+0", "-0", NaN, undefined}
- 2: Set(3) {"+0", NaN, undefined}
- 3: Set(5) {"+0", "-0", NaN, undefined, NaN}
- 4: Set(4) {"+0", NaN, undefined, NaN}

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 1

Set has few exceptions from equality check,

1. All NaN values are equal
2. Both +0 and -0 considered as different values

</p>
</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 30. What is the output of below code

```javascript
const sym1 = Symbol('one');
const sym2 = Symbol('one');

const sym3 = Symbol.for('two');
const sym4 = Symbol.for('two');

cnsooe.log(sym1 === sym2, sym3 === sym4);
```

- 1: true, true
- 2: true, false
- 3: false, true
- 4: false, false

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 3

Symbol follows below conventions,

1. Every symbol value returned from Symbol() is unique irrespective of the optional string.
2. `Symbol.for()` function creates a symbol in a global symbol registry list. But it doesn't  necessarily create a new symbol on every call, it checks first if a symbol with the given key is already present in the registry and returns the symbol if it is found. Otherwise a new symbol created in the registry.

**Note:** The symbol description is just useful for debugging purposes.
</p>

</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 31. What is the output of below code

```javascript
const sym1 = new Symbol('one');
console.log(sym1);
```

- 1: SyntaxError
- 2: one
- 3: Symbol('one')
- 4: Symbol

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 1

`Symbol` is a just a standard function and not an object constructor(unlike other primitives new Boolean, new String and new Number). So if you try to call it with the new operator will result in a TypeError
</p>

</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 32. What is the output of below code

```javascript
let myNumber = 100;
let myString = '100';

if (!typeof myNumber === "string") {
   console.log("It is not a string!");
} else {
    console.log("It is a string!");
}

if (!typeof myString === "number"){
   console.log("It is not a number!")
} else {
   console.log("It is a number!");
}
```

- 1: SyntaxError
- 2: It is not a string!, It is not a number!
- 3: It is not a string!, It is a number!
- 4: It is a string!, It is a number!

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 4

The return value of `typeof myNumber (OR) typeof myString` is always the truthy value (either "number" or "string"). Since ! operator converts the value to a boolean value, the value of both `!typeof myNumber or !typeof myString` is always false. Hence the if condition fails and control goes to else block.
</p>

</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 33. What is the output of below code

```javascript
console.log(JSON.stringify({ myArray: ['one', undefined, function(){}, Symbol('')] }));
console.log(JSON.stringify({ [Symbol.for('one')]: 'one' }, [Symbol.for('one')]));
```

- 1: {"myArray":['one', undefined, {}, Symbol]}, {}
- 2: {"myArray":['one', null,null,null]}, {}
- 3: {"myArray":['one', null,null,null]}, "{ [Symbol.for('one')]: 'one' }, [Symbol.for('one')]"
- 4: {"myArray":['one', undefined, function(){}, Symbol('')]}, {}

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 2

The symbols has below constraints,

1. The undefined, Functions, and Symbols are not valid JSON values. So those values are either omitted (in an object) or changed to null (in an array). Hence, it returns null values for the value array.
2. All Symbol-keyed properties will be completely ignored. Hence it returns an empty object({}).

</p>

</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 34. What is the output of below code

```javascript
class A {
  constructor() {
    console.log(new.target.name)
  }
}

class B extends A { constructor() { super() } }

new A();
new B();
```

- 1: A, A
- 2: A, B

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 2

Using constructors, `new.target` refers to the constructor (points to the class definition of class which is initialized) that was directly invoked by new. This also applies to the case if the constructor is in a parent class and was delegated from a child constructor.
</p>

</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 35. What is the output of below code

```javascript
const [x, ...y,] = [1, 2, 3, 4];
console.log(x, y);
```

- 1: 1, [2, 3, 4]
- 2: 1, [2, 3]
- 3: 1, [2]
- 4: SyntaxError

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 4

It throws a syntax error because the rest element should not have a trailing comma. You should always consider using a rest operator as the last element.
</p>

</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 36. What is the output of below code

```javascript
const {a: x = 10, b: y = 20} = {a: 30};

console.log(x);
console.log(y);
```

- 1: 30, 20
- 2: 10, 20
- 3: 10, undefined
- 4: 30, undefined

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 1

The object property follows below rules,

1. The object properties can be retrieved and assigned to a variable with a different name
2. The property assigned a default value when the retrieved value is `undefined`

</p>

</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 37. What is the output of below code

```javascript
function area({length = 10, width = 20}) {
  console.log(length*width);
}

area();
```

- 1: 200
- 2: Error
- 3: undefined
- 4: 0

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 2

If you leave out the right-hand side assignment for the destructuring object, the function will look for at least one argument to be supplied when invoked. Otherwise you will receive an error `Error: Cannot read property 'length' of undefined` as mentioned above.

You can avoid the error with either of the below changes,

1. **Pass at least an empty object:**

```javascript
function area({length = 10, width = 20}) {
  console.log(length*width);
}

area({});
```

2. **Assign default empty object:**

```javascript
function area({length = 10, width = 20} = {}) {
  console.log(length*width);
}

area();
```

</p>

</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 38. What is the output of below code

```javascript
const props = [
  { id: 1, name: 'John'},
  { id: 2, name: 'Jack'},
  { id: 3, name: 'Tom'}
];

const [,, { name }] = props;
console.log(name);
```

- 1: Tom
- 2: Error
- 3: undefined
- 4: John

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 1

It is possible to combine Array and Object destructuring. In this case, the third element in the array props accessed first followed by name property in the object.
</p>

</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 39. What is the output of below code

```javascript
function checkType(num = 1) {
  console.log(typeof num);
}

checkType();
checkType(undefined);
checkType('');
checkType(null);
```

- 1: number, undefined, string, object
- 2: undefined, undefined, string, object
- 3: number, number, string, object
- 4: number, number, number, number

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 3

If the function argument is set implicitly(not passing argument) or explicitly to undefined, the value of the argument is the default parameter. Whereas for other falsy values('' or null), the value of the argument is passed as a parameter.

Hence, the result of function calls categorized as below,

1. The first two function calls logs number type since the type of default value is number
2. The type of '' and null values are string and object type respectively.

</p>

</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 40. What is the output of below code

```javascript
function add(item, items = []) {
  items.push(item);
  return items;
}

console.log(add('Orange'));
console.log(add('Apple'));
```

- 1: ['Orange'], ['Orange', 'Apple']
- 2: ['Orange'], ['Apple']

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 2

Since the default argument is evaluated at call time, a new object is created each time the function is called. So in this case, the new array is created and an element pushed to the default empty array.

</p>

</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 41. What is the output of below code

```javascript
function greet(greeting, name, message = greeting + ' ' + name) {
  console.log([greeting, name, message]);
}

greet('Hello', 'John');
greet('Hello', 'John', 'Good morning!');
```

- 1: SyntaxError
- 2: ['Hello', 'John', 'Hello John'], ['Hello', 'John', 'Good morning!']


<details><summary><b>Answer</b></summary>
<p>

##### Answer: 2

Since parameters defined earlier are available to later default parameters, this code snippet doesn't throw any error.
</p>

</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 42. What is the output of below code

```javascript
function outer(f = inner()) {
  function inner() { return 'Inner' }
}
outer();
```

- 1: ReferenceError
- 2: Inner

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 1

The functions and variables declared in the function body cannot be referred from default value parameter initializers. If you still try to access, it throws a run-time ReferenceError(i.e, `inner` is not defined).
</p>

</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 43. What is the output of below code

```javascript
function myFun(x, y, ...manyMoreArgs) {
  console.log(manyMoreArgs)
}

myFun(1, 2, 3, 4, 5);
myFun(1, 2);
```

- 1: [3, 4, 5], undefined
- 2: SyntaxError
- 3: [3, 4, 5], []
- 4: [3, 4, 5], [undefined]

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 3

The rest parameter is used to hold the remaining parameters of a function and it becomes an empty array if the argument is not provided.
</p>

</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 44. What is the output of below code

```javascript
const obj = {'key': 'value'};
const array = [...obj];
console.log(array);
```

- 1: ['key', 'value']
- 2: TypeError
- 3: []
- 4: ['key']

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 2

Spread syntax can be applied only to iterable objects. By default, Objects are not iterable, but they become iterable when used in an Array, or with iterating functions such as `map(), reduce(), and assign()`. If you still try to do it, it still throws `TypeError: obj is not iterable`.
</p>

</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 45. What is the output of below code

```javascript
function* myGenFunc() {
    yield 1;
    yield 2;
    yield 3;
}
var myGenObj = new myGenFunc;
console.log(myGenObj.next().value);
```

- 1: 1
- 2: undefined
- 3: SyntaxError
- 4: TypeError

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 4

Generators are not constructible type. But if you still proceed to do, there will be an error saying "TypeError: myGenFunc is not a constructor"

</p>

</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 46. What is the output of below code

```javascript

function* yieldAndReturn() {
  yield 1;
  return 2;
  yield 3;
}

var myGenObj = yieldAndReturn()
console.log(myGenObj.next());
console.log(myGenObj.next());
console.log(myGenObj.next());
```

- 1: { value: 1, done: false }, { value: 2, done: true }, { value: undefined, done: true }
- 2: { value: 1, done: false }, { value: 2, done: false }, { value: undefined, done: true }
- 3: { value: 1, done: false }, { value: 2, done: true }, { value: 3, done: true }
- 4: { value: 1, done: false }, { value: 2, done: false }, { value: 3, done: true }

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 1

A return statement in a generator function will make the generator finish. If a value is returned, it will be set as the value property of the object and done property to true. When a generator is finished, subsequent next() calls return an object of this form: `{value: undefined, done: true}`.
</p>

</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 47. What is the output of below code

```javascript
const myGenerator = (function *(){
  yield 1;
  yield 2;
  yield 3;
})();
for (const value of myGenerator) {
  console.log(value);
  break;
}

for (const value of myGenerator) {
  console.log(value);
}
```

- 1: 1,2,3 and 1,2,3
- 2: 1,2,3 and 4,5,6
- 3: 1 and 1
- 4: 1

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 4

The generator should not be re-used once the iterator is closed. i.e, Upon exiting a loop(on completion or using break & return), the generator is closed and trying to iterate over it again does not yield any more results. Hence, the second loop doesn't print any value.
</p>

</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 48. What is the output of below code

```javascript
const num = 0o38;
console.log(num);
```

- 1: SyntaxError
- 2: 38

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 1
If you use an invalid number(outside of 0-7 range) in the octal literal, JavaScript will throw a SyntaxError. In ES5, it treats the octal literal as a decimal number.
</p>

</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 49. What is the output of below code

```javascript
const squareObj = new Square(10);
console.log(squareObj.area);

class Square {
  constructor(length) {
    this.length = length;
  }

  get area() {
    return this.length * this.length;
  }

  set area(value) {
    this.area = value;
  }
}
```

- 1: 100
- 2: ReferenceError

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 2

Unlike function declarations, class declarations are not hoisted. i.e, First You need to declare your class and then access it, otherwise it will throw a ReferenceError "Uncaught ReferenceError: Square is not defined".

**Note:** Class expressions also applies to the same hoisting restrictions of class declarations.
</p>

</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 50. What is the output of below code

```javascript
function Person() { }

Person.prototype.walk = function() {
  return this;
}

Person.run = function() {
  return this;
}

let user = new Person();
let walk = user.walk;
console.log(walk());

let run = Person.run;
console.log(run());
```

- 1: undefined, undefined
- 2: Person, Person
- 3: SyntaxError
- 4: Window, Window

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 4

When a regular or prototype method is called without a value for **this**, the methods return an initial this value if the value is not undefined. Otherwise global window object will be returned. In our case, the initial `this` value is undefined so both methods return window objects.

</p>

</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 51. What is the output of below code

```javascript
class Vehicle {
  constructor(name) {
    this.name = name;
  }

  start() {
    console.log(`${this.name} vehicle started`);
  }
}

class Car extends Vehicle {
  start() {
    console.log(`${this.name} car started`);
    super.start();
  }
}

const car = new Car('BMW');
console.log(car.start());
```

- 1: SyntaxError
- 2: BMW vehicle started, BMW car started
- 3: BMW car started, BMW vehicle started
- 4: BMW car started, BMW car started

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 3

The super keyword is used to call methods of a superclass. Unlike other languages the super invocation doesn't need to be a first statement. i.e, The statements will be executed in the same order of code.

</p>

</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 52. What is the output of below code

```javascript
const USER = {'age': 30};
USER.age = 25;
console.log(USER.age);
```

- 1: 30
- 2: 25
- 3: Uncaught TypeError
- 4: SyntaxError

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 2

Even though we used constant variables, the content of it is an object and the object's contents (e.g properties) can be altered. Hence, the change is going to be valid in this case.
</p>

</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 53. What is the output of below code

```javascript
console.log('🙂' === '🙂');
```

- 1: false
- 2: true

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 2
Emojis are unicodes and the unicode for smile symbol is "U+1F642". The unicode comparision of same emojies is equivalent to string comparison. Hence, the output is always true.

</p>

</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 54. What is the output of below code?

```javascript
console.log(typeof typeof typeof true);
```

- 1: string
- 2: boolean
- 3: NaN
- 4: number

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 1
The typeof operator on any primitive returns a string value. So even if you apply the chain of typeof operators on the return value, it is always string.
</p>

</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 55. What is the output of below code?

```javascript
let zero = new Number(0);

if (zero) {
  console.log("If");
} else {
  console.log("Else");
}
```

- 1: If
- 2: Else
- 3: NaN
- 4: SyntaxError

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 1
1. The type of operator on new Number always returns object. i.e, typeof new Number(0) --> object. 
2. Objects are always truthy in if block

Hence the above code block always goes to if section.

</p>

</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 55. What is the output of below code in non strict mode?

```javascript
let msg = "Good morning!!";

msg.name = "John"; 

console.log(msg.name);
```

- 1: ""
- 2: Error
- 3: John
- 4: Undefined

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 4
It returns undefined for non-strict mode and returns Error for strict mode. In non-strict mode, the wrapper object is going to be created and get the mentioned property. But the object get disappeared after accessing the property in next line.
</p>

</details>

---

**[⬆ Back to Top](#table-of-contents)**

#### 56. What is the output of below code?

```javascript
let count = 10;

(function innerFunc() {
    if (count === 10) {
        let count = 11;
        console.log(count);
    }
    console.log(count);
})();
```

- 1: 11, 10
- 2: 11, 11
- 3: 10, 11
- 4: 10, 10

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 1
11 and 10 is logged to the console. 

The innerFunc is a closure which captures the count variable from the outerscope. i.e, 10. But the conditional has another local variable `count` which overwrites the ourter `count` variable. So the first console.log displays value 11.
Whereas the second console.log logs 10 by capturing the count variable from outerscope.
 
</p>

</details>

**[⬆ Back to Top](#table-of-contents)**

#### 57.  What is the output of below code ?

 - 1: console.log(true && 'hi');
 - 2: console.log(true && 'hi' && 1);
 - 3: console.log(true && '' && 0);
 
<details><summary><b>Answer</b></summary>
  
 - 1: hi
 - 2: 1
 - 3: ''
  
 Reason : The operator returns the value of the first falsy operand encountered when evaluating from left to right, or the value of the last operand if they are all truthy.

 **Note:** Below these values are consider as falsy value
 - 1:  0 
 - 2:  '' 
 - 3:  null 
 - 4:  undefined 
 - 5:  NAN 
   
</p>
</details>

---

#### 58.  What is the output of below code ?

```javascript
let arr = [1, 2, 3];
let str = "1,2,3";

console.log(arr == str);
```

- 1: false
- 2: Error
- 3: true

<details><summary><b>Answer</b></summary>
<p>

##### Answer: 3
Arrays have their own implementation of `toString` method that returns a comma-separated list of elements. So the above code snippet returns true. In order to avoid conversion of array type, we should use === for comparison.
</p>

</details>

## Disclaimer

The questions provided in this repository are the summary of frequently asked questions across numerous companies. We cannot guarantee that these questions will actually be asked during your interview process, nor should you focus on memorizing all of them. The primary purpose is for you to get a sense of what some companies might ask — do not get discouraged if you don't know the answer to all of them ⁠— that is ok!

Good luck with your interview 😊

---
