<a name="top"></a>

[На главную](../README.md)

[Перейти к вопросам](#questions)

| №. | Вопрос |
| --- | --------- |
|   | PHP-Grundlagen |
|1 | [Was ist PHP und wie funktioniert es?](#1) |
|2 | [Wie funktioniert das Client-Server-Modell mit PHP?](#2) |
|3 | [Worin unterscheidet sich PHP von JavaScript?](#3) |
|4 | [Wie wird eine HTTP-Anfrage in PHP verarbeitet?](#4) |
|5 | [Was ist eine index.php und was bedeutet das Front-Controller-Pattern?](#5) |
|   | Datentypen und Variablen |
|6 | [Welche Datentypen gibt es in PHP?](#6) |
|7 | [Was ist der Unterschied zwischen == und ===?](#7) |
|8 | [Was bedeutet null in PHP?](#8) |
|9 | [Unterschied zwischen isset() und empty()](#9) |
|10 | [Übergabe von Variablen per Wert und per Referenz (&)](#10) |
|11 | [Was bewirkt declare(strict_types=1)?](#11) |
|   | Arrays |
|12 | [Welche Arten von Arrays gibt es in PHP?](#12) |
|13 | [Was ist ein assoziatives Array?](#13) |
|14 | [Wofür werden array_map, array_filter, array_reduce verwendet?](#14) |
|15 | [Wie prüft man, ob ein Schlüssel in einem Array existiert?](#15) |
|16 | [Wie kann man Arrays sortieren?](#16) |
|   | Funktionen |
|17 | [Wie definiert man eine Funktion in PHP?](#17) |
|18 | [Was sind Standardparameter?](#18) |
|19 | [Was sind anonyme Funktionen?](#19) |
|20 | [Was sind Arrow Functions (fn)?](#20) |
|21 | [Was ist eine Callback-Funktion?](#21) |
|   | OOP – Grundlagen |
|22 | [Was ist eine Klasse und was ist ein Objekt?](#22) |
|23 | [Welche Sichtbarkeiten gibt es (public, protected, private)?](#23) |
|24 | [Was ist ein Konstruktor?](#24) |
|25 | [Wie funktioniert Vererbung (extends)?](#25) |
|26 | [Unterschied zwischen interface und abstract class](#26) |
|   | Formulare und HTTP |
|27 | [Unterschied zwischen GET und POST](#27) |
|28 | [Was sind $_GET, $_POST, $_SESSION, $_COOKIE?](#28) |
|29 | [Wie validiert man Benutzereingaben?](#29) |
|30 | [Was sind HTTP-Statuscodes (z. B. 200, 400, 401, 403, 404, 500)?](#30) |
|   | Sicherheit (Grundlagen) |
|31 | [Was ist SQL Injection?](#31) |
|32 | [Was ist XSS?](#32) |
|33 | [Wie speichert man Passwörter sicher?](#33) |
|34 | [Wozu dient htmlspecialchars()?](#34) |
|   | Fortgeschrittenes PHP |
|35 | [Wie funktioniert PHP intern (Zend Engine)?](#35) |
|36 | [Was ist OPcache und wozu dient es?](#36) |
|37 | [Unterschied zwischen require und include](#37) |
|38 | [Was ist Autoloading und was bedeutet PSR-4?](#38) |
|39 | [Was sind Namespaces und warum sind sie wichtig?](#39) |
|   | OOP – Fortgeschritten |
|40 | [Was bedeuten die SOLID-Prinzipien?](#40) |
|41 | [Was ist Dependency Injection?](#41) |
|42 | [Unterschied zwischen Komposition und Vererbung](#42) |
|43 | [Wofür werden final, static und readonly verwendet?](#43) |
|44 | [Was sind Magic Methods (__get, __set, __call)?](#44) |
|   | Exceptions und Fehler |
|45 | [Unterschied zwischen Exception und Error](#45) |
|46 | [Wie funktioniert try / catch / finally?](#46) |
|47 | [Wie erstellt man eigene Exceptions?](#47) |
|48 | [Welche Strategien für Error Handling kennst du?](#48) |
|   | Datenbank-Anbindung |
|49 | [Unterschied zwischen PDO und MySQLi](#49) |
|50 | [Was sind Prepared Statements?](#50) |
|51 | [Wie funktionieren Transaktionen?](#51) |
|52 | [Was sind Indizes und warum sind sie wichtig?](#52) |
|53 | [Was bedeutet Normalisierung einer Datenbank?](#53) |
|   | Frameworks (sehr häufig in Deutschland) |
|54 | [Wie ist das MVC-Pattern aufgebaut?](#54) |
|55 | [Was ist ein Service Container?](#55) |
|56 | [Wie funktioniert Routing?](#56) |
|57 | [Was sind Middleware bzw. Event Listener?](#57) |
|58 | [Was ist ein ORM (Doctrine / Eloquent)?](#58) |
|59 | [Was sind Migrations?](#59) |
|60 | [Wie funktioniert Validation im Framework?](#60) |
|   | Testing |
|61 | [Unterschied zwischen Unit-Tests und Integration-Tests](#61) |
|62 | [Was ist PHPUnit?](#62) |
|63 | [Was sind Mocks und Stubs?](#63) |
|64 | [Warum sind Tests im Backend wichtig?](#64) |
|   | Performance |
|65 | [Was ist das N+1-Problem?](#65) |
|66 | [Welche Caching-Strategien kennst du (Redis, APCu)?](#66) |
|67 | [Was bedeutet Lazy Loading?](#67) |
|68 | [Wo entstehen typischerweise Performance-Probleme in PHP-Anwendungen?](#68) |
|   | Sicherheit |
|69 | [Was ist CSRF und wie schützt man sich davor?](#69) |
|70 | [JWT vs. Session-basierte Authentifizierung](#70) |
|71 | [Was ist CORS und warum ist es relevant?](#71) |
|72 | [Best Practices für Authentifizierung und Autorisierung](#72) |
|   | Typische Praxis- & Soft-Skill-Fragen |
|73 | [Wie debugst du PHP-Code?](#73) |
|74 | [Wie gehst du mit Legacy-Code um?](#74) |
|75 | [Wie stellst du Code-Qualität sicher?](#75) |
|76 | [Wie dokumentierst du APIs?](#76) |
|77 | [Wie läuft Code Review in deinem Team ab?](#77) |
|78 | [](#78) |
|79 | [](#79) |
|80 | [](#80) |
|81 | [](#81) |
|82 | [](#82) |
|83 | [](#83) |
|84 | [](#84) |
|85 | [](#85) |
|86 | [](#86) |
|87 | [](#87) |
|88 | [](#88) |
|89 | [](#89) |
|90 | [](#90) |
|91 | [](#91) |
|92 | [](#92) |
|93 | [](#93) |
|94 | [](#94) |
|95 | [](#95) |
|96 | [](#96) |
|97 | [](#97) |
|98 | [](#98) |
|99 | [](#99) |
|100 | [](#100) |
|   | gfd |
|101 | [](#101) |
|102 | [](#102) |
|103 | [](#103) |
|104 | [](#104) |
|105 | [](#105) |
|106 | [](#106) |
|107 | [](#107) |
|108 | [](#108) |
|109 | [](#109) |
|110 | [](#110) |
|111 | [](#111) |
|112 | [](#112) |
|113 | [](#113) |
|114 | [](#114) |
|115 | [](#115) |
|116 | [](#116) |
|117 | [](#117) |
|118 | [](#118) |
|119 | [](#119) |
|120 | [](#120) |
|   | React...... |
|121 | [](#121) |
|122 | [](#122) |
|123 | [](#123) |
|124 | [](#124) |
|125 | [](#125) |
|126 | [](#126) |
|127 | [](#127) |
|128 | [](#128) |
|129 | [](#129) |
|130 | [](#130) |
|131 | [](#131) |
|132 | [](#132) |
|133 | [](#133) |
|134 | [](#134) |
|135 | [](#135) |
|136 | [](#136) |
|137 | [](#137) |
|138 | [](#138) |
|139 | [](#139) |
|140 | [](#140) |
|141 | [](#141) |
|142 | [](#142) |
|143 | [](#143) |
|144 | [](#144) |
|145 | [](#145) |
|146 | [](#146) |
|147 | [](#147) |
|148 | [](#148) |
|149 | [](#149) |
|150 | [](#150) |
|151 | [](#151) |
|152 | [](#152) |
|153 | [](#153) |
|154 | [](#154) |
|155 | [](#155) |
|156 | [](#156) |
|157 | [](#157) |
|158 | [](#158) |
|159 | [](#159) |
|160 | [](#160) |
|161 | [](#161) |
|162 | [](#162) |
|163 | [](#163) |
|164 | [](#164) |
|165 | [](#165) |
|166 | [](#166) |
|167 | [](#167) |
|168 | [](#168) |
|169 | [](#169) |
|170 | [](#170) |
|171 | [](#171) |
|172 | [](#172) |
|173 | [](#173) |
|174 | [](#174) |
|175 | [](#175) |
|176 | [](#176) |
|177 | [](#177) |
|178 | [](#178) |
|179 | [](#179) |
|180 | [](#180) |
|181 | [](#181) |
|182 | [](#182) |
|183 | [](#183) |
|184 | [](#184) |
|185 | [](#185) |
|186 | [](#186) |
|187 | [](#187) |
|188 | [](#188) |
|189 | [](#189) |
|190 | [](#190) |
|191 | [](#191) |
|192 | [](#192) |
|193 | [](#193) |
|194 | [](#194) |
|195 | [](#195) |
|196 | [](#196) |
|197 | [](#197) |
|198 | [](#198) |
|199 | [](#199) |
|200 | [](#200) |



<a name="questions"></a>

## PHP 

  **[⬆ Наверх](#top)**
  
1. ### <a name="1"></a> Was ist PHP und wie funktioniert es?

## Was ist PHP und wie funktioniert es?

### Definition

**PHP (Hypertext Preprocessor)** ist eine **serverseitige Skriptsprache**, die hauptsächlich zur Entwicklung von Webanwendungen verwendet wird. PHP-Code wird **auf dem Server ausgeführt** und erzeugt typischerweise **HTML, JSON oder andere HTTP-Responses**, die an den Client (Browser) gesendet werden.

Quelle:

* PHP Manual – Introduction: [https://www.php.net/manual/de/intro-whatis.php](https://www.php.net/manual/de/intro-whatis.php)

---

### Grundprinzip (Client–Server)

1. Der Client (Browser) sendet eine **HTTP-Anfrage** an den Webserver.
2. Der Webserver (z. B. Nginx/Apache) leitet die Anfrage an **PHP-FPM** weiter.
3. Der **PHP-Interpreter** führt den PHP-Code aus.
4. PHP erzeugt eine **Response** (z. B. HTML oder JSON).
5. Der Webserver sendet die Response an den Client zurück.

Der Client sieht **nur das Ergebnis**, niemals den PHP-Code.

---

### Minimalbeispiel

```php
<?php
echo "Hello World";
```

* `<?php` öffnet den PHP-Kontext
* `echo` gibt Daten an den Output-Buffer aus
* Der Output wird Teil der HTTP-Response

---

### PHP im Web-Kontext (vereinfachtes Beispiel)

```php
<?php
$name = $_GET['name'] ?? 'Gast';
echo "Hallo " . htmlspecialchars($name);
```

* Zugriff auf HTTP-Parameter über Superglobals (`$_GET`)
* Ausgabe wird serverseitig erzeugt
* `htmlspecialchars()` schützt vor XSS

---

### PHP-Ausführungsmodell

* **Request-basiert**: Jeder HTTP-Request startet einen neuen PHP-Prozess
* Kein Shared State zwischen Requests (außer Sessions, Cache, DB)
* Sehr gut geeignet für **stateless Webanwendungen**

---

### Typische Einsatzgebiete

* Backend für Webanwendungen
* REST APIs
* Server-side Rendering (SSR)
* CMS (z. B. WordPress)
* Framework-basierte Anwendungen (Symfony, Laravel)

---

### Abgrenzung zu JavaScript

| PHP                    | JavaScript               |
| ---------------------- | ------------------------ |
| Serverseitig           | Clientseitig (primär)    |
| Zugriff auf DB         | Kein direkter DB-Zugriff |
| Generiert HTML/JSON    | Manipuliert DOM          |
| Läuft vor dem Response | Läuft nach dem Response  |

---

### Zusammenfassung

* PHP ist eine **serverseitige Skriptsprache**
* Wird **pro HTTP-Request** ausgeführt
* Erzeugt HTML/JSON für den Client
* PHP-Code ist **nicht im Browser sichtbar**
* Zentrale Rolle im klassischen Web-Backend

---

### Typische Interview-Fallen

* „PHP läuft im Browser“ ❌
* „PHP ist stateful“ ❌
* HTTP-Response ≠ PHP-Ausgabe verwechseln
* PHP mit JavaScript vergleichen ohne Client/Server-Trennung

---

### Mini-Check

* Wo wird PHP-Code ausgeführt?
* Sieht der Browser PHP-Code?
* Warum ist PHP gut für REST APIs geeignet?

---

**Weiterführende Doku:**

* [https://www.php.net/manual/de/features.commandline.webserver.php](https://www.php.net/manual/de/features.commandline.webserver.php)

  **[⬆ Наверх](#top)**

2. ### <a name="2"></a> Wie funktioniert das Client-Server-Modell mit PHP?

## Wie funktioniert das Client-Server-Modell mit PHP?

### Grundidee

PHP arbeitet im **klassischen Client-Server-Modell**.
Der **Client** (z. B. Browser) sendet eine HTTP-Anfrage, der **Server** verarbeitet sie und sendet eine HTTP-Antwort zurück.
PHP läuft **ausschließlich auf dem Server**.

---

### Ablauf Schritt für Schritt

1. **Client → HTTP-Request**

   * Browser ruft eine URL auf (z. B. `GET /users?id=5`).

2. **Webserver (Apache/Nginx)**

   * Empfängt die Anfrage.
   * Leitet PHP-Dateien an **PHP-FPM** (FastCGI Process Manager) weiter.

3. **PHP-Interpreter**

   * Führt den PHP-Code aus.
   * Greift ggf. auf:

     * Datenbank
     * Cache (Redis)
     * Dateien
     * Session-Daten
   * Erzeugt Output (HTML, JSON, XML).

4. **HTTP-Response**

   * PHP gibt den Output an den Webserver zurück.
   * Der Webserver sendet die Response an den Client.

5. **Client**

   * Rendert HTML oder verarbeitet JSON (z. B. via JavaScript).

---

### Vereinfachtes Schema

```
Browser
  ↓ HTTP Request
Webserver (Nginx / Apache)
  ↓ FastCGI
PHP-FPM
  ↓
PHP Code → DB / Cache
  ↓
HTML / JSON
  ↑
Webserver
  ↑ HTTP Response
Browser
```

---

### Beispiel: HTTP-Request → PHP → Response

```php
<?php
// request.php

$userId = $_GET['id'] ?? null;

if ($userId === null) {
    http_response_code(400);
    echo json_encode(['error' => 'Missing id']);
    exit;
}

echo json_encode([
    'id' => (int) $userId,
    'name' => 'Max Mustermann'
]);
```

* PHP liest Request-Daten über Superglobals
* Logik läuft **serverseitig**
* Ergebnis ist eine **HTTP-Response**

---

### Wichtiges Architekturprinzip

* **Request-basiert & stateless**
* Jeder HTTP-Request:

  * startet eine neue PHP-Ausführung
  * kennt keinen vorherigen Zustand
* Persistenz nur über:

  * Datenbank
  * Sessions
  * Cache (Redis, Memcached)

---

### Rolle von PHP im modernen Stack

* PHP = **Backend**
* JavaScript = **Frontend**
* Kommunikation meist über **REST APIs (JSON)**

Beispiel:

* Frontend: React / Vue
* Backend: PHP (Symfony/Laravel)
* Transport: HTTP + JSON

---

### Zusammenfassung

* PHP ist Teil des **Server-Bereichs** im Client-Server-Modell
* Der Client sendet HTTP-Requests
* PHP verarbeitet die Anfrage serverseitig
* Der Client erhält nur die fertige Response
* PHP-Anwendungen sind **request-basiert und stateless**

---

**Weiterführende Doku:**

* PHP Manual – Webserver-Integration:
  [https://www.php.net/manual/en/install.fpm.php](https://www.php.net/manual/en/install.fpm.php)

  **[⬆ Наверх](#top)**

3. ### <a name="3"></a> Worin unterscheidet sich PHP von JavaScript?

## Worin unterscheidet sich PHP von JavaScript?

### Grundlegender Unterschied

Der zentrale Unterschied liegt im **Ausführungsort**:

* **PHP** läuft **serverseitig**
* **JavaScript** läuft **clientseitig** (primär im Browser)

---

### Ausführungsumgebung

| Aspekt           | PHP                                | JavaScript                  |
| ---------------- | ---------------------------------- | --------------------------- |
| Ausführung       | Server                             | Browser (oder Node.js)      |
| Sichtbarkeit     | Code nicht sichtbar für den Client | Code sichtbar im Browser    |
| Zugriff auf DB   | Direkt möglich                     | Nicht direkt möglich        |
| Typischer Output | HTML, JSON                         | DOM-Manipulation, API-Calls |

---

### Rolle im Web-Stack

**PHP**

* Backend-Logik
* Datenbankzugriffe
* Authentifizierung
* Business-Logik
* API-Endpunkte

**JavaScript**

* Benutzerinteraktion
* Dynamische UI
* Formular-Validierung (clientseitig)
* API-Kommunikation (Fetch/Axios)

---

### Beispiel: gleiche Aufgabe, unterschiedliche Rolle

**PHP (Backend – serverseitig)**

```php
<?php
// Liefert JSON-Daten
echo json_encode([
    'status' => 'ok',
    'time' => date('Y-m-d H:i:s')
]);
```

**JavaScript (Frontend – clientseitig)**

```javascript
fetch('/api/status.php')
  .then(response => response.json())
  .then(data => console.log(data));
```

* PHP erzeugt die Daten
* JavaScript konsumiert die Daten

---

### State & Lebenszyklus

* **PHP**

  * Request-basiert
  * Jeder Request = neue Ausführung
  * Kein persistenter Speicher im Prozess

* **JavaScript (Browser)**

  * Lebt so lange wie die Seite offen ist
  * Kann State im Speicher halten
  * Reagiert auf Events (Click, Input)

---

### Typisierung

* **PHP**

  * Dynamisch typisiert
  * Optionale strikte Typen (`strict_types`)
  * Stark im Backend validierbar

* **JavaScript**

  * Dynamisch typisiert
  * Schwächeres Typensystem
  * TypeScript als Erweiterung

---

### Typische Einsatzszenarien

**PHP**

* REST APIs
* CMS (WordPress, TYPO3)
* Backend mit Symfony/Laravel

**JavaScript**

* SPAs (React, Vue)
* Client-seitige Logik
* Echtzeit-Interaktionen

---

### Zusammenfassung

* PHP und JavaScript lösen **unterschiedliche Aufgaben**
* PHP = **Server / Backend**
* JavaScript = **Client / UI**
* Beide arbeiten meist **zusammen**, nicht gegeneinander
* Kommunikation erfolgt über **HTTP (JSON)**

**Weiterführende Doku:**

* PHP: [https://www.php.net/manual/en/intro-whatis.php](https://www.php.net/manual/en/intro-whatis.php)
* JavaScript (MDN): [https://developer.mozilla.org/en-US/docs/Web/JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript)

  **[⬆ Наверх](#top)**

4. ### <a name="4"></a> Wie wird eine HTTP-Anfrage in PHP verarbeitet?

## Wie wird eine HTTP-Anfrage in PHP verarbeitet?

### Überblick

Eine HTTP-Anfrage wird in PHP **request-basiert** verarbeitet.
Jeder Request durchläuft denselben Ablauf: **Client → Webserver → PHP → Response**.

---

### Ablauf im Detail

#### 1. Client sendet HTTP-Anfrage

Beispiel:

```
GET /users?id=10 HTTP/1.1
Host: example.com
```

Die Anfrage enthält:

* HTTP-Methode (GET, POST, …)
* URL + Query-Parameter
* Header (z. B. `Content-Type`, `Authorization`)
* optional: Body (bei POST/PUT)

---

#### 2. Webserver empfängt die Anfrage

* Apache oder Nginx prüft die URL
* PHP-Dateien werden an **PHP-FPM** (FastCGI) weitergeleitet
* Statische Dateien (CSS, JS, Images) werden direkt ausgeliefert

---

#### 3. PHP initialisiert den Request-Kontext

PHP stellt Request-Daten über **Superglobals** bereit:

```php
$_GET;        // Query-Parameter
$_POST;       // POST-Daten
$_SERVER;     // Request-Metadaten
$_COOKIE;     // Cookies
$_FILES;      // Uploads
$_SESSION;    // Session-Daten
```

Beispiel:

```php
<?php
$id = $_GET['id'] ?? null;
```

---

#### 4. Applikationslogik wird ausgeführt

* Validierung der Eingaben
* Business-Logik
* Zugriff auf Datenbank / Cache
* Aufbau der Response-Daten

Beispiel:

```php
<?php
if ($id === null) {
    http_response_code(400);
    echo json_encode(['error' => 'Missing id']);
    exit;
}
```

---

#### 5. PHP erzeugt die HTTP-Response

* Setzen von Statuscodes
* Setzen von Headern
* Ausgabe des Response-Bodys

```php
<?php
header('Content-Type: application/json');
http_response_code(200);

echo json_encode([
    'id' => (int) $id,
    'name' => 'Max Mustermann'
]);
```

---

#### 6. Webserver sendet Response an den Client

Beispiel:

```
HTTP/1.1 200 OK
Content-Type: application/json

{"id":10,"name":"Max Mustermann"}
```

Der Client verarbeitet:

* HTML → Rendern
* JSON → JavaScript-Logik

---

### Besonderheit: Request-basierte Ausführung

* Jeder HTTP-Request startet **eine neue PHP-Ausführung**
* Kein Shared Memory zwischen Requests
* Persistenz nur über:

  * Datenbank
  * Session
  * Cache (z. B. Redis)

---

### Moderne PHP-Anwendungen

In Frameworks (Symfony / Laravel):

* **Front Controller** (`index.php`)
* Routing entscheidet, welcher Controller den Request verarbeitet
* Response wird über Response-Objekte erzeugt

---

### Zusammenfassung

* HTTP-Anfragen werden **über den Webserver an PHP weitergeleitet**
* PHP liest Request-Daten aus Superglobals
* Business-Logik läuft serverseitig
* PHP erzeugt Statuscode, Header und Body
* Jede Anfrage ist **isoliert und stateless**

---

**Weiterführende Doku:**

* PHP Superglobals: [https://www.php.net/manual/en/language.variables.superglobals.php](https://www.php.net/manual/en/language.variables.superglobals.php)
* PHP-FPM: [https://www.php.net/manual/en/install.fpm.php](https://www.php.net/manual/en/install.fpm.php)


  **[⬆ Наверх](#top)**

5. ### <a name="5"></a> Was ist eine index.php und was bedeutet das Front-Controller-Pattern?

## Was ist eine `index.php` und was bedeutet das Front-Controller-Pattern?

### `index.php`

Die `index.php` ist der **zentrale Einstiegspunkt** einer PHP-Webanwendung.
Alle HTTP-Anfragen werden (direkt oder per Rewrite) an diese Datei weitergeleitet und **von dort aus gesteuert**.

Typische Aufgaben der `index.php`:

* Initialisierung der Anwendung
* Laden des Autoloaders (Composer)
* Erstellen des Request-Objekts
* Weiterleitung an Router/Controller
* Senden der Response

Minimalbeispiel:

```php
<?php
require __DIR__ . '/../vendor/autoload.php';

// einfache Ausgabe
echo 'Hello World';
```

---

### Front-Controller-Pattern

Das **Front-Controller-Pattern** besagt:

> Es gibt **einen zentralen Controller**, der **alle Requests** entgegennimmt und entscheidet, **welche Logik** ausgeführt wird.

**Ziel:**

* Zentrale Kontrolle des Request-Flows
* Einheitliche Behandlung von:

  * Routing
  * Security
  * Error Handling
  * Logging

---

### Typischer Ablauf mit Front Controller

1. Client sendet HTTP-Request
2. Webserver leitet **jede Anfrage** an `index.php` weiter
3. `index.php`:

   * bootstrapped die App
   * ruft Router auf
4. Router bestimmt passenden Controller
5. Controller erzeugt Response
6. Response wird an den Client gesendet

---

### Beispiel: Sehr vereinfachter Front Controller

```php
<?php
// public/index.php

require __DIR__ . '/../vendor/autoload.php';

$path = $_SERVER['REQUEST_URI'];

if ($path === '/users') {
    echo 'User list';
} elseif ($path === '/login') {
    echo 'Login page';
} else {
    http_response_code(404);
    echo 'Not Found';
}
```

---

### Umsetzung in Frameworks

#### Symfony

* **Front Controller:** `public/index.php`
* Routing, Controller, Middleware laufen zentral darüber

```php
// public/index.php (Symfony, stark vereinfacht)
$kernel = new Kernel($_SERVER['APP_ENV'], (bool) $_SERVER['APP_DEBUG']);
$request = Request::createFromGlobals();
$response = $kernel->handle($request);
$response->send();
```

Quelle:
[https://symfony.com/doc/current/introduction/from_flat_php_to_symfony.html](https://symfony.com/doc/current/introduction/from_flat_php_to_symfony.html)

---

#### Laravel

* **Front Controller:** `public/index.php`
* Alle Requests gehen durch den HTTP Kernel

```php
$app = require_once __DIR__.'/../bootstrap/app.php';

$kernel = $app->make(Illuminate\Contracts\Http\Kernel::class);
$response = $kernel->handle(
    $request = Illuminate\Http\Request::capture()
);
$response->send();
```

Quelle:
[https://laravel.com/docs/requests](https://laravel.com/docs/requests)

---

### Vorteile des Front-Controller-Patterns

* Einheitlicher Einstiegspunkt
* Saubere Trennung von Routing und Business-Logik
* Zentrale Security (Auth, CSRF, Middleware)
* Gute Testbarkeit
* Standard in modernen PHP-Frameworks

---

### Abgrenzung: Kein Front Controller

Ohne Front Controller:

* Jede URL zeigt auf eine eigene PHP-Datei
* Duplizierter Code (Auth, DB, Includes)
* Schwer wartbar und schlecht skalierbar

---

### Zusammenfassung

* `index.php` ist der **zentrale Einstiegspunkt** einer PHP-Anwendung
* Das Front-Controller-Pattern leitet **alle Requests** über diese Datei
* Routing und Controller-Logik werden zentral gesteuert
* Symfony und Laravel basieren vollständig auf diesem Pattern

**Weiterführende Doku:**

* PHP Manual – Built-in Web Server & Routing:
  [https://www.php.net/manual/en/features.commandline.webserver.php](https://www.php.net/manual/en/features.commandline.webserver.php)
* Front Controller Pattern (Symfony):
  [https://symfony.com/doc/current/introduction/from_flat_php_to_symfony.html](https://symfony.com/doc/current/introduction/from_flat_php_to_symfony.html)

  **[⬆ Наверх](#top)**

6. ### <a name="6"></a> Welche Datentypen gibt es in PHP?

## Welche Datentypen gibt es in PHP?

PHP ist **dynamisch typisiert** und kennt **skalare**, **zusammengesetzte** sowie **spezielle** Datentypen.

---

### Skalare Datentypen

#### `int` (Integer)

Ganze Zahlen.

```php
$age = 30;
```

* Plattformabhängig (meist 64-bit)
* Keine Dezimalstellen

---

#### `float` (Double)

Gleitkommazahlen.

```php
$price = 19.99;
```

* Achtung bei Rundungsfehlern (Floating-Point-Arithmetik)

---

#### `string`

Zeichenketten.

```php
$name = "Max";
```

* Single Quotes: keine Variablen-Interpolation
* Double Quotes: Variablen werden ersetzt

---

#### `bool`

Wahrheitswerte.

```php
$isActive = true;
```

* `true` oder `false`

---

### Zusammengesetzte Datentypen

#### `array`

Sammlung von Werten (indexiert oder assoziativ).

```php
$numbers = [1, 2, 3];

$user = [
    'id' => 1,
    'name' => 'Anna'
];
```

* Sehr zentral in PHP
* Arrays sind **ordered maps**

---

#### `object`

Instanz einer Klasse.

```php
class User {
    public string $name;
}

$user = new User();
$user->name = 'Anna';
```

* Grundlage für OOP in PHP

---

### Spezielle Datentypen

#### `null`

Variable ohne Wert.

```php
$value = null;
```

* Bedeutet: bewusst **kein Wert**
* Unterschiedlich zu `0`, `""` oder `false`

---

#### `resource`

Verweis auf externe Ressourcen.

```php
$file = fopen('file.txt', 'r');
```

* Wird intern von PHP verwaltet
* Kein direkter Zugriff auf den Inhalt

---

### Callable & Iterable (konzeptionelle Typen)

#### `callable`

Alles, was aufrufbar ist.

```php
$fn = function () {
    return 'Hello';
};
```

---

#### `iterable`

Alles, was durchlaufen werden kann (`array`, `Traversable`).

```php
function process(iterable $items) {
    foreach ($items as $item) {}
}
```

---

### Typisierung in PHP (ab PHP 7+)

* Dynamisch, aber **optional streng**
* Typdeklarationen möglich:

```php
function add(int $a, int $b): int {
    return $a + $b;
}
```

```php
declare(strict_types=1);
```

---

### Zusammenfassung

* PHP kennt **skalare**, **zusammengesetzte** und **spezielle** Datentypen
* Typen werden **zur Laufzeit** bestimmt
* Strikte Typisierung ist optional
* Arrays und Objects sind zentrale Bausteine
* `null` ist ein eigener, bedeutender Typ

**Weiterführende Doku:**

* PHP Datentypen:
  [https://www.php.net/manual/en/language.types.php](https://www.php.net/manual/en/language.types.php)

  **[⬆ Наверх](#top)**

7. ### <a name="7"></a> Was ist der Unterschied zwischen == und ===?

## Was ist der Unterschied zwischen `==` und `===`?

### Grundidee

Der Unterschied liegt in der **Typprüfung**:

* `==` → **Wertvergleich** (mit Typumwandlung)
* `===` → **Wert- und Typvergleich** (ohne Typumwandlung)

---

### `==` (lockerer Vergleich)

PHP führt bei `==` eine **automatische Typkonvertierung** durch, bevor verglichen wird.

```php
var_dump(0 == '0');        // true
var_dump(0 == false);     // true
var_dump('123' == 123);   // true
var_dump(null == false);  // true
```

PHP versucht, beide Operanden in einen **gemeinsamen Typ** umzuwandeln.

---

### `===` (strikter Vergleich)

Bei `===` müssen **Wert und Datentyp identisch** sein.

```php
var_dump(0 === '0');        // false
var_dump(0 === false);     // false
var_dump('123' === 123);   // false
var_dump(null === false);  // false
```

Keine Typumwandlung findet statt.

---

### Vergleich von Objekten

```php
$a = new stdClass();
$b = new stdClass();

var_dump($a == $b);   // true (gleiche Properties)
var_dump($a === $b);  // false (nicht dieselbe Instanz)
```

* `==` vergleicht Struktur/Werte
* `===` vergleicht Identität (gleiche Instanz)

---

### Best Practice

* **Fast immer `===` verwenden**
* Vermeidet unerwartetes Verhalten durch Type Juggling
* Besonders wichtig bei:

  * `null`-Checks
  * `false`-Rückgabewerten
  * Sicherheitsrelevanter Logik

Beispiel:

```php
if ($userId === null) {
    // korrekt
}
```

---

### Zusammenhang mit `strict_types`

`declare(strict_types=1)` beeinflusst:

* Funktionsargumente
* Rückgabewerte

**Nicht** den Vergleichsoperator (`==` / `===`).

---

### Zusammenfassung

* `==` vergleicht nur den **Wert** (mit Typkonvertierung)
* `===` vergleicht **Wert und Typ**
* `===` ist vorhersehbar und sicherer
* In modernen PHP-Projekten ist `===` der Standard

**Weiterführende Doku:**

* PHP Vergleichsoperatoren:
  [https://www.php.net/manual/en/language.operators.comparison.php](https://www.php.net/manual/en/language.operators.comparison.php)

  **[⬆ Наверх](#top)**

8. ### <a name="8"></a> Was bedeutet null in PHP?

## Was bedeutet `null` in PHP?

### Bedeutung

`null` ist ein **eigener Datentyp** in PHP und bedeutet:

> Eine Variable hat **bewusst keinen Wert**.

`null` ist **nicht** gleich `0`, `false` oder `""` (leerer String).

---

### Zuweisung von `null`

```php
$value = null;
```

Oder implizit:

* Variable wurde **nie gesetzt**
* Variable wurde mit `unset()` entfernt

```php
unset($value);
```

---

### Typische Anwendungsfälle

* Optionaler Wert (noch nicht gesetzt)
* Fehlender Datenbankwert
* Ergebnis „nicht vorhanden“
* Initialisierung vor späterer Zuweisung

---

### `null` vs andere „leere“ Werte

```php
var_dump(null == false);   // true
var_dump(null === false);  // false

var_dump(null == 0);       // true
var_dump(null === 0);      // false

var_dump(null == '');      // true
var_dump(null === '');     // false
```

→ **Strikter Vergleich (`===`) ist entscheidend**.

---

### Prüfung auf `null`

#### Strikter Vergleich (empfohlen)

```php
if ($value === null) {
    // Wert ist null
}
```

---

#### `is_null()`

```php
if (is_null($value)) {
    // identisch zu === null
}
```

---

#### `isset()`

Prüft, ob eine Variable **existiert und nicht null ist**.

```php
$value = null;

isset($value); // false
```

---

#### `empty()`

Prüft auf „leer“ (sehr breit).

```php
empty(null);   // true
empty(false);  // true
empty(0);      // true
empty('');     // true
```

→ Für präzise Logik **ungeeignet**.

---

### `null` in Funktionen und Typen

```php
function findUser(): ?User {
    return null; // erlaubt
}
```

* `?Type` bedeutet: `Type` **oder** `null`
* Häufig bei Repositories / Services

---

### `null` in Datenbanken

* Entspricht SQL `NULL`
* Bedeutet: kein Wert gespeichert

```sql
SELECT * FROM users WHERE deleted_at IS NULL;
```

---

### Zusammenfassung

* `null` bedeutet: **kein Wert**
* Eigener Datentyp in PHP
* Nicht gleich `false`, `0` oder `""`
* Immer mit `=== null` prüfen
* Sehr häufig bei optionalen Werten und DB-Ergebnissen

**Weiterführende Doku:**

* PHP `null`-Typ:
  [https://www.php.net/manual/en/language.types.null.php](https://www.php.net/manual/en/language.types.null.php)

  **[⬆ Наверх](#top)**

9. ### <a name="9"></a> Unterschied zwischen isset() und empty()

## Unterschied zwischen `isset()` und `empty()`

### Grundidee

Beide Funktionen prüfen Variablen, aber mit **unterschiedlicher Bedeutung**:

* `isset()` → prüft **Existenz und nicht `null`**
* `empty()` → prüft, ob ein Wert als **„leer“** gilt

---

### `isset()`

```php
$value = null;

isset($value); // false
```

**Bedeutung:**

* Gibt `true` zurück, wenn:

  * die Variable **existiert**
  * und **nicht `null`** ist

```php
$value = 0;
isset($value); // true
```

**Eigenschaften:**

* Sehr präzise
* Keine Typumwandlung
* Sicher für Existenzprüfungen

---

### `empty()`

```php
$value = 0;

empty($value); // true
```

**Bedeutung:**

* Gibt `true` zurück, wenn der Wert als **leer** interpretiert wird

Als „leer“ gelten u. a.:

* `null`
* `false`
* `0`, `0.0`
* `""`
* `"0"`
* `[]`

---

### Direkter Vergleich

| Wert            | `isset()` | `empty()` |
| --------------- | --------- | --------- |
| `null`          | false     | true      |
| `false`         | true      | true      |
| `0`             | true      | true      |
| `""`            | true      | true      |
| `"0"`           | true      | true      |
| `[]`            | true      | true      |
| nicht definiert | false     | true      |

---

### Typische Verwendung

**`isset()`**

* Prüfen, ob ein Wert gesetzt wurde
* Optional-Parameter
* Vor Zugriff auf Arrays / Objekte

```php
if (isset($_GET['id'])) {
    $id = $_GET['id'];
}
```

---

**`empty()`**

* Formularvalidierung („Wert fehlt“)
* Benutzer-Eingaben

```php
if (empty($_POST['email'])) {
    echo 'E-Mail ist erforderlich';
}
```

---

### Wichtige Besonderheit

`empty()` erzeugt **keine Notice**, auch wenn die Variable nicht existiert.

```php
empty($foo); // kein Fehler
```

---

### Zusammenfassung

* `isset()` prüft: **existiert und nicht `null`**
* `empty()` prüft: **„leer“ nach PHP-Regeln**
* `empty()` ist breit und unscharf
* Für präzise Logik → `isset()` oder `=== null`
* Für einfache Pflichtfeld-Checks → `empty()`

**Weiterführende Doku:**

* `isset()`: [https://www.php.net/manual/en/function.isset.php](https://www.php.net/manual/en/function.isset.php)
* `empty()`: [https://www.php.net/manual/en/function.empty.php](https://www.php.net/manual/en/function.empty.php)

  **[⬆ Наверх](#top)**

10. ### <a name="10"></a> Übergabe von Variablen per Wert und per Referenz (&)

## Übergabe von Variablen per Wert und per Referenz (`&`)

### Grundidee

In PHP können Variablen **per Wert** oder **per Referenz** an Funktionen übergeben werden.

* **Per Wert** → Funktion erhält eine **Kopie** des Werts
* **Per Referenz (`&`)** → Funktion arbeitet mit der **Originalvariable**

---

### Übergabe **per Wert** (Standard)

```php
function increment(int $value): void {
    $value++;
}

$number = 5;
increment($number);

echo $number; // 5
```

* `$value` ist eine Kopie
* Änderungen haben **keinen Effekt** außerhalb der Funktion

---

### Übergabe **per Referenz** (`&`)

```php
function increment(int &$value): void {
    $value++;
}

$number = 5;
increment($number);

echo $number; // 6
```

* `$value` verweist auf `$number`
* Änderung wirkt sich **direkt auf die Originalvariable** aus

---

### Referenzen bei Arrays

```php
function addItem(array &$items): void {
    $items[] = 'new';
}

$list = ['a', 'b'];
addItem($list);

print_r($list);
// ['a', 'b', 'new']
```

---

### Rückgabe per Referenz (selten, meist vermeiden)

```php
function &getValue(): int {
    static $value = 10;
    return $value;
}

$ref = &getValue();
$ref = 20;
```

* Schwer zu lesen
* Kann unerwartete Seiteneffekte erzeugen

---

### Performance-Hinweis

* PHP nutzt **Copy-on-Write**
* Arrays/Objekte werden **nicht sofort kopiert**
* Referenzen bringen **meist keinen Performance-Vorteil**
* Klarheit > Mikro-Optimierung

---

### Referenzen bei Objekten

Objekte werden in PHP **immer als Referenz** behandelt.

```php
class User {
    public string $name;
}

$user1 = new User();
$user2 = $user1;

$user2->name = 'Anna';

echo $user1->name; // Anna
```

* Kein `&` notwendig
* Beide Variablen zeigen auf **dieselbe Objektinstanz**

---

### Wann Referenzen sinnvoll sind

* Funktionen sollen mehrere Werte verändern
* Große Arrays gezielt modifizieren
* API-Design explizit darauf ausgelegt

---

### Wann vermeiden

* Unklare Seiteneffekte
* Schwer testbarer Code
* Versteckte Abhängigkeiten

---

### Zusammenfassung

* Standard: Übergabe **per Wert**
* `&` ermöglicht direkte Änderung der Originalvariable
* Objekte sind implizit referenziert
* Copy-on-Write macht Referenzen selten nötig
* Referenzen sparsam und bewusst einsetzen

**Weiterführende Doku:**

* PHP Referenzen:
  [https://www.php.net/manual/en/language.references.php](https://www.php.net/manual/en/language.references.php)

  **[⬆ Наверх](#top)**

11. ### <a name="11"></a> Was bewirkt declare(strict_types=1)?

## Was bewirkt `declare(strict_types=1)`?

### Grundidee

`declare(strict_types=1)` aktiviert **strikte Typprüfung** für **Funktionsparameter und Rückgabewerte** in einer PHP-Datei.

Ohne `strict_types` führt PHP **implizite Typumwandlungen** durch (Type Juggling).

---

### Gültigkeitsbereich

* Wirkt **nur pro Datei**
* Muss **ganz am Anfang** der Datei stehen
* Beeinflusst **nur skalare Typen** (`int`, `float`, `string`, `bool`)

```php
<?php
declare(strict_types=1);
```

---

### Verhalten ohne `strict_types`

```php
function add(int $a, int $b): int {
    return $a + $b;
}

echo add('5', '10'); // 15
```

* Strings werden automatisch zu `int` konvertiert
* Kein Fehler

---

### Verhalten mit `strict_types=1`

```php
<?php
declare(strict_types=1);

function add(int $a, int $b): int {
    return $a + $b;
}

echo add('5', '10'); // TypeError
```

* Keine automatische Typkonvertierung
* PHP wirft einen `TypeError`

---

### Rückgabewerte

```php
<?php
declare(strict_types=1);

function getCount(): int {
    return '5'; // TypeError
}
```

* Rückgabewert muss exakt dem Typ entsprechen

---

### Was `strict_types` **nicht** beeinflusst

* Vergleichsoperatoren (`==`, `===`)
* Interne PHP-Funktionen
* Property-Typen außerhalb von Funktionssignaturen
* Arrays und Objekte

---

### Typische Verwendung

* Moderne PHP-Projekte
* Symfony / Laravel Code
* Erhöht Code-Qualität und Vorhersehbarkeit
* Verhindert versteckte Bugs

---

### Best Practice

```php
<?php
declare(strict_types=1);

// immer an oberster Stelle
```

* Einheitlich in allen Projektdateien verwenden
* Besonders wichtig in Domain- und Service-Layern

---

### Zusammenfassung

* Erzwingt **strikte Typprüfung**
* Gilt nur für **Funktionen und Rückgabewerte**
* Verhindert implizite Typumwandlung
* Reduziert Laufzeitfehler
* Empfohlen für professionelle PHP-Projekte

**Weiterführende Doku:**

* PHP Strict Types:
  [https://www.php.net/manual/en/functions.arguments.php#functions.arguments.type-declaration.strict](https://www.php.net/manual/en/functions.arguments.php#functions.arguments.type-declaration.strict)

  **[⬆ Наверх](#top)**

12. ### <a name="12"></a> Welche Arten von Arrays gibt es in PHP?

## Welche Arten von Arrays gibt es in PHP?

### Überblick

PHP kennt **nur einen Array-Typ**, der intern als **geordnetes Hash-Map** implementiert ist.
Je nach Nutzung unterscheidet man **konzeptionell** mehrere Arten von Arrays.

---

### 1. Indexierte Arrays

Arrays mit **numerischen Schlüsseln** (beginnend bei `0`).

```php
$colors = ['red', 'green', 'blue'];

echo $colors[0]; // red
```

* Schlüssel werden automatisch vergeben
* Reihenfolge bleibt erhalten

---

### 2. Assoziative Arrays

Arrays mit **benannten (string) Schlüsseln**.

```php
$user = [
    'id' => 1,
    'name' => 'Anna',
    'email' => 'anna@example.com'
];

echo $user['name']; // Anna
```

* Sehr häufig für:

  * Konfigurationsdaten
  * Request-/Response-Daten
  * DTO-ähnliche Strukturen

---

### 3. Gemischte Arrays

Kombination aus **numerischen und string Keys**.

```php
$data = [
    'status' => 'ok',
    0 => 'first',
    1 => 'second'
];
```

* Technisch erlaubt
* In sauberem Code meist **vermeiden**
* Erschwert Lesbarkeit und Wartung

---

### 4. Mehrdimensionale Arrays

Arrays, die **Arrays enthalten**.

```php
$users = [
    [
        'id' => 1,
        'name' => 'Anna'
    ],
    [
        'id' => 2,
        'name' => 'Max'
    ]
];

echo $users[0]['name']; // Anna
```

* Typisch für:

  * Datenbank-Resultsets
  * JSON-Strukturen
  * API-Antworten

---

### 5. Arrays als Maps / Sets (konzeptionell)

#### Map (Key → Value)

```php
$prices = [
    'apple' => 1.2,
    'banana' => 0.8
];
```

#### Set (nur Schlüssel relevant)

```php
$set = [
    'read' => true,
    'write' => true
];
```

* PHP hat keine eigenen `Map`/`Set`-Typen
* Wird über Arrays abgebildet

---

### 6. Spezialfall: Arrays vs. Objekte

Arrays werden oft dort eingesetzt, wo in anderen Sprachen Objekte genutzt würden.

```php
$response = [
    'success' => true,
    'data' => []
];
```

In modernen Anwendungen:

* **Arrays** → Transport / Daten
* **Objekte** → Logik / Domain

---

### Zusammenfassung

* PHP hat **einen Array-Typ**, aber mehrere **konzeptionelle Formen**
* Wichtigste Arten:

  * Indexierte Arrays
  * Assoziative Arrays
  * Mehrdimensionale Arrays
* Arrays sind **geordnet**, flexibel und sehr mächtig
* Für Business-Logik sind Objekte meist besser geeignet

**Weiterführende Doku:**

* PHP Arrays:
  [https://www.php.net/manual/en/language.types.array.php](https://www.php.net/manual/en/language.types.array.php)

  **[⬆ Наверх](#top)**

13. ### <a name="13"></a> Was ist ein assoziatives Array?

## Was ist ein assoziatives Array?

### Definition

Ein **assoziatives Array** ist ein Array, bei dem die Elemente **über benannte Schlüssel (Strings)** statt über numerische Indizes angesprochen werden.

In PHP sind assoziative Arrays die häufigste Form von Arrays.

---

### Grundbeispiel

```php
$user = [
    'id' => 1,
    'name' => 'Anna',
    'email' => 'anna@example.com'
];

echo $user['name']; // Anna
```

* Schlüssel (`'name'`) → Wert (`'Anna'`)
* Reihenfolge bleibt erhalten

---

### Typische Anwendungsfälle

* Konfigurationsdaten
* HTTP-Request- und Response-Daten
* Datenbank-Ergebnisse
* JSON-Strukturen
* Übergabe strukturierter Daten zwischen Layern

---

### Zugriff und Prüfung

```php
if (isset($user['email'])) {
    echo $user['email'];
}
```

* Zugriff über Schlüssel
* `isset()` zur sicheren Prüfung

---

### Iteration

```php
foreach ($user as $key => $value) {
    echo $key . ': ' . $value;
}
```

* Schlüssel und Wert sind verfügbar
* Sehr gut für dynamische Datenstrukturen

---

### Kombination mit verschachtelten Arrays

```php
$order = [
    'id' => 1001,
    'customer' => [
        'name' => 'Max',
        'country' => 'DE'
    ]
];

echo $order['customer']['country']; // DE
```

---

### Assoziative Arrays vs. Objekte

```php
// Array
$userArray = ['name' => 'Anna'];

// Objekt
class User {
    public string $name;
}
$userObject = new User();
$userObject->name = 'Anna';
```

**Faustregel:**

* Arrays → Datentransport
* Objekte → Business-Logik

---

### Zusammenfassung

* Assoziative Arrays nutzen **String-Schlüssel**
* Elemente werden über Schlüssel angesprochen
* Sehr flexibel und weit verbreitet in PHP
* Ideal für strukturierte Daten
* Für komplexe Logik sind Objekte besser geeignet

**Weiterführende Doku:**

* PHP Assoziative Arrays:
  [https://www.php.net/manual/en/language.types.array.php](https://www.php.net/manual/en/language.types.array.php)

  **[⬆ Наверх](#top)**

14. ### <a name="14"></a> Wofür werden array_map, array_filter, array_reduce verwendet?

## Wofür werden `array_map`, `array_filter`, `array_reduce` verwendet?

Diese drei Funktionen dienen der **funktionalen Verarbeitung von Arrays**.
Sie sind sehr verbreitet in modernem PHP-Code (lesbarer, weniger `foreach`-Boilerplate).

---

## `array_map()` – Elemente **transformieren**

**Zweck:**
Wendet eine Funktion auf **jedes Element** eines Arrays an und gibt ein **neues Array** zurück.

```php
$numbers = [1, 2, 3];

$squared = array_map(fn ($n) => $n * $n, $numbers);

// [1, 4, 9]
```

**Eigenschaften:**

* Anzahl der Elemente bleibt gleich
* Originalarray wird nicht verändert
* Ideal für Daten-Transformationen

---

## `array_filter()` – Elemente **filtern**

**Zweck:**
Entfernt Elemente, die eine Bedingung **nicht erfüllen**.

```php
$numbers = [1, 2, 3, 4, 5];

$even = array_filter($numbers, fn ($n) => $n % 2 === 0);

// [2, 4]
```

**Eigenschaften:**

* Gibt nur Elemente zurück, die `true` liefern
* Schlüssel bleiben erhalten (wichtig!)

```php
array_values($even); // optional: neu indizieren
```

---

## `array_reduce()` – Array **aggregieren**

**Zweck:**
Reduziert ein Array auf **einen einzigen Wert**.

```php
$numbers = [1, 2, 3, 4];

$sum = array_reduce(
    $numbers,
    fn ($carry, $item) => $carry + $item,
    0
);

// 10
```

**Typische Anwendungsfälle:**

* Summen
* Zähler
* Aufbau komplexer Strukturen

---

## Vergleich auf einen Blick

| Funktion       | Zweck          | Ergebnis        |
| -------------- | -------------- | --------------- |
| `array_map`    | Transformieren | Neues Array     |
| `array_filter` | Filtern        | Kleineres Array |
| `array_reduce` | Aggregieren    | Einzelwert      |

---

## Praxisbeispiel (realistisch)

```php
$users = [
    ['name' => 'Anna', 'active' => true],
    ['name' => 'Max', 'active' => false],
];

// 1. Nur aktive User
$activeUsers = array_filter(
    $users,
    fn ($u) => $u['active']
);

// 2. Nur Namen extrahieren
$names = array_map(
    fn ($u) => $u['name'],
    $activeUsers
);
```

---

## Wann statt `foreach`?

* Wenn die Operation **klar und linear** ist
* Wenn Transformation / Filter / Aggregation im Vordergrund steht
* Für **lesbaren, deklarativen Code**

Bei komplexer Logik → `foreach` oft verständlicher.

---

### Zusammenfassung

* `array_map` → transformiert jedes Element
* `array_filter` → entfernt unerwünschte Elemente
* `array_reduce` → fasst ein Array zu einem Wert zusammen
* Fördern sauberen, funktionalen PHP-Code
* Sehr häufig in modernen Codebases und Interviews

**Weiterführende Doku:**

* `array_map`: [https://www.php.net/manual/en/function.array-map.php](https://www.php.net/manual/en/function.array-map.php)
* `array_filter`: [https://www.php.net/manual/en/function.array-filter.php](https://www.php.net/manual/en/function.array-filter.php)
* `array_reduce`: [https://www.php.net/manual/en/function.array-reduce.php](https://www.php.net/manual/en/function.array-reduce.php)

  **[⬆ Наверх](#top)**

15. ### <a name="15"></a> Wie prüft man, ob ein Schlüssel in einem Array existiert?

## Wie prüft man, ob ein Schlüssel in einem Array existiert?

### Überblick

In PHP gibt es **zwei gebräuchliche und wichtige Möglichkeiten**, um zu prüfen, ob ein Schlüssel in einem Array existiert:

* `array_key_exists()`
* `isset()`

Sie haben **unterschiedliches Verhalten**, besonders bei `null`-Werten.

---

## `array_key_exists()` – prüft nur den Schlüssel

```php
$data = [
    'name' => null
];

array_key_exists('name', $data); // true
```

**Eigenschaften:**

* Gibt `true` zurück, wenn der Schlüssel existiert
* Wert kann auch `null` sein
* Präzise Prüfung auf **Existenz des Schlüssels**

**Typischer Einsatz:**

* Konfigurationsarrays
* Unterscheidung zwischen „nicht vorhanden“ und „vorhanden, aber null“

---

## `isset()` – Schlüssel existiert **und** Wert ist nicht `null`

```php
$data = [
    'name' => null
];

isset($data['name']); // false
```

```php
$data = [
    'name' => 'Anna'
];

isset($data['name']); // true
```

**Eigenschaften:**

* Schneller als `array_key_exists()`
* Gibt `false` zurück, wenn der Wert `null` ist
* Sehr häufig verwendet

---

## Direkter Vergleich

| Fall                             | `array_key_exists()` | `isset()` |
| -------------------------------- | -------------------- | --------- |
| Schlüssel existiert, Wert ≠ null | true                 | true      |
| Schlüssel existiert, Wert = null | true                 | false     |
| Schlüssel existiert nicht        | false                | false     |

---

## Praktische Empfehlung

* **`isset()`** → Standardfall, wenn `null` kein gültiger Wert ist
* **`array_key_exists()`** → wenn `null` ein gültiger Wert sein kann

---

## Beispiel aus der Praxis

```php
$config = [
    'cache_ttl' => null
];

if (array_key_exists('cache_ttl', $config)) {
    // bewusst gesetzt, auch wenn null
}
```

---

### Sonderfall: Mehrdimensionale Arrays

```php
if (isset($data['user']['email'])) {
    // sicherer Zugriff
}
```

* Verhindert Notices
* Kurz und performant

---

### Zusammenfassung

* `array_key_exists()` prüft **nur den Schlüssel**
* `isset()` prüft **Schlüssel + Wert ≠ null**
* Unterschied ist entscheidend bei `null`-Werten
* `isset()` ist der Standard, `array_key_exists()` für Sonderfälle

**Weiterführende Doku:**

* `array_key_exists()`: [https://www.php.net/manual/en/function.array-key-exists.php](https://www.php.net/manual/en/function.array-key-exists.php)
* `isset()`: [https://www.php.net/manual/en/function.isset.php](https://www.php.net/manual/en/function.isset.php)

  **[⬆ Наверх](#top)**

16. ### <a name="16"></a> Wie kann man Arrays sortieren?

## Wie kann man Arrays sortieren?

### Überblick

PHP bietet **mehrere Sortierfunktionen**, abhängig davon:

* ob **Schlüssel erhalten bleiben** sollen
* ob nach **Werten oder Schlüsseln** sortiert wird
* ob **auf- oder absteigend**

---

## Sortieren nach Werten (Schlüssel gehen verloren)

### `sort()` – aufsteigend

```php
$numbers = [3, 1, 2];
sort($numbers);

// [1, 2, 3]
```

* Sortiert nach Werten
* Numerische Schlüssel werden neu vergeben

---

### `rsort()` – absteigend

```php
rsort($numbers);

// [3, 2, 1]
```

---

## Sortieren nach Werten (Schlüssel bleiben erhalten)

### `asort()` – aufsteigend

```php
$userScores = [
    'Anna' => 90,
    'Max' => 75,
    'Lisa' => 85
];

asort($userScores);
```

---

### `arsort()` – absteigend

```php
arsort($userScores);
```

---

## Sortieren nach Schlüsseln

### `ksort()` – aufsteigend

```php
ksort($userScores);
```

---

### `krsort()` – absteigend

```php
krsort($userScores);
```

---

## Benutzerdefinierte Sortierung

### `usort()` – Werte, Schlüssel gehen verloren

```php
$users = [
    ['name' => 'Anna', 'age' => 30],
    ['name' => 'Max', 'age' => 25]
];

usort($users, fn ($a, $b) => $a['age'] <=> $b['age']);
```

---

### `uasort()` – Werte, Schlüssel bleiben erhalten

```php
uasort($users, fn ($a, $b) => $a['age'] <=> $b['age']);
```

---

### `uksort()` – Schlüssel vergleichen

```php
uksort($userScores, fn ($a, $b) => strcmp($a, $b));
```

---

## Spaceship-Operator (`<=>`)

* Liefert `-1`, `0` oder `1`
* Ideal für Vergleichsfunktionen

```php
$a <=> $b;
```

---

## Praxisbeispiel (Framework-nah)

```php
usort(
    $users,
    fn ($a, $b) => $b['created_at'] <=> $a['created_at']
);
```

---

### Zusammenfassung

* `sort`, `rsort` → Werte, Schlüssel weg
* `asort`, `arsort` → Werte, Schlüssel bleiben
* `ksort`, `krsort` → nach Schlüsseln
* `usort`, `uasort`, `uksort` → eigene Logik
* `<=>` vereinfacht Vergleichsfunktionen

**Weiterführende Doku:**

* PHP Array Sorting:
  [https://www.php.net/manual/en/array.sorting.php](https://www.php.net/manual/en/array.sorting.php)

  **[⬆ Наверх](#top)**

17. ### <a name="17"></a> Wie definiert man eine Funktion in PHP?

## Wie definiert man eine Funktion in PHP?

### Grundsyntax

Eine Funktion wird mit dem Schlüsselwort `function` definiert.

```php
function greet() {
    echo 'Hallo Welt';
}
```

Aufruf:

```php
greet();
```

---

### Funktionen mit Parametern

```php
function greet(string $name) {
    echo 'Hallo ' . $name;
}

greet('Anna');
```

* Parameter werden in runden Klammern definiert
* Typdeklarationen sind optional, aber empfohlen

---

### Rückgabewerte

```php
function add(int $a, int $b): int {
    return $a + $b;
}
```

* `return` beendet die Funktion
* Rückgabetyp wird nach `:` angegeben

---

### Optionale Parameter (Default-Werte)

```php
function greet(string $name = 'Gast'): string {
    return 'Hallo ' . $name;
}
```

* Default-Werte müssen **rechts** stehen

---

### Strikte Typisierung

```php
declare(strict_types=1);

function multiply(int $a, int $b): int {
    return $a * $b;
}
```

* Verhindert implizite Typkonvertierung

---

### Anonyme Funktionen (Closures)

```php
$sum = function (int $a, int $b): int {
    return $a + $b;
};
```

* Können Variablen kapseln (`use`)
* Häufig bei Callbacks

---

### Arrow Functions (kurze Syntax)

```php
$sum = fn (int $a, int $b) => $a + $b;
```

* Ab PHP 7.4
* Automatisches `return`
* Lexical Scope (kein `use` nötig)

---

### Typisierte Parameter & Nullable Types

```php
function findUser(?int $id): ?string {
    return $id ? 'User' : null;
}
```

* `?Type` erlaubt `null`

---

### Sichtbarkeit & Namensräume

```php
namespace App\Service;

function helper() {
    // ...
}
```

* Funktionen können in Namespaces liegen
* Vermeidet Namenskonflikte

---

### Zusammenfassung

* Funktionen werden mit `function` definiert
* Parameter und Rückgabewerte können typisiert werden
* Default-Werte machen Parameter optional
* Closures und Arrow Functions für Callbacks
* `strict_types` erhöht Typensicherheit

**Weiterführende Doku:**

* PHP Funktionen:
  [https://www.php.net/manual/en/functions.user-defined.php](https://www.php.net/manual/en/functions.user-defined.php)

  **[⬆ Наверх](#top)**

18. ### <a name="18"></a> Was sind Standardparameter?

## Was sind Standardparameter?

### Definition

**Standardparameter** (Default-Parameter) sind Funktionsparameter, die **einen vordefinierten Wert** haben.
Wird beim Funktionsaufruf **kein Argument übergeben**, verwendet PHP automatisch diesen Standardwert.

---

### Einfaches Beispiel

```php
function greet(string $name = 'Gast'): string {
    return 'Hallo ' . $name;
}

greet();        // Hallo Gast
greet('Anna');  // Hallo Anna
```

---

### Regeln für Standardparameter

* Standardparameter müssen **rechts** von Pflichtparametern stehen
* Jeder Parameter kann **optional** sein
* Typdeklarationen sind erlaubt

```php
function example(int $a, int $b = 10) {
    // gültig
}
```

❌ Ungültig:

```php
function example(int $a = 10, int $b) {
}
```

---

### Standardparameter mit `null`

```php
function findUser(?int $id = null): ?string {
    if ($id === null) {
        return null;
    }

    return 'User ' . $id;
}
```

* Häufige Kombination: `?Type = null`
* Typisch in Services und Repositories

---

### Standardparameter bei Arrays

```php
function connect(array $options = []): void {
    // Optionen optional
}
```

* Sehr verbreitet für Konfiguration

---

### Standardparameter & `strict_types`

```php
declare(strict_types=1);

function test(int $value = 5) {
}
```

* Standardwert muss dem Typ entsprechen
* Keine implizite Typkonvertierung

---

### Typischer Einsatz

* Optionale Konfigurationswerte
* Vereinfachte API-Aufrufe
* Rückwärtskompatibilität
* Klarere Funktionssignaturen

---

### Zusammenfassung

* Standardparameter haben einen **Default-Wert**
* Werden genutzt, wenn kein Argument übergeben wird
* Müssen **am Ende** der Parameterliste stehen
* Häufig kombiniert mit `null` oder leeren Arrays
* Erhöhen Flexibilität und Lesbarkeit von Funktionen

**Weiterführende Doku:**

* PHP Default Parameter Values:
  [https://www.php.net/manual/en/functions.arguments.php](https://www.php.net/manual/en/functions.arguments.php)

  **[⬆ Наверх](#top)**

19. ### <a name="19"></a> Was sind anonyme Funktionen?

## Was sind anonyme Funktionen?

### Definition

**Anonyme Funktionen** (Closures) sind Funktionen **ohne Namen**, die einer Variable zugewiesen oder direkt als Argument übergeben werden.
Sie werden häufig für **Callbacks**, **Event-Handler** und **funktionale Array-Operationen** verwendet.

---

### Grundbeispiel

```php
$greet = function (string $name): string {
    return 'Hallo ' . $name;
};

echo $greet('Anna');
```

* Die Funktion hat **keinen Namen**
* Sie wird über eine Variable aufgerufen

---

### Typischer Einsatz: Callback-Funktionen

```php
$numbers = [1, 2, 3];

$squared = array_map(function (int $n): int {
    return $n * $n;
}, $numbers);
```

* Sehr verbreitet bei `array_map`, `array_filter`, `usort` usw.

---

### Zugriff auf äußere Variablen (`use`)

Anonyme Funktionen können Variablen aus dem äußeren Scope übernehmen:

```php
$factor = 2;

$multiply = function (int $value) use ($factor): int {
    return $value * $factor;
};
```

* `use` kopiert den Wert
* Referenzübergabe möglich mit `use (&$factor)`

---

### Anonyme Funktionen als Rückgabewert

```php
function createMultiplier(int $factor): callable {
    return function (int $value) use ($factor): int {
        return $value * $factor;
    };
}

$double = createMultiplier(2);
echo $double(5); // 10
```

---

### Unterschied zu Arrow Functions

Arrow Functions (`fn`) sind eine **Kurzform** anonymer Funktionen:

```php
$sum = fn (int $a, int $b) => $a + $b;
```

Unterschiede:

* Arrow Functions:

  * automatisch `return`
  * kein `use` nötig (lexical scope)
  * nur **eine Expression**
* Anonyme Funktionen:

  * mehrere Statements
  * mehr Kontrolle

---

### Typisierung

Anonyme Funktionen können vollständig typisiert werden:

```php
$fn = function (int $a, int $b): int {
    return $a + $b;
};
```

---

### Zusammenfassung

* Anonyme Funktionen sind **namenlose Funktionen**
* Werden Variablen zugewiesen oder als Callback genutzt
* Können Variablen aus dem äußeren Scope übernehmen (`use`)
* Sehr wichtig für funktionalen und modernen PHP-Code
* Arrow Functions sind die kompakte Alternative

**Weiterführende Doku:**

* PHP Anonymous Functions (Closures):
  [https://www.php.net/manual/en/functions.anonymous.php](https://www.php.net/manual/en/functions.anonymous.php)

  **[⬆ Наверх](#top)**

20. ### <a name="20"></a> Was sind Arrow Functions (fn)?

## Was sind Arrow Functions (`fn`)?

### Definition

**Arrow Functions** (`fn`) sind eine **kurze Syntax für anonyme Funktionen**, eingeführt in **PHP 7.4**.
Sie sind für **kleine, einfache Funktionen** gedacht, insbesondere als Callbacks.

---

### Grundsyntax

```php
$sum = fn (int $a, int $b) => $a + $b;
```

* Automatisches `return`
* Nur **eine Expression**
* Kein Funktionsblock `{}` nötig

---

### Typischer Einsatz: Array-Funktionen

```php
$numbers = [1, 2, 3];

$squared = array_map(fn ($n) => $n * $n, $numbers);
```

* Sehr kompakt
* Gut lesbar bei einfacher Logik

---

### Lexical Scope (wichtig!)

Arrow Functions übernehmen Variablen aus dem äußeren Scope **automatisch**.

```php
$factor = 2;

$multiply = fn (int $n) => $n * $factor;
```

* Kein `use` nötig
* Immer **per Wert**, nicht per Referenz

---

### Vergleich: Arrow Function vs. anonyme Funktion

```php
// Arrow Function
fn ($x) => $x * 2;

// Anonyme Funktion
function ($x) use ($factor) {
    return $x * $factor;
}
```

**Unterschiede:**

* Arrow Functions:

  * eine Expression
  * implizites `return`
  * kein `use`
* Anonyme Funktionen:

  * mehrere Statements möglich
  * explizites `return`
  * `use` erforderlich

---

### Einschränkungen

* Kein Block-Code (`{}`)
* Keine Statements wie `if`, `foreach`, `try`
* Keine Referenz-Rückgabe
* Kein `void`

---

### Typisierung

```php
$calc = fn (int $a, int $b): int => $a + $b;
```

* Parameter- und Rückgabetypen möglich
* Kompatibel mit `strict_types`

---

### Typische Einsatzbereiche

* Callbacks
* Mapper / Filter
* Sortierfunktionen
* Kurze mathematische/logische Operationen

---

### Zusammenfassung

* Arrow Functions sind **kurze anonyme Funktionen**
* Einführung in PHP 7.4
* Automatisches `return`, eine Expression
* Lexical Scope ohne `use`
* Ideal für kurze Callback-Logik

**Weiterführende Doku:**

* PHP Arrow Functions:
  [https://www.php.net/manual/en/functions.arrow.php](https://www.php.net/manual/en/functions.arrow.php)

  **[⬆ Наверх](#top)**

21. ### <a name="21"></a> Was ist eine Callback-Funktion?

## Was ist eine Callback-Funktion?

### Definition

Eine **Callback-Funktion** ist eine Funktion, die **als Argument an eine andere Funktion übergeben** und **später von dieser aufgerufen** wird.
Sie dient dazu, **dynamisches Verhalten** zu ermöglichen, ohne die aufrufende Funktion zu ändern.

---

### Einfaches Beispiel

```php
function process(int $a, int $b, callable $callback): int {
    return $callback($a, $b);
}

$result = process(2, 3, fn ($x, $y) => $x + $y);

echo $result; // 5
```

* Die Funktion kennt die Logik nicht
* Der Callback definiert das Verhalten

---

### Typische Formen von Callbacks in PHP

#### 1. Anonyme Funktion

```php
array_map(function ($n) {
    return $n * 2;
}, [1, 2, 3]);
```

---

#### 2. Arrow Function

```php
array_filter($numbers, fn ($n) => $n > 10);
```

---

#### 3. Benannte Funktion

```php
function isEven(int $n): bool {
    return $n % 2 === 0;
}

array_filter([1, 2, 3, 4], 'isEven');
```

---

#### 4. Methoden-Callback

```php
class Validator {
    public static function isValid(string $value): bool {
        return $value !== '';
    }
}

array_filter($data, [Validator::class, 'isValid']);
```

---

### Typisierung mit `callable`

```php
function run(callable $callback): void {
    $callback();
}
```

* `callable` stellt sicher, dass der Parameter aufrufbar ist
* Sehr wichtig für saubere APIs

---

### Typische Einsatzgebiete

* Array-Funktionen (`array_map`, `array_filter`)
* Event-Handling
* Middleware
* Validierung
* Sortierlogik (`usort`)

---

### Callback vs. direkte Logik

Callbacks:

* Erhöhen Flexibilität
* Trennen Logik und Ablauf
* Fördern Wiederverwendbarkeit

---

### Zusammenfassung

* Callback-Funktionen werden **als Parameter übergeben**
* Sie definieren Verhalten zur Laufzeit
* Können anonym, als Arrow Function oder Methode definiert sein
* Sehr wichtig für funktionalen und modularen PHP-Code

**Weiterführende Doku:**

* PHP Callables:
  [https://www.php.net/manual/en/language.types.callable.php](https://www.php.net/manual/en/language.types.callable.php)

  **[⬆ Наверх](#top)**

22. ### <a name="22"></a> Was ist eine Klasse und was ist ein Objekt?

## Was ist eine Klasse und was ist ein Objekt?

### Klasse

Eine **Klasse** ist ein **Bauplan (Blueprint)**, der definiert:

* **Eigenschaften** (Properties → Zustand)
* **Methoden** (Verhalten)

Sie beschreibt **was ein Objekt ist und was es kann**, erzeugt aber noch kein konkretes Exemplar.

```php
class User {
    public string $name;

    public function greet(): string {
        return 'Hallo ' . $this->name;
    }
}
```

---

### Objekt

Ein **Objekt** ist eine **konkrete Instanz** einer Klasse.
Es wird mit dem Schlüsselwort `new` erzeugt und existiert zur Laufzeit.

```php
$user = new User();
$user->name = 'Anna';

echo $user->greet(); // Hallo Anna
```

* `$user` ist ein Objekt
* Es hat eigenen Zustand (`$name`)
* Es kann Methoden ausführen

---

### Beziehung Klasse ↔ Objekt

* **Klasse** = Definition
* **Objekt** = konkrete Ausprägung

```php
$user1 = new User();
$user2 = new User();

$user1->name = 'Anna';
$user2->name = 'Max';
```

* Beide Objekte basieren auf derselben Klasse
* Haben aber **unabhängigen Zustand**

---

### Eigenschaften (Properties)

```php
class Product {
    public string $title;
    private float $price;
}
```

* Beschreiben den Zustand eines Objekts
* Sichtbarkeit steuert Zugriff

---

### Methoden

```php
class Product {
    private float $price;

    public function setPrice(float $price): void {
        $this->price = $price;
    }

    public function getPrice(): float {
        return $this->price;
    }
}
```

* Methoden definieren Verhalten
* Zugriff auf Properties über `$this`

---

### Warum OOP?

* Kapselung von Logik und Daten
* Bessere Struktur
* Wartbarer Code
* Grundlage für Frameworks (Symfony, Laravel)

---

### Klassen in modernen PHP-Anwendungen

* Services
* Controller
* Entities
* Value Objects
* DTOs

---

### Zusammenfassung

* Eine Klasse ist ein **Bauplan**
* Ein Objekt ist eine **Instanz einer Klasse**
* Klassen definieren Struktur und Verhalten
* Objekte repräsentieren konkrete Zustände
* OOP ist zentral für moderne PHP-Architektur

**Weiterführende Doku:**

* PHP OOP Grundlagen:
  [https://www.php.net/manual/en/language.oop5.basic.php](https://www.php.net/manual/en/language.oop5.basic.php)

  **[⬆ Наверх](#top)**

23. ### <a name="23"></a> Welche Sichtbarkeiten gibt es (public, protected, private)?

## Welche Sichtbarkeiten gibt es (`public`, `protected`, `private`)?

### Überblick

Sichtbarkeiten (Access Modifiers) steuern, **von wo aus** auf **Eigenschaften und Methoden** einer Klasse zugegriffen werden darf.
Sie sind ein zentrales Konzept der **Kapselung** in OOP.

---

## `public`

Zugriff **von überall**:

* innerhalb der Klasse
* von abgeleiteten Klassen
* von außen (über Objektinstanz)

```php
class User {
    public string $name;

    public function getName(): string {
        return $this->name;
    }
}

$user = new User();
$user->name = 'Anna';
```

**Einsatz:**

* Öffentliche API einer Klasse
* Methoden, die bewusst nach außen angeboten werden

---

## `protected`

Zugriff:

* innerhalb der Klasse
* in **Kindklassen**
* **nicht** von außen

```php
class BaseUser {
    protected string $role;
}

class Admin extends BaseUser {
    public function setRole(string $role): void {
        $this->role = $role;
    }
}
```

**Einsatz:**

* Gemeinsame Logik für Vererbung
* Erweiterbare Basisklassen

---

## `private`

Zugriff **nur innerhalb derselben Klasse**.

```php
class User {
    private string $passwordHash;

    private function hashPassword(string $password): string {
        return password_hash($password, PASSWORD_DEFAULT);
    }
}
```

**Einsatz:**

* Interne Implementierungsdetails
* Schutz vor unbeabsichtigtem Zugriff
* Starke Kapselung

---

## Vergleich auf einen Blick

| Sichtbarkeit | Klasse | Kindklasse | Außen |
| ------------ | ------ | ---------- | ----- |
| `public`     | ✔      | ✔          | ✔     |
| `protected`  | ✔      | ✔          | ✘     |
| `private`    | ✔      | ✘          | ✘     |

---

## Best Practices

* Standard: **`private`**
* Öffentliche Methoden bewusst wählen
* `protected` nur bei geplanter Vererbung
* Properties fast immer `private`

---

## Zusammenhang mit `final`

* `private` Methoden können nicht überschrieben werden
* `final` verhindert Überschreiben auch bei `public` / `protected`

---

### Zusammenfassung

* `public` → überall zugreifbar
* `protected` → Klasse + Kindklassen
* `private` → nur in derselben Klasse
* Richtige Sichtbarkeit ist zentral für sauberes OOP-Design
* Bevorzuge möglichst restriktive Sichtbarkeit

**Weiterführende Doku:**

* PHP Visibility:
  [https://www.php.net/manual/en/language.oop5.visibility.php](https://www.php.net/manual/en/language.oop5.visibility.php)

  **[⬆ Наверх](#top)**

24. ### <a name="24"></a> Was ist ein Konstruktor?

## Was ist ein Konstruktor?

### Definition

Ein **Konstruktor** ist eine spezielle Methode einer Klasse, die **automatisch beim Erzeugen eines Objekts** aufgerufen wird.
Er dient dazu, das Objekt **initial zu konfigurieren** (Initialisierung von Properties, Abhängigkeiten, Zustand).

In PHP heißt der Konstruktor immer `__construct`.

---

### Einfaches Beispiel

```php
class User {
    public string $name;

    public function __construct(string $name) {
        $this->name = $name;
    }
}

$user = new User('Anna');
```

* `__construct()` wird beim `new User(...)` aufgerufen
* Das Objekt ist nach der Erstellung direkt nutzbar

---

### Konstruktor mit mehreren Parametern

```php
class Product {
    private string $title;
    private float $price;

    public function __construct(string $title, float $price) {
        $this->title = $title;
        $this->price = $price;
    }
}
```

* Erzwingt gültigen Anfangszustand
* Verhindert „halbfertige“ Objekte

---

### Dependency Injection über den Konstruktor

```php
class UserService {
    private UserRepository $repository;

    public function __construct(UserRepository $repository) {
        $this->repository = $repository;
    }
}
```

* Sehr wichtig in Symfony / Laravel
* Abhängigkeiten sind explizit sichtbar
* Erleichtert Testbarkeit

---

### Konstruktor-Vererbung

```php
class BaseUser {
    public function __construct(string $role) {
        // ...
    }
}

class Admin extends BaseUser {
    public function __construct() {
        parent::__construct('admin');
    }
}
```

* `parent::__construct()` ruft den Elternkonstruktor auf

---

### Property Promotion (PHP 8+)

```php
class User {
    public function __construct(
        private string $name,
        private string $email
    ) {}
}
```

* Kürzere Syntax
* Sehr verbreitet in modernem PHP

---

### Optionaler Konstruktor

Ein Konstruktor ist **nicht verpflichtend**.

```php
class Logger {
    // kein Konstruktor
}
```

---

### Zusammenfassung

* Konstruktor = Initialisierungsmethode einer Klasse
* Heißt in PHP `__construct`
* Wird beim Erzeugen eines Objekts automatisch aufgerufen
* Ideal für Pflichtdaten und Dependency Injection
* Property Promotion vereinfacht modernen Code

**Weiterführende Doku:**

* PHP Konstruktoren:
  [https://www.php.net/manual/en/language.oop5.decon.php](https://www.php.net/manual/en/language.oop5.decon.php)

  **[⬆ Наверх](#top)**

25. ### <a name="25"></a> Wie funktioniert Vererbung (extends)?

## Wie funktioniert Vererbung (`extends`)?

### Grundidee

**Vererbung** erlaubt es, eine bestehende Klasse (**Elternklasse**) zu erweitern.
Die **Kindklasse** übernimmt Eigenschaften und Methoden der Elternklasse und kann sie **verwenden, erweitern oder überschreiben**.

In PHP wird Vererbung mit dem Schlüsselwort `extends` umgesetzt.

---

### Einfaches Beispiel

```php
class User {
    protected string $name;

    public function setName(string $name): void {
        $this->name = $name;
    }
}

class Admin extends User {
    public function getRole(): string {
        return 'ADMIN';
    }
}
```

* `Admin` erbt von `User`
* `Admin` hat Zugriff auf `protected` und `public` Member

---

### Zugriff auf geerbte Eigenschaften

```php
$admin = new Admin();
$admin->setName('Anna');
```

* `protected` → zugreifbar in der Kindklasse
* `private` → **nicht** vererbbar

---

### Methoden überschreiben (Override)

```php
class User {
    public function getRole(): string {
        return 'USER';
    }
}

class Admin extends User {
    public function getRole(): string {
        return 'ADMIN';
    }
}
```

* Signatur muss kompatibel sein
* Sichtbarkeit darf **nicht eingeschränkt** werden

---

### Aufruf der Elternmethode (`parent::`)

```php
class Admin extends User {
    public function getRole(): string {
        return parent::getRole() . '_ADMIN';
    }
}
```

---

### Konstruktoren und Vererbung

```php
class User {
    public function __construct(string $name) {}
}

class Admin extends User {
    public function __construct(string $name) {
        parent::__construct($name);
    }
}
```

* Elternkonstruktor wird **nicht automatisch** aufgerufen
* Muss explizit mit `parent::__construct()` erfolgen

---

### Vererbung einschränken mit `final`

```php
final class User {
}

// class Admin extends User {} ❌
```

Oder Methoden sperren:

```php
class User {
    final public function getId(): int {
        return 1;
    }
}
```

---

### Wann Vererbung sinnvoll ist

* **„is-a“-Beziehung**

  * `Admin` ist ein `User`
* Gemeinsames Verhalten
* Gemeinsame Basisklassen (Frameworks)

---

### Wann vermeiden

* Code-Wiederverwendung ohne echte Beziehung
* Tiefe Vererbungshierarchien
* Besser: **Komposition statt Vererbung**

---

### Zusammenfassung

* `extends` ermöglicht Klassenvererbung
* Kindklassen erben `public` und `protected` Member
* Methoden können überschrieben werden
* `parent::` greift auf Elternlogik zu
* Vererbung sparsam einsetzen, Komposition bevorzugen

**Weiterführende Doku:**

* PHP Vererbung:
  [https://www.php.net/manual/en/language.oop5.inheritance.php](https://www.php.net/manual/en/language.oop5.inheritance.php)

  **[⬆ Наверх](#top)**

26. ### <a name="26"></a> Unterschied zwischen interface und abstract class

## Unterschied zwischen `interface` und `abstract class`

### Grundidee

Beide Konzepte dienen der **Abstraktion**, haben aber **unterschiedliche Ziele**:

* **`interface`** → definiert **was** eine Klasse können muss
* **`abstract class`** → definiert **was** eine Klasse ist und **wie** Teile davon funktionieren

---

## `interface`

### Eigenschaften

* Enthält **nur Methodensignaturen**
* **Keine Implementierung** (außer `default`-Methoden gibt es in PHP nicht)
* Alle Methoden sind automatisch `public`
* Eine Klasse kann **mehrere Interfaces implementieren**

```php
interface LoggerInterface {
    public function log(string $message): void;
}
```

```php
class FileLogger implements LoggerInterface {
    public function log(string $message): void {
        // Implementierung
    }
}
```

---

### Typische Einsatzfälle

* Verträge / APIs
* Dependency Injection
* Austauschbare Implementierungen
* Framework-Services (z. B. PSR-Interfaces)

---

## `abstract class`

### Eigenschaften

* Kann **konkrete und abstrakte Methoden** enthalten
* Kann Properties haben
* Methoden können `protected` oder `private` sein
* Eine Klasse kann **nur eine abstrakte Klasse erben**

```php
abstract class BaseLogger {
    protected string $path;

    public function __construct(string $path) {
        $this->path = $path;
    }

    abstract public function log(string $message): void;
}
```

```php
class FileLogger extends BaseLogger {
    public function log(string $message): void {
        // Implementierung
    }
}
```

---

### Typische Einsatzfälle

* Gemeinsame Basislogik
* Teilweise Implementierung
* Template-Method-Pattern

---

## Vergleich auf einen Blick

| Aspekt          | `interface`  | `abstract class`           |
| --------------- | ------------ | -------------------------- |
| Implementierung | ❌            | ✔                          |
| Properties      | ❌            | ✔                          |
| Konstruktor     | ❌            | ✔                          |
| Mehrfachnutzung | ✔ (mehrere)  | ❌ (nur eine)               |
| Sichtbarkeit    | nur `public` | `public/protected/private` |
| Zweck           | Vertrag      | Basisimplementierung       |

---

## Praxis-Empfehlung

* **Interface**, wenn:

  * Verhalten definiert werden soll
  * Austauschbarkeit wichtig ist
* **Abstract Class**, wenn:

  * Gemeinsamer Code vorhanden ist
  * Teilimplementierung sinnvoll ist

In modernen PHP-Anwendungen:

* **Interfaces an Abhängigkeiten**
* **Abstrakte Klassen für Wiederverwendung**

---

### Zusammenfassung

* Interfaces definieren **Verträge**
* Abstrakte Klassen liefern **Basisimplementierungen**
* Interfaces erlauben Mehrfachimplementierung
* Abstrakte Klassen erlauben Code-Wiederverwendung
* Beide sind zentrale Werkzeuge für sauberes OOP-Design

**Weiterführende Doku:**

* Interfaces: [https://www.php.net/manual/en/language.oop5.interfaces.php](https://www.php.net/manual/en/language.oop5.interfaces.php)
* Abstrakte Klassen: [https://www.php.net/manual/en/language.oop5.abstract.php](https://www.php.net/manual/en/language.oop5.abstract.php)

  **[⬆ Наверх](#top)**

27. ### <a name="27"></a> Unterschied zwischen GET und POST

## Unterschied zwischen GET und POST

### Grundidee

`GET` und `POST` sind HTTP-Methoden, mit denen der Client Daten an den Server sendet.
Der Unterschied liegt in **Zweck**, **Datenübertragung** und **Sichtbarkeit**.

---

## GET

### Eigenschaften

* Daten werden über die **URL (Query-String)** gesendet
* Sichtbar in der Adresszeile
* Länge der URL ist begrenzt
* Kann gecacht und gebookmarkt werden
* Sollte **keine Zustandsänderung** verursachen

```http
GET /users?id=10 HTTP/1.1
```

```php
$id = $_GET['id'] ?? null;
```

### Typische Verwendung

* Daten abrufen (Read)
* Filter, Suche
* REST: `GET /users`, `GET /users/10`

---

## POST

### Eigenschaften

* Daten werden im **Request-Body** gesendet
* Nicht in der URL sichtbar
* Keine feste Größenbegrenzung (praktisch serverseitig limitiert)
* Nicht idempotent
* Nicht bookmarkbar
* Geeignet für **Zustandsänderungen**

```http
POST /users HTTP/1.1
Content-Type: application/json

{"name":"Anna"}
```

```php
$name = $_POST['name'] ?? null;
```

### Typische Verwendung

* Formulare absenden
* Daten erstellen oder verarbeiten
* REST: `POST /users`

---

## Vergleich auf einen Blick

| Aspekt           | GET                           | POST                                   |
| ---------------- | ----------------------------- | -------------------------------------- |
| Datenübertragung | URL (Query)                   | Request-Body                           |
| Sichtbarkeit     | sichtbar                      | nicht sichtbar                         |
| Länge            | begrenzt                      | praktisch unbegrenzt                   |
| Caching          | möglich                       | i. d. R. nein                          |
| Bookmark         | möglich                       | nein                                   |
| Zweck            | Lesen                         | Erstellen / Verarbeiten                |
| Sicherheit       | ungeeignet für sensible Daten | besser (aber nicht automatisch sicher) |

---

## Sicherheitshinweis

* **GET ist nicht sicher** für sensible Daten (Passwörter, Tokens)
* **POST ist nicht automatisch sicher**
  → Sicherheit kommt durch **HTTPS**, Validierung, CSRF-Schutz

---

## REST-Kontext (wichtig im Interview)

* `GET` → lesen (safe, idempotent)
* `POST` → erstellen / Aktionen auslösen
* `PUT/PATCH` → aktualisieren
* `DELETE` → löschen

---

### Zusammenfassung

* `GET` überträgt Daten über die URL und dient dem **Lesen**
* `POST` überträgt Daten im Body und dient der **Verarbeitung**
* GET ist sichtbar, cachebar und bookmarkbar
* POST ist flexibler für größere und sensible Daten
* In REST-APIs hat jede Methode eine klare Semantik

**Weiterführende Doku:**

* PHP Superglobals (`$_GET`, `$_POST`):
  [https://www.php.net/manual/en/language.variables.superglobals.php](https://www.php.net/manual/en/language.variables.superglobals.php)
* HTTP Semantics (MDN):
  [https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods)

  **[⬆ Наверх](#top)**

28. ### <a name="28"></a> Was sind $_GET, $_POST, $_SESSION, $_COOKIE?

## Was sind `$_GET`, `$_POST`, `$_SESSION`, `$_COOKIE`?

### Überblick

`$_GET`, `$_POST`, `$_SESSION` und `$_COOKIE` sind **PHP-Superglobals**.
Sie sind **in jeder PHP-Datei automatisch verfügbar** und enthalten Daten aus dem HTTP-Kontext.

---

## `$_GET`

Enthält Daten aus der **URL (Query-String)**.

```http
GET /search?q=php&page=2
```

```php
$q = $_GET['q'] ?? null;
$page = $_GET['page'] ?? 1;
```

**Eigenschaften:**

* Sichtbar in der URL
* Geeignet für Filter, Suche, Pagination
* Nicht für sensible Daten

---

## `$_POST`

Enthält Daten aus dem **Request-Body** (z. B. HTML-Formulare).

```php
$email = $_POST['email'] ?? null;
$password = $_POST['password'] ?? null;
```

**Eigenschaften:**

* Nicht in der URL sichtbar
* Für größere Datenmengen geeignet
* Sicherheit nur mit HTTPS

---

## `$_SESSION`

Speichert **serverseitige Daten pro Benutzer-Session**.

```php
session_start();
$_SESSION['user_id'] = 42;
```

**Eigenschaften:**

* Daten liegen auf dem Server
* Client erhält nur eine **Session-ID** (Cookie)
* Geeignet für Login-Status, Flash-Messages

---

## `$_COOKIE`

Enthält **Client-seitig gespeicherte Daten**.

```php
setcookie('language', 'de', time() + 3600);

$lang = $_COOKIE['language'] ?? 'en';
```

**Eigenschaften:**

* Werden bei jedem Request gesendet
* Manipulierbar durch den Client
* Niemals sensible Daten speichern

---

## Zusammenhang zwischen Session und Cookie

* PHP speichert die **Session-ID** in einem Cookie (`PHPSESSID`)
* `$_SESSION`-Daten liegen serverseitig
* Cookie verknüpft Client und Session

---

## Vergleich auf einen Blick

| Superglobal | Speicherort   | Sichtbar | Zweck         |
| ----------- | ------------- | -------- | ------------- |
| `$_GET`     | Client (URL)  | ✔        | Filter, Suche |
| `$_POST`    | Client (Body) | ✘        | Formulare     |
| `$_COOKIE`  | Client        | ✔        | Einstellungen |
| `$_SESSION` | Server        | ✘        | Login-Status  |

---

### Zusammenfassung

* Superglobals sind global verfügbare PHP-Variablen
* `$_GET` → URL-Parameter
* `$_POST` → Request-Body
* `$_COOKIE` → clientseitige Speicherung
* `$_SESSION` → serverseitige Sitzung
* Sessions basieren technisch auf Cookies

**Weiterführende Doku:**

* PHP Superglobals:
  [https://www.php.net/manual/en/language.variables.superglobals.php](https://www.php.net/manual/en/language.variables.superglobals.php)
* PHP Sessions:
  [https://www.php.net/manual/en/book.session.php](https://www.php.net/manual/en/book.session.php)

  **[⬆ Наверх](#top)**

29. ### <a name="29"></a> Wie validiert man Benutzereingaben?

## Wie validiert man Benutzereingaben?

### Grundprinzipien

1. **Immer serverseitig validieren** (Client-Validierung ist nur UX).
2. **Whitelist statt Blacklist** (erlaubte Formate/Values definieren).
3. **Validierung ≠ Sanitization**

   * **Validierung:** „Ist das Eingabeformat korrekt?“
   * **Sanitization/Normalisierung:** „In welches sichere Format bringe ich es?“
4. **Kontextabhängig escapen**

   * HTML-Ausgabe → `htmlspecialchars()`
   * SQL → **Prepared Statements (PDO)**
5. **Klare Fehlermeldungen + passende HTTP-Statuscodes** (z. B. `422 Unprocessable Entity` bei API-Validation).

---

## Core PHP: typische Patterns

### 1) Presence + Typen + Range (Beispiel: JSON-API)

```php
<?php
declare(strict_types=1);

header('Content-Type: application/json');

$raw = file_get_contents('php://input');
$data = json_decode($raw, true);

if (!is_array($data)) {
    http_response_code(400);
    echo json_encode(['error' => 'Invalid JSON']);
    exit;
}

$errors = [];

// name: required, string, length
$name = $data['name'] ?? null;
if (!is_string($name) || mb_strlen(trim($name)) < 2 || mb_strlen($name) > 100) {
    $errors['name'] = 'Must be a string (2–100 chars).';
}

// email: required, valid email
$email = $data['email'] ?? null;
if (!is_string($email) || filter_var($email, FILTER_VALIDATE_EMAIL) === false) {
    $errors['email'] = 'Invalid email.';
}

// age: optional, integer, range
$age = $data['age'] ?? null;
if ($age !== null) {
    $ageInt = filter_var($age, FILTER_VALIDATE_INT, [
        'options' => ['min_range' => 0, 'max_range' => 130],
    ]);
    if ($ageInt === false) {
        $errors['age'] = 'Age must be an integer between 0 and 130.';
    }
}

if ($errors) {
    http_response_code(422);
    echo json_encode(['errors' => $errors]);
    exit;
}

// Normalisierung (Beispiel)
$name = trim($name);
$email = strtolower(trim($email));

http_response_code(200);
echo json_encode(['ok' => true]);
```

**Docs:**

* Filter/Validation: [https://www.php.net/manual/en/book.filter.php](https://www.php.net/manual/en/book.filter.php)
* `filter_var`: [https://www.php.net/manual/en/function.filter-var.php](https://www.php.net/manual/en/function.filter-var.php)

---

### 2) Output-Escaping gegen XSS

Validierung schützt nicht automatisch vor XSS. Beim Rendern in HTML:

```php
<?php
echo htmlspecialchars($name, ENT_QUOTES | ENT_SUBSTITUTE, 'UTF-8');
```

**Docs:** [https://www.php.net/manual/en/function.htmlspecialchars.php](https://www.php.net/manual/en/function.htmlspecialchars.php)
**OWASP XSS:** [https://owasp.org/www-community/attacks/xss/](https://owasp.org/www-community/attacks/xss/)

---

### 3) SQL Injection verhindern (Validation ersetzt das nicht)

Immer Prepared Statements nutzen:

```php
<?php
$stmt = $pdo->prepare('SELECT * FROM users WHERE email = :email');
$stmt->execute(['email' => $email]);
$user = $stmt->fetch();
```

**PDO Prepared Statements:** [https://www.php.net/manual/en/pdo.prepared-statements.php](https://www.php.net/manual/en/pdo.prepared-statements.php)
**OWASP SQLi:** [https://owasp.org/www-community/attacks/SQL_Injection](https://owasp.org/www-community/attacks/SQL_Injection)

---

## Symfony: Validation mit Validator Component (Best Practice)

```php
<?php
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\Validator\Validator\ValidatorInterface;
use Symfony\Component\Validator\Constraints as Assert;

final class RegisterController
{
    public function __invoke(Request $request, ValidatorInterface $validator)
    {
        $data = $request->toArray();

        $constraints = new Assert\Collection([
            'name'  => [new Assert\NotBlank(), new Assert\Length(['min' => 2, 'max' => 100])],
            'email' => [new Assert\NotBlank(), new Assert\Email()],
            'age'   => new Assert\Optional([new Assert\Type('integer'), new Assert\Range(['min' => 0, 'max' => 130])]),
        ]);

        $violations = $validator->validate($data, $constraints);

        if (count($violations) > 0) {
            // In der Praxis: Violations in ein Fehler-Array mappen, 422 zurückgeben
        }

        // ...
    }
}
```

**Docs:** [https://symfony.com/doc/current/validation.html](https://symfony.com/doc/current/validation.html)

---

## Laravel: Validation (Form Request)

```php
<?php
// app/Http/Requests/RegisterRequest.php
namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class RegisterRequest extends FormRequest
{
    public function rules(): array
    {
        return [
            'name'  => ['required', 'string', 'min:2', 'max:100'],
            'email' => ['required', 'email'],
            'age'   => ['nullable', 'integer', 'between:0,130'],
        ];
    }
}
```

Controller:

```php
public function store(RegisterRequest $request)
{
    $validated = $request->validated();
    // ...
}
```

**Docs:** [https://laravel.com/docs/validation](https://laravel.com/docs/validation)

---

## Zusammenfassung

* Serverseitige Validierung ist Pflicht; Client-Checks sind nur Komfort.
* Validierung (Format/Regeln) getrennt von Normalisierung/Sanitization behandeln.
* XSS verhindert man primär durch **Output-Escaping**, SQLi durch **Prepared Statements**.
* In Symfony/Laravel nutzt man bevorzugt deren Validator-Systeme für konsistente Fehlerbehandlung.

**Für Vertiefung:** OWASP Top 10 (Input Validation & Injection): [https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/)

  **[⬆ Наверх](#top)**

30. ### <a name="30"></a> Was sind HTTP-Statuscodes (z. B. 200, 400, 401, 403, 404, 500)?

## Was sind HTTP-Statuscodes (z. B. 200, 400, 401, 403, 404, 500)?

### Definition

**HTTP-Statuscodes** sind **dreistellige Zahlen**, die der Server in der HTTP-Response zurückgibt.
Sie informieren den Client über das **Ergebnis der Anfrage** (Erfolg, Fehler, Umleitung).

---

## Klassen von HTTP-Statuscodes

| Bereich | Bedeutung     |
| ------- | ------------- |
| 1xx     | Information   |
| 2xx     | Erfolg        |
| 3xx     | Weiterleitung |
| 4xx     | Client-Fehler |
| 5xx     | Server-Fehler |

---

## Häufige Statuscodes (Interview-relevant)

### `200 OK`

Die Anfrage wurde **erfolgreich** verarbeitet.

```http
HTTP/1.1 200 OK
```

**Typisch für:**

* Erfolgreiche `GET`, `PUT`, `PATCH`
* Erfolgreiche API-Responses

---

### `400 Bad Request`

Die Anfrage ist **syntaktisch oder semantisch ungültig**.

```http
HTTP/1.1 400 Bad Request
```

**Typisch für:**

* Ungültiges JSON
* Fehlende Pflichtfelder
* Falsches Request-Format

---

### `401 Unauthorized`

**Authentifizierung fehlt oder ist ungültig**.

```http
HTTP/1.1 401 Unauthorized
```

**Typisch für:**

* Fehlender/ungültiger Token
* Nicht eingeloggt

> Wichtig: Bedeutet **nicht** „verboten“, sondern „nicht authentifiziert“.

---

### `403 Forbidden`

Zugriff **verboten**, obwohl der Benutzer authentifiziert ist.

```http
HTTP/1.1 403 Forbidden
```

**Typisch für:**

* Fehlende Berechtigung (Role/Permission)
* Zugriff auf geschützte Ressourcen

---

### `404 Not Found`

Die angeforderte Ressource **existiert nicht**.

```http
HTTP/1.1 404 Not Found
```

**Typisch für:**

* Falsche URL
* Ressource nicht vorhanden (`/users/999`)

---

### `500 Internal Server Error`

Ein **unerwarteter Serverfehler** ist aufgetreten.

```http
HTTP/1.1 500 Internal Server Error
```

**Typisch für:**

* Unbehandelte Exceptions
* Programmfehler
* Fehlerhafte Serverkonfiguration

---

## Statuscodes im REST-Kontext (Kurzüberblick)

| Aktion             | Typischer Code |
| ------------------ | -------------- |
| GET erfolgreich    | 200            |
| POST erfolgreich   | 201 Created    |
| Ungültige Eingaben | 400 / 422      |
| Nicht eingeloggt   | 401            |
| Keine Berechtigung | 403            |
| Ressource fehlt    | 404            |
| Serverfehler       | 500            |

---

## Statuscodes in PHP setzen

```php
http_response_code(404);
```

Oder mit Header:

```php
header('HTTP/1.1 403 Forbidden');
```

In Frameworks:

* Symfony/Laravel nutzen Response-Objekte

---

### Zusammenfassung

* HTTP-Statuscodes beschreiben das **Ergebnis einer Anfrage**
* 2xx = Erfolg, 4xx = Client-Fehler, 5xx = Server-Fehler
* `401` ≠ `403` (Auth vs. Permission)
* Korrekte Statuscodes sind essenziell für saubere APIs
* Besonders wichtig im REST- und Backend-Interview

**Weiterführende Doku:**

* HTTP Status Codes (MDN):
  [https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)

  **[⬆ Наверх](#top)**  

31. ### <a name="31"></a> Was ist SQL Injection?

## Was ist SQL Injection?

### Definition

**SQL Injection** ist eine **Sicherheitslücke**, bei der ein Angreifer **SQL-Code über Benutzereingaben einschleust**, um Datenbankabfragen zu manipulieren.
Ursache ist meist das **direkte Einfügen von Benutzereingaben in SQL-Statements**.

---

## Unsicheres Beispiel (anfällig)

```php
<?php
$email = $_POST['email'];

$sql = "SELECT * FROM users WHERE email = '$email'";
$result = $pdo->query($sql);
```

**Angreifer-Eingabe:**

```
' OR 1=1 --
```

**Resultierendes SQL:**

```sql
SELECT * FROM users WHERE email = '' OR 1=1 --'
```

→ Gibt **alle Benutzer** zurück.

---

## Typische Auswirkungen

* Umgehung von Login-Mechanismen
* Zugriff auf fremde Daten
* Datenmanipulation (`UPDATE`, `DELETE`)
* Kompletter Datenbankverlust

---

## Sichere Lösung: Prepared Statements (PDO)

```php
<?php
$stmt = $pdo->prepare(
    'SELECT * FROM users WHERE email = :email'
);
$stmt->execute([
    'email' => $email
]);

$user = $stmt->fetch();
```

**Warum sicher:**

* SQL-Code und Daten sind strikt getrennt
* Eingaben werden **nicht als SQL interpretiert**

---

## Beispiel mit Login

```php
<?php
$stmt = $pdo->prepare(
    'SELECT id, password_hash FROM users WHERE email = :email'
);
$stmt->execute(['email' => $email]);

$user = $stmt->fetch();
```

* Selbst bei bösartiger Eingabe bleibt das SQL unverändert

---

## Wichtige Ergänzungen

* **Escaping allein reicht nicht**
* **Validation ersetzt keinen SQL-Schutz**
* ORMs (Doctrine, Eloquent) nutzen intern Prepared Statements
* Auch bei `LIMIT`, `ORDER BY` auf Whitelists achten

---

## Häufige Fehler

* String-Konkatenation im SQL
* Vertrauen auf `addslashes()`
* Dynamische SQL-Teile ohne Whitelist
* Annahme: „POST ist sicher“

---

### Zusammenfassung

* SQL Injection = Einschleusen von SQL-Code über Eingaben
* Entsteht durch unsichere SQL-Konstruktion
* **Prepared Statements sind Pflicht**
* PDO und ORMs schützen zuverlässig
* Zentrale Sicherheitsanforderung im Backend

**Weiterführende Doku:**

* PHP PDO Prepared Statements:
  [https://www.php.net/manual/en/pdo.prepared-statements.php](https://www.php.net/manual/en/pdo.prepared-statements.php)
* OWASP SQL Injection:
  [https://owasp.org/www-community/attacks/SQL_Injection](https://owasp.org/www-community/attacks/SQL_Injection)

  **[⬆ Наверх](#top)**

32. ### <a name="32"></a> Was ist XSS?

## Was ist XSS?

### Definition

**XSS (Cross-Site Scripting)** ist eine **Sicherheitslücke**, bei der Angreifer **schädlichen JavaScript-Code in eine Webseite einschleusen**, der anschließend **im Browser anderer Benutzer ausgeführt** wird.

Ursache ist fast immer **fehlendes oder falsches Escaping von Benutzereingaben bei der Ausgabe**.

---

## Grundprinzip

1. Benutzer gibt manipulierte Daten ein (z. B. Kommentar, Formularfeld).
2. Server speichert oder gibt diese Daten **ungefiltert** zurück.
3. Browser interpretiert den Inhalt als **JavaScript**.
4. Code läuft im **Sicherheitskontext der Webseite**.

---

## Einfaches Beispiel (unsicher)

```php
<?php
// UNSICHER
echo $_GET['name'];
```

**Aufruf:**

```
/page.php?name=<script>alert('XSS')</script>
```

→ JavaScript wird im Browser ausgeführt.

---

## Sichere Variante: Output Escaping

```php
<?php
echo htmlspecialchars(
    $_GET['name'] ?? '',
    ENT_QUOTES | ENT_SUBSTITUTE,
    'UTF-8'
);
```

* HTML-Sonderzeichen werden entschärft
* Script wird als Text angezeigt, nicht ausgeführt

---

## Arten von XSS

### 1) Reflected XSS

* Code kommt direkt aus dem Request
* Kein Persistieren

Beispiel:

```
/search?q=<script>...</script>
```

---

### 2) Stored XSS (besonders gefährlich)

* Code wird **in DB gespeichert**
* Wird später an andere Benutzer ausgeliefert

Typisch:

* Kommentare
* Foren
* Profile

---

### 3) DOM-based XSS

* Entsteht **rein im Frontend (JavaScript)**
* Server ist nicht direkt beteiligt

---

## Typische Angriffsmöglichkeiten

* Session-Cookies auslesen
* Benutzeraktionen ausführen (CSRF-Kombination)
* Phishing
* Weiterleitung auf Schadseiten

---

## Schutzmaßnahmen (Best Practices)

### 1) Kontextabhängiges Escaping

* **HTML** → `htmlspecialchars()`
* **Attribute** → ebenfalls `htmlspecialchars()`
* **JavaScript** → JSON-Encoding
* **URLs** → `rawurlencode()`

---

### 2) Keine Roh-Ausgabe von Benutzerdaten

```php
// niemals:
echo $comment;
```

---

### 3) Framework-Schutz

* **Twig (Symfony)** → Auto-Escaping aktiv
* **Blade (Laravel)** → `{{ }}` escaped automatisch

```twig
{{ user.name }}
```

---

### 4) Content Security Policy (CSP)

HTTP-Header zur Einschränkung von Skripten.

---

## Wichtig: XSS ≠ SQL Injection

* **XSS** → Angriff auf **Browser / Benutzer**
* **SQL Injection** → Angriff auf **Datenbank / Server**

---

### Zusammenfassung

* XSS bedeutet Ausführung von fremdem JavaScript im Browser
* Ursache: fehlendes Escaping bei der Ausgabe
* Besonders gefährlich: Stored XSS
* Schutz erfolgt **bei der Ausgabe**, nicht primär bei der Speicherung
* Frameworks bieten Auto-Escaping, aber nur bei korrekter Nutzung

**Weiterführende Doku:**

* OWASP XSS:
  [https://owasp.org/www-community/attacks/xss/](https://owasp.org/www-community/attacks/xss/)
* PHP `htmlspecialchars()`:
  [https://www.php.net/manual/en/function.htmlspecialchars.php](https://www.php.net/manual/en/function.htmlspecialchars.php)

  **[⬆ Наверх](#top)**

33. ### <a name="33"></a> Wie speichert man Passwörter sicher?

## Wie speichert man Passwörter sicher?

### Grundprinzip

Passwörter dürfen **niemals im Klartext** gespeichert werden.
Stattdessen werden sie **gehasht** – mit einem **langsamen, sicheren Passwort-Hashing-Algorithmus**.

In PHP ist der **Standardweg**:

* `password_hash()`
* `password_verify()`

---

## Sicheres Hashing mit `password_hash()`

```php
<?php
$password = 'secret123';

$hash = password_hash($password, PASSWORD_DEFAULT);
```

**Eigenschaften:**

* Nutzt aktuell **bcrypt** oder **Argon2** (abhängig von PHP-Version)
* Automatisches Salt
* Sicher gegen Rainbow-Table-Angriffe
* Empfohlen vom PHP-Core-Team

---

## Passwort prüfen mit `password_verify()`

```php
<?php
if (password_verify($password, $hash)) {
    // Passwort korrekt
}
```

* Kein eigener Vergleich nötig
* Schutz vor Timing-Attacken
* Funktioniert auch bei Algorithmus-Wechsel

---

## Passwort-Update (Rehashing)

```php
<?php
if (password_needs_rehash($hash, PASSWORD_DEFAULT)) {
    $hash = password_hash($password, PASSWORD_DEFAULT);
}
```

* Wichtig bei:

  * PHP-Upgrades
  * Änderung der Kosten (`cost`)
* Best Practice in produktiven Systemen

---

## Was man **nicht** tun darf

❌ **Unsicher**

```php
md5($password);
sha1($password);
hash('sha256', $password);
```

**Warum?**

* Zu schnell
* Kein eingebautes Salt
* Leicht angreifbar (Brute Force)

---

## Warum langsames Hashing wichtig ist

* Angreifer probieren Millionen Passwörter pro Sekunde
* Passwort-Hashing-Algorithmen sind **bewusst langsam**
* Erschwert Brute-Force- und Dictionary-Angriffe massiv

---

## Umgang mit Passwort-Resets

* Passwörter **nicht entschlüsseln**
* Reset über:

  * zufälligen Token
  * zeitlich begrenzten Link
* Neues Passwort **neu hashen**

---

## Framework-Unterstützung

### Symfony

```php
$passwordHasher->hashPassword($user, $plainPassword);
```

Quelle:
[https://symfony.com/doc/current/security/passwords.html](https://symfony.com/doc/current/security/passwords.html)

---

### Laravel

```php
Hash::make($password);
Hash::check($password, $hash);
```

Quelle:
[https://laravel.com/docs/hashing](https://laravel.com/docs/hashing)

---

## Zusätzliche Sicherheitsmaßnahmen

* HTTPS erzwingen
* Rate Limiting bei Login
* Starke Passwort-Regeln
* Optional: 2FA

---

### Zusammenfassung

* Passwörter **niemals im Klartext speichern**
* Immer `password_hash()` + `password_verify()` verwenden
* Keine eigenen Hash-Lösungen bauen
* Rehashing bei Bedarf durchführen
* Frameworks nutzen sichere Defaults

**Weiterführende Doku:**

* PHP Password Hashing:
  [https://www.php.net/manual/en/book.password.php](https://www.php.net/manual/en/book.password.php)
* OWASP Password Storage:
  [https://owasp.org/www-project-cheat-sheets/cheatsheets/Password_Storage_Cheat_Sheet.html](https://owasp.org/www-project-cheat-sheets/cheatsheets/Password_Storage_Cheat_Sheet.html)

  **[⬆ Наверх](#top)**

34. ### <a name="34"></a> Wozu dient htmlspecialchars()?

## Wozu dient `htmlspecialchars()`?

### Zweck

`htmlspecialchars()` dient dem **Schutz vor Cross-Site Scripting (XSS)**, indem es **HTML-Sonderzeichen in sichere HTML-Entities umwandelt**.
Dadurch wird verhindert, dass Benutzereingaben als HTML oder JavaScript interpretiert werden.

---

### Grundprinzip

Gefährliche Zeichen werden ersetzt, z. B.:

| Zeichen | Wird zu  |
| ------- | -------- |
| `<`     | `&lt;`   |
| `>`     | `&gt;`   |
| `"`     | `&quot;` |
| `'`     | `&#039;` |
| `&`     | `&amp;`  |

---

### Unsicheres Beispiel

```php
echo $_GET['name'];
```

Aufruf:

```
/page.php?name=<script>alert('XSS')</script>
```

→ JavaScript wird ausgeführt.

---

### Sichere Ausgabe mit `htmlspecialchars()`

```php
echo htmlspecialchars(
    $_GET['name'] ?? '',
    ENT_QUOTES | ENT_SUBSTITUTE,
    'UTF-8'
);
```

* Script wird **als Text angezeigt**
* Keine Ausführung im Browser

---

### Wichtige Parameter

```php
htmlspecialchars(string $string, int $flags, ?string $encoding)
```

**Empfohlene Flags:**

* `ENT_QUOTES` → escaped `'` und `"`
* `ENT_SUBSTITUTE` → ersetzt ungültige UTF-8-Zeichen

**Encoding:**

* Immer explizit `'UTF-8'` setzen

---

### Wann verwenden?

* **Bei der Ausgabe in HTML**
* Bei:

  * Formularwerten
  * Kommentaren
  * Usernamen
  * Daten aus der Datenbank

```php
<input value="<?= htmlspecialchars($value, ENT_QUOTES, 'UTF-8') ?>">
```

---

### Wann **nicht** verwenden?

* **Nicht** vor dem Speichern in der Datenbank
* **Nicht** als Ersatz für SQL-Schutz
* **Nicht** für JSON-Ausgaben

Für JSON:

```php
json_encode($data);
```

---

### Framework-Hinweis

* **Symfony (Twig)**: Auto-Escaping standardmäßig aktiv
* **Laravel (Blade)**: `{{ }}` escaped automatisch

```twig
{{ user.name }}
```

---

### Zusammenfassung

* `htmlspecialchars()` schützt vor XSS
* Escaped HTML-Sonderzeichen bei der **Ausgabe**
* Sollte **immer** mit `ENT_QUOTES` und `UTF-8` genutzt werden
* Kein Ersatz für SQL-Schutz oder Validierung
* Frameworks übernehmen Escaping oft automatisch

**Weiterführende Doku:**

* PHP `htmlspecialchars()`:
  [https://www.php.net/manual/en/function.htmlspecialchars.php](https://www.php.net/manual/en/function.htmlspecialchars.php)
* OWASP XSS:
  [https://owasp.org/www-community/attacks/xss/](https://owasp.org/www-community/attacks/xss/)

  **[⬆ Наверх](#top)**

35. ### <a name="35"></a> Wie funktioniert PHP intern (Zend Engine)?

## Wie funktioniert PHP intern (Zend Engine)?

### Überblick

Die **Zend Engine** ist das **Herz von PHP**.
Sie ist für das **Parsen, Kompilieren und Ausführen** von PHP-Code verantwortlich sowie für **Speicherverwaltung** und **Garbage Collection**.

---

## Verarbeitungs-Pipeline (vereinfacht)

1. **PHP-Code (Text)**
2. **Lexer** → zerlegt Code in Tokens
3. **Parser** → baut einen Abstract Syntax Tree (AST)
4. **Compiler** → erzeugt **Opcodes**
5. **Zend Virtual Machine (VM)** → führt Opcodes aus
6. **Output** → HTML / JSON / etc.

---

## 1) Lexer & Parser

* **Lexer** erkennt Tokens wie `T_VARIABLE`, `T_FUNCTION`
* **Parser** prüft Syntax und erstellt den **AST**

Beispiel:

```php
$a = 1 + 2;
```

→ AST repräsentiert die Struktur (Zuweisung, Addition)

---

## 2) Opcodes

Der Compiler übersetzt den AST in **Opcodes** (Zwischencode).

Beispiel (vereinfacht):

```
ASSIGN
ADD
RETURN
```

* Opcodes sind **maschinenunabhängig**
* Werden von der Zend VM interpretiert

---

## 3) Zend Virtual Machine (VM)

* Führt Opcodes **sequentiell** aus
* Implementiert als Stack-basierte VM
* Jede PHP-Anfrage startet eine **neue VM-Instanz**

---

## 4) Speicherverwaltung

* PHP nutzt **Referenzzählung**
* **Copy-on-Write** verhindert unnötige Kopien
* Arrays werden erst kopiert, wenn sie verändert werden

Beispiel:

```php
$a = [1, 2, 3];
$b = $a;      // keine Kopie
$b[] = 4;     // jetzt Kopie
```

---

## 5) Garbage Collection

* Entfernt **zyklische Referenzen**
* Ergänzt Referenzzählung
* Wichtig bei Objekten mit gegenseitigen Referenzen

---

## 6) OPcache (Performance)

* Zwischenspeichert **Opcodes**
* Vermeidet erneutes Parsen & Kompilieren
* Massive Performance-Verbesserung

Ablauf mit OPcache:

```
PHP-Datei → einmal kompilieren → Opcodes im Cache → wiederverwenden
```

---

## Wichtige Eigenschaften der Zend Engine

* **Request-basiert** (kein Shared State)
* **Single-Threaded pro Request**
* Stark optimiert für Web-Workloads
* Grundlage für alle PHP-Versionen (PHP 7, 8)

---

## Relevanz im Interview

Erwartet wird:

* Kein C-Level-Wissen
* Verständnis von:

  * Opcodes
  * OPcache
  * Request-basierter Ausführung
  * Copy-on-Write

---

### Zusammenfassung

* Zend Engine ist die PHP-Laufzeitumgebung
* PHP-Code → Tokens → AST → Opcodes → Zend VM
* OPcache speichert Opcodes für Performance
* Speicherverwaltung über Referenzzählung + GC
* Zentrale Grundlage für PHP-Performance

**Weiterführende Doku:**

* PHP Internals Book:
  [https://www.phpinternalsbook.com/](https://www.phpinternalsbook.com/)
* OPcache:
  [https://www.php.net/manual/en/book.opcache.php](https://www.php.net/manual/en/book.opcache.php)

  **[⬆ Наверх](#top)**

36. ### <a name="36"></a> Was ist OPcache und wozu dient es?

## Was ist OPcache und wozu dient es?

### Definition

**OPcache** ist eine **PHP-Erweiterung**, die **kompilierte PHP-Opcodes im Speicher zwischenspeichert**.
Dadurch müssen PHP-Dateien **nicht bei jedem Request neu geparst und kompiliert** werden.

Ziel: **deutlich bessere Performance und geringere Serverlast**.

---

## Problem ohne OPcache

Bei jedem HTTP-Request:

1. PHP-Datei lesen
2. Code parsen
3. AST erstellen
4. Opcodes generieren
5. Opcodes ausführen

→ Viel Overhead, besonders bei vielen Requests.

---

## Lösung mit OPcache

Mit OPcache:

1. PHP-Datei **einmal** parsen & kompilieren
2. Opcodes im **Shared Memory** speichern
3. Bei weiteren Requests **direkt aus dem Cache ausführen**

```
PHP-Code → Opcodes → OPcache → Zend VM
```

---

## Performance-Effekt

* Weniger CPU-Last
* Schnellere Response-Zeiten
* Standard in Produktivsystemen
* Besonders wichtig bei Frameworks (Symfony, Laravel)

---

## Aktivierung (typisch)

```ini
opcache.enable=1
opcache.enable_cli=0
opcache.memory_consumption=128
opcache.max_accelerated_files=10000
```

In vielen Hosting-Umgebungen **standardmäßig aktiv**.

---

## Wichtige Einstellungen (Interview-relevant)

* `opcache.enable`
  → OPcache an/aus

* `opcache.memory_consumption`
  → Größe des Shared Memory (z. B. 128 MB)

* `opcache.validate_timestamps`

  * `1` → prüft Dateiänderungen (Dev)
  * `0` → keine Prüfung (Prod)

* `opcache.revalidate_freq`
  → Intervall für Datei-Checks

---

## Development vs. Production

**Development**

```ini
opcache.validate_timestamps=1
opcache.revalidate_freq=0
```

**Production**

```ini
opcache.validate_timestamps=0
```

→ In Prod nach Deploy:

```bash
php -r "opcache_reset();"
```

---

## Was OPcache **nicht** ist

* Kein Daten-Cache (kein Redis)
* Kein HTTP-Cache
* Kein Ersatz für Application-Caching

OPcache cached **nur PHP-Opcodes**.

---

## OPcache & PHP-FPM

* Shared Memory zwischen PHP-FPM-Workern
* Ein kompiliertes Script → für alle Worker nutzbar
* Sehr effizient bei hoher Last

---

### Zusammenfassung

* OPcache cached **kompilierte Opcodes**
* Vermeidet erneutes Parsen & Kompilieren
* Massive Performance-Verbesserung
* Standard für produktive PHP-Systeme
* Kein Ersatz für Redis oder HTTP-Caching

**Weiterführende Doku:**

* PHP OPcache:
  [https://www.php.net/manual/en/book.opcache.php](https://www.php.net/manual/en/book.opcache.php)

  **[⬆ Наверх](#top)**

37. ### <a name="37"></a> Unterschied zwischen require und include

## Unterschied zwischen `require` und `include`

### Grundidee

`require` und `include` werden verwendet, um **PHP-Dateien einzubinden**.
Der entscheidende Unterschied liegt im **Fehlerverhalten**, wenn die Datei **nicht gefunden** wird.

---

## `require`

```php
require 'config.php';
```

**Verhalten:**

* Bei Fehler → **Fatal Error**
* Script wird **sofort beendet**
* Programm kann nicht weiterlaufen

**Typischer Einsatz:**

* Zentrale Dateien:

  * Konfiguration
  * Autoloader
  * Kern-Komponenten
* Alles, ohne das die Anwendung **nicht sinnvoll funktioniert**

---

## `include`

```php
include 'header.php';
```

**Verhalten:**

* Bei Fehler → **Warning**
* Script läuft **weiter**

**Typischer Einsatz:**

* Optionale Templates
* UI-Komponenten
* Nicht-kritische Dateien

---

## Vergleich auf einen Blick

| Aspekt            | `require`   | `include` |
| ----------------- | ----------- | --------- |
| Fehlerart         | Fatal Error | Warning   |
| Script-Abbruch    | ✔           | ✘         |
| Kritische Dateien | ✔           | ✘         |
| Optionale Dateien | ✘           | ✔         |

---

## `require_once` / `include_once`

```php
require_once 'vendor/autoload.php';
include_once 'helpers.php';
```

* Datei wird **nur einmal** eingebunden
* Verhindert:

  * Funktions-Neudefinition
  * Klassenkonflikte

**Hinweis:**
`*_once` ist minimal langsamer, aber sicherer.

---

## Rückgabewert

* `include` und `require` geben den Rückgabewert der eingebundenen Datei zurück
* Oder `1` bei Erfolg

```php
$config = require 'config.php';
```

```php
// config.php
return [
    'db_host' => 'localhost'
];
```

---

## Best Practice

* Für Pflichtdateien → **`require_once`**
* Für optionale Templates → **`include`**
* In modernen Projekten:

  * **Composer Autoloading statt manueller Includes**

---

### Zusammenfassung

* `require` bricht das Script bei Fehler ab
* `include` erzeugt nur eine Warnung
* `*_once` verhindert Mehrfach-Einbindung
* `require_once` ist Standard für Kern-Dateien
* Autoloading ersetzt manuelle Includes

**Weiterführende Doku:**

* PHP include/require:
  [https://www.php.net/manual/en/function.require.php](https://www.php.net/manual/en/function.require.php)

  **[⬆ Наверх](#top)**

38. ### <a name="38"></a> Was ist Autoloading und was bedeutet PSR-4?

## Was ist Autoloading und was bedeutet PSR-4?

### Autoloading – Grundidee

**Autoloading** bedeutet, dass PHP **Klassen automatisch lädt**, sobald sie benötigt werden – **ohne manuelle `require`/`include`-Aufrufe**.

PHP nutzt dafür die Funktion `spl_autoload_register()`; in der Praxis wird fast immer **Composer** verwendet.

---

## Problem ohne Autoloading

```php
require 'User.php';
require 'UserRepository.php';
require 'UserService.php';
```

* Unübersichtlich
* Fehleranfällig
* Schlechte Wartbarkeit

---

## Autoloading mit Composer

```php
require __DIR__ . '/vendor/autoload.php';
```

* Registriert einen Autoloader
* Klassen werden **on demand** geladen
* Standard in modernen PHP-Projekten

**Composer Docs:**
[https://getcomposer.org/doc/01-basic-usage.md#autoloading](https://getcomposer.org/doc/01-basic-usage.md#autoloading)

---

## PSR-4 – Definition

**PSR-4** ist ein Standard der **PHP-FIG**, der festlegt:

> Wie **Namespaces** auf **Verzeichnisstrukturen** abgebildet werden.

Ziel:

* Einheitliche Projektstruktur
* Vorhersehbares Autoloading
* Interoperabilität zwischen Frameworks

**PSR-4 Spec:**
[https://www.php-fig.org/psr/psr-4/](https://www.php-fig.org/psr/psr-4/)

---

## PSR-4: Namespace → Datei

### Regel

```text
Namespace\Sub\Class  →  src/Sub/Class.php
```

### Beispiel

```php
// src/Service/UserService.php
namespace App\Service;

class UserService {}
```

```php
use App\Service\UserService;

$service = new UserService();
```

Composer weiß, wo die Datei liegt.

---

## PSR-4 Konfiguration in `composer.json`

```json
{
  "autoload": {
    "psr-4": {
      "App\\": "src/"
    }
  }
}
```

Nach Änderung:

```bash
composer dump-autoload
```

---

## Wie Composer Autoloading funktioniert (vereinfacht)

1. Klasse wird referenziert
2. Composer-Autoloader prüft Namespace
3. Namespace wird auf Pfad gemappt
4. Datei wird geladen
5. Klasse steht zur Verfügung

---

## Vorteile von PSR-4

* Keine manuellen Includes
* Saubere Ordnerstruktur
* Standard in Symfony & Laravel
* Einfaches Refactoring
* IDE-Support

---

## Typische Fehler

* Falscher Namespace
* Dateiname ≠ Klassenname
* Fehlender `dump-autoload`
* Groß-/Kleinschreibung (Linux!)

---

### Zusammenfassung

* Autoloading lädt Klassen **automatisch bei Bedarf**
* Composer ist der Standard-Autoloader
* PSR-4 definiert die Zuordnung Namespace ↔ Dateipfad
* Symfony und Laravel basieren vollständig auf PSR-4
* Grundlage für moderne PHP-Architektur

**Weiterführende Doku:**

* Composer Autoloading:
  [https://getcomposer.org/doc/01-basic-usage.md#autoloading](https://getcomposer.org/doc/01-basic-usage.md#autoloading)
* PSR-4 Standard:
  [https://www.php-fig.org/psr/psr-4/](https://www.php-fig.org/psr/psr-4/)

  **[⬆ Наверх](#top)**

39. ### <a name="39"></a> Was sind Namespaces und warum sind sie wichtig?

## Was sind Namespaces und warum sind sie wichtig?

### Definition

**Namespaces** sind Namensräume, die es erlauben, **Klassen, Interfaces, Funktionen und Konstanten logisch zu gruppieren** und **Namenskonflikte zu vermeiden**.

Sie sind ein zentrales Konzept in **modernen PHP-Anwendungen**.

---

## Problem ohne Namespaces

```php
class User {}
class User {} // Fatal Error
```

* Gleicher Klassenname → Konflikt
* Besonders problematisch bei großen Projekten und Libraries

---

## Lösung mit Namespaces

```php
namespace App\Model;

class User {}
```

```php
namespace App\Admin;

class User {}
```

* Gleiche Klassennamen möglich
* Eindeutig durch Namespace

---

## Verwendung von Namespaces

### Definition

```php
namespace App\Service;

class UserService {}
```

* `namespace` muss **am Anfang der Datei** stehen

---

### Verwendung mit `use`

```php
use App\Service\UserService;

$service = new UserService();
```

* Kürzerer, lesbarer Code
* Wichtig für saubere Imports

---

### Vollqualifizierter Name

```php
$service = new \App\Service\UserService();
```

* Beginnend mit `\`
* Umgeht `use`

---

## Namespaces & Autoloading (PSR-4)

Namespaces sind die Grundlage für **PSR-4 Autoloading**:

```text
App\Service\UserService
→ src/Service/UserService.php
```

* Namespace spiegelt Ordnerstruktur
* Composer lädt Klassen automatisch

---

## Namespaces für Funktionen & Konstanten

```php
namespace App\Util;

function formatDate() {}

const VERSION = '1.0';
```

---

## Typische Anwendungsbereiche

* Trennung von:

  * Domain
  * Services
  * Controller
  * Infrastruktur
* Vendor-Code vs. eigener Code
* Große Teams / große Codebases

---

## Best Practices

* Ein Namespace pro Datei
* Namespace = Ordnerstruktur
* Kein globaler Namespace für Applikationscode
* Konsistente Benennung (`App\...`)

---

### Zusammenfassung

* Namespaces verhindern Namenskonflikte
* Ermöglichen saubere Code-Struktur
* Grundlage für PSR-4 und Autoloading
* Unverzichtbar in Frameworks und Libraries
* Erhöhen Wartbarkeit und Lesbarkeit

**Weiterführende Doku:**

* PHP Namespaces:
  [https://www.php.net/manual/en/language.namespaces.php](https://www.php.net/manual/en/language.namespaces.php)

  **[⬆ Наверх](#top)**

40. ### <a name="40"></a> Was bedeuten die SOLID-Prinzipien?

## Was bedeuten die SOLID-Prinzipien?

**SOLID** ist ein Satz von **fünf OOP-Designprinzipien**, die helfen, **wartbaren, testbaren und erweiterbaren Code** zu schreiben.

---

## S — Single Responsibility Principle (SRP)

**Eine Klasse hat genau eine Verantwortung.**

```php
class User {
    public function changeEmail(string $email): void {}
}

// Ausgelagert:
class EmailValidator {
    public function isValid(string $email): bool {}
}
```

* Jede Klasse hat **einen Grund zur Änderung**
* Fördert klare Zuständigkeiten

---

## O — Open/Closed Principle (OCP)

**Offen für Erweiterung, geschlossen für Änderung.**

```php
interface Discount {
    public function apply(float $price): float;
}

class BlackFridayDiscount implements Discount {
    public function apply(float $price): float {
        return $price * 0.8;
    }
}
```

* Neue Funktionalität durch **neue Klassen**
* Bestehender Code bleibt unverändert

---

## L — Liskov Substitution Principle (LSP)

**Subklassen müssen ihre Basisklasse korrekt ersetzen können.**

```php
function printArea(Shape $shape): float {
    return $shape->area();
}
```

* Keine unerwarteten Seiteneffekte
* Gleiche Erwartungen an Verhalten & Rückgabewerte

---

## I — Interface Segregation Principle (ISP)

**Viele kleine Interfaces statt eines großen.**

```php
interface Readable {
    public function read(): string;
}

interface Writable {
    public function write(string $data): void;
}
```

* Klassen implementieren **nur das, was sie brauchen**
* Vermeidet „fette“ Interfaces

---

## D — Dependency Inversion Principle (DIP)

**Abhängigkeiten zu Abstraktionen, nicht zu konkreten Klassen.**

```php
class UserService {
    public function __construct(private UserRepositoryInterface $repo) {}
}
```

* Abhängigkeiten per **Interface**
* Ermöglicht Austauschbarkeit & Testbarkeit (Mocks)

---

## Zusammenhang mit Frameworks

* **Symfony/Laravel** setzen SOLID konsequent ein:

  * Controller → SRP
  * Services → DIP
  * Contracts/Interfaces → ISP & OCP

---

### Zusammenfassung

* **SRP**: eine Verantwortung pro Klasse
* **OCP**: erweitern ohne ändern
* **LSP**: Subklassen verhalten sich korrekt
* **ISP**: kleine, spezialisierte Interfaces
* **DIP**: Abhängigkeiten über Interfaces

SOLID ist **kein Dogma**, sondern ein **Werkzeug**, um sauberen, skalierbaren PHP-Code zu schreiben.

**Weiterführende Doku:**

* SOLID Überblick (Symfony Best Practices):
  [https://symfony.com/doc/current/best_practices.html](https://symfony.com/doc/current/best_practices.html)
* SOLID Principles (Allgemein):
  [https://en.wikipedia.org/wiki/SOLID](https://en.wikipedia.org/wiki/SOLID)

  **[⬆ Наверх](#top)**  

41. ### <a name="41"></a> Was ist Dependency Injection?

## Was ist Dependency Injection?

### Definition

**Dependency Injection (DI)** ist ein Entwurfsmuster, bei dem eine Klasse ihre **Abhängigkeiten von außen erhält**, anstatt sie selbst zu erzeugen.
Ziel ist **lose Kopplung**, **bessere Testbarkeit** und **austauschbare Implementierungen**.

---

## Problem ohne Dependency Injection

```php
class UserService {
    private UserRepository $repo;

    public function __construct() {
        $this->repo = new UserRepository(); // feste Abhängigkeit
    }
}
```

* Starke Kopplung
* Schwer zu testen
* Austausch der Implementierung kaum möglich

---

## Lösung mit Dependency Injection

```php
class UserService {
    public function __construct(
        private UserRepositoryInterface $repo
    ) {}
}
```

```php
$service = new UserService(new UserRepository());
```

* Abhängigkeit wird **injiziert**
* Klasse kennt nur das **Interface**

---

## Arten von Dependency Injection

### 1) Constructor Injection (empfohlen)

```php
class OrderService {
    public function __construct(
        private PaymentGateway $gateway
    ) {}
}
```

* Pflichtabhängigkeiten
* Immutable nach Konstruktion
* Standard in modernen Projekten

---

### 2) Setter Injection

```php
class LoggerAwareService {
    private Logger $logger;

    public function setLogger(Logger $logger): void {
        $this->logger = $logger;
    }
}
```

* Optionale Abhängigkeiten
* Gefahr unvollständiger Initialisierung

---

### 3) Method Injection

```php
class ReportService {
    public function generate(Logger $logger): void {
        // ...
    }
}
```

* Abhängigkeit nur für eine Methode
* Weniger verbreitet

---

## Dependency Injection & SOLID

* **DIP** (Dependency Inversion Principle) wird umgesetzt
* Abhängigkeit von **Abstraktionen (Interfaces)**

---

## Dependency Injection Container

Frameworks nutzen einen **DI-Container**, der:

* Objekte erstellt
* Abhängigkeiten auflöst
* Lifecycle verwaltet

---

### Beispiel: Symfony

```php
class UserController {
    public function __construct(
        private UserService $service
    ) {}
}
```

* Symfony injiziert `UserService` automatisch

**Docs:**
[https://symfony.com/doc/current/service_container.html](https://symfony.com/doc/current/service_container.html)

---

### Beispiel: Laravel

```php
class UserController {
    public function __construct(UserService $service) {}
}
```

* Laravel löst Abhängigkeiten automatisch

**Docs:**
[https://laravel.com/docs/container](https://laravel.com/docs/container)

---

## Vorteile von Dependency Injection

* Lose Kopplung
* Bessere Testbarkeit (Mocks)
* Austauschbare Implementierungen
* Klarere Architektur

---

### Zusammenfassung

* Dependency Injection = Abhängigkeiten von außen übergeben
* Klassen erzeugen ihre Dependencies nicht selbst
* Constructor Injection ist Best Practice
* DI ist zentral für SOLID (DIP)
* Frameworks nutzen DI-Container standardmäßig

**Weiterführende Doku:**

* Symfony DI Container:
  [https://symfony.com/doc/current/service_container.html](https://symfony.com/doc/current/service_container.html)
* Laravel Service Container:
  [https://laravel.com/docs/container](https://laravel.com/docs/container)

  **[⬆ Наверх](#top)**

42. ### <a name="42"></a> Unterschied zwischen Komposition und Vererbung

## Unterschied zwischen Komposition und Vererbung

### Grundidee

Beide Konzepte dienen der **Wiederverwendung von Code**, verfolgen aber unterschiedliche Ansätze:

* **Vererbung** → *is-a*-Beziehung (ist ein …)
* **Komposition** → *has-a*-Beziehung (hat ein …)

---

## Vererbung (`extends`)

### Prinzip

Eine Klasse **erbt** Eigenschaften und Methoden einer Basisklasse.

```php
class User {
    public function getRole(): string {
        return 'USER';
    }
}

class Admin extends User {
    public function getRole(): string {
        return 'ADMIN';
    }
}
```

**Eigenschaften:**

* Enge Kopplung
* Kindklasse ist stark an Basisklasse gebunden
* Änderungen in der Basisklasse wirken sich auf alle Kinder aus
* Nur **eine** Basisklasse möglich

**Wann sinnvoll:**

* Echte *is-a*-Beziehung
* Klare, stabile Hierarchie
* Framework-Basisklassen

---

## Komposition

### Prinzip

Eine Klasse **nutzt andere Klassen als Abhängigkeiten**, statt sie zu erben.

```php
class Logger {
    public function log(string $message): void {}
}

class UserService {
    public function __construct(
        private Logger $logger
    ) {}

    public function createUser(): void {
        $this->logger->log('User created');
    }
}
```

**Eigenschaften:**

* Lose Kopplung
* Abhängigkeiten austauschbar
* Mehr Flexibilität
* Sehr gut testbar (Mocks)

**Wann sinnvoll:**

* Wiederverwendung von Verhalten
* Austauschbare Implementierungen
* Service- und Domain-Logik

---

## Vergleich auf einen Blick

| Aspekt          | Vererbung         | Komposition |
| --------------- | ----------------- | ----------- |
| Beziehung       | *is-a*            | *has-a*     |
| Kopplung        | Stark             | Lose        |
| Flexibilität    | Geringer          | Hoch        |
| Testbarkeit     | Eingeschränkt     | Sehr gut    |
| Mehrfachnutzung | ❌                 | ✔           |
| SOLID-konform   | Oft problematisch | Sehr gut    |

---

## Best Practice in PHP

* **Komposition bevorzugen**
* Vererbung **sparsam und gezielt** einsetzen
* Abhängigkeiten über **Interfaces + DI**

Beispiel mit Interface:

```php
interface LoggerInterface {
    public function log(string $message): void;
}

class FileLogger implements LoggerInterface {}
class NullLogger implements LoggerInterface {}

class UserService {
    public function __construct(
        private LoggerInterface $logger
    ) {}
}
```

---

### Zusammenfassung

* **Vererbung**: „ist ein …“, enge Kopplung, wenig flexibel
* **Komposition**: „hat ein …“, lose Kopplung, sehr flexibel
* Moderne PHP-Architekturen bevorzugen **Komposition**
* Vererbung nur bei klarer, stabiler Hierarchie einsetzen

**Weiterführende Doku:**

* PHP OOP – Inheritance:
  [https://www.php.net/manual/en/language.oop5.inheritance.php](https://www.php.net/manual/en/language.oop5.inheritance.php)
* Symfony Best Practices (Design):
  [https://symfony.com/doc/current/best_practices.html](https://symfony.com/doc/current/best_practices.html)

  **[⬆ Наверх](#top)**

43. ### <a name="43"></a> Wofür werden final, static und readonly verwendet?

## Wofür werden `final`, `static` und `readonly` verwendet?

Diese Schlüsselwörter steuern **Erweiterbarkeit**, **Lebensdauer/Zugriff** und **Mutierbarkeit** von Klassen, Methoden und Properties.

---

## `final`

### Zweck

Verhindert **Vererbung** oder **Überschreiben**.

### Verwendung

**Klasse sperren:**

```php
final class Config {
}
```

→ Die Klasse kann **nicht** erweitert werden.

**Methode sperren:**

```php
class BaseService {
    final public function execute(): void {
        // feste Logik
    }
}
```

→ Methode kann in Kindklassen **nicht überschrieben** werden.

**Wann sinnvoll**

* Sicherheitskritische Logik
* Stabile APIs
* Framework- oder Core-Komponenten

---

## `static`

### Zweck

Bindet Eigenschaften/Methoden an die **Klasse**, nicht an eine Instanz.

### Statische Methoden

```php
class Math {
    public static function add(int $a, int $b): int {
        return $a + $b;
    }
}

$result = Math::add(2, 3);
```

### Statische Properties

```php
class Counter {
    public static int $count = 0;
}
```

**Eigenschaften**

* Kein `$this`
* Gemeinsamer Zustand für alle Aufrufe
* Erreichbar über `ClassName::method()`

**Achtung**

* Erschwert Testbarkeit
* Globaler Zustand
* In Business-Logik sparsam einsetzen

---

## `readonly` (PHP 8.1+)

### Zweck

Macht Properties **nach Initialisierung unveränderlich** (immutable).

### Verwendung

```php
class User {
    public function __construct(
        public readonly int $id,
        public readonly string $email
    ) {}
}
```

```php
$user = new User(1, 'a@example.com');
$user->email = 'b@example.com'; // ❌ Fehler
```

**Eigenschaften**

* Setzbar **nur im Konstruktor**
* Danach **nicht änderbar**
* Sehr gut für DTOs, Value Objects

---

## Vergleich auf einen Blick

| Keyword    | Wirkung                                       |
| ---------- | --------------------------------------------- |
| `final`    | Verhindert Vererbung / Überschreiben          |
| `static`   | Gehört zur Klasse, nicht zur Instanz          |
| `readonly` | Property ist nach Konstruktion unveränderlich |

---

## Best Practices

* `final` für stabile, nicht erweiterbare Bausteine
* `static` nur für **zustandslose Helper**
* `readonly` für **immutables Datenobjekte**
* Kombiniere `readonly` + Constructor Promotion für sauberen Code

---

### Zusammenfassung

* `final` schützt Klassen/Methoden vor Erweiterung
* `static` ermöglicht klassenweite Nutzung ohne Instanz
* `readonly` erzwingt Immutability von Properties
* Richtiger Einsatz verbessert Sicherheit, Klarheit und Wartbarkeit

**Weiterführende Doku:**

* `final`: [https://www.php.net/manual/en/language.oop5.final.php](https://www.php.net/manual/en/language.oop5.final.php)
* `static`: [https://www.php.net/manual/en/language.oop5.static.php](https://www.php.net/manual/en/language.oop5.static.php)
* `readonly`: [https://www.php.net/manual/en/language.oop5.properties.php#language.oop5.properties.readonly](https://www.php.net/manual/en/language.oop5.properties.php#language.oop5.properties.readonly)

  **[⬆ Наверх](#top)**

44. ### <a name="44"></a> Was sind Magic Methods (__get, __set, __call)?

## Was sind Magic Methods (`__get`, `__set`, `__call`)?

### Definition

**Magic Methods** sind spezielle Methoden in PHP, die **automatisch aufgerufen werden**, wenn auf **nicht vorhandene oder nicht zugängliche** Eigenschaften oder Methoden zugegriffen wird.
Sie beginnen immer mit `__`.

---

## `__get()` – Zugriff auf nicht zugängliche Properties

Wird aufgerufen, wenn auf eine **nicht existente oder nicht sichtbare Property** zugegriffen wird.

```php
class User {
    private array $data = [
        'name' => 'Anna'
    ];

    public function __get(string $key) {
        return $this->data[$key] ?? null;
    }
}

$user = new User();
echo $user->name; // Anna
```

**Einsatz:**

* Dynamische Properties
* Read-only-Zugriffe
* Proxy- oder Wrapper-Klassen

---

## `__set()` – Schreiben auf nicht zugängliche Properties

Wird aufgerufen, wenn eine **nicht existente oder nicht sichtbare Property gesetzt** wird.

```php
class User {
    private array $data = [];

    public function __set(string $key, $value): void {
        $this->data[$key] = $value;
    }
}

$user = new User();
$user->email = 'a@example.com';
```

**Einsatz:**

* Zentrale Validierung
* Dynamische Datenstrukturen
* Mapping (z. B. DTO → Array)

---

## `__call()` – Aufruf nicht existierender Methoden (Objekt)

Wird aufgerufen, wenn eine **nicht existierende oder nicht sichtbare Methode** aufgerufen wird.

```php
class Logger {
    public function __call(string $method, array $arguments) {
        echo "Called {$method}";
    }
}

$logger = new Logger();
$logger->info('test'); // __call wird ausgeführt
```

**Einsatz:**

* Dynamische APIs
* Fluent Interfaces
* Proxy zu anderen Objekten

---

## Verwandt: `__callStatic()`

```php
class Helper {
    public static function __callStatic(string $method, array $args) {
        echo "Static call: {$method}";
    }
}

Helper::run();
```

---

## Vorteile

* Sehr flexible APIs
* Reduziert Boilerplate-Code
* Ermöglicht dynamisches Verhalten

---

## Nachteile

* Schwerer zu debuggen
* Keine statische Analyse / Autocomplete
* Fehler erst zur Laufzeit
* Kann Code undurchsichtig machen

---

## Best Practices

* **Sparsam einsetzen**
* Nicht für Business-Logik
* Gut dokumentieren
* Alternativen bevorzugen:

  * Explizite Methoden
  * DTOs
  * Getter/Setter

---

### Zusammenfassung

* Magic Methods reagieren auf **dynamische Zugriffe**
* `__get` / `__set` → Properties
* `__call` / `__callStatic` → Methoden
* Mächtig, aber potenziell gefährlich
* Für Infrastruktur/Wrapper sinnvoll, nicht für Kernlogik

**Weiterführende Doku:**

* PHP Magic Methods:
  [https://www.php.net/manual/en/language.oop5.magic.php](https://www.php.net/manual/en/language.oop5.magic.php)

  **[⬆ Наверх](#top)**

45. ### <a name="45"></a> Unterschied zwischen Exception und Error

## Unterschied zwischen `Exception` und `Error`

### Grundidee

In PHP sind **`Exception`** und **`Error`** zwei unterschiedliche Arten von **Throwable-Objekten**, die **verschiedene Fehlerklassen** repräsentieren.

Seit PHP 7 implementieren beide das Interface **`Throwable`**.

---

## `Exception`

### Bedeutung

`Exception` steht für **erwartbare, behandelbare Fehler**, die zur Laufzeit auftreten können und **kontrolliert abgefangen** werden sollen.

### Beispiele

* Ungültige Benutzereingaben
* Business-Logik-Fehler
* Fehlende Ressource
* Externe Service-Fehler

```php
throw new InvalidArgumentException('Invalid input');
```

```php
try {
    // ...
} catch (InvalidArgumentException $e) {
    // sinnvoll behandeln
}
```

---

## `Error`

### Bedeutung

`Error` steht für **schwere Programmfehler**, die meist auf **Bugs oder falsche Nutzung der Sprache** hinweisen.

### Beispiele

* Syntaxfehler
* TypeError
* Aufruf nicht existierender Methoden
* Falsche Typen bei `strict_types`

```php
function add(int $a): int {
    return $a;
}

add('test'); // TypeError
```

---

## Hierarchie (vereinfacht)

```
Throwable
├── Exception
│   └── RuntimeException, LogicException, ...
└── Error
    ├── TypeError
    ├── ParseError
    └── ArithmeticError
```

---

## Abfangen von Errors

```php
try {
    riskyCode();
} catch (Throwable $t) {
    // fängt Exception UND Error
}
```

* In Frameworks oft globales Error-Handling
* Im Business-Code eher gezielt `Exception` fangen

---

## Wann was verwenden?

### Eigene Fehler werfen

* **Exception** für:

  * Validierung
  * Business-Regeln
  * Kontrollierbare Fehler

```php
throw new DomainException('User not found');
```

* **Error** **nicht selbst werfen** (außer sehr spezielle Fälle)

---

## Best Practice

* Exceptions für kontrollierte Fehlerflüsse
* Errors als Bugs betrachten
* Globales Exception-/Error-Handling (Middleware)
* Nie Errors als normale Logik verwenden

---

### Zusammenfassung

* Beide implementieren `Throwable`
* `Exception` = erwartbare, behandelbare Fehler
* `Error` = Programmierfehler / Runtime-Probleme
* Business-Logik wirft Exceptions, keine Errors
* Globales Handling fängt beide ab

**Weiterführende Doku:**

* PHP Exceptions:
  [https://www.php.net/manual/en/language.exceptions.php](https://www.php.net/manual/en/language.exceptions.php)
* PHP Errors:
  [https://www.php.net/manual/en/language.errors.php](https://www.php.net/manual/en/language.errors.php)

  **[⬆ Наверх](#top)**

46. ### <a name="46"></a> Wie funktioniert try / catch / finally?

## Wie funktioniert `try / catch / finally`?

### Zweck

`try / catch / finally` dient zur **kontrollierten Fehlerbehandlung** in PHP.
Damit können **Exceptions (und Errors)** abgefangen, behandelt und **Aufräumarbeiten garantiert ausgeführt** werden.

---

## Grundstruktur

```php
try {
    // Code, der eine Exception werfen kann
} catch (ExceptionType $e) {
    // Behandlung der Exception
} finally {
    // Wird immer ausgeführt
}
```

---

## `try`

* Enthält Code, der fehlschlagen kann
* Wenn eine Exception geworfen wird, wird der `try`-Block **sofort verlassen**

```php
try {
    riskyOperation();
}
```

---

## `catch`

* Fängt eine **bestimmte Exception-Klasse**
* Mehrere `catch`-Blöcke sind möglich
* Reihenfolge: **spezifisch → allgemein**

```php
try {
    process($input);
} catch (InvalidArgumentException $e) {
    // Validierungsfehler
} catch (RuntimeException $e) {
    // Laufzeitfehler
}
```

---

## `finally`

* Wird **immer ausgeführt**

  * egal ob Exception geworfen wurde oder nicht
* Ideal für:

  * Ressourcen freigeben
  * Logs
  * Cleanup

```php
try {
    $conn = openConnection();
} finally {
    closeConnection();
}
```

---

## `Throwable` abfangen (Exception + Error)

```php
try {
    riskyCode();
} catch (Throwable $t) {
    // fängt Exception UND Error
}
```

* Häufig im **globalen Error-Handling** (Frameworks, Middleware)
* In Business-Code eher **konkret fangen**

---

## Eigene Exceptions werfen

```php
if ($user === null) {
    throw new DomainException('User not found');
}
```

* Exceptions signalisieren **kontrollierte Fehler**
* Keine Rückgabewerte für Fehler verwenden

---

## Rückgabewerte & `finally`

`finally` **überschreibt keine Rückgabe**, außer es gibt selbst `return` (nicht empfohlen).

```php
function test(): int {
    try {
        return 1;
    } finally {
        // kein return hier!
    }
}
```

---

## Einsatz in Frameworks

### Symfony

* Exceptions werden global abgefangen
* In Controller/Services: **werfen**, nicht abfangen

```php
throw $this->createNotFoundException();
```

**Docs:** [https://symfony.com/doc/current/controller.html#managing-errors](https://symfony.com/doc/current/controller.html#managing-errors)

---

### Laravel

* Globaler Exception Handler
* Controller-Code bleibt sauber

```php
abort(404);
```

**Docs:** [https://laravel.com/docs/errors](https://laravel.com/docs/errors)

---

### Zusammenfassung

* `try` kapselt fehleranfälligen Code
* `catch` behandelt spezifische Exceptions
* `finally` wird **immer** ausgeführt
* `Throwable` fängt Exceptions **und** Errors
* Business-Code wirft Exceptions, Frameworks handeln sie global

**Weiterführende Doku:**

* PHP Exceptions & try/catch:
  [https://www.php.net/manual/en/language.exceptions.php](https://www.php.net/manual/en/language.exceptions.php)

  **[⬆ Наверх](#top)**

47. ### <a name="47"></a> Wie erstellt man eigene Exceptions?

## Wie erstellt man eigene Exceptions?

### Grundidee

**Eigene Exceptions** sind **benutzerdefinierte Fehlerklassen**, die von `Exception` (oder einer Unterklasse) erben.
Sie machen Fehler **aussagekräftig**, **typisierbar** und **gezielt behandelbar**.

---

## Einfache eigene Exception

```php
class UserNotFoundException extends Exception
{
}
```

Verwendung:

```php
throw new UserNotFoundException('User not found');
```

Abfangen:

```php
try {
    findUser($id);
} catch (UserNotFoundException $e) {
    // gezielte Behandlung
}
```

---

## Eigene Exception mit Standard-Message & Code

```php
class InvalidOrderException extends Exception
{
    protected $message = 'Invalid order';
    protected $code = 400;
}
```

* Einheitliche Fehlermeldungen
* Optional: HTTP-nahe Codes

---

## Eigene Exception mit Zusatzdaten

```php
class ValidationException extends Exception
{
    public function __construct(
        private array $errors,
        string $message = 'Validation failed',
        int $code = 422
    ) {
        parent::__construct($message, $code);
    }

    public function getErrors(): array
    {
        return $this->errors;
    }
}
```

Verwendung:

```php
throw new ValidationException([
    'email' => 'Invalid email'
]);
```

---

## Ableiten von SPL-Exceptions (Best Practice)

PHP stellt semantische Basisklassen bereit:

```php
class UserNotFoundException extends RuntimeException {}
class InvalidInputException extends InvalidArgumentException {}
class PermissionDeniedException extends LogicException {}
```

**Vorteil:**

* Bessere Einordnung
* Konsistentes Catching

---

## Catching nach Typ-Hierarchie

```php
try {
    process();
} catch (ValidationException $e) {
    // spezifisch
} catch (RuntimeException $e) {
    // allgemein
}
```

* Reihenfolge: **spezifisch → allgemein**

---

## Integration in Frameworks

### Symfony

```php
throw new AccessDeniedHttpException();
```

Oder eigene Domain-Exception + globales Mapping auf HTTP-Statuscodes.

**Docs:** [https://symfony.com/doc/current/controller.html#managing-errors](https://symfony.com/doc/current/controller.html#managing-errors)

---

### Laravel

```php
throw new ModelNotFoundException();
```

Eigene Exceptions werden im **Exception Handler** gemappt.

**Docs:** [https://laravel.com/docs/errors](https://laravel.com/docs/errors)

---

## Best Practices

* Eigene Exceptions für **Business-Regeln**
* Aussagekräftige Namen
* Keine generische `Exception` im Domain-Code
* Exceptions **werfen**, nicht als Rückgabewerte nutzen
* Mapping auf HTTP-Codes im **globalen Handler**

---

### Zusammenfassung

* Eigene Exceptions erben von `Exception` oder SPL-Exceptions
* Ermöglichen gezielte Fehlerbehandlung
* Trennen Fehlerarten sauber
* Verbessern Lesbarkeit, Wartbarkeit und Tests
* Standard in professionellen PHP-Codebases

**Weiterführende Doku:**

* PHP Exceptions:
  [https://www.php.net/manual/en/language.exceptions.php](https://www.php.net/manual/en/language.exceptions.php)
* SPL Exceptions:
  [https://www.php.net/manual/en/spl.exceptions.php](https://www.php.net/manual/en/spl.exceptions.php)

  **[⬆ Наверх](#top)**

48. ### <a name="48"></a> Welche Strategien für Error Handling kennst du?

## Welche Strategien für Error Handling kennst du?

### Überblick

Error Handling beschreibt, **wie Fehler erkannt, behandelt, geloggt und kommuniziert** werden.
In modernen PHP-Anwendungen werden **mehrere Strategien kombiniert**.

---

## 1) Exceptions statt Rückgabewerte

**Standard in modernem PHP.**

```php
if ($user === null) {
    throw new UserNotFoundException('User not found');
}
```

**Vorteile:**

* Trennung von Happy Path und Fehlerpfad
* Klare Semantik
* Erzwingt explizite Behandlung

---

## 2) Typisierte (domänenspezifische) Exceptions

Eigene Exceptions für unterschiedliche Fehlerarten.

```php
class ValidationException extends RuntimeException {}
class PermissionDeniedException extends LogicException {}
```

**Vorteile:**

* Gezielt catchbar
* Sauberes Mapping auf HTTP-Statuscodes
* Bessere Lesbarkeit

---

## 3) Globales Error-/Exception-Handling

Fehler werden **zentral** abgefangen (Middleware / Kernel).

### Symfony

* Globaler Exception Listener
* Controller werfen Exceptions, Handler erzeugt Response

**Docs:** [https://symfony.com/doc/current/controller/error_pages.html](https://symfony.com/doc/current/controller/error_pages.html)

### Laravel

* Globaler Exception Handler (`app/Exceptions/Handler.php`)

**Docs:** [https://laravel.com/docs/errors](https://laravel.com/docs/errors)

**Vorteile:**

* Einheitliche Fehlerantworten
* Weniger Boilerplate in Controllern

---

## 4) Mapping von Exceptions auf HTTP-Statuscodes (APIs)

```php
throw new ValidationException('Invalid input'); // → 422
throw new AccessDeniedException();              // → 403
throw new NotFoundHttpException();               // → 404
```

**Best Practice:**

* Domain-Exception → globales Mapping → HTTP-Response
* Controller bleibt schlank

---

## 5) Logging & Monitoring

Fehler werden **nicht nur behandelt**, sondern auch **beobachtet**.

```php
$logger->error('Payment failed', [
    'orderId' => $orderId,
    'exception' => $e,
]);
```

**Tools:**

* Monolog (Symfony)
* Laravel Logging
* Sentry, Bugsnag, ELK

---

## 6) Fail Fast

Fehler **früh erkennen und abbrechen**.

```php
if (!is_numeric($amount)) {
    throw new InvalidArgumentException();
}
```

**Vorteile:**

* Weniger inkonsistente Zustände
* Einfacheres Debugging

---

## 7) Graceful Degradation

Nicht-kritische Fehler **abfedern**, Anwendung läuft weiter.

```php
try {
    $cache->set($key, $value);
} catch (Throwable $e) {
    // Fallback auf DB
}
```

**Typisch für:**

* Cache
* Externe Services
* Third-Party-APIs

---

## 8) Retry & Fallback (bei externen Services)

* Wiederholungslogik
* Zeitlich begrenzt
* Optional mit Circuit Breaker

```php
for ($i = 0; $i < 3; $i++) {
    try {
        return $client->call();
    } catch (RuntimeException $e) {}
}
```

---

## 9) Unterschiedliche Strategien nach Layer

| Layer         | Strategie                |
| ------------- | ------------------------ |
| Domain        | Eigene Exceptions        |
| Service       | Exceptions weiterreichen |
| Controller    | Keine Catch-Blöcke       |
| Middleware    | Globales Handling        |
| Infrastruktur | Retry / Fallback         |

---

### Zusammenfassung

* Exceptions sind die Basis für Error Handling
* Eigene, typisierte Exceptions für Business-Fehler
* Globales Handling für konsistente Responses
* Logging & Monitoring sind Pflicht
* Fail Fast + Graceful Degradation kombinieren
* Strategien unterscheiden sich je nach Layer

**Weiterführende Doku:**

* PHP Exceptions:
  [https://www.php.net/manual/en/language.exceptions.php](https://www.php.net/manual/en/language.exceptions.php)
* Symfony Error Handling:
  [https://symfony.com/doc/current/controller/error_pages.html](https://symfony.com/doc/current/controller/error_pages.html)
* Laravel Errors & Logging:
  [https://laravel.com/docs/errors](https://laravel.com/docs/errors)

  **[⬆ Наверх](#top)**

49. ### <a name="49"></a> Unterschied zwischen PDO und MySQLi

## Unterschied zwischen PDO und MySQLi

### Grundidee

**PDO** und **MySQLi** sind PHP-Erweiterungen für den Datenbankzugriff.
Der Hauptunterschied: **PDO ist datenbankunabhängig**, **MySQLi ist MySQL-spezifisch**.

---

## PDO (PHP Data Objects)

### Eigenschaften

* Einheitliche API für **verschiedene Datenbanken**

  * MySQL, PostgreSQL, SQLite, MSSQL, …
* **Prepared Statements** (empfohlen)
* Unterstützt **Transaktionen**
* Objektorientierter Stil
* Standard in modernen PHP-Projekten

```php
$pdo = new PDO(
    'mysql:host=localhost;dbname=test',
    'user',
    'password'
);

$stmt = $pdo->prepare('SELECT * FROM users WHERE email = :email');
$stmt->execute(['email' => $email]);
```

---

## MySQLi (MySQL Improved)

### Eigenschaften

* **Nur MySQL / MariaDB**
* Objektorientiert **und** prozedural nutzbar
* Prepared Statements verfügbar
* Etwas bessere MySQL-spezifische Features

```php
$mysqli = new mysqli('localhost', 'user', 'password', 'test');

$stmt = $mysqli->prepare('SELECT * FROM users WHERE email = ?');
$stmt->bind_param('s', $email);
$stmt->execute();
```

---

## Vergleich auf einen Blick

| Aspekt              | PDO          | MySQLi      |
| ------------------- | ------------ | ----------- |
| DB-Unterstützung    | Mehrere DBs  | Nur MySQL   |
| Prepared Statements | ✔            | ✔           |
| Named Parameter     | ✔ (`:email`) | ✘ (nur `?`) |
| Transaktionen       | ✔            | ✔           |
| OO-API              | ✔            | ✔           |
| Prozedural          | ✘            | ✔           |
| Zukunftssicherheit  | Hoch         | Mittel      |

---

## Fehlerbehandlung

**PDO**

```php
$pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
```

* Exceptions → sauberes Error Handling

**MySQLi**

* Fehler über Rückgabewerte oder `$mysqli->error`

---

## Warum PDO bevorzugt wird

* Datenbankunabhängigkeit
* Lesbare Named Parameter
* Einheitliches API
* Bessere Integration in Frameworks
* Leichter testbar

Symfony & Laravel nutzen **PDO** intern.

---

## Wann MySQLi sinnvoll ist

* Reines MySQL-Projekt
* Nutzung sehr spezieller MySQL-Features
* Legacy-Codebases

---

### Zusammenfassung

* PDO ist **flexibel und zukunftssicher**
* MySQLi ist **MySQL-spezifisch**
* Beide unterstützen Prepared Statements
* Moderne PHP-Projekte bevorzugen **PDO**
* Frameworks basieren auf PDO

**Weiterführende Doku:**

* PDO:
  [https://www.php.net/manual/en/book.pdo.php](https://www.php.net/manual/en/book.pdo.php)
* MySQLi:
  [https://www.php.net/manual/en/book.mysqli.php](https://www.php.net/manual/en/book.mysqli.php)

  **[⬆ Наверх](#top)**

50. ### <a name="50"></a> Was sind Prepared Statements?

## Was sind Prepared Statements?

### Definition

**Prepared Statements** sind **vorbereitete SQL-Abfragen**, bei denen **SQL-Code und Daten strikt getrennt** werden.
Sie sind der **Standardmechanismus zum Schutz vor SQL Injection** und verbessern zusätzlich **Performance** und **Code-Qualität**.

---

## Grundprinzip

1. SQL-Statement wird **einmal vorbereitet** (mit Platzhaltern).
2. Werte werden **separat gebunden**.
3. Datenbank führt das Statement mit den gebundenen Werten aus.

→ Benutzereingaben werden **niemals als SQL interpretiert**.

---

## Unsicher (ohne Prepared Statements)

```php
$sql = "SELECT * FROM users WHERE email = '$email'";
$pdo->query($sql);
```

* Anfällig für SQL Injection
* SQL und Daten vermischt

---

## Sicher (PDO Prepared Statement)

```php
$stmt = $pdo->prepare(
    'SELECT * FROM users WHERE email = :email'
);
$stmt->execute([
    'email' => $email
]);

$user = $stmt->fetch();
```

**Warum sicher:**

* Platzhalter (`:email`)
* Werte werden getrennt übergeben
* DB behandelt Werte als **Daten**, nicht als Code

---

## Platzhalter-Typen

### Named Parameter (PDO)

```php
:email, :id
```

```php
$stmt = $pdo->prepare(
    'SELECT * FROM users WHERE id = :id'
);
$stmt->execute(['id' => $id]);
```

---

### Positionale Parameter

```php
$stmt = $pdo->prepare(
    'SELECT * FROM users WHERE id = ?'
);
$stmt->execute([$id]);
```

---

## Wiederverwendung & Performance

Prepared Statements können **mehrfach mit unterschiedlichen Werten** ausgeführt werden:

```php
$stmt = $pdo->prepare(
    'INSERT INTO logs (message) VALUES (:msg)'
);

$stmt->execute(['msg' => 'A']);
$stmt->execute(['msg' => 'B']);
```

* DB kann das Statement intern optimieren
* Besonders sinnvoll bei vielen ähnlichen Abfragen

---

## Prepared Statements & Datentypen

```php
$stmt->bindValue(':id', $id, PDO::PARAM_INT);
```

* Optionale explizite Typbindung
* Nützlich bei Grenzfällen (z. B. `LIMIT`)

---

## Grenzen & Best Practices

* **Keine Platzhalter** für SQL-Struktur:

  * Tabellen-/Spaltennamen
  * `ORDER BY` / `LIMIT` → **Whitelist** verwenden
* Prepared Statements ersetzen **nicht**:

  * Validierung
  * Autorisierung
* In ORMs (Doctrine/Eloquent) **implizit** genutzt

---

### Zusammenfassung

* Prepared Statements trennen **SQL und Daten**
* Effektiver Schutz vor SQL Injection
* Bessere Performance bei Wiederverwendung
* Standard in modernen PHP-Anwendungen
* PDO und Frameworks nutzen sie konsequent

**Weiterführende Doku:**

* PDO Prepared Statements:
  [https://www.php.net/manual/en/pdo.prepared-statements.php](https://www.php.net/manual/en/pdo.prepared-statements.php)
* OWASP SQL Injection:
  [https://owasp.org/www-community/attacks/SQL_Injection](https://owasp.org/www-community/attacks/SQL_Injection)

  **[⬆ Наверх](#top)**  

51. ### <a name="51"></a> Wie funktionieren Transaktionen?

## Wie funktionieren Transaktionen?

### Grundidee

**Transaktionen** sorgen dafür, dass **mehrere Datenbankoperationen als eine unteilbare Einheit** ausgeführt werden.
Entweder werden **alle Änderungen übernommen** oder **keine**.

Ziel: **Datenkonsistenz und Integrität**.

---

## ACID-Prinzipien

Transaktionen folgen den **ACID-Eigenschaften**:

* **A – Atomicity**: Alles oder nichts
* **C – Consistency**: DB bleibt in gültigem Zustand
* **I – Isolation**: Parallel laufende Transaktionen beeinflussen sich nicht unerwünscht
* **D – Durability**: Nach Commit sind Daten dauerhaft gespeichert

---

## Transaktionen mit PDO (Beispiel)

```php
<?php
$pdo->beginTransaction();

try {
    $pdo->prepare(
        'INSERT INTO orders (user_id) VALUES (:user_id)'
    )->execute(['user_id' => 1]);

    $pdo->prepare(
        'INSERT INTO payments (order_id, amount) VALUES (:order_id, :amount)'
    )->execute(['order_id' => 10, 'amount' => 99.99]);

    $pdo->commit();
} catch (Throwable $e) {
    $pdo->rollBack();
    throw $e;
}
```

* `beginTransaction()` → Start
* `commit()` → Änderungen speichern
* `rollBack()` → alles zurücksetzen

---

## Warum Transaktionen wichtig sind

Ohne Transaktion:

* Bestellung gespeichert
* Zahlung schlägt fehl
* **Inkonsistenter Zustand**

Mit Transaktion:

* Fehler → **keine** der Änderungen wird gespeichert

---

## Typische Einsatzfälle

* Bestellungen + Zahlungen
* Kontostand-Änderungen
* Mehrere abhängige Inserts/Updates
* Datenmigrationen

---

## Transaktionen & Exceptions

* Fehler **immer** per Exception behandeln
* `commit()` nur bei erfolgreichem Ablauf
* `rollBack()` im `catch`

---

## Verschachtelte Transaktionen

* PDO unterstützt **keine echten Nested Transactions**
* Frameworks nutzen **Savepoints**

```sql
SAVEPOINT step1;
ROLLBACK TO step1;
```

---

## Isolation Levels (Kurzüberblick)

| Level            | Beschreibung      |
| ---------------- | ----------------- |
| READ UNCOMMITTED | Kann Dirty Reads  |
| READ COMMITTED   | Keine Dirty Reads |
| REPEATABLE READ  | Standard in MySQL |
| SERIALIZABLE     | Höchste Isolation |

* Höhere Isolation = weniger Nebenwirkungen, aber geringere Performance

---

## Transaktionen in Frameworks

### Symfony (Doctrine)

```php
$entityManager->wrapInTransaction(function () use ($entityManager) {
    // persist / flush
});
```

**Docs:**
[https://www.doctrine-project.org/projects/doctrine-orm/en/current/reference/transactions-and-concurrency.html](https://www.doctrine-project.org/projects/doctrine-orm/en/current/reference/transactions-and-concurrency.html)

---

### Laravel (Eloquent)

```php
DB::transaction(function () {
    // Queries
});
```

**Docs:**
[https://laravel.com/docs/database#database-transactions](https://laravel.com/docs/database#database-transactions)

---

### Zusammenfassung

* Transaktionen bündeln mehrere DB-Operationen
* ACID garantiert Datenkonsistenz
* `begin → commit / rollback`
* Unverzichtbar bei kritischen Geschäftsprozessen
* Frameworks kapseln Transaktionen komfortabel

**Weiterführende Doku:**

* PDO Transactions:
  [https://www.php.net/manual/en/pdo.transactions.php](https://www.php.net/manual/en/pdo.transactions.php)
* Doctrine Transactions:
  [https://www.doctrine-project.org/projects/doctrine-orm/en/current/reference/transactions-and-concurrency.html](https://www.doctrine-project.org/projects/doctrine-orm/en/current/reference/transactions-and-concurrency.html)

  **[⬆ Наверх](#top)**

52. ### <a name="52"></a> Was sind Indizes und warum sind sie wichtig?

## Was sind Indizes und warum sind sie wichtig?

### Definition

**Indizes** sind **zusätzliche Datenstrukturen** in der Datenbank, die den **schnellen Zugriff auf Zeilen** ermöglichen – ähnlich wie ein Inhaltsverzeichnis in einem Buch.

Ohne Index muss die Datenbank jede Zeile prüfen (**Full Table Scan**).

---

## Wie Indizes funktionieren (vereinfacht)

* Meist als **B-Tree** implementiert
* Index speichert:

  * Spaltenwert
  * Verweis auf die Zeile
* Datenbank nutzt den Index, um Datensätze schneller zu finden

---

## Beispiel ohne Index

```sql
SELECT * FROM users WHERE email = 'a@example.com';
```

* Tabelle mit 1 Mio. Zeilen
* Ohne Index → 1 Mio. Vergleiche

---

## Mit Index

```sql
CREATE INDEX idx_users_email ON users(email);
```

* Datenbank springt direkt zur passenden Stelle
* Laufzeit stark reduziert

---

## Typische Arten von Indizes

### 1) Primary Key Index

* Automatisch
* Eindeutig
* Sehr schnell

```sql
PRIMARY KEY (id)
```

---

### 2) Unique Index

* Erzwingt Eindeutigkeit

```sql
CREATE UNIQUE INDEX idx_users_email ON users(email);
```

---

### 3) Normaler (Non-Unique) Index

* Für häufige Suchanfragen

```sql
CREATE INDEX idx_users_status ON users(status);
```

---

### 4) Composite Index (mehrere Spalten)

```sql
CREATE INDEX idx_orders_user_date ON orders(user_id, created_at);
```

* Reihenfolge der Spalten ist **entscheidend**
* Nur nutzbar für linke Präfixe

---

## Wann Indizes genutzt werden

* `WHERE`
* `JOIN`
* `ORDER BY`
* `GROUP BY`

---

## Nachteile von Indizes

* Benötigen Speicherplatz
* Verlangsamen:

  * `INSERT`
  * `UPDATE`
  * `DELETE`
* Zu viele Indizes → schlechtere Performance

---

## Best Practices

* Indexe auf:

  * Foreign Keys
  * Suchfelder
  * Join-Spalten
* Keine Indizes auf sehr kleine Tabellen
* Nicht blind alles indexieren
* Queries mit `EXPLAIN` analysieren

```sql
EXPLAIN SELECT * FROM users WHERE email = 'a@example.com';
```

---

## ORM & Indizes

### Doctrine

```php
#[ORM\Index(columns: ['email'])]
class User {}
```

---

### Laravel

```php
$table->index('email');
$table->unique('email');
```

---

### Zusammenfassung

* Indizes beschleunigen Datenbankabfragen
* Verhindern Full Table Scans
* Besonders wichtig bei großen Tabellen
* Zu viele Indizes schaden der Performance
* Analyse mit `EXPLAIN` ist Pflicht

**Weiterführende Doku:**

* MySQL Indexes:
  [https://dev.mysql.com/doc/refman/8.0/en/mysql-indexes.html](https://dev.mysql.com/doc/refman/8.0/en/mysql-indexes.html)
* PostgreSQL Indexes:
  [https://www.postgresql.org/docs/current/indexes.html](https://www.postgresql.org/docs/current/indexes.html)

  **[⬆ Наверх](#top)**

53. ### <a name="53"></a> Was bedeutet Normalisierung einer Datenbank?

## Was bedeutet Normalisierung einer Datenbank?

### Definition

**Normalisierung** ist der Prozess, bei dem eine Datenbank so strukturiert wird, dass:

* **Redundanzen reduziert**
* **Dateninkonsistenzen vermieden**
* **Daten logisch und sauber getrennt** werden

Ziel: **konsistente, wartbare und erweiterbare Datenmodelle**.

---

## Warum Normalisierung wichtig ist

Ohne Normalisierung:

* Gleiche Daten mehrfach gespeichert
* Updates an vielen Stellen nötig
* Risiko von Inkonsistenzen

Mit Normalisierung:

* Eine Information an **einem Ort**
* Klare Beziehungen
* Saubere Update-Logik

---

## Normalformen (interviewrelevant)

### 1. Normalform (1NF)

**Alle Felder sind atomar** (keine Listen, keine Mehrfachwerte).

❌ Nicht normalisiert:

```text
orders
id | products
1  | apple, banana
```

✔ Normalisiert:

```text
order_products
order_id | product
1        | apple
1        | banana
```

---

### 2. Normalform (2NF)

* Tabelle ist in 1NF
* **Alle Nicht-Schlüsselattribute** hängen **vollständig vom Primärschlüssel** ab

Problem bei zusammengesetzten Schlüsseln.

❌:

```text
order_products
(order_id, product_id) | product_name
```

✔:

```text
products
product_id | name
```

---

### 3. Normalform (3NF)

* Tabelle ist in 2NF
* **Keine transitiven Abhängigkeiten**

❌:

```text
users
id | city | zip_code
```

`zip_code` hängt von `city`, nicht direkt von `id`.

✔:

```text
cities
city_id | zip_code

users
id | city_id
```

---

## Typischer Zielzustand

* Meist reicht **3NF**
* Höhere Normalformen selten notwendig
* In Business-Anwendungen Standard

---

## Normalisierung vs. Denormalisierung

### Denormalisierung

* Bewusstes Einführen von Redundanzen
* Ziel: **Performance**

Beispiel:

* `total_price` zusätzlich speichern
* Reporting-Tabellen

**Wichtig:**
Denormalisierung ist eine **Optimierung**, keine schlechte Praxis per se.

---

## Normalisierung in der Praxis

* OLTP-Systeme → stark normalisiert
* Reporting / Analytics → oft denormalisiert
* ORMs (Doctrine/Eloquent) gehen von normalisierten Modellen aus

---

### Zusammenfassung

* Normalisierung reduziert Redundanz
* Verhindert Inkonsistenzen
* Strukturierung nach Normalformen (1NF–3NF)
* 3NF ist meist ausreichend
* Denormalisierung gezielt für Performance einsetzen

**Weiterführende Doku:**

* Database Normalization (PostgreSQL):
  [https://www.postgresql.org/docs/current/ddl.html](https://www.postgresql.org/docs/current/ddl.html)
* Database Design Basics:
  [https://en.wikipedia.org/wiki/Database_normalization](https://en.wikipedia.org/wiki/Database_normalization)

  **[⬆ Наверх](#top)**

54. ### <a name="54"></a> Wie ist das MVC-Pattern aufgebaut?

## Wie ist das MVC-Pattern aufgebaut?

### Grundidee

**MVC (Model–View–Controller)** ist ein Architekturpattern, das eine Anwendung in **drei klar getrennte Verantwortlichkeiten** aufteilt.
Ziel: **Trennung von Zuständigkeiten**, bessere Wartbarkeit und Testbarkeit.

---

## Die drei Komponenten

### 1) Model

**Verantwortung:**

* Geschäftslogik
* Datenzugriff
* Domain-Regeln

**Typische Inhalte:**

* Entities / Models
* Repositories
* Services (Domain-nahe Logik)

```php
class User {
    public function __construct(
        public int $id,
        public string $email
    ) {}
}
```

---

### 2) View

**Verantwortung:**

* Darstellung der Daten
* Keine Business-Logik

**Typische Inhalte:**

* Templates (HTML)
* Platzhalter für Daten

```twig
{# Twig (Symfony) #}
<h1>{{ user.email }}</h1>
```

* Auto-Escaping gegen XSS
* View kennt **kein Model intern**, nur Daten

---

### 3) Controller

**Verantwortung:**

* Entgegennahme des Requests
* Koordination zwischen Model und View
* Rückgabe der Response

```php
class UserController
{
    public function show(int $id): Response
    {
        $user = $this->repository->find($id);

        return new Response(
            $this->twig->render('user/show.html.twig', [
                'user' => $user,
            ])
        );
    }
}
```

* **Keine Business-Logik**
* Schlank halten

---

## Request-Flow im MVC

1. Client sendet HTTP-Request
2. Router wählt passenden **Controller**
3. Controller:

   * ruft Model/Service auf
   * erhält Daten
4. Controller übergibt Daten an die **View**
5. View rendert Ausgabe
6. Response geht an den Client

---

## MVC in modernen Frameworks

### Symfony

* **Controller** → HTTP-Einstieg
* **Model** → Entities, Services, Repositories
* **View** → Twig Templates

Quelle:
[https://symfony.com/doc/current/controller.html](https://symfony.com/doc/current/controller.html)

---

### Laravel

* **Controller** → App\Http\Controllers
* **Model** → Eloquent Models
* **View** → Blade Templates

Quelle:
[https://laravel.com/docs/structure](https://laravel.com/docs/structure)

---

## Vorteile von MVC

* Klare Struktur
* Gute Testbarkeit
* Parallele Entwicklung (Backend / Frontend)
* Skalierbar für große Projekte

---

## Häufige Missverständnisse

* Controller ist **kein** Ort für Business-Logik
* Model ist **mehr als nur DB-Zugriff**
* View enthält **keine Logik**

---

### Zusammenfassung

* MVC trennt Anwendung in Model, View, Controller
* Model = Daten + Logik
* View = Darstellung
* Controller = Koordination
* Standardarchitektur in Symfony & Laravel
* Grundlage für sauberen Backend-Code

**Weiterführende Doku:**

* Symfony MVC:
  [https://symfony.com/doc/current/introduction/from_flat_php_to_symfony.html](https://symfony.com/doc/current/introduction/from_flat_php_to_symfony.html)
* Laravel MVC:
  [https://laravel.com/docs/structure](https://laravel.com/docs/structure)

  **[⬆ Наверх](#top)**

55. ### <a name="55"></a> Was ist ein Service Container?

## Was ist ein Service Container?

### Definition

Ein **Service Container** (auch **Dependency Injection Container**) ist eine zentrale Komponente, die:

* **Objekte (Services) erstellt**
* **Abhängigkeiten automatisch auflöst**
* den **Lifecycle** dieser Objekte verwaltet

Er ist die technische Umsetzung von **Dependency Injection**.

---

## Problem ohne Service Container

```php
class UserController {
    public function __construct() {
        $repo = new UserRepository();
        $service = new UserService($repo);
    }
}
```

* Starke Kopplung
* Schwer testbar
* Manuelles Erstellen komplexer Objektgraphen

---

## Lösung mit Service Container

```php
class UserController {
    public function __construct(
        private UserService $service
    ) {}
}
```

* Container erstellt `UserService`
* Container injiziert automatisch `UserRepository`
* Controller kennt nur seine **direkten Abhängigkeiten**

---

## Aufgaben eines Service Containers

* **Instantiation**: Erzeugen von Objekten
* **Dependency Resolution**: Auflösen verschachtelter Abhängigkeiten
* **Configuration**: Parameter, Aliase, Interfaces → Implementierungen
* **Lifecycle-Management**:

  * Singleton (shared)
  * Prototype (neu pro Aufruf)

---

## Wie der Container intern arbeitet (vereinfacht)

1. Klasse wird angefordert
2. Container analysiert den Konstruktor
3. Abhängigkeiten werden rekursiv erstellt
4. Objekt wird zurückgegeben (ggf. gecached)

---

## Service Container in Frameworks

### Symfony

* Services werden meist **automatisch registriert**
* Autowiring + Autoconfiguration

```php
class Mailer {
    public function __construct(private LoggerInterface $logger) {}
}
```

```yaml
# services.yaml
services:
  App\:
    resource: '../src/'
    autowire: true
    autoconfigure: true
```

**Docs:**
[https://symfony.com/doc/current/service_container.html](https://symfony.com/doc/current/service_container.html)

---

### Laravel

* Service Container ist **zentraler Bestandteil**
* Bindings über Service Provider

```php
$this->app->bind(
    PaymentGatewayInterface::class,
    StripeGateway::class
);
```

```php
class OrderService {
    public function __construct(
        PaymentGatewayInterface $gateway
    ) {}
}
```

**Docs:**
[https://laravel.com/docs/container](https://laravel.com/docs/container)

---

## Vorteile

* Lose Kopplung
* Hohe Testbarkeit (Mocks)
* Zentrale Konfiguration
* Saubere Architektur
* Skalierbar bei großen Projekten

---

## Typische Missverständnisse

* Service Container ≠ Service Locator
  (Service Locator **versteckt** Abhängigkeiten)
* Nicht jede Klasse muss ein Service sein
* Business-Logik gehört **nicht** in den Container

---

### Zusammenfassung

* Service Container erstellt und verwaltet Objekte
* Löst Abhängigkeiten automatisch auf
* Kernstück von Dependency Injection
* Standard in Symfony & Laravel
* Ermöglicht sauberen, testbaren Code

**Weiterführende Doku:**

* Symfony Service Container:
  [https://symfony.com/doc/current/service_container.html](https://symfony.com/doc/current/service_container.html)
* Laravel Service Container:
  [https://laravel.com/docs/container](https://laravel.com/docs/container)

  **[⬆ Наверх](#top)**

56. ### <a name="56"></a> Wie funktioniert Routing?

## Wie funktioniert Routing?

### Definition

**Routing** ordnet eine **HTTP-Anfrage (URL + Methode)** einer **konkreten Aktion** in der Anwendung zu (meist einer Controller-Methode).
Ziel: Anfragen gezielt weiterleiten und sauber strukturieren.

---

## Grundbestandteile einer Route

* **HTTP-Methode**: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`
* **Pfad (URI)**: `/users/{id}`
* **Handler**: Controller + Methode
* **Optionen**: Parameter, Constraints, Middleware

---

## Ablauf einer Anfrage (vereinfacht)

1. Client sendet Request (z. B. `GET /users/42`)
2. **Router** vergleicht Methode + Pfad mit definierten Routen
3. Passende Route gefunden
4. Router extrahiert Parameter (`id = 42`)
5. Controller-Methode wird aufgerufen
6. Controller gibt **Response** zurück

---

## Einfaches Routing (Konzeptuell)

```php
GET /users/42  →  UserController::show(42)
```

---

## Routing in Frameworks

### Symfony

**Attribut-basiert (empfohlen):**

```php
use Symfony\Component\Routing\Annotation\Route;

#[Route('/users/{id}', methods: ['GET'])]
public function show(int $id): Response
{
    // ...
}
```

**Eigenschaften:**

* Methodenbindung (`methods`)
* Typisierte Parameter
* Regex-Constraints möglich

**Docs:**
[https://symfony.com/doc/current/routing.html](https://symfony.com/doc/current/routing.html)

---

### Laravel

```php
Route::get('/users/{id}', [UserController::class, 'show']);
```

**Eigenschaften:**

* Sehr deklarativ
* Route Model Binding
* Middleware pro Route/Gruppe

**Docs:**
[https://laravel.com/docs/routing](https://laravel.com/docs/routing)

---

## Route-Parameter & Constraints

### Symfony

```php
#[Route('/users/{id}', requirements: ['id' => '\d+'])]
```

### Laravel

```php
Route::get('/users/{id}', ...)
     ->whereNumber('id');
```

---

## RESTful Routing

Typische REST-Zuordnung:

| Methode   | Pfad          | Aktion        |
| --------- | ------------- | ------------- |
| GET       | `/users`      | Liste         |
| GET       | `/users/{id}` | Detail        |
| POST      | `/users`      | Erstellen     |
| PUT/PATCH | `/users/{id}` | Aktualisieren |
| DELETE    | `/users/{id}` | Löschen       |

---

## Middleware im Routing

Middleware laufen **vor oder nach** dem Controller:

* Authentifizierung
* Autorisierung
* Logging
* Rate Limiting

```php
Route::middleware('auth')->group(function () {
    Route::get('/dashboard', ...);
});
```

---

## Routing & Front Controller

Alle Requests gehen über **eine Einstiegspunkt-Datei** (`index.php`):

```
public/index.php → Router → Controller
```

* Webserver (Apache/Nginx) leitet alles an `index.php`
* Router entscheidet weiter

---

### Zusammenfassung

* Routing verbindet HTTP-Anfragen mit Code
* Basis: Methode + Pfad → Handler
* Parameter werden aus der URL extrahiert
* Frameworks bieten deklaratives, mächtiges Routing
* Grundlage für MVC und REST-APIs

**Weiterführende Doku:**

* Symfony Routing:
  [https://symfony.com/doc/current/routing.html](https://symfony.com/doc/current/routing.html)
* Laravel Routing:
  [https://laravel.com/docs/routing](https://laravel.com/docs/routing)

  **[⬆ Наверх](#top)**

57. ### <a name="57"></a> Was sind Middleware bzw. Event Listener?

## Was sind Middleware bzw. Event Listener?

### Grundidee

Beide Konzepte ermöglichen es, **Querschnittsfunktionen** (Cross-Cutting Concerns) **zentral** umzusetzen – ohne sie in Controller oder Business-Logik zu mischen.

* **Middleware** → arbeiten **entlang des Request/Response-Flows**
* **Event Listener** → reagieren **auf Ereignisse (Events)** im System

---

## Middleware

### Definition

**Middleware** sind Komponenten, die **zwischen Request und Response** ausgeführt werden.
Sie können:

* Requests **verändern**
* Requests **abbrechen**
* Responses **modifizieren**

---

### Request-Flow mit Middleware

```
Request
  ↓
Middleware A
  ↓
Middleware B
  ↓
Controller
  ↓
Response
  ↑
Middleware B
  ↑
Middleware A
```

---

### Typische Aufgaben

* Authentifizierung
* Autorisierung
* Logging
* Rate Limiting
* CORS
* Locale-Erkennung

---

### Beispiel: Laravel Middleware

```php
class AuthMiddleware
{
    public function handle($request, Closure $next)
    {
        if (!$request->user()) {
            abort(401);
        }

        return $next($request);
    }
}
```

**Docs:**
[https://laravel.com/docs/middleware](https://laravel.com/docs/middleware)

---

### Symfony (HTTP Kernel Middleware-ähnlich)

Symfony nutzt **Kernel Events** (ähnlich zu Middleware).

```php
class AuthListener
{
    public function onKernelRequest(RequestEvent $event): void
    {
        // Auth prüfen
    }
}
```

---

## Event Listener

### Definition

**Event Listener** reagieren auf **konkrete Events**, die im System ausgelöst werden.

```php
event('user.registered');
```

Listener:

```php
class SendWelcomeMail
{
    public function __invoke(UserRegistered $event)
    {
        // Mail senden
    }
}
```

---

### Eigenschaften

* **Entkoppelt** Sender und Empfänger
* Ein Event → mehrere Listener möglich
* Kein direkter Einfluss auf den Request-Flow (meist)

---

### Typische Events

* User registriert
* Bestellung erstellt
* Login erfolgreich
* Cache geleert

---

### Event Listener vs. Event Subscriber

* **Listener** → reagieren auf ein Event
* **Subscriber** → registrieren sich für mehrere Events

---

## Vergleich auf einen Blick

| Aspekt                | Middleware          | Event Listener      |
| --------------------- | ------------------- | ------------------- |
| Zeitpunkt             | Vor/nach Controller | Bei Event-Auslösung |
| Einfluss auf Response | ✔                   | meist ✘             |
| Request-bezogen       | ✔                   | ✘                   |
| Entkopplung           | Mittel              | Hoch                |
| Typische Nutzung      | Auth, Logging       | Business-Reaktionen |

---

## Wann was verwenden?

* **Middleware**, wenn:

  * Logik an **jede Anfrage** gekoppelt ist
  * Zugriff blockiert werden soll
* **Event Listener**, wenn:

  * Reaktion auf **ein Ereignis**
  * Lose Kopplung wichtig ist

---

### Zusammenfassung

* Middleware arbeiten im Request/Response-Zyklus
* Event Listener reagieren auf Events
* Middleware können Requests stoppen oder verändern
* Event Listener sind entkoppelt und erweiterbar
* Beide sind zentrale Bausteine moderner Frameworks

**Weiterführende Doku:**

* Laravel Middleware:
  [https://laravel.com/docs/middleware](https://laravel.com/docs/middleware)
* Symfony Events:
  [https://symfony.com/doc/current/event_dispatcher.html](https://symfony.com/doc/current/event_dispatcher.html)

  **[⬆ Наверх](#top)**

58. ### <a name="58"></a> Was ist ein ORM (Doctrine / Eloquent)?

## Was ist ein ORM (Doctrine / Eloquent)?

### Definition

**ORM (Object-Relational Mapping)** ist eine Technik, die **Datenbanktabellen auf PHP-Objekte abbildet**.
Dadurch kann man mit der Datenbank **objektorientiert** arbeiten, ohne SQL direkt schreiben zu müssen.

Beispiele:

* **Doctrine ORM** (Symfony)
* **Eloquent ORM** (Laravel)

---

## Grundidee

| Datenbank   | PHP             |
| ----------- | --------------- |
| Tabelle     | Klasse          |
| Zeile       | Objekt          |
| Spalte      | Property        |
| Foreign Key | Objekt-Relation |

---

## Einfaches ORM-Beispiel (Eloquent)

```php
class User extends Model
{
    protected $fillable = ['email'];
}
```

```php
$user = User::find(1);
$user->email = 'a@example.com';
$user->save();
```

* Kein SQL nötig
* ORM kümmert sich um Persistenz

---

## Doctrine ORM (Symfony)

### Entity

```php
#[ORM\Entity]
class User
{
    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column]
    private int $id;

    #[ORM\Column(length: 255)]
    private string $email;
}
```

```php
$user = $entityManager->find(User::class, 1);
```

---

## Beziehungen (Relations)

| Beziehung  | Beispiel       |
| ---------- | -------------- |
| OneToOne   | User ↔ Profile |
| OneToMany  | User ↔ Orders  |
| ManyToMany | User ↔ Roles   |

---

## Vorteile von ORMs

* Weniger SQL
* Objektorientierter Code
* DB-unabhängiger
* Schutz vor SQL Injection
* Einheitliches Datenmodell

---

## Nachteile

* Performance-Overhead
* Verstecktes SQL
* Komplex bei sehr großen Queries
* Lernkurve

---

## Wann ORM sinnvoll ist

* Business-Anwendungen
* CRUD-lastige Systeme
* Schnelle Entwicklung

Wann nicht:

* Reporting
* Massive Datenmengen
* Spezial-Queries

---

## ORM vs. Query Builder vs. SQL

* **ORM** → Komfort, OO
* **Query Builder** → Kontrolle + Sicherheit
* **Raw SQL** → Maximale Performance

Moderne Projekte **kombinieren** alle drei.

---

### Zusammenfassung

* ORM mappt DB-Tabellen auf Objekte
* Doctrine (Symfony) und Eloquent (Laravel) sind Standard
* Erhöht Produktivität und Wartbarkeit
* Nicht für jeden Use-Case optimal
* Oft mit Query Buildern kombiniert

**Weiterführende Doku:**

* Doctrine ORM:
  [https://www.doctrine-project.org/projects/doctrine-orm/en/current/](https://www.doctrine-project.org/projects/doctrine-orm/en/current/)
* Laravel Eloquent:
  [https://laravel.com/docs/eloquent](https://laravel.com/docs/eloquent)

  **[⬆ Наверх](#top)**

59. ### <a name="59"></a> Was sind Migrations?

## Was sind Migrations?

### Definition

**Migrations** sind **versionierte Datenbankänderungen**, die den **Schema-Zustand der Datenbank** reproduzierbar beschreiben.
Sie erlauben es, das Datenbankschema **kontrolliert zu erstellen, zu ändern und zurückzurollen**.

---

## Problem ohne Migrations

* Manuelle SQL-Skripte
* Unterschiedliche DB-Stände (Dev/Test/Prod)
* Fehleranfällige Deployments
* Keine Versionshistorie

---

## Lösung mit Migrations

* Jede Schema-Änderung = **eine Migration**
* Reihenfolge eindeutig
* Versionierbar (Git)
* Automatisierbar

---

## Grundprinzip

* `up()` → Änderung anwenden
* `down()` → Änderung rückgängig machen

---

## Beispiel: Laravel Migration

```php
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

class CreateUsersTable extends Migration
{
    public function up(): void
    {
        Schema::create('users', function (Blueprint $table) {
            $table->id();
            $table->string('email')->unique();
            $table->timestamps();
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('users');
    }
}
```

---

## Beispiel: Doctrine Migration (Symfony)

```php
final class Version20240101000000 extends AbstractMigration
{
    public function up(Schema $schema): void
    {
        $this->addSql('CREATE TABLE users (id INT PRIMARY KEY, email VARCHAR(255))');
    }

    public function down(Schema $schema): void
    {
        $this->addSql('DROP TABLE users');
    }
}
```

---

## Typische Einsatzfälle

* Neue Tabellen
* Neue Spalten
* Indizes
* Constraints
* Datenmigrationen (vorsichtig!)

---

## Vorteile

* Reproduzierbarer DB-Zustand
* Team-fähig
* Sicheres Deployment
* Rollbacks möglich
* CI/CD-tauglich

---

## Best Practices

* Jede Migration klein halten
* Niemals produktive Daten „blind“ löschen
* Datenmigrationen trennen von Schema-Migrationen
* Migrationen **nicht nachträglich ändern**
* Rollback testen

---

## Migrations & ORM

* Doctrine/Eloquent nutzen Migrations **für das Schema**
* ORM-Entities/Models spiegeln Schema wider
* Änderungen immer synchron halten

---

### Zusammenfassung

* Migrations versionieren DB-Schema-Änderungen
* `up()` wendet Änderungen an, `down()` macht sie rückgängig
* Standard in Symfony & Laravel
* Unverzichtbar für Teams & Deployments
* Grundlage für sauberes DB-Management

**Weiterführende Doku:**

* Laravel Migrations:
  [https://laravel.com/docs/migrations](https://laravel.com/docs/migrations)
* Doctrine Migrations:
  [https://www.doctrine-project.org/projects/doctrine-migrations/en/current/](https://www.doctrine-project.org/projects/doctrine-migrations/en/current/)

  **[⬆ Наверх](#top)**

60. ### <a name="60"></a> Wie funktioniert Validation im Framework?

## Wie funktioniert Validation im Framework?

### Grundidee

Frameworks (Symfony, Laravel) stellen **zentrale Validator-Komponenten** bereit, die:

* Eingaben **serverseitig prüfen**
* **klare Fehlermeldungen** erzeugen
* sich sauber in **Controller, Services und Requests** integrieren

Validierung ist **deklarativ**, wiederverwendbar und konsistent.

---

## Validation in Symfony

### Validator Component

Symfony validiert Daten über **Constraints**.

#### Beispiel: Validierung eines Arrays (z. B. JSON-Request)

```php
use Symfony\Component\Validator\Validator\ValidatorInterface;
use Symfony\Component\Validator\Constraints as Assert;

$constraints = new Assert\Collection([
    'email' => [
        new Assert\NotBlank(),
        new Assert\Email(),
    ],
    'age' => new Assert\Optional([
        new Assert\Type('integer'),
        new Assert\Range(['min' => 0, 'max' => 130]),
    ]),
]);

$violations = $validator->validate($data, $constraints);

if (count($violations) > 0) {
    // Violations auslesen und 422 zurückgeben
}
```

---

### Entity-Validation (häufigster Fall)

```php
use Symfony\Component\Validator\Constraints as Assert;

class User
{
    #[Assert\NotBlank]
    #[Assert\Email]
    public string $email;

    #[Assert\Range(min: 0, max: 130)]
    public int $age;
}
```

```php
$violations = $validator->validate($user);
```

* Regeln liegen **direkt am Modell**
* Sehr gut für Domain-nahe Validierung

**Doku:** [https://symfony.com/doc/current/validation.html](https://symfony.com/doc/current/validation.html)

---

## Validation in Laravel

### Form Request (Best Practice)

```php
class RegisterRequest extends FormRequest
{
    public function rules(): array
    {
        return [
            'email' => ['required', 'email'],
            'age'   => ['nullable', 'integer', 'between:0,130'],
        ];
    }
}
```

Controller:

```php
public function store(RegisterRequest $request)
{
    $validated = $request->validated();
}
```

* Automatische Validierung **vor** Controller-Logik
* Fehler → automatisch `422 Unprocessable Entity`
* Saubere Controller

---

### Inline-Validation (einfacher)

```php
$request->validate([
    'email' => 'required|email',
]);
```

---

**Doku:** [https://laravel.com/docs/validation](https://laravel.com/docs/validation)

---

## Gemeinsame Konzepte (Symfony & Laravel)

### Validierungszeitpunkt

* **Vor** Business-Logik
* Oft direkt beim Request-Eingang

### Fehlerbehandlung

* Strukturierte Fehlermeldungen
* API: meist `422`
* Web: Redirect + Errors

### Custom Validation

* Eigene Constraints (Symfony)
* Custom Rules (Laravel)

---

## Validation ≠ Security

Framework-Validation:

* prüft **Format & Regeln**

Nicht abgedeckt:

* SQL Injection → Prepared Statements
* XSS → Output Escaping
* Auth/Permissions → Middleware / Guards

---

## Best Practices

* Validation **am Rand der Anwendung**
* Domain-Regeln ggf. zusätzlich im Model/Service prüfen
* API: konsistente Fehlerformate
* Wiederverwendbare Validatoren statt Copy-Paste

---

### Zusammenfassung

* Frameworks bieten zentrale, deklarative Validation
* Symfony: Validator Component + Constraints
* Laravel: Form Requests + Rules
* Validation läuft vor Business-Logik
* Klare Trennung von Validation, Security und Domain-Logik

**Weiterführende Doku:**

* Symfony Validation:
  [https://symfony.com/doc/current/validation.html](https://symfony.com/doc/current/validation.html)
* Laravel Validation:
  [https://laravel.com/docs/validation](https://laravel.com/docs/validation)

  **[⬆ Наверх](#top)**

61. ### <a name="61"></a> Unterschied zwischen Unit-Tests und Integration-Tests

## Unterschied zwischen Unit-Tests und Integration-Tests

### Grundidee

Beide Testarten prüfen Software, aber auf **unterschiedlichen Ebenen** und mit **unterschiedlichem Scope**.

* **Unit-Tests** → testen **kleinste Code-Einheiten isoliert**
* **Integration-Tests** → testen das **Zusammenspiel mehrerer Komponenten**

---

## Unit-Tests

### Was wird getestet?

* Einzelne Klassen oder Methoden
* **Ohne externe Abhängigkeiten**

```php
class PriceCalculator {
    public function addVat(float $price): float {
        return $price * 1.19;
    }
}
```

```php
public function testAddVat(): void
{
    $calc = new PriceCalculator();
    $this->assertSame(11.9, $calc->addVat(10));
}
```

### Eigenschaften

* Sehr schnell
* Keine DB, kein Netzwerk
* Abhängigkeiten werden **gemockt**
* Finden Logikfehler früh

**Typisch für:**

* Business-Logik
* Helper
* Services

---

## Integration-Tests

### Was wird getestet?

* Zusammenspiel mehrerer Komponenten
* Echte Abhängigkeiten (DB, Container, HTTP)

```php
public function testUserIsPersisted(): void
{
    $user = new User('a@example.com');
    $this->entityManager->persist($user);
    $this->entityManager->flush();

    $this->assertNotNull($user->getId());
}
```

### Eigenschaften

* Langsamer als Unit-Tests
* Reale Infrastruktur
* Höherer Setup-Aufwand
* Finden Konfigurations- und Integrationsfehler

**Typisch für:**

* Repository + DB
* HTTP-Endpoints
* Service-Container

---

## Vergleich auf einen Blick

| Aspekt          | Unit-Test        | Integration-Test    |
| --------------- | ---------------- | ------------------- |
| Scope           | Einzelne Einheit | Mehrere Komponenten |
| Abhängigkeiten  | Gemockt          | Echt                |
| Geschwindigkeit | Sehr schnell     | Langsamer           |
| Stabilität      | Sehr stabil      | Anfälliger          |
| Fehlerart       | Logikfehler      | Integrationsfehler  |

---

## PHPUnit: Mocks vs. echte Abhängigkeiten

### Unit-Test mit Mock

```php
$repo = $this->createMock(UserRepository::class);
```

### Integration-Test

* Echte DB (oft SQLite/Testcontainer)
* Echter DI-Container

---

## Best Practices

* **Viele Unit-Tests**, wenige Integration-Tests
* Unit-Tests für Logik
* Integration-Tests für:

  * DB-Zugriff
  * Routing
  * Konfiguration
* Beide ergänzen sich, ersetzen sich nicht

---

### Zusammenfassung

* **Unit-Tests** prüfen isolierte Logik schnell und zuverlässig
* **Integration-Tests** prüfen das Zusammenspiel realer Komponenten
* Unit-Tests = Basis
* Integration-Tests = Absicherung
* Professionelle Projekte nutzen **beide Testarten**

**Weiterführende Doku:**

* PHPUnit Basics:
  [https://phpunit.de/documentation.html](https://phpunit.de/documentation.html)

  **[⬆ Наверх](#top)**

62. ### <a name="62"></a> Was ist PHPUnit?

## Was ist PHPUnit?

### Definition

**PHPUnit** ist das **Standard-Testing-Framework für PHP**.
Es wird verwendet, um **automatisierte Tests** zu schreiben und auszuführen – vor allem **Unit-Tests**, aber auch **Integration-Tests**.

---

## Zweck von PHPUnit

* Sicherstellen, dass Code **korrekt funktioniert**
* Regressionen früh erkennen
* Refactoring ermöglichen
* Code-Qualität erhöhen

---

## Grundkonzept

Ein Test:

* besteht aus **Testklassen**
* enthält **Testmethoden**
* prüft Erwartungen mit **Assertions**

---

## Einfaches Beispiel (Unit-Test)

```php
use PHPUnit\Framework\TestCase;

class MathTest extends TestCase
{
    public function testAddition(): void
    {
        $this->assertSame(4, 2 + 2);
    }
}
```

* `TestCase` ist die Basisklasse
* Methoden mit `test*` werden automatisch ausgeführt

---

## Assertions (Auswahl)

```php
$this->assertSame($expected, $actual);
$this->assertTrue($value);
$this->assertFalse($value);
$this->assertNull($value);
$this->assertCount(3, $array);
```

* Assertions prüfen Erwartungen
* Bei Fehlschlag → Test schlägt fehl

---

## Test ausführen

```bash
vendor/bin/phpunit
```

Oder mit Konfiguration:

```bash
vendor/bin/phpunit --configuration phpunit.xml
```

---

## Mocks & Stubs (Isolation)

```php
$repo = $this->createMock(UserRepository::class);
$repo->method('find')->willReturn(null);
```

* Abhängigkeiten simulieren
* Wichtig für echte Unit-Tests

---

## PHPUnit im Framework-Kontext

### Symfony

* PHPUnit ist **Standard**
* Tests unter `tests/`
* Integration mit Kernel & Container

### Laravel

* PHPUnit vorinstalliert
* `php artisan test` nutzt PHPUnit intern

---

## Testarten mit PHPUnit

* Unit-Tests
* Integration-Tests
* Feature-/HTTP-Tests (Framework-abhängig)
* Datengetriebene Tests (Data Provider)

---

### Zusammenfassung

* PHPUnit ist das Standard-Testframework für PHP
* Ermöglicht automatisierte Unit- und Integration-Tests
* Arbeitet mit Assertions, Mocks und TestCases
* Fester Bestandteil von Symfony & Laravel
* Grundlage für professionelle PHP-Entwicklung

**Weiterführende Doku:**

* PHPUnit Dokumentation:
  [https://phpunit.de/documentation.html](https://phpunit.de/documentation.html)

  **[⬆ Наверх](#top)**

63. ### <a name="63"></a> Was sind Mocks und Stubs?

## Was sind Mocks und Stubs?

### Grundidee

**Mocks** und **Stubs** sind **Test-Doubles**.
Sie ersetzen reale Abhängigkeiten (DB, APIs, Services), um **Unit-Tests zu isolieren** und **deterministisch** zu machen.

---

## Stubs

### Zweck

**Stubs liefern vorgefertigte Antworten**, damit der getestete Code weiterlaufen kann.
Sie **prüfen kein Verhalten**, sondern stellen nur Daten bereit.

```php
$repo = $this->createStub(UserRepository::class);
$repo->method('find')->willReturn(null);
```

**Eigenschaften**

* Gibt feste Werte zurück
* Keine Verhaltensprüfung
* Einfach und stabil

**Wann verwenden?**

* Wenn das *Ergebnis* wichtig ist, nicht die Interaktion
* Für reine Datenlieferanten

---

## Mocks

### Zweck

**Mocks prüfen, ob und wie Abhängigkeiten aufgerufen wurden**.
Sie verifizieren **Interaktionen** (Methoden, Aufrufanzahl, Parameter).

```php
$mailer = $this->createMock(Mailer::class);
$mailer->expects($this->once())
       ->method('send')
       ->with('user@example.com');
```

**Eigenschaften**

* Erwartet bestimmte Aufrufe
* Test schlägt fehl, wenn Erwartungen nicht erfüllt sind
* Strenger als Stubs

**Wann verwenden?**

* Wenn *Nebenwirkungen* relevant sind (z. B. Mail versendet)
* Für Command-/Action-Logik

---

## Vergleich auf einen Blick

| Aspekt        | Stub    | Mock          |
| ------------- | ------- | ------------- |
| Liefert Werte | ✔       | ✔             |
| Prüft Aufrufe | ✘       | ✔             |
| Fokus         | Zustand | Verhalten     |
| Strenge       | Niedrig | Hoch          |
| Einsatz       | Daten   | Interaktionen |

---

## Beispiel: Service testen

```php
class UserService {
    public function __construct(
        private UserRepository $repo,
        private Mailer $mailer
    ) {}

    public function register(string $email): void {
        $this->repo->save($email);
        $this->mailer->send($email);
    }
}
```

**Stub für Repository, Mock für Mailer:**

```php
$repo = $this->createStub(UserRepository::class);

$mailer = $this->createMock(Mailer::class);
$mailer->expects($this->once())
       ->method('send');

$service = new UserService($repo, $mailer);
$service->register('a@example.com');
```

---

## Best Practices

* **Stubs bevorzugen**, wenn möglich (weniger fragile Tests)
* **Mocks gezielt** für wichtige Interaktionen einsetzen
* Nicht alles mocken → Integration-Tests ergänzen
* Mocks nicht für Business-Logik missbrauchen

---

### Zusammenfassung

* **Stubs** liefern kontrollierte Rückgabewerte
* **Mocks** überprüfen Interaktionen
* Beide isolieren Unit-Tests von externen Abhängigkeiten
* Stubs = Zustand, Mocks = Verhalten
* Sinnvolle Kombination erhöht Testqualität

**Weiterführende Doku:**

* PHPUnit Test Doubles:
  [https://phpunit.de/documentation.html#test-doubles](https://phpunit.de/documentation.html#test-doubles)

  **[⬆ Наверх](#top)**

64. ### <a name="64"></a> Warum sind Tests im Backend wichtig?

## Warum sind Tests im Backend wichtig?

### 1) Früherkennung von Fehlern

Tests entdecken **Bugs früh**, oft schon beim Entwickeln oder im CI-Pipeline-Lauf – bevor sie in Produktion gehen.

* Günstiger zu beheben
* Weniger Produktionsfehler
* Schnellere Feedback-Loops

---

### 2) Absicherung von Business-Logik

Backend enthält **kritische Logik** (Zahlungen, Berechtigungen, Datenkonsistenz).

* Tests stellen sicher, dass Regeln korrekt umgesetzt sind
* Verhindern stille Fehler bei Edge-Cases
* Schützen vor unbeabsichtigten Änderungen

---

### 3) Schutz vor Regressionen

Bei Änderungen oder Refactoring prüfen Tests automatisch:

* Ob bestehende Funktionalität **weiterhin korrekt** arbeitet
* Ob neue Änderungen alte Features kaputtmachen

→ Besonders wichtig in wachsenden Codebases.

---

### 4) Erleichtert Refactoring

Mit guter Testabdeckung kann man Code:

* sicher umbauen
* vereinfachen
* optimieren

Ohne Tests ist Refactoring riskant und teuer.

---

### 5) Bessere Architektur & Code-Qualität

Testbarer Code ist meist:

* modular
* lose gekoppelt
* klar strukturiert

Tests fördern:

* Dependency Injection
* klare Verantwortlichkeiten
* saubere APIs

---

### 6) Dokumentation des Verhaltens

Tests zeigen **wie Code gedacht ist**, nicht nur *was er tut*.

```php
public function testUserCannotLoginWithInvalidPassword(): void
```

* Lesbare Spezifikation
* Hilfreich für neue Teammitglieder
* Verlässlicher als Wiki-Dokumentation

---

### 7) Sicherheit & Stabilität

Tests helfen bei:

* Auth/Permission-Logik
* Validierung
* Fehlerbehandlung
* Edge-Cases

Besonders relevant für:

* APIs
* Multi-User-Systeme
* Finanz-/Gesundheitsdaten

---

### 8) CI/CD & professionelle Entwicklung

In modernen Projekten sind Tests **Pflicht**:

* Automatische Checks bei Pull Requests
* Blockieren fehlerhaften Code
* Erhöhen Vertrauen in Deployments

Ohne Tests kein echtes Continuous Deployment.

---

### Zusammenfassung

* Tests verhindern Bugs und Regressionen
* Sie sichern Business-Logik und Datenintegrität
* Ermöglichen sicheres Refactoring
* Verbessern Architektur und Wartbarkeit
* Sind Grundlage für CI/CD und professionelle Backend-Entwicklung

Kurz: **Tests machen Backend-Code stabil, vertrauenswürdig und skalierbar.**

  **[⬆ Наверх](#top)**

65. ### <a name="65"></a> Was ist das N+1-Problem?

## Was ist das N+1-Problem?

### Definition

Das **N+1-Problem** ist ein **Performance-Problem bei Datenbankzugriffen**, das häufig bei **ORMs** auftritt.
Es bedeutet, dass statt **einer effizienten Abfrage** **N zusätzliche Abfragen** ausgeführt werden.

---

## Wie entsteht das N+1-Problem?

### Beispiel (Users → Orders)

```php
$users = $userRepository->findAll();

foreach ($users as $user) {
    $orders = $user->getOrders(); // zusätzliche Query pro User
}
```

**Was passiert intern:**

1. **1 Query**: Lade alle Users
2. **N Queries**: Lade Orders für jeden User einzeln

→ **1 + N Queries**

Bei 100 Users → **101 Datenbankabfragen** ❌

---

## Warum ist das problematisch?

* Massive Performance-Verluste
* Hohe DB-Last
* Langsame API-Responses
* Skaliert sehr schlecht

---

## Erkennen des N+1-Problems

* SQL-Logs zeigen viele ähnliche Queries
* Performance-Profiler (Symfony Profiler, Laravel Debugbar)
* Auffällig viele Queries pro Request

---

## Lösung 1: Eager Loading (empfohlen)

### Doctrine (Symfony)

```php
$query = $entityManager->createQuery(
    'SELECT u, o FROM App\Entity\User u
     JOIN FETCH u.orders o'
);
```

Oder im Repository:

```php
->leftJoin('u.orders', 'o')
->addSelect('o')
```

---

### Eloquent (Laravel)

```php
$users = User::with('orders')->get();
```

* Lädt Relationen **in einer (oder wenigen) Queries**
* Verhindert zusätzliche Lazy-Loads

---

## Lösung 2: Explizite Joins

* Statt Objekt-Navigation direkt SQL/QueryBuilder nutzen
* Besonders bei Listen & Reports sinnvoll

---

## Lösung 3: Lazy Loading bewusst einsetzen

* Lazy Loading ist **nicht per se schlecht**
* Aber gefährlich in Schleifen
* Regel: **Nie Lazy Loading in Loops**

---

## Typischer Vergleich

| Ansatz           | Anzahl Queries |
| ---------------- | -------------- |
| Lazy Loading     | 1 + N          |
| Eager Loading    | 1–2            |
| Optimierter Join | 1              |

---

## ORMs & N+1

* **Doctrine & Eloquent** sind beide betroffen
* Problem liegt **nicht am ORM**, sondern an falscher Nutzung
* Gute ORM-Nutzung = bewusstes Laden von Relationen

---

### Zusammenfassung

* N+1 = 1 Hauptquery + N Folgequeries
* Entsteht oft durch Lazy Loading in Schleifen
* Führt zu massiven Performance-Problemen
* Lösung: **Eager Loading oder Joins**
* Sehr häufige Interviewfrage im Backend

**Weiterführende Doku:**

* Doctrine Fetch Joins:
  [https://www.doctrine-project.org/projects/doctrine-orm/en/current/reference/dql-doctrine-query-language.html#fetch-joins](https://www.doctrine-project.org/projects/doctrine-orm/en/current/reference/dql-doctrine-query-language.html#fetch-joins)
* Laravel Eager Loading:
  [https://laravel.com/docs/eloquent-relationships#eager-loading](https://laravel.com/docs/eloquent-relationships#eager-loading)

  **[⬆ Наверх](#top)**

66. ### <a name="66"></a> Welche Caching-Strategien kennst du (Redis, APCu)?

## Welche Caching-Strategien kennst du (Redis, APCu)?

### Grundidee

**Caching** speichert häufig benötigte Daten temporär, um:

* Datenbankzugriffe zu reduzieren
* Antwortzeiten zu verkürzen
* Last und Kosten zu senken

Wichtig: Cache ist **optimierend**, nicht die primäre Datenquelle.

---

## Ebenen des Cachings (Überblick)

1. **In-Memory Cache (lokal)** → APCu
2. **Distributed Cache** → Redis
3. **Application Cache** → Ergebnisse von Services/Queries
4. **HTTP Cache** → Reverse Proxy / Browser
5. **ORM Cache** → Query-/Result-Cache

---

## APCu (lokaler In-Memory Cache)

### Eigenschaften

* Läuft **im PHP-Prozess**
* Extrem schnell
* **Nicht geteilt** zwischen Servern/Containern
* Cache geht bei Prozess-Neustart verloren

```php
apcu_store('user_1', $user, 300);
$user = apcu_fetch('user_1');
```

**Einsatz**

* Kleine, häufig genutzte Daten
* Feature Flags
* Konfigurationswerte

**Grenzen**

* Nicht clusterfähig
* Nicht geeignet für mehrere PHP-FPM-Worker über Server hinweg

**Docs:**
[https://www.php.net/manual/en/book.apcu.php](https://www.php.net/manual/en/book.apcu.php)

---

## Redis (Distributed Cache)

### Eigenschaften

* Externer In-Memory-Store
* **Mehrere Server / Prozesse teilen sich den Cache**
* Sehr schnell
* Unterstützt TTL, Sets, Hashes, Lists
* Persistenz optional

```php
$redis->setex('user:1', 300, json_encode($user));
```

**Einsatz**

* Session-Storage
* Query-/Result-Cache
* Rate Limiting
* Queues / Jobs
* Locks

**Vorteile**

* Skalierbar
* Clusterfähig
* Stabil in Production

**Docs:**
[https://redis.io/docs/](https://redis.io/docs/)

---

## Cache-Strategien (Patterns)

### 1) Cache-Aside (Lazy Loading) – Standard

```text
Request → Cache?
  ↳ Hit → Return
  ↳ Miss → DB → Cache → Return
```

* Einfach
* Sehr verbreitet
* Cache wird bei Bedarf gefüllt

---

### 2) Write-Through

```text
Write → Cache + DB
```

* Cache immer aktuell
* Schreibzugriffe langsamer

---

### 3) Write-Behind (Write-Back)

```text
Write → Cache → DB (async)
```

* Sehr schnell
* Risiko bei Cache-Verlust
* Selten für Business-Daten

---

### 4) Read-Through

* Cache kümmert sich selbst um DB-Fetch
* Weniger verbreitet in PHP

---

## Cache-Invalidierung (kritisch!)

Häufigste Strategien:

* **TTL (Time To Live)**
* Explizites Löschen bei Updates
* Versionierte Cache-Keys

```php
$userKey = 'user:'.$id.':v2';
```

> „There are only two hard things in Computer Science: cache invalidation and naming things.“

---

## APCu vs. Redis – Vergleich

| Aspekt           | APCu          | Redis           |
| ---------------- | ------------- | --------------- |
| Speicherort      | PHP-Prozess   | Externer Server |
| Geschwindigkeit  | Sehr hoch     | Sehr hoch       |
| Mehrere Server   | ❌             | ✔               |
| Persistenz       | ❌             | Optional        |
| Typische Nutzung | Lokaler Cache | Globaler Cache  |

---

## Framework-Integration

### Symfony

* Cache Component (PSR-6 / PSR-16)
* Adapter: APCu, Redis

```php
CacheInterface $cache
```

**Docs:**
[https://symfony.com/doc/current/cache.html](https://symfony.com/doc/current/cache.html)

---

### Laravel

* Einheitliches Cache-API
* Driver: Redis, APCu, Memcached

```php
Cache::remember('key', 300, fn () => $value);
```

**Docs:**
[https://laravel.com/docs/cache](https://laravel.com/docs/cache)

---

### Zusammenfassung

* Caching reduziert DB-Last und beschleunigt Responses
* **APCu**: extrem schnell, lokal, nicht clusterfähig
* **Redis**: verteilt, skalierbar, production-tauglich
* Cache-Aside ist die Standardstrategie
* Cache-Invalidierung ist entscheidend für Korrektheit
* Frameworks abstrahieren Caching über einheitliche APIs

  **[⬆ Наверх](#top)**

67. ### <a name="67"></a> Was bedeutet Lazy Loading?

## Was bedeutet Lazy Loading?

### Definition

**Lazy Loading** bedeutet, dass Daten oder Ressourcen **erst dann geladen werden, wenn sie tatsächlich benötigt werden** – nicht im Voraus.

Im Backend-Kontext (PHP, ORMs) bezieht sich Lazy Loading meist auf das **verzögerte Laden von Relationen aus der Datenbank**.

---

## Beispiel ohne Lazy Loading (Eager Loading)

```php
$users = User::with('orders')->get();
```

* Users **und** Orders werden sofort geladen
* Mehr Speicherverbrauch
* Keine zusätzlichen Queries später

---

## Lazy Loading in ORMs

### Eloquent (Laravel)

```php
$users = User::all(); // nur Users

foreach ($users as $user) {
    $orders = $user->orders; // Query wird hier ausgelöst
}
```

* Relation wird **erst beim Zugriff** geladen
* Jede Nutzung triggert ggf. eine DB-Abfrage

---

### Doctrine (Symfony)

```php
$user = $entityManager->find(User::class, 1);
$orders = $user->getOrders(); // Lazy Load
```

* Doctrine nutzt **Proxy-Objekte**
* DB-Zugriff erfolgt erst beim Methodenaufruf

---

## Vorteile von Lazy Loading

* Spart Ressourcen, wenn Daten **nicht benötigt werden**
* Einfacher Code
* Flexibel

---

## Nachteile / Risiken

* **N+1-Problem** bei Zugriff in Schleifen
* Unklare Performance-Kosten
* Versteckte DB-Zugriffe

---

## Lazy vs. Eager Loading (Vergleich)

| Aspekt     | Lazy Loading   | Eager Loading |
| ---------- | -------------- | ------------- |
| Ladezeit   | Später         | Sofort        |
| DB-Queries | Unvorhersehbar | Planbar       |
| Speicher   | Geringer       | Höher         |
| Risiko N+1 | Hoch           | Niedrig       |

---

## Best Practices

* Lazy Loading **nicht in Loops**
* Für Listen & APIs → **Eager Loading**
* Für Detailseiten → Lazy Loading ok
* Queries bewusst planen

---

## Lazy Loading außerhalb von ORMs

* Dateien
* Konfigurationswerte
* Services (on demand)

---

### Zusammenfassung

* Lazy Loading lädt Daten **erst bei Bedarf**
* Häufig bei ORM-Relationen
* Spart Ressourcen, kann aber Performance-Probleme verursachen
* Hauptgefahr: **N+1-Problem**
* Bewusster Einsatz ist entscheidend

**Weiterführende Doku:**

* Doctrine Fetching Strategies:
  [https://www.doctrine-project.org/projects/doctrine-orm/en/current/reference/working-with-associations.html#fetching-strategies](https://www.doctrine-project.org/projects/doctrine-orm/en/current/reference/working-with-associations.html#fetching-strategies)
* Laravel Eloquent Loading:
  [https://laravel.com/docs/eloquent-relationships#lazy-loading](https://laravel.com/docs/eloquent-relationships#lazy-loading)

  **[⬆ Наверх](#top)**

68. ### <a name="68"></a> Wo entstehen typischerweise Performance-Probleme in PHP-Anwendungen?

## Wo entstehen typischerweise Performance-Probleme in PHP-Anwendungen?

### Überblick

Performance-Probleme entstehen meist **nicht im PHP-Core**, sondern durch **I/O, Datenbankzugriffe, falsche Architektur oder Fehlkonfiguration**.
Die folgenden Punkte sind die **häufigsten Ursachen** (interview-relevant).

---

## 1) Datenbankzugriffe (Hauptursache)

### Typische Probleme

* **N+1-Queries**
* Fehlende oder falsche **Indizes**
* `SELECT *` statt gezielter Spalten
* Komplexe Joins ohne Analyse
* Fehlende Transaktionen

```php
foreach ($users as $user) {
    $orders = $user->getOrders(); // N+1
}
```

**Gegenmaßnahmen**

* Eager Loading
* Indizes + `EXPLAIN`
* Query-Optimierung
* Batch-Queries

---

## 2) Fehlendes oder falsches Caching

### Typische Probleme

* Kein Cache für:

  * Konfiguration
  * Rechenintensive Operationen
  * DB-Abfragen
* Falsche Cache-Invalidierung

**Gegenmaßnahmen**

* Redis / APCu einsetzen
* Cache-Aside Pattern
* Sinnvolle TTLs
* Versionierte Cache-Keys

---

## 3) ORM-Overhead & falsche Nutzung

### Typische Probleme

* Zu viele Entities im Speicher
* Unkontrolliertes Lazy Loading
* ORM für Reporting-Queries

**Gegenmaßnahmen**

* Eager Loading
* Query Builder / Raw SQL
* Pagination
* `iterate()` / Cursor nutzen

---

## 4) PHP-Runtime & Konfiguration

### Typische Probleme

* **OPcache deaktiviert**
* Zu wenig OPcache-Memory
* `validate_timestamps=1` in Production
* Falsche PHP-FPM-Settings

**Gegenmaßnahmen**

* OPcache korrekt konfigurieren
* PHP-FPM Worker anpassen
* Production-Settings prüfen

---

## 5) Externe Services & Netzwerke

### Typische Probleme

* Langsame API-Calls
* Serielle HTTP-Requests
* Keine Timeouts / Retries

```php
// Blockierend
$response = $client->request(...);
```

**Gegenmaßnahmen**

* Timeouts setzen
* Caching
* Asynchrone Jobs (Queues)
* Circuit Breaker

---

## 6) Große Datenmengen im Speicher

### Typische Probleme

* Große Arrays
* Kein Streaming
* `findAll()` statt Pagination

```php
$users = $repo->findAll(); // ❌
```

**Gegenmaßnahmen**

* Pagination
* Generatoren
* Chunking
* Cursor-basierte Abfragen

---

## 7) I/O-Operationen (Filesystem)

### Typische Probleme

* Häufiges Lesen von Dateien
* Kein Cache für Konfiguration
* Große Logs synchron schreiben

**Gegenmaßnahmen**

* Config-Cache
* Async Logging
* Filesystem-Caching

---

## 8) Fehlendes Profiling & Monitoring

### Typische Probleme

* „Blindes Optimieren“
* Keine Messdaten
* Keine Slow-Query-Logs

**Tools**

* Symfony Profiler
* Laravel Debugbar
* Xdebug / Blackfire
* DB Slow Query Log

---

## 9) Falsche Architekturentscheidungen

### Typische Probleme

* Business-Logik im Controller
* Enge Kopplung
* Fehlende Trennung von Read/Write

**Gegenmaßnahmen**

* Saubere Layer-Architektur
* CQRS (bei Bedarf)
* Services + DI

---

### Zusammenfassung

* Haupt-Bottleneck: **Datenbank**
* Häufige Ursachen: N+1, fehlende Indizes, kein Cache
* ORM falsch eingesetzt = Performance-Risiko
* OPcache & PHP-Config sind Pflicht
* Profiling ist Voraussetzung für Optimierung
* Performance ist meist **Architektur-, nicht PHP-Problem**

**Weiterführende Doku:**

* PHP OPcache:
  [https://www.php.net/manual/en/book.opcache.php](https://www.php.net/manual/en/book.opcache.php)
* Doctrine Performance:
  [https://www.doctrine-project.org/projects/doctrine-orm/en/current/reference/performance.html](https://www.doctrine-project.org/projects/doctrine-orm/en/current/reference/performance.html)

  **[⬆ Наверх](#top)**

69. ### <a name="69"></a> Was ist CSRF und wie schützt man sich davor?

## Was ist CSRF und wie schützt man sich davor?

### Definition

**CSRF (Cross-Site Request Forgery)** ist eine **Sicherheitslücke**, bei der ein Angreifer einen **authentifizierten Benutzer dazu bringt, ungewollt eine Aktion auszuführen**, weil der Browser automatisch **Cookies (Session)** mitsendet.

Der Server kann nicht unterscheiden, ob die Anfrage **legitim** oder **bösartig** ist.

---

## Wie entsteht CSRF?

### Ausgangssituation

* Benutzer ist eingeloggt (Session-Cookie vorhanden)
* Browser sendet Cookies **automatisch** bei jeder Anfrage

---

### Angriffsszenario

1. Benutzer ist bei `bank.example` eingeloggt
2. Benutzer besucht eine **bösartige Seite**
3. Diese Seite sendet im Hintergrund eine Anfrage:

```html
<form action="https://bank.example/transfer" method="POST">
  <input type="hidden" name="amount" value="1000">
  <input type="hidden" name="to" value="attacker">
</form>

<script>
  document.forms[0].submit();
</script>
```

4. Browser sendet die Anfrage **inkl. Session-Cookie**
5. Server denkt: „Benutzer ist authentifiziert“ → Aktion wird ausgeführt ❌

---

## Warum ist das gefährlich?

* Geldüberweisungen
* Passwortänderungen
* Account-Löschungen
* Rechteänderungen

**CSRF betrifft nur zustandsverändernde Requests** (`POST`, `PUT`, `DELETE`).

---

## Schutzmaßnahme #1: CSRF-Token (Standard)

### Prinzip

* Server erzeugt ein **zufälliges, geheimes Token**
* Token wird im Formular mitgesendet
* Server prüft: **Token gültig?**

---

### Beispiel (Core PHP – vereinfacht)

```php
// Token erzeugen
$_SESSION['csrf_token'] = bin2hex(random_bytes(32));
```

```html
<input type="hidden" name="csrf_token" value="<?= $_SESSION['csrf_token'] ?>">
```

```php
// Validierung
if ($_POST['csrf_token'] !== $_SESSION['csrf_token']) {
    http_response_code(403);
    exit('Invalid CSRF token');
}
```

**Warum sicher?**

* Angreifer kann Token nicht erraten
* Token ist nicht über Cross-Origin zugänglich

---

## Schutzmaßnahme #2: SameSite Cookies

```http
Set-Cookie: PHPSESSID=...; SameSite=Lax; Secure; HttpOnly
```

**Wirkung**

* Cookie wird **nicht** bei Cross-Site-Requests gesendet
* Sehr effektiv gegen klassische CSRF-Angriffe

**Wichtig**

* `SameSite=Lax` → guter Standard
* `SameSite=Strict` → sehr restriktiv

---

## Schutzmaßnahme #3: HTTP-Methoden korrekt nutzen

* **Keine Zustandsänderung über GET**
* GET = lesen
* POST/PUT/DELETE = ändern

```php
// ❌ falsch
GET /delete-user?id=5
```

---

## Schutzmaßnahme #4: CSRF-Schutz im Framework

### Symfony

* CSRF-Token automatisch in Formularen
* Schutz aktiv per `CsrfTokenManager`

```twig
{{ csrf_token('authenticate') }}
```

**Doku:**
[https://symfony.com/doc/current/security/csrf.html](https://symfony.com/doc/current/security/csrf.html)

---

### Laravel

* CSRF-Schutz standardmäßig aktiv
* Token in jedem Formular

```blade
@csrf
```

* Middleware prüft Token automatisch

**Doku:**
[https://laravel.com/docs/csrf](https://laravel.com/docs/csrf)

---

## Was **nicht** gegen CSRF hilft

❌ `POST` allein
❌ `Referer`-Header prüfen
❌ Input-Validation
❌ Authentifizierung

---

## CSRF vs. XSS (klar trennen)

* **CSRF** → missbraucht **Session des Opfers**
* **XSS** → führt Code im Browser aus

XSS kann CSRF **umgehen**, daher:
→ **XSS-Schutz ist indirekt auch CSRF-Schutz**

---

### Zusammenfassung

* CSRF zwingt eingeloggte Nutzer zu ungewollten Aktionen
* Ursache: Browser sendet Cookies automatisch
* Hauptschutz: **CSRF-Tokens**
* Ergänzend: **SameSite-Cookies**
* Frameworks schützen standardmäßig
* Betrifft nur zustandsverändernde Requests

**Weiterführende Doku:**

* OWASP CSRF:
  [https://owasp.org/www-community/attacks/csrf](https://owasp.org/www-community/attacks/csrf)
* Symfony CSRF Protection:
  [https://symfony.com/doc/current/security/csrf.html](https://symfony.com/doc/current/security/csrf.html)

  **[⬆ Наверх](#top)**

70. ### <a name="70"></a> JWT vs. Session-basierte Authentifizierung

## JWT vs. Session-basierte Authentifizierung

### Grundidee

Beide Ansätze authentifizieren Benutzer, unterscheiden sich aber darin, **wo der Authentifizierungszustand gespeichert wird**.

* **Session-basiert** → Zustand liegt **serverseitig**
* **JWT (JSON Web Token)** → Zustand liegt **im Token auf Client-Seite**

---

## Session-basierte Authentifizierung

### Funktionsweise

1. Login erfolgreich
2. Server erstellt **Session**
3. Session-ID wird als **Cookie** gespeichert
4. Bei jedem Request sendet der Browser das Cookie
5. Server liest Session-Daten

```php
session_start();
$_SESSION['user_id'] = 42;
```

### Eigenschaften

* Server kennt den Auth-Zustand
* Session kann serverseitig gelöscht werden
* Cookies werden automatisch gesendet

### Vorteile

* Einfach zu implementieren
* Sehr sicher bei korrekter Konfiguration
* Leicht widerrufbar (Logout)
* Standard für klassische Web-Apps

### Nachteile

* Server muss Sessions speichern
* Skalierung benötigt:

  * Sticky Sessions oder
  * Shared Storage (Redis)

---

## JWT-basierte Authentifizierung

### Funktionsweise

1. Login erfolgreich
2. Server erstellt **JWT**
3. Token wird dem Client übergeben
4. Client sendet Token bei jedem Request (Header)
5. Server validiert Token-Signatur

```http
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

### Token-Inhalt (Payload)

```json
{
  "sub": 42,
  "exp": 1710000000,
  "role": "user"
}
```

### Eigenschaften

* Server speichert **keinen Zustand**
* Token enthält Claims (User-ID, Rollen)
* Validierung über Signatur

### Vorteile

* Stateless → sehr gut skalierbar
* Ideal für APIs & Microservices
* Kein Session-Storage nötig

### Nachteile

* Token-Revocation schwierig
* Logout nur indirekt (Ablaufzeit)
* Token-Diebstahl kritisch
* Größere Payload bei jedem Request

---

## Sicherheitsaspekte (wichtig im Interview)

### Session

* Schutz durch:

  * `HttpOnly`, `Secure`, `SameSite`
  * CSRF-Tokens
* Sehr robust bei Web-Forms

### JWT

* Token **niemals im LocalStorage**
* Besser:

  * HttpOnly-Cookie **oder**
  * Authorization Header (SPA)
* Kurze `exp` + optional Refresh Tokens
* XSS = hohes Risiko

---

## Vergleich auf einen Blick

| Aspekt      | Session     | JWT             |
| ----------- | ----------- | --------------- |
| Zustand     | Server      | Client          |
| Skalierung  | Aufwendiger | Sehr gut        |
| Widerruf    | Einfach     | Schwierig       |
| Speicher    | Server      | Client          |
| CSRF-Risiko | Ja          | Nur bei Cookies |
| API-Eignung | Mittel      | Sehr gut        |
| Web-Apps    | Sehr gut    | Möglich         |

---

## Typische Einsatzszenarien

### Session verwenden, wenn:

* Klassische Web-App
* Serverseitiges Rendering
* Einfache Auth-Logik
* Logout & Widerruf wichtig

### JWT verwenden, wenn:

* REST API
* SPA / Mobile App
* Microservices
* Hohe Skalierung

---

## Kombination (Best Practice)

* **Web-App** → Session
* **API** → JWT
* Oder:

  * JWT **im HttpOnly-Cookie**
  * Mit kurzer Laufzeit + Refresh Token

---

### Zusammenfassung

* Session = serverseitig, sicher, einfach
* JWT = stateless, skalierbar, API-freundlich
* JWT erschwert Widerruf & Logout
* Wahl hängt vom Use Case ab
* Kein Ansatz ist „besser“ – nur **passender**

**Weiterführende Doku:**

* PHP Sessions:
  [https://www.php.net/manual/en/book.session.php](https://www.php.net/manual/en/book.session.php)
* JWT Einführung (RFC 7519):
  [https://datatracker.ietf.org/doc/html/rfc7519](https://datatracker.ietf.org/doc/html/rfc7519)

  **[⬆ Наверх](#top)**

71. ### <a name="71"></a> Was ist CORS und warum ist es relevant?

## Was ist CORS und warum ist es relevant?

### Definition

**CORS (Cross-Origin Resource Sharing)** ist ein **Browser-Sicherheitsmechanismus**, der steuert, **ob eine Webanwendung Ressourcen von einer anderen Origin** (Domain/Port/Protokoll) **abrufen darf**.

CORS ist **kein Server-Feature**, sondern eine **Browser-Regel**, die durch **HTTP-Header vom Server** konfiguriert wird.

---

## Warum gibt es CORS?

Browser verbieten standardmäßig **Cross-Origin-Requests** aus JavaScript (Same-Origin-Policy), um:

* Datenlecks zu verhindern
* Benutzer vor bösartigen Webseiten zu schützen

**Beispiel (blockiert ohne CORS):**

* Frontend: `https://app.example`
* API: `https://api.example`
* `fetch()` von `app.example` zu `api.example` → **CORS nötig**

---

## Was ist eine „Origin“?

Eine Origin ist die Kombination aus:

* **Protokoll** (`https`)
* **Domain** (`example.com`)
* **Port** (`443`)

Schon **eine Abweichung** ⇒ andere Origin.

---

## Wie funktioniert CORS technisch?

### Wichtige Response-Header

```http
Access-Control-Allow-Origin: https://app.example
Access-Control-Allow-Methods: GET, POST, PUT, DELETE
Access-Control-Allow-Headers: Content-Type, Authorization
Access-Control-Allow-Credentials: true
```

* **Allow-Origin**: Wer darf zugreifen?
* **Allow-Methods**: Welche HTTP-Methoden?
* **Allow-Headers**: Welche Request-Header?
* **Allow-Credentials**: Cookies/Authorization erlaubt?

---

## Simple Request vs. Preflight

### Simple Request

* Methoden: `GET`, `POST`, `HEAD`
* Standard-Header
  → **Kein Preflight**

### Preflight Request (OPTIONS)

Bei „komplizierten“ Requests (z. B. `PUT`, `DELETE`, `Authorization`):

1. Browser sendet `OPTIONS`
2. Server antwortet mit CORS-Headern
3. Browser entscheidet, ob der echte Request erlaubt ist

```http
OPTIONS /users HTTP/1.1
```

---

## Typische CORS-Probleme

* API funktioniert mit `curl`, aber **nicht im Browser**
* Fehlende `Access-Control-Allow-Origin`
* `Allow-Credentials=true` + `Allow-Origin=*` ❌ (verboten)
* Vergessene Behandlung von `OPTIONS`

---

## CORS & Security (wichtig)

* **CORS schützt nicht die API**
* Es schützt **den Browser-Nutzer**
* Server muss trotzdem:

  * Authentifizieren
  * Autorisieren
  * Validieren

> Ein Angreifer kann CORS **nicht** umgehen, aber auch **nicht** dadurch gestoppt werden, serverseitige Checks zu umgehen.

---

## CORS in Frameworks

### Symfony

```yaml
# nelmio_cors.yaml
nelmio_cors:
  defaults:
    allow_origin: ['https://app.example']
    allow_methods: ['GET', 'POST', 'PUT', 'DELETE']
    allow_headers: ['Content-Type', 'Authorization']
```

**Docs:** [https://symfony.com/doc/current/security/cors.html](https://symfony.com/doc/current/security/cors.html)

---

### Laravel

```php
// config/cors.php
'allowed_origins' => ['https://app.example'],
'allowed_methods' => ['*'],
'allowed_headers' => ['*'],
```

**Docs:** [https://laravel.com/docs/routing#cors](https://laravel.com/docs/routing#cors)

---

## Best Practices

* Origins **explizit** erlauben (kein `*` in Prod)
* `OPTIONS` korrekt behandeln
* Credentials nur wenn nötig
* CORS **nicht** als Auth-Ersatz sehen
* Unterschied zwischen Browser & Server verstehen

---

### Zusammenfassung

* CORS ist eine **Browser-Sicherheitsregel**
* Steuert Cross-Origin-Zugriffe per HTTP-Header
* Relevant für SPAs, APIs, Microservices
* Verhindert keine Angriffe auf die API selbst
* Korrekte Konfiguration ist essenziell für funktionierende Frontend–Backend-Kommunikation

**Weiterführende Doku:**

* MDN CORS:
  [https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)
* Fetch & CORS:
  [https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch)

  **[⬆ Наверх](#top)**

72. ### <a name="72"></a> Best Practices für Authentifizierung und Autorisierung

## Best Practices für Authentifizierung und Autorisierung

### Begriffe sauber trennen

* **Authentifizierung (AuthN):** Wer bist du? (Login, Token, Session)
* **Autorisierung (AuthZ):** Was darfst du? (Rollen, Rechte, Policies)

---

## Authentifizierung – Best Practices

### 1) Sichere Passwort-Logik

* `password_hash()` + `password_verify()`
* Keine eigenen Hashes, kein `md5/sha1`

**Docs:** [https://www.php.net/manual/en/book.password.php](https://www.php.net/manual/en/book.password.php)

---

### 2) Session-Sicherheit (wenn Session-basiert)

* Cookies: `HttpOnly`, `Secure`, `SameSite`
* Session-ID nach Login **regenerieren**
* Kurze Idle-Timeouts

```php
session_start();
session_regenerate_id(true);
```

**Docs:** [https://www.php.net/manual/en/function.session-regenerate-id.php](https://www.php.net/manual/en/function.session-regenerate-id.php)

---

### 3) Token-Sicherheit (wenn JWT/Token-basiert)

* **Kurze Access-Token-Laufzeit** (`exp`)
* Refresh Tokens getrennt und sicher speichern
* Tokens nicht in `localStorage` (XSS-Risiko)
* Prefer: **HttpOnly Cookie** oder konsequent Header + XSS-Schutz
* Bei JWT: Signatur prüfen, `exp`, `iss`, `aud` validieren

**JWT RFC:** [https://datatracker.ietf.org/doc/html/rfc7519](https://datatracker.ietf.org/doc/html/rfc7519)

---

### 4) Rate Limiting & Brute-Force-Schutz

* Limit pro IP/User/Endpoint
* Lockout/Backoff (vorsichtig, DoS vermeiden)
* Captcha nur bei Verdacht

---

### 5) 2FA (wo sinnvoll)

* Für Admins, sensible Accounts
* TOTP/WebAuthn je nach Bedarf

---

### 6) Sichere Fehlerantworten

* Login-Fehler nicht verraten, ob User existiert
* Einheitliche Messages + Logging intern

---

## Autorisierung – Best Practices

### 1) RBAC + Policies (klarer Standard)

* **RBAC** (Roles): `admin`, `user`, `editor`
* **Permissions** fein granular: `user.read`, `user.write`
* **Policy/Guard** pro Ressource und Aktion

Beispiel-Policy:

* „Darf User X Profil von User Y sehen?“
* „Darf User X Order Y stornieren?“

---

### 2) Serverseitig überall prüfen

* Nicht nur im Frontend
* Nicht nur „auf der UI“
* Jede sensitive Aktion braucht eine AuthZ-Prüfung

---

### 3) Least Privilege

* Standardrolle minimal
* Admin-Rechte explizit vergeben
* Keine „god roles“ in der Fachlogik

---

### 4) Ownership-Checks (sehr häufig im Interview)

Nicht nur Rolle prüfen, sondern **Besitz/Beziehung**:

```php
if ($order->userId !== $currentUserId) {
    throw new AccessDeniedException();
}
```

---

### 5) Multi-Tenancy / Mandantenfähigkeit (falls relevant)

* Immer `tenant_id` in Queries berücksichtigen
* Keine „globalen“ Finds ohne Tenant-Filter

---

### 6) Fail Closed

Wenn unklar → **Zugriff verweigern** (Default Deny).

---

## Framework-spezifisch

### Symfony (Security)

* Firewalls + User Provider
* Voter/Access Control für Policies
* `isGranted()` für Entscheidungen

**Docs:** [https://symfony.com/doc/current/security.html](https://symfony.com/doc/current/security.html)

---

### Laravel (Auth + Gates/Policies)

* Guards (Session/JWT via Packages)
* Gates/Policies für Autorisierung

**Docs:**

* Auth: [https://laravel.com/docs/authentication](https://laravel.com/docs/authentication)
* Authorization: [https://laravel.com/docs/authorization](https://laravel.com/docs/authorization)

---

## Häufige Sicherheitsbausteine, die dazugehören

* **CSRF-Schutz** (bei Cookie/Session Auth)
* **CORS korrekt konfigurieren** (für Browser-Clients)
* **Input Validation + Output Escaping**
* **Audit Logging** für Admin-Aktionen
* **Secrets** in ENV/Secret Manager, nie im Repo

**OWASP Top 10:** [https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/)

---

### Zusammenfassung

* AuthN: sichere Passwörter, sichere Sessions/Tokens, Rate Limiting, saubere Token-Validierung
* AuthZ: RBAC + Policies, Ownership-Checks, least privilege, überall serverseitig prüfen
* Frameworks liefern dafür fertige Mechanismen (Symfony Security, Laravel Policies/Gates)
* Default-Deny und konsistentes Logging sind zentrale Prinzipien

  **[⬆ Наверх](#top)**

73. ### <a name="73"></a> Wie debugst du PHP-Code?

## Wie debugst du PHP-Code?

### Grundprinzip

Debugging in PHP bedeutet **systematisch Ursachen finden**, nicht „blindes Rumprobieren“.
Effektives Debugging kombiniert **Logs, Debugger, Tests und Profiling**.

---

## 1) Fehler korrekt sichtbar machen (Grundlage)

### Development-Umgebung

```ini
display_errors = On
error_reporting = E_ALL
```

Oder im Code:

```php
ini_set('display_errors', '1');
error_reporting(E_ALL);
```

* Nur **in Development**
* In Production → **Logging statt Anzeige**

---

## 2) Logging (wichtigster Debug-Weg)

### PHP Error Log

```php
error_log('Debug: User not found');
```

* Schnell
* Immer verfügbar
* Auch in Production nutzbar

---

### Framework-Logging

* Symfony / Laravel → Monolog
* Kontextdaten loggen

```php
$logger->error('Payment failed', [
    'orderId' => $orderId,
    'exception' => $e,
]);
```

**Warum wichtig:**
Logs zeigen **was wirklich passiert ist**, nicht was man denkt.

---

## 3) Dumping (schnell, lokal)

```php
var_dump($data);
```

Frameworks:

* Symfony: `dump($var)`
* Laravel: `dd($var)`

**Einsatz**

* Schnelle Kontrolle
* Lokales Debugging

❌ Nicht für Production
❌ Nicht für komplexe Flows

---

## 4) Debugger: Xdebug (professionell)

### Was Xdebug kann

* Breakpoints
* Step-by-step-Ausführung
* Variablen inspizieren
* Call Stack analysieren

### Typischer Ablauf

1. Breakpoint setzen
2. Request ausführen
3. Code schrittweise durchgehen
4. Zustand analysieren

**Tools**

* PhpStorm + Xdebug
* VS Code + Xdebug

**Warum wichtig:**
Unverzichtbar bei komplexer Logik.

---

## 5) Framework-Profiler

### Symfony Profiler

* SQL-Queries
* Requests
* Services
* Events
* Performance

### Laravel Debugbar

* Queries
* Views
* Memory
* Time

**Nutzen**

* N+1 erkennen
* Langsame Queries finden
* Request-Flows verstehen

---

## 6) Tests als Debug-Werkzeug

* Bug reproduzieren
* Test schreiben → rot
* Fix → grün

```php
public function testOrderFailsWithoutPayment(): void
{
    $this->expectException(PaymentException::class);
}
```

**Vorteil**

* Bug kommt **nie zurück**
* Sauberster Fix

---

## 7) Datenbank-Debugging

### SQL anzeigen

* ORM SQL-Logging aktivieren
* `EXPLAIN` verwenden

```sql
EXPLAIN SELECT * FROM users WHERE email = 'a@example.com';
```

**Ziel**

* N+1 erkennen
* Fehlende Indizes
* Teure Joins

---

## 8) Debugging von APIs

* Postman / HTTPie
* Statuscodes prüfen
* Request-/Response-Payloads loggen
* Headers kontrollieren (Auth, CORS)

---

## 9) Debugging in Production (vorsichtig)

* **Keine Dumps**
* **Keine Debug-Ausgaben**
* Nur:

  * Logs
  * Monitoring
  * Trace-IDs
  * Error-Tracking (z. B. Sentry)

---

## Typische Debug-Reihenfolge (Interview-tauglich)

1. Fehler reproduzieren
2. Logs prüfen
3. Daten prüfen
4. Debugger einsetzen
5. Fix mit Test absichern

---

### Zusammenfassung

* Grundlage: sauberes Error Reporting
* Logs sind das wichtigste Werkzeug
* Dumps nur lokal
* Xdebug für komplexe Probleme
* Profiler für Performance & Queries
* Tests sichern Fixes dauerhaft
* Production-Debugging = Logging + Monitoring

Kurz: **erst messen & verstehen, dann fixen.**

  **[⬆ Наверх](#top)**

74. ### <a name="74"></a> Wie gehst du mit Legacy-Code um?

## Wie gehst du mit Legacy-Code um?

### 1) Erst verstehen, dann ändern

* Code lesen + Business-Flow nachvollziehen
* „Warum existiert das?“ klären (Tickets, Domain, Stakeholder)
* **Beobachten statt sofort refactoren**

---

## 2) Risiken minimieren: Sicherheitsnetz bauen

### Charakterisierungstests (Golden Master)

* Verhalten des aktuellen Systems festhalten, bevor man etwas ändert

```php
public function testLegacyBehavior(): void
{
    $result = $this->service->process($input);
    $this->assertSame($expected, $result);
}
```

* Nicht perfekt, aber schützt vor Regressionen

---

## 3) Kleine, inkrementelle Schritte (Boy Scout Rule)

* Kleine PRs
* Pro Änderung: **ein klarer Zweck**
* Nach jedem Schritt: Tests + Review

---

## 4) Hotspots priorisieren

Nicht alles refactoren:

* Fokus auf Stellen mit

  * häufigen Bugs
  * Performance-Problemen
  * hoher Änderungsrate
* „Low risk, high value“ zuerst

---

## 5) Abhängigkeiten entkoppeln (Strangler Pattern / Seams)

* „Seams“ schaffen: Schnittstellen, Adapter, Wrapper
* Legacy bleibt, neue Logik daneben

Beispiel (Interface einziehen):

```php
interface PaymentGatewayInterface {
    public function charge(int $amount): void;
}
```

* Dann Legacy-Implementierung dahinter verstecken

---

## 6) Refactoring-Techniken (praxisnah)

* Extrahiere Methoden/Klassen
* Entferne Duplikate
* Klarere Namen
* Reduziere Seiteneffekte
* Komplexe Bedingungen vereinfachen

> Refactoring immer mit Tests/Charakterisierungstests absichern.

---

## 7) Technische Schulden sichtbar machen

* TODOs/Tech-Debt-Tickets
* Aufwand und Risiko dokumentieren
* Definition of Done erweitern (z. B. „Tests für neue Logik“)

---

## 8) Tooling einsetzen

* Static Analysis: PHPStan / Psalm
* Code Style: PHP-CS-Fixer
* Linting: PHP_CodeSniffer
* Metrics: Cyclomatic Complexity (um Hotspots zu finden)

---

## 9) Produktionssicherheit

* Feature Flags für riskante Änderungen
* Logging/Monitoring verbessern
* Saubere Rollback-Strategie
* DB-Migrationen vorsichtig (backward compatible)

---

## 10) Kommunikation (Deutschland-Interview relevant)

* Klar sagen: „Ich optimiere nicht blind, sondern schrittweise.“
* Trade-offs erklären: Zeit vs. Risiko vs. Business Value

---

### Zusammenfassung

* Legacy-Code: erst verstehen, dann ändern
* Sicherheitsnetz: Charakterisierungstests + kleine PRs
* Fokus auf Hotspots statt Big Rewrite
* Entkoppeln via Interfaces/Adapter (Strangler/Seams)
* Refactoring inkrementell, immer abgesichert durch Tests
* Tooling + Monitoring nutzen, um Risiko zu senken

  **[⬆ Наверх](#top)**

75. ### <a name="75"></a> Wie stellst du Code-Qualität sicher?

## Wie stellst du Code-Qualität sicher?

### 1) Standards & Konsistenz

* **Coding Standards (PSR-12)** + automatisches Formatting
* Einheitliche Namensgebung, Projektstruktur, Architekturregeln

**Quelle (PSR-12):** [https://www.php-fig.org/psr/psr-12/](https://www.php-fig.org/psr/psr-12/)

---

## 2) Statische Analyse (vor dem Laufzeitfehler)

* **PHPStan oder Psalm** für:

  * Typfehler
  * Nullability
  * tote Codepfade
  * API-Misuse

Beispiel (CI):

```bash
vendor/bin/phpstan analyse
```

**Quelle:** [https://phpstan.org/](https://phpstan.org/)  (Dokumentation auf der Seite)

---

## 3) Linting & Code Style automatisieren

* **PHP-CS-Fixer** oder **PHP_CodeSniffer**
* Wird lokal (pre-commit) und in CI ausgeführt

```bash
vendor/bin/php-cs-fixer fix
```

**Quelle:** [https://cs.symfony.com/](https://cs.symfony.com/) (PHP-CS-Fixer)

---

## 4) Tests als Qualitäts-Gate

* Unit-Tests für Business-Logik
* Integration-Tests für DB/HTTP/Container
* Kritische Flows extra absichern (Auth, Payments)

```bash
vendor/bin/phpunit
```

**Quelle:** [https://phpunit.de/documentation.html](https://phpunit.de/documentation.html)

---

## 5) Code Reviews + klare Review-Regeln

* PRs klein halten
* Review-Checkliste:

  * Lesbarkeit
  * SOLID/Separation of Concerns
  * Fehlerbehandlung
  * Security (Input/Output)
  * Tests vorhanden?
  * Performance (Queries, N+1)

---

## 6) Architektur & Abhängigkeitsregeln

* Layering: Controller → Service → Repository
* Abhängigkeiten über **Interfaces** (DI)
* Keine Business-Logik im Controller
* „Boundaries“ dokumentieren (z. B. ADRs)

---

## 7) Security-by-Default

* Prepared Statements / ORM korrekt nutzen
* Output Escaping (XSS)
* CSRF bei Session-Auth
* Secrets nicht im Repo
* Regelmäßige Dependency Updates

**Quelle (OWASP Top 10):** [https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/)

---

## 8) Performance-Checks

* N+1 vermeiden (Eager Loading)
* Indizes + `EXPLAIN`
* OPcache aktiv
* Profiling (Symfony Profiler / Debugbar / Blackfire)

---

## 9) CI/CD als Qualitäts-Filter

Pipeline typischerweise:

1. Lint
2. Code Style
3. Static Analysis
4. Tests
5. Security Scan (Dependencies)

---

## 10) Dokumentation, die zählt

* README + Setup
* API Contracts (OpenAPI, falls relevant)
* „Warum“ dokumentieren (ADRs, Comments bei komplexer Logik)

---

### Zusammenfassung

* Code-Qualität = Kombination aus **Standards + Automatisierung + Tests + Reviews**
* Kern-Stack: **PSR-12**, **Static Analysis (PHPStan/Psalm)**, **PHPUnit**, **Formatter/Linter**, **CI-Pipeline**
* Ergänzend: Architekturregeln, Security-by-default, Performance-Profiling

  **[⬆ Наверх](#top)**

76. ### <a name="76"></a> Wie dokumentierst du APIs?

## Wie dokumentierst du APIs?

### 1) Standard: OpenAPI (Swagger)

Ich dokumentiere REST-APIs bevorzugt mit **OpenAPI** (maschinenlesbar + UI-generierbar).
Vorteile:

* Single Source of Truth
* Generiert Swagger UI / Redoc
* Client-SDKs und Server-Stubs möglich
* Validierung + Contract-Tests einfacher

**Minimalbeispiel (OpenAPI 3.0, YAML):**

```yaml
openapi: 3.0.3
info:
  title: Users API
  version: 1.0.0
paths:
  /users/{id}:
    get:
      summary: Get user by id
      parameters:
        - in: path
          name: id
          required: true
          schema: { type: integer }
      responses:
        "200":
          description: OK
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/User"
        "404":
          description: Not Found
components:
  schemas:
    User:
      type: object
      required: [id, email]
      properties:
        id: { type: integer }
        email: { type: string, format: email }
```

---

### 2) Was gehört in gute API-Doku (Checkliste)

* **Endpoints** + **HTTP-Methoden**
* **Auth** (z. B. Bearer Token / Cookies) + Beispiele
* **Request/Response-Schemas** (inkl. Typen, required/optional)
* **Statuscodes** + Fehlerformat (z. B. 400/401/403/404/422/500)
* **Pagination/Sorting/Filtering** (Parameter + Beispiele)
* **Versioning** (z. B. `/v1` oder Header)
* **Rate Limits** (falls vorhanden)
* **Beispiele** (curl/HTTP) für typische Calls

**Beispiel (curl):**

```bash
curl -H "Authorization: Bearer <token>" \
  https://api.example.com/users/42
```

---

### 3) Fehlerformat standardisieren

Ein konsistentes Error-Response-Format spart Zeit beim Debugging und Frontend-Integration.

**Beispiel (JSON-Error):**

```json
{
  "error": "validation_failed",
  "message": "Invalid input",
  "details": {
    "email": "Must be a valid email"
  }
}
```

---

### 4) Framework-Integration

#### Laravel

* OpenAPI per Annotations/Attributes oder separate YAML/JSON Specs
* Zusätzlich: Request-Validation als „lebende Doku“ (Rules) + API Resources für Response-Struktur

#### Symfony

* OpenAPI über Attributes/Annotations oder Spec-Datei
* DTOs + Validator Constraints helfen, Request/Response sauber zu definieren

(Je nach Projekt nutze ich Tooling, das aus Code/DTOs eine OpenAPI-Spezifikation erzeugt, oder pflege die Spec als YAML/JSON bewusst manuell.)

---

### 5) „Living Documentation“ + CI

* OpenAPI-Spec liegt im Repo
* CI prüft:

  * Spec ist valide
  * Breaking Changes (optional)
  * Beispiele/Contract-Tests (optional)
* Dokumentation wird bei Deploy automatisch veröffentlicht (Swagger UI)

---

### Zusammenfassung

* Best Practice ist **OpenAPI** als Standardformat (Spec + UI + Automatisierung).
* Gute Doku beschreibt nicht nur Endpoints, sondern auch **Auth, Fehlerformat, Statuscodes, Beispiele und Konventionen**.
* Idealer Workflow: **Spec im Repo + CI-Validation + veröffentlichte Swagger UI**.

Fürs Vertiefen:

* OpenAPI Spec: [https://spec.openapis.org/oas/latest.html](https://spec.openapis.org/oas/latest.html)
* Swagger UI: [https://swagger.io/tools/swagger-ui/](https://swagger.io/tools/swagger-ui/)

  **[⬆ Наверх](#top)**

77. ### <a name="77"></a> Wie läuft Code Review in deinem Team ab?

## Wie läuft Code Review in meinem Team ab?

### 1) Vorbereitung durch den Autor (vor dem PR)

* Branch + kleiner Scope (eine klare Änderung pro PR)
* Self-Review: Diff durchgehen, unnötige Änderungen entfernen
* Tests lokal grün, Linter/Formatter ausgeführt
* DB-Migrations/Backward-Compatibility geprüft (falls relevant)

---

### 2) Pull Request erstellen

* Klare Beschreibung: **Was**, **Warum**, **Wie testen**
* Verlinkung zu Ticket/Issue
* Screenshots/Beispiele bei UI oder API-Responses
* Checkliste im PR (Tests, Migrationen, Security, Docs)

Beispiel PR-Template (kurz):

* **Änderung:** …
* **Motivation:** …
* **Testplan:** `vendor/bin/phpunit` / API-Call / Postman Collection
* **Risiken/Rollback:** …

---

### 3) Automatische Checks (CI) als Gate

* Code Style (PSR-12), Linting
* Static Analysis (PHPStan/Psalm)
* Unit/Integration Tests
* Optional: Security/Dependency Scan, Coverage-Threshold

PR wird erst reviewt/merget, wenn CI grün ist.

---

### 4) Review durch 1–2 Reviewer

Reviewer fokussieren auf:

* **Korrektheit** (Edge Cases, Error Handling)
* **Lesbarkeit** (Naming, Struktur, kleine Funktionen)
* **Architektur** (Controller schlank, Services/Repositories sauber, DI)
* **Security** (Input Validation, SQL Injection, XSS/CSRF je nach Kontext, AuthZ)
* **Performance** (N+1, Indizes, unnötige Queries, Caching)
* **Tests** (sinnvolle Abdeckung, stabile Tests, keine unnötigen Mocks)

---

### 5) Feedback-Kultur

* Kommentare sind konkret, mit Vorschlag/Begründung
* „Must fix“ vs. „Nice to have“ wird klar markiert
* Kurzer Sync nur, wenn Kommentare missverständlich sind (nicht endlose Threads)

---

### 6) Iteration & Approval

* Autor passt an, pusht Updates
* Reviewer prüft erneut
* Nach Approval: **Squash & Merge** oder **Rebase** (je nach Team-Regel)
* Keine direkten Commits auf `main` (Merge nur via PR)

---

### 7) Nach dem Merge

* Deploy-Pipeline läuft
* Monitoring/Logs checken bei riskanten Änderungen
* Bei Bugs: schnelle Fix-PR + Postmortem/Action Items, falls nötig

---

### Zusammenfassung

* PR klein halten, Self-Review + CI zuerst
* Review prüft Korrektheit, Architektur, Security, Performance und Tests
* Klare „Must fix“-Regeln, sauberes Merge-Verfahren, keine Änderungen direkt auf `main`

  **[⬆ Наверх](#top)**

78. ### <a name="78"></a> 



  **[⬆ Наверх](#top)**

79. ### <a name="79"></a> 



  **[⬆ Наверх](#top)**

80. ### <a name="80"></a> 



  **[⬆ Наверх](#top)**  

81. ### <a name="81"></a> 



  **[⬆ Наверх](#top)**

82. ### <a name="82"></a> 



  **[⬆ Наверх](#top)**

83. ### <a name="83"></a> 



  **[⬆ Наверх](#top)**

84. ### <a name="84"></a> 



  **[⬆ Наверх](#top)**

85. ### <a name="85"></a> 



  **[⬆ Наверх](#top)**

86. ### <a name="86"></a> 



  **[⬆ Наверх](#top)**

87. ### <a name="87"></a> 



  **[⬆ Наверх](#top)**

88. ### <a name="88"></a> 



  **[⬆ Наверх](#top)**

89. ### <a name="89"></a> 



  **[⬆ Наверх](#top)**

90. ### <a name="90"></a> 



  **[⬆ Наверх](#top)**  

91. ### <a name="91"></a> 



  **[⬆ Наверх](#top)**

92. ### <a name="92"></a> 



  **[⬆ Наверх](#top)**

93. ### <a name="93"></a> 



  **[⬆ Наверх](#top)**

94. ### <a name="94"></a> 



  **[⬆ Наверх](#top)**

95. ### <a name="95"></a> 



  **[⬆ Наверх](#top)**

96. ### <a name="96"></a> 



  **[⬆ Наверх](#top)**

97. ### <a name="97"></a> 



  **[⬆ Наверх](#top)**

98. ### <a name="98"></a> 



  **[⬆ Наверх](#top)**

99. ### <a name="99"></a> 



  **[⬆ Наверх](#top)**

100. ### <a name="100"></a> 



  **[⬆ Наверх](#top)**    

101. ### <a name="101"></a> 



  **[⬆ Наверх](#top)**

102. ### <a name="102"></a> 



  **[⬆ Наверх](#top)**

103. ### <a name="103"></a> 



  **[⬆ Наверх](#top)**

104. ### <a name="104"></a> 



  **[⬆ Наверх](#top)**

105. ### <a name="105"></a> 



  **[⬆ Наверх](#top)**

106. ### <a name="106"></a> 



  **[⬆ Наверх](#top)**

107. ### <a name="107"></a> 



  **[⬆ Наверх](#top)**

108. ### <a name="108"></a> 



  **[⬆ Наверх](#top)**

109. ### <a name="109"></a> 



  **[⬆ Наверх](#top)**

110. ### <a name="110"></a> 



  **[⬆ Наверх](#top)**

111. ### <a name="111"></a> 



  **[⬆ Наверх](#top)**

112. ### <a name="112"></a> 



  **[⬆ Наверх](#top)**

113. ### <a name="113"></a> 



  **[⬆ Наверх](#top)**

114. ### <a name="114"></a> 



  **[⬆ Наверх](#top)**

115. ### <a name="115"></a> 



  **[⬆ Наверх](#top)**

116. ### <a name="116"></a> 



  **[⬆ Наверх](#top)**

117. ### <a name="117"></a> 



  **[⬆ Наверх](#top)**

118. ### <a name="118"></a> 



  **[⬆ Наверх](#top)**

119. ### <a name="119"></a> 



  **[⬆ Наверх](#top)**

120. ### <a name="120"></a> 



  **[⬆ Наверх](#top)**

121. ### <a name="121"></a> 



  **[⬆ Наверх](#top)**

122. ### <a name="122"></a> 



  **[⬆ Наверх](#top)**

123. ### <a name="123"></a> 



  **[⬆ Наверх](#top)**

124. ### <a name="124"></a> 



  **[⬆ Наверх](#top)**

125. ### <a name="125"></a> 



  **[⬆ Наверх](#top)**

126. ### <a name="126"></a> 



  **[⬆ Наверх](#top)**

127. ### <a name="127"></a> 



  **[⬆ Наверх](#top)**

128. ### <a name="128"></a> 



  **[⬆ Наверх](#top)**

129. ### <a name="129"></a> 



  **[⬆ Наверх](#top)**

130. ### <a name="130"></a> 



  **[⬆ Наверх](#top)**  

131. ### <a name="131"></a> 



  **[⬆ Наверх](#top)**

132. ### <a name="132"></a> 



  **[⬆ Наверх](#top)**

133. ### <a name="133"></a> 



  **[⬆ Наверх](#top)**

134. ### <a name="134"></a> 



  **[⬆ Наверх](#top)**

135. ### <a name="135"></a> 



  **[⬆ Наверх](#top)**

136. ### <a name="136"></a> 



  **[⬆ Наверх](#top)**

137. ### <a name="137"></a> 



  **[⬆ Наверх](#top)**

138. ### <a name="138"></a> 



  **[⬆ Наверх](#top)**

139. ### <a name="139"></a> 



  **[⬆ Наверх](#top)**

140. ### <a name="140"></a> 



  **[⬆ Наверх](#top)**  

141. ### <a name="141"></a> 



  **[⬆ Наверх](#top)**

142. ### <a name="142"></a> 



  **[⬆ Наверх](#top)**

143. ### <a name="143"></a> 



  **[⬆ Наверх](#top)**

144. ### <a name="144"></a> 



  **[⬆ Наверх](#top)**

145. ### <a name="145"></a> 



  **[⬆ Наверх](#top)**

146. ### <a name="146"></a> 



  **[⬆ Наверх](#top)**

147. ### <a name="147"></a> 



  **[⬆ Наверх](#top)**

148. ### <a name="148"></a> 



  **[⬆ Наверх](#top)**

149. ### <a name="149"></a> 



  **[⬆ Наверх](#top)**

150. ### <a name="150"></a> 



  **[⬆ Наверх](#top)**  

151. ### <a name="151"></a> 



  **[⬆ Наверх](#top)**

152. ### <a name="152"></a> 



  **[⬆ Наверх](#top)**

153. ### <a name="153"></a> 



  **[⬆ Наверх](#top)**

154. ### <a name="154"></a> 



  **[⬆ Наверх](#top)**

155. ### <a name="155"></a> 



  **[⬆ Наверх](#top)**

156. ### <a name="156"></a> 



  **[⬆ Наверх](#top)**

157. ### <a name="157"></a> 



  **[⬆ Наверх](#top)**

158. ### <a name="158"></a> 



  **[⬆ Наверх](#top)**

159. ### <a name="159"></a> 



  **[⬆ Наверх](#top)**

160. ### <a name="160"></a> 



  **[⬆ Наверх](#top)**

161. ### <a name="161"></a> 



  **[⬆ Наверх](#top)**

162. ### <a name="162"></a> 



  **[⬆ Наверх](#top)**

163. ### <a name="163"></a> 



  **[⬆ Наверх](#top)**

164. ### <a name="164"></a> 



  **[⬆ Наверх](#top)**

165. ### <a name="165"></a> 



  **[⬆ Наверх](#top)**

166. ### <a name="166"></a> 



  **[⬆ Наверх](#top)**

167. ### <a name="167"></a> 



  **[⬆ Наверх](#top)**

168. ### <a name="168"></a> 



  **[⬆ Наверх](#top)**

169. ### <a name="169"></a> 



  **[⬆ Наверх](#top)**

170. ### <a name="170"></a> 



  **[⬆ Наверх](#top)**

171. ### <a name="171"></a> 



  **[⬆ Наверх](#top)**

172. ### <a name="172"></a> 



  **[⬆ Наверх](#top)**

173. ### <a name="173"></a> 



  **[⬆ Наверх](#top)**

174. ### <a name="174"></a> 



  **[⬆ Наверх](#top)**

175. ### <a name="175"></a> 



  **[⬆ Наверх](#top)**

176. ### <a name="176"></a> 



  **[⬆ Наверх](#top)**

177. ### <a name="177"></a> 



  **[⬆ Наверх](#top)**

178. ### <a name="178"></a> 



  **[⬆ Наверх](#top)**

179. ### <a name="179"></a> 



  **[⬆ Наверх](#top)**

180. ### <a name="180"></a> 



  **[⬆ Наверх](#top)**  

181. ### <a name="181"></a> 



  **[⬆ Наверх](#top)**

182. ### <a name="182"></a> 



  **[⬆ Наверх](#top)**

183. ### <a name="183"></a> 



  **[⬆ Наверх](#top)**

184. ### <a name="184"></a> 



  **[⬆ Наверх](#top)**

185. ### <a name="185"></a> 



  **[⬆ Наверх](#top)**

186. ### <a name="186"></a> 



  **[⬆ Наверх](#top)**

187. ### <a name="187"></a> 



  **[⬆ Наверх](#top)**

188. ### <a name="188"></a> 



  **[⬆ Наверх](#top)**

189. ### <a name="189"></a> 



  **[⬆ Наверх](#top)**

190. ### <a name="190"></a> 



  **[⬆ Наверх](#top)**  

191. ### <a name="191"></a> 



  **[⬆ Наверх](#top)**

192. ### <a name="192"></a> 



  **[⬆ Наверх](#top)**

193. ### <a name="193"></a> 



  **[⬆ Наверх](#top)**

194. ### <a name="194"></a> 



  **[⬆ Наверх](#top)**

195. ### <a name="195"></a> 



  **[⬆ Наверх](#top)**

196. ### <a name="196"></a> 



  **[⬆ Наверх](#top)**

197. ### <a name="197"></a> 



  **[⬆ Наверх](#top)**

198. ### <a name="198"></a> 



  **[⬆ Наверх](#top)**

199. ### <a name="199"></a> 



  **[⬆ Наверх](#top)**

200. ### <a name="200"></a> 



  **[⬆ Наверх](#top)**      
