<a name="top"></a>

[–ù–∞ –≥–ª–∞–≤–Ω—É—é](../README.md)

[–ü–µ—Ä–µ–π—Ç–∏ –∫ –≤–æ–ø—Ä–æ—Å–∞–º](#questions)

| ‚Ññ. | –í–æ–ø—Ä–æ—Å |
| --- | --------- |
|   | TypeScript ‚Äî Grundlagen |
|1 | [Was ist TypeScript und wie unterscheidet es sich von JavaScript?](#1) |
|2 | [Welche Vorteile bietet die Verwendung von TypeScript?](#2) |
|3 | [Was ist Typisierung (static typing)?](#3) |
|4 | [Welche grundlegenden Typen gibt es in TypeScript?](#4) |
|5 | [Worin besteht der Unterschied zwischen any und unknown?](#5) |
|6 | [Was ist never und wann wird es verwendet?](#6) |
|7 | [Was ist der Unterschied zwischen null und undefined?](#7) |
|8 | [Was ist void?](#8) |
|9 | [Was sind Union Types? Gib ein Beispiel.](#9) |
|10 | [Was sind Intersection Types? Gib ein Beispiel.](#10) |
|11 | [Was sind Literal Types?](#11) |
|12 | [Wie funktioniert type inference in TypeScript?](#12) |
|13 | [Was ist ein Type Alias (type) und wie unterscheidet er sich von interface?](#13) |
|14 | [Was ist der Unterschied zwischen interface und type?](#14) |
|15 | [Kann man Interfaces zusammenf√ºhren (extend)?](#15) |
|16 | [Was sind optionale Eigenschaften in Interfaces?](#16) |
|17 | [Wie deklariert man readonly-Eigenschaften?](#17) |
|18 | [Was sind Tupel (tuples) in TypeScript?](#18) |
|19 | [Was ist ein Enum und wann sollte man es verwenden?](#19) |
|20 | [Was ist der Unterschied zwischen const enum und einem normalen enum?](#20) |
|21 | [Was ist Type Narrowing (Typschr√§nkung)?](#21) |
|22 | [Was sind Type Guards? Gib ein Beispiel.](#22) |
|23 | [Wie funktioniert der Operator in bei der Typpr√ºfung?](#23) |
|24 | [Wie funktioniert typeof in TypeScript?](#24) |
|25 | [Wie funktioniert instanceof?](#25) |
|26 | [Was sind Discriminated Unions (diskriminierte Typen)?](#26) |
|27 | [Was ist der Unterschied zwischen interface und abstract class?](#27) |
|28 | [Wie implementiert man Funktions√ºberladungen (function overloads) in TypeScript?](#28) |
|29 | [Was sind Index Signatures?](#29) |
|30 | [Was ist keyof und wof√ºr wird es verwendet?](#30) |
|31 | [Wie funktioniert der Operator as?](#31) |
|32 | [Was ist der Unterschied zwischen as const und einem normalen const?](#32) |
|33 | [Was macht der Operator satisfies (TS 4.9+)?](#33) |
|34 | [Was sind Assertion Functions?](#34) |
|35 | [Was ist der Unterschied zwischen struktureller Typisierung (structural typing) und nominaler Typisierung (nominal typing)?](#35) |
|36 | [Was sind Deklarationsdateien (.d.ts)?](#36) |
|37 | [Wie bindet man eine externe JS-Bibliothek ohne Typen ein?](#37) |
|38 | [Was sind Ambient Declarations (declare)?](#38) |
|39 | [Was ist strict mode in TypeScript?](#39) |
|40 | [Wozu dient strictNullChecks?](#40) |
|   | TypeScript ‚Äî Funktionen und Generics |
|41 | [Wie typisiert man Parameter und R√ºckgabewerte von Funktionen?](#41) |
|42 | [Was sind optionale Parameter in Funktionen?](#42) |
|43 | [Wie deklariert man Standardwerte f√ºr Parameter mit Typisierung?](#43) |
|44 | [Was sind Rest-Parameter und wie typisiert man sie?](#44) |
|45 | [Wie typisiert man Arrow Functions?](#45) |
|46 | [Was sind Funktions√ºberladungen?](#46) |
|47 | [Was sind Generics?](#47) |
|48 | [Wie erstellt man eine generische Funktion?](#48) |
|49 | [Was sind Generic Constraints (extends)?](#49) |
|50 | [Wie funktioniert T extends keyof U?](#50) |
|51 | [Was sind Utility Types (Partial, Pick, Omit, Record usw.)?](#51) |
|52 | [Was ist der Unterschied zwischen Partial<T> und Required<T>?](#52) |
|53 | [Wie funktioniert Readonly<T>?](#53) |
|54 | [Wie funktionieren Pick<T, K> und Omit<T, K>?](#54) |
|55 | [Was macht Record<K, T>?](#55) |
|56 | [Was macht ReturnType<T>?](#56) |
|57 | [Was macht Parameters<T>?](#57) |
|58 | [Was macht ConstructorParameters<T>?](#58) |
|59 | [Wie funktionieren Extract und Exclude?](#59) |
|60 | [Was macht NonNullable<T>?](#60) |
|   | TypeScript ‚Äî Klassen und OOP |
|61 | [Wie deklariert man eine Klasse in TypeScript?](#61) |
|62 | [Was sind Zugriffsmodifikatoren (public, private, protected)?](#62) |
|63 | [Was sind readonly-Eigenschaften in Klassen?](#63) |
|64 | [Wie deklariert man statische Eigenschaften und Methoden?](#64) |
|65 | [Was ist der Unterschied zwischen einer abstrakten und einer normalen Klasse?](#65) |
|66 | [Kann man Interfaces mit Klassen implementieren?](#66) |
|67 | [Was ist der Unterschied zwischen implements und extends?](#67) |
|68 | [Was ist this und wie typisiert man es?](#68) |
|69 | [Kann man generische Klassen erstellen?](#69) |
|   | React + TypeScript ‚Äî Grundlagen |
|70 | [Wie erstellt man ein React-Projekt mit TypeScript?](#70) |
|71 | [Wie typisiert man eine React-Komponente (FC)?](#71) |
|72 | [Was ist React.FC und wann sollte man es vermeiden?](#72) |
|73 | [Wie typisiert man Props in einer React-Komponente?](#73) |
|74 | [Wie typisiert man optionale Props?](#74) |
|75 | [Wie deklariert man Default Props in TypeScript?](#75) |
|76 | [Wie typisiert man children in React-Komponenten?](#76) |
|77 | [Was ist der Unterschied zwischen ReactNode, JSX.Element und ReactElement?](#77) |
|78 | [Wie typisiert man Events (z. B. onClick, onChange)?](#78) |
|79 | [Wie typisiert man Refs in React?](#79) |
|80 | [Wie typisiert man State mit useState?](#80) |
|81 | [Wie typisiert man useReducer?](#81) |
|82 | [Wie typisiert man useRef mit initial null?](#82) |
|83 | [Wie typisiert man einen Custom Hook?](#83) |
|84 | [Wie typisiert man Komponenten mit forwardRef?](#84) |
|85 | [Wie typisiert man Context (React Context API)?](#85) |
|86 | [Wie typisiert man HOCs (Higher-Order Components)?](#86) |
|87 | [Wie typisiert man asynchrone Funktionen in React-Komponenten?](#87) |
|88 | [Wie typisiert man Event-Handler in Formularen?](#88) |
|89 | [Wie typisiert man API-Requests und Responses?](#89) |
|90 | [Wie typisiert man React-Router-Komponenten?](#90) |
|   | React + TypeScript ‚Äî Praxis und Architektur |
|91 | [Wie organisiert man Typen f√ºr ein gesamtes Projekt?](#91) |
|92 | [Wo speichert man gemeinsame Typen (z. B. User, Product)?](#92) |
|93 | [Wie typisiert man den globalen Store (Redux/RTK)?](#93) |
|94 | [Wie typisiert man Actions und Reducer im Redux Toolkit?](#94) |
|95 | [Wie typisiert man useSelector und useDispatch?](#95) |
|96 | [Wie typisiert man einen Zustand-Store (Zustand)?](#96) |
|97 | [Wie typisiert man Async Thunks?](#97) |
|98 | [Wie typisiert man Query Hooks in RTK Query?](#98) |
|99 | [Wie verwendet man Enums f√ºr Redux-Actions?](#99) |
|100 | [Wie typisiert man Formulare mit React Hook Form?](#100) |
|101 | [Wie typisiert man axios-Requests?](#101) |
|102 | [Wie typisiert man fetch-Requests mit Generics?](#102) |
|103 | [Wie geht man mit Typen bei API-Fehlern um?](#103) |
|104 | [Wie verwendet man Utility Types f√ºr API-Modelle?](#104) |
|105 | [Wie typisiert man Dynamic Imports in React?](#105) |
|106 | [Wie verwendet man keyof f√ºr dynamische Eigenschaften in Komponenten?](#106) |
|107 | [Wie erstellt man typsichere Styles (z. B. mit styled-components)?](#107) |
|108 | [Wie typisiert man Props f√ºr Bibliothekskomponenten (z. B. Material UI)?](#108) |
|109 | [Wie typisiert man React.memo?](#109) |
|110 | [Wie typisiert man React.lazy und Suspense?](#110) |
|   | Fragen auf Middle-Level |
|111 | [Wie verwendet man Conditional Types (T extends U ? X : Y)?](#111) |
|112 | [Was sind Mapped Types?](#112) |
|113 | [Wie funktionieren Template Literal Types?](#113) |
|114 | [Was ist infer?](#114) |
|115 | [Wie schreibt man eigene Utility Types?](#115) |
|116 | [Wie kombiniert man mehrere Generics?](#116) |
|117 | [Was sind polymorphe Komponenten in React?](#117) |
|118 | [Wie erstellt man eine generische React-Komponente?](#118) |
|119 | [Wie verbindet man Generics in Props und State?](#119) |
|120 | [Wie stellt man vollst√§ndige Typsicherheit bei der Arbeit mit APIs sicher?](#120) |
|121 | [](#121) |
|122 | [](#122) |
|123 | [](#123) |
|124 | [](#124) |
|125 | [](#125) |
|126 | [](#126) |
|127 | [](#127) |
|128 | [](#128) |
|129 | [](#129) |
|130 | [](#130) |
|131 | [](#131) |
|132 | [](#132) |
|133 | [](#133) |
|134 | [](#134) |
|135 | [](#135) |
|136 | [](#136) |
|137 | [](#137) |
|138 | [](#138) |
|139 | [](#139) |
|140 | [](#140) |
|141 | [](#141) |
|142 | [](#142) |
|143 | [](#143) |
|144 | [](#144) |
|145 | [](#145) |
|146 | [](#146) |
|147 | [](#147) |
|148 | [](#148) |
|149 | [](#149) |
|150 | [](#150) |
|151 | [](#151) |
|152 | [](#152) |
|153 | [](#153) |
|154 | [](#154) |
|155 | [](#155) |
|156 | [](#156) |
|157 | [](#157) |
|158 | [](#158) |
|159 | [](#159) |
|160 | [](#160) |
|161 | [](#161) |
|162 | [](#162) |
|163 | [](#163) |
|164 | [](#164) |
|165 | [](#165) |
|166 | [](#166) |
|167 | [](#167) |
|168 | [](#168) |
|169 | [](#169) |
|170 | [](#170) |
|171 | [](#171) |
|172 | [](#172) |
|173 | [](#173) |
|174 | [](#174) |
|175 | [](#175) |
|176 | [](#176) |
|177 | [](#177) |
|178 | [](#178) |
|179 | [](#179) |
|180 | [](#180) |
|181 | [](#181) |
|182 | [](#182) |
|183 | [](#183) |
|184 | [](#184) |
|185 | [](#185) |
|186 | [](#186) |
|187 | [](#187) |
|188 | [](#188) |
|189 | [](#189) |
|190 | [](#190) |
|191 | [](#191) |
|192 | [](#192) |
|193 | [](#193) |
|194 | [](#194) |
|195 | [](#195) |
|196 | [](#196) |
|197 | [](#197) |
|198 | [](#198) |
|199 | [](#199) |
|200 | [](#200) |



<a name="questions"></a>

## ReactJS 

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**
  
1. ### <a name="1"></a> Was ist TypeScript und wie unterscheidet es sich von JavaScript?

**TypeScript** ist eine von Microsoft entwickelte Programmiersprache, die auf **JavaScript** basiert und dieses um **statische Typisierung** erweitert. Jeder g√ºltige JavaScript-Code ist auch g√ºltiger TypeScript-Code.

### Hauptunterschiede zu JavaScript

1. **Statische Typisierung**

   * In JavaScript sind Variablen dynamisch typisiert.
   * In TypeScript kann man Typen explizit angeben, was Fehler schon w√§hrend der Entwicklung verhindert.

   ```js
   // JavaScript (dynamisch, Fehler erst zur Laufzeit m√∂glich)
   let name = "Sergii"
   name = 42 // kein Fehler beim Schreiben, nur Laufzeitproblem

   // TypeScript (statisch, Fehler beim Kompilieren)
   let name: string = "Sergii"
   name = 42 // ‚ùå Fehler: Type 'number' is not assignable to type 'string'
   ```

2. **Typinferenz**

   * TypeScript erkennt oft automatisch den Typ einer Variable.

   ```js
   let age = 33 // Typ: number (automatisch erkannt)
   ```

3. **Erweiterte Features**

   * Interfaces, Enums, Generics, Union- und Intersection-Types, Utility-Types.

   ```js
   interface User {
     id: number
     name: string
   }

   const user: User = { id: 1, name: "Sergii" }
   ```

4. **Kompilierung**

   * TypeScript wird in **JavaScript** transpiliert (mittels `tsc` oder Bundler wie Vite/Webpack).
   * L√§uft nicht direkt im Browser, sondern wird vorher in JavaScript konvertiert.

5. **Entwicklerfreundlichkeit**

   * Bessere **IntelliSense**, Autovervollst√§ndigung und Fehlererkennung in IDEs.

---

### Zusammenfassung

* **JavaScript**: dynamisch typisiert, direkt im Browser lauff√§hig.
* **TypeScript**: superset von JavaScript mit **statischer Typisierung** und zus√§tzlichen Features; erfordert Transpilation.
* Vorteil: Weniger Laufzeitfehler, besserer Code-Support.

üîó Quellen:

* [TypeScript: What is TypeScript?](https://www.typescriptlang.org/docs/handbook/intro.html)
* [React TypeScript Cheatsheet: Setup](https://react-typescript-cheatsheet.netlify.app/docs/basic/setup)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

2. ### <a name="2"></a> Welche Vorteile bietet die Verwendung von TypeScript?

### Vorteile von TypeScript

1. **Fr√ºhe Fehlererkennung**

   * Typfehler werden bereits beim Kompilieren gefunden, bevor der Code ausgef√ºhrt wird.

   ```js
   let price: number = 50
   price = "f√ºnfzig" // ‚ùå Fehler beim Kompilieren
   ```

2. **Bessere Entwicklererfahrung (DX)**

   * IntelliSense, Autovervollst√§ndigung, Hover-Infos und Refactoring sind pr√§ziser.

3. **Klarheit und Wartbarkeit**

   * Durch Typannotationen und Interfaces ist der Code selbstdokumentierend.

   ```js
   interface Product {
     id: number
     name: string
     price: number
   }
   ```

4. **Skalierbarkeit**

   * Besonders n√ºtzlich in gro√üen Projekten mit vielen Entwicklern.
   * √Ñnderungen sind sicherer, da Typen sofort Konflikte zeigen.

5. **Moderne Features**

   * Unterst√ºtzung von Generics, Union/Intersection Types, Enums, Utility-Types.

   ```js
   function wrapValue<T>(value: T): T[] {
     return [value]
   }
   const result = wrapValue<string>("Hallo") // result: string[]
   ```

6. **Kompatibilit√§t mit JavaScript**

   * Jeder JS-Code l√§uft auch in TS.
   * Migration von bestehenden Projekten m√∂glich (schrittweise Einf√ºhrung).

---

### Zusammenfassung

* **TypeScript** bringt Typensicherheit, bessere Entwickler-Tools, klareren und wartbareren Code, Skalierbarkeit in gro√üen Projekten und moderne Sprachfeatures.
* Besonders vorteilhaft bei **langfristigen, komplexen Projekten** mit mehreren Teammitgliedern.

üîó Quellen:

* [TypeScript Handbook ‚Äì Why TypeScript](https://www.typescriptlang.org/docs/handbook/2/basic-types.html)
* [React TypeScript Cheatsheet ‚Äì Vorteile](https://react-typescript-cheatsheet.netlify.app/docs/basic/setup)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

3. ### <a name="3"></a> Was ist Typisierung (static typing)?

### Typisierung (Static Typing)

**Definition:**
Statische Typisierung bedeutet, dass der Datentyp einer Variable oder Funktion **zur Compile-Zeit** festgelegt wird und nicht erst zur Laufzeit.

### Merkmale

1. **Fester Typ w√§hrend der gesamten Lebenszeit**

   * Eine Variable beh√§lt den einmal festgelegten Typ.
   * Zuweisungen anderer Typen f√ºhren zu einem Kompilierungsfehler.

   ```js
   let username: string = "Sergii"
   username = 42 // ‚ùå Fehler: number ist nicht string
   ```

2. **Fr√ºhe Fehlererkennung**

   * Tippfehler oder falsche Funktionsaufrufe werden direkt angezeigt.

   ```js
   function add(a: number, b: number): number {
     return a + b
   }

   add(5, "10") // ‚ùå Fehler: Argument vom Typ 'string' ist nicht zuweisbar
   ```

3. **Verbesserte Autovervollst√§ndigung und Dokumentation**

   * IDEs k√∂nnen anhand der Typen Vorschl√§ge und Hilfen anzeigen.

4. **Generics und komplexe Typen**

   * Flexible, aber dennoch sichere Strukturen m√∂glich.

   ```js
   function identity<T>(value: T): T {
     return value
   }
   const result = identity<number>(10) // Typ: number
   ```

---

### Unterschied zu dynamischer Typisierung (JavaScript)

* **Dynamisch:** Typen werden erst zur Laufzeit gepr√ºft.
* **Statisch:** Typen werden bereits vor der Ausf√ºhrung gepr√ºft.

---

### Zusammenfassung

* **Static Typing** = feste Typpr√ºfung w√§hrend der Kompilierung.
* Vorteile: weniger Laufzeitfehler, klarer Code, bessere Tool-Unterst√ºtzung.
* In TypeScript zwingend (mit Ausnahmen wie `any`), in JavaScript nicht vorhanden.

üîó Quellen:

* [TypeScript Handbook ‚Äì Basic Types](https://www.typescriptlang.org/docs/handbook/2/basic-types.html)
* [MDN ‚Äì JavaScript Datentypen](https://developer.mozilla.org/ru/docs/Web/JavaScript/Data_structures)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

4. ### <a name="4"></a> Welche grundlegenden Typen gibt es in TypeScript?

### Grundlegende Typen in TypeScript

TypeScript erweitert JavaScript um **statische Typisierung**. Die wichtigsten **Basis-Typen** sind:

---

#### 1. **Primitives**

* **string**

  ```js
  let username: string = "Sergii"
  ```
* **number** (Ganzzahlen & Flie√ükommazahlen)

  ```js
  let age: number = 34
  ```
* **boolean**

  ```js
  let isOnline: boolean = true
  ```
* **null** und **undefined**

  ```js
  let value: null = null
  let notAssigned: undefined = undefined
  ```
* **bigint** (f√ºr sehr gro√üe Zahlen)

  ```js
  let big: bigint = 9007199254740991n
  ```
* **symbol** (einzigartige Werte)

  ```js
  let uniqueId: symbol = Symbol("id")
  ```

---

#### 2. **Arrays**

```js
let numbers: number[] = [1, 2, 3]
let names: Array<string> = ["Anna", "Tom"] // Generics-Schreibweise
```

---

#### 3. **Tuples**

* Feste Anzahl von Elementen mit festen Typen.

```js
let person: [string, number] = ["Sergii", 34]
```

---

#### 4. **Enums**

* Sammlung von benannten Konstanten.

```js
enum Role {
  Admin,
  User,
  Guest
}

let currentRole: Role = Role.Admin
```

---

#### 5. **Any**

* Deaktiviert Typpr√ºfung (sollte vermieden werden).

```js
let data: any = 5
data = "Text"
```

---

#### 6. **Unknown**

* Sicherere Alternative zu `any`, erfordert Typpr√ºfung vor Verwendung.

```js
let value: unknown = "Hallo"

if (typeof value === "string") {
  console.log(value.toUpperCase())
}
```

---

#### 7. **Void**

* Wird f√ºr Funktionen verwendet, die nichts zur√ºckgeben.

```js
function logMessage(message: string): void {
  console.log(message)
}
```

---

#### 8. **Never**

* F√ºr Funktionen, die niemals einen Wert zur√ºckgeben (z. B. Fehler werfen).

```js
function throwError(msg: string): never {
  throw new Error(msg)
}
```

---

### Zusammenfassung

* **Primitive Typen**: string, number, boolean, null, undefined, bigint, symbol
* **Spezielle Typen**: any, unknown, void, never
* **Strukturierte Typen**: arrays, tuples, enums

üîó Quellen:

* [TypeScript Handbook ‚Äì Basic Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html)
* [React TypeScript Cheatsheet ‚Äì Basic Setup](https://react-typescript-cheatsheet.netlify.app/docs/basic/setup)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

5. ### <a name="5"></a> Worin besteht der Unterschied zwischen any und unknown?

### Unterschied zwischen `any` und `unknown`

#### **1. `any`**

* Deaktiviert **jegliche Typpr√ºfung**.
* Man kann jede Operation auf `any` ausf√ºhren, ohne Fehler beim Kompilieren.
* Gefahr: Laufzeitfehler, da TypeScript keine Sicherheit bietet.

```js
let value: any = "Hallo"
value = 123
value.toUpperCase() // ‚úÖ Kein Fehler beim Kompilieren, aber Laufzeitfehler m√∂glich
```

---

#### **2. `unknown`**

* Ist ein **sicherer Gegenspieler zu `any`**.
* Man kann einen Wert vom Typ `unknown` nicht direkt verwenden, ohne ihn vorher zu pr√ºfen oder zu casten.
* Erzwingt **Type-Safety** durch Typabfragen.

```js
let input: unknown = "Hallo"

// ‚ùå Direkt nicht erlaubt
// input.toUpperCase()

// ‚úÖ Mit Typpr√ºfung
if (typeof input === "string") {
  console.log(input.toUpperCase())
}
```

---

#### **Vergleich**

| Merkmal            | `any`                 | `unknown`                            |
| ------------------ | --------------------- | ------------------------------------ |
| Typpr√ºfung         | Keine                 | Erforderlich                         |
| Sicherheit         | Niedrig               | Hoch                                 |
| Nutzungsempfehlung | Nur in Ausnahmef√§llen | Besser als `any` f√ºr unsichere Werte |

---

### Zusammenfassung

* **`any`**: erlaubt alles, keine Typpr√ºfung ‚Üí unsicher.
* **`unknown`**: erfordert Typpr√ºfung oder Casting ‚Üí sicherer, bevorzugt f√ºr unbekannte Werte (z. B. API-Response).

üîó Quellen:

* [TypeScript Handbook ‚Äì unknown](https://www.typescriptlang.org/docs/handbook/2/functions.html#unknown)
* [React TypeScript Cheatsheet ‚Äì any vs. unknown](https://react-typescript-cheatsheet.netlify.app/docs/basic/troubleshooting/types)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

6. ### <a name="6"></a> Was ist never und wann wird es verwendet?

### `never` in TypeScript

**Definition:**
`never` ist ein spezieller Typ f√ºr Werte, die **niemals existieren k√∂nnen**.
Eine Funktion oder ein Ausdruck vom Typ `never` beendet entweder den Programmfluss (z. B. durch einen Fehler) oder l√§uft unendlich weiter.

---

### Anwendungsf√§lle

#### 1. **Funktionen, die immer Fehler werfen**

```js
function throwError(message: string): never {
  throw new Error(message)
}
```

* R√ºckgabewert: niemals erreichbar, da die Funktion das Programm mit einem Fehler abbricht.

---

#### 2. **Endlose Schleifen**

```js
function infiniteLoop(): never {
  while (true) {
    console.log("l√§uft ewig...")
  }
}
```

* Die Funktion verl√§sst nie die Schleife ‚Üí daher `never`.

---

#### 3. **Exhaustiveness Checking** (Typpr√ºfung bei `switch` / `if-else`)

* `never` wird verwendet, um sicherzustellen, dass alle m√∂glichen F√§lle abgedeckt sind.

```js
type Shape = "circle" | "square"

function getArea(shape: Shape): number {
  switch (shape) {
    case "circle":
      return Math.PI * 10 ** 2
    case "square":
      return 10 * 10
    default:
      const exhaustiveCheck: never = shape
      return exhaustiveCheck
  }
}
```

* Vorteil: Falls sp√§ter ein neuer Typ (`"triangle"`) hinzugef√ºgt wird, zeigt TypeScript einen Fehler an, solange er nicht im `switch` behandelt wird.

---

### Unterschied zu `void`

* **`void`**: Funktion gibt keinen **Wert** zur√ºck.
* **`never`**: Funktion gibt **nie** etwas zur√ºck (nicht mal `undefined`).

---

### Zusammenfassung

* **`never`** = Typ f√ºr Werte, die nie vorkommen k√∂nnen.
* Typische Nutzung: Funktionen, die Fehler werfen, unendliche Schleifen oder Exhaustiveness Checking.
* Unterschied zu `void`: `void` = kein R√ºckgabewert, `never` = niemals R√ºckgabe.

üîó Quellen:

* [TypeScript Handbook ‚Äì never](https://www.typescriptlang.org/docs/handbook/2/functions.html#never)
* [MDN ‚Äì JavaScript Error](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Error)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

7. ### <a name="7"></a> Was ist der Unterschied zwischen null und undefined?

### Unterschied zwischen `null` und `undefined` in TypeScript / JavaScript

#### **1. `undefined`**

* Automatischer Standardwert f√ºr nicht initialisierte Variablen oder fehlende Eigenschaften.
* Bedeutet: *"nicht zugewiesen"*.

```js
let a
console.log(a) // undefined

const obj = {}
console.log(obj.prop) // undefined
```

---

#### **2. `null`**

* Wird explizit vom Entwickler gesetzt.
* Bedeutet: *"absichtlich leer / kein Wert"*.

```js
let b: string | null = null
console.log(b) // null
```

---

#### **3. Vergleich**

```js
console.log(null == undefined)  // true  (lockerer Vergleich)
console.log(null === undefined) // false (strenger Vergleich)
```

---

#### **4. In TypeScript**

* `undefined` und `null` sind eigene Typen.
* Standardm√§√üig sind sie **Zuweisungen an andere Typen erlaubt** (abh√§ngig von `--strictNullChecks`).

```js
let x: string | null = null   // erlaubt
let y: string | undefined     // muss initialisiert oder gepr√ºft werden
```

---

#### **5. Typische Verwendung**

* **`undefined`**: vom System vergeben, wenn nichts zugewiesen wurde.
* **`null`**: vom Entwickler gesetzt, um ‚Äûkeinen Wert‚Äú darzustellen.

---

### Zusammenfassung

* **`undefined`** = Wert fehlt automatisch (nicht initialisiert, nicht vorhanden).
* **`null`** = Wert wurde absichtlich auf ‚Äûkein Wert‚Äú gesetzt.
* Unterschied deutlich machen mit `===`: `null !== undefined`.

üîó Quellen:

* [TypeScript Handbook ‚Äì Everyday Types: null & undefined](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#null-and-undefined)
* [MDN ‚Äì null](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/null)
* [MDN ‚Äì undefined](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/undefined)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

8. ### <a name="8"></a> Was ist void?

### `void` in TypeScript

**Definition:**
`void` ist ein spezieller Typ in TypeScript, der bedeutet, dass eine Funktion **keinen R√ºckgabewert** hat.

---

### Anwendungsf√§lle

#### 1. **Funktion ohne R√ºckgabewert**

```js
function logMessage(message: string): void {
  console.log(message)
}

const result = logMessage("Hallo")
// result hat den Typ void ‚Üí es wird nichts zur√ºckgegeben
```

---

#### 2. **Callbacks, die nichts zur√ºckgeben**

```js
function forEachItem(items: string[], callback: (item: string) => void) {
  for (const item of items) {
    callback(item)
  }
}

forEachItem(["A", "B"], (el) => console.log(el))
```

---

#### 3. **Unterschied zu `undefined`**

* `void` ‚â† `undefined`, auch wenn Funktionen implizit `undefined` zur√ºckgeben.
* Mit `void` sagt man ausdr√ºcklich: *‚ÄûKein R√ºckgabewert ist relevant‚Äú*.

```js
function test(): void {
  return // erlaubt, implizit undefined
}

function test2(): undefined {
  return undefined // nur explizit erlaubt
}
```

---

#### 4. **Besonderheit bei Promises**

* `Promise<void>` ‚Üí Funktion gibt ein Promise zur√ºck, dessen Wert nicht benutzt werden soll.

```js
async function saveData(): Promise<void> {
  await fetch("/api/save")
}
```

---

### Zusammenfassung

* **`void`** kennzeichnet Funktionen ohne R√ºckgabewert.
* Typischer Einsatz: `console.log`, Event-Handler, Callbacks.
* Unterschied zu `undefined`: `void` betont die Abwesenheit eines R√ºckgabewerts, `undefined` ist ein Wert selbst.

üîó Quellen:

* [TypeScript Handbook ‚Äì void](https://www.typescriptlang.org/docs/handbook/2/functions.html#void)
* [React TS Cheatsheet ‚Äì void in Callbacks](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/event-handling/)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

9. ### <a name="9"></a> Was sind Union Types? Gib ein Beispiel.

### Union Types in TypeScript

**Definition:**
Ein **Union Type** erlaubt es, dass eine Variable oder ein Parameter **mehrere m√∂gliche Typen** haben kann. Er wird mit dem **`|`-Operator** geschrieben.

---

### Beispiel 1 ‚Äì Variable mit mehreren Typen

```js
let id: string | number

id = 42      // ‚úÖ erlaubt
id = "abc"   // ‚úÖ erlaubt
id = true    // ‚ùå Fehler: boolean nicht erlaubt
```

---

### Beispiel 2 ‚Äì Funktion mit Union Types

```js
function printId(id: string | number): void {
  if (typeof id === "string") {
    console.log("ID als Text:", id.toUpperCase())
  } else {
    console.log("ID als Zahl:", id.toFixed(2))
  }
}

printId("abc") // ID als Text: ABC
printId(123.456) // ID als Zahl: 123.46
```

---

### Beispiel 3 ‚Äì Union in Arrays

```js
let values: (string | number)[] = [1, "zwei", 3, "vier"]
```

---

### Zusammenfassung

* **Union Types** = Typen, die **mehrere m√∂gliche Werte** annehmen k√∂nnen.
* Verwendung: `string | number`, `(string | number)[]`.
* N√ºtzlich f√ºr Werte mit mehreren erlaubten Formen (z. B. API-Response: `string | null`).

üîó Quellen:

* [TypeScript Handbook ‚Äì Union Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types)
* [React TypeScript Cheatsheet ‚Äì Union Types](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

10. ### <a name="10"></a> Was sind Intersection Types? Gib ein Beispiel.

### Intersection Types in TypeScript

**Definition:**
Ein **Intersection Type** (`&`) kombiniert mehrere Typen zu einem **neuen Typ**, der **alle Eigenschaften** der beteiligten Typen enthalten muss.
‚Üí W√§hrend `Union (|)` **entweder-oder** bedeutet, ist `Intersection (&)` ein **sowohl-als-auch**.

---

### Beispiel 1 ‚Äì Kombination von Interfaces

```js
interface Person {
  name: string
}

interface Employee {
  company: string
}

type EmployeePerson = Person & Employee

const worker: EmployeePerson = {
  name: "Sergii",
  company: "Tech GmbH"
}
```

---

### Beispiel 2 ‚Äì Kombination von Typen

```js
type A = { x: number }
type B = { y: number }

type AB = A & B

const point: AB = { x: 10, y: 20 } // Muss beide Eigenschaften haben
```

---

### Beispiel 3 ‚Äì Praktisch in Generics

```js
function merge<T, U>(objA: T, objB: U): T & U {
  return { ...objA, ...objB }
}

const merged = merge({ id: 1 }, { role: "admin" })
// Typ: { id: number } & { role: string }
```

---

### Zusammenfassung

* **Intersection Types (`&`)** = Kombination mehrerer Typen zu einem Typ, der **alle Eigenschaften** enth√§lt.
* Unterschied zu Union:

  * **Union (`|`)** ‚Üí entweder-oder.
  * **Intersection (`&`)** ‚Üí sowohl-als-auch.

üîó Quellen:

* [TypeScript Handbook ‚Äì Intersection Types](https://www.typescriptlang.org/docs/handbook/2/objects.html#intersection-types)
* [React TS Cheatsheet ‚Äì Utility Types & Intersections](https://react-typescript-cheatsheet.netlify.app/docs/advanced/types_react_api/)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

11. ### <a name="11"></a> Was sind Literal Types?

### Literal Types in TypeScript

**Definition:**
Ein **Literal Type** schr√§nkt eine Variable auf einen **konkreten Wert** ein, anstatt nur auf den allgemeinen Typ (z. B. `string` oder `number`).
So kann man Variablen oder Parameter **nur bestimmte erlaubte Werte** zuweisen.

---

### Beispiel 1 ‚Äì String-Literals

```js
let direction: "left" | "right"

direction = "left"   // ‚úÖ erlaubt
direction = "right"  // ‚úÖ erlaubt
direction = "up"     // ‚ùå Fehler
```

---

### Beispiel 2 ‚Äì Number-Literals

```js
let diceRoll: 1 | 2 | 3 | 4 | 5 | 6

diceRoll = 3  // ‚úÖ erlaubt
diceRoll = 7  // ‚ùå Fehler
```

---

### Beispiel 3 ‚Äì In Kombination mit Unions

```js
type Status = "success" | "error" | "loading"

function handleStatus(status: Status): void {
  if (status === "success") {
    console.log("Alles gut ‚úÖ")
  } else if (status === "error") {
    console.log("Fehler ‚ùå")
  } else {
    console.log("L√§dt ‚è≥")
  }
}

handleStatus("success")
```

---

### Beispiel 4 ‚Äì Literal Inferenz mit `const`

```js
const role = "admin"
// Typ ist "admin", nicht string
```

---

### Zusammenfassung

* **Literal Types** = feste, konkrete Werte als Typen.
* N√ºtzlich f√ºr: erlaubte Werte (Enums-√§hnlich), Statusangaben, Konstanten.
* Oft in Kombination mit **Union Types** genutzt.

üîó Quellen:

* [TypeScript Handbook ‚Äì Literal Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-types)
* [React TS Cheatsheet ‚Äì Discriminated Unions](https://react-typescript-cheatsheet.netlify.app/docs/advanced/discriminated_unions/)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

12. ### <a name="12"></a> Wie funktioniert type inference in TypeScript?

### Type Inference in TypeScript

**Definition:**
**Type Inference (Typinferenz)** bedeutet, dass TypeScript den Typ einer Variable, Funktion oder eines Ausdrucks **automatisch ableitet**, wenn kein expliziter Typ angegeben wird.

---

### Regeln der Typinferenz

#### 1. **Variable-Zuweisung**

```js
let count = 10
// Typ wird automatisch als number erkannt
// count: number
```

---

#### 2. **Funktionsergebnisse**

```js
function add(a: number, b: number) {
  return a + b
}
// R√ºckgabetyp: number (wird automatisch erkannt)
```

---

#### 3. **Best Common Type**

Wenn verschiedene Typen in einem Array vorkommen, w√§hlt TypeScript den "allgemeinsten" Typ.

```js
let values = [1, "zwei", 3]
// Typ: (string | number)[]
```

---

#### 4. **Contextual Typing**

Der Typ kann auch aus dem **Kontext** abgeleitet werden.

```js
window.addEventListener("click", (event) => {
  console.log(event.clientX) // event: MouseEvent
})
```

---

#### 5. **Default Inference f√ºr `any`**

Wenn keine Information vorliegt, wird `any` angenommen (au√üer bei `--noImplicitAny`).

```js
function log(value) {
  console.log(value)
}
// value: any
```

---

### Vorteile

* Weniger Schreibarbeit (man muss nicht √ºberall Typen manuell angeben).
* Bessere Lesbarkeit.
* Trotzdem Typ-Sicherheit, solange genug Information vorhanden ist.

---

### Zusammenfassung

* **Type Inference** = automatische Typbestimmung durch TypeScript.
* Regeln: Variablenzuweisung, Funktionsr√ºckgaben, Arrays (Best Common Type), Kontextabh√§ngigkeit.
* Vorteil: weniger Code, aber trotzdem Typ-Sicherheit.

üîó Quellen:

* [TypeScript Handbook ‚Äì Type Inference](https://www.typescriptlang.org/docs/handbook/type-inference.html)
* [React TS Cheatsheet ‚Äì Inference](https://react-typescript-cheatsheet.netlify.app/docs/basic/troubleshooting/types/#type-inference)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

13. ### <a name="13"></a> Was ist ein Type Alias (type) und wie unterscheidet er sich von interface?

### **Type Alias (`type`) in TypeScript**

**Definition:**
Ein **Type Alias** erstellt einen neuen Namen f√ºr einen bestehenden Typ.
Er kann primitive Typen, Union/Intersection Types, Funktionen oder komplexe Strukturen beschreiben.

```js
type UserID = string | number

type User = {
  id: UserID
  name: string
}
```

---

### **Interface in TypeScript**

**Definition:**
Ein **Interface** beschreibt die **Struktur eines Objekts** (Shape).
Es wird h√§ufig f√ºr Klassen, Objekte und die Definition von Vertr√§gen verwendet.

```js
interface User {
  id: number
  name: string
}
```

---

### **Hauptunterschiede**

| Aspekt                   | `type`                                                               | `interface`                                    |
| ------------------------ | -------------------------------------------------------------------- | ---------------------------------------------- |
| **Einsatz**              | Alias f√ºr jeden Typ (Primitives, Unions, Functions, Tuples, Objects) | Nur Objekte und Klassen-Strukturen             |
| **Erweiterung**          | Mit `&` (Intersection)                                               | Mit `extends`                                  |
| **Deklarations-Merging** | ‚ùå Nicht m√∂glich                                                      | ‚úÖ Mehrfachdeklarationen werden zusammengef√ºhrt |
| **Flexibilit√§t**         | Sehr vielseitig                                                      | Speziell f√ºr objektorientierte Modelle         |

---

### **Beispiele f√ºr Unterschiede**

#### 1. Type f√ºr Union

```js
type Status = "success" | "error" | "loading"
```

Mit `interface` nicht m√∂glich.

---

#### 2. Interface-Erweiterung

```js
interface Person {
  name: string
}

interface Employee extends Person {
  company: string
}
```

---

#### 3. Type-Erweiterung mit Intersection

```js
type Person = { name: string }
type Employee = Person & { company: string }
```

---

#### 4. Deklarations-Merging

```js
interface Window {
  title: string
}

interface Window {
  size: number
}

const w: Window = { title: "App", size: 800 }
// ‚úÖ erlaubt, beide Interfaces verschmelzen
```

Mit `type` nicht m√∂glich.

---

### Zusammenfassung

* **`type`** = Alias f√ºr beliebige Typen (Primitives, Union, Intersection, Functions, Tuples, Objekte).
* **`interface`** = Vertrag f√ºr Objekt- oder Klassen-Strukturen, unterst√ºtzt Deklarations-Merging.
* Empfehlung:

  * **Objektmodelle ‚Üí `interface`**
  * **Komplexe Typ-Kombinationen ‚Üí `type`**

üîó Quellen:

* [TypeScript Handbook ‚Äì Type Aliases](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-aliases)
* [TypeScript Handbook ‚Äì Interfaces](https://www.typescriptlang.org/docs/handbook/2/objects.html)
* [React TS Cheatsheet ‚Äì Types vs. Interfaces](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example#types-vs-interfaces)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

14. ### <a name="14"></a> Was ist der Unterschied zwischen interface und type?

### Unterschied zwischen `interface` und `type` in TypeScript

#### **1. Gemeinsamkeiten**

* Beide k√∂nnen Objekte beschreiben.
* Beide unterst√ºtzen Erweiterung und Wiederverwendung.
* Beide sind strukturell (nicht nominal) ‚Üí entscheidend ist die Form, nicht der Name.

---

#### **2. Unterschiede**

| Aspekt                   | `interface`                                       | `type`                                                             |
| ------------------------ | ------------------------------------------------- | ------------------------------------------------------------------ |
| **Verwendungszweck**     | Haupts√§chlich f√ºr Objekte und Klassen-Contracts   | Alias f√ºr jeden Typ (auch Primitives, Union, Tuple, Function etc.) |
| **Erweiterung**          | `extends`                                         | Intersection (`&`)                                                 |
| **Deklarations-Merging** | ‚úÖ Ja (mehrfach definierbar, wird zusammengef√ºhrt) | ‚ùå Nein                                                             |
| **Flexibilit√§t**         | Eingeschr√§nkter (nur f√ºr Objekt-√§hnliche Typen)   | Sehr flexibel, kann alles beschreiben                              |
| **Lesbarkeit**           | Oft bevorzugt f√ºr Props, Klassen, API-Schemas     | Bevorzugt f√ºr komplexe Typkombinationen, Union/Intersection        |

---

#### **3. Beispiele**

**Interface f√ºr Objekte**

```js
interface Person {
  name: string
  age: number
}

interface Employee extends Person {
  company: string
}

const dev: Employee = { name: "Sergii", age: 34, company: "Tech GmbH" }
```

**Type f√ºr komplexe Kombinationen**

```js
type Status = "success" | "error" | "loading"

type UserID = string | number

type Point = [number, number] // Tuple
```

**Deklarations-Merging (nur bei Interface)**

```js
interface Window {
  title: string
}

interface Window {
  size: number
}

const w: Window = { title: "App", size: 800 } // ‚úÖ erlaubt
```

---

### Zusammenfassung

* **`interface`** = objektorientiert, erweiterbar (`extends`), unterst√ºtzt Deklarations-Merging.
* **`type`** = flexibler, geeignet f√ºr Unions, Primitives, Funktionen, Tuples.
* Empfehlung:

  * **Objekte/Klassen** ‚Üí `interface`
  * **Union/Intersection/Primitives** ‚Üí `type`

üîó Quellen:

* [TypeScript Handbook ‚Äì Interfaces](https://www.typescriptlang.org/docs/handbook/2/objects.html)
* [TypeScript Handbook ‚Äì Type Aliases](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-aliases)
* [React TS Cheatsheet ‚Äì Types vs Interfaces](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example#types-vs-interfaces)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

15. ### <a name="15"></a> Kann man Interfaces zusammenf√ºhren (extend)?

### Interfaces zusammenf√ºhren in TypeScript

Ja ‚Äì **Interfaces** k√∂nnen auf zwei Arten zusammengef√ºhrt werden:

---

#### **1. Erweiterung mit `extends`**

Ein Interface kann ein anderes Interface erweitern.

```js
interface Person {
  name: string
}

interface Employee extends Person {
  company: string
}

const dev: Employee = {
  name: "Sergii",
  company: "Tech GmbH"
}
```

* `Employee` erbt alle Eigenschaften von `Person`.

---

#### **2. Deklarations-Merging**

Wenn mehrere **gleichnamige Interfaces** existieren, werden sie automatisch zusammengef√ºhrt.

```js
interface Window {
  title: string
}

interface Window {
  size: number
}

const w: Window = {
  title: "App",
  size: 1200
}
```

* TypeScript kombiniert beide Definitionen ‚Üí Ergebnis ist ein Interface mit `title` **und** `size`.

---

#### Unterschied zu `type`

* `type` kann **nicht** gemerged werden.
* Nur `interface` unterst√ºtzt Deklarations-Merging.

---

### Zusammenfassung

* **Ja, Interfaces k√∂nnen zusammengef√ºhrt werden.**
* Zwei Wege:

  1. **`extends`** ‚Üí Vererbung.
  2. **Deklarations-Merging** ‚Üí mehrere gleiche Namen = automatisch kombiniert.
* Vorteil: Flexibel f√ºr API-Erweiterungen oder globale Typdefinitionen.

üîó Quellen:

* [TypeScript Handbook ‚Äì Interfaces](https://www.typescriptlang.org/docs/handbook/2/objects.html#extending-interfaces)
* [TypeScript Handbook ‚Äì Declaration Merging](https://www.typescriptlang.org/docs/handbook/declaration-merging.html)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

16. ### <a name="16"></a> Was sind optionale Eigenschaften in Interfaces?

### Optionale Eigenschaften in Interfaces

**Definition:**
Optionale Eigenschaften in einem Interface sind Felder, die beim Erstellen eines Objekts **nicht zwingend angegeben** werden m√ºssen.
Man markiert sie mit einem **Fragezeichen (`?`)** nach dem Eigenschaftsnamen.

---

### Beispiel 1 ‚Äì Einfaches Interface mit optionalen Feldern

```js
interface User {
  id: number
  name: string
  age?: number // optional
}

const user1: User = { id: 1, name: "Sergii" }       // ‚úÖ ohne age
const user2: User = { id: 2, name: "Anna", age: 30 } // ‚úÖ mit age
```

---

### Beispiel 2 ‚Äì Optional in Kombination mit Funktionen

```js
interface Config {
  url: string
  timeout?: number
}

function fetchData(config: Config) {
  console.log(`Hole Daten von ${config.url}`)
  if (config.timeout) {
    console.log(`Timeout: ${config.timeout}ms`)
  }
}

fetchData({ url: "/api" })
fetchData({ url: "/api", timeout: 5000 })
```

---

### Beispiel 3 ‚Äì Unterschied zu `undefined`

Ein optionales Feld kann fehlen **oder explizit `undefined` sein**.

```js
interface Product {
  name: string
  price?: number
}

const p1: Product = { name: "Buch" }                 // kein price
const p2: Product = { name: "Buch", price: undefined } // explizit undefined
```

---

### Zusammenfassung

* **Optionale Eigenschaften** (`?`) = nicht verpflichtend in Objekten.
* K√∂nnen weggelassen oder explizit auf `undefined` gesetzt werden.
* N√ºtzlich f√ºr **Konfigurationsobjekte, optionale Props, flexible Datenstrukturen**.

üîó Quellen:

* [TypeScript Handbook ‚Äì Interfaces](https://www.typescriptlang.org/docs/handbook/2/objects.html#optional-properties)
* [React TS Cheatsheet ‚Äì Optional Props](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example#optional-props)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

17. ### <a name="17"></a> Wie deklariert man readonly-Eigenschaften?

### `readonly` Eigenschaften in TypeScript

**Definition:**
Mit dem Schl√ºsselwort **`readonly`** kann man Eigenschaften in Interfaces, Types oder Klassen so deklarieren, dass sie **nach der Initialisierung nicht mehr ver√§ndert** werden d√ºrfen.

---

### Beispiel 1 ‚Äì Interface mit `readonly`

```js
interface User {
  readonly id: number
  name: string
}

const user: User = { id: 1, name: "Sergii" }

user.name = "Anna"   // ‚úÖ erlaubt
user.id = 2          // ‚ùå Fehler: id ist readonly
```

---

### Beispiel 2 ‚Äì Type mit `readonly`

```js
type Point = {
  readonly x: number
  readonly y: number
}

const p: Point = { x: 10, y: 20 }
p.x = 30 // ‚ùå Fehler
```

---

### Beispiel 3 ‚Äì Klassen mit `readonly`

```js
class Person {
  readonly id: number
  name: string

  constructor(id: number, name: string) {
    this.id = id      // ‚úÖ Initialisierung erlaubt
    this.name = name
  }
}

const dev = new Person(1, "Sergii")
dev.name = "Anna"   // ‚úÖ erlaubt
dev.id = 2          // ‚ùå Fehler
```

---

### Beispiel 4 ‚Äì Readonly Arrays

```js
const numbers: ReadonlyArray<number> = [1, 2, 3]

numbers.push(4) // ‚ùå Fehler: push ist nicht erlaubt
```

---

### Zusammenfassung

* **`readonly`** = Eigenschaft kann nur bei der Initialisierung gesetzt werden.
* Einsatz in: **Interfaces, Types, Klassen, Arrays**.
* Vorteil: bessere **Immutabilit√§t** und Sicherheit vor unbeabsichtigten √Ñnderungen.

üîó Quellen:

* [TypeScript Handbook ‚Äì readonly](https://www.typescriptlang.org/docs/handbook/2/objects.html#readonly-properties)
* [React TS Cheatsheet ‚Äì readonly usage](https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase#readonly-and-const-assertions)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

18. ### <a name="18"></a> Was sind Tupel (tuples) in TypeScript?

### Tupel (Tuples) in TypeScript

**Definition:**
Ein **Tuple** ist ein spezielles Array mit **fester L√§nge** und **fest definierten Typen** an den jeweiligen Positionen.
‚Üí Anders als bei Arrays kann jedes Element einen eigenen Typ haben, der an einer bestimmten Stelle erwartet wird.

---

### Beispiel 1 ‚Äì Einfaches Tuple

```js
let user: [string, number]

user = ["Sergii", 34]   // ‚úÖ korrekt
user = [34, "Sergii"]   // ‚ùå Fehler: Reihenfolge stimmt nicht
```

---

### Beispiel 2 ‚Äì Tuple mit optionalem Element

```js
let point: [number, number, number?]

point = [10, 20]       // ‚úÖ erlaubt
point = [10, 20, 30]   // ‚úÖ erlaubt
```

---

### Beispiel 3 ‚Äì Mit `readonly` (immutable Tuple)

```js
let coordinates: readonly [number, number] = [50, 100]

coordinates[0] = 10 // ‚ùå Fehler: readonly
```

---

### Beispiel 4 ‚Äì Einsatz in Funktionen

```js
function useCoordinates(): [number, number] {
  return [10, 20]
}

const [x, y] = useCoordinates()
```

---

### Beispiel 5 ‚Äì Variadische Tupel (seit TS 4.0)

```js
type Pair<T> = [T, T]
type Triple<T> = [T, T, T]

let pair: Pair<string> = ["a", "b"]
let triple: Triple<number> = [1, 2, 3]
```

---

### Zusammenfassung

* **Tuple** = Array mit **fester L√§nge** und **definierten Typen pro Index**.
* N√ºtzlich f√ºr: R√ºckgabewerte von Funktionen, koordinatenartige Werte, kleine feste Strukturen.
* Erweiterungen: optionale Elemente, `readonly`, variadische Tupel.

üîó Quellen:

* [TypeScript Handbook ‚Äì Tuples](https://www.typescriptlang.org/docs/handbook/2/objects.html#tuple-types)
* [MDN ‚Äì Arrays (als Grundlage)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

19. ### <a name="19"></a> Was ist ein Enum und wann sollte man es verwenden?

### Enum in TypeScript

**Definition:**
Ein **Enum** (Aufz√§hlungstyp) ist eine Sammlung von **benannten Konstanten**.
Es wird verwendet, um Wertegruppen besser lesbar und verst√§ndlich zu machen.

---

### Arten von Enums

#### 1. **Numerische Enums (Standard)**

```js
enum Direction {
  Up,    // 0
  Down,  // 1
  Left,  // 2
  Right  // 3
}

let move: Direction = Direction.Up
console.log(move) // 0
```

Man kann auch Startwerte vergeben:

```js
enum Status {
  Success = 1,
  Error = 2,
  Loading = 3
}
```

---

#### 2. **String Enums**

```js
enum Role {
  Admin = "ADMIN",
  User = "USER",
  Guest = "GUEST"
}

let current: Role = Role.Admin
```

---

#### 3. **Const Enums (Kompilierungsoptimierung)**

```js
const enum LogLevel {
  Info,
  Warning,
  Error
}

let level: LogLevel = LogLevel.Error
```

üëâ Vorteile: wird zu einfachen Konstanten kompiliert ‚Üí bessere Performance.

---

### Wann verwenden?

‚úÖ **Geeignet f√ºr:**

* Feste, klar definierte Wertegruppen (z. B. Rollen, Status, Richtungen).
* Lesbarkeit: statt `"ADMIN"` oder `1` ‚Üí `Role.Admin`.
* Weniger Tippfehler durch Autovervollst√§ndigung.

‚ö†Ô∏è **Alternativen:**

* **Union Types** mit Literal-Typen sind oft schlanker und flexibler.

  ```js
  type Role = "ADMIN" | "USER" | "GUEST"
  ```
* Empfehlung: In modernen Projekten werden h√§ufig **Union Types** anstelle von Enums bevorzugt, da sie besser mit TypeScript-Features wie Narrowing und Type Inference harmonieren.

---

### Zusammenfassung

* **Enum** = Sammlung von benannten Konstanten (numeric, string, const).
* Vorteile: bessere Lesbarkeit, Fehlervermeidung, klare Struktur.
* Verwendung: feste Wertemengen (Status, Rollen, Richtungen).
* Alternative: **Union Types** ‚Üí oft moderner und einfacher.

üîó Quellen:

* [TypeScript Handbook ‚Äì Enums](https://www.typescriptlang.org/docs/handbook/enums.html)
* [React TS Cheatsheet ‚Äì Union vs Enums](https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase#enums-vs-union-types)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

20. ### <a name="20"></a> Was ist der Unterschied zwischen const enum und einem normalen enum?

### Unterschied zwischen `enum` und `const enum` in TypeScript

#### **1. Normales `enum`**

* Wird zur **Laufzeit** in JavaScript-Code kompiliert.
* TypeScript erzeugt ein **Objekt** mit Schl√ºssel/Wert-Zuordnung.
* Bidirektionale Abbildung: man kann von Namen auf Wert und umgekehrt zugreifen.

```js
enum Direction {
  Up,
  Down,
  Left,
  Right
}

console.log(Direction.Up)    // 0
console.log(Direction[0])    // "Up"
```

‚û°Ô∏è Nach der Kompilierung entsteht ein JS-Objekt:

```js
var Direction;
(function (Direction) {
    Direction[Direction["Up"] = 0] = "Up";
    Direction[Direction["Down"] = 1] = "Down";
    Direction[Direction["Left"] = 2] = "Left";
    Direction[Direction["Right"] = 3] = "Right";
})(Direction || (Direction = {}));
```

---

#### **2. `const enum`**

* Wird **zur Compile-Zeit** durch seine Werte ersetzt.
* Kein Objekt im generierten JavaScript.
* Spart Code und verbessert Performance.

```js
const enum Direction {
  Up,
  Down,
  Left,
  Right
}

let move = Direction.Up
console.log(move) // 0
```

‚û°Ô∏è Nach der Kompilierung:

```js
let move = 0 /* Up */
```

* Kein `Direction`-Objekt vorhanden ‚Üí keine bidirektionale Abbildung m√∂glich.

---

#### **3. Vergleich**

| Aspekt              | `enum`                                      | `const enum`                     |
| ------------------- | ------------------------------------------- | -------------------------------- |
| **Kompilierung**    | JS-Objekt wird erzeugt                      | Ersetzt durch Werte, kein Objekt |
| **Performance**     | Mehr Overhead                               | Weniger Overhead                 |
| **Reverse Mapping** | ‚úÖ m√∂glich (`Direction[0] ‚Üí "Up"`)           | ‚ùå nicht m√∂glich                  |
| **Codegr√∂√üe**       | Gr√∂√üer                                      | Kleiner                          |
| **Verwendung**      | Wenn bidirektionales Mapping gebraucht wird | F√ºr reine Konstantenwerte        |

---

### Zusammenfassung

* **`enum`**: erzeugt ein JavaScript-Objekt ‚Üí erlaubt Zugriff in beide Richtungen, gr√∂√üerer Output.
* **`const enum`**: wird w√§hrend der Kompilierung inline ersetzt ‚Üí effizienter, aber ohne Reverse Mapping.

üîó Quellen:

* [TypeScript Handbook ‚Äì Enums](https://www.typescriptlang.org/docs/handbook/enums.html#const-enums)
* [React TS Cheatsheet ‚Äì Enums](https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase#enums-vs-union-types)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

21. ### <a name="21"></a> Was ist Type Narrowing (Typschr√§nkung)?

### Type Narrowing (Typschr√§nkung) in TypeScript

**Definition:**
**Type Narrowing** bedeutet, dass TypeScript den Typ einer Variable w√§hrend des Codes **einschr√§nkt** (von einem breiteren Union-Typ auf einen spezifischeren Typ), basierend auf **Kontrollstrukturen oder Type Guards**.

---

### Beispiel 1 ‚Äì `typeof` Narrowing

```js
function printId(id: string | number) {
  if (typeof id === "string") {
    console.log(id.toUpperCase()) // id: string
  } else {
    console.log(id.toFixed(2))    // id: number
  }
}
```

---

### Beispiel 2 ‚Äì `instanceof` Narrowing

```js
class Dog {
  bark() { console.log("Wuff!") }
}
class Cat {
  meow() { console.log("Miau!") }
}

function makeSound(animal: Dog | Cat) {
  if (animal instanceof Dog) {
    animal.bark() // animal: Dog
  } else {
    animal.meow() // animal: Cat
  }
}
```

---

### Beispiel 3 ‚Äì Property Check (`in` Operator)

```js
type Fish = { swim: () => void }
type Bird = { fly: () => void }

function move(animal: Fish | Bird) {
  if ("swim" in animal) {
    animal.swim() // Typ: Fish
  } else {
    animal.fly()  // Typ: Bird
  }
}
```

---

### Beispiel 4 ‚Äì Gleichheitspr√ºfung (Literal Narrowing)

```js
type Status = "success" | "error" | "loading"

function handleStatus(status: Status) {
  if (status === "success") {
    console.log("Alles gut ‚úÖ")
  }
}
```

---

### Beispiel 5 ‚Äì Exhaustive Check mit `never`

```js
type Shape = { kind: "circle"; radius: number } 
           | { kind: "square"; side: number }

function area(shape: Shape): number {
  switch (shape.kind) {
    case "circle": return Math.PI * shape.radius ** 2
    case "square": return shape.side * shape.side
    default:
      const exhaustive: never = shape // Fehler, falls ein neuer Typ fehlt
      return exhaustive
  }
}
```

---

### Zusammenfassung

* **Type Narrowing** = Einschr√§nkung von Union-Typen auf spezifische Typen.
* Methoden: `typeof`, `instanceof`, `in`, Gleichheitspr√ºfungen, Kontrollfluss.
* Vorteil: bessere Typ-Sicherheit, weniger Fehler, klarer Code.

üîó Quellen:

* [TypeScript Handbook ‚Äì Narrowing](https://www.typescriptlang.org/docs/handbook/2/narrowing.html)
* [React TS Cheatsheet ‚Äì Type Narrowing](https://react-typescript-cheatsheet.netlify.app/docs/basic/troubleshooting/types/#type-narrowing)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

22. ### <a name="22"></a> Was sind Type Guards? Gib ein Beispiel.

### Type Guards in TypeScript

**Definition:**
Ein **Type Guard** ist eine spezielle Bedingung oder Funktion, mit der TypeScript erkennt, welchen konkreten Typ eine Variable in einem Union-Type-Kontext hat.
‚Üí Er hilft beim **Type Narrowing**, sodass TypeScript innerhalb des Blocks mit dem spezifischen Typ arbeiten kann.

---

### Beispiel 1 ‚Äì `typeof` als Type Guard

```js
function printValue(value: string | number) {
  if (typeof value === "string") {
    console.log(value.toUpperCase()) // value: string
  } else {
    console.log(value.toFixed(2))    // value: number
  }
}
```

---

### Beispiel 2 ‚Äì `instanceof` als Type Guard

```js
class Dog {
  bark() { console.log("Wuff!") }
}
class Cat {
  meow() { console.log("Miau!") }
}

function makeSound(animal: Dog | Cat) {
  if (animal instanceof Dog) {
    animal.bark() // animal: Dog
  } else {
    animal.meow() // animal: Cat
  }
}
```

---

### Beispiel 3 ‚Äì Property Check (`in` Operator)

```js
type Fish = { swim: () => void }
type Bird = { fly: () => void }

function move(animal: Fish | Bird) {
  if ("swim" in animal) {
    animal.swim() // animal: Fish
  } else {
    animal.fly()  // animal: Bird
  }
}
```

---

### Beispiel 4 ‚Äì Benutzerdefinierter Type Guard (`is`-Syntax)

```js
type Car = { drive: () => void }
type Boat = { sail: () => void }

function isCar(vehicle: Car | Boat): vehicle is Car {
  return (vehicle as Car).drive !== undefined
}

function useVehicle(vehicle: Car | Boat) {
  if (isCar(vehicle)) {
    vehicle.drive() // Typ: Car
  } else {
    vehicle.sail()  // Typ: Boat
  }
}
```

---

### Zusammenfassung

* **Type Guards** = Bedingungen/Funktionen, die Typen pr√§zisieren.
* Varianten:

  * `typeof` (f√ºr primitive Typen)
  * `instanceof` (f√ºr Klassen)
  * `in` Operator (f√ºr Properties)
  * benutzerdefinierte Type Guards (`is`-Syntax)
* Zweck: **sicheres Type Narrowing** in Union Types.

üîó Quellen:

* [TypeScript Handbook ‚Äì Narrowing](https://www.typescriptlang.org/docs/handbook/2/narrowing.html)
* [React TS Cheatsheet ‚Äì Type Guards](https://react-typescript-cheatsheet.netlify.app/docs/basic/troubleshooting/types/#type-guards)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

23. ### <a name="23"></a> Wie funktioniert der Operator in bei der Typpr√ºfung?

### Der `in`-Operator bei der Typpr√ºfung in TypeScript

**Definition:**
Der **`in`-Operator** pr√ºft, ob ein bestimmtes Property in einem Objekt existiert.
In TypeScript wird er als **Type Guard** genutzt, um zwischen verschiedenen Typen in einer Union zu unterscheiden.

---

### Beispiel 1 ‚Äì Unterschiedliche Objekt-Typen

```js
type Dog = { bark: () => void }
type Cat = { meow: () => void }

function makeSound(animal: Dog | Cat) {
  if ("bark" in animal) {
    animal.bark() // animal: Dog
  } else {
    animal.meow() // animal: Cat
  }
}
```

‚û°Ô∏è Der `in`-Check sagt TypeScript:

* Wenn `bark` vorhanden ist ‚Üí Typ ist `Dog`.
* Ansonsten ‚Üí Typ ist `Cat`.

---

### Beispiel 2 ‚Äì Optionale Properties

```js
interface User {
  id: number
  name: string
  email?: string
}

function hasEmail(user: User) {
  if ("email" in user) {
    console.log("User hat eine Email:", user.email)
  } else {
    console.log("Keine Email")
  }
}
```

---

### Beispiel 3 ‚Äì Discriminated Unions

```js
type Circle = { kind: "circle"; radius: number }
type Square = { kind: "square"; side: number }

function area(shape: Circle | Square) {
  if ("radius" in shape) {
    return Math.PI * shape.radius ** 2 // Circle
  } else {
    return shape.side * shape.side     // Square
  }
}
```

---

### Zusammenfassung

* **`in`-Operator** pr√ºft, ob ein Property existiert.
* In TypeScript dient er als **Type Guard** f√ºr Union Types.
* Typische Nutzung: Unterscheidung zwischen Objekten mit unterschiedlichen Eigenschaften oder optionalen Feldern.

üîó Quellen:

* [TypeScript Handbook ‚Äì Narrowing mit `in`](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-the-in-operator)
* [MDN ‚Äì in Operator](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/in)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

24. ### <a name="24"></a> Wie funktioniert typeof in TypeScript?

### `typeof` in TypeScript

**Definition:**
In TypeScript hat `typeof` **zwei unterschiedliche Einsatzm√∂glichkeiten**:

1. **Zur Laufzeit** ‚Üí wie in JavaScript, um den Typ eines Wertes zu pr√ºfen.
2. **Zur Compile-Zeit** ‚Üí um den Typ einer Variablen/Funktion zu extrahieren und wiederzuverwenden.

---

## 1. `typeof` zur Laufzeit (Type Guard)

Verh√§lt sich wie in JavaScript, gibt einen **String** mit dem Typ zur√ºck.
Wird in TypeScript f√ºr **Type Narrowing** genutzt.

```js
function printValue(value: string | number) {
  if (typeof value === "string") {
    console.log(value.toUpperCase()) // value: string
  } else {
    console.log(value.toFixed(2))    // value: number
  }
}
```

M√∂gliche Ergebnisse: `"string"`, `"number"`, `"boolean"`, `"object"`, `"function"`, `"undefined"`, `"symbol"`, `"bigint"`.

---

## 2. `typeof` zur Compile-Zeit (Type Query Operator)

Damit kann man den **Typ einer bestehenden Variable/Funktion** f√ºr eine Typdefinition wiederverwenden.

```js
let user = { id: 1, name: "Sergii" }

// Extrahiert den Typ von user
type User = typeof user

const admin: User = { id: 2, name: "Anna" } // ‚úÖ korrekt
```

---

## 3. `typeof` f√ºr Funktionen

```js
function add(a: number, b: number) {
  return a + b
}

type AddFunction = typeof add
// AddFunction ist: (a: number, b: number) => number
```

---

### Zusammenfassung

* **Laufzeit (`typeof` als Operator):** gibt den primitiven JS-Typ zur√ºck, nutzbar als Type Guard.
* **Compile-Zeit (`typeof` als Type Query):** extrahiert den Typ einer bestehenden Variablen oder Funktion.
* Vorteil: weniger Code-Duplikation, sicheres Type Narrowing.

üîó Quellen:

* [TypeScript Handbook ‚Äì typeof](https://www.typescriptlang.org/docs/handbook/2/typeof-types.html)
* [TypeScript Handbook ‚Äì Narrowing mit typeof](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#typeof-type-guards)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

25. ### <a name="25"></a> Wie funktioniert instanceof?

### `instanceof` in TypeScript

**Definition:**
Der Operator **`instanceof`** pr√ºft **zur Laufzeit**, ob ein Objekt von einer bestimmten **Klasse oder einem Konstruktor** erstellt wurde.
In TypeScript wird er als **Type Guard** verwendet, um den Typ innerhalb eines Blocks einzugrenzen (**Type Narrowing**).

---

### Beispiel 1 ‚Äì Klassenpr√ºfung

```js
class Dog {
  bark() { console.log("Wuff!") }
}

class Cat {
  meow() { console.log("Miau!") }
}

function makeSound(animal: Dog | Cat) {
  if (animal instanceof Dog) {
    animal.bark() // animal: Dog
  } else {
    animal.meow() // animal: Cat
  }
}
```

---

### Beispiel 2 ‚Äì Mit eingebauten Objekten

```js
function logDate(date: Date | string) {
  if (date instanceof Date) {
    console.log("Datum:", date.toISOString()) // date: Date
  } else {
    console.log("String:", date.toUpperCase()) // date: string
  }
}
```

---

### Beispiel 3 ‚Äì Nicht f√ºr primitive Typen

```js
let value = "Hallo"

console.log(value instanceof String) // ‚ùå false (Primitives sind keine Instanzen)
```

üëâ F√ºr Primitives verwendet man `typeof`, nicht `instanceof`.

---

### Vergleich zu anderen Type Guards

* **`typeof`** ‚Üí f√ºr primitive Typen (`string`, `number`, `boolean`, ‚Ä¶).
* **`instanceof`** ‚Üí f√ºr Klassen und Objekte, die mit `new` erstellt wurden.
* **`in`** ‚Üí f√ºr Property-Pr√ºfungen in Objekten.

---

### Zusammenfassung

* **`instanceof`** pr√ºft, ob ein Objekt von einer bestimmten Klasse/Konstruktor stammt.
* Dient als **Type Guard** in Union Types.
* Funktioniert nur bei **Objekten/Klassen**, nicht bei Primitives.

üîó Quellen:

* [TypeScript Handbook ‚Äì Narrowing mit `instanceof`](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#instanceof-narrowing)
* [MDN ‚Äì instanceof](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/instanceof)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

26. ### <a name="26"></a> Was sind Discriminated Unions (diskriminierte Typen)?

### Discriminated Unions (diskriminierte Typen) in TypeScript

**Definition:**
Ein **Discriminated Union** ist ein **Union Type**, bei dem jede Variante ein gemeinsames, eindeutiges Feld (das sog. **Discriminant**) enth√§lt.
TypeScript kann dadurch den Typ automatisch unterscheiden (**Type Narrowing**).

---

### Beispiel 1 ‚Äì Shapes

```js
interface Circle {
  kind: "circle"   // Discriminant
  radius: number
}

interface Square {
  kind: "square"   // Discriminant
  side: number
}

type Shape = Circle | Square

function area(shape: Shape): number {
  switch (shape.kind) {
    case "circle":
      return Math.PI * shape.radius ** 2
    case "square":
      return shape.side * shape.side
  }
}
```

‚û°Ô∏è `kind` diskriminiert zwischen `Circle` und `Square`.

---

### Beispiel 2 ‚Äì API-Status

```js
type ApiResponse =
  | { status: "success"; data: string }
  | { status: "error"; error: Error }
  | { status: "loading" }

function handleResponse(res: ApiResponse) {
  if (res.status === "success") {
    console.log("Data:", res.data)
  } else if (res.status === "error") {
    console.error("Fehler:", res.error.message)
  } else {
    console.log("L√§dt...")
  }
}
```

---

### Beispiel 3 ‚Äì Exhaustive Checking mit `never`

```js
function exhaustiveCheck(x: never): never {
  throw new Error("Unreachable code")
}

function handleShape(shape: Shape) {
  switch (shape.kind) {
    case "circle": return Math.PI * shape.radius ** 2
    case "square": return shape.side * shape.side
    default: return exhaustiveCheck(shape) // ‚õî Compiler-Fehler, falls neuer Typ fehlt
  }
}
```

---

### Vorteile

* Bessere **Typ-Sicherheit** bei Union Types.
* TypeScript erkennt automatisch, welcher Typ in welchem Zweig vorliegt.
* Erleichtert **Fehlerpr√§vention** durch Exhaustive Checks.

---

### Zusammenfassung

* **Discriminated Unions** = Union Types mit einem gemeinsamen Feld (`kind`, `status`, etc.).
* Dienen zur klaren Typunterscheidung.
* Sehr n√ºtzlich in **Switch-Statements** und bei **API-Responses** oder **React-Props**.

üîó Quellen:

* [TypeScript Handbook ‚Äì Discriminated Unions](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#discriminated-unions)
* [React TS Cheatsheet ‚Äì Discriminated Unions](https://react-typescript-cheatsheet.netlify.app/docs/advanced/discriminated_unions/)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

27. ### <a name="27"></a> Was ist der Unterschied zwischen interface und abstract class?

### Unterschied zwischen `interface` und `abstract class` in TypeScript

#### **1. Interface**

* Beschreibt **nur die Struktur** (Vertrag), aber keine Implementierung.
* Enth√§lt **keinen Code**, nur Signaturen (Properties, Methoden).
* Eine Klasse kann mehrere Interfaces implementieren.

```js
interface Flyable {
  fly(): void
}

class Bird implements Flyable {
  fly() {
    console.log("Der Vogel fliegt üïäÔ∏è")
  }
}
```

---

#### **2. Abstract Class**

* Kann sowohl **abstrakte Methoden** (ohne Implementierung) als auch **konkrete Methoden** (mit Code) enthalten.
* Kann **Felder** und **Konstruktoren** haben.
* Klassen k√∂nnen nur **eine abstrakte Klasse** erweitern (Einzelvererbung).

```js
abstract class Animal {
  constructor(public name: string) {}

  abstract makeSound(): void // muss implementiert werden

  move(): void {
    console.log(`${this.name} bewegt sich`)
  }
}

class Dog extends Animal {
  makeSound() {
    console.log("Wuff!")
  }
}

const rex = new Dog("Rex")
rex.makeSound() // Wuff!
rex.move()      // Rex bewegt sich
```

---

### **3. Vergleichstabelle**

| Aspekt                 | `interface`                     | `abstract class`                           |
| ---------------------- | ------------------------------- | ------------------------------------------ |
| **Implementierung**    | Keine, nur Vertrag              | Kann Code enthalten                        |
| **Konstruktor**        | ‚ùå Nein                          | ‚úÖ Ja                                       |
| **Felder mit Werten**  | ‚ùå Nein                          | ‚úÖ Ja                                       |
| **Abstrakte Methoden** | ‚úÖ Nur Signaturen                | ‚úÖ Ja                                       |
| **Normale Methoden**   | ‚ùå Nein                          | ‚úÖ Ja                                       |
| **Mehrfachverwendung** | ‚úÖ Mehrere Interfaces pro Klasse | ‚ùå Nur eine abstrakte Klasse pro Klasse     |
| **Verwendung**         | F√ºr reine Strukturdefinition    | F√ºr Basisklassen mit gemeinsamem Verhalten |

---

### **Wann verwenden?**

* **Interface** ‚Üí wenn du nur einen Vertrag beschreiben willst (z. B. Props, Data Models, API-Schemas).
* **Abstract Class** ‚Üí wenn du **gemeinsames Verhalten + Vertrag** f√ºr Subklassen definieren willst.

---

### Zusammenfassung

* **`interface`** = reine Struktur, keine Implementierung, unterst√ºtzt Mehrfach-Implementierung.
* **`abstract class`** = Kombination aus Vertrag und (teilweiser) Implementierung, mit Konstruktor und Feldern.

üîó Quellen:

* [TypeScript Handbook ‚Äì Interfaces](https://www.typescriptlang.org/docs/handbook/2/objects.html)
* [TypeScript Handbook ‚Äì Classes](https://www.typescriptlang.org/docs/handbook/2/classes.html#abstract-classes)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

28. ### <a name="28"></a> Wie implementiert man Funktions√ºberladungen (function overloads) in TypeScript?

### Funktions√ºberladungen (Function Overloads) in TypeScript

**Definition:**
Mit **Function Overloads** kann eine Funktion **mehrere Signaturen** haben, aber nur **eine Implementierung**.
Dadurch k√∂nnen unterschiedliche Argumenttypen oder R√ºckgabewerte abgebildet werden.

---

### Syntax

1. **Mehrere Signaturen (Overloads)**
2. **Eine gemeinsame Implementierung**

---

### Beispiel 1 ‚Äì String vs. Number Eingabe

```js
// Overload-Signaturen
function reverse(value: string): string
function reverse(value: number): number

// Implementierung
function reverse(value: string | number): string | number {
  if (typeof value === "string") {
    return value.split("").reverse().join("")
  } else {
    return Number(value.toString().split("").reverse().join(""))
  }
}

console.log(reverse("Sergii")) // iigreS
console.log(reverse(12345))    // 54321
```

‚û°Ô∏è Der Aufrufer sieht die √úberladungen (`string ‚Üí string`, `number ‚Üí number`),
aber die Implementierung deckt beide F√§lle ab.

---

### Beispiel 2 ‚Äì Mehrere Argumenttypen

```js
function getLength(value: string): number
function getLength(value: any[]): number

function getLength(value: string | any[]): number {
  return value.length
}

console.log(getLength("Hallo"))   // 5
console.log(getLength([1, 2, 3])) // 3
```

---

### Beispiel 3 ‚Äì Optional und Union

```js
function combine(a: number, b: number): number
function combine(a: string, b: string): string

function combine(a: number | string, b: number | string): number | string {
  if (typeof a === "string" && typeof b === "string") {
    return a + b
  }
  if (typeof a === "number" && typeof b === "number") {
    return a + b
  }
  throw new Error("Ung√ºltige Argumente")
}

console.log(combine(5, 10))      // 15
console.log(combine("Hi ", "TS")) // Hi TS
```

---

### Zusammenfassung

* **Function Overloads** = mehrere Signaturen, eine Implementierung.
* Vorteil: bessere Typ-Sicherheit und IntelliSense.
* Syntax: **Signaturen oben**, **Implementierung unten**.

üîó Quellen:

* [TypeScript Handbook ‚Äì Functions (Overloads)](https://www.typescriptlang.org/docs/handbook/2/functions.html#function-overloads)
* [MDN ‚Äì Funktionen in JS (Grundlage)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Functions)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

29. ### <a name="29"></a> Was sind Index Signatures?

### Index Signatures in TypeScript

**Definition:**
Eine **Index Signature** erlaubt es, die Typen von Objekten zu beschreiben, deren Schl√ºssel **nicht im Voraus bekannt** sind.
Damit sagt man: *‚ÄûDieses Objekt kann beliebig viele Properties haben, und ihre Schl√ºssel/Werte haben einen bestimmten Typ.‚Äú*

---

### Beispiel 1 ‚Äì Einfache Index Signature

```js
interface StringArray {
  [index: number]: string
}

const names: StringArray = ["Anna", "Tom", "Sergii"]
console.log(names[0]) // Anna
```

‚û°Ô∏è Jeder numerische Index (`number`) muss einen `string` liefern.

---

### Beispiel 2 ‚Äì String-Keys

```js
interface Dictionary {
  [key: string]: string
}

const translations: Dictionary = {
  hello: "Hallo",
  bye: "Tsch√ºss"
}

console.log(translations["hello"]) // Hallo
```

---

### Beispiel 3 ‚Äì Mischung mit festen Properties

```js
interface User {
  id: number
  name: string
  [key: string]: string | number // erlaubt zus√§tzliche Properties
}

const u: User = {
  id: 1,
  name: "Sergii",
  role: "Admin"
}
```

---

### Beispiel 4 ‚Äì Readonly Index Signature

```js
interface ReadonlyArrayLike {
  readonly [index: number]: string
}

const arr: ReadonlyArrayLike = ["A", "B"]
// arr[0] = "X" // ‚ùå Fehler: readonly
```

---

### Einschr√§nkungen

* Der Werttyp der Index Signature muss **alle festen Properties** abdecken.

  ```js
  interface Bad {
    name: string
    [key: string]: number // ‚ùå Fehler, da name: string nicht kompatibel
  }
  ```

---

### Zusammenfassung

* **Index Signatures** = definieren Typen f√ºr unbekannte Schl√ºssel/Werte.
* Syntax: `[key: string]: WertTyp` oder `[index: number]: WertTyp`.
* Einsatz: Dictionaries, flexible Objekte, Maps.

üîó Quellen:

* [TypeScript Handbook ‚Äì Index Signatures](https://www.typescriptlang.org/docs/handbook/2/objects.html#index-signatures)
* [React TS Cheatsheet ‚Äì Index Signatures](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example#index-signatures)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

30. ### <a name="30"></a> Was ist keyof und wof√ºr wird es verwendet?

### `keyof` in TypeScript

**Definition:**
Der **`keyof` Operator** erzeugt einen Typ, der alle **Schl√ºssel** (Property-Namen) eines Objekttyps als **Union Type** enth√§lt.

---

### Beispiel 1 ‚Äì Einfaches Objekt

```js
interface User {
  id: number
  name: string
  isAdmin: boolean
}

type UserKeys = keyof User
// UserKeys = "id" | "name" | "isAdmin"
```

‚û°Ô∏è `keyof` extrahiert `"id" | "name" | "isAdmin"` als Union.

---

### Beispiel 2 ‚Äì Nutzung in Funktionen

```js
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key]
}

const user: User = { id: 1, name: "Sergii", isAdmin: true }

const name = getProperty(user, "name")   // string
const admin = getProperty(user, "isAdmin") // boolean
// getProperty(user, "age") ‚ùå Fehler: "age" existiert nicht in User
```

‚û°Ô∏è Vorteil: **sichere Property-Zugriffe** ohne Magic Strings.

---

### Beispiel 3 ‚Äì Mit `typeof`

```js
const config = {
  url: "/api",
  timeout: 5000
}

type ConfigKeys = keyof typeof config
// "url" | "timeout"
```

---

### Beispiel 4 ‚Äì Kombination mit Mapped Types

```js
type ReadonlyUser = {
  readonly [K in keyof User]: User[K]
}

// Alle Properties von User werden readonly
```

---

### Zusammenfassung

* **`keyof`** = erzeugt Union der Schl√ºssel eines Typs.
* Verwendung: generische Funktionen, sichere Property-Zugriffe, Mapped Types.
* Typische Kombination: `keyof`, `typeof`, `in`.

üîó Quellen:

* [TypeScript Handbook ‚Äì keyof](https://www.typescriptlang.org/docs/handbook/2/keyof-types.html)
* [React TS Cheatsheet ‚Äì keyof usage](https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase#keyof-and-typeof)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

31. ### <a name="31"></a> Wie funktioniert der Operator as?

### Der `as` Operator in TypeScript

**Definition:**
Der **`as` Operator** wird f√ºr **Type Assertions (Typumwandlungen)** verwendet.
Damit sagt man dem Compiler: *‚ÄûVertraue mir, dieser Wert hat einen bestimmten Typ.‚Äú*
Er √§ndert nichts am **Laufzeitwert**, sondern nur an der **Typpr√ºfung** von TypeScript.

---

### Beispiel 1 ‚Äì Einfache Typumwandlung

```js
let value: unknown = "Hallo TypeScript"
let strLength: number = (value as string).length

console.log(strLength) // 16
```

‚û°Ô∏è Der Compiler behandelt `value` innerhalb der Klammern als `string`.

---

### Beispiel 2 ‚Äì DOM-Manipulation

```js
const input = document.querySelector("input") as HTMLInputElement
input.value = "Sergii"
```

‚û°Ô∏è Ohne `as` kennt TypeScript nur den Typ `Element | null`.
Mit `as` wird er auf `HTMLInputElement` eingeschr√§nkt.

---

### Beispiel 3 ‚Äì Union Type Spezifizierung

```js
type Bird = { fly: () => void }
type Fish = { swim: () => void }

let pet: Bird | Fish = { swim: () => console.log("Schwimmt") }

;(pet as Fish).swim() // ‚úÖ erlaubt
```

---

### Beispiel 4 ‚Äì Doppelte Typumwandlung (Edge Case)

```js
let num: number = 10
let str = num as unknown as string // ‚ùå unsicher, aber manchmal genutzt
```

---

### Wichtige Hinweise

* `as` ist **keine Typkonvertierung** wie in anderen Sprachen (z. B. `int ‚Üí string`),
  sondern nur ein Hinweis f√ºr den Compiler.
* Missbrauch kann zu **Laufzeitfehlern** f√ºhren, wenn man falsche Annahmen macht.

---

### Zusammenfassung

* **`as` Operator** = Type Assertion, √§ndert nur den Typ f√ºr den Compiler, nicht den Wert zur Laufzeit.
* Typische Nutzung: DOM-Elemente, Union Types, `unknown` ‚Üí spezifischer Typ.
* Vorsicht: kann Sicherheit unterlaufen, sollte sparsam und bewusst eingesetzt werden.

üîó Quellen:

* [TypeScript Handbook ‚Äì Type Assertions](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-assertions)
* [MDN ‚Äì DOM querySelector](https://developer.mozilla.org/ru/docs/Web/API/Document/querySelector)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

32. ### <a name="32"></a> Was ist der Unterschied zwischen as const und einem normalen const?

### Unterschied zwischen `const` und `as const` in TypeScript

---

#### **1. Normales `const` (JavaScript/TypeScript)**

* Bedeutet, dass die **Variable nicht neu zugewiesen** werden kann.
* Der Wert selbst bleibt aber oft **mutierbar** (bei Objekten/Arrays).
* Typ wird **verallgemeinert** (z. B. `string`, `number`).

```js
const role = "admin"
// Typ: string (kein Literal), Wert: "admin"
```

---

#### **2. `as const` (TypeScript)**

* Erzwingt eine **Literal Inferenz**:

  * Der Wert bekommt den **engsten m√∂glichen Typ** (statt `string` ‚Üí `"admin"`).
* Macht **alle Properties readonly** (bei Objekten und Arrays).

```js
const role = "admin" as const
// Typ: "admin" (Literal), Wert: "admin"
```

---

### Beispiele

#### **Beispiel 1 ‚Äì String vs. Literal**

```js
const status = "success"
// Typ: string

const status2 = "success" as const
// Typ: "success" (Literal)
```

---

#### **Beispiel 2 ‚Äì Objekte**

```js
const user = { id: 1, role: "admin" }
// Typ: { id: number; role: string }

const user2 = { id: 1, role: "admin" } as const
// Typ: { readonly id: 1; readonly role: "admin" }
```

---

#### **Beispiel 3 ‚Äì Arrays**

```js
const numbers = [1, 2, 3]
// Typ: number[]

const numbers2 = [1, 2, 3] as const
// Typ: readonly [1, 2, 3]
```

---

### **Vergleichstabelle**

| Aspekt           | `const`                              | `as const`                              |
| ---------------- | ------------------------------------ | --------------------------------------- |
| Variablenbindung | unver√§nderlich                       | unver√§nderlich                          |
| Typ-Inferenz     | allgemeiner Typ (`string`, `number`) | Literal-Typ (`"admin"`, `1`)            |
| Objekte/Arrays   | ver√§nderbar                          | `readonly`                              |
| Einsatzgebiet    | normales JS-Verhalten                | f√ºr pr√§zise Typisierung & Immutabilit√§t |

---

### Zusammenfassung

* **`const`** = normale Konstantenbindung, Typ wird verallgemeinert.
* **`as const`** = engste m√∂gliche Typen (Literal), zus√§tzlich `readonly`.
* N√ºtzlich f√ºr:

  * **Discriminated Unions**
  * **Objekte/Arrays als feste Konfigurationen**
  * **Props in React**

üîó Quellen:

* [TypeScript Handbook ‚Äì const assertions](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-inference)
* [React TS Cheatsheet ‚Äì as const](https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase#literal-types-as-const)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

33. ### <a name="33"></a> Was macht der Operator satisfies (TS 4.9+)?

### Der `satisfies` Operator in TypeScript (seit 4.9)

**Definition:**
Der Operator **`satisfies`** pr√ºft, ob ein Wert einen bestimmten Typ erf√ºllt (**Type Constraint**), **ohne** den engeren Typ des Werts zu verlieren.
Er ist eine Art *Kompromiss zwischen Type Assertion (`as`) und direkter Typannotation (`: Type`)*.

---

### Beispiel 1 ‚Äì Normale Typannotation

```ts
type Role = "admin" | "user" | "guest"

const role: Role = "admin"
// Typ von role: "admin" | "user" | "guest"
```

üëâ Nach der Annotation verliert `role` den spezifischen Literal-Typ `"admin"` und wird zum Union-Type.

---

### Beispiel 2 ‚Äì Mit `as` (unsafe)

```ts
const role = "admin" as Role
// Typ von role: Role ("admin" | "user" | "guest")
```

üëâ Compiler nimmt an, dass es passt ‚Äì aber kein echter Check, da `as` nur ‚Äûerzwingt‚Äú.

---

### Beispiel 3 ‚Äì Mit `satisfies` ‚úÖ

```ts
type Role = "admin" | "user" | "guest"

const role = "admin" satisfies Role
// Typ von role: "admin" (Literal bleibt erhalten)
// Compiler pr√ºft: "admin" ist Teil von Role ‚Üí ‚úÖ korrekt
```

üëâ Vorteil: Wert bleibt **eng getypt** (`"admin"`) und erf√ºllt trotzdem die Bedingung `Role`.

---

### Beispiel 4 ‚Äì Praktisch bei Objekten

```ts
type Config = {
  url: string
  method: "GET" | "POST"
}

const config = {
  url: "/api",
  method: "GET"
} satisfies Config

// Typ von config.method = "GET" (Literal, nicht nur "GET" | "POST")
```

üëâ Mit `: Config` w√§re `config.method` nur `"GET" | "POST"`.
üëâ Mit `satisfies` bleibt es `"GET"`.

---

### Beispiel 5 ‚Äì Exhaustiveness Checks

```ts
type Status = "success" | "error" | "loading"

const states = ["success", "error", "loading"] satisfies Status[]
// Typ: ("success" | "error" | "loading")[]
// Compiler pr√ºft: alle Elemente geh√∂ren zu Status
```

---

### Zusammenfassung

* **`satisfies`** pr√ºft, ob ein Wert zu einem Typ passt, **ohne den pr√§zisen Typ zu verlieren**.
* Unterschied zu anderen Varianten:

  * `: Type` ‚Üí Typ wird erweitert/verallgemeinert.
  * `as Type` ‚Üí Compiler vertraut blind, keine echte Pr√ºfung.
  * `satisfies Type` ‚Üí Typpr√ºfung + Beibehaltung der Literaltypen.

üîó Quellen:

* [TypeScript 4.9 ‚Äì satisfies Operator](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html#the-satisfies-operator)
* [React TS Cheatsheet ‚Äì satisfies](https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase#satisfies-operator)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

34. ### <a name="34"></a> Was sind Assertion Functions?

### Assertion Functions in TypeScript

**Definition:**
Eine **Assertion Function** ist eine spezielle Funktion, die TypeScript mitteilt:
*"Wenn diese Funktion erfolgreich zur√ºckkehrt, kannst du davon ausgehen, dass eine bestimmte Bedingung erf√ºllt ist."*
‚Üí Sie werden mit dem R√ºckgabetyp `asserts` deklariert und dienen der **Typpr√ºfung** (Type Narrowing).

---

### Beispiel 1 ‚Äì Einfache Assertion Function

```ts
function assertIsString(value: unknown): asserts value is string {
  if (typeof value !== "string") {
    throw new Error("Wert ist kein String")
  }
}

function printUppercase(value: unknown) {
  assertIsString(value) 
  // Ab hier: value hat Typ string
  console.log(value.toUpperCase())
}
```

‚û°Ô∏è Ohne `assertIsString` m√ºsste man jedes Mal manuell pr√ºfen.

---

### Beispiel 2 ‚Äì Non-Null Assertion

```ts
function assertNotNull<T>(value: T): asserts value is NonNullable<T> {
  if (value === null || value === undefined) {
    throw new Error("Wert darf nicht null oder undefined sein")
  }
}

function process(value?: string | null) {
  assertNotNull(value)
  // Ab hier: value ist string
  console.log(value.trim())
}
```

---

### Beispiel 3 ‚Äì F√ºr komplexe Typen

```ts
type User = { id: number; name: string }

function assertIsUser(obj: any): asserts obj is User {
  if (typeof obj !== "object" || typeof obj.id !== "number" || typeof obj.name !== "string") {
    throw new Error("Kein g√ºltiger User")
  }
}

const data: unknown = { id: 1, name: "Sergii" }

assertIsUser(data)
// Ab hier: data hat Typ User
console.log(data.name.toUpperCase())
```

---

### Vorteile

* Verhindern unn√∂tige Type Assertions (`as`).
* Erm√∂glichen **saubere Typ Narrowing**.
* Praktisch f√ºr **Input-Validierung, API-Responses, Guards in React/Express**.

---

### Zusammenfassung

* **Assertion Functions** = Funktionen mit R√ºckgabetyp `asserts`, die Typen validieren.
* Nutzen: automatische Typ-Einschr√§nkung, wenn die Assertion erfolgreich ist.
* Typische Form: `asserts value is Type`.

üîó Quellen:

* [TypeScript Handbook ‚Äì Assertion Functions](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#assertion-functions)
* [React TS Cheatsheet ‚Äì Type Guards & Assertions](https://react-typescript-cheatsheet.netlify.app/docs/basic/troubleshooting/types/#user-defined-type-guards)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

35. ### <a name="35"></a> Was ist der Unterschied zwischen struktureller Typisierung (structural typing) und nominaler Typisierung (nominal typing)?

### Unterschied zwischen **struktureller Typisierung** und **nominaler Typisierung**

---

#### **1. Strukturelle Typisierung (Structural Typing)**

* In **TypeScript** verwendet.
* Zwei Typen sind **kompatibel**, wenn ihre **Struktur** (Shape) gleich ist ‚Äì unabh√§ngig vom Namen.
* ‚ÄûDuck Typing‚Äú: *Wenn es aussieht wie eine Ente und quakt wie eine Ente, ist es eine Ente.*

**Beispiel:**

```ts
interface Point {
  x: number
  y: number
}

interface Coordinate {
  x: number
  y: number
}

let p: Point = { x: 10, y: 20 }
let c: Coordinate = { x: 30, y: 40 }

p = c // ‚úÖ erlaubt, gleiche Struktur
```

---

#### **2. Nominale Typisierung (Nominal Typing)**

* In Sprachen wie **Java, C#** √ºblich.
* Typen sind nur dann kompatibel, wenn sie **explizit denselben Namen** oder dieselbe Vererbung haben.
* Die Struktur allein reicht nicht.

**Beispiel (in TS simuliert):**

```ts
type USD = number & { readonly brand: unique symbol }
type EUR = number & { readonly brand: unique symbol }

let usd: USD = 10 as USD
let eur: EUR = 20 as EUR

usd = eur // ‚ùå Fehler, trotz gleicher Struktur (Nominalisierung durch unique symbol)
```

---

### Vergleich

| Merkmal             | Strukturell (TS)                        | Nominal (Java, C#)      |
| ------------------- | --------------------------------------- | ----------------------- |
| Vergleichsgrundlage | Struktur (Properties & Methoden)        | Name/Erkl√§rung des Typs |
| Flexibilit√§t        | Hoch                                    | Niedrig                 |
| Fehleranf√§lligkeit  | Kann ungewollte Kompatibilit√§t zulassen | Strenger, sicherer      |
| Beispielsprachen    | TypeScript, Go                          | Java, C#, Rust          |

---

### Zusammenfassung

* **Structural Typing (TS):** Kompatibilit√§t h√§ngt nur von der **Form** ab.
* **Nominal Typing:** Kompatibilit√§t h√§ngt vom **Namen/Erkl√§rung** ab.
* TypeScript ist **strukturell typisiert**, man kann aber nominale Typisierung mit Tricks (`unique symbol`) erzwingen.

üîó Quellen:

* [TypeScript Handbook ‚Äì Structural Typing](https://www.typescriptlang.org/docs/handbook/type-compatibility.html)
* [MDN ‚Äì TypeScript Type System](https://www.typescriptlang.org/docs/)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

36. ### <a name="36"></a> Was sind Deklarationsdateien (.d.ts)?

### Deklarationsdateien (`.d.ts`) in TypeScript

**Definition:**
Eine **Deklarationsdatei** (`.d.ts`) enth√§lt **nur Typinformationen** (Signaturen, Interfaces, Typen), aber **keinen ausf√ºhrbaren Code**.
Sie dient dazu, JavaScript-Bibliotheken oder bereits kompilierte TypeScript-Module f√ºr den TypeScript-Compiler **typisiert verf√ºgbar** zu machen.

---

### Eigenschaften

* Endung: **`.d.ts`**
* Enth√§lt keine Implementierungen ‚Üí nur Typdefinitionen.
* Wird automatisch von TypeScript verwendet, wenn eine Bibliothek Typen mitliefert.
* H√§ufig im Verzeichnis `@types/` (z. B. aus **DefinitelyTyped**).

---

### Beispiel 1 ‚Äì Eigene Deklarationsdatei

`math.d.ts`:

```ts
declare module "math-lib" {
  export function add(a: number, b: number): number
  export const PI: number
}
```

Nutzung:

```ts
import { add, PI } from "math-lib"

console.log(add(2, 3))  // 5
console.log(PI)         // number
```

---

### Beispiel 2 ‚Äì Globale Deklaration

```ts
// global.d.ts
declare global {
  interface Window {
    myAppVersion: string
  }
}
```

Nutzung:

```ts
console.log(window.myAppVersion)
```

---

### Beispiel 3 ‚Äì Typen f√ºr externe Bibliotheken

Wenn eine JS-Library keine Typen mitliefert:

```bash
npm install @types/lodash --save-dev
```

üëâ Installiert Deklarationsdateien von **DefinitelyTyped**.

---

### Zusammenfassung

* **`.d.ts` Dateien** = Typdefinitionen ohne Implementierung.
* Nutzen: Typpr√ºfung und IntelliSense f√ºr **JS-Bibliotheken** oder eigene APIs.
* Typische Orte:

  * Bibliotheken mitgeliefert (`node_modules/@types/`)
  * Eigene Projekte (`global.d.ts`)

üîó Quellen:

* [TypeScript Handbook ‚Äì Declaration Files](https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html)
* [DefinitelyTyped Repository](https://github.com/DefinitelyTyped/DefinitelyTyped)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

37. ### <a name="37"></a> Wie bindet man eine externe JS-Bibliothek ohne Typen ein?

### Externe JS-Bibliothek **ohne Typen** in TypeScript einbinden

#### 1) Pr√ºfen, ob Typen existieren

```bash
npm i -D @types/<libname>
```

Wenn vorhanden ‚Üí normal importieren. Wenn **nicht** vorhanden, weiter mit 2‚Äì5.

---

#### 2) Schneller Start: eigenes **Shims**-Modul (`global.d.ts` oder `types/<lib>.d.ts`)

```ts
// types/untyped-lib.d.ts
declare module "untyped-lib" {
  // minimaler Start ‚Äì alles als any
  const api: any
  export default api
}
```

Verwendung:

```js
import lib from "untyped-lib"
lib.doSomething() // Typpr√ºfung ausgesetzt (any)
```

---

#### 3) Besser: **gezielte Typen** statt `any`

```ts
// types/untyped-lib.d.ts
declare module "untyped-lib" {
  export interface Options {
    retry?: number
    baseUrl: string
  }
  export function createClient(opts: Options): {
    get(path: string): Promise<string>
    post<T>(path: string, body: T): Promise<void>
  }
}
```

```js
import { createClient } from "untyped-lib"

const client = createClient({ baseUrl: "/api", retry: 2 })
const text = await client.get("/status")
```

---

#### 4) Globales Script (CDN) typisieren

```ts
// global.d.ts
declare global {
  interface Window {
    MyLib: {
      version: string
      init(config: { key: string }): void
    }
  }
}
export {} // macht die Datei zum Modul
```

```js
// nach <script src=".../mylib.js"></script>
window.MyLib.init({ key: "abc" })
```

---

#### 5) √úbergangsweise absichern: `unknown` + Laufzeit-Guards (statt `any`)

```js
import lib from "untyped-lib"

function isClient(x: unknown): x is { get: (p: string) => Promise<string> } {
  return !!x && typeof (x as any).get === "function"
}

const client: unknown = lib.createClient?.({ baseUrl: "/api" })
if (isClient(client)) {
  const s = await client.get("/health")
}
```

---

#### 6) Notfalls (kurzfristig) unterdr√ºcken

```js
// @ts-ignore: untyped third-party export
import lib from "untyped-lib"
```

> Nur punktuell verwenden; besser fr√ºh eigene `.d.ts` anlegen.

---

#### 7) tsconfig-Hinweise

* Eigene Typen einbinden: `"typeRoots": ["./types", "./node_modules/@types"]`
* Keine Fremdtypfehler beim Build: `"skipLibCheck": true` (optional, nicht sicherheitsrelevant)

---

### Zusammenfassung

* Falls keine offiziellen Typen existieren: **eigene `.d.ts`** schreiben.
* Start mit einfachem `declare module`, dann **gezielt typisieren** (Interfaces/Funktionssignaturen).
* F√ºr globale Skripte: **`declare global`**.
* **`unknown` + Type Guards** statt `any` f√ºr mehr Sicherheit.
* `@ts-ignore` nur ausnahmsweise.

üîó Quellen:

* [TypeScript Docs ‚Äì Declaration Files](https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html)
* [TypeScript Docs ‚Äì Modules & `declare module`](https://www.typescriptlang.org/docs/handbook/modules.html)
* [React TypeScript Cheatsheet ‚Äì Working with 3rd-Party Libs](https://react-typescript-cheatsheet.netlify.app/docs/basic/troubleshooting/types/#third-party-libraries)
* [MDN ‚Äì `window`](https://developer.mozilla.org/ru/docs/Web/API/Window)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

38. ### <a name="38"></a> Was sind Ambient Declarations (declare)?

### Ambient Declarations (`declare`) in TypeScript

**Definition:**
Ambient Declarations sind **Typdefinitionen f√ºr bereits existierenden Code** (meist JavaScript), damit der TypeScript-Compiler wei√ü, welche Variablen, Funktionen oder Module es gibt ‚Äì auch wenn sie **nicht in TypeScript implementiert** sind.
üëâ Sie enthalten **nur Typinformationen**, aber keine Implementierungen.

---

### 1. Globale Variablen deklarieren

```ts
// global.d.ts
declare const VERSION: string
```

Nutzung:

```ts
console.log(VERSION) // Compiler wei√ü: VERSION ist string
```

---

### 2. Funktionen deklarieren

```ts
declare function logMessage(message: string): void

logMessage("Hallo") // g√ºltig, auch ohne Implementierung in TS
```

---

### 3. Klassen deklarieren

```ts
declare class Person {
  constructor(name: string)
  greet(): void
}

let p = new Person("Sergii")
p.greet()
```

---

### 4. Module deklarieren

```ts
// math-lib.d.ts
declare module "math-lib" {
  export function add(a: number, b: number): number
}
```

Nutzung:

```ts
import { add } from "math-lib"
console.log(add(2, 3))
```

---

### 5. Namespace / Global erweitern

```ts
declare namespace NodeJS {
  interface ProcessEnv {
    NODE_ENV: "development" | "production"
  }
}
```

---

### Wann verwendet?

‚úÖ Typische Einsatzf√§lle:

* **Externe JS-Bibliotheken ohne Typen** (eigene `.d.ts`).
* **Globale Variablen/Objekte** (z. B. `window`, `process`).
* **Erweiterung von bestehenden Typen** (z. B. Express `Request`).

---

### Zusammenfassung

* **Ambient Declarations (`declare`)** = reine Typinfos ohne Code.
* Nutzen: Beschreiben von vorhandenen Variablen, Funktionen, Klassen oder Modulen.
* Typische Orte: **`.d.ts`-Dateien**, Third-Party-Libs, globale Variablen.

üîó Quellen:

* [TypeScript Handbook ‚Äì Declaration Files](https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html)
* [TypeScript Handbook ‚Äì Ambient Declarations](https://www.typescriptlang.org/docs/handbook/declaration-files/by-example.html)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

39. ### <a name="39"></a> Was ist strict mode in TypeScript?

### Strict Mode in TypeScript

**Definition:**
Der **Strict Mode** ist eine Sammlung von Compiler-Optionen in TypeScript, die die **strengste Typpr√ºfung** aktivieren.
Er wird mit `"strict": true` in der `tsconfig.json` eingeschaltet.

---

### Enthaltene Optionen (ab Werk in `strict` enthalten)

1. **`strictNullChecks`**

   * `null` und `undefined` m√ºssen explizit behandelt werden.

   ```ts
   let name: string = "Sergii"
   name = null // ‚ùå Fehler bei strictNullChecks
   ```

2. **`noImplicitAny`**

   * Variablen oder Parameter ohne Typ d√ºrfen nicht automatisch `any` sein.

   ```ts
   function log(msg) { // ‚ùå Fehler
     console.log(msg)
   }
   ```

3. **`strictBindCallApply`**

   * Typpr√ºfung f√ºr Methoden wie `bind`, `call`, `apply`.

4. **`strictFunctionTypes`**

   * Strengere √úberpr√ºfung bei Funktionszuweisungen.

5. **`strictPropertyInitialization`**

   * Klassen-Eigenschaften m√ºssen im Konstruktor oder direkt initialisiert werden.

   ```ts
   class User {
     name: string // ‚ùå Fehler ohne Initialisierung
     constructor(name: string) {
       this.name = name // ‚úÖ
     }
   }
   ```

6. **`alwaysStrict`**

   * Alle Dateien werden im **JavaScript Strict Mode** kompiliert (`"use strict"`).

---

### Vorteile

* Weniger Laufzeitfehler durch strengere Typpr√ºfung.
* Sicherere und besser wartbare Codebasis.
* Erh√∂ht Codequalit√§t besonders in gro√üen Projekten.

---

### Zusammenfassung

* **Strict Mode** (`"strict": true`) = aktiviert alle wichtigen Sicherheitspr√ºfungen des Compilers.
* Beinhaltet u. a. `strictNullChecks`, `noImplicitAny`, `strictPropertyInitialization`.
* Ziel: maximale Typ-Sicherheit und Fehlervermeidung.

üîó Quellen:

* [TypeScript Handbook ‚Äì Strict Mode](https://www.typescriptlang.org/tsconfig#strict)
* [TSConfig Reference ‚Äì Strict Options](https://www.typescriptlang.org/tsconfig#strictNullChecks)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

40. ### <a name="40"></a> Wozu dient strictNullChecks?

### `strictNullChecks` in TypeScript

**Definition:**
Die Option **`strictNullChecks`** erzwingt, dass `null` und `undefined` **nicht automatisch jedem Typ zugewiesen** werden d√ºrfen.
üëâ Ohne diese Option: `null` und `undefined` sind **Teil aller Typen**.
üëâ Mit dieser Option: sie m√ºssen **explizit** erlaubt werden (`| null`, `| undefined`).

---

### Beispiel 1 ‚Äì Ohne `strictNullChecks` (unsicher)

```ts
let name: string = "Sergii"
name = null       // ‚úÖ erlaubt (unsicher)
```

---

### Beispiel 2 ‚Äì Mit `strictNullChecks: true` (sicher)

```ts
let name: string = "Sergii"
name = null       // ‚ùå Fehler: null nicht zuweisbar zu string

let safeName: string | null = "Sergii"
safeName = null   // ‚úÖ erlaubt
```

---

### Beispiel 3 ‚Äì Funktionen

```ts
function greet(user: string | null) {
  if (user !== null) {
    console.log("Hallo", user.toUpperCase())
  }
}

greet(null) // ‚úÖ funktioniert, sicher gepr√ºft
```

---

### Beispiel 4 ‚Äì Optional Properties

```ts
interface User {
  id: number
  email?: string
}

function printEmail(user: User) {
  // user.email: string | undefined
  if (user.email) {
    console.log(user.email.toUpperCase())
  }
}
```

---

### Zusammenfassung

* **`strictNullChecks`** verhindert, dass `null` und `undefined` stillschweigend √ºberall zugewiesen werden k√∂nnen.
* Erzwingt **explizite Behandlung** von `null` und `undefined`.
* Vorteil: weniger `Cannot read property of undefined`-Fehler zur Laufzeit.

üîó Quellen:

* [TypeScript Handbook ‚Äì strictNullChecks](https://www.typescriptlang.org/tsconfig#strictNullChecks)
* [Everyday Types ‚Äì null & undefined](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#null-and-undefined)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

41. ### <a name="41"></a> Wie typisiert man Parameter und R√ºckgabewerte von Funktionen?

### Funktionen typisieren: Parameter & R√ºckgabewerte

#### 1) Basis: Parameter- und R√ºckgabetyp

```js
// ESM-Export
export function add(a: number, b: number): number {
  return a + b
}
```

#### 2) Arrow Functions

```js
export const toUpper = (s: string): string => s.toUpperCase()
```

#### 3) Optional-, Default- und Rest-Parameter

```js
export function greet(name: string, title?: string): string {
  return title ? `${title} ${name}` : `Hallo ${name}`
}

export function pow(base: number, exp: number = 2): number {
  return base ** exp
}

export function sum(...nums: number[]): number {
  return nums.reduce((acc, n) => acc + n, 0)
}
```

#### 4) Void, Never, Union/Unknown in Signaturen

```js
export function log(msg: string): void {
  console.log(msg) // kein R√ºckgabewert
}

export function fail(message: string): never {
  throw new Error(message) // kehrt nie zur√ºck
}

export function parseJson(json: string): unknown {
  return JSON.parse(json) // Callsite muss narrowen
}
```

#### 5) Funktions-Typen (Alias/Interface)

```js
export type Comparator<T> = (a: T, b: T) => number

export interface Fetcher {
  (url: string): Promise<string>
}

export const byLength: Comparator<string> = (a, b) => a.length - b.length
```

#### 6) Generische Funktionen

```js
export function identity<T>(value: T): T {
  return value
}

export function pick<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key]
}
```

#### 7) Async/Promise-R√ºckgaben

```js
export async function getText(url: string): Promise<string> {
  const res = await fetch(url)
  return res.text()
}
```

#### 8) Overloads (mehrere Signaturen, eine Implementierung)

```js
export function len(x: string): number
export function len<T>(x: T[]): number
export function len(x: string | unknown[]): number {
  return (x as any).length
}
```

#### 9) Kontext: React-Event-Handler (h√§ufig im Frontend)

```js
// Beispiel: React + TS (ESM)
import type { ChangeEvent } from "react"

export const onChange = (e: ChangeEvent<HTMLInputElement>): void => {
  console.log(e.currentTarget.value)
}
```

---

### Zusammenfassung

* Parameter werden nach dem Namen, R√ºckgabewerte nach dem Parameterblock typisiert: `fn(a: A, b: B): R`.
* Verwende optionale (`?`), Default- und Rest-Parameter je nach Bedarf.
* Nutze `void`/`never` zielgerichtet; f√ºr unbekannte R√ºckgaben `unknown` + Narrowing.
* Funktions-Typen per **Type Alias** oder **Call-Signature in Interfaces**; Generics f√ºr Wiederverwendbarkeit.
* Overloads: mehrere Signaturen, **eine** Implementierung.
* In React Events streng typisieren (z. B. `ChangeEvent<HTMLInputElement>`).

**Quellen:**

* [TypeScript Docs ‚Äì Functions](https://www.typescriptlang.org/docs/handbook/2/functions.html)
* [TypeScript Docs ‚Äì Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
* [React TypeScript Cheatsheet ‚Äì Event Handling](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/event_handling/)
* [MDN ‚Äì Functions (JS-Grundlagen)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Functions)
* [React Docs](https://react.dev/)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

42. ### <a name="42"></a> Was sind optionale Parameter in Funktionen?

### Optionale Parameter in TypeScript-Funktionen

**Definition:**
Ein **optionaler Parameter** ist ein Funktionsparameter, der beim Aufruf **nicht zwingend angegeben** werden muss.
Man kennzeichnet ihn mit einem **Fragezeichen (`?`)** nach dem Parameternamen.

---

### Beispiel 1 ‚Äì Einfacher optionaler Parameter

```ts
export function greet(name: string, title?: string): string {
  return title ? `${title} ${name}` : `Hallo ${name}`
}

greet("Sergii")            // Hallo Sergii
greet("Sergii", "Herr")    // Herr Sergii
```

‚û°Ô∏è `title` ist optional (`string | undefined`).

---

### Beispiel 2 ‚Äì Kombination mit Default-Werten

```ts
export function pow(base: number, exp: number = 2): number {
  return base ** exp
}

pow(3)      // 9
pow(3, 3)   // 27
```

‚û°Ô∏è Unterschied: `?` ‚Üí kann fehlen, `= Default` ‚Üí hat immer einen Wert.

---

### Beispiel 3 ‚Äì Mehrere optionale Parameter

```ts
export function createUser(id: number, name?: string, age?: number) {
  return { id, name, age }
}

createUser(1)                // { id: 1 }
createUser(2, "Anna")        // { id: 2, name: "Anna" }
createUser(3, "Tom", 25)     // { id: 3, name: "Tom", age: 25 }
```

---

### Einschr√§nkungen

* Optionale Parameter m√ºssen **am Ende der Parameterliste** stehen.
* Sie sind implizit `Typ | undefined`.

---

### Zusammenfassung

* **Optionale Parameter** (`param?: Type`) = Argumente, die beim Funktionsaufruf nicht zwingend √ºbergeben werden m√ºssen.
* Standardm√§√üig sind sie `Type | undefined`.
* Typischer Einsatz: flexible APIs, optionale Konfigurationen.

üîó Quellen:

* [TypeScript Handbook ‚Äì Functions](https://www.typescriptlang.org/docs/handbook/2/functions.html#optional-parameters)
* [MDN ‚Äì Functions](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Functions)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

43. ### <a name="43"></a> Wie deklariert man Standardwerte f√ºr Parameter mit Typisierung?

### Standardwerte (Default Parameter) mit Typisierung in TypeScript

**Definition:**
Ein **Default-Parameter** ist ein Funktionsparameter, der einen **Standardwert** erh√§lt, falls kein Argument √ºbergeben wird.
In TypeScript wird der Typ entweder automatisch aus dem Standardwert **inferred** oder explizit angegeben.

---

### Beispiel 1 ‚Äì Automatische Typinferenz

```ts
export function greet(name: string, title = "Herr"): string {
  return `${title} ${name}`
}

greet("Sergii")          // Herr Sergii
greet("Sergii", "Dr.")   // Dr. Sergii
```

‚û°Ô∏è `title` wird automatisch als `string` typisiert, weil der Standardwert `"Herr"` ist.

---

### Beispiel 2 ‚Äì Explizite Typannotation

```ts
export function pow(base: number, exp: number = 2): number {
  return base ** exp
}

pow(3)    // 9
pow(3, 3) // 27
```

‚û°Ô∏è `exp: number = 2` ‚Üí expliziter Typ + Default-Wert.

---

### Beispiel 3 ‚Äì Union-Typ mit Default

```ts
type Role = "admin" | "user" | "guest"

export function createUser(name: string, role: Role = "user") {
  return { name, role }
}

createUser("Sergii")          // role = "user"
createUser("Anna", "admin")   // role = "admin"
```

---

### Beispiel 4 ‚Äì Kombination mit Optionalem Parameter (selten n√∂tig)

```ts
export function log(msg?: string, level: "info" | "error" = "info") {
  console.log(`[${level}]`, msg ?? "leer")
}
```

---

### Regeln

* Parameter mit Default-Werten sind **implizit optional**.
* Sie m√ºssen nicht am Ende der Parameterliste stehen (anders als `?`).
* Typ wird **vom Wert oder Annotation** bestimmt.

---

### Zusammenfassung

* Default-Parameter = `param: Typ = Wert`.
* Typ wird entweder **inferred** oder **explizit angegeben**.
* Vorteil: klare Signaturen, weniger `undefined`.

üîó Quellen:

* [TypeScript Handbook ‚Äì Functions](https://www.typescriptlang.org/docs/handbook/2/functions.html#optional-parameters)
* [MDN ‚Äì Default Parameters](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Default_parameters)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

44. ### <a name="44"></a> Was sind Rest-Parameter und wie typisiert man sie?

### Rest-Parameter in TypeScript

**Definition:**
Rest-Parameter (`...`) erlauben es, **eine variable Anzahl von Argumenten** an eine Funktion zu √ºbergeben.
Sie werden in TypeScript als **Array eines Typs** typisiert.

---

### Beispiel 1 ‚Äì Einfache Typisierung

```ts
export function sum(...numbers: number[]): number {
  return numbers.reduce((acc, n) => acc + n, 0)
}

sum(1, 2, 3, 4) // 10
```

‚û°Ô∏è `numbers: number[]` ‚Üí alle Argumente m√ºssen `number` sein.

---

### Beispiel 2 ‚Äì Strings

```ts
export function concat(...parts: string[]): string {
  return parts.join(" ")
}

concat("TypeScript", "macht", "Spa√ü")
```

---

### Beispiel 3 ‚Äì Kombination mit festen Parametern

```ts
export function greet(greeting: string, ...names: string[]): string {
  return `${greeting}, ${names.join(" und ")}!`
}

greet("Hallo", "Sergii", "Anna") // Hallo, Sergii und Anna!
```

---

### Beispiel 4 ‚Äì Generics f√ºr Rest-Parameter

```ts
export function first<T>(...items: T[]): T {
  return items[0]
}

const num = first(1, 2, 3)         // number
const str = first("a", "b", "c")   // string
```

---

### Beispiel 5 ‚Äì Tupel als Rest-Parameter (variadische Tupel, TS 4.0+)

```ts
type Point = [number, number]

export function logCoordinates(...coords: Point) {
  const [x, y] = coords
  console.log(`X=${x}, Y=${y}`)
}

logCoordinates(10, 20)
```

‚û°Ô∏è Rest-Parameter k√∂nnen auch **feste Strukturen** (Tupel) erzwingen.

---

### Zusammenfassung

* **Rest-Parameter** = `...args: Typ[]`.
* Erfassen variable Argumentlisten als Array.
* Erweiterbar mit **Generics** und **Tupeln** (seit TS 4.0).
* Typische Nutzung: Utility-Funktionen, Logging, flexible APIs.

üîó Quellen:

* [TypeScript Handbook ‚Äì Functions (Rest Parameters)](https://www.typescriptlang.org/docs/handbook/2/functions.html#rest-parameters-and-arguments)
* [MDN ‚Äì Rest Parameters](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/rest_parameters)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

45. ### <a name="45"></a> Wie typisiert man Arrow Functions?

### Arrow Functions in TypeScript typisieren

Arrow Functions werden in TypeScript genauso typisiert wie normale Funktionen ‚Äì nur mit der **Lambda-Syntax**.

---

### 1. Parameter- und R√ºckgabetyp explizit

```ts
export const add = (a: number, b: number): number => {
  return a + b
}
```

---

### 2. Typinferenz (Compiler erkennt den R√ºckgabewert selbst)

```ts
export const double = (x: number) => x * 2
// R√ºckgabewert: number (inferred)
```

---

### 3. Funktions-Typ mit Type Alias

```ts
type Comparator = (a: number, b: number) => number

export const compare: Comparator = (a, b) => a - b
```

---

### 4. Funktions-Typ mit Interface

```ts
interface Logger {
  (msg: string): void
}

export const log: Logger = (message) => console.log(message)
```

---

### 5. Arrow Function mit Generics

```ts
export const identity = <T>(value: T): T => value

const s = identity("Sergii") // string
const n = identity(42)       // number
```

---

### 6. React-Event-Handler (sehr h√§ufig)

```ts
import type { ChangeEvent } from "react"

export const handleChange = (e: ChangeEvent<HTMLInputElement>): void => {
  console.log(e.currentTarget.value)
}
```

---

### Zusammenfassung

* Arrow Functions typisiert man mit `(param: Typ): R√ºckgabeTyp => {}`.
* R√ºckgabetyp kann oft **inferred** werden.
* F√ºr Wiederverwendbarkeit: **Type Alias** oder **Interface** f√ºr Funktionssignaturen.
* Generics erm√∂glichen flexible Arrow Functions.
* In React wichtig: Eventtypen (`ChangeEvent<HTMLInputElement>` usw.).

üîó Quellen:

* [TypeScript Handbook ‚Äì Functions](https://www.typescriptlang.org/docs/handbook/2/functions.html)
* [React TypeScript Cheatsheet ‚Äì Event Handling](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/event_handling/)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

46. ### <a name="46"></a> Was sind Funktions√ºberladungen?

### Funktions√ºberladungen (Function Overloads) in TypeScript

**Definition:**
Funktions√ºberladungen erlauben es, f√ºr **eine Funktion mehrere Signaturen** zu definieren.
Der Aufrufer sieht unterschiedliche Signaturen, aber die **Implementierung existiert nur einmal**.
‚Üí Damit kann eine Funktion verschiedene **Argumenttypen** und **R√ºckgabewerte** unterst√ºtzen.

---

### Beispiel 1 ‚Äì String vs. Number

```ts
// √úberladungen (Signaturen)
function reverse(value: string): string
function reverse(value: number): number

// Implementierung (gemeinsam)
function reverse(value: string | number): string | number {
  if (typeof value === "string") {
    return value.split("").reverse().join("")
  }
  return Number(value.toString().split("").reverse().join(""))
}

reverse("Sergii") // string ‚Üí "iigreS"
reverse(12345)    // number ‚Üí 54321
```

---

### Beispiel 2 ‚Äì Mehrere Argumenttypen

```ts
function getLength(value: string): number
function getLength(value: any[]): number

function getLength(value: string | any[]): number {
  return value.length
}

getLength("Hallo")   // 5
getLength([1, 2, 3]) // 3
```

---

### Beispiel 3 ‚Äì Unterschiedliche R√ºckgabewerte

```ts
function combine(a: number, b: number): number
function combine(a: string, b: string): string

function combine(a: number | string, b: number | string): number | string {
  if (typeof a === "string" && typeof b === "string") {
    return a + b // string
  }
  if (typeof a === "number" && typeof b === "number") {
    return a + b // number
  }
  throw new Error("Ung√ºltige Argumente")
}
```

---

### Regeln f√ºr Overloads

* **Signaturen oben**, **Implementierung unten**.
* Implementierung muss alle F√§lle abdecken.
* TypeScript w√§hlt anhand der Argumente die passende Signatur.

---

### Zusammenfassung

* **Funktions√ºberladungen** = mehrere Signaturen f√ºr eine Funktion.
* N√ºtzlich f√ºr Funktionen, die mit verschiedenen Eingabetypen arbeiten.
* Syntax: `function name(param: Typ): R√ºckgabeTyp` (mehrfach), dann eine gemeinsame Implementierung.

üîó Quellen:

* [TypeScript Handbook ‚Äì Function Overloads](https://www.typescriptlang.org/docs/handbook/2/functions.html#function-overloads)
* [React TS Cheatsheet ‚Äì Functions](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example#function-overloads)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

47. ### <a name="47"></a> Was sind Generics?

### Generics in TypeScript

**Definition:**
**Generics** sind Platzhalter f√ºr Typen, die es erm√∂glichen, **flexiblen, wiederverwendbaren und typsicheren Code** zu schreiben.
Man definiert einen Typ erst **zur Nutzung**, nicht beim Schreiben der Funktion oder Klasse.

---

### Beispiel 1 ‚Äì Generische Funktion

```ts
function identity<T>(value: T): T {
  return value
}

const num = identity(42)         // T = number
const str = identity("Sergii")   // T = string
```

üëâ Der Typ `T` wird automatisch **inferred**.

---

### Beispiel 2 ‚Äì Generisches Array

```ts
function getFirst<T>(arr: T[]): T {
  return arr[0]
}

getFirst([1, 2, 3])      // number
getFirst(["a", "b", "c"]) // string
```

---

### Beispiel 3 ‚Äì Generics mit Einschr√§nkungen (`extends`)

```ts
interface HasLength {
  length: number
}

function logLength<T extends HasLength>(item: T): void {
  console.log(item.length)
}

logLength("Hallo")       // string (hat length)
logLength([1, 2, 3])     // Array (hat length)
```

---

### Beispiel 4 ‚Äì Mehrere Typ-Parameter

```ts
function pair<K, V>(key: K, value: V): [K, V] {
  return [key, value]
}

const entry = pair("id", 123) // [string, number]
```

---

### Beispiel 5 ‚Äì Generics in Klassen

```ts
class Box<T> {
  content: T
  constructor(value: T) {
    this.content = value
  }
}

const stringBox = new Box("Text") // T = string
const numBox = new Box(99)        // T = number
```

---

### Beispiel 6 ‚Äì Generics in React (h√§ufig)

```tsx
import { useState } from "react"

const [count, setCount] = useState<number>(0)
```

üëâ `useState<number>` ist ein generischer Hook.

---

### Zusammenfassung

* **Generics** = Typparameter (`<T>`) f√ºr wiederverwendbaren, typsicheren Code.
* Vorteile: Flexibilit√§t + Typpr√ºfung gleichzeitig.
* Einsatz: Funktionen, Klassen, Interfaces, React-Hooks.

üîó Quellen:

* [TypeScript Handbook ‚Äì Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
* [React TypeScript Cheatsheet ‚Äì Generics](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/hooks/#generic-hooks)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

48. ### <a name="48"></a> Wie erstellt man eine generische Funktion?

### Generische Funktion in TypeScript erstellen

**Definition:**
Eine **generische Funktion** nutzt Typparameter (`<T>`), um flexibel mit unterschiedlichen Typen zu arbeiten, ohne die Typ-Sicherheit zu verlieren.

---

### 1. Syntax ‚Äì einfaches Beispiel

```ts
export function identity<T>(value: T): T {
  return value
}

const num = identity(42)        // T = number
const str = identity("Sergii")  // T = string
```

üëâ `T` ist ein Platzhalter, der beim Aufruf ersetzt wird.

---

### 2. Mit Arrays

```ts
export function firstElement<T>(arr: T[]): T {
  return arr[0]
}

const n = firstElement([1, 2, 3])     // number
const s = firstElement(["a", "b", "c"]) // string
```

---

### 3. Mehrere Typparameter

```ts
export function pair<K, V>(key: K, value: V): [K, V] {
  return [key, value]
}

const entry = pair("id", 123) // [string, number]
```

---

### 4. Einschr√§nkungen mit `extends`

```ts
interface HasLength {
  length: number
}

export function logLength<T extends HasLength>(item: T): void {
  console.log(item.length)
}

logLength("Hallo")   // string ‚úÖ
logLength([1, 2, 3]) // number[] ‚úÖ
```

---

### 5. Default-Typen

```ts
export function toArray<T = string>(value: T): T[] {
  return [value]
}

const a = toArray("hi")   // string[]
const b = toArray(42)     // number[]
const c = toArray()       // string[] (Default)
```

---

### Zusammenfassung

* Generische Funktionen nutzt man mit `<T>` oder mehreren Parametern (`<K, V>`).
* Vorteil: **flexibel + typsicher**.
* Erweiterbar mit `extends` (Constraints) oder Defaults.
* Typische Einsatzgebiete: Utility-Funktionen, Datenstrukturen, React-Hooks.

üîó Quellen:

* [TypeScript Handbook ‚Äì Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
* [React TypeScript Cheatsheet ‚Äì Generics](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/hooks/#generic-hooks)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

49. ### <a name="49"></a> Was sind Generic Constraints (extends)?

### Generic Constraints (`extends`) in TypeScript

**Definition:**
Mit **Generic Constraints** (`extends`) kann man den **G√ºltigkeitsbereich** eines Generics einschr√§nken.
üëâ Ohne Constraint: `T` kann *alles* sein.
üëâ Mit Constraint: `T` muss bestimmte Eigenschaften haben oder von einem Typ erben.

---

### 1. Einfaches Constraint

```ts
function logLength<T extends { length: number }>(item: T): void {
  console.log(item.length)
}

logLength("Hallo")       // string ‚úÖ
logLength([1, 2, 3])     // number[] ‚úÖ
// logLength(123)        // ‚ùå Fehler: number hat kein length
```

‚û°Ô∏è `T` muss ein Objekt mit `length: number` sein.

---

### 2. Constraint auf Interface

```ts
interface User {
  id: number
  name: string
}

function getName<T extends User>(obj: T): string {
  return obj.name
}

getName({ id: 1, name: "Sergii" }) // ‚úÖ
```

‚û°Ô∏è `T` muss mindestens die Struktur von `User` haben.

---

### 3. Constraint auf Union-Typ

```ts
type Role = "admin" | "user" | "guest"

function setRole<T extends Role>(role: T) {
  console.log(`Neue Rolle: ${role}`)
}

setRole("admin") // ‚úÖ
setRole("root")  // ‚ùå Fehler
```

---

### 4. Mehrere Constraints (`extends` + `extends`)

```ts
function merge<T extends object, U extends object>(a: T, b: U): T & U {
  return { ...a, ...b }
}

const obj = merge({ id: 1 }, { role: "admin" })
// Typ: { id: number } & { role: string }
```

---

### 5. Generics mit `keyof` Constraint

```ts
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key]
}

const user = { id: 1, name: "Sergii" }
getProperty(user, "name") // string
// getProperty(user, "age") ‚ùå Fehler
```

‚û°Ô∏è `K` darf nur ein Schl√ºssel von `T` sein.

---

### Zusammenfassung

* **Generic Constraints (`extends`)** = Eingrenzung, welche Typen ein Generic akzeptieren darf.
* Erm√∂glicht: Zugriff auf Eigenschaften, sichere Schl√ºsselpr√ºfung, Wiederverwendbarkeit.
* Typische Muster: `extends {}`, `extends Interface`, `extends keyof T`.

üîó Quellen:

* [TypeScript Handbook ‚Äì Generic Constraints](https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-constraints)
* [React TypeScript Cheatsheet ‚Äì Generics](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/hooks/#generic-hooks)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

50. ### <a name="50"></a> Wie funktioniert T extends keyof U?

### `T extends keyof U` in TypeScript

**Definition:**
`T extends keyof U` bedeutet:
üëâ `T` darf nur Werte annehmen, die **ein Schl√ºssel von `U`** sind.
So lassen sich Generics auf g√ºltige Property-Namen einschr√§nken.

---

### Beispiel 1 ‚Äì Grundprinzip

```ts
interface User {
  id: number
  name: string
  isAdmin: boolean
}

function getProperty<T extends keyof User>(obj: User, key: T): User[T] {
  return obj[key]
}

const u: User = { id: 1, name: "Sergii", isAdmin: true }

getProperty(u, "name")    // ‚úÖ string
getProperty(u, "isAdmin") // ‚úÖ boolean
// getProperty(u, "age")  // ‚ùå Fehler: "age" ist kein Schl√ºssel von User
```

---

### Beispiel 2 ‚Äì Generische Objektfunktion

```ts
function pluck<T, K extends keyof T>(obj: T, keys: K[]): T[K][] {
  return keys.map(key => obj[key])
}

const user = { id: 1, name: "Sergii", active: true }

const values = pluck(user, ["id", "name"])
// Typ: (string | number)[]
```

---

### Beispiel 3 ‚Äì R√ºckgabewerte typisieren

```ts
type Person = { name: string; age: number }

function pickValue<T extends keyof Person>(key: T): Person[T] {
  const dummy: Person = { name: "Anna", age: 25 }
  return dummy[key]
}

const age = pickValue("age")   // number
const name = pickValue("name") // string
```

---

### Beispiel 4 ‚Äì Kombination mit `Record`

```ts
function mapObject<T, K extends keyof T>(obj: T, keys: K[]): Record<K, T[K]> {
  const result = {} as Record<K, T[K]>
  keys.forEach(k => {
    result[k] = obj[k]
  })
  return result
}

const person = { id: 1, name: "Tom", active: true }
const subset = mapObject(person, ["id", "active"])
// Typ: { id: number; active: boolean }
```

---

### Zusammenfassung

* `keyof U` = Union aller Schl√ºssel von `U`.
* `T extends keyof U` = `T` darf nur einer dieser Schl√ºssel sein.
* Einsatz: **Property-Zugriffe, `pluck`/`getProperty`-Utilities, sichere Schl√ºssel-Pr√ºfungen.**

üîó Quellen:

* [TypeScript Handbook ‚Äì keyof and Lookup Types](https://www.typescriptlang.org/docs/handbook/2/keyof-types.html)
* [TypeScript Generics ‚Äì Constraints](https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-constraints)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

51. ### <a name="51"></a> Was sind Utility Types (Partial, Pick, Omit, Record usw.)?

### Utility Types in TypeScript

**Definition:**
Utility Types sind vordefinierte Generics, die bestehende Typen **transformieren oder anpassen**.
Sie sparen Boilerplate und erh√∂hen die Typ-Sicherheit.

---

## üîë Die wichtigsten Utility Types

### 1. **`Partial<T>`**

Macht alle Eigenschaften von `T` optional.

```ts
interface User {
  id: number
  name: string
}

type PartialUser = Partial<User>
// { id?: number; name?: string }
```

---

### 2. **`Required<T>`**

Macht alle Eigenschaften von `T` verpflichtend.

```ts
interface User {
  id?: number
  name?: string
}

type RequiredUser = Required<User>
// { id: number; name: string }
```

---

### 3. **`Readonly<T>`**

Macht alle Eigenschaften von `T` schreibgesch√ºtzt.

```ts
interface User {
  id: number
  name: string
}

type ReadonlyUser = Readonly<User>
// { readonly id: number; readonly name: string }
```

---

### 4. **`Pick<T, K>`**

W√§hlt bestimmte Eigenschaften aus `T`.

```ts
interface User {
  id: number
  name: string
  email: string
}

type UserPreview = Pick<User, "id" | "name">
// { id: number; name: string }
```

---

### 5. **`Omit<T, K>`**

Entfernt bestimmte Eigenschaften aus `T`.

```ts
type UserWithoutEmail = Omit<User, "email">
// { id: number; name: string }
```

---

### 6. **`Record<K, T>`**

Erzeugt ein Objekt mit Schl√ºsseln vom Typ `K` und Werten vom Typ `T`.

```ts
type Role = "admin" | "user" | "guest"

type RolePermissions = Record<Role, boolean>
// { admin: boolean; user: boolean; guest: boolean }
```

---

### 7. **`Exclude<T, U>`**

Entfernt aus `T` alle Typen, die auch in `U` enthalten sind.

```ts
type Status = "success" | "error" | "loading"
type WithoutLoading = Exclude<Status, "loading">
// "success" | "error"
```

---

### 8. **`Extract<T, U>`**

Beinhaltet nur die Typen, die in beiden enthalten sind.

```ts
type A = "a" | "b" | "c"
type B = "b" | "c" | "d"

type Common = Extract<A, B> // "b" | "c"
```

---

### 9. **`NonNullable<T>`**

Entfernt `null` und `undefined`.

```ts
type Value = string | null | undefined
type SafeValue = NonNullable<Value>
// string
```

---

### 10. **`ReturnType<T>`**

Ermittelt den R√ºckgabetyp einer Funktion.

```ts
function getUser() {
  return { id: 1, name: "Sergii" }
}

type User = ReturnType<typeof getUser>
// { id: number; name: string }
```

---

### 11. **`Parameters<T>`**

Ermittelt die Parametertypen einer Funktion als Tupel.

```ts
function login(user: string, password: string) {}

type LoginParams = Parameters<typeof login>
// [user: string, password: string]
```

---

### Zusammenfassung

* **Utility Types** = vordefinierte Generics f√ºr schnelle Typtransformation.
* H√§ufige Kandidaten: `Partial`, `Required`, `Readonly`, `Pick`, `Omit`, `Record`.
* Weitere m√§chtige Tools: `Exclude`, `Extract`, `NonNullable`, `ReturnType`, `Parameters`.
* Typischer Einsatz: **Modelle anpassen, DTOs, React-Props, API-Typisierung.**

üîó Quellen:

* [TypeScript Handbook ‚Äì Utility Types](https://www.typescriptlang.org/docs/handbook/utility-types.html)
* [React TS Cheatsheet ‚Äì Utility Types](https://react-typescript-cheatsheet.netlify.app/docs/advanced/utility_types/)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

52. ### <a name="52"></a> Was ist der Unterschied zwischen Partial<T> und Required<T>?

### Unterschied zwischen `Partial<T>` und `Required<T>` in TypeScript

---

### **1. `Partial<T>`**

* Macht **alle Properties** eines Typs **optional** (`?`).
* Typische Nutzung: bei **Update-Objekten** (z. B. nur einige Felder eines Users √§ndern).

```ts
interface User {
  id: number
  name: string
  email: string
}

type PartialUser = Partial<User>
// { id?: number; name?: string; email?: string }

const updateUser: PartialUser = { name: "Sergii" } // ‚úÖ nur name
```

---

### **2. `Required<T>`**

* Macht **alle Properties** eines Typs **pflichtig** (auch solche, die urspr√ºnglich optional waren).
* Typische Nutzung: wenn du sicherstellen willst, dass **komplette Daten** √ºbergeben werden.

```ts
interface User {
  id?: number
  name?: string
  email?: string
}

type RequiredUser = Required<User>
// { id: number; name: string; email: string }

const fullUser: RequiredUser = {
  id: 1,
  name: "Sergii",
  email: "sergii@mail.com"
} // ‚úÖ alles Pflicht
```

---

### **Vergleichstabelle**

| Utility Type  | Wirkung                              | Beispiel                         |
| ------------- | ------------------------------------ | -------------------------------- |
| `Partial<T>`  | Alle Properties werden **optional**  | `{ id?: number; name?: string }` |
| `Required<T>` | Alle Properties werden **pflichtig** | `{ id: number; name: string }`   |

---

### Zusammenfassung

* **`Partial<T>`** = macht alle Felder **optional** ‚Üí n√ºtzlich f√ºr Updates oder Teilobjekte.
* **`Required<T>`** = macht alle Felder **zwingend** ‚Üí n√ºtzlich f√ºr Validierung oder vollst√§ndige Daten.

üîó Quellen:

* [TypeScript Handbook ‚Äì Utility Types](https://www.typescriptlang.org/docs/handbook/utility-types.html)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

53. ### <a name="53"></a> Wie funktioniert Readonly<T>?

### `Readonly<T>` in TypeScript

**Definition:**
Der Utility Type **`Readonly<T>`** macht **alle Eigenschaften** eines Typs **schreibgesch√ºtzt** (`readonly`).
Das bedeutet: einmal gesetzte Werte k√∂nnen nicht mehr ver√§ndert werden.

---

### Beispiel 1 ‚Äì Einfaches Interface

```ts
interface User {
  id: number
  name: string
}

type ReadonlyUser = Readonly<User>
// { readonly id: number; readonly name: string }

const u: ReadonlyUser = { id: 1, name: "Sergii" }

u.name = "Anna" // ‚ùå Fehler: name ist readonly
```

---

### Beispiel 2 ‚Äì Readonly Arrays

```ts
const numbers: Readonly<number[]> = [1, 2, 3]

numbers.push(4)   // ‚ùå Fehler: push existiert nicht
numbers[0] = 99   // ‚ùå Fehler
```

Alternative:

```ts
const tuple: Readonly<[number, number]> = [10, 20]
```

---

### Beispiel 3 ‚Äì In Kombination mit `Partial`

```ts
interface Config {
  host: string
  port: number
}

type ImmutableConfig = Readonly<Partial<Config>>
// { readonly host?: string; readonly port?: number }
```

---

### Beispiel 4 ‚Äì Praktisch in React (Props)

```tsx
type ButtonProps = Readonly<{
  label: string
  onClick: () => void
}>

// Props sind automatisch readonly ‚Üí Schutz vor √Ñnderungen
const Button = (props: ButtonProps) => {
  // props.label = "Neu" ‚ùå nicht erlaubt
  return <button onClick={props.onClick}>{props.label}</button>
}
```

---

### Zusammenfassung

* **`Readonly<T>`** ‚Üí macht alle Felder **immutable** (nur lesbar).
* N√ºtzlich f√ºr: **Props in React**, Konfigurationen, sichere Datenmodelle.
* Kombination mit anderen Utility Types (`Partial`, `Pick`, etc.) sehr m√§chtig.

üîó Quellen:

* [TypeScript Handbook ‚Äì Readonly](https://www.typescriptlang.org/docs/handbook/utility-types.html#readonlytype)
* [React TS Cheatsheet ‚Äì Props Readonly](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example/#readonly-and-const)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

54. ### <a name="54"></a> Wie funktionieren Pick<T, K> und Omit<T, K>?

### `Pick<T, K>` und `Omit<T, K>` in TypeScript

Beide sind **Utility Types**, die auf bestehenden Typen basieren.
üëâ `Pick` = bestimmte Properties ausw√§hlen
üëâ `Omit` = bestimmte Properties ausschlie√üen

---

### **1. Pick<T, K>**

* Baut aus Typ `T` einen neuen Typ mit **nur den ausgew√§hlten Keys `K`**.

```ts
interface User {
  id: number
  name: string
  email: string
  isAdmin: boolean
}

type UserPreview = Pick<User, "id" | "name">
// { id: number; name: string }

const preview: UserPreview = { id: 1, name: "Sergii" }
```

---

### **2. Omit<T, K>**

* Baut aus Typ `T` einen neuen Typ mit **allen Properties au√üer `K`**.

```ts
type UserWithoutEmail = Omit<User, "email" | "isAdmin">
// { id: number; name: string }

const simpleUser: UserWithoutEmail = { id: 2, name: "Anna" }
```

---

### **3. Vergleich**

```ts
// Pick -> nur bestimmte Eigenschaften
type OnlyName = Pick<User, "name">
// { name: string }

// Omit -> bestimmte Eigenschaften entfernen
type WithoutName = Omit<User, "name">
// { id: number; email: string; isAdmin: boolean }
```

---

### **4. Typische Einsatzgebiete**

* **Pick**: DTOs, kurze Vorschau-Typen (z. B. f√ºr UI).
* **Omit**: Typen f√ºr "Create" oder "Update", wenn bestimmte Felder nicht erlaubt sind.

```ts
// Beispiel: API CreateUser ohne id und isAdmin
type CreateUserDto = Omit<User, "id" | "isAdmin">
```

---

### Zusammenfassung

* **`Pick<T, K>`** ‚Üí erstellt neuen Typ mit **nur K** aus T.
* **`Omit<T, K>`** ‚Üí erstellt neuen Typ mit **allen au√üer K**.
* Sehr n√ºtzlich f√ºr **DTOs, API-Modelle, React-Props**.

üîó Quellen:

* [TypeScript Handbook ‚Äì Utility Types](https://www.typescriptlang.org/docs/handbook/utility-types.html)
* [React TS Cheatsheet ‚Äì Utility Types](https://react-typescript-cheatsheet.netlify.app/docs/advanced/utility_types/)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

55. ### <a name="55"></a> Was macht Record<K, T>?

### `Record<K, T>` in TypeScript

**Definition:**
`Record<K, T>` erstellt einen **Objekttyp**, bei dem:

* alle Schl√ºssel (`K`) denselben Typ haben,
* und die Werte vom Typ `T` sind.

Es ist eine **kurze Schreibweise** f√ºr Objekte mit einheitlichen Keys/Werten.

---

### Beispiel 1 ‚Äì Einfache Verwendung

```ts
type Role = "admin" | "user" | "guest"

type RolePermissions = Record<Role, boolean>
// { admin: boolean; user: boolean; guest: boolean }

const permissions: RolePermissions = {
  admin: true,
  user: false,
  guest: false
}
```

---

### Beispiel 2 ‚Äì Index als Zahl

```ts
type ScoreBoard = Record<number, string>

const scores: ScoreBoard = {
  1: "Anna",
  2: "Sergii"
}
```

---

### Beispiel 3 ‚Äì Mit komplexen Werten

```ts
interface User {
  id: number
  name: string
}

type UserDictionary = Record<string, User>

const users: UserDictionary = {
  a1: { id: 1, name: "Anna" },
  b2: { id: 2, name: "Sergii" }
}
```

---

### Beispiel 4 ‚Äì Kombination mit `keyof`

```ts
interface Config {
  host: string
  port: number
}

type ConfigMap = Record<keyof Config, string>
// { host: string; port: string }
```

---

### Vergleich zu **Index Signatures**

```ts
// Mit Index Signature
type Dict = { [key: string]: number }

// Mit Record
type Dict2 = Record<string, number>
```

üëâ Beide √§hnlich ‚Äì aber `Record` ist **k√ºrzer** und wird oft bevorzugt.

---

### Zusammenfassung

* **`Record<K, T>`** = Objekt mit Schl√ºsseln aus `K` und Werten vom Typ `T`.
* Kurzform f√ºr Dictionaries und Maps.
* Praktisch f√ºr **Mappings, Lookups, Konfigurationen**.

üîó Quellen:

* [TypeScript Handbook ‚Äì Record](https://www.typescriptlang.org/docs/handbook/utility-types.html#recordkeys-type)
* [React TS Cheatsheet ‚Äì Record](https://react-typescript-cheatsheet.netlify.app/docs/advanced/utility_types/)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

56. ### <a name="56"></a> Was macht ReturnType<T>?

### `ReturnType<T>` in TypeScript

**Definition:**
Der Utility Type **`ReturnType<T>`** extrahiert den **R√ºckgabewert-Typ** einer Funktion.
üëâ `T` muss dabei eine **Funktionssignatur** oder der Typ einer Funktion sein.

---

### Beispiel 1 ‚Äì Einfache Funktion

```ts
function getUser() {
  return { id: 1, name: "Sergii" }
}

type User = ReturnType<typeof getUser>
// { id: number; name: string }

const u: User = { id: 2, name: "Anna" }
```

---

### Beispiel 2 ‚Äì Mit Arrow Function

```ts
const add = (a: number, b: number) => a + b

type SumReturn = ReturnType<typeof add>
// number
```

---

### Beispiel 3 ‚Äì Async Funktionen

```ts
async function fetchData() {
  return { ok: true, data: [1, 2, 3] }
}

type FetchResult = ReturnType<typeof fetchData>
// Promise<{ ok: boolean; data: number[] }>
```

---

### Beispiel 4 ‚Äì In Kombination mit `InstanceType`

```ts
class Person {
  constructor(public name: string) {}
}

function createPerson() {
  return new Person("Sergii")
}

type PersonReturn = ReturnType<typeof createPerson>
// Person
```

---

### Typischer Nutzen

* Vermeidung von **doppelter Typdefinition**.
* R√ºckgabewerte **automatisch ableiten**.
* Besonders n√ºtzlich bei **Utility-Funktionen**, **Hooks** in React oder **Factory Functions**.

---

### Zusammenfassung

* **`ReturnType<T>`** = extrahiert den R√ºckgabewert einer Funktion.
* Spart Boilerplate und verhindert Inkonsistenzen.
* Funktioniert mit normalen, Arrow- und async-Funktionen.

üîó Quellen:

* [TypeScript Handbook ‚Äì ReturnType](https://www.typescriptlang.org/docs/handbook/utility-types.html#returntypetype)
* [React TS Cheatsheet ‚Äì Utility Types](https://react-typescript-cheatsheet.netlify.app/docs/advanced/utility_types/)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

57. ### <a name="57"></a> Was macht Parameters<T>?

### `Parameters<T>` in TypeScript

**Definition:**
Der Utility Type **`Parameters<T>`** extrahiert die **Parametertypen** einer Funktion als **Tupel**.
üëâ `T` muss eine Funktion oder Funktionssignatur sein.

---

### Beispiel 1 ‚Äì Normale Funktion

```ts
function login(user: string, password: string) {}

type LoginParams = Parameters<typeof login>
// [user: string, password: string]

const args: LoginParams = ["Sergii", "1234"]
login(...args) // ‚úÖ korrekt
```

---

### Beispiel 2 ‚Äì Arrow Function

```ts
const add = (a: number, b: number) => a + b

type AddParams = Parameters<typeof add>
// [a: number, b: number]
```

---

### Beispiel 3 ‚Äì Optional & Default Parameter

```ts
function greet(name: string, title?: string) {}

type GreetParams = Parameters<typeof greet>
// [name: string, title?: string | undefined]
```

---

### Beispiel 4 ‚Äì Async Funktion

```ts
async function fetchData(url: string, retries: number) {
  return `Fetch: ${url} (${retries})`
}

type FetchParams = Parameters<typeof fetchData>
// [url: string, retries: number]
```

---

### Beispiel 5 ‚Äì Generisch kombinieren

```ts
function callFn<T extends (...args: any[]) => any>(fn: T, ...args: Parameters<T>): ReturnType<T> {
  return fn(...args)
}

function multiply(x: number, y: number) {
  return x * y
}

const result = callFn(multiply, 3, 4) // number
```

---

### Zusammenfassung

* **`Parameters<T>`** = extrahiert Parametertypen als **Tupel**.
* N√ºtzlich f√ºr **Wrapper-Funktionen**, **Middleware**, **Decorator-Pattern**.
* Oft in Kombination mit **`ReturnType<T>`**.

üîó Quellen:

* [TypeScript Handbook ‚Äì Parameters](https://www.typescriptlang.org/docs/handbook/utility-types.html#parameterstype)
* [React TS Cheatsheet ‚Äì Utility Types](https://react-typescript-cheatsheet.netlify.app/docs/advanced/utility_types/)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

58. ### <a name="58"></a> Was macht ConstructorParameters<T>?

### `ConstructorParameters<T>` in TypeScript

**Definition:**
Der Utility Type **`ConstructorParameters<T>`** extrahiert die **Parameter-Typen eines Konstruktors** als **Tupel**.
üëâ `T` muss ein Konstruktor-Typ (z. B. eine Klasse oder `new (...args) => any`) sein.

---

### Beispiel 1 ‚Äì Einfache Klasse

```ts
class User {
  constructor(public id: number, public name: string) {}
}

type UserArgs = ConstructorParameters<typeof User>
// [id: number, name: string]

const args: UserArgs = [1, "Sergii"]
const u = new User(...args) // ‚úÖ
```

---

### Beispiel 2 ‚Äì Mit optionalen Parametern

```ts
class Book {
  constructor(public title: string, public pages?: number) {}
}

type BookArgs = ConstructorParameters<typeof Book>
// [title: string, pages?: number | undefined]

const args: BookArgs = ["TS Handbook"]
const b = new Book(...args)
```

---

### Beispiel 3 ‚Äì Factory Function mit ConstructorParameters

```ts
function createInstance<T extends new (...args: any) => any>(
  Ctor: T,
  ...args: ConstructorParameters<T>
): InstanceType<T> {
  return new Ctor(...args)
}

class Car {
  constructor(public brand: string, public year: number) {}
}

const myCar = createInstance(Car, "BMW", 2025) // Car
```

---

### Beispiel 4 ‚Äì Mit eingebauten Klassen

```ts
type DateArgs = ConstructorParameters<typeof Date>
// [value?: string | number | Date]

const d = new Date(...(["2025-01-01"] as DateArgs))
```

---

### Zusammenfassung

* **`ConstructorParameters<T>`** = extrahiert **Konstruktor-Argumente** als Tupel.
* Einsatz: Factories, Wrapper, Dependency Injection.
* N√ºtzlich in Kombination mit **`InstanceType<T>`**.

üîó Quellen:

* [TypeScript Handbook ‚Äì ConstructorParameters](https://www.typescriptlang.org/docs/handbook/utility-types.html#constructorparameterstype)
* [TypeScript Handbook ‚Äì InstanceType](https://www.typescriptlang.org/docs/handbook/utility-types.html#instancetypetype)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

59. ### <a name="59"></a> Wie funktionieren Extract und Exclude?

### `Extract<T, U>` und `Exclude<T, U>` in TypeScript

Beide Utility Types arbeiten mit **Union Types** und helfen, Typen zu filtern.

---

## **1. `Exclude<T, U>`**

Entfernt aus `T` alle Typen, die auch in `U` enthalten sind.
üëâ ‚ÄûAlles au√üer‚Äú

```ts
type Status = "success" | "error" | "loading"

type WithoutLoading = Exclude<Status, "loading">
// "success" | "error"
```

**Beispiel mit mehreren:**

```ts
type Letters = "a" | "b" | "c" | "d"

type WithoutBC = Exclude<Letters, "b" | "c">
// "a" | "d"
```

---

## **2. `Extract<T, U>`**

Beh√§lt nur die Typen aus `T`, die auch in `U` vorkommen.
üëâ ‚ÄûSchnittmenge‚Äú

```ts
type Status = "success" | "error" | "loading"

type OnlyError = Extract<Status, "error" | "fatal">
// "error"
```

**Beispiel mit mehreren:**

```ts
type Letters = "a" | "b" | "c" | "d"

type OnlyBC = Extract<Letters, "b" | "c" | "z">
// "b" | "c"
```

---

## **Vergleichs√ºbersicht**

| Utility Type    | Bedeutung                            | Beispiel     |                  |             |
| --------------- | ------------------------------------ | ------------ | ---------------- | ----------- |
| `Exclude<T, U>` | Entfernt Typen von `U` aus `T`       | `Exclude<"a" | "b", "b">`‚Üí`"a"` |             |
| `Extract<T, U>` | Behalte nur gemeinsame Typen mit `U` | `Extract<"a" | "b", "b"         | "c">`‚Üí`"b"` |

---

## **Praktische Anwendung**

* **`Exclude`**: Bestimmte Werte/Typszenarien ausschlie√üen.

  ```ts
  type EventType = "click" | "change" | "hover"
  type NonInteractive = Exclude<EventType, "click">
  // "change" | "hover"
  ```
* **`Extract`**: Nur erlaubte Schnittmenge behalten.

  ```ts
  type AllEvents = "click" | "change" | "hover"
  type UiEvents = "click" | "hover"

  type Allowed = Extract<AllEvents, UiEvents>
  // "click" | "hover"
  ```

---

### Zusammenfassung

* **`Exclude<T, U>`** = entfernt Typen von `U` aus `T`.
* **`Extract<T, U>`** = beh√§lt nur gemeinsame Typen zwischen `T` und `U`.
* Einsatz: Union-Typen filtern, APIs einschr√§nken, erlaubte/unerlaubte Werte modellieren.

üîó Quellen:

* [TypeScript Handbook ‚Äì Utility Types](https://www.typescriptlang.org/docs/handbook/utility-types.html)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

60. ### <a name="60"></a> Was macht NonNullable<T>?

### `NonNullable<T>` in TypeScript

**Definition:**
Der Utility Type **`NonNullable<T>`** entfernt **`null`** und **`undefined`** aus einem Typ.
üëâ Praktisch, wenn man einen Typ sicher ohne diese beiden Werte verwenden m√∂chte.

---

### Beispiel 1 ‚Äì Einfacher Typ

```ts
type Value = string | null | undefined

type SafeValue = NonNullable<Value>
// string
```

---

### Beispiel 2 ‚Äì Mit Union Types

```ts
type Status = "success" | "error" | null | undefined

type CleanStatus = NonNullable<Status>
// "success" | "error"
```

---

### Beispiel 3 ‚Äì In Funktionen

```ts
function printName(name: NonNullable<string | null | undefined>) {
  console.log(name.toUpperCase())
}

printName("Sergii")   // ‚úÖ
printName(null)       // ‚ùå Fehler
```

---

### Beispiel 4 ‚Äì In Kombination mit `strictNullChecks`

```ts
interface User {
  id: number
  email?: string | null
}

type SafeEmail = NonNullable<User["email"]>
// string
```

---

### Zusammenfassung

* **`NonNullable<T>`** = entfernt `null` und `undefined` aus Typ `T`.
* Typische Nutzung: Eingaben absichern, optionale Properties bereinigen, Union Types aufr√§umen.
* Besonders n√ºtzlich in Projekten mit **`strictNullChecks`**.

üîó Quellen:

* [TypeScript Handbook ‚Äì NonNullable](https://www.typescriptlang.org/docs/handbook/utility-types.html#nonnullabletype)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

61. ### <a name="61"></a> Wie deklariert man eine Klasse in TypeScript?

### Klassen in TypeScript deklarieren

In TypeScript funktionieren Klassen wie in JavaScript, k√∂nnen aber zus√§tzlich **Typen, Sichtbarkeiten und Interfaces** nutzen.

---

### 1. Basis-Syntax

```ts
export class Person {
  name: string
  age: number

  constructor(name: string, age: number) {
    this.name = name
    this.age = age
  }

  greet(): void {
    console.log(`Hallo, ich hei√üe ${this.name}`)
  }
}

const p = new Person("Sergii", 34)
p.greet() // Hallo, ich hei√üe Sergii
```

---

### 2. Sichtbarkeitsmodifikatoren

* **`public`** (Standard) ‚Üí √ºberall sichtbar
* **`private`** ‚Üí nur in der Klasse sichtbar
* **`protected`** ‚Üí in der Klasse und Subklassen sichtbar
* **`readonly`** ‚Üí Wert nur im Konstruktor setzbar

```ts
class User {
  readonly id: number
  private password: string
  protected role: string
  public name: string

  constructor(id: number, name: string, password: string, role: string) {
    this.id = id
    this.name = name
    this.password = password
    this.role = role
  }
}
```

---

### 3. Verk√ºrzte Schreibweise im Konstruktor

```ts
class Car {
  constructor(public brand: string, private year: number) {}
}

const c = new Car("BMW", 2025)
console.log(c.brand) // BMW
// console.log(c.year) ‚ùå Fehler: private
```

---

### 4. Vererbung (`extends`)

```ts
class Animal {
  move() {
    console.log("Bewegt sich")
  }
}

class Dog extends Animal {
  bark() {
    console.log("Wuff!")
  }
}

const d = new Dog()
d.move() // von Animal
d.bark() // von Dog
```

---

### 5. Abstrakte Klassen

```ts
abstract class Shape {
  abstract area(): number
}

class Square extends Shape {
  constructor(public side: number) {
    super()
  }

  area(): number {
    return this.side * this.side
  }
}
```

---

### 6. Klassen + Interfaces

```ts
interface Flyable {
  fly(): void
}

class Bird implements Flyable {
  fly() {
    console.log("Der Vogel fliegt")
  }
}
```

---

### Zusammenfassung

* Klassen werden mit `class` deklariert.
* **Features in TS:** Typisierung, Sichtbarkeitsmodifikatoren, `readonly`.
* Unterst√ºtzt: **Vererbung**, **abstrakte Klassen**, **Interfaces**.
* Vorteile: bessere Struktur und Typsicherheit gegen√ºber reinem JS.

üîó Quellen:

* [TypeScript Handbook ‚Äì Classes](https://www.typescriptlang.org/docs/handbook/2/classes.html)
* [MDN ‚Äì Classes in JS](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

62. ### <a name="62"></a> Was sind Zugriffsmodifikatoren (public, private, protected)?

### Zugriffsmodifikatoren in TypeScript (`public`, `private`, `protected`)

TypeScript erweitert JavaScript-Klassen um **Zugriffsmodifikatoren**, die steuern, **wo Eigenschaften und Methoden sichtbar sind**.

---

### 1. **public** (Standard)

* Zugriff von √ºberall: innerhalb der Klasse, in Subklassen, von au√üen.
* Ist der **Default**, auch wenn man nichts angibt.

```ts
class User {
  public name: string
  constructor(name: string) {
    this.name = name
  }
}

const u = new User("Sergii")
console.log(u.name) // ‚úÖ erlaubt
```

---

### 2. **private**

* Zugriff nur innerhalb der **gleichen Klasse**.
* Nicht von Subklassen oder von au√üen sichtbar.

```ts
class Account {
  private balance: number
  constructor(balance: number) {
    this.balance = balance
  }

  deposit(amount: number) {
    this.balance += amount
  }
}

const acc = new Account(100)
// acc.balance // ‚ùå Fehler: private
acc.deposit(50) // ‚úÖ erlaubt
```

---

### 3. **protected**

* Zugriff in der Klasse **und in Subklassen**.
* Nicht von au√üen sichtbar.

```ts
class Animal {
  protected move() {
    console.log("Bewegt sich")
  }
}

class Dog extends Animal {
  bark() {
    this.move() // ‚úÖ erlaubt, da protected
    console.log("Wuff!")
  }
}

const d = new Dog()
// d.move() ‚ùå Fehler
d.bark() // ‚úÖ erlaubt
```

---

### 4. **readonly** (Sonderfall)

* Kein Zugriffsmodifikator, aber oft in Kombination genutzt.
* Wert darf **nur im Konstruktor oder bei Deklaration gesetzt** werden.

```ts
class Config {
  readonly version: string = "1.0"
}

const c = new Config()
// c.version = "2.0" ‚ùå Fehler
```

---

### Vergleichstabelle

| Modifikator | Zugriff in Klasse | Zugriff in Subklasse | Zugriff von au√üen |
| ----------- | ----------------- | -------------------- | ----------------- |
| `public`    | ‚úÖ                 | ‚úÖ                    | ‚úÖ                 |
| `protected` | ‚úÖ                 | ‚úÖ                    | ‚ùå                 |
| `private`   | ‚úÖ                 | ‚ùå                    | ‚ùå                 |

---

### Zusammenfassung

* **public** = √ºberall sichtbar (Default).
* **private** = nur in der Klasse.
* **protected** = in Klasse + Subklassen.
* **readonly** = Wert nicht √§nderbar (Erg√§nzung).

üîó Quellen:

* [TypeScript Handbook ‚Äì Classes](https://www.typescriptlang.org/docs/handbook/2/classes.html#public-private-and-protected-modifiers)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

63. ### <a name="63"></a> Was sind readonly-Eigenschaften in Klassen?

### `readonly` Eigenschaften in TypeScript-Klassen

**Definition:**
Eine **`readonly`-Eigenschaft** in einer Klasse kann **nur einmal** gesetzt werden:

* bei der **Deklaration**, oder
* im **Konstruktor**.

Danach ist sie **unver√§nderlich** (immutable).

---

### Beispiel 1 ‚Äì `readonly` bei Deklaration

```ts
class Config {
  readonly version: string = "1.0"
}

const c = new Config()
// c.version = "2.0" ‚ùå Fehler: version ist readonly
```

---

### Beispiel 2 ‚Äì `readonly` im Konstruktor

```ts
class User {
  readonly id: number
  name: string

  constructor(id: number, name: string) {
    this.id = id   // ‚úÖ erlaubt
    this.name = name
  }
}

const u = new User(1, "Sergii")
u.name = "Anna"   // ‚úÖ ver√§nderbar
// u.id = 2       // ‚ùå Fehler: readonly
```

---

### Beispiel 3 ‚Äì Kombination mit Modifikatoren

```ts
class Token {
  private readonly secret: string

  constructor(secret: string) {
    this.secret = secret
  }

  getSecret(): string {
    return this.secret // ‚úÖ nur lesbar
  }
}
```

---

### Beispiel 4 ‚Äì `readonly` Arrays (nicht tief eingefroren!)

```ts
class Data {
  readonly items: string[] = ["a", "b"]
}

const d = new Data()
d.items.push("c")    // ‚úÖ erlaubt, weil Array selbst mutable
// d.items = []       // ‚ùå Fehler: Referenz ist readonly
```

üëâ F√ºr wirklich **immutable Arrays** ‚Üí `ReadonlyArray<T>`.

---

### Zusammenfassung

* **`readonly`** = Eigenschaft ist nach Zuweisung nicht mehr √ºberschreibbar.
* Initialisierung: in **Deklaration** oder im **Konstruktor**.
* Kombinierbar mit `public`, `private`, `protected`.
* Wichtig: bei Arrays/Objekten sch√ºtzt es nur die **Referenz**, nicht den Inhalt.

üîó Quellen:

* [TypeScript Handbook ‚Äì Classes: readonly](https://www.typescriptlang.org/docs/handbook/2/classes.html#readonly)
* [MDN ‚Äì const vs. readonly (Unterschied)](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#readonly-properties)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

64. ### <a name="64"></a> Wie deklariert man statische Eigenschaften und Methoden?

### Statische Eigenschaften und Methoden in TypeScript

**Definition:**
Mit dem Schl√ºsselwort **`static`** deklariert man **Eigenschaften oder Methoden**, die **zur Klasse selbst geh√∂ren**, nicht zu deren Instanzen.
üëâ Zugriff erfolgt √ºber den **Klassennamen**, nicht √ºber `this`.

---

### 1. Statische Eigenschaft

```ts
class Config {
  static readonly version: string = "1.0"
}

console.log(Config.version) // ‚úÖ Zugriff √ºber Klasse
// new Config().version ‚ùå Fehler
```

---

### 2. Statische Methode

```ts
class MathUtils {
  static add(a: number, b: number): number {
    return a + b
  }
}

console.log(MathUtils.add(2, 3)) // 5
```

---

### 3. Kombination von static + private

```ts
class Counter {
  private static count = 0

  static increment(): number {
    return ++this.count
  }
}

console.log(Counter.increment()) // 1
console.log(Counter.increment()) // 2
```

---

### 4. Zugriff aus Instanzmethoden (z. B. Singleton-Pattern)

```ts
class Database {
  private static instance: Database

  private constructor() {}

  static getInstance(): Database {
    if (!Database.instance) {
      Database.instance = new Database()
    }
    return Database.instance
  }
}

const db1 = Database.getInstance()
const db2 = Database.getInstance()

console.log(db1 === db2) // true
```

---

### 5. Einschr√§nkung: kein Zugriff √ºber `this` in Instanzmethoden

```ts
class Example {
  static x = 10

  logX() {
    // console.log(this.x) ‚ùå Fehler
    console.log(Example.x) // ‚úÖ
  }
}
```

---

### Zusammenfassung

* **`static`** ‚Üí geh√∂rt zur Klasse, nicht zur Instanz.
* Zugriff: **`Klassenname.member`**.
* Typische Nutzung: **Hilfsfunktionen, Konstanten, Singleton-Pattern, Counter, Factories**.

üîó Quellen:

* [TypeScript Handbook ‚Äì Classes: static](https://www.typescriptlang.org/docs/handbook/2/classes.html#static-members)
* [MDN ‚Äì static keyword (JS)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes/static)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

65. ### <a name="65"></a> Was ist der Unterschied zwischen einer abstrakten und einer normalen Klasse?

### Unterschied: Abstrakte Klasse vs. Normale Klasse in TypeScript

---

### **1. Normale Klasse**

* Kann **direkt instanziiert** werden (`new`).
* Enth√§lt **komplette Implementierungen** von Eigenschaften und Methoden.

```ts
class Person {
  constructor(public name: string) {}

  greet(): void {
    console.log(`Hallo, ich hei√üe ${this.name}`)
  }
}

const p = new Person("Sergii") // ‚úÖ erlaubt
p.greet() // Hallo, ich hei√üe Sergii
```

---

### **2. Abstrakte Klasse**

* Kann **nicht direkt instanziiert** werden (`new` ist verboten).
* Kann **abstrakte Methoden** enthalten ‚Üí nur **Signatur**, keine Implementierung.
* Dient als **Basisklasse** f√ºr Spezialisierungen.

```ts
abstract class Animal {
  constructor(public name: string) {}

  abstract makeSound(): void // nur Signatur

  move(): void {
    console.log(`${this.name} bewegt sich`)
  }
}

class Dog extends Animal {
  makeSound(): void {
    console.log("Wuff!")
  }
}

const d = new Dog("Bello") // ‚úÖ erlaubt
d.makeSound() // Wuff!

// const a = new Animal("X") ‚ùå Fehler: abstrakte Klasse
```

---

### **3. Typische Nutzung von abstrakten Klassen**

* Gemeinsame **Grundlogik** in der Basisklasse.
* Unterschiedliche Subklassen m√ºssen **abstrakte Methoden implementieren**.
* Beispiel: **Template Method Pattern**, **Basis-Modelle** in OOP.

---

### **Vergleichstabelle**

| Merkmal            | Normale Klasse    | Abstrakte Klasse                          |
| ------------------ | ----------------- | ----------------------------------------- |
| Instanziierung     | ‚úÖ m√∂glich (`new`) | ‚ùå nicht m√∂glich                           |
| Abstrakte Methoden | ‚ùå nicht erlaubt   | ‚úÖ erlaubt (Signatur ohne Body)            |
| Implementierung    | ‚úÖ vollst√§ndig     | ‚úÖ teilweise + abstrakte Methoden          |
| Einsatz            | konkrete Objekte  | Basis f√ºr Spezialisierungen (Polymorphie) |

---

### Zusammenfassung

* **Normale Klasse** = vollst√§ndige Implementierung, direkt instanziierbar.
* **Abstrakte Klasse** = kann nicht instanziiert werden, enth√§lt evtl. abstrakte Methoden, zwingt Subklassen zur Implementierung.
* Einsatz: **OOP-Design, Polymorphismus, Code-Wiederverwendung**.

üîó Quellen:

* [TypeScript Handbook ‚Äì Classes: abstract](https://www.typescriptlang.org/docs/handbook/2/classes.html#abstract-classes)
* [MDN ‚Äì Classes](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

66. ### <a name="66"></a> Kann man Interfaces mit Klassen implementieren?

### Interfaces mit Klassen implementieren

**Antwort:**
Ja ‚úÖ ‚Äî eine Klasse kann ein oder mehrere **Interfaces implementieren**, indem sie deren Struktur erf√ºllt.
üëâ Interfaces definieren nur die **Form** (keine Implementierung).
üëâ Klassen m√ºssen dann **alle Eigenschaften und Methoden** implementieren.

---

### Beispiel 1 ‚Äì Einfaches Interface

```ts
interface Greetable {
  name: string
  greet(): void
}

class Person implements Greetable {
  constructor(public name: string) {}

  greet(): void {
    console.log(`Hallo, ich hei√üe ${this.name}`)
  }
}

const p = new Person("Sergii")
p.greet() // Hallo, ich hei√üe Sergii
```

---

### Beispiel 2 ‚Äì Mehrere Interfaces

```ts
interface CanRun {
  run(): void
}

interface CanJump {
  jump(): void
}

class Athlete implements CanRun, CanJump {
  run(): void {
    console.log("Ich laufe")
  }
  jump(): void {
    console.log("Ich springe")
  }
}
```

---

### Beispiel 3 ‚Äì Interface als Vertrag f√ºr Klassen

```ts
interface Repository<T> {
  getAll(): T[]
  add(item: T): void
}

class UserRepository implements Repository<string> {
  private users: string[] = []

  getAll(): string[] {
    return this.users
  }

  add(user: string): void {
    this.users.push(user)
  }
}
```

---

### Regeln

* `implements` = **Interface einhalten**.
* Anders als `extends` ‚Üí keine Vererbung von Implementierung, nur von **Struktur**.
* Klassen k√∂nnen **mehrere Interfaces** implementieren, aber nur **eine Klasse** erweitern.

---

### Zusammenfassung

* **Interfaces + Klassen** = Vertrag + konkrete Umsetzung.
* Syntax: `class X implements InterfaceA, InterfaceB`.
* Typisch f√ºr: Architektur, Code-Wiederverwendung, Polymorphismus.

üîó Quellen:

* [TypeScript Handbook ‚Äì Classes: implements](https://www.typescriptlang.org/docs/handbook/2/classes.html#implements-clauses)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

67. ### <a name="67"></a> Was ist der Unterschied zwischen implements und extends?

### Unterschied: `implements` vs. `extends` in TypeScript

---

### **1. `extends`**

* Wird f√ºr **Vererbung** genutzt.
* Eine Klasse kann **nur eine andere Klasse** erweitern.
* Subklasse erbt **Eigenschaften + Methoden** der Superklasse.

```ts
class Animal {
  move() {
    console.log("Bewegt sich")
  }
}

class Dog extends Animal {
  bark() {
    console.log("Wuff!")
  }
}

const d = new Dog()
d.move() // von Animal
d.bark() // von Dog
```

---

### **2. `implements`**

* Wird genutzt, um eine Klasse an ein **Interface** (oder mehrere) zu binden.
* Klasse muss alle **Properties und Methoden-Signaturen** des Interfaces implementieren.
* Interfaces geben nur die **Struktur** vor, keine Logik.

```ts
interface Flyable {
  fly(): void
}

class Bird implements Flyable {
  fly() {
    console.log("Der Vogel fliegt")
  }
}
```

---

### **3. Kombination**

Eine Klasse kann **gleichzeitig** eine Klasse erweitern und Interfaces implementieren.

```ts
interface Swimmable {
  swim(): void
}

class Animal {
  eat() {
    console.log("Frisst")
  }
}

class Fish extends Animal implements Swimmable {
  swim() {
    console.log("Schwimmt")
  }
}
```

---

### **Vergleichstabelle**

| Merkmal         | `extends`                        | `implements`                            |
| --------------- | -------------------------------- | --------------------------------------- |
| Zweck           | Vererbung (Code wiederverwenden) | Vertrag erf√ºllen (Struktur einhalten)   |
| Quelle          | Klasse oder abstrakte Klasse     | Interface(s)                            |
| Mehrfachnutzung | Nur **eine** Superklasse m√∂glich | Mehrere Interfaces gleichzeitig m√∂glich |
| Enth√§lt Logik   | ‚úÖ Ja                             | ‚ùå Nur Signaturen                        |

---

### Zusammenfassung

* **`extends`** = Vererbung: Klasse erbt Implementierungen.
* **`implements`** = Vertrag: Klasse muss Interface erf√ºllen.
* Kombination m√∂glich: `class X extends Y implements Z`.

üîó Quellen:

* [TypeScript Handbook ‚Äì Classes](https://www.typescriptlang.org/docs/handbook/2/classes.html)
* [TypeScript Handbook ‚Äì Interfaces](https://www.typescriptlang.org/docs/handbook/2/objects.html)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

68. ### <a name="68"></a> Was ist this und wie typisiert man es?

### `this` in TypeScript

**Definition:**
`this` verweist im Kontext einer Funktion oder Methode auf das **aktuelle Objekt**, in dem die Funktion ausgef√ºhrt wird.
In TypeScript kann man `this` **explizit typisieren**, um Typ-Sicherheit zu gew√§hrleisten.

---

## 1. `this` in Klassen

Automatisch auf die **Instanz** der Klasse gebunden.

```ts
class User {
  name: string
  constructor(name: string) {
    this.name = name
  }

  greet(): void {
    console.log(`Hallo, ich bin ${this.name}`)
  }
}

const u = new User("Sergii")
u.greet() // Hallo, ich bin Sergii
```

üëâ Hier ist `this: User`.

---

## 2. `this` als expliziter Typ in Funktionen

Man kann `this` als **ersten Pseudoparameter** typisieren.

> Wichtig: Dieser Parameter existiert nur f√ºr die Typpr√ºfung, nicht im Runtime-Code!

```ts
interface User {
  name: string
}

function greet(this: User, greeting: string) {
  console.log(`${greeting}, ich bin ${this.name}`)
}

const u: User = { name: "Anna" }
greet.call(u, "Hallo") // Hallo, ich bin Anna
```

üëâ Ohne `this: User` w√ºrde `this.name` einen Fehler ausl√∂sen.

---

## 3. Arrow Functions und `this`

Arrow Functions **binden kein eigenes `this`**, sondern √ºbernehmen es aus dem umgebenden Kontext.

```ts
class Counter {
  count = 0

  // normales this -> muss gebunden werden
  incNormal() {
    setTimeout(function () {
      // console.log(this.count) ‚ùå Fehler
    }, 1000)
  }

  // Arrow Function -> this bleibt auf Instanz gebunden
  incArrow() {
    setTimeout(() => {
      this.count++  // ‚úÖ korrekt
      console.log(this.count)
    }, 1000)
  }
}
```

---

## 4. `this` als R√ºckgabewert (Fluent API)

Man kann `this` typisieren, damit Methoden **Method Chaining** unterst√ºtzen.

```ts
class Builder {
  private content: string = ""

  add(text: string): this {
    this.content += text
    return this // Typ = Builder
  }

  print(): void {
    console.log(this.content)
  }
}

new Builder().add("Hallo ").add("Welt!").print()
```

---

## 5. Typische Nutzung in Generics (`this` Types)

TypeScript erlaubt **polymorphe this-Typen** f√ºr bessere R√ºckgabetypen.

```ts
class Base {
  withBase(): this {
    return this
  }
}

class Sub extends Base {
  withSub(): this {
    return this
  }
}

const obj = new Sub().withBase().withSub() // ‚úÖ Sub
```

---

### Zusammenfassung

* `this` = aktuelles Objekt im Kontext.
* Typisierbar: `function fn(this: Typ, ...)`.
* In **Klassen** automatisch Instanz-Typ.
* **Arrow Functions** ‚Üí √ºbernehmen `this` vom √§u√üeren Kontext.
* Unterst√ºtzt **Method Chaining** via `this`-R√ºckgabetyp.

üîó Quellen:

* [TypeScript Handbook ‚Äì this parameters](https://www.typescriptlang.org/docs/handbook/2/functions.html#this-parameters)
* [MDN ‚Äì this (JavaScript)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/this)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

69. ### <a name="69"></a> Kann man generische Klassen erstellen?

### Generische Klassen in TypeScript

**Antwort:**
Ja ‚úÖ ‚Äî Klassen k√∂nnen wie Funktionen **Generics** verwenden.
üëâ Damit k√∂nnen Klassen flexibel mit unterschiedlichen Typen arbeiten, ohne die Typ-Sicherheit zu verlieren.

---

## 1. Einfache generische Klasse

```ts
class Box<T> {
  private content: T

  constructor(value: T) {
    this.content = value
  }

  getContent(): T {
    return this.content
  }
}

const stringBox = new Box("Hallo") // Box<string>
const numBox = new Box(42)         // Box<number>

console.log(stringBox.getContent()) // Hallo
console.log(numBox.getContent())    // 42
```

---

## 2. Generische Klasse mit mehreren Typ-Parametern

```ts
class Pair<K, V> {
  constructor(public key: K, public value: V) {}
}

const entry = new Pair("id", 123) // Pair<string, number>
```

---

## 3. Mit `extends` (Constraints)

```ts
interface Identifiable {
  id: number
}

class Repository<T extends Identifiable> {
  private items: T[] = []

  add(item: T) {
    this.items.push(item)
  }

  getById(id: number): T | undefined {
    return this.items.find(item => item.id === id)
  }
}

const repo = new Repository<{ id: number; name: string }>()
repo.add({ id: 1, name: "Sergii" })
console.log(repo.getById(1)) // { id: 1, name: "Sergii" }
```

---

## 4. Generische Klassen + Interfaces

```ts
interface Storage<T> {
  add(item: T): void
  getAll(): T[]
}

class MemoryStorage<T> implements Storage<T> {
  private items: T[] = []

  add(item: T): void {
    this.items.push(item)
  }

  getAll(): T[] {
    return this.items
  }
}

const store = new MemoryStorage<string>()
store.add("Hello")
store.add("World")
console.log(store.getAll()) // ["Hello", "World"]
```

---

### Zusammenfassung

* **Generische Klassen** = Klassen mit Typparametern (`class MyClass<T> {}`).
* Erlauben **flexible, typsichere Datenstrukturen** (z. B. Box, Repository, Storage).
* Unterst√ºtzen mehrere Typparameter (`<K, V>`), Constraints (`extends`) und Implementierungen von Interfaces.

üîó Quellen:

* [TypeScript Handbook ‚Äì Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-classes)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

70. ### <a name="70"></a> Wie erstellt man ein React-Projekt mit TypeScript?

### Schnellstart: React + TypeScript

#### **Option A ‚Äì Vite (empfohlen, schnell & leicht)**

```bash
# Node 18+ empfohlen
npm create vite@latest my-app -- --template react-ts
cd my-app
npm install
npm run dev
```

**Beispiel-Komponente**

```js
// src/components/Hello.tsx
import { useState } from "react"

export function Hello({ name }: { name: string }) {
  const [count, setCount] = useState<number>(0)
  return (
    <button onClick={() => setCount((c) => c + 1)}>
      Hallo {name}! Klicks: {count}
    </button>
  )
}
```

**Pfadalias (optional)**

```js
// tsconfig.json (Auszug)
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": { "@/*": ["src/*"] },
    "strict": true,
    "jsx": "react-jsx"
  }
}
```

```js
// vite.config.ts (Auszug)
import { defineConfig } from "vite"
import react from "@vitejs/plugin-react"
import path from "node:path"

export default defineConfig({
  plugins: [react()],
  resolve: { alias: { "@": path.resolve(__dirname, "src") } }
})
```

---

#### **Option B ‚Äì Next.js (SSR/SSG, Full-stack)**

```bash
npx create-next-app@latest my-app --ts
cd my-app
npm run dev
```

**Client-Komponente**

```js
// app/page.tsx (Next.js App Router)
export default function Page() {
  return <h1>Hallo Next.js + TypeScript</h1>
}
```

---

### Typische TS/React-Patterns

**Props & Events**

```js
// src/components/Input.tsx
import type { ChangeEvent } from "react"

export function Input({ onChange }: { onChange: (v: string) => void }) {
  const handle = (e: ChangeEvent<HTMLInputElement>) => onChange(e.target.value)
  return <input onChange={handle} />
}
```

**Generische Utility-Komponente**

```js
// src/components/List.tsx
export function List<T>({ items, render }: { items: T[]; render: (x: T) => JSX.Element }) {
  return <ul>{items.map(render)}</ul>
}
```

---

### Qualit√§t & DX (optional, kurz)

* **ESLint/Prettier**

  ```bash
  npm i -D eslint @typescript-eslint/{parser,eslint-plugin} prettier
  ```
* **Strict** aktiv lassen (`"strict": true`) f√ºr bessere Typpr√ºfung.
* **Testing**: Vitest + React Testing Library in Vite-Projekten.

---

### Zusammenfassung

* **Vite + `react-ts`** f√ºr SPA: schnell, minimal.
* **Next.js + `--ts`** f√ºr SSR/SSG/Full-stack.
* Aktiviere **`strict`** & nutze **`jsx: "react-jsx"`**.
* Typisiere Props/Events explizit; nutze Generics bei Wiederverwendung.

**Quellen:**

* [React Offizielle Doku ‚Äì Einstieg](https://react.dev/learn)
* [TypeScript ‚Äì React mit TS (JSX/TSX)](https://www.typescriptlang.org/docs/handbook/jsx.html)
* [React + TypeScript Cheatsheet ‚Äì Setup](https://react-typescript-cheatsheet.netlify.app/docs/basic/setup)
* [Vite ‚Äì React TS Template](https://vitejs.dev/guide/)
* [Next.js ‚Äì TypeScript](https://nextjs.org/docs/basic-features/typescript)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

71. ### <a name="71"></a> Wie typisiert man eine React-Komponente (FC)?

### Typisierung von React-Komponenten in TypeScript

---

## **1. Funktionale Komponente mit Props**

```tsx
type HelloProps = {
  name: string
  age?: number // optional
}

export function Hello({ name, age }: HelloProps) {
  return <h1>Hallo {name}, Alter: {age}</h1>
}
```

üëâ Standard: Props mit einem **Type** oder **Interface** typisieren.

---

## **2. Mit `React.FC` (funktioniert, wird aber weniger empfohlen)**

```tsx
import type { FC } from "react"

type HelloProps = {
  name: string
}

export const Hello: FC<HelloProps> = ({ name, children }) => (
  <div>
    <h1>Hallo {name}</h1>
    {children} {/* children automatisch typisiert */}
  </div>
)
```

‚ö†Ô∏è Nachteile von `React.FC`:

* `children` wird **immer erlaubt** (auch wenn nicht erw√ºnscht).
* Manche HOCs/Generics funktionieren schlechter.

---

## **3. Mit Generics (z. B. List-Komponente)**

```tsx
type ListProps<T> = {
  items: T[]
  render: (item: T) => JSX.Element
}

export function List<T>({ items, render }: ListProps<T>) {
  return <ul>{items.map(render)}</ul>
}

// Verwendung:
<List items={["A", "B", "C"]} render={(item) => <li>{item}</li>} />
```

---

## **4. Event-Handler in Props**

```tsx
import type { MouseEventHandler } from "react"

type ButtonProps = {
  label: string
  onClick: MouseEventHandler<HTMLButtonElement>
}

export function Button({ label, onClick }: ButtonProps) {
  return <button onClick={onClick}>{label}</button>
}
```

---

## **5. Default Props (via Default-Parameter)**

```tsx
type TitleProps = {
  text?: string
}

export function Title({ text = "Standardtitel" }: TitleProps) {
  return <h2>{text}</h2>
}
```

---

## Zusammenfassung

* **Empfohlen:** Props √ºber **Type oder Interface** definieren und direkt in der Funktion nutzen.
* **`React.FC`** m√∂glich, aber Nachteile (immer `children`).
* F√ºr wiederverwendbare Komponenten ‚Üí **Generics** verwenden.
* Events immer mit **React-Eventtypen** (`MouseEvent`, `ChangeEvent`, ‚Ä¶) typisieren.

üîó Quellen:

* [React TypeScript Cheatsheet ‚Äì Function Components](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/function_components/)
* [React Docs](https://react.dev/)
* [TypeScript Handbook ‚Äì Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

72. ### <a name="72"></a> Was ist React.FC und wann sollte man es vermeiden?

### `React.FC` in TypeScript

---

## **1. Definition**

`React.FC` (Function Component) ist ein vordefinierter Typ in `@types/react`, um **funktionale Komponenten** zu typisieren:

```tsx
import type { FC } from "react"

type HelloProps = { name: string }

export const Hello: FC<HelloProps> = ({ name }) => <h1>Hallo {name}</h1>
```

---

## **2. Vorteile von `React.FC`**

* Bietet **automatische Typisierung von `children`**.
* Klare Signatur: `const Comp: FC<Props>`.
* Einfacher f√ºr Einsteiger.

---

## **3. Nachteile von `React.FC` (Gr√ºnde zum Vermeiden)**

1. **`children` ist immer erlaubt**, auch wenn man es gar nicht will.

   ```tsx
   type Props = { name: string }
   const A: FC<Props> = ({ name, children }) => <>{name}{children}</>
   <A name="Sergii">‚ùå children wird automatisch zugelassen</A>
   ```

2. **Keine Unterst√ºtzung f√ºr `defaultProps`/`propTypes`** (deprecated Pattern).

3. **Generics schwieriger einzusetzen** (z. B. `FC<ListProps<T>>`).

4. **Nicht n√∂tig**, weil Typisierung ohne `React.FC` pr√§ziser und flexibler ist.

---

## **4. Empfohlene Alternative (ohne React.FC)**

```tsx
type HelloProps = { name: string }

export function Hello({ name }: HelloProps) {
  return <h1>Hallo {name}</h1>
}
```

üëâ Props direkt typisieren ‚Üí mehr Kontrolle, keine unn√∂tigen `children`.

---

## **5. Wann `React.FC` verwenden?**

* Kleine Projekte oder **schneller Prototyping-Code**.
* Wenn man **immer `children`** ben√∂tigt (z. B. Layout-Komponenten).
* Aber: In gr√∂√üeren Projekten wird **Vermeidung empfohlen** ‚Üí klarere Typen, weniger Fehler.

---

### Zusammenfassung

* **`React.FC`** = Typalias f√ºr Function Components, inkl. implizitem `children`.
* **Problem:** macht `children` immer verf√ºgbar, erschwert Generics.
* **Empfehlung:** Props **direkt typisieren** (statt `React.FC`).
* Nutzen: nur, wenn man absichtlich `children` erzwingen will.

üîó Quellen:

* [React TypeScript Cheatsheet ‚Äì Function Components](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/function_components/)
* [React Docs](https://react.dev/)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

73. ### <a name="73"></a> Wie typisiert man Props in einer React-Komponente?

### Props in React-Komponenten typisieren (TypeScript)

---

## **1. Mit `type`**

```tsx
type GreetingProps = {
  name: string
  age?: number // optional
}

export function Greeting({ name, age }: GreetingProps) {
  return <h1>Hallo {name}, Alter: {age}</h1>
}
```

üëâ Empfehlung: `type` f√ºr Props, da es auch Unions, Utility Types usw. unterst√ºtzt.

---

## **2. Mit `interface`**

```tsx
interface ButtonProps {
  label: string
  onClick: () => void
}

export function Button({ label, onClick }: ButtonProps) {
  return <button onClick={onClick}>{label}</button>
}
```

üëâ Vorteil: `interface` l√§sst sich **erweitern** (`extends`).

---

## **3. Mit `children`**

```tsx
type CardProps = {
  title: string
  children: React.ReactNode
}

export function Card({ title, children }: CardProps) {
  return (
    <div>
      <h2>{title}</h2>
      <div>{children}</div>
    </div>
  )
}
```

---

## **4. Mit Events**

```tsx
import type { MouseEvent } from "react"

type ButtonProps = {
  onClick: (e: MouseEvent<HTMLButtonElement>) => void
}

export function Button({ onClick }: ButtonProps) {
  return <button onClick={onClick}>Klick mich</button>
}
```

---

## **5. Mit Generics (z. B. Listen-Komponente)**

```tsx
type ListProps<T> = {
  items: T[]
  render: (item: T) => JSX.Element
}

export function List<T>({ items, render }: ListProps<T>) {
  return <ul>{items.map(render)}</ul>
}

// Nutzung
<List items={["A", "B", "C"]} render={(i) => <li>{i}</li>} />
```

---

## Zusammenfassung

* **Props** typisiert man √ºber `type` oder `interface`.
* **Optional** mit `?`, **children** mit `React.ReactNode`.
* Events strikt mit **React-Eventtypen** (`MouseEvent`, `ChangeEvent`, ‚Ä¶).
* F√ºr wiederverwendbare Komponenten ‚Üí **Generics**.

üîó Quellen:

* [React TypeScript Cheatsheet ‚Äì Props](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example/)
* [React Docs ‚Äì Passing Props](https://react.dev/learn/passing-props-to-a-component)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

74. ### <a name="74"></a> Wie typisiert man optionale Props?

### Optionale Props in React mit TypeScript

---

## **1. Mit `?` (Standardmethode)**

```tsx
type GreetingProps = {
  name: string
  age?: number // optional
}

export function Greeting({ name, age }: GreetingProps) {
  return <h1>Hallo {name}, Alter: {age ?? "unbekannt"}</h1>
}
```

üëâ `age` ist automatisch `number | undefined`.

---

## **2. Mit Default-Wert im Destructuring**

```tsx
type TitleProps = {
  text?: string
}

export function Title({ text = "Standardtitel" }: TitleProps) {
  return <h2>{text}</h2>
}
```

üëâ So wird `text` im Body **immer ein `string`**.

---

## **3. In Kombination mit `React.ReactNode` (children optional)**

```tsx
type CardProps = {
  title: string
  children?: React.ReactNode
}

export function Card({ title, children }: CardProps) {
  return (
    <div>
      <h2>{title}</h2>
      {children && <div>{children}</div>}
    </div>
  )
}
```

---

## **4. Utility Types f√ºr optionale Props (`Partial`)**

```tsx
type User = { id: number; name: string; email: string }

type OptionalUserProps = Partial<User>
// alle Props jetzt optional
```

---

### Zusammenfassung

* Optionale Props mit **`?`** markieren.
* Optional + Default-Wert ‚Üí verhindert `undefined` im Body.
* `children` oft als optionales `React.ReactNode`.
* Utility Type **`Partial<T>`** macht alle Props optional.

üîó Quellen:

* [TypeScript Handbook ‚Äì Optional Properties](https://www.typescriptlang.org/docs/handbook/2/objects.html#optional-properties)
* [React TS Cheatsheet ‚Äì Props](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example/)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

75. ### <a name="75"></a> Wie deklariert man Default Props in TypeScript?

### Default Props in React + TypeScript

In modernen React-Projekten mit TypeScript setzt man **Default-Werte direkt im Funktionsparameter**.
üëâ Die alte L√∂sung mit `Component.defaultProps` ist **deprecated**.

---

## **1. Default Props √ºber Destructuring**

```tsx
type GreetingProps = {
  name: string
  age?: number
}

export function Greeting({ name, age = 18 }: GreetingProps) {
  return <h1>Hallo {name}, Alter: {age}</h1>
}

// Verwendung:
<Greeting name="Sergii" />       // Alter: 18
<Greeting name="Anna" age={25} /> // Alter: 25
```

‚û°Ô∏è `age` ist im Body immer `number`, kein `undefined`.

---

## **2. Default Props bei `children`**

```tsx
type CardProps = {
  title?: string
  children?: React.ReactNode
}

export function Card({ title = "Ohne Titel", children }: CardProps) {
  return (
    <div>
      <h2>{title}</h2>
      {children}
    </div>
  )
}
```

---

## **3. Mit `Partial<T>` f√ºr flexible Defaults**

```tsx
type ButtonProps = {
  label: string
  size?: "small" | "medium" | "large"
}

const defaultProps: Partial<ButtonProps> = {
  size: "medium"
}

export function Button({ label, size = defaultProps.size }: ButtonProps) {
  return <button>{`${label} (${size})`}</button>
}
```

---

## **4. Generische Komponente mit Defaults**

```tsx
type ListProps<T> = {
  items?: T[]
  render: (item: T) => JSX.Element
}

export function List<T>({ items = [], render }: ListProps<T>) {
  return <ul>{items.map(render)}</ul>
}
```

---

### Zusammenfassung

* **Empfohlene Methode**: Default-Werte direkt beim **Destructuring** setzen.
* Props bleiben **optional** (`?`), aber im Funktionsk√∂rper ist der Typ **bereinigt**.
* `defaultProps` (alte Syntax) ‚Üí vermeiden.

üîó Quellen:

* [React TS Cheatsheet ‚Äì Props mit Defaults](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example/#default-props)
* [React Docs ‚Äì Passing Props](https://react.dev/learn/passing-props-to-a-component)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

76. ### <a name="76"></a> Wie typisiert man children in React-Komponenten?

### `children` in React-Komponenten typisieren

---

## **1. Mit `React.ReactNode` (Standard)**

```tsx
type CardProps = {
  children: React.ReactNode
}

export function Card({ children }: CardProps) {
  return <div className="card">{children}</div>
}

// Nutzung:
<Card>
  <h2>Hallo</h2>
  <p>Inhalt</p>
</Card>
```

üëâ `React.ReactNode` erlaubt: JSX, Strings, Zahlen, Arrays, `null`, `undefined`.

---

## **2. Mit `ReactElement` (nur JSX erlaubt)**

```tsx
import type { ReactElement } from "react"

type WrapperProps = {
  children: ReactElement
}

export function Wrapper({ children }: WrapperProps) {
  return <section>{children}</section>
}

// <Wrapper><h1>‚úÖ nur ein Element</h1></Wrapper>
// <Wrapper>Text ‚ùå Fehler</Wrapper>
```

---

## **3. Array von React-Elementen**

```tsx
import type { ReactElement } from "react"

type ListProps = {
  children: ReactElement[]
}

export function List({ children }: ListProps) {
  return <ul>{children}</ul>
}

// <List><li>A</li><li>B</li></List> ‚úÖ
```

---

## **4. Funktion als Children (Render Prop)**

```tsx
type RenderPropProps = {
  children: (count: number) => React.ReactNode
}

export function Counter({ children }: RenderPropProps) {
  return <div>{children(5)}</div>
}

// <Counter>{(n) => <span>Zahl: {n}</span>}</Counter>
```

---

## **5. Optionales `children`**

```tsx
type ContainerProps = {
  children?: React.ReactNode
}

export function Container({ children }: ContainerProps) {
  return <main>{children ?? "Kein Inhalt"}</main>
}
```

---

### Zusammenfassung

* **`React.ReactNode`** ‚Üí flexibel, Standard f√ºr `children`.
* **`ReactElement`** ‚Üí nur g√ºltige JSX-Elemente (kein Text, kein Array).
* **Arrays** explizit als `ReactElement[]`.
* **Render Props** typisieren mit Funktionssignatur.
* `children` optional machen mit `?`.

üîó Quellen:

* [React TypeScript Cheatsheet ‚Äì Children](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example/#children)
* [React Docs ‚Äì Passing Children](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

77. ### <a name="77"></a> Was ist der Unterschied zwischen ReactNode, JSX.Element und ReactElement?

### Unterschied: `ReactNode` vs. `JSX.Element` vs. `ReactElement`

Diese drei Typen werden in React/TypeScript oft verwechselt, haben aber **verschiedene Bedeutungen**.

---

## **1. `ReactNode`**

üëâ Der **allgemeinste Typ** f√ºr Inhalte, die in JSX gerendert werden k√∂nnen.
Enth√§lt:

* `string`, `number`, `boolean` (teilweise),
* `null`, `undefined`,
* `JSX.Element`, `ReactElement`,
* Arrays dieser Typen.

```tsx
type ExampleProps = {
  children: React.ReactNode
}

export function Example({ children }: ExampleProps) {
  return <div>{children}</div>
}

// ‚úÖ erlaubt:
<Example>Hallo</Example>
<Example>{123}</Example>
<Example><span>Text</span></Example>
<Example>{["A", "B", <b key="x">C</b>]}</Example>
```

---

## **2. `JSX.Element`**

üëâ Typ, den der **JSX-Compiler** (`<div>...</div>`) zur√ºckgibt.

* Wird von `React.createElement` erzeugt.
* Ist **genauer** als `ReactNode`.
* Entspricht in der Praxis **einem einzelnen React-Element**.

```tsx
const el: JSX.Element = <h1>Hello</h1>
// el = React.createElement("h1", null, "Hello")
```

---

## **3. `ReactElement`**

üëâ Generischer Typ f√ºr ein Element, erzeugt durch `React.createElement`.

```tsx
const el: React.ReactElement = <button>Klick</button>
```

* Kann generisch spezifiziert werden:

```tsx
const el: React.ReactElement<{ onClick: () => void }> = (
  <button onClick={() => {}}>Klick</button>
)
```

* Typisch in **Bibliotheken und Low-Level-APIs**, seltener in App-Code.

---

## **Vergleichstabelle**

| Typ            | Beschreibung                                   | Beispiel-Einsatz             |
| -------------- | ---------------------------------------------- | ---------------------------- |
| `ReactNode`    | **Alles**, was in JSX gerendert werden kann    | Props: `children: ReactNode` |
| `JSX.Element`  | Ergebnis von JSX-Ausdr√ºcken (`<div>...</div>`) | R√ºckgabewert von Komponenten |
| `ReactElement` | Konkretes React-Element (mit Props & Type)     | Low-Level-APIs, Tests, Libs  |

---

## **4. Typische Verwendung**

* **`ReactNode`** ‚Üí f√ºr `children` (flexibel).
* **`JSX.Element`** ‚Üí f√ºr R√ºckgabewerte von Komponenten.
* **`ReactElement`** ‚Üí f√ºr pr√§zise Typisierung einzelner Elemente.

---

### Zusammenfassung

* **`ReactNode`** = Union aller renderbaren Typen ‚Üí am breitesten.
* **`JSX.Element`** = konkretes JSX-Ergebnis ‚Üí Standard f√ºr `return` einer Komponente.
* **`ReactElement`** = generischer Typ eines React-Elements, inkl. Props.

üîó Quellen:

* [React TypeScript Cheatsheet ‚Äì JSX, ReactNode, ReactElement](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/jsx)
* [React Docs ‚Äì JSX](https://react.dev/learn/writing-markup-with-jsx)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

78. ### <a name="78"></a> Wie typisiert man Events (z. B. onClick, onChange)?

### Events in React mit TypeScript typisieren

React liefert f√ºr jedes DOM-Element eigene **Event-Typen**.
üëâ Diese sind in `@types/react` vordefiniert und basieren auf **`SyntheticEvent`**.

---

## **1. Allgemeiner Typ**

```tsx
import type { SyntheticEvent } from "react"

function handleEvent(e: SyntheticEvent) {
  console.log(e.type) // z. B. "click"
}
```

üëâ Gut f√ºr Basisevents, aber unpr√§zise.

---

## **2. `onClick` ‚Äì Button Klick**

```tsx
import type { MouseEvent } from "react"

function handleClick(e: MouseEvent<HTMLButtonElement>) {
  console.log("Button geklickt:", e.currentTarget)
}

export function App() {
  return <button onClick={handleClick}>Klick mich</button>
}
```

---

## **3. `onChange` ‚Äì Input √§ndern**

```tsx
import type { ChangeEvent } from "react"

function handleChange(e: ChangeEvent<HTMLInputElement>) {
  console.log("Wert:", e.target.value)
}

export function Input() {
  return <input type="text" onChange={handleChange} />
}
```

---

## **4. Formular-Submit**

```tsx
import type { FormEvent } from "react"

function handleSubmit(e: FormEvent<HTMLFormElement>) {
  e.preventDefault()
  console.log("Formular gesendet")
}

export function Form() {
  return <form onSubmit={handleSubmit}><button>Senden</button></form>
}
```

---

## **5. Weitere Beispiele**

* **Mouse Events**:
  `MouseEvent<HTMLDivElement>` ‚Üí `onMouseEnter`, `onMouseLeave`, `onContextMenu`
* **Keyboard Events**:
  `KeyboardEvent<HTMLInputElement>` ‚Üí `onKeyDown`, `onKeyUp`
* **Focus Events**:
  `FocusEvent<HTMLInputElement>` ‚Üí `onFocus`, `onBlur`

```tsx
import type { KeyboardEvent } from "react"

function handleKeyDown(e: KeyboardEvent<HTMLInputElement>) {
  if (e.key === "Enter") console.log("Enter gedr√ºckt")
}
```

---

## **6. Inline-Handler (kurz)**

```tsx
export function Btn() {
  return (
    <button
      onClick={(e: React.MouseEvent<HTMLButtonElement>) => console.log(e.currentTarget)}
    >
      Klick
    </button>
  )
}
```

---

### Zusammenfassung

* Basis: `SyntheticEvent`.
* Genaue Typen: `MouseEvent`, `ChangeEvent`, `KeyboardEvent`, `FormEvent` usw.
* Generische Signatur: `Event<HTMLTagElement>`.
* Faustregel: **Immer den passenden DOM-Typ** einsetzen (z. B. `HTMLInputElement`, `HTMLButtonElement`).

üîó Quellen:

* [React TS Cheatsheet ‚Äì Events](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/event_handling/)
* [MDN ‚Äì DOM Events](https://developer.mozilla.org/ru/docs/Web/Events)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

79. ### <a name="79"></a> Wie typisiert man Refs in React?

### Refs in React mit TypeScript typisieren

Refs werden in React √ºber **`useRef`** oder **`createRef`** erstellt. Mit TypeScript kann man genau angeben, **auf welchen Typ** sie verweisen.

---

## **1. Ref auf DOM-Element**

```tsx
import { useRef, useEffect } from "react"

export function InputFocus() {
  const inputRef = useRef<HTMLInputElement>(null)

  useEffect(() => {
    inputRef.current?.focus()
  }, [])

  return <input ref={inputRef} />
}
```

üëâ Typ: `HTMLInputElement | null`.

---

## **2. Ref auf andere DOM-Elemente**

* `HTMLDivElement`
* `HTMLButtonElement`
* `HTMLTextAreaElement`
* `HTMLCanvasElement` usw.

```tsx
const divRef = useRef<HTMLDivElement>(null)
```

---

## **3. Ref auf einen Wert (Mutable Ref)**

üëâ Wenn man kein DOM-Element, sondern **einen beliebigen Wert** speichern will.

```tsx
const countRef = useRef<number>(0)

function increment() {
  countRef.current += 1
}
```

* Kein `null` n√∂tig ‚Üí direkt `useRef<number>(0)`
* Typ: `MutableRefObject<number>`

---

## **4. `createRef` (meist f√ºr Klassenkomponenten)**

```tsx
import { createRef, Component } from "react"

class MyForm extends Component {
  inputRef = createRef<HTMLInputElement>()

  focusInput = () => {
    this.inputRef.current?.focus()
  }

  render() {
    return <input ref={this.inputRef} />
  }
}
```

---

## **5. Weitergabe von Refs mit `forwardRef`**

```tsx
import { forwardRef } from "react"

type InputProps = { placeholder?: string }

export const CustomInput = forwardRef<HTMLInputElement, InputProps>(
  ({ placeholder }, ref) => <input ref={ref} placeholder={placeholder} />
)

// Nutzung:
import { useRef } from "react"

export function Form() {
  const ref = useRef<HTMLInputElement>(null)
  return <CustomInput ref={ref} placeholder="Name" />
}
```

---

## Zusammenfassung

* DOM-Ref: `useRef<HTMLTagElement>(null)`
* Wert-Ref: `useRef<T>(initialValue)` ‚Üí `MutableRefObject<T>`
* `forwardRef` f√ºr Weitergabe von Refs typisieren mit `forwardRef<HTMLTag, Props>`.
* `createRef` ‚Üí selten, v. a. f√ºr Klassenkomponenten.

üîó Quellen:

* [React TypeScript Cheatsheet ‚Äì Refs](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/hooks/#useref)
* [React Docs ‚Äì Refs](https://react.dev/learn/referencing-values-with-refs)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

80. ### <a name="80"></a> Wie typisiert man State mit useState?

### State mit `useState` typisieren

React‚Äôs **`useState`** ist ein generischer Hook (`useState<S>()`).
üëâ Man kann den Typ explizit angeben oder TypeScript l√§sst ihn **inferen**.

---

## **1. Einfache Typisierung**

```tsx
import { useState } from "react"

export function Counter() {
  const [count, setCount] = useState<number>(0)

  return <button onClick={() => setCount(count + 1)}>{count}</button>
}
```

‚û°Ô∏è `count: number`, `setCount: Dispatch<SetStateAction<number>>`

---

## **2. Typ wird automatisch inferred**

```tsx
const [name, setName] = useState("Sergii")
// Typ: string (kein <string> n√∂tig)
```

---

## **3. Union Types**

```tsx
type Status = "loading" | "success" | "error"

const [status, setStatus] = useState<Status>("loading")

setStatus("success") // ‚úÖ
setStatus("failed")  // ‚ùå Fehler
```

---

## **4. Nullbare Werte**

```tsx
interface User {
  id: number
  name: string
}

const [user, setUser] = useState<User | null>(null)

if (user) {
  console.log(user.name) // sicher
}
```

---

## **5. useState mit Funktion (Lazy Init)**

```tsx
const [expensive, setExpensive] = useState<number>(() => {
  return Math.random() * 1000 // nur einmal beim Mount
})
```

---

## **6. useState mit Objekt**

```tsx
type FormState = {
  username: string
  age: number
}

const [form, setForm] = useState<FormState>({ username: "", age: 0 })

setForm(prev => ({ ...prev, username: "Anna" }))
```

---

### Zusammenfassung

* **`useState<T>()`** ‚Üí Typ explizit oder inferred.
* Union-Typen f√ºr begrenzte Werte (`"success" | "error"`).
* F√ºr optionale Werte: `T | null`.
* Bei Objekten: State-Updates immutabel mit Spread.

üîó Quellen:

* [React TypeScript Cheatsheet ‚Äì useState](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/hooks/#usestate)
* [React Docs ‚Äì useState](https://react.dev/reference/react/useState)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

81. ### <a name="81"></a> Wie typisiert man useReducer?

### `useReducer` in React mit TypeScript typisieren

Der Hook **`useReducer`** ist generisch und erlaubt eine sehr pr√§zise Typisierung von **State** und **Actions**.

---

## **1. Basis-Signatur**

```ts
const [state, dispatch] = useReducer<Reducer<State, Action>>(reducer, initialState)
```

oder einfach:

```ts
const [state, dispatch] = useReducer(reducer, initialState)
```

üëâ TypeScript inferiert die Typen, wenn `reducer` und `initialState` sauber typisiert sind.

---

## **2. Beispiel ‚Äì Counter**

```tsx
import { useReducer } from "react"

// State-Typ
type State = { count: number }

// Action-Typ (Union)
type Action = { type: "increment" } | { type: "decrement" } | { type: "reset"; payload: number }

// Reducer
function reducer(state: State, action: Action): State {
  switch (action.type) {
    case "increment":
      return { count: state.count + 1 }
    case "decrement":
      return { count: state.count - 1 }
    case "reset":
      return { count: action.payload }
    default:
      return state
  }
}

// Nutzung
export function Counter() {
  const [state, dispatch] = useReducer(reducer, { count: 0 })

  return (
    <>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: "increment" })}>+</button>
      <button onClick={() => dispatch({ type: "decrement" })}>-</button>
      <button onClick={() => dispatch({ type: "reset", payload: 10 })}>Reset</button>
    </>
  )
}
```

üëâ `dispatch` ist automatisch auf den Typ `Action` eingeschr√§nkt.

---

## **3. Mit Generics (explizit)**

```tsx
import { useReducer, Reducer } from "react"

type State = { name: string }
type Action = { type: "setName"; payload: string }

const reducer: Reducer<State, Action> = (state, action) => {
  switch (action.type) {
    case "setName":
      return { ...state, name: action.payload }
  }
}

const [state, dispatch] = useReducer(reducer, { name: "Sergii" })
```

---

## **4. Mit komplexeren Payloads**

```tsx
type Todo = { id: number; text: string; done: boolean }

type Action =
  | { type: "add"; payload: string }
  | { type: "toggle"; payload: number }
  | { type: "remove"; payload: number }
```

üëâ Payload-Typen sind individuell je Action.

---

## **5. Lazy Initialization (dritter Parameter)**

```tsx
function init(count: number): State {
  return { count }
}

const [state, dispatch] = useReducer(reducer, 5, init)
// initialisiert mit { count: 5 }
```

---

### Zusammenfassung

* `useReducer` typisiert man mit **State** und **Action**.
* Action-Typen meist als **Discriminated Unions**.
* `dispatch` ist automatisch korrekt typisiert.
* Option f√ºr Lazy Init mit drittem Parameter.

üîó Quellen:

* [React Docs ‚Äì useReducer](https://react.dev/reference/react/useReducer)
* [React TypeScript Cheatsheet ‚Äì useReducer](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/hooks/#usereducer)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

82. ### <a name="82"></a> Wie typisiert man useRef mit initial null?

### `useRef` mit initial `null` typisieren

In React ist ein **DOM-Ref** oder ein **nullable Ref** typisch ‚Üí `T | null`.

---

## **1. Ref auf DOM-Element**

```tsx
import { useRef, useEffect } from "react"

export function InputFocus() {
  // HTMLInputElement | null
  const inputRef = useRef<HTMLInputElement>(null)

  useEffect(() => {
    inputRef.current?.focus()
  }, [])

  return <input ref={inputRef} />
}
```

üëâ `inputRef.current` hat den Typ `HTMLInputElement | null`.

---

## **2. Ref auf generische Werte**

```tsx
const timerRef = useRef<number | null>(null)

function startTimer() {
  timerRef.current = window.setTimeout(() => {
    console.log("Timer!")
  }, 1000)
}

function clearTimer() {
  if (timerRef.current !== null) {
    clearTimeout(timerRef.current)
  }
}
```

---

## **3. Unterschied: `useRef<T>(null)` vs. `useRef<T | null>(null)`**

* **`useRef<T>(null)`** ‚Üí Fehler, weil `null` nicht `T` ist.
* **`useRef<T | null>(null)`** ‚Üí korrekt, `current` kann `null` sein.

---

## **4. Zugriff absichern**

```tsx
if (inputRef.current) {
  inputRef.current.value = "Hallo"
}
```

oder mit **Optional Chaining**:

```tsx
inputRef.current?.focus()
```

---

### Zusammenfassung

* F√ºr DOM-Elemente: `useRef<HTMLDivElement | null>(null)`.
* F√ºr Werte: `useRef<T | null>(null)`.
* Immer `| null` hinzuf√ºgen, da beim Initialisieren `null` gesetzt wird.
* Zugriff absichern mit `if` oder `?.`.

üîó Quellen:

* [React Docs ‚Äì Refs](https://react.dev/learn/referencing-values-with-refs)
* [React TS Cheatsheet ‚Äì useRef](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/hooks/#useref)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

83. ### <a name="83"></a> Wie typisiert man einen Custom Hook?

### Custom Hook in TypeScript typisieren

---

## 1) Einfacher Hook (R√ºckgabetyp inferieren lassen)

```js
import { useEffect, useState } from "react"

export function useOnline() {
  const [online, setOnline] = useState<boolean>(navigator.onLine)

  useEffect(() => {
    const on = () => setOnline(true)
    const off = () => setOnline(false)
    window.addEventListener("online", on)
    window.addEventListener("offline", off)
    return () => {
      window.removeEventListener("online", on)
      window.removeEventListener("offline", off)
    }
  }, [])

  return online // boolean
}
```

---

## 2) Hook mit explizitem R√ºckgabetyp (Objekt / Tupel)

```js
import { useCallback, useState } from "react"

type Counter = {
  count: number
  inc: () => void
  dec: () => void
  reset: () => void
}

export function useCounter(initial = 0): Counter {
  const [count, setCount] = useState<number>(initial)
  const inc = useCallback(() => setCount((c) => c + 1), [])
  const dec = useCallback(() => setCount((c) => c - 1), [])
  const reset = useCallback(() => setCount(initial), [initial])
  return { count, inc, dec, reset }
}
```

```js
// Tupel-Variante
import { useState } from "react"

export function useToggle(initial = false): [boolean, () => void] {
  const [on, setOn] = useState<boolean>(initial)
  return [on, () => setOn((v) => !v)]
}
```

---

## 3) Generischer Hook (mit Constraints)

```js
import { useMemo } from "react"

export function usePick<T extends object, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> {
  return useMemo(() => {
    const out = {} as Pick<T, K>
    for (const k of keys) out[k] = obj[k]
    return out
  }, [obj, keys.join("|")])
}

// Nutzung
const user = { id: 1, name: "Sergii", admin: true }
const partial = usePick(user, ["id", "name"]) // Typ: { id: number; name: string }
```

---

## 4) Hook, der Promise-Status kapselt (Union/Discriminated Union)

```js
import { useEffect, useState } from "react"

type AsyncState<T> =
  | { status: "idle" }
  | { status: "loading" }
  | { status: "success"; data: T }
  | { status: "error"; error: Error }

export function useAsync<T>(fn: () => Promise<T>, deps: unknown[] = []) {
  const [state, setState] = useState<AsyncState<T>>({ status: "idle" })

  useEffect(() => {
    let alive = true
    setState({ status: "loading" })
    fn()
      .then((data) => alive && setState({ status: "success", data }))
      .catch((error) => alive && setState({ status: "error", error }))
    return () => { alive = false }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, deps)

  return state
}
```

---

## 5) Hook mit Ref im R√ºckgabewert

```js
import { useEffect, useRef } from "react"

export function useFocus<T extends HTMLElement>() {
  const ref = useRef<T | null>(null)
  useEffect(() => { ref.current?.focus() }, [])
  return ref // RefObject<T | null>
}
```

---

## 6) Typ-Tipps

* Parameter und R√ºckgabewert klar typisieren; bei einfachen F√§llen **Inference** nutzen.
* F√ºr Tupel-R√ºckgaben **exakten Tupeltyp** angeben (`[T, U]`).
* Bei generischen Hooks **Constraints** setzen (`<T extends object>`).
* F√ºr `null`-bare Werte explizit `| null`.
* F√ºr komplexe Status **discriminated unions** nutzen.

---

### Zusammenfassung

* Custom Hooks sind normale Funktionen: **Parameter- & R√ºckgabetyp** angeben; bei Bedarf **Generics** und **Unions** einsetzen.
* Tupel oder Objekt als R√ºckgabewert klar typisieren.
* Refs als `RefObject<T | null>`, asynchrone Zust√§nde √ºber **discriminated unions**.

**Quellen:**

* [React Docs ‚Äì Reusing Logic with Custom Hooks](https://react.dev/learn/reusing-logic-with-custom-hooks)
* [React TypeScript Cheatsheet ‚Äì Hooks & Patterns](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/hooks/)
* [TypeScript Handbook ‚Äì Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

84. ### <a name="84"></a> Wie typisiert man Komponenten mit forwardRef?

### Komponenten mit `forwardRef` typisieren (TypeScript + React)

---

## **1. Grundsyntax**

`forwardRef` ist ein **Generic**: `forwardRef<T, P>`

* **`T`** = Typ des Referenz-Elements (z. B. `HTMLInputElement`)
* **`P`** = Typ der Props

```tsx
import { forwardRef } from "react"

type InputProps = {
  label: string
}

export const Input = forwardRef<HTMLInputElement, InputProps>(
  ({ label, ...props }, ref) => (
    <label>
      {label}
      <input ref={ref} {...props} />
    </label>
  )
)

// Nutzung
import { useRef } from "react"

export function Form() {
  const inputRef = useRef<HTMLInputElement>(null)
  return <Input ref={inputRef} label="Name" />
}
```

---

## **2. Mit optionalen Props + `children`**

```tsx
type ButtonProps = {
  children: React.ReactNode
  onClick?: () => void
}

export const Button = forwardRef<HTMLButtonElement, ButtonProps>(
  ({ children, onClick }, ref) => (
    <button ref={ref} onClick={onClick}>
      {children}
    </button>
  )
)
```

---

## **3. Generischer Typ in `forwardRef`**

```tsx
type ListProps<T> = {
  items: T[]
  render: (item: T) => JSX.Element
}

function ListInner<T>(
  { items, render }: ListProps<T>,
  ref: React.Ref<HTMLUListElement>
) {
  return <ul ref={ref}>{items.map(render)}</ul>
}

export const List = forwardRef(ListInner) as <T>(
  props: ListProps<T> & { ref?: React.Ref<HTMLUListElement> }
) => JSX.Element

// Nutzung
<List items={[1, 2, 3]} render={(i) => <li>{i}</li>} />
```

---

## **4. Mit `useImperativeHandle` (Custom Ref API)**

```tsx
import { forwardRef, useImperativeHandle, useRef } from "react"

type FocusInputHandle = {
  focus: () => void
}

export const FocusInput = forwardRef<FocusInputHandle, {}>((_, ref) => {
  const inputRef = useRef<HTMLInputElement>(null)

  useImperativeHandle(ref, () => ({
    focus: () => inputRef.current?.focus(),
  }))

  return <input ref={inputRef} />
})

// Nutzung
export function App() {
  const ref = useRef<FocusInputHandle>(null)
  return (
    <>
      <FocusInput ref={ref} />
      <button onClick={() => ref.current?.focus()}>Fokus setzen</button>
    </>
  )
}
```

---

### Zusammenfassung

* `forwardRef<T, P>` ‚Üí `T` = Ref-Element-Typ, `P` = Props.
* R√ºckgabe: `JSX.Element`.
* Mit `useImperativeHandle` ‚Üí eigene Methoden im Ref freigeben.
* F√ºr Generics ‚Üí `as`-Casting notwendig.

üîó Quellen:

* [React Docs ‚Äì forwardRef](https://react.dev/reference/react/forwardRef)
* [React TypeScript Cheatsheet ‚Äì forwardRef](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/forms_and_events/#forwardref-createref)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

85. ### <a name="85"></a> Wie typisiert man Context (React Context API)?

### React Context API mit TypeScript typisieren

---

## **1. Einfacher Context (nicht nullbar)**

```tsx
import { createContext, useContext } from "react"

type Theme = "light" | "dark"

const ThemeContext = createContext<Theme>("light")

export function useTheme() {
  return useContext(ThemeContext)
}

// Nutzung
export function App() {
  return (
    <ThemeContext.Provider value="dark">
      <Child />
    </ThemeContext.Provider>
  )
}

function Child() {
  const theme = useTheme()
  return <p>Aktuelles Theme: {theme}</p>
}
```

üëâ Typ des Context-Werts: `Theme`.

---

## **2. Context mit `null` als Default**

‚ö†Ô∏è H√§ufig: Provider setzt sp√§ter einen Wert ‚Üí Default = `null`.

```tsx
type AuthContextValue = {
  user: string
  login: (name: string) => void
}

const AuthContext = createContext<AuthContextValue | null>(null)

export function useAuth() {
  const ctx = useContext(AuthContext)
  if (!ctx) throw new Error("useAuth muss innerhalb von AuthProvider genutzt werden")
  return ctx
}

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const login = (name: string) => console.log("Login:", name)
  return (
    <AuthContext.Provider value={{ user: "Sergii", login }}>
      {children}
    </AuthContext.Provider>
  )
}
```

---

## **3. Context mit State (useState + Context)**

```tsx
import { useState } from "react"

type CounterContextValue = {
  count: number
  setCount: React.Dispatch<React.SetStateAction<number>>
}

const CounterContext = createContext<CounterContextValue | null>(null)

export function CounterProvider({ children }: { children: React.ReactNode }) {
  const [count, setCount] = useState(0)
  return (
    <CounterContext.Provider value={{ count, setCount }}>
      {children}
    </CounterContext.Provider>
  )
}

export function useCounter() {
  const ctx = useContext(CounterContext)
  if (!ctx) throw new Error("useCounter muss in CounterProvider genutzt werden")
  return ctx
}
```

---

## **4. Context mit Generics (z. B. Repository Pattern)**

```tsx
type RepoContext<T> = {
  items: T[]
  add: (item: T) => void
}

function createRepoContext<T>() {
  return createContext<RepoContext<T> | null>(null)
}

const UserRepoContext = createRepoContext<{ id: number; name: string }>()
```

---

### Zusammenfassung

* Context wird mit `createContext<T>()` erstellt.
* Default-Wert ‚Üí entweder **konkreter Wert** oder **`null`**.
* Mit `null` ‚Üí immer Custom Hook bauen, der `useContext` kapselt + Fehler wirft.
* Typisch: `Context + Provider + useXyz-Hook`.
* Mit Generics ‚Üí wiederverwendbare Contexts m√∂glich.

üîó Quellen:

* [React Docs ‚Äì Context](https://react.dev/reference/react/createContext)
* [React TypeScript Cheatsheet ‚Äì Context](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/context/)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

86. ### <a name="86"></a> Wie typisiert man HOCs (Higher-Order Components)?

### HOCs (Higher-Order Components) typisieren

**Definition:**
Ein HOC ist eine Funktion, die eine Komponente **entgegennimmt** und eine **neue Komponente zur√ºckgibt**. In TypeScript nutzt man Generics, um die **Props des Wrapped Components** zu erhalten und ggf. **injizierte Props** nach au√üen zu entfernen.

---

## 1) Basis-HOC (ohne Prop-√Ñnderung)

```js
import type { ComponentType } from "react"

export function withLogger<P>(Wrapped: ComponentType<P>) {
  return function ComponentWithLogger(props: P) {
    console.log("props:", props)
    return <Wrapped {...props} />
  }
}
```

* `P` repr√§sentiert die Props des Wrapped Components.
* R√ºckgabe akzeptiert **die gleichen Props** wie `Wrapped`.

---

## 2) HOC mit **injizierten Props** (nach au√üen entfernen)

```js
import type { ComponentType } from "react"

type Injected = { user: { id: number; name: string } }

export function withUser<P extends Injected>(
  Wrapped: ComponentType<P>
) {
  // nach au√üen entferne "user", weil HOC ihn liefert
  type OuterProps = Omit<P, keyof Injected>

  return function WithUser(props: OuterProps) {
    const injected: Injected = { user: { id: 1, name: "Sergii" } }
    return <Wrapped {...(props as P)} {...injected} />
  }
}

// Nutzung
type ProfileProps = { user: { id: number; name: string }; editable?: boolean }
function Profile({ user, editable }: ProfileProps) {
  return <div>{user.name} {editable ? "(edit)" : ""}</div>
}
export const ProfileWithUser = withUser(Profile)
// <ProfileWithUser editable />  // ‚úÖ user wird vom HOC gesetzt
```

* **Wichtig:** `P extends Injected` und `OuterProps = Omit<P, keyof Injected>`.

---

## 3) HOC, der Props transformiert (z. B. Loading)

```js
import type { ComponentType } from "react"

type WithLoadingProps = { loading: boolean }

export function withLoading<P>(
  Wrapped: ComponentType<P>
) {
  return function WithLoading(props: P & WithLoadingProps) {
    if (props.loading) return <span>L√§dt‚Ä¶</span>
    const { loading, ...rest } = props as WithLoadingProps & P
    return <Wrapped {...(rest as P)} />
  }
}
```

* HOC **erweitert** die √§u√üeren Props um `loading`.

---

## 4) HOC + `forwardRef` (Ref durchleiten)

```js
import { forwardRef } from "react"
import type { ComponentType, Ref } from "react"

export function withRef<P, T>(Wrapped: ComponentType<P & { ref?: Ref<T> }>) {
  // √§u√üere Props sollen die internen "ref"-Props nicht enthalten
  type OuterProps = P

  const Component = (props: OuterProps, ref: Ref<T>) => {
    return <Wrapped {...props} ref={ref} />
  }

  return forwardRef<T, OuterProps>(Component)
}

// Beispiel: DOM-Ref auf <input>
type InputProps = { placeholder?: string }
const RawInput = (p: InputProps, ref: Ref<HTMLInputElement>) => (
  <input ref={ref} {...p} />
)
const Input = forwardRef<HTMLInputElement, InputProps>(RawInput)

export const InputWithRef = withRef<InputProps, HTMLInputElement>(Input)
// Nutzung: const r = useRef<HTMLInputElement>(null); <InputWithRef ref={r} />
```

---

## 5) Statische Eigenschaften ‚Äûhoisten‚Äú

HOCs verlieren i. d. R. **statische Properties** des Wrapped Components.
‚Üí In Bibliotheken nutzt man oft `hoist-non-react-statics`, um sie zu kopieren.
*(Tipp f√ºrs Interview erw√§hnen, Code hier weggelassen.)*

---

## 6) Typ-Tipps & Fallstricke

* Verwende **`ComponentType<P>`** statt `FC<P>`, um auch Klassenkomponenten zu unterst√ºtzen.
* F√ºr injizierte Props immer **`Omit`** nach au√üen nutzen.
* Bei Refs: HOC mit **`forwardRef`** typisieren (siehe oben).
* Bei generischen Wrapped Components ggf. explizit casten (Constraint auf `P` setzen).

---

### Zusammenfassung

* HOCs mit Generics: `function withX<P>(Comp: ComponentType<P>) => (props: P|Omit<P,‚Ä¶>) => JSX.Element`.
* **Injected Props** nach au√üen mit `Omit` entfernen.
* **Refs** via `forwardRef<T, P>` korrekt weiterreichen.
* Optional: **statische Properties hoisten** (Lib-Nennung reicht im Interview).

**Quellen:**

* [React TypeScript Cheatsheet ‚Äì HOCs](https://react-typescript-cheatsheet.netlify.app/docs/hoc/react_hoc_docs/)
* [React Offizielle Doku ‚Äì HOCs (Konzept)](https://react.dev/learn/reusing-logic-with-custom-hooks)
* [TypeScript Handbook ‚Äì Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)

**Zusammenfassung:**
HOCs typisiert man generisch √ºber `ComponentType<P>`, entfernt **injizierte Props** per `Omit`, leitet **Refs** mit `forwardRef` durch und achtet bei Bedarf aufs **Hoisten statischer Properties**.

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

87. ### <a name="87"></a> Wie typisiert man asynchrone Funktionen in React-Komponenten?

### Asynchrone Funktionen in React-Komponenten typisieren

---

## 1) Async-Eventhandler: immer `Promise<void>`

```js
import type { MouseEvent, FormEvent, ChangeEvent } from "react"

export function Actions() {
  const onClick = async (e: MouseEvent<HTMLButtonElement>): Promise<void> => {
    e.preventDefault()
    await fetch("/api/click")
  }

  const onSubmit = async (e: FormEvent<HTMLFormElement>): Promise<void> => {
    e.preventDefault()
    // ‚Ä¶
  }

  const onChange = async (e: ChangeEvent<HTMLInputElement>): Promise<void> => {
    // ‚Ä¶
  }

  return (
    <form onSubmit={onSubmit}>
      <input onChange={onChange} />
      <button onClick={onClick}>Senden</button>
      <button type="submit">Submit</button>
    </form>
  )
}
```

**Faustregel:** UI-Handler `async` ‚Üí R√ºckgabetyp **`Promise<void>`**.

---

## 2) Async mit `useCallback`

```js
import { useCallback, useState } from "react"

export function Loader() {
  const [data, setData] = useState<string | null>(null)
  const [error, setError] = useState<Error | null>(null)
  const [loading, setLoading] = useState(false)

  const load = useCallback(async (): Promise<void> => {
    try {
      setLoading(true)
      const res = await fetch("/api/text")
      const text = await res.text()
      setData(text)
    } catch (e) {
      setError(e as Error)
    } finally {
      setLoading(false)
    }
  }, [])

  return <button onClick={load} disabled={loading}>{loading ? "‚Ä¶" : "Laden"}</button>
}
```

---

## 3) Async Funktionen mit R√ºckgabewert

```js
async function getUser(): Promise<{ id: number; name: string }> {
  const res = await fetch("/api/user")
  return res.json()
}

export function Profile() {
  // Nutzung: R√ºckgabetyp ist Promise<{ id; name }>
  // In Handlern weiterhin Promise<void> zur√ºckgeben:
  const handle = async (): Promise<void> => {
    const user = await getUser()
    console.log(user.name)
  }
  return <button onClick={handle}>Profil laden</button>
}
```

---

## 4) Async Props (Funktionen als Props)

```js
type SaveFn = (payload: { id: number }) => Promise<void>

export function SaveButton({ onSave }: { onSave: SaveFn }) {
  const handle = async (): Promise<void> => {
    await onSave({ id: 1 })
  }
  return <button onClick={handle}>Speichern</button>
}
```

---

## 5) Abbrechen mit `AbortController` (typisiert)

```js
export function Fetcher() {
  const handle = async (): Promise<void> => {
    const controller = new AbortController()
    const id = setTimeout(() => controller.abort(), 3000)
    try {
      const res = await fetch("/api/data", { signal: controller.signal })
      await res.json()
    } finally {
      clearTimeout(id)
    }
  }
  return <button onClick={handle}>Fetch (3s Timeout)</button>
}
```

---

## 6) Typische Fehler vermeiden

* **Kein ungetyptes `any`**: Ergebnis immer mit **`Promise<T>`** annotieren.
* **Eventtypen korrekt** (`MouseEvent<HTMLButtonElement>`, `FormEvent<HTMLFormElement>`, ‚Ä¶).
* **State-Typen** pr√§zise halten (`T | null`, Discriminated Unions f√ºr Lade/Error-Status).
* **Handler** sollen keine Werte returnen, die React ignoriert ‚Üí `Promise<void>`.

---

### Zusammenfassung

* Eventhandler als `async` ‚Üí **`Promise<void>`** + passender **React-Eventtyp**.
* Datenfunktionen geben **`Promise<T>`** zur√ºck; Handler nutzen sie und bleiben bei `Promise<void>`.
* `useCallback` f√ºr stabile Referenzen; Fehler/Loading in State modellieren.
* Abbrechen √ºber **`AbortController`** korrekt typisieren.

**Quellen:**

* [React Docs ‚Äì Events & Handlers](https://react.dev/learn/responding-to-events)
* [React TypeScript Cheatsheet ‚Äì Event Handling & Hooks](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/event_handling/)
* [TypeScript Docs ‚Äì Promises & async/await](https://www.typescriptlang.org/docs/handbook/2/functions.html#async-functions)
* [MDN ‚Äì AbortController](https://developer.mozilla.org/ru/docs/Web/API/AbortController)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

88. ### <a name="88"></a> Wie typisiert man Event-Handler in Formularen?

### Event-Handler in Formularen typisieren (React + TypeScript)

React nutzt **synthetische Events** (`SyntheticEvent`) mit spezifischen Subtypen f√ºr Formulareingaben.
üëâ Immer den **richtigen DOM-Typ** mitgeben (`HTMLFormElement`, `HTMLInputElement`, `HTMLSelectElement` ‚Ä¶).

---

## **1. Formular-Submit (`onSubmit`)**

```tsx
import type { FormEvent } from "react"

function Form() {
  const handleSubmit = (e: FormEvent<HTMLFormElement>): void => {
    e.preventDefault()
    console.log("Formular gesendet")
  }

  return (
    <form onSubmit={handleSubmit}>
      <button type="submit">Senden</button>
    </form>
  )
}
```

---

## **2. Input-Felder (`onChange`)**

```tsx
import type { ChangeEvent } from "react"

function TextInput() {
  const handleChange = (e: ChangeEvent<HTMLInputElement>): void => {
    console.log("Neuer Wert:", e.target.value)
  }

  return <input type="text" onChange={handleChange} />
}
```

---

## **3. Select (`onChange`)**

```tsx
function SelectBox() {
  const handleChange = (e: React.ChangeEvent<HTMLSelectElement>): void => {
    console.log("Gew√§hlt:", e.target.value)
  }

  return (
    <select onChange={handleChange}>
      <option value="a">A</option>
      <option value="b">B</option>
    </select>
  )
}
```

---

## **4. Textarea (`onChange`)**

```tsx
function TextArea() {
  const handleChange = (e: React.ChangeEvent<HTMLTextAreaElement>): void => {
    console.log("Text:", e.target.value)
  }

  return <textarea onChange={handleChange} />
}
```

---

## **5. Checkbox & Radio (`onChange`)**

```tsx
function Checkbox() {
  const handleCheck = (e: React.ChangeEvent<HTMLInputElement>): void => {
    console.log("Checked:", e.target.checked)
  }

  return <input type="checkbox" onChange={handleCheck} />
}
```

---

## **6. Generische Variante**

Falls man den Typ nicht kennt:

```tsx
function GenericHandler() {
  const handle = (e: React.SyntheticEvent): void => {
    console.log(e.type)
  }

  return <form onSubmit={handle}></form>
}
```

üëâ Besser immer pr√§zise statt `SyntheticEvent`.

---

### Zusammenfassung

* **`FormEvent<HTMLFormElement>`** ‚Üí f√ºr `onSubmit`.
* **`ChangeEvent<HTMLInputElement>`** ‚Üí Text, Checkbox, Radio.
* **`ChangeEvent<HTMLSelectElement>`** ‚Üí Select.
* **`ChangeEvent<HTMLTextAreaElement>`** ‚Üí Textarea.
* Faustregel: **`ChangeEvent<T>`**, wobei `T` = konkretes HTML-Element.

üîó Quellen:

* [React TypeScript Cheatsheet ‚Äì Events](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/event_handling/)
* [React Docs ‚Äì Form Handling](https://react.dev/learn/managing-state#updating-state-based-on-input-fields)

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

89. ### <a name="89"></a> Wie typisiert man API-Requests und Responses?

### API-Requests und -Responses typisieren (TypeScript + Fetch/Axios)

---

## 1) DTOs (Request/Response-Modelle) definieren

```js
// types.ts
export type CreateUserReq = {
  name: string
  email: string
}

export type User = {
  id: number
  name: string
  email: string
}

export type ApiError = {
  status: number
  message: string
}
```

---

## 2) `fetch`-Wrapper mit Generics (`Promise<T>`)

```js
// api.ts
export async function apiGet<T>(url: string, init?: RequestInit): Promise<T> {
  const res = await fetch(url, { ...init, method: "GET" })
  if (!res.ok) {
    throw { status: res.status, message: res.statusText } // ApiError-√§hnlich
  }
  const data: unknown = await res.json()
  return data as T // besser: runtime-validate, siehe unten
}

export async function apiPost<TReq, TRes>(url: string, body: TReq, init?: RequestInit): Promise<TRes> {
  const res = await fetch(url, {
    method: "POST",
    headers: { "Content-Type": "application/json", ...(init?.headers ?? {}) },
    body: JSON.stringify(body),
    ...init
  })
  if (!res.ok) {
    throw { status: res.status, message: await res.text() }
  }
  const data: unknown = await res.json()
  return data as TRes
}
```

**Verwendung:**

```js
import { apiGet, apiPost } from "./api.js"
import type { CreateUserReq, User } from "./types.js"

const user = await apiGet<User>("/api/user/1")
const created = await apiPost<CreateUserReq, User>("/api/users", { name: "Sergii", email: "s@ex.com" })
```

---

## 3) Axios mit Generics

```js
import axios from "axios"
import type { CreateUserReq, User } from "./types.js"

export async function getUser(id: number) {
  const res = await axios.get<User>(`/api/users/${id}`)
  return res.data // User
}

export async function createUser(dto: CreateUserReq) {
  const res = await axios.post<User>("/api/users", dto)
  return res.data // User
}
```

---

## 4) Runtime-Validierung (Zod) statt blindem `as`

```js
import { z } from "zod"

export const UserSchema = z.object({
  id: z.number(),
  name: z.string(),
  email: z.string().email()
})
export type User = z.infer<typeof UserSchema>

export async function safeGetUser(id: number): Promise<User> {
  const res = await fetch(`/api/users/${id}`)
  if (!res.ok) throw new Error("HTTP " + res.status)
  const json: unknown = await res.json()
  return UserSchema.parse(json) // ‚úÖ Laufzeit-Check + Typ
}
```

---

## 5) API-Status als Discriminated Union (f√ºr UI-States)

```js
export type ApiState<T> =
  | { status: "idle" }
  | { status: "loading" }
  | { status: "success"; data: T }
  | { status: "error"; error: string }
```

```js
import { useEffect, useState } from "react"
import type { User } from "./types.js"

export function useUser(id: number) {
  const [state, setState] = useState<ApiState<User>>({ status: "idle" })

  useEffect(() => {
    let alive = true
    setState({ status: "loading" })
    fetch(`/api/users/${id}`)
      .then(r => r.json())
      .then((j: unknown) => {
        // hier idealerweise Zod-Parse
        if (alive) setState({ status: "success", data: j as User })
      })
      .catch(e => alive && setState({ status: "error", error: String(e) }))
    return () => { alive = false }
  }, [id])

  return state
}
```

---

## 6) Pagination/Envelope-Typen

```js
export type Page<T> = {
  items: T[]
  total: number
  page: number
  pageSize: number
}

const page = await apiGet<Page<User>>("/api/users?page=1&pageSize=20")
```

---

## 7) Endpunkt-Map (sicher via `satisfies`)

```js
export const endpoints = {
  getUser: { path: (id: number) => `/api/users/${id}`, method: "GET" },
  createUser: { path: () => "/api/users", method: "POST" }
} as const satisfies Record<string, { path: (...a: any[]) => string; method: "GET" | "POST" }>
```

---

## 8) Fehler-Typen & Narrowing

```js
try {
  const data = await apiGet<User>("/api/user/1")
} catch (e) {
  const err = e as { status?: number; message?: string }
  console.error(err.status ?? 0, err.message ?? "Unknown")
}
```

---

## 9) Request-Bodies typisieren (FormData/Query)

```js
export type SearchParams = { q: string; limit?: number }

export function toQuery(params: SearchParams): string {
  const usp = new URLSearchParams()
  usp.set("q", params.q)
  if (params.limit != null) usp.set("limit", String(params.limit))
  return usp.toString()
}
```

---

### Zusammenfassung

* **DTOs** f√ºr Requests/Responses definieren; **Generics** nutzen (`apiGet<T>`, Axios `<T>`).
* Responses nie als `any` akzeptieren ‚Üí **Runtime-Validation** (z. B. **Zod**) ist best practice.
* UI-Status via **Discriminated Union** modellieren.
* **Envelope-/Pagination-Typen** standardisieren; **satisfies** f√ºr Endpoint-Maps.
* Fehler konsequent typisieren und per **Narrowing** behandeln.

**Quellen:**

* [TypeScript Docs ‚Äì Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
* [TypeScript Docs ‚Äì Utility Types](https://www.typescriptlang.org/docs/handbook/utility-types.html)
* [React TypeScript Cheatsheet ‚Äì Basic/Typing Functions & Hooks](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/)
* [MDN ‚Äì Fetch API](https://developer.mozilla.org/ru/docs/Web/API/Fetch_API)
* [React Docs](https://react.dev/)

**Zusammenfassung:**
Typisierte API-Kommunikation = **Generics f√ºr Fetch/Axios**, **DTO-Typen**, **Runtime-Validation (Zod)**, **Union-Status** f√ºr UI und sauberes **Error-Handling**.


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

90. ### <a name="90"></a> Wie typisiert man React-Router-Komponenten?

### React Router mit TypeScript typisieren (v6.4+)

---

## 1) `useParams`

```js
import { useParams } from "react-router-dom"

// Generics definieren NUR die Param-Namen, Werte bleiben string | undefined
type Params = { id: string }

export function UserPage() {
  const { id } = useParams<Params>() // id: string | undefined
  if (!id) return <p>Kein ID-Parameter</p>
  return <h1>User {id}</h1>
}
```

**Sicherer mit Assertion/Narrowing:**

```js
function assertString(v: unknown): asserts v is string {
  if (typeof v !== "string") throw new Error("Expected string")
}

const { id } = useParams<{ id: string }>()
assertString(id) // ab hier: id: string
```

---

## 2) `useSearchParams`

```js
import { useSearchParams } from "react-router-dom"

export function List() {
  const [sp, setSp] = useSearchParams()
  const page = Number(sp.get("page") ?? "1") // page: number
  // setSp(prev => { prev.set("page", String(page+1)); return prev })
  return <div>Seite {page}</div>
}
```

---

## 3) `useNavigate`

```js
import { useNavigate } from "react-router-dom"

export function BackButton() {
  const navigate = useNavigate()
  return <button onClick={() => navigate(-1)}>Zur√ºck</button>
}
```

---

## 4) Route-Objekte, Loader & Actions (Data Router)

```js
import { createBrowserRouter, RouterProvider } from "react-router-dom"

type User = { id: number; name: string }

async function usersLoader(): Promise<User[]> {
  const res = await fetch("/api/users")
  return res.json() // besser mit Zod validieren
}

function Users() {
  return <UsersList />
}

const router = createBrowserRouter([
  {
    path: "/users",
    element: <Users />,
    loader: usersLoader,
  }
])

export default function App() {
  return <RouterProvider router={router} />
}
```

**Loader-Daten konsumieren:**

```js
import { useLoaderData } from "react-router-dom"

export function UsersList() {
  const users = useLoaderData() as User[] // oder: useLoaderData<User[]>()
  return <ul>{users.map(u => <li key={u.id}>{u.name}</li>)}</ul>
}
```

---

## 5) `useRouteError` (Fehler typisieren)

```js
import { isRouteErrorResponse, useRouteError } from "react-router-dom"

export function ErrorBoundary() {
  const err = useRouteError()
  if (isRouteErrorResponse(err)) {
    return <p>HTTP {err.status}: {err.statusText}</p>
  }
  return <p>Unbekannter Fehler</p>
}
```

---

## 6) `Outlet`-Context typisieren

```js
import { Outlet, useOutletContext } from "react-router-dom"

type LayoutCtx = { locale: "de" | "en" }

export function Layout() {
  const ctx: LayoutCtx = { locale: "de" }
  return <Outlet context={ctx} />
}

export function Child() {
  const { locale } = useOutletContext<LayoutCtx>()
  return <p>Sprache: {locale}</p>
}
```

---

## 7) `Link`/`NavLink` (Props sind bereits typisiert)

```js
import { Link, NavLink } from "react-router-dom"

export function Nav() {
  return (
    <nav>
      <NavLink to="/users">Users</NavLink>
      <Link to={{ pathname: "/search", search: "?q=ts" }}>Suche</Link>
    </nav>
  )
}
```

---

## 8) Routen-Definitionen als Typhilfe (optional)

```js
const routes = {
  user: (id: string) => `/users/${id}`,
  search: (q: string) => `/search?q=${encodeURIComponent(q)}`
} as const

type AppRoutes = typeof routes
// routes.user("42") // string (typsicher konstruiert)
```

---

## 9) Zod/Runtime-Validation f√ºr Param/Suchwerte (Best Practice)

```js
import { z } from "zod"
const PageSchema = z.coerce.number().int().positive().default(1)

const [sp] = useSearchParams()
const page = PageSchema.parse(sp.get("page")) // number sicher validiert
```

---

### Zusammenfassung

* `useParams<Params>`: Generics definieren Schl√ºssel; Werte bleiben `string | undefined` ‚Üí per Assertion/Narrowing absichern.
* Data Router: Loader/Action **R√ºckgabewerte** typisieren und mit `useLoaderData<T>()` konsumieren.
* `useRouteError`, `useOutletContext<T>()`, `useNavigate`, `useSearchParams` sind bereits TS-typisiert.
* F√ºr robuste Apps: **Runtime-Validation** (z. B. Zod) bei Params/Query/Loader-Daten.

**Quellen**

* [React Router Docs ‚Äì TypeScript](https://reactrouter.com/en/main/guides/typescript)
* [React Offizielle Doku](https://react.dev/)
* [TypeScript Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
* [React TypeScript Cheatsheet ‚Äì Router](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/react_router/)

**Zusammenfassung**
React Router in TS: Params `string | undefined`, Loader per `useLoaderData<T>`, Fehler via `useRouteError`, Outlet-Kontext mit `useOutletContext<T>()`, Query √ºber `useSearchParams`; bei Bedarf Zod einsetzen.

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

91. ### <a name="91"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

92. ### <a name="92"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

93. ### <a name="93"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

94. ### <a name="94"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

95. ### <a name="95"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

96. ### <a name="96"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

97. ### <a name="97"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

98. ### <a name="98"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

99. ### <a name="99"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

100. ### <a name="100"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**    

101. ### <a name="101"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

102. ### <a name="102"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

103. ### <a name="103"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

104. ### <a name="104"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

105. ### <a name="105"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

106. ### <a name="106"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

107. ### <a name="107"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

108. ### <a name="108"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

109. ### <a name="109"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

110. ### <a name="110"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

111. ### <a name="111"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

112. ### <a name="112"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

113. ### <a name="113"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

114. ### <a name="114"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

115. ### <a name="115"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

116. ### <a name="116"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

117. ### <a name="117"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

118. ### <a name="118"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

119. ### <a name="119"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

120. ### <a name="120"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

121. ### <a name="121"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

122. ### <a name="122"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

123. ### <a name="123"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

124. ### <a name="124"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

125. ### <a name="125"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

126. ### <a name="126"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

127. ### <a name="127"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

128. ### <a name="128"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

129. ### <a name="129"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

130. ### <a name="130"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

131. ### <a name="131"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

132. ### <a name="132"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

133. ### <a name="133"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

134. ### <a name="134"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

135. ### <a name="135"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

136. ### <a name="136"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

137. ### <a name="137"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

138. ### <a name="138"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

139. ### <a name="139"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

140. ### <a name="140"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

141. ### <a name="141"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

142. ### <a name="142"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

143. ### <a name="143"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

144. ### <a name="144"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

145. ### <a name="145"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

146. ### <a name="146"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

147. ### <a name="147"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

148. ### <a name="148"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

149. ### <a name="149"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

150. ### <a name="150"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

151. ### <a name="151"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

152. ### <a name="152"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

153. ### <a name="153"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

154. ### <a name="154"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

155. ### <a name="155"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

156. ### <a name="156"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

157. ### <a name="157"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

158. ### <a name="158"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

159. ### <a name="159"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

160. ### <a name="160"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

161. ### <a name="161"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

162. ### <a name="162"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

163. ### <a name="163"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

164. ### <a name="164"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

165. ### <a name="165"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

166. ### <a name="166"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

167. ### <a name="167"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

168. ### <a name="168"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

169. ### <a name="169"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

170. ### <a name="170"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

171. ### <a name="171"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

172. ### <a name="172"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

173. ### <a name="173"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

174. ### <a name="174"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

175. ### <a name="175"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

176. ### <a name="176"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

177. ### <a name="177"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

178. ### <a name="178"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

179. ### <a name="179"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

180. ### <a name="180"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

181. ### <a name="181"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

182. ### <a name="182"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

183. ### <a name="183"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

184. ### <a name="184"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

185. ### <a name="185"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

186. ### <a name="186"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

187. ### <a name="187"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

188. ### <a name="188"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

189. ### <a name="189"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

190. ### <a name="190"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

191. ### <a name="191"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

192. ### <a name="192"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

193. ### <a name="193"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

194. ### <a name="194"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

195. ### <a name="195"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

196. ### <a name="196"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

197. ### <a name="197"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

198. ### <a name="198"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

199. ### <a name="199"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

200. ### <a name="200"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**      
