<a name="top"></a>

[На главную](../README.md)

[Перейти к вопросам](#questions)

| №. | Вопрос |
| --- | --------- |
|   | TypeScript — Grundlagen |
|1 | [Was ist TypeScript und wie unterscheidet es sich von JavaScript?](#1) |
|2 | [Welche Vorteile bietet die Verwendung von TypeScript?](#2) |
|3 | [Was ist Typisierung (static typing)?](#3) |
|4 | [Welche grundlegenden Typen gibt es in TypeScript?](#4) |
|5 | [Worin besteht der Unterschied zwischen any und unknown?](#5) |
|6 | [Was ist never und wann wird es verwendet?](#6) |
|7 | [Was ist der Unterschied zwischen null und undefined?](#7) |
|8 | [Was ist void?](#8) |
|9 | [Was sind Union Types? Gib ein Beispiel.](#9) |
|10 | [Was sind Intersection Types? Gib ein Beispiel.](#10) |
|11 | [Was sind Literal Types?](#11) |
|12 | [Wie funktioniert type inference in TypeScript?](#12) |
|13 | [Was ist ein Type Alias (type) und wie unterscheidet er sich von interface?](#13) |
|14 | [Was ist der Unterschied zwischen interface und type?](#14) |
|15 | [Kann man Interfaces zusammenführen (extend)?](#15) |
|16 | [Was sind optionale Eigenschaften in Interfaces?](#16) |
|17 | [Wie deklariert man readonly-Eigenschaften?](#17) |
|18 | [Was sind Tupel (tuples) in TypeScript?](#18) |
|19 | [Was ist ein Enum und wann sollte man es verwenden?](#19) |
|20 | [Was ist der Unterschied zwischen const enum und einem normalen enum?](#20) |
|21 | [Was ist Type Narrowing (Typschränkung)?](#21) |
|22 | [Was sind Type Guards? Gib ein Beispiel.](#22) |
|23 | [Wie funktioniert der Operator in bei der Typprüfung?](#23) |
|24 | [Wie funktioniert typeof in TypeScript?](#24) |
|25 | [Wie funktioniert instanceof?](#25) |
|26 | [Was sind Discriminated Unions (diskriminierte Typen)?](#26) |
|27 | [Was ist der Unterschied zwischen interface und abstract class?](#27) |
|28 | [Wie implementiert man Funktionsüberladungen (function overloads) in TypeScript?](#28) |
|29 | [Was sind Index Signatures?](#29) |
|30 | [Was ist keyof und wofür wird es verwendet?](#30) |
|31 | [Wie funktioniert der Operator as?](#31) |
|32 | [Was ist der Unterschied zwischen as const und einem normalen const?](#32) |
|33 | [Was macht der Operator satisfies (TS 4.9+)?](#33) |
|34 | [Was sind Assertion Functions?](#34) |
|35 | [Was ist der Unterschied zwischen struktureller Typisierung (structural typing) und nominaler Typisierung (nominal typing)?](#35) |
|36 | [Was sind Deklarationsdateien (.d.ts)?](#36) |
|37 | [Wie bindet man eine externe JS-Bibliothek ohne Typen ein?](#37) |
|38 | [Was sind Ambient Declarations (declare)?](#38) |
|39 | [Was ist strict mode in TypeScript?](#39) |
|40 | [Wozu dient strictNullChecks?](#40) |
|   | TypeScript — Funktionen und Generics |
|41 | [Wie typisiert man Parameter und Rückgabewerte von Funktionen?](#41) |
|42 | [Was sind optionale Parameter in Funktionen?](#42) |
|43 | [Wie deklariert man Standardwerte für Parameter mit Typisierung?](#43) |
|44 | [Was sind Rest-Parameter und wie typisiert man sie?](#44) |
|45 | [Wie typisiert man Arrow Functions?](#45) |
|46 | [Was sind Funktionsüberladungen?](#46) |
|47 | [Was sind Generics?](#47) |
|48 | [Wie erstellt man eine generische Funktion?](#48) |
|49 | [Was sind Generic Constraints (extends)?](#49) |
|50 | [Wie funktioniert T extends keyof U?](#50) |
|51 | [Was sind Utility Types (Partial, Pick, Omit, Record usw.)?](#51) |
|52 | [Was ist der Unterschied zwischen Partial<T> und Required<T>?](#52) |
|53 | [Wie funktioniert Readonly<T>?](#53) |
|54 | [Wie funktionieren Pick<T, K> und Omit<T, K>?](#54) |
|55 | [Was macht Record<K, T>?](#55) |
|56 | [Was macht ReturnType<T>?](#56) |
|57 | [Was macht Parameters<T>?](#57) |
|58 | [Was macht ConstructorParameters<T>?](#58) |
|59 | [Wie funktionieren Extract und Exclude?](#59) |
|60 | [Was macht NonNullable<T>?](#60) |
|   | TypeScript — Klassen und OOP |
|61 | [Wie deklariert man eine Klasse in TypeScript?](#61) |
|62 | [Was sind Zugriffsmodifikatoren (public, private, protected)?](#62) |
|63 | [Was sind readonly-Eigenschaften in Klassen?](#63) |
|64 | [Wie deklariert man statische Eigenschaften und Methoden?](#64) |
|65 | [Was ist der Unterschied zwischen einer abstrakten und einer normalen Klasse?](#65) |
|66 | [Kann man Interfaces mit Klassen implementieren?](#66) |
|67 | [Was ist der Unterschied zwischen implements und extends?](#67) |
|68 | [Was ist this und wie typisiert man es?](#68) |
|69 | [Kann man generische Klassen erstellen?](#69) |
|   | React + TypeScript — Grundlagen |
|70 | [Wie erstellt man ein React-Projekt mit TypeScript?](#70) |
|71 | [Wie typisiert man eine React-Komponente (FC)?](#71) |
|72 | [Was ist React.FC und wann sollte man es vermeiden?](#72) |
|73 | [Wie typisiert man Props in einer React-Komponente?](#73) |
|74 | [Wie typisiert man optionale Props?](#74) |
|75 | [Wie deklariert man Default Props in TypeScript?](#75) |
|76 | [Wie typisiert man children in React-Komponenten?](#76) |
|77 | [Was ist der Unterschied zwischen ReactNode, JSX.Element und ReactElement?](#77) |
|78 | [Wie typisiert man Events (z. B. onClick, onChange)?](#78) |
|79 | [Wie typisiert man Refs in React?](#79) |
|80 | [Wie typisiert man State mit useState?](#80) |
|81 | [Wie typisiert man useReducer?](#81) |
|82 | [Wie typisiert man useRef mit initial null?](#82) |
|83 | [Wie typisiert man einen Custom Hook?](#83) |
|84 | [Wie typisiert man Komponenten mit forwardRef?](#84) |
|85 | [Wie typisiert man Context (React Context API)?](#85) |
|86 | [Wie typisiert man HOCs (Higher-Order Components)?](#86) |
|87 | [Wie typisiert man asynchrone Funktionen in React-Komponenten?](#87) |
|88 | [Wie typisiert man Event-Handler in Formularen?](#88) |
|89 | [Wie typisiert man API-Requests und Responses?](#89) |
|90 | [Wie typisiert man React-Router-Komponenten?](#90) |
|   | React + TypeScript — Praxis und Architektur |
|91 | [Wie organisiert man Typen für ein gesamtes Projekt?](#91) |
|92 | [Wo speichert man gemeinsame Typen (z. B. User, Product)?](#92) |
|93 | [Wie typisiert man den globalen Store (Redux/RTK)?](#93) |
|94 | [Wie typisiert man Actions und Reducer im Redux Toolkit?](#94) |
|95 | [Wie typisiert man useSelector und useDispatch?](#95) |
|96 | [Wie typisiert man einen Zustand-Store (Zustand)?](#96) |
|97 | [Wie typisiert man Async Thunks?](#97) |
|98 | [Wie typisiert man Query Hooks in RTK Query?](#98) |
|99 | [Wie verwendet man Enums für Redux-Actions?](#99) |
|100 | [Wie typisiert man Formulare mit React Hook Form?](#100) |
|101 | [Wie typisiert man axios-Requests?](#101) |
|102 | [Wie typisiert man fetch-Requests mit Generics?](#102) |
|103 | [Wie geht man mit Typen bei API-Fehlern um?](#103) |
|104 | [Wie verwendet man Utility Types für API-Modelle?](#104) |
|105 | [Wie typisiert man Dynamic Imports in React?](#105) |
|106 | [Wie verwendet man keyof für dynamische Eigenschaften in Komponenten?](#106) |
|107 | [Wie erstellt man typsichere Styles (z. B. mit styled-components)?](#107) |
|108 | [Wie typisiert man Props für Bibliothekskomponenten (z. B. Material UI)?](#108) |
|109 | [Wie typisiert man React.memo?](#109) |
|110 | [Wie typisiert man React.lazy und Suspense?](#110) |
|   | Fragen auf Middle-Level |
|111 | [Wie verwendet man Conditional Types (T extends U ? X : Y)?](#111) |
|112 | [Was sind Mapped Types?](#112) |
|113 | [Wie funktionieren Template Literal Types?](#113) |
|114 | [Was ist infer?](#114) |
|115 | [Wie schreibt man eigene Utility Types?](#115) |
|116 | [Wie kombiniert man mehrere Generics?](#116) |
|117 | [Was sind polymorphe Komponenten in React?](#117) |
|118 | [Wie erstellt man eine generische React-Komponente?](#118) |
|119 | [Wie verbindet man Generics in Props und State?](#119) |
|120 | [Wie stellt man vollständige Typsicherheit bei der Arbeit mit APIs sicher?](#120) |
|121 | [](#121) |
|122 | [](#122) |
|123 | [](#123) |
|124 | [](#124) |
|125 | [](#125) |
|126 | [](#126) |
|127 | [](#127) |
|128 | [](#128) |
|129 | [](#129) |
|130 | [](#130) |
|131 | [](#131) |
|132 | [](#132) |
|133 | [](#133) |
|134 | [](#134) |
|135 | [](#135) |
|136 | [](#136) |
|137 | [](#137) |
|138 | [](#138) |
|139 | [](#139) |
|140 | [](#140) |
|141 | [](#141) |
|142 | [](#142) |
|143 | [](#143) |
|144 | [](#144) |
|145 | [](#145) |
|146 | [](#146) |
|147 | [](#147) |
|148 | [](#148) |
|149 | [](#149) |
|150 | [](#150) |
|151 | [](#151) |
|152 | [](#152) |
|153 | [](#153) |
|154 | [](#154) |
|155 | [](#155) |
|156 | [](#156) |
|157 | [](#157) |
|158 | [](#158) |
|159 | [](#159) |
|160 | [](#160) |
|161 | [](#161) |
|162 | [](#162) |
|163 | [](#163) |
|164 | [](#164) |
|165 | [](#165) |
|166 | [](#166) |
|167 | [](#167) |
|168 | [](#168) |
|169 | [](#169) |
|170 | [](#170) |
|171 | [](#171) |
|172 | [](#172) |
|173 | [](#173) |
|174 | [](#174) |
|175 | [](#175) |
|176 | [](#176) |
|177 | [](#177) |
|178 | [](#178) |
|179 | [](#179) |
|180 | [](#180) |
|181 | [](#181) |
|182 | [](#182) |
|183 | [](#183) |
|184 | [](#184) |
|185 | [](#185) |
|186 | [](#186) |
|187 | [](#187) |
|188 | [](#188) |
|189 | [](#189) |
|190 | [](#190) |
|191 | [](#191) |
|192 | [](#192) |
|193 | [](#193) |
|194 | [](#194) |
|195 | [](#195) |
|196 | [](#196) |
|197 | [](#197) |
|198 | [](#198) |
|199 | [](#199) |
|200 | [](#200) |



<a name="questions"></a>

## ReactJS 

  **[⬆ Наверх](#top)**
  
1. ### <a name="1"></a> Was ist TypeScript und wie unterscheidet es sich von JavaScript?

**TypeScript** ist eine von Microsoft entwickelte Programmiersprache, die auf **JavaScript** basiert und dieses um **statische Typisierung** erweitert. Jeder gültige JavaScript-Code ist auch gültiger TypeScript-Code.

### Hauptunterschiede zu JavaScript

1. **Statische Typisierung**

   * In JavaScript sind Variablen dynamisch typisiert.
   * In TypeScript kann man Typen explizit angeben, was Fehler schon während der Entwicklung verhindert.

   ```js
   // JavaScript (dynamisch, Fehler erst zur Laufzeit möglich)
   let name = "Sergii"
   name = 42 // kein Fehler beim Schreiben, nur Laufzeitproblem

   // TypeScript (statisch, Fehler beim Kompilieren)
   let name: string = "Sergii"
   name = 42 // ❌ Fehler: Type 'number' is not assignable to type 'string'
   ```

2. **Typinferenz**

   * TypeScript erkennt oft automatisch den Typ einer Variable.

   ```js
   let age = 33 // Typ: number (automatisch erkannt)
   ```

3. **Erweiterte Features**

   * Interfaces, Enums, Generics, Union- und Intersection-Types, Utility-Types.

   ```js
   interface User {
     id: number
     name: string
   }

   const user: User = { id: 1, name: "Sergii" }
   ```

4. **Kompilierung**

   * TypeScript wird in **JavaScript** transpiliert (mittels `tsc` oder Bundler wie Vite/Webpack).
   * Läuft nicht direkt im Browser, sondern wird vorher in JavaScript konvertiert.

5. **Entwicklerfreundlichkeit**

   * Bessere **IntelliSense**, Autovervollständigung und Fehlererkennung in IDEs.

---

### Zusammenfassung

* **JavaScript**: dynamisch typisiert, direkt im Browser lauffähig.
* **TypeScript**: superset von JavaScript mit **statischer Typisierung** und zusätzlichen Features; erfordert Transpilation.
* Vorteil: Weniger Laufzeitfehler, besserer Code-Support.

🔗 Quellen:

* [TypeScript: What is TypeScript?](https://www.typescriptlang.org/docs/handbook/intro.html)
* [React TypeScript Cheatsheet: Setup](https://react-typescript-cheatsheet.netlify.app/docs/basic/setup)

  **[⬆ Наверх](#top)**

2. ### <a name="2"></a> Welche Vorteile bietet die Verwendung von TypeScript?

### Vorteile von TypeScript

1. **Frühe Fehlererkennung**

   * Typfehler werden bereits beim Kompilieren gefunden, bevor der Code ausgeführt wird.

   ```js
   let price: number = 50
   price = "fünfzig" // ❌ Fehler beim Kompilieren
   ```

2. **Bessere Entwicklererfahrung (DX)**

   * IntelliSense, Autovervollständigung, Hover-Infos und Refactoring sind präziser.

3. **Klarheit und Wartbarkeit**

   * Durch Typannotationen und Interfaces ist der Code selbstdokumentierend.

   ```js
   interface Product {
     id: number
     name: string
     price: number
   }
   ```

4. **Skalierbarkeit**

   * Besonders nützlich in großen Projekten mit vielen Entwicklern.
   * Änderungen sind sicherer, da Typen sofort Konflikte zeigen.

5. **Moderne Features**

   * Unterstützung von Generics, Union/Intersection Types, Enums, Utility-Types.

   ```js
   function wrapValue<T>(value: T): T[] {
     return [value]
   }
   const result = wrapValue<string>("Hallo") // result: string[]
   ```

6. **Kompatibilität mit JavaScript**

   * Jeder JS-Code läuft auch in TS.
   * Migration von bestehenden Projekten möglich (schrittweise Einführung).

---

### Zusammenfassung

* **TypeScript** bringt Typensicherheit, bessere Entwickler-Tools, klareren und wartbareren Code, Skalierbarkeit in großen Projekten und moderne Sprachfeatures.
* Besonders vorteilhaft bei **langfristigen, komplexen Projekten** mit mehreren Teammitgliedern.

🔗 Quellen:

* [TypeScript Handbook – Why TypeScript](https://www.typescriptlang.org/docs/handbook/2/basic-types.html)
* [React TypeScript Cheatsheet – Vorteile](https://react-typescript-cheatsheet.netlify.app/docs/basic/setup)

  **[⬆ Наверх](#top)**

3. ### <a name="3"></a> Was ist Typisierung (static typing)?

### Typisierung (Static Typing)

**Definition:**
Statische Typisierung bedeutet, dass der Datentyp einer Variable oder Funktion **zur Compile-Zeit** festgelegt wird und nicht erst zur Laufzeit.

### Merkmale

1. **Fester Typ während der gesamten Lebenszeit**

   * Eine Variable behält den einmal festgelegten Typ.
   * Zuweisungen anderer Typen führen zu einem Kompilierungsfehler.

   ```js
   let username: string = "Sergii"
   username = 42 // ❌ Fehler: number ist nicht string
   ```

2. **Frühe Fehlererkennung**

   * Tippfehler oder falsche Funktionsaufrufe werden direkt angezeigt.

   ```js
   function add(a: number, b: number): number {
     return a + b
   }

   add(5, "10") // ❌ Fehler: Argument vom Typ 'string' ist nicht zuweisbar
   ```

3. **Verbesserte Autovervollständigung und Dokumentation**

   * IDEs können anhand der Typen Vorschläge und Hilfen anzeigen.

4. **Generics und komplexe Typen**

   * Flexible, aber dennoch sichere Strukturen möglich.

   ```js
   function identity<T>(value: T): T {
     return value
   }
   const result = identity<number>(10) // Typ: number
   ```

---

### Unterschied zu dynamischer Typisierung (JavaScript)

* **Dynamisch:** Typen werden erst zur Laufzeit geprüft.
* **Statisch:** Typen werden bereits vor der Ausführung geprüft.

---

### Zusammenfassung

* **Static Typing** = feste Typprüfung während der Kompilierung.
* Vorteile: weniger Laufzeitfehler, klarer Code, bessere Tool-Unterstützung.
* In TypeScript zwingend (mit Ausnahmen wie `any`), in JavaScript nicht vorhanden.

🔗 Quellen:

* [TypeScript Handbook – Basic Types](https://www.typescriptlang.org/docs/handbook/2/basic-types.html)
* [MDN – JavaScript Datentypen](https://developer.mozilla.org/ru/docs/Web/JavaScript/Data_structures)

  **[⬆ Наверх](#top)**

4. ### <a name="4"></a> Welche grundlegenden Typen gibt es in TypeScript?

### Grundlegende Typen in TypeScript

TypeScript erweitert JavaScript um **statische Typisierung**. Die wichtigsten **Basis-Typen** sind:

---

#### 1. **Primitives**

* **string**

  ```js
  let username: string = "Sergii"
  ```
* **number** (Ganzzahlen & Fließkommazahlen)

  ```js
  let age: number = 34
  ```
* **boolean**

  ```js
  let isOnline: boolean = true
  ```
* **null** und **undefined**

  ```js
  let value: null = null
  let notAssigned: undefined = undefined
  ```
* **bigint** (für sehr große Zahlen)

  ```js
  let big: bigint = 9007199254740991n
  ```
* **symbol** (einzigartige Werte)

  ```js
  let uniqueId: symbol = Symbol("id")
  ```

---

#### 2. **Arrays**

```js
let numbers: number[] = [1, 2, 3]
let names: Array<string> = ["Anna", "Tom"] // Generics-Schreibweise
```

---

#### 3. **Tuples**

* Feste Anzahl von Elementen mit festen Typen.

```js
let person: [string, number] = ["Sergii", 34]
```

---

#### 4. **Enums**

* Sammlung von benannten Konstanten.

```js
enum Role {
  Admin,
  User,
  Guest
}

let currentRole: Role = Role.Admin
```

---

#### 5. **Any**

* Deaktiviert Typprüfung (sollte vermieden werden).

```js
let data: any = 5
data = "Text"
```

---

#### 6. **Unknown**

* Sicherere Alternative zu `any`, erfordert Typprüfung vor Verwendung.

```js
let value: unknown = "Hallo"

if (typeof value === "string") {
  console.log(value.toUpperCase())
}
```

---

#### 7. **Void**

* Wird für Funktionen verwendet, die nichts zurückgeben.

```js
function logMessage(message: string): void {
  console.log(message)
}
```

---

#### 8. **Never**

* Für Funktionen, die niemals einen Wert zurückgeben (z. B. Fehler werfen).

```js
function throwError(msg: string): never {
  throw new Error(msg)
}
```

---

### Zusammenfassung

* **Primitive Typen**: string, number, boolean, null, undefined, bigint, symbol
* **Spezielle Typen**: any, unknown, void, never
* **Strukturierte Typen**: arrays, tuples, enums

🔗 Quellen:

* [TypeScript Handbook – Basic Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html)
* [React TypeScript Cheatsheet – Basic Setup](https://react-typescript-cheatsheet.netlify.app/docs/basic/setup)

  **[⬆ Наверх](#top)**

5. ### <a name="5"></a> Worin besteht der Unterschied zwischen any und unknown?

### Unterschied zwischen `any` und `unknown`

#### **1. `any`**

* Deaktiviert **jegliche Typprüfung**.
* Man kann jede Operation auf `any` ausführen, ohne Fehler beim Kompilieren.
* Gefahr: Laufzeitfehler, da TypeScript keine Sicherheit bietet.

```js
let value: any = "Hallo"
value = 123
value.toUpperCase() // ✅ Kein Fehler beim Kompilieren, aber Laufzeitfehler möglich
```

---

#### **2. `unknown`**

* Ist ein **sicherer Gegenspieler zu `any`**.
* Man kann einen Wert vom Typ `unknown` nicht direkt verwenden, ohne ihn vorher zu prüfen oder zu casten.
* Erzwingt **Type-Safety** durch Typabfragen.

```js
let input: unknown = "Hallo"

// ❌ Direkt nicht erlaubt
// input.toUpperCase()

// ✅ Mit Typprüfung
if (typeof input === "string") {
  console.log(input.toUpperCase())
}
```

---

#### **Vergleich**

| Merkmal            | `any`                 | `unknown`                            |
| ------------------ | --------------------- | ------------------------------------ |
| Typprüfung         | Keine                 | Erforderlich                         |
| Sicherheit         | Niedrig               | Hoch                                 |
| Nutzungsempfehlung | Nur in Ausnahmefällen | Besser als `any` für unsichere Werte |

---

### Zusammenfassung

* **`any`**: erlaubt alles, keine Typprüfung → unsicher.
* **`unknown`**: erfordert Typprüfung oder Casting → sicherer, bevorzugt für unbekannte Werte (z. B. API-Response).

🔗 Quellen:

* [TypeScript Handbook – unknown](https://www.typescriptlang.org/docs/handbook/2/functions.html#unknown)
* [React TypeScript Cheatsheet – any vs. unknown](https://react-typescript-cheatsheet.netlify.app/docs/basic/troubleshooting/types)

  **[⬆ Наверх](#top)**

6. ### <a name="6"></a> Was ist never und wann wird es verwendet?

### `never` in TypeScript

**Definition:**
`never` ist ein spezieller Typ für Werte, die **niemals existieren können**.
Eine Funktion oder ein Ausdruck vom Typ `never` beendet entweder den Programmfluss (z. B. durch einen Fehler) oder läuft unendlich weiter.

---

### Anwendungsfälle

#### 1. **Funktionen, die immer Fehler werfen**

```js
function throwError(message: string): never {
  throw new Error(message)
}
```

* Rückgabewert: niemals erreichbar, da die Funktion das Programm mit einem Fehler abbricht.

---

#### 2. **Endlose Schleifen**

```js
function infiniteLoop(): never {
  while (true) {
    console.log("läuft ewig...")
  }
}
```

* Die Funktion verlässt nie die Schleife → daher `never`.

---

#### 3. **Exhaustiveness Checking** (Typprüfung bei `switch` / `if-else`)

* `never` wird verwendet, um sicherzustellen, dass alle möglichen Fälle abgedeckt sind.

```js
type Shape = "circle" | "square"

function getArea(shape: Shape): number {
  switch (shape) {
    case "circle":
      return Math.PI * 10 ** 2
    case "square":
      return 10 * 10
    default:
      const exhaustiveCheck: never = shape
      return exhaustiveCheck
  }
}
```

* Vorteil: Falls später ein neuer Typ (`"triangle"`) hinzugefügt wird, zeigt TypeScript einen Fehler an, solange er nicht im `switch` behandelt wird.

---

### Unterschied zu `void`

* **`void`**: Funktion gibt keinen **Wert** zurück.
* **`never`**: Funktion gibt **nie** etwas zurück (nicht mal `undefined`).

---

### Zusammenfassung

* **`never`** = Typ für Werte, die nie vorkommen können.
* Typische Nutzung: Funktionen, die Fehler werfen, unendliche Schleifen oder Exhaustiveness Checking.
* Unterschied zu `void`: `void` = kein Rückgabewert, `never` = niemals Rückgabe.

🔗 Quellen:

* [TypeScript Handbook – never](https://www.typescriptlang.org/docs/handbook/2/functions.html#never)
* [MDN – JavaScript Error](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Error)

  **[⬆ Наверх](#top)**

7. ### <a name="7"></a> Was ist der Unterschied zwischen null und undefined?

### Unterschied zwischen `null` und `undefined` in TypeScript / JavaScript

#### **1. `undefined`**

* Automatischer Standardwert für nicht initialisierte Variablen oder fehlende Eigenschaften.
* Bedeutet: *"nicht zugewiesen"*.

```js
let a
console.log(a) // undefined

const obj = {}
console.log(obj.prop) // undefined
```

---

#### **2. `null`**

* Wird explizit vom Entwickler gesetzt.
* Bedeutet: *"absichtlich leer / kein Wert"*.

```js
let b: string | null = null
console.log(b) // null
```

---

#### **3. Vergleich**

```js
console.log(null == undefined)  // true  (lockerer Vergleich)
console.log(null === undefined) // false (strenger Vergleich)
```

---

#### **4. In TypeScript**

* `undefined` und `null` sind eigene Typen.
* Standardmäßig sind sie **Zuweisungen an andere Typen erlaubt** (abhängig von `--strictNullChecks`).

```js
let x: string | null = null   // erlaubt
let y: string | undefined     // muss initialisiert oder geprüft werden
```

---

#### **5. Typische Verwendung**

* **`undefined`**: vom System vergeben, wenn nichts zugewiesen wurde.
* **`null`**: vom Entwickler gesetzt, um „keinen Wert“ darzustellen.

---

### Zusammenfassung

* **`undefined`** = Wert fehlt automatisch (nicht initialisiert, nicht vorhanden).
* **`null`** = Wert wurde absichtlich auf „kein Wert“ gesetzt.
* Unterschied deutlich machen mit `===`: `null !== undefined`.

🔗 Quellen:

* [TypeScript Handbook – Everyday Types: null & undefined](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#null-and-undefined)
* [MDN – null](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/null)
* [MDN – undefined](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/undefined)

  **[⬆ Наверх](#top)**

8. ### <a name="8"></a> Was ist void?

### `void` in TypeScript

**Definition:**
`void` ist ein spezieller Typ in TypeScript, der bedeutet, dass eine Funktion **keinen Rückgabewert** hat.

---

### Anwendungsfälle

#### 1. **Funktion ohne Rückgabewert**

```js
function logMessage(message: string): void {
  console.log(message)
}

const result = logMessage("Hallo")
// result hat den Typ void → es wird nichts zurückgegeben
```

---

#### 2. **Callbacks, die nichts zurückgeben**

```js
function forEachItem(items: string[], callback: (item: string) => void) {
  for (const item of items) {
    callback(item)
  }
}

forEachItem(["A", "B"], (el) => console.log(el))
```

---

#### 3. **Unterschied zu `undefined`**

* `void` ≠ `undefined`, auch wenn Funktionen implizit `undefined` zurückgeben.
* Mit `void` sagt man ausdrücklich: *„Kein Rückgabewert ist relevant“*.

```js
function test(): void {
  return // erlaubt, implizit undefined
}

function test2(): undefined {
  return undefined // nur explizit erlaubt
}
```

---

#### 4. **Besonderheit bei Promises**

* `Promise<void>` → Funktion gibt ein Promise zurück, dessen Wert nicht benutzt werden soll.

```js
async function saveData(): Promise<void> {
  await fetch("/api/save")
}
```

---

### Zusammenfassung

* **`void`** kennzeichnet Funktionen ohne Rückgabewert.
* Typischer Einsatz: `console.log`, Event-Handler, Callbacks.
* Unterschied zu `undefined`: `void` betont die Abwesenheit eines Rückgabewerts, `undefined` ist ein Wert selbst.

🔗 Quellen:

* [TypeScript Handbook – void](https://www.typescriptlang.org/docs/handbook/2/functions.html#void)
* [React TS Cheatsheet – void in Callbacks](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/event-handling/)

  **[⬆ Наверх](#top)**

9. ### <a name="9"></a> Was sind Union Types? Gib ein Beispiel.

### Union Types in TypeScript

**Definition:**
Ein **Union Type** erlaubt es, dass eine Variable oder ein Parameter **mehrere mögliche Typen** haben kann. Er wird mit dem **`|`-Operator** geschrieben.

---

### Beispiel 1 – Variable mit mehreren Typen

```js
let id: string | number

id = 42      // ✅ erlaubt
id = "abc"   // ✅ erlaubt
id = true    // ❌ Fehler: boolean nicht erlaubt
```

---

### Beispiel 2 – Funktion mit Union Types

```js
function printId(id: string | number): void {
  if (typeof id === "string") {
    console.log("ID als Text:", id.toUpperCase())
  } else {
    console.log("ID als Zahl:", id.toFixed(2))
  }
}

printId("abc") // ID als Text: ABC
printId(123.456) // ID als Zahl: 123.46
```

---

### Beispiel 3 – Union in Arrays

```js
let values: (string | number)[] = [1, "zwei", 3, "vier"]
```

---

### Zusammenfassung

* **Union Types** = Typen, die **mehrere mögliche Werte** annehmen können.
* Verwendung: `string | number`, `(string | number)[]`.
* Nützlich für Werte mit mehreren erlaubten Formen (z. B. API-Response: `string | null`).

🔗 Quellen:

* [TypeScript Handbook – Union Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types)
* [React TypeScript Cheatsheet – Union Types](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example)

  **[⬆ Наверх](#top)**

10. ### <a name="10"></a> Was sind Intersection Types? Gib ein Beispiel.

### Intersection Types in TypeScript

**Definition:**
Ein **Intersection Type** (`&`) kombiniert mehrere Typen zu einem **neuen Typ**, der **alle Eigenschaften** der beteiligten Typen enthalten muss.
→ Während `Union (|)` **entweder-oder** bedeutet, ist `Intersection (&)` ein **sowohl-als-auch**.

---

### Beispiel 1 – Kombination von Interfaces

```js
interface Person {
  name: string
}

interface Employee {
  company: string
}

type EmployeePerson = Person & Employee

const worker: EmployeePerson = {
  name: "Sergii",
  company: "Tech GmbH"
}
```

---

### Beispiel 2 – Kombination von Typen

```js
type A = { x: number }
type B = { y: number }

type AB = A & B

const point: AB = { x: 10, y: 20 } // Muss beide Eigenschaften haben
```

---

### Beispiel 3 – Praktisch in Generics

```js
function merge<T, U>(objA: T, objB: U): T & U {
  return { ...objA, ...objB }
}

const merged = merge({ id: 1 }, { role: "admin" })
// Typ: { id: number } & { role: string }
```

---

### Zusammenfassung

* **Intersection Types (`&`)** = Kombination mehrerer Typen zu einem Typ, der **alle Eigenschaften** enthält.
* Unterschied zu Union:

  * **Union (`|`)** → entweder-oder.
  * **Intersection (`&`)** → sowohl-als-auch.

🔗 Quellen:

* [TypeScript Handbook – Intersection Types](https://www.typescriptlang.org/docs/handbook/2/objects.html#intersection-types)
* [React TS Cheatsheet – Utility Types & Intersections](https://react-typescript-cheatsheet.netlify.app/docs/advanced/types_react_api/)

  **[⬆ Наверх](#top)**

11. ### <a name="11"></a> Was sind Literal Types?

### Literal Types in TypeScript

**Definition:**
Ein **Literal Type** schränkt eine Variable auf einen **konkreten Wert** ein, anstatt nur auf den allgemeinen Typ (z. B. `string` oder `number`).
So kann man Variablen oder Parameter **nur bestimmte erlaubte Werte** zuweisen.

---

### Beispiel 1 – String-Literals

```js
let direction: "left" | "right"

direction = "left"   // ✅ erlaubt
direction = "right"  // ✅ erlaubt
direction = "up"     // ❌ Fehler
```

---

### Beispiel 2 – Number-Literals

```js
let diceRoll: 1 | 2 | 3 | 4 | 5 | 6

diceRoll = 3  // ✅ erlaubt
diceRoll = 7  // ❌ Fehler
```

---

### Beispiel 3 – In Kombination mit Unions

```js
type Status = "success" | "error" | "loading"

function handleStatus(status: Status): void {
  if (status === "success") {
    console.log("Alles gut ✅")
  } else if (status === "error") {
    console.log("Fehler ❌")
  } else {
    console.log("Lädt ⏳")
  }
}

handleStatus("success")
```

---

### Beispiel 4 – Literal Inferenz mit `const`

```js
const role = "admin"
// Typ ist "admin", nicht string
```

---

### Zusammenfassung

* **Literal Types** = feste, konkrete Werte als Typen.
* Nützlich für: erlaubte Werte (Enums-ähnlich), Statusangaben, Konstanten.
* Oft in Kombination mit **Union Types** genutzt.

🔗 Quellen:

* [TypeScript Handbook – Literal Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-types)
* [React TS Cheatsheet – Discriminated Unions](https://react-typescript-cheatsheet.netlify.app/docs/advanced/discriminated_unions/)

  **[⬆ Наверх](#top)**

12. ### <a name="12"></a> Wie funktioniert type inference in TypeScript?

### Type Inference in TypeScript

**Definition:**
**Type Inference (Typinferenz)** bedeutet, dass TypeScript den Typ einer Variable, Funktion oder eines Ausdrucks **automatisch ableitet**, wenn kein expliziter Typ angegeben wird.

---

### Regeln der Typinferenz

#### 1. **Variable-Zuweisung**

```js
let count = 10
// Typ wird automatisch als number erkannt
// count: number
```

---

#### 2. **Funktionsergebnisse**

```js
function add(a: number, b: number) {
  return a + b
}
// Rückgabetyp: number (wird automatisch erkannt)
```

---

#### 3. **Best Common Type**

Wenn verschiedene Typen in einem Array vorkommen, wählt TypeScript den "allgemeinsten" Typ.

```js
let values = [1, "zwei", 3]
// Typ: (string | number)[]
```

---

#### 4. **Contextual Typing**

Der Typ kann auch aus dem **Kontext** abgeleitet werden.

```js
window.addEventListener("click", (event) => {
  console.log(event.clientX) // event: MouseEvent
})
```

---

#### 5. **Default Inference für `any`**

Wenn keine Information vorliegt, wird `any` angenommen (außer bei `--noImplicitAny`).

```js
function log(value) {
  console.log(value)
}
// value: any
```

---

### Vorteile

* Weniger Schreibarbeit (man muss nicht überall Typen manuell angeben).
* Bessere Lesbarkeit.
* Trotzdem Typ-Sicherheit, solange genug Information vorhanden ist.

---

### Zusammenfassung

* **Type Inference** = automatische Typbestimmung durch TypeScript.
* Regeln: Variablenzuweisung, Funktionsrückgaben, Arrays (Best Common Type), Kontextabhängigkeit.
* Vorteil: weniger Code, aber trotzdem Typ-Sicherheit.

🔗 Quellen:

* [TypeScript Handbook – Type Inference](https://www.typescriptlang.org/docs/handbook/type-inference.html)
* [React TS Cheatsheet – Inference](https://react-typescript-cheatsheet.netlify.app/docs/basic/troubleshooting/types/#type-inference)

  **[⬆ Наверх](#top)**

13. ### <a name="13"></a> Was ist ein Type Alias (type) und wie unterscheidet er sich von interface?

### **Type Alias (`type`) in TypeScript**

**Definition:**
Ein **Type Alias** erstellt einen neuen Namen für einen bestehenden Typ.
Er kann primitive Typen, Union/Intersection Types, Funktionen oder komplexe Strukturen beschreiben.

```js
type UserID = string | number

type User = {
  id: UserID
  name: string
}
```

---

### **Interface in TypeScript**

**Definition:**
Ein **Interface** beschreibt die **Struktur eines Objekts** (Shape).
Es wird häufig für Klassen, Objekte und die Definition von Verträgen verwendet.

```js
interface User {
  id: number
  name: string
}
```

---

### **Hauptunterschiede**

| Aspekt                   | `type`                                                               | `interface`                                    |
| ------------------------ | -------------------------------------------------------------------- | ---------------------------------------------- |
| **Einsatz**              | Alias für jeden Typ (Primitives, Unions, Functions, Tuples, Objects) | Nur Objekte und Klassen-Strukturen             |
| **Erweiterung**          | Mit `&` (Intersection)                                               | Mit `extends`                                  |
| **Deklarations-Merging** | ❌ Nicht möglich                                                      | ✅ Mehrfachdeklarationen werden zusammengeführt |
| **Flexibilität**         | Sehr vielseitig                                                      | Speziell für objektorientierte Modelle         |

---

### **Beispiele für Unterschiede**

#### 1. Type für Union

```js
type Status = "success" | "error" | "loading"
```

Mit `interface` nicht möglich.

---

#### 2. Interface-Erweiterung

```js
interface Person {
  name: string
}

interface Employee extends Person {
  company: string
}
```

---

#### 3. Type-Erweiterung mit Intersection

```js
type Person = { name: string }
type Employee = Person & { company: string }
```

---

#### 4. Deklarations-Merging

```js
interface Window {
  title: string
}

interface Window {
  size: number
}

const w: Window = { title: "App", size: 800 }
// ✅ erlaubt, beide Interfaces verschmelzen
```

Mit `type` nicht möglich.

---

### Zusammenfassung

* **`type`** = Alias für beliebige Typen (Primitives, Union, Intersection, Functions, Tuples, Objekte).
* **`interface`** = Vertrag für Objekt- oder Klassen-Strukturen, unterstützt Deklarations-Merging.
* Empfehlung:

  * **Objektmodelle → `interface`**
  * **Komplexe Typ-Kombinationen → `type`**

🔗 Quellen:

* [TypeScript Handbook – Type Aliases](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-aliases)
* [TypeScript Handbook – Interfaces](https://www.typescriptlang.org/docs/handbook/2/objects.html)
* [React TS Cheatsheet – Types vs. Interfaces](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example#types-vs-interfaces)

  **[⬆ Наверх](#top)**

14. ### <a name="14"></a> Was ist der Unterschied zwischen interface und type?

### Unterschied zwischen `interface` und `type` in TypeScript

#### **1. Gemeinsamkeiten**

* Beide können Objekte beschreiben.
* Beide unterstützen Erweiterung und Wiederverwendung.
* Beide sind strukturell (nicht nominal) → entscheidend ist die Form, nicht der Name.

---

#### **2. Unterschiede**

| Aspekt                   | `interface`                                       | `type`                                                             |
| ------------------------ | ------------------------------------------------- | ------------------------------------------------------------------ |
| **Verwendungszweck**     | Hauptsächlich für Objekte und Klassen-Contracts   | Alias für jeden Typ (auch Primitives, Union, Tuple, Function etc.) |
| **Erweiterung**          | `extends`                                         | Intersection (`&`)                                                 |
| **Deklarations-Merging** | ✅ Ja (mehrfach definierbar, wird zusammengeführt) | ❌ Nein                                                             |
| **Flexibilität**         | Eingeschränkter (nur für Objekt-ähnliche Typen)   | Sehr flexibel, kann alles beschreiben                              |
| **Lesbarkeit**           | Oft bevorzugt für Props, Klassen, API-Schemas     | Bevorzugt für komplexe Typkombinationen, Union/Intersection        |

---

#### **3. Beispiele**

**Interface für Objekte**

```js
interface Person {
  name: string
  age: number
}

interface Employee extends Person {
  company: string
}

const dev: Employee = { name: "Sergii", age: 34, company: "Tech GmbH" }
```

**Type für komplexe Kombinationen**

```js
type Status = "success" | "error" | "loading"

type UserID = string | number

type Point = [number, number] // Tuple
```

**Deklarations-Merging (nur bei Interface)**

```js
interface Window {
  title: string
}

interface Window {
  size: number
}

const w: Window = { title: "App", size: 800 } // ✅ erlaubt
```

---

### Zusammenfassung

* **`interface`** = objektorientiert, erweiterbar (`extends`), unterstützt Deklarations-Merging.
* **`type`** = flexibler, geeignet für Unions, Primitives, Funktionen, Tuples.
* Empfehlung:

  * **Objekte/Klassen** → `interface`
  * **Union/Intersection/Primitives** → `type`

🔗 Quellen:

* [TypeScript Handbook – Interfaces](https://www.typescriptlang.org/docs/handbook/2/objects.html)
* [TypeScript Handbook – Type Aliases](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-aliases)
* [React TS Cheatsheet – Types vs Interfaces](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example#types-vs-interfaces)

  **[⬆ Наверх](#top)**

15. ### <a name="15"></a> Kann man Interfaces zusammenführen (extend)?

### Interfaces zusammenführen in TypeScript

Ja – **Interfaces** können auf zwei Arten zusammengeführt werden:

---

#### **1. Erweiterung mit `extends`**

Ein Interface kann ein anderes Interface erweitern.

```js
interface Person {
  name: string
}

interface Employee extends Person {
  company: string
}

const dev: Employee = {
  name: "Sergii",
  company: "Tech GmbH"
}
```

* `Employee` erbt alle Eigenschaften von `Person`.

---

#### **2. Deklarations-Merging**

Wenn mehrere **gleichnamige Interfaces** existieren, werden sie automatisch zusammengeführt.

```js
interface Window {
  title: string
}

interface Window {
  size: number
}

const w: Window = {
  title: "App",
  size: 1200
}
```

* TypeScript kombiniert beide Definitionen → Ergebnis ist ein Interface mit `title` **und** `size`.

---

#### Unterschied zu `type`

* `type` kann **nicht** gemerged werden.
* Nur `interface` unterstützt Deklarations-Merging.

---

### Zusammenfassung

* **Ja, Interfaces können zusammengeführt werden.**
* Zwei Wege:

  1. **`extends`** → Vererbung.
  2. **Deklarations-Merging** → mehrere gleiche Namen = automatisch kombiniert.
* Vorteil: Flexibel für API-Erweiterungen oder globale Typdefinitionen.

🔗 Quellen:

* [TypeScript Handbook – Interfaces](https://www.typescriptlang.org/docs/handbook/2/objects.html#extending-interfaces)
* [TypeScript Handbook – Declaration Merging](https://www.typescriptlang.org/docs/handbook/declaration-merging.html)

  **[⬆ Наверх](#top)**

16. ### <a name="16"></a> Was sind optionale Eigenschaften in Interfaces?

### Optionale Eigenschaften in Interfaces

**Definition:**
Optionale Eigenschaften in einem Interface sind Felder, die beim Erstellen eines Objekts **nicht zwingend angegeben** werden müssen.
Man markiert sie mit einem **Fragezeichen (`?`)** nach dem Eigenschaftsnamen.

---

### Beispiel 1 – Einfaches Interface mit optionalen Feldern

```js
interface User {
  id: number
  name: string
  age?: number // optional
}

const user1: User = { id: 1, name: "Sergii" }       // ✅ ohne age
const user2: User = { id: 2, name: "Anna", age: 30 } // ✅ mit age
```

---

### Beispiel 2 – Optional in Kombination mit Funktionen

```js
interface Config {
  url: string
  timeout?: number
}

function fetchData(config: Config) {
  console.log(`Hole Daten von ${config.url}`)
  if (config.timeout) {
    console.log(`Timeout: ${config.timeout}ms`)
  }
}

fetchData({ url: "/api" })
fetchData({ url: "/api", timeout: 5000 })
```

---

### Beispiel 3 – Unterschied zu `undefined`

Ein optionales Feld kann fehlen **oder explizit `undefined` sein**.

```js
interface Product {
  name: string
  price?: number
}

const p1: Product = { name: "Buch" }                 // kein price
const p2: Product = { name: "Buch", price: undefined } // explizit undefined
```

---

### Zusammenfassung

* **Optionale Eigenschaften** (`?`) = nicht verpflichtend in Objekten.
* Können weggelassen oder explizit auf `undefined` gesetzt werden.
* Nützlich für **Konfigurationsobjekte, optionale Props, flexible Datenstrukturen**.

🔗 Quellen:

* [TypeScript Handbook – Interfaces](https://www.typescriptlang.org/docs/handbook/2/objects.html#optional-properties)
* [React TS Cheatsheet – Optional Props](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example#optional-props)

  **[⬆ Наверх](#top)**

17. ### <a name="17"></a> Wie deklariert man readonly-Eigenschaften?

### `readonly` Eigenschaften in TypeScript

**Definition:**
Mit dem Schlüsselwort **`readonly`** kann man Eigenschaften in Interfaces, Types oder Klassen so deklarieren, dass sie **nach der Initialisierung nicht mehr verändert** werden dürfen.

---

### Beispiel 1 – Interface mit `readonly`

```js
interface User {
  readonly id: number
  name: string
}

const user: User = { id: 1, name: "Sergii" }

user.name = "Anna"   // ✅ erlaubt
user.id = 2          // ❌ Fehler: id ist readonly
```

---

### Beispiel 2 – Type mit `readonly`

```js
type Point = {
  readonly x: number
  readonly y: number
}

const p: Point = { x: 10, y: 20 }
p.x = 30 // ❌ Fehler
```

---

### Beispiel 3 – Klassen mit `readonly`

```js
class Person {
  readonly id: number
  name: string

  constructor(id: number, name: string) {
    this.id = id      // ✅ Initialisierung erlaubt
    this.name = name
  }
}

const dev = new Person(1, "Sergii")
dev.name = "Anna"   // ✅ erlaubt
dev.id = 2          // ❌ Fehler
```

---

### Beispiel 4 – Readonly Arrays

```js
const numbers: ReadonlyArray<number> = [1, 2, 3]

numbers.push(4) // ❌ Fehler: push ist nicht erlaubt
```

---

### Zusammenfassung

* **`readonly`** = Eigenschaft kann nur bei der Initialisierung gesetzt werden.
* Einsatz in: **Interfaces, Types, Klassen, Arrays**.
* Vorteil: bessere **Immutabilität** und Sicherheit vor unbeabsichtigten Änderungen.

🔗 Quellen:

* [TypeScript Handbook – readonly](https://www.typescriptlang.org/docs/handbook/2/objects.html#readonly-properties)
* [React TS Cheatsheet – readonly usage](https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase#readonly-and-const-assertions)

  **[⬆ Наверх](#top)**

18. ### <a name="18"></a> Was sind Tupel (tuples) in TypeScript?

### Tupel (Tuples) in TypeScript

**Definition:**
Ein **Tuple** ist ein spezielles Array mit **fester Länge** und **fest definierten Typen** an den jeweiligen Positionen.
→ Anders als bei Arrays kann jedes Element einen eigenen Typ haben, der an einer bestimmten Stelle erwartet wird.

---

### Beispiel 1 – Einfaches Tuple

```js
let user: [string, number]

user = ["Sergii", 34]   // ✅ korrekt
user = [34, "Sergii"]   // ❌ Fehler: Reihenfolge stimmt nicht
```

---

### Beispiel 2 – Tuple mit optionalem Element

```js
let point: [number, number, number?]

point = [10, 20]       // ✅ erlaubt
point = [10, 20, 30]   // ✅ erlaubt
```

---

### Beispiel 3 – Mit `readonly` (immutable Tuple)

```js
let coordinates: readonly [number, number] = [50, 100]

coordinates[0] = 10 // ❌ Fehler: readonly
```

---

### Beispiel 4 – Einsatz in Funktionen

```js
function useCoordinates(): [number, number] {
  return [10, 20]
}

const [x, y] = useCoordinates()
```

---

### Beispiel 5 – Variadische Tupel (seit TS 4.0)

```js
type Pair<T> = [T, T]
type Triple<T> = [T, T, T]

let pair: Pair<string> = ["a", "b"]
let triple: Triple<number> = [1, 2, 3]
```

---

### Zusammenfassung

* **Tuple** = Array mit **fester Länge** und **definierten Typen pro Index**.
* Nützlich für: Rückgabewerte von Funktionen, koordinatenartige Werte, kleine feste Strukturen.
* Erweiterungen: optionale Elemente, `readonly`, variadische Tupel.

🔗 Quellen:

* [TypeScript Handbook – Tuples](https://www.typescriptlang.org/docs/handbook/2/objects.html#tuple-types)
* [MDN – Arrays (als Grundlage)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array)

  **[⬆ Наверх](#top)**

19. ### <a name="19"></a> Was ist ein Enum und wann sollte man es verwenden?

### Enum in TypeScript

**Definition:**
Ein **Enum** (Aufzählungstyp) ist eine Sammlung von **benannten Konstanten**.
Es wird verwendet, um Wertegruppen besser lesbar und verständlich zu machen.

---

### Arten von Enums

#### 1. **Numerische Enums (Standard)**

```js
enum Direction {
  Up,    // 0
  Down,  // 1
  Left,  // 2
  Right  // 3
}

let move: Direction = Direction.Up
console.log(move) // 0
```

Man kann auch Startwerte vergeben:

```js
enum Status {
  Success = 1,
  Error = 2,
  Loading = 3
}
```

---

#### 2. **String Enums**

```js
enum Role {
  Admin = "ADMIN",
  User = "USER",
  Guest = "GUEST"
}

let current: Role = Role.Admin
```

---

#### 3. **Const Enums (Kompilierungsoptimierung)**

```js
const enum LogLevel {
  Info,
  Warning,
  Error
}

let level: LogLevel = LogLevel.Error
```

👉 Vorteile: wird zu einfachen Konstanten kompiliert → bessere Performance.

---

### Wann verwenden?

✅ **Geeignet für:**

* Feste, klar definierte Wertegruppen (z. B. Rollen, Status, Richtungen).
* Lesbarkeit: statt `"ADMIN"` oder `1` → `Role.Admin`.
* Weniger Tippfehler durch Autovervollständigung.

⚠️ **Alternativen:**

* **Union Types** mit Literal-Typen sind oft schlanker und flexibler.

  ```js
  type Role = "ADMIN" | "USER" | "GUEST"
  ```
* Empfehlung: In modernen Projekten werden häufig **Union Types** anstelle von Enums bevorzugt, da sie besser mit TypeScript-Features wie Narrowing und Type Inference harmonieren.

---

### Zusammenfassung

* **Enum** = Sammlung von benannten Konstanten (numeric, string, const).
* Vorteile: bessere Lesbarkeit, Fehlervermeidung, klare Struktur.
* Verwendung: feste Wertemengen (Status, Rollen, Richtungen).
* Alternative: **Union Types** → oft moderner und einfacher.

🔗 Quellen:

* [TypeScript Handbook – Enums](https://www.typescriptlang.org/docs/handbook/enums.html)
* [React TS Cheatsheet – Union vs Enums](https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase#enums-vs-union-types)

  **[⬆ Наверх](#top)**

20. ### <a name="20"></a> Was ist der Unterschied zwischen const enum und einem normalen enum?

### Unterschied zwischen `enum` und `const enum` in TypeScript

#### **1. Normales `enum`**

* Wird zur **Laufzeit** in JavaScript-Code kompiliert.
* TypeScript erzeugt ein **Objekt** mit Schlüssel/Wert-Zuordnung.
* Bidirektionale Abbildung: man kann von Namen auf Wert und umgekehrt zugreifen.

```js
enum Direction {
  Up,
  Down,
  Left,
  Right
}

console.log(Direction.Up)    // 0
console.log(Direction[0])    // "Up"
```

➡️ Nach der Kompilierung entsteht ein JS-Objekt:

```js
var Direction;
(function (Direction) {
    Direction[Direction["Up"] = 0] = "Up";
    Direction[Direction["Down"] = 1] = "Down";
    Direction[Direction["Left"] = 2] = "Left";
    Direction[Direction["Right"] = 3] = "Right";
})(Direction || (Direction = {}));
```

---

#### **2. `const enum`**

* Wird **zur Compile-Zeit** durch seine Werte ersetzt.
* Kein Objekt im generierten JavaScript.
* Spart Code und verbessert Performance.

```js
const enum Direction {
  Up,
  Down,
  Left,
  Right
}

let move = Direction.Up
console.log(move) // 0
```

➡️ Nach der Kompilierung:

```js
let move = 0 /* Up */
```

* Kein `Direction`-Objekt vorhanden → keine bidirektionale Abbildung möglich.

---

#### **3. Vergleich**

| Aspekt              | `enum`                                      | `const enum`                     |
| ------------------- | ------------------------------------------- | -------------------------------- |
| **Kompilierung**    | JS-Objekt wird erzeugt                      | Ersetzt durch Werte, kein Objekt |
| **Performance**     | Mehr Overhead                               | Weniger Overhead                 |
| **Reverse Mapping** | ✅ möglich (`Direction[0] → "Up"`)           | ❌ nicht möglich                  |
| **Codegröße**       | Größer                                      | Kleiner                          |
| **Verwendung**      | Wenn bidirektionales Mapping gebraucht wird | Für reine Konstantenwerte        |

---

### Zusammenfassung

* **`enum`**: erzeugt ein JavaScript-Objekt → erlaubt Zugriff in beide Richtungen, größerer Output.
* **`const enum`**: wird während der Kompilierung inline ersetzt → effizienter, aber ohne Reverse Mapping.

🔗 Quellen:

* [TypeScript Handbook – Enums](https://www.typescriptlang.org/docs/handbook/enums.html#const-enums)
* [React TS Cheatsheet – Enums](https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase#enums-vs-union-types)

  **[⬆ Наверх](#top)**

21. ### <a name="21"></a> Was ist Type Narrowing (Typschränkung)?

### Type Narrowing (Typschränkung) in TypeScript

**Definition:**
**Type Narrowing** bedeutet, dass TypeScript den Typ einer Variable während des Codes **einschränkt** (von einem breiteren Union-Typ auf einen spezifischeren Typ), basierend auf **Kontrollstrukturen oder Type Guards**.

---

### Beispiel 1 – `typeof` Narrowing

```js
function printId(id: string | number) {
  if (typeof id === "string") {
    console.log(id.toUpperCase()) // id: string
  } else {
    console.log(id.toFixed(2))    // id: number
  }
}
```

---

### Beispiel 2 – `instanceof` Narrowing

```js
class Dog {
  bark() { console.log("Wuff!") }
}
class Cat {
  meow() { console.log("Miau!") }
}

function makeSound(animal: Dog | Cat) {
  if (animal instanceof Dog) {
    animal.bark() // animal: Dog
  } else {
    animal.meow() // animal: Cat
  }
}
```

---

### Beispiel 3 – Property Check (`in` Operator)

```js
type Fish = { swim: () => void }
type Bird = { fly: () => void }

function move(animal: Fish | Bird) {
  if ("swim" in animal) {
    animal.swim() // Typ: Fish
  } else {
    animal.fly()  // Typ: Bird
  }
}
```

---

### Beispiel 4 – Gleichheitsprüfung (Literal Narrowing)

```js
type Status = "success" | "error" | "loading"

function handleStatus(status: Status) {
  if (status === "success") {
    console.log("Alles gut ✅")
  }
}
```

---

### Beispiel 5 – Exhaustive Check mit `never`

```js
type Shape = { kind: "circle"; radius: number } 
           | { kind: "square"; side: number }

function area(shape: Shape): number {
  switch (shape.kind) {
    case "circle": return Math.PI * shape.radius ** 2
    case "square": return shape.side * shape.side
    default:
      const exhaustive: never = shape // Fehler, falls ein neuer Typ fehlt
      return exhaustive
  }
}
```

---

### Zusammenfassung

* **Type Narrowing** = Einschränkung von Union-Typen auf spezifische Typen.
* Methoden: `typeof`, `instanceof`, `in`, Gleichheitsprüfungen, Kontrollfluss.
* Vorteil: bessere Typ-Sicherheit, weniger Fehler, klarer Code.

🔗 Quellen:

* [TypeScript Handbook – Narrowing](https://www.typescriptlang.org/docs/handbook/2/narrowing.html)
* [React TS Cheatsheet – Type Narrowing](https://react-typescript-cheatsheet.netlify.app/docs/basic/troubleshooting/types/#type-narrowing)

  **[⬆ Наверх](#top)**

22. ### <a name="22"></a> Was sind Type Guards? Gib ein Beispiel.

### Type Guards in TypeScript

**Definition:**
Ein **Type Guard** ist eine spezielle Bedingung oder Funktion, mit der TypeScript erkennt, welchen konkreten Typ eine Variable in einem Union-Type-Kontext hat.
→ Er hilft beim **Type Narrowing**, sodass TypeScript innerhalb des Blocks mit dem spezifischen Typ arbeiten kann.

---

### Beispiel 1 – `typeof` als Type Guard

```js
function printValue(value: string | number) {
  if (typeof value === "string") {
    console.log(value.toUpperCase()) // value: string
  } else {
    console.log(value.toFixed(2))    // value: number
  }
}
```

---

### Beispiel 2 – `instanceof` als Type Guard

```js
class Dog {
  bark() { console.log("Wuff!") }
}
class Cat {
  meow() { console.log("Miau!") }
}

function makeSound(animal: Dog | Cat) {
  if (animal instanceof Dog) {
    animal.bark() // animal: Dog
  } else {
    animal.meow() // animal: Cat
  }
}
```

---

### Beispiel 3 – Property Check (`in` Operator)

```js
type Fish = { swim: () => void }
type Bird = { fly: () => void }

function move(animal: Fish | Bird) {
  if ("swim" in animal) {
    animal.swim() // animal: Fish
  } else {
    animal.fly()  // animal: Bird
  }
}
```

---

### Beispiel 4 – Benutzerdefinierter Type Guard (`is`-Syntax)

```js
type Car = { drive: () => void }
type Boat = { sail: () => void }

function isCar(vehicle: Car | Boat): vehicle is Car {
  return (vehicle as Car).drive !== undefined
}

function useVehicle(vehicle: Car | Boat) {
  if (isCar(vehicle)) {
    vehicle.drive() // Typ: Car
  } else {
    vehicle.sail()  // Typ: Boat
  }
}
```

---

### Zusammenfassung

* **Type Guards** = Bedingungen/Funktionen, die Typen präzisieren.
* Varianten:

  * `typeof` (für primitive Typen)
  * `instanceof` (für Klassen)
  * `in` Operator (für Properties)
  * benutzerdefinierte Type Guards (`is`-Syntax)
* Zweck: **sicheres Type Narrowing** in Union Types.

🔗 Quellen:

* [TypeScript Handbook – Narrowing](https://www.typescriptlang.org/docs/handbook/2/narrowing.html)
* [React TS Cheatsheet – Type Guards](https://react-typescript-cheatsheet.netlify.app/docs/basic/troubleshooting/types/#type-guards)

  **[⬆ Наверх](#top)**

23. ### <a name="23"></a> Wie funktioniert der Operator in bei der Typprüfung?

### Der `in`-Operator bei der Typprüfung in TypeScript

**Definition:**
Der **`in`-Operator** prüft, ob ein bestimmtes Property in einem Objekt existiert.
In TypeScript wird er als **Type Guard** genutzt, um zwischen verschiedenen Typen in einer Union zu unterscheiden.

---

### Beispiel 1 – Unterschiedliche Objekt-Typen

```js
type Dog = { bark: () => void }
type Cat = { meow: () => void }

function makeSound(animal: Dog | Cat) {
  if ("bark" in animal) {
    animal.bark() // animal: Dog
  } else {
    animal.meow() // animal: Cat
  }
}
```

➡️ Der `in`-Check sagt TypeScript:

* Wenn `bark` vorhanden ist → Typ ist `Dog`.
* Ansonsten → Typ ist `Cat`.

---

### Beispiel 2 – Optionale Properties

```js
interface User {
  id: number
  name: string
  email?: string
}

function hasEmail(user: User) {
  if ("email" in user) {
    console.log("User hat eine Email:", user.email)
  } else {
    console.log("Keine Email")
  }
}
```

---

### Beispiel 3 – Discriminated Unions

```js
type Circle = { kind: "circle"; radius: number }
type Square = { kind: "square"; side: number }

function area(shape: Circle | Square) {
  if ("radius" in shape) {
    return Math.PI * shape.radius ** 2 // Circle
  } else {
    return shape.side * shape.side     // Square
  }
}
```

---

### Zusammenfassung

* **`in`-Operator** prüft, ob ein Property existiert.
* In TypeScript dient er als **Type Guard** für Union Types.
* Typische Nutzung: Unterscheidung zwischen Objekten mit unterschiedlichen Eigenschaften oder optionalen Feldern.

🔗 Quellen:

* [TypeScript Handbook – Narrowing mit `in`](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-the-in-operator)
* [MDN – in Operator](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/in)

  **[⬆ Наверх](#top)**

24. ### <a name="24"></a> Wie funktioniert typeof in TypeScript?

### `typeof` in TypeScript

**Definition:**
In TypeScript hat `typeof` **zwei unterschiedliche Einsatzmöglichkeiten**:

1. **Zur Laufzeit** → wie in JavaScript, um den Typ eines Wertes zu prüfen.
2. **Zur Compile-Zeit** → um den Typ einer Variablen/Funktion zu extrahieren und wiederzuverwenden.

---

## 1. `typeof` zur Laufzeit (Type Guard)

Verhält sich wie in JavaScript, gibt einen **String** mit dem Typ zurück.
Wird in TypeScript für **Type Narrowing** genutzt.

```js
function printValue(value: string | number) {
  if (typeof value === "string") {
    console.log(value.toUpperCase()) // value: string
  } else {
    console.log(value.toFixed(2))    // value: number
  }
}
```

Mögliche Ergebnisse: `"string"`, `"number"`, `"boolean"`, `"object"`, `"function"`, `"undefined"`, `"symbol"`, `"bigint"`.

---

## 2. `typeof` zur Compile-Zeit (Type Query Operator)

Damit kann man den **Typ einer bestehenden Variable/Funktion** für eine Typdefinition wiederverwenden.

```js
let user = { id: 1, name: "Sergii" }

// Extrahiert den Typ von user
type User = typeof user

const admin: User = { id: 2, name: "Anna" } // ✅ korrekt
```

---

## 3. `typeof` für Funktionen

```js
function add(a: number, b: number) {
  return a + b
}

type AddFunction = typeof add
// AddFunction ist: (a: number, b: number) => number
```

---

### Zusammenfassung

* **Laufzeit (`typeof` als Operator):** gibt den primitiven JS-Typ zurück, nutzbar als Type Guard.
* **Compile-Zeit (`typeof` als Type Query):** extrahiert den Typ einer bestehenden Variablen oder Funktion.
* Vorteil: weniger Code-Duplikation, sicheres Type Narrowing.

🔗 Quellen:

* [TypeScript Handbook – typeof](https://www.typescriptlang.org/docs/handbook/2/typeof-types.html)
* [TypeScript Handbook – Narrowing mit typeof](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#typeof-type-guards)

  **[⬆ Наверх](#top)**

25. ### <a name="25"></a> Wie funktioniert instanceof?

### `instanceof` in TypeScript

**Definition:**
Der Operator **`instanceof`** prüft **zur Laufzeit**, ob ein Objekt von einer bestimmten **Klasse oder einem Konstruktor** erstellt wurde.
In TypeScript wird er als **Type Guard** verwendet, um den Typ innerhalb eines Blocks einzugrenzen (**Type Narrowing**).

---

### Beispiel 1 – Klassenprüfung

```js
class Dog {
  bark() { console.log("Wuff!") }
}

class Cat {
  meow() { console.log("Miau!") }
}

function makeSound(animal: Dog | Cat) {
  if (animal instanceof Dog) {
    animal.bark() // animal: Dog
  } else {
    animal.meow() // animal: Cat
  }
}
```

---

### Beispiel 2 – Mit eingebauten Objekten

```js
function logDate(date: Date | string) {
  if (date instanceof Date) {
    console.log("Datum:", date.toISOString()) // date: Date
  } else {
    console.log("String:", date.toUpperCase()) // date: string
  }
}
```

---

### Beispiel 3 – Nicht für primitive Typen

```js
let value = "Hallo"

console.log(value instanceof String) // ❌ false (Primitives sind keine Instanzen)
```

👉 Für Primitives verwendet man `typeof`, nicht `instanceof`.

---

### Vergleich zu anderen Type Guards

* **`typeof`** → für primitive Typen (`string`, `number`, `boolean`, …).
* **`instanceof`** → für Klassen und Objekte, die mit `new` erstellt wurden.
* **`in`** → für Property-Prüfungen in Objekten.

---

### Zusammenfassung

* **`instanceof`** prüft, ob ein Objekt von einer bestimmten Klasse/Konstruktor stammt.
* Dient als **Type Guard** in Union Types.
* Funktioniert nur bei **Objekten/Klassen**, nicht bei Primitives.

🔗 Quellen:

* [TypeScript Handbook – Narrowing mit `instanceof`](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#instanceof-narrowing)
* [MDN – instanceof](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/instanceof)

  **[⬆ Наверх](#top)**

26. ### <a name="26"></a> Was sind Discriminated Unions (diskriminierte Typen)?

### Discriminated Unions (diskriminierte Typen) in TypeScript

**Definition:**
Ein **Discriminated Union** ist ein **Union Type**, bei dem jede Variante ein gemeinsames, eindeutiges Feld (das sog. **Discriminant**) enthält.
TypeScript kann dadurch den Typ automatisch unterscheiden (**Type Narrowing**).

---

### Beispiel 1 – Shapes

```js
interface Circle {
  kind: "circle"   // Discriminant
  radius: number
}

interface Square {
  kind: "square"   // Discriminant
  side: number
}

type Shape = Circle | Square

function area(shape: Shape): number {
  switch (shape.kind) {
    case "circle":
      return Math.PI * shape.radius ** 2
    case "square":
      return shape.side * shape.side
  }
}
```

➡️ `kind` diskriminiert zwischen `Circle` und `Square`.

---

### Beispiel 2 – API-Status

```js
type ApiResponse =
  | { status: "success"; data: string }
  | { status: "error"; error: Error }
  | { status: "loading" }

function handleResponse(res: ApiResponse) {
  if (res.status === "success") {
    console.log("Data:", res.data)
  } else if (res.status === "error") {
    console.error("Fehler:", res.error.message)
  } else {
    console.log("Lädt...")
  }
}
```

---

### Beispiel 3 – Exhaustive Checking mit `never`

```js
function exhaustiveCheck(x: never): never {
  throw new Error("Unreachable code")
}

function handleShape(shape: Shape) {
  switch (shape.kind) {
    case "circle": return Math.PI * shape.radius ** 2
    case "square": return shape.side * shape.side
    default: return exhaustiveCheck(shape) // ⛔ Compiler-Fehler, falls neuer Typ fehlt
  }
}
```

---

### Vorteile

* Bessere **Typ-Sicherheit** bei Union Types.
* TypeScript erkennt automatisch, welcher Typ in welchem Zweig vorliegt.
* Erleichtert **Fehlerprävention** durch Exhaustive Checks.

---

### Zusammenfassung

* **Discriminated Unions** = Union Types mit einem gemeinsamen Feld (`kind`, `status`, etc.).
* Dienen zur klaren Typunterscheidung.
* Sehr nützlich in **Switch-Statements** und bei **API-Responses** oder **React-Props**.

🔗 Quellen:

* [TypeScript Handbook – Discriminated Unions](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#discriminated-unions)
* [React TS Cheatsheet – Discriminated Unions](https://react-typescript-cheatsheet.netlify.app/docs/advanced/discriminated_unions/)

  **[⬆ Наверх](#top)**

27. ### <a name="27"></a> Was ist der Unterschied zwischen interface und abstract class?

### Unterschied zwischen `interface` und `abstract class` in TypeScript

#### **1. Interface**

* Beschreibt **nur die Struktur** (Vertrag), aber keine Implementierung.
* Enthält **keinen Code**, nur Signaturen (Properties, Methoden).
* Eine Klasse kann mehrere Interfaces implementieren.

```js
interface Flyable {
  fly(): void
}

class Bird implements Flyable {
  fly() {
    console.log("Der Vogel fliegt 🕊️")
  }
}
```

---

#### **2. Abstract Class**

* Kann sowohl **abstrakte Methoden** (ohne Implementierung) als auch **konkrete Methoden** (mit Code) enthalten.
* Kann **Felder** und **Konstruktoren** haben.
* Klassen können nur **eine abstrakte Klasse** erweitern (Einzelvererbung).

```js
abstract class Animal {
  constructor(public name: string) {}

  abstract makeSound(): void // muss implementiert werden

  move(): void {
    console.log(`${this.name} bewegt sich`)
  }
}

class Dog extends Animal {
  makeSound() {
    console.log("Wuff!")
  }
}

const rex = new Dog("Rex")
rex.makeSound() // Wuff!
rex.move()      // Rex bewegt sich
```

---

### **3. Vergleichstabelle**

| Aspekt                 | `interface`                     | `abstract class`                           |
| ---------------------- | ------------------------------- | ------------------------------------------ |
| **Implementierung**    | Keine, nur Vertrag              | Kann Code enthalten                        |
| **Konstruktor**        | ❌ Nein                          | ✅ Ja                                       |
| **Felder mit Werten**  | ❌ Nein                          | ✅ Ja                                       |
| **Abstrakte Methoden** | ✅ Nur Signaturen                | ✅ Ja                                       |
| **Normale Methoden**   | ❌ Nein                          | ✅ Ja                                       |
| **Mehrfachverwendung** | ✅ Mehrere Interfaces pro Klasse | ❌ Nur eine abstrakte Klasse pro Klasse     |
| **Verwendung**         | Für reine Strukturdefinition    | Für Basisklassen mit gemeinsamem Verhalten |

---

### **Wann verwenden?**

* **Interface** → wenn du nur einen Vertrag beschreiben willst (z. B. Props, Data Models, API-Schemas).
* **Abstract Class** → wenn du **gemeinsames Verhalten + Vertrag** für Subklassen definieren willst.

---

### Zusammenfassung

* **`interface`** = reine Struktur, keine Implementierung, unterstützt Mehrfach-Implementierung.
* **`abstract class`** = Kombination aus Vertrag und (teilweiser) Implementierung, mit Konstruktor und Feldern.

🔗 Quellen:

* [TypeScript Handbook – Interfaces](https://www.typescriptlang.org/docs/handbook/2/objects.html)
* [TypeScript Handbook – Classes](https://www.typescriptlang.org/docs/handbook/2/classes.html#abstract-classes)

  **[⬆ Наверх](#top)**

28. ### <a name="28"></a> Wie implementiert man Funktionsüberladungen (function overloads) in TypeScript?

### Funktionsüberladungen (Function Overloads) in TypeScript

**Definition:**
Mit **Function Overloads** kann eine Funktion **mehrere Signaturen** haben, aber nur **eine Implementierung**.
Dadurch können unterschiedliche Argumenttypen oder Rückgabewerte abgebildet werden.

---

### Syntax

1. **Mehrere Signaturen (Overloads)**
2. **Eine gemeinsame Implementierung**

---

### Beispiel 1 – String vs. Number Eingabe

```js
// Overload-Signaturen
function reverse(value: string): string
function reverse(value: number): number

// Implementierung
function reverse(value: string | number): string | number {
  if (typeof value === "string") {
    return value.split("").reverse().join("")
  } else {
    return Number(value.toString().split("").reverse().join(""))
  }
}

console.log(reverse("Sergii")) // iigreS
console.log(reverse(12345))    // 54321
```

➡️ Der Aufrufer sieht die Überladungen (`string → string`, `number → number`),
aber die Implementierung deckt beide Fälle ab.

---

### Beispiel 2 – Mehrere Argumenttypen

```js
function getLength(value: string): number
function getLength(value: any[]): number

function getLength(value: string | any[]): number {
  return value.length
}

console.log(getLength("Hallo"))   // 5
console.log(getLength([1, 2, 3])) // 3
```

---

### Beispiel 3 – Optional und Union

```js
function combine(a: number, b: number): number
function combine(a: string, b: string): string

function combine(a: number | string, b: number | string): number | string {
  if (typeof a === "string" && typeof b === "string") {
    return a + b
  }
  if (typeof a === "number" && typeof b === "number") {
    return a + b
  }
  throw new Error("Ungültige Argumente")
}

console.log(combine(5, 10))      // 15
console.log(combine("Hi ", "TS")) // Hi TS
```

---

### Zusammenfassung

* **Function Overloads** = mehrere Signaturen, eine Implementierung.
* Vorteil: bessere Typ-Sicherheit und IntelliSense.
* Syntax: **Signaturen oben**, **Implementierung unten**.

🔗 Quellen:

* [TypeScript Handbook – Functions (Overloads)](https://www.typescriptlang.org/docs/handbook/2/functions.html#function-overloads)
* [MDN – Funktionen in JS (Grundlage)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Functions)

  **[⬆ Наверх](#top)**

29. ### <a name="29"></a> Was sind Index Signatures?

### Index Signatures in TypeScript

**Definition:**
Eine **Index Signature** erlaubt es, die Typen von Objekten zu beschreiben, deren Schlüssel **nicht im Voraus bekannt** sind.
Damit sagt man: *„Dieses Objekt kann beliebig viele Properties haben, und ihre Schlüssel/Werte haben einen bestimmten Typ.“*

---

### Beispiel 1 – Einfache Index Signature

```js
interface StringArray {
  [index: number]: string
}

const names: StringArray = ["Anna", "Tom", "Sergii"]
console.log(names[0]) // Anna
```

➡️ Jeder numerische Index (`number`) muss einen `string` liefern.

---

### Beispiel 2 – String-Keys

```js
interface Dictionary {
  [key: string]: string
}

const translations: Dictionary = {
  hello: "Hallo",
  bye: "Tschüss"
}

console.log(translations["hello"]) // Hallo
```

---

### Beispiel 3 – Mischung mit festen Properties

```js
interface User {
  id: number
  name: string
  [key: string]: string | number // erlaubt zusätzliche Properties
}

const u: User = {
  id: 1,
  name: "Sergii",
  role: "Admin"
}
```

---

### Beispiel 4 – Readonly Index Signature

```js
interface ReadonlyArrayLike {
  readonly [index: number]: string
}

const arr: ReadonlyArrayLike = ["A", "B"]
// arr[0] = "X" // ❌ Fehler: readonly
```

---

### Einschränkungen

* Der Werttyp der Index Signature muss **alle festen Properties** abdecken.

  ```js
  interface Bad {
    name: string
    [key: string]: number // ❌ Fehler, da name: string nicht kompatibel
  }
  ```

---

### Zusammenfassung

* **Index Signatures** = definieren Typen für unbekannte Schlüssel/Werte.
* Syntax: `[key: string]: WertTyp` oder `[index: number]: WertTyp`.
* Einsatz: Dictionaries, flexible Objekte, Maps.

🔗 Quellen:

* [TypeScript Handbook – Index Signatures](https://www.typescriptlang.org/docs/handbook/2/objects.html#index-signatures)
* [React TS Cheatsheet – Index Signatures](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example#index-signatures)

  **[⬆ Наверх](#top)**

30. ### <a name="30"></a> Was ist keyof und wofür wird es verwendet?

### `keyof` in TypeScript

**Definition:**
Der **`keyof` Operator** erzeugt einen Typ, der alle **Schlüssel** (Property-Namen) eines Objekttyps als **Union Type** enthält.

---

### Beispiel 1 – Einfaches Objekt

```js
interface User {
  id: number
  name: string
  isAdmin: boolean
}

type UserKeys = keyof User
// UserKeys = "id" | "name" | "isAdmin"
```

➡️ `keyof` extrahiert `"id" | "name" | "isAdmin"` als Union.

---

### Beispiel 2 – Nutzung in Funktionen

```js
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key]
}

const user: User = { id: 1, name: "Sergii", isAdmin: true }

const name = getProperty(user, "name")   // string
const admin = getProperty(user, "isAdmin") // boolean
// getProperty(user, "age") ❌ Fehler: "age" existiert nicht in User
```

➡️ Vorteil: **sichere Property-Zugriffe** ohne Magic Strings.

---

### Beispiel 3 – Mit `typeof`

```js
const config = {
  url: "/api",
  timeout: 5000
}

type ConfigKeys = keyof typeof config
// "url" | "timeout"
```

---

### Beispiel 4 – Kombination mit Mapped Types

```js
type ReadonlyUser = {
  readonly [K in keyof User]: User[K]
}

// Alle Properties von User werden readonly
```

---

### Zusammenfassung

* **`keyof`** = erzeugt Union der Schlüssel eines Typs.
* Verwendung: generische Funktionen, sichere Property-Zugriffe, Mapped Types.
* Typische Kombination: `keyof`, `typeof`, `in`.

🔗 Quellen:

* [TypeScript Handbook – keyof](https://www.typescriptlang.org/docs/handbook/2/keyof-types.html)
* [React TS Cheatsheet – keyof usage](https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase#keyof-and-typeof)

  **[⬆ Наверх](#top)**  

31. ### <a name="31"></a> Wie funktioniert der Operator as?

### Der `as` Operator in TypeScript

**Definition:**
Der **`as` Operator** wird für **Type Assertions (Typumwandlungen)** verwendet.
Damit sagt man dem Compiler: *„Vertraue mir, dieser Wert hat einen bestimmten Typ.“*
Er ändert nichts am **Laufzeitwert**, sondern nur an der **Typprüfung** von TypeScript.

---

### Beispiel 1 – Einfache Typumwandlung

```js
let value: unknown = "Hallo TypeScript"
let strLength: number = (value as string).length

console.log(strLength) // 16
```

➡️ Der Compiler behandelt `value` innerhalb der Klammern als `string`.

---

### Beispiel 2 – DOM-Manipulation

```js
const input = document.querySelector("input") as HTMLInputElement
input.value = "Sergii"
```

➡️ Ohne `as` kennt TypeScript nur den Typ `Element | null`.
Mit `as` wird er auf `HTMLInputElement` eingeschränkt.

---

### Beispiel 3 – Union Type Spezifizierung

```js
type Bird = { fly: () => void }
type Fish = { swim: () => void }

let pet: Bird | Fish = { swim: () => console.log("Schwimmt") }

;(pet as Fish).swim() // ✅ erlaubt
```

---

### Beispiel 4 – Doppelte Typumwandlung (Edge Case)

```js
let num: number = 10
let str = num as unknown as string // ❌ unsicher, aber manchmal genutzt
```

---

### Wichtige Hinweise

* `as` ist **keine Typkonvertierung** wie in anderen Sprachen (z. B. `int → string`),
  sondern nur ein Hinweis für den Compiler.
* Missbrauch kann zu **Laufzeitfehlern** führen, wenn man falsche Annahmen macht.

---

### Zusammenfassung

* **`as` Operator** = Type Assertion, ändert nur den Typ für den Compiler, nicht den Wert zur Laufzeit.
* Typische Nutzung: DOM-Elemente, Union Types, `unknown` → spezifischer Typ.
* Vorsicht: kann Sicherheit unterlaufen, sollte sparsam und bewusst eingesetzt werden.

🔗 Quellen:

* [TypeScript Handbook – Type Assertions](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-assertions)
* [MDN – DOM querySelector](https://developer.mozilla.org/ru/docs/Web/API/Document/querySelector)

  **[⬆ Наверх](#top)**

32. ### <a name="32"></a> Was ist der Unterschied zwischen as const und einem normalen const?

### Unterschied zwischen `const` und `as const` in TypeScript

---

#### **1. Normales `const` (JavaScript/TypeScript)**

* Bedeutet, dass die **Variable nicht neu zugewiesen** werden kann.
* Der Wert selbst bleibt aber oft **mutierbar** (bei Objekten/Arrays).
* Typ wird **verallgemeinert** (z. B. `string`, `number`).

```js
const role = "admin"
// Typ: string (kein Literal), Wert: "admin"
```

---

#### **2. `as const` (TypeScript)**

* Erzwingt eine **Literal Inferenz**:

  * Der Wert bekommt den **engsten möglichen Typ** (statt `string` → `"admin"`).
* Macht **alle Properties readonly** (bei Objekten und Arrays).

```js
const role = "admin" as const
// Typ: "admin" (Literal), Wert: "admin"
```

---

### Beispiele

#### **Beispiel 1 – String vs. Literal**

```js
const status = "success"
// Typ: string

const status2 = "success" as const
// Typ: "success" (Literal)
```

---

#### **Beispiel 2 – Objekte**

```js
const user = { id: 1, role: "admin" }
// Typ: { id: number; role: string }

const user2 = { id: 1, role: "admin" } as const
// Typ: { readonly id: 1; readonly role: "admin" }
```

---

#### **Beispiel 3 – Arrays**

```js
const numbers = [1, 2, 3]
// Typ: number[]

const numbers2 = [1, 2, 3] as const
// Typ: readonly [1, 2, 3]
```

---

### **Vergleichstabelle**

| Aspekt           | `const`                              | `as const`                              |
| ---------------- | ------------------------------------ | --------------------------------------- |
| Variablenbindung | unveränderlich                       | unveränderlich                          |
| Typ-Inferenz     | allgemeiner Typ (`string`, `number`) | Literal-Typ (`"admin"`, `1`)            |
| Objekte/Arrays   | veränderbar                          | `readonly`                              |
| Einsatzgebiet    | normales JS-Verhalten                | für präzise Typisierung & Immutabilität |

---

### Zusammenfassung

* **`const`** = normale Konstantenbindung, Typ wird verallgemeinert.
* **`as const`** = engste mögliche Typen (Literal), zusätzlich `readonly`.
* Nützlich für:

  * **Discriminated Unions**
  * **Objekte/Arrays als feste Konfigurationen**
  * **Props in React**

🔗 Quellen:

* [TypeScript Handbook – const assertions](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-inference)
* [React TS Cheatsheet – as const](https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase#literal-types-as-const)

  **[⬆ Наверх](#top)**

33. ### <a name="33"></a> Was macht der Operator satisfies (TS 4.9+)?

### Der `satisfies` Operator in TypeScript (seit 4.9)

**Definition:**
Der Operator **`satisfies`** prüft, ob ein Wert einen bestimmten Typ erfüllt (**Type Constraint**), **ohne** den engeren Typ des Werts zu verlieren.
Er ist eine Art *Kompromiss zwischen Type Assertion (`as`) und direkter Typannotation (`: Type`)*.

---

### Beispiel 1 – Normale Typannotation

```ts
type Role = "admin" | "user" | "guest"

const role: Role = "admin"
// Typ von role: "admin" | "user" | "guest"
```

👉 Nach der Annotation verliert `role` den spezifischen Literal-Typ `"admin"` und wird zum Union-Type.

---

### Beispiel 2 – Mit `as` (unsafe)

```ts
const role = "admin" as Role
// Typ von role: Role ("admin" | "user" | "guest")
```

👉 Compiler nimmt an, dass es passt – aber kein echter Check, da `as` nur „erzwingt“.

---

### Beispiel 3 – Mit `satisfies` ✅

```ts
type Role = "admin" | "user" | "guest"

const role = "admin" satisfies Role
// Typ von role: "admin" (Literal bleibt erhalten)
// Compiler prüft: "admin" ist Teil von Role → ✅ korrekt
```

👉 Vorteil: Wert bleibt **eng getypt** (`"admin"`) und erfüllt trotzdem die Bedingung `Role`.

---

### Beispiel 4 – Praktisch bei Objekten

```ts
type Config = {
  url: string
  method: "GET" | "POST"
}

const config = {
  url: "/api",
  method: "GET"
} satisfies Config

// Typ von config.method = "GET" (Literal, nicht nur "GET" | "POST")
```

👉 Mit `: Config` wäre `config.method` nur `"GET" | "POST"`.
👉 Mit `satisfies` bleibt es `"GET"`.

---

### Beispiel 5 – Exhaustiveness Checks

```ts
type Status = "success" | "error" | "loading"

const states = ["success", "error", "loading"] satisfies Status[]
// Typ: ("success" | "error" | "loading")[]
// Compiler prüft: alle Elemente gehören zu Status
```

---

### Zusammenfassung

* **`satisfies`** prüft, ob ein Wert zu einem Typ passt, **ohne den präzisen Typ zu verlieren**.
* Unterschied zu anderen Varianten:

  * `: Type` → Typ wird erweitert/verallgemeinert.
  * `as Type` → Compiler vertraut blind, keine echte Prüfung.
  * `satisfies Type` → Typprüfung + Beibehaltung der Literaltypen.

🔗 Quellen:

* [TypeScript 4.9 – satisfies Operator](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html#the-satisfies-operator)
* [React TS Cheatsheet – satisfies](https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase#satisfies-operator)

  **[⬆ Наверх](#top)**

34. ### <a name="34"></a> Was sind Assertion Functions?

### Assertion Functions in TypeScript

**Definition:**
Eine **Assertion Function** ist eine spezielle Funktion, die TypeScript mitteilt:
*"Wenn diese Funktion erfolgreich zurückkehrt, kannst du davon ausgehen, dass eine bestimmte Bedingung erfüllt ist."*
→ Sie werden mit dem Rückgabetyp `asserts` deklariert und dienen der **Typprüfung** (Type Narrowing).

---

### Beispiel 1 – Einfache Assertion Function

```ts
function assertIsString(value: unknown): asserts value is string {
  if (typeof value !== "string") {
    throw new Error("Wert ist kein String")
  }
}

function printUppercase(value: unknown) {
  assertIsString(value) 
  // Ab hier: value hat Typ string
  console.log(value.toUpperCase())
}
```

➡️ Ohne `assertIsString` müsste man jedes Mal manuell prüfen.

---

### Beispiel 2 – Non-Null Assertion

```ts
function assertNotNull<T>(value: T): asserts value is NonNullable<T> {
  if (value === null || value === undefined) {
    throw new Error("Wert darf nicht null oder undefined sein")
  }
}

function process(value?: string | null) {
  assertNotNull(value)
  // Ab hier: value ist string
  console.log(value.trim())
}
```

---

### Beispiel 3 – Für komplexe Typen

```ts
type User = { id: number; name: string }

function assertIsUser(obj: any): asserts obj is User {
  if (typeof obj !== "object" || typeof obj.id !== "number" || typeof obj.name !== "string") {
    throw new Error("Kein gültiger User")
  }
}

const data: unknown = { id: 1, name: "Sergii" }

assertIsUser(data)
// Ab hier: data hat Typ User
console.log(data.name.toUpperCase())
```

---

### Vorteile

* Verhindern unnötige Type Assertions (`as`).
* Ermöglichen **saubere Typ Narrowing**.
* Praktisch für **Input-Validierung, API-Responses, Guards in React/Express**.

---

### Zusammenfassung

* **Assertion Functions** = Funktionen mit Rückgabetyp `asserts`, die Typen validieren.
* Nutzen: automatische Typ-Einschränkung, wenn die Assertion erfolgreich ist.
* Typische Form: `asserts value is Type`.

🔗 Quellen:

* [TypeScript Handbook – Assertion Functions](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#assertion-functions)
* [React TS Cheatsheet – Type Guards & Assertions](https://react-typescript-cheatsheet.netlify.app/docs/basic/troubleshooting/types/#user-defined-type-guards)

  **[⬆ Наверх](#top)**

35. ### <a name="35"></a> Was ist der Unterschied zwischen struktureller Typisierung (structural typing) und nominaler Typisierung (nominal typing)?

### Unterschied zwischen **struktureller Typisierung** und **nominaler Typisierung**

---

#### **1. Strukturelle Typisierung (Structural Typing)**

* In **TypeScript** verwendet.
* Zwei Typen sind **kompatibel**, wenn ihre **Struktur** (Shape) gleich ist – unabhängig vom Namen.
* „Duck Typing“: *Wenn es aussieht wie eine Ente und quakt wie eine Ente, ist es eine Ente.*

**Beispiel:**

```ts
interface Point {
  x: number
  y: number
}

interface Coordinate {
  x: number
  y: number
}

let p: Point = { x: 10, y: 20 }
let c: Coordinate = { x: 30, y: 40 }

p = c // ✅ erlaubt, gleiche Struktur
```

---

#### **2. Nominale Typisierung (Nominal Typing)**

* In Sprachen wie **Java, C#** üblich.
* Typen sind nur dann kompatibel, wenn sie **explizit denselben Namen** oder dieselbe Vererbung haben.
* Die Struktur allein reicht nicht.

**Beispiel (in TS simuliert):**

```ts
type USD = number & { readonly brand: unique symbol }
type EUR = number & { readonly brand: unique symbol }

let usd: USD = 10 as USD
let eur: EUR = 20 as EUR

usd = eur // ❌ Fehler, trotz gleicher Struktur (Nominalisierung durch unique symbol)
```

---

### Vergleich

| Merkmal             | Strukturell (TS)                        | Nominal (Java, C#)      |
| ------------------- | --------------------------------------- | ----------------------- |
| Vergleichsgrundlage | Struktur (Properties & Methoden)        | Name/Erklärung des Typs |
| Flexibilität        | Hoch                                    | Niedrig                 |
| Fehleranfälligkeit  | Kann ungewollte Kompatibilität zulassen | Strenger, sicherer      |
| Beispielsprachen    | TypeScript, Go                          | Java, C#, Rust          |

---

### Zusammenfassung

* **Structural Typing (TS):** Kompatibilität hängt nur von der **Form** ab.
* **Nominal Typing:** Kompatibilität hängt vom **Namen/Erklärung** ab.
* TypeScript ist **strukturell typisiert**, man kann aber nominale Typisierung mit Tricks (`unique symbol`) erzwingen.

🔗 Quellen:

* [TypeScript Handbook – Structural Typing](https://www.typescriptlang.org/docs/handbook/type-compatibility.html)
* [MDN – TypeScript Type System](https://www.typescriptlang.org/docs/)

  **[⬆ Наверх](#top)**

36. ### <a name="36"></a> Was sind Deklarationsdateien (.d.ts)?

### Deklarationsdateien (`.d.ts`) in TypeScript

**Definition:**
Eine **Deklarationsdatei** (`.d.ts`) enthält **nur Typinformationen** (Signaturen, Interfaces, Typen), aber **keinen ausführbaren Code**.
Sie dient dazu, JavaScript-Bibliotheken oder bereits kompilierte TypeScript-Module für den TypeScript-Compiler **typisiert verfügbar** zu machen.

---

### Eigenschaften

* Endung: **`.d.ts`**
* Enthält keine Implementierungen → nur Typdefinitionen.
* Wird automatisch von TypeScript verwendet, wenn eine Bibliothek Typen mitliefert.
* Häufig im Verzeichnis `@types/` (z. B. aus **DefinitelyTyped**).

---

### Beispiel 1 – Eigene Deklarationsdatei

`math.d.ts`:

```ts
declare module "math-lib" {
  export function add(a: number, b: number): number
  export const PI: number
}
```

Nutzung:

```ts
import { add, PI } from "math-lib"

console.log(add(2, 3))  // 5
console.log(PI)         // number
```

---

### Beispiel 2 – Globale Deklaration

```ts
// global.d.ts
declare global {
  interface Window {
    myAppVersion: string
  }
}
```

Nutzung:

```ts
console.log(window.myAppVersion)
```

---

### Beispiel 3 – Typen für externe Bibliotheken

Wenn eine JS-Library keine Typen mitliefert:

```bash
npm install @types/lodash --save-dev
```

👉 Installiert Deklarationsdateien von **DefinitelyTyped**.

---

### Zusammenfassung

* **`.d.ts` Dateien** = Typdefinitionen ohne Implementierung.
* Nutzen: Typprüfung und IntelliSense für **JS-Bibliotheken** oder eigene APIs.
* Typische Orte:

  * Bibliotheken mitgeliefert (`node_modules/@types/`)
  * Eigene Projekte (`global.d.ts`)

🔗 Quellen:

* [TypeScript Handbook – Declaration Files](https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html)
* [DefinitelyTyped Repository](https://github.com/DefinitelyTyped/DefinitelyTyped)

  **[⬆ Наверх](#top)**

37. ### <a name="37"></a> Wie bindet man eine externe JS-Bibliothek ohne Typen ein?

### Externe JS-Bibliothek **ohne Typen** in TypeScript einbinden

#### 1) Prüfen, ob Typen existieren

```bash
npm i -D @types/<libname>
```

Wenn vorhanden → normal importieren. Wenn **nicht** vorhanden, weiter mit 2–5.

---

#### 2) Schneller Start: eigenes **Shims**-Modul (`global.d.ts` oder `types/<lib>.d.ts`)

```ts
// types/untyped-lib.d.ts
declare module "untyped-lib" {
  // minimaler Start – alles als any
  const api: any
  export default api
}
```

Verwendung:

```js
import lib from "untyped-lib"
lib.doSomething() // Typprüfung ausgesetzt (any)
```

---

#### 3) Besser: **gezielte Typen** statt `any`

```ts
// types/untyped-lib.d.ts
declare module "untyped-lib" {
  export interface Options {
    retry?: number
    baseUrl: string
  }
  export function createClient(opts: Options): {
    get(path: string): Promise<string>
    post<T>(path: string, body: T): Promise<void>
  }
}
```

```js
import { createClient } from "untyped-lib"

const client = createClient({ baseUrl: "/api", retry: 2 })
const text = await client.get("/status")
```

---

#### 4) Globales Script (CDN) typisieren

```ts
// global.d.ts
declare global {
  interface Window {
    MyLib: {
      version: string
      init(config: { key: string }): void
    }
  }
}
export {} // macht die Datei zum Modul
```

```js
// nach <script src=".../mylib.js"></script>
window.MyLib.init({ key: "abc" })
```

---

#### 5) Übergangsweise absichern: `unknown` + Laufzeit-Guards (statt `any`)

```js
import lib from "untyped-lib"

function isClient(x: unknown): x is { get: (p: string) => Promise<string> } {
  return !!x && typeof (x as any).get === "function"
}

const client: unknown = lib.createClient?.({ baseUrl: "/api" })
if (isClient(client)) {
  const s = await client.get("/health")
}
```

---

#### 6) Notfalls (kurzfristig) unterdrücken

```js
// @ts-ignore: untyped third-party export
import lib from "untyped-lib"
```

> Nur punktuell verwenden; besser früh eigene `.d.ts` anlegen.

---

#### 7) tsconfig-Hinweise

* Eigene Typen einbinden: `"typeRoots": ["./types", "./node_modules/@types"]`
* Keine Fremdtypfehler beim Build: `"skipLibCheck": true` (optional, nicht sicherheitsrelevant)

---

### Zusammenfassung

* Falls keine offiziellen Typen existieren: **eigene `.d.ts`** schreiben.
* Start mit einfachem `declare module`, dann **gezielt typisieren** (Interfaces/Funktionssignaturen).
* Für globale Skripte: **`declare global`**.
* **`unknown` + Type Guards** statt `any` für mehr Sicherheit.
* `@ts-ignore` nur ausnahmsweise.

🔗 Quellen:

* [TypeScript Docs – Declaration Files](https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html)
* [TypeScript Docs – Modules & `declare module`](https://www.typescriptlang.org/docs/handbook/modules.html)
* [React TypeScript Cheatsheet – Working with 3rd-Party Libs](https://react-typescript-cheatsheet.netlify.app/docs/basic/troubleshooting/types/#third-party-libraries)
* [MDN – `window`](https://developer.mozilla.org/ru/docs/Web/API/Window)

  **[⬆ Наверх](#top)**

38. ### <a name="38"></a> Was sind Ambient Declarations (declare)?

### Ambient Declarations (`declare`) in TypeScript

**Definition:**
Ambient Declarations sind **Typdefinitionen für bereits existierenden Code** (meist JavaScript), damit der TypeScript-Compiler weiß, welche Variablen, Funktionen oder Module es gibt – auch wenn sie **nicht in TypeScript implementiert** sind.
👉 Sie enthalten **nur Typinformationen**, aber keine Implementierungen.

---

### 1. Globale Variablen deklarieren

```ts
// global.d.ts
declare const VERSION: string
```

Nutzung:

```ts
console.log(VERSION) // Compiler weiß: VERSION ist string
```

---

### 2. Funktionen deklarieren

```ts
declare function logMessage(message: string): void

logMessage("Hallo") // gültig, auch ohne Implementierung in TS
```

---

### 3. Klassen deklarieren

```ts
declare class Person {
  constructor(name: string)
  greet(): void
}

let p = new Person("Sergii")
p.greet()
```

---

### 4. Module deklarieren

```ts
// math-lib.d.ts
declare module "math-lib" {
  export function add(a: number, b: number): number
}
```

Nutzung:

```ts
import { add } from "math-lib"
console.log(add(2, 3))
```

---

### 5. Namespace / Global erweitern

```ts
declare namespace NodeJS {
  interface ProcessEnv {
    NODE_ENV: "development" | "production"
  }
}
```

---

### Wann verwendet?

✅ Typische Einsatzfälle:

* **Externe JS-Bibliotheken ohne Typen** (eigene `.d.ts`).
* **Globale Variablen/Objekte** (z. B. `window`, `process`).
* **Erweiterung von bestehenden Typen** (z. B. Express `Request`).

---

### Zusammenfassung

* **Ambient Declarations (`declare`)** = reine Typinfos ohne Code.
* Nutzen: Beschreiben von vorhandenen Variablen, Funktionen, Klassen oder Modulen.
* Typische Orte: **`.d.ts`-Dateien**, Third-Party-Libs, globale Variablen.

🔗 Quellen:

* [TypeScript Handbook – Declaration Files](https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html)
* [TypeScript Handbook – Ambient Declarations](https://www.typescriptlang.org/docs/handbook/declaration-files/by-example.html)

  **[⬆ Наверх](#top)**

39. ### <a name="39"></a> Was ist strict mode in TypeScript?

### Strict Mode in TypeScript

**Definition:**
Der **Strict Mode** ist eine Sammlung von Compiler-Optionen in TypeScript, die die **strengste Typprüfung** aktivieren.
Er wird mit `"strict": true` in der `tsconfig.json` eingeschaltet.

---

### Enthaltene Optionen (ab Werk in `strict` enthalten)

1. **`strictNullChecks`**

   * `null` und `undefined` müssen explizit behandelt werden.

   ```ts
   let name: string = "Sergii"
   name = null // ❌ Fehler bei strictNullChecks
   ```

2. **`noImplicitAny`**

   * Variablen oder Parameter ohne Typ dürfen nicht automatisch `any` sein.

   ```ts
   function log(msg) { // ❌ Fehler
     console.log(msg)
   }
   ```

3. **`strictBindCallApply`**

   * Typprüfung für Methoden wie `bind`, `call`, `apply`.

4. **`strictFunctionTypes`**

   * Strengere Überprüfung bei Funktionszuweisungen.

5. **`strictPropertyInitialization`**

   * Klassen-Eigenschaften müssen im Konstruktor oder direkt initialisiert werden.

   ```ts
   class User {
     name: string // ❌ Fehler ohne Initialisierung
     constructor(name: string) {
       this.name = name // ✅
     }
   }
   ```

6. **`alwaysStrict`**

   * Alle Dateien werden im **JavaScript Strict Mode** kompiliert (`"use strict"`).

---

### Vorteile

* Weniger Laufzeitfehler durch strengere Typprüfung.
* Sicherere und besser wartbare Codebasis.
* Erhöht Codequalität besonders in großen Projekten.

---

### Zusammenfassung

* **Strict Mode** (`"strict": true`) = aktiviert alle wichtigen Sicherheitsprüfungen des Compilers.
* Beinhaltet u. a. `strictNullChecks`, `noImplicitAny`, `strictPropertyInitialization`.
* Ziel: maximale Typ-Sicherheit und Fehlervermeidung.

🔗 Quellen:

* [TypeScript Handbook – Strict Mode](https://www.typescriptlang.org/tsconfig#strict)
* [TSConfig Reference – Strict Options](https://www.typescriptlang.org/tsconfig#strictNullChecks)

  **[⬆ Наверх](#top)**

40. ### <a name="40"></a> Wozu dient strictNullChecks?

### `strictNullChecks` in TypeScript

**Definition:**
Die Option **`strictNullChecks`** erzwingt, dass `null` und `undefined` **nicht automatisch jedem Typ zugewiesen** werden dürfen.
👉 Ohne diese Option: `null` und `undefined` sind **Teil aller Typen**.
👉 Mit dieser Option: sie müssen **explizit** erlaubt werden (`| null`, `| undefined`).

---

### Beispiel 1 – Ohne `strictNullChecks` (unsicher)

```ts
let name: string = "Sergii"
name = null       // ✅ erlaubt (unsicher)
```

---

### Beispiel 2 – Mit `strictNullChecks: true` (sicher)

```ts
let name: string = "Sergii"
name = null       // ❌ Fehler: null nicht zuweisbar zu string

let safeName: string | null = "Sergii"
safeName = null   // ✅ erlaubt
```

---

### Beispiel 3 – Funktionen

```ts
function greet(user: string | null) {
  if (user !== null) {
    console.log("Hallo", user.toUpperCase())
  }
}

greet(null) // ✅ funktioniert, sicher geprüft
```

---

### Beispiel 4 – Optional Properties

```ts
interface User {
  id: number
  email?: string
}

function printEmail(user: User) {
  // user.email: string | undefined
  if (user.email) {
    console.log(user.email.toUpperCase())
  }
}
```

---

### Zusammenfassung

* **`strictNullChecks`** verhindert, dass `null` und `undefined` stillschweigend überall zugewiesen werden können.
* Erzwingt **explizite Behandlung** von `null` und `undefined`.
* Vorteil: weniger `Cannot read property of undefined`-Fehler zur Laufzeit.

🔗 Quellen:

* [TypeScript Handbook – strictNullChecks](https://www.typescriptlang.org/tsconfig#strictNullChecks)
* [Everyday Types – null & undefined](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#null-and-undefined)

  **[⬆ Наверх](#top)**  

41. ### <a name="41"></a> Wie typisiert man Parameter und Rückgabewerte von Funktionen?

### Funktionen typisieren: Parameter & Rückgabewerte

#### 1) Basis: Parameter- und Rückgabetyp

```js
// ESM-Export
export function add(a: number, b: number): number {
  return a + b
}
```

#### 2) Arrow Functions

```js
export const toUpper = (s: string): string => s.toUpperCase()
```

#### 3) Optional-, Default- und Rest-Parameter

```js
export function greet(name: string, title?: string): string {
  return title ? `${title} ${name}` : `Hallo ${name}`
}

export function pow(base: number, exp: number = 2): number {
  return base ** exp
}

export function sum(...nums: number[]): number {
  return nums.reduce((acc, n) => acc + n, 0)
}
```

#### 4) Void, Never, Union/Unknown in Signaturen

```js
export function log(msg: string): void {
  console.log(msg) // kein Rückgabewert
}

export function fail(message: string): never {
  throw new Error(message) // kehrt nie zurück
}

export function parseJson(json: string): unknown {
  return JSON.parse(json) // Callsite muss narrowen
}
```

#### 5) Funktions-Typen (Alias/Interface)

```js
export type Comparator<T> = (a: T, b: T) => number

export interface Fetcher {
  (url: string): Promise<string>
}

export const byLength: Comparator<string> = (a, b) => a.length - b.length
```

#### 6) Generische Funktionen

```js
export function identity<T>(value: T): T {
  return value
}

export function pick<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key]
}
```

#### 7) Async/Promise-Rückgaben

```js
export async function getText(url: string): Promise<string> {
  const res = await fetch(url)
  return res.text()
}
```

#### 8) Overloads (mehrere Signaturen, eine Implementierung)

```js
export function len(x: string): number
export function len<T>(x: T[]): number
export function len(x: string | unknown[]): number {
  return (x as any).length
}
```

#### 9) Kontext: React-Event-Handler (häufig im Frontend)

```js
// Beispiel: React + TS (ESM)
import type { ChangeEvent } from "react"

export const onChange = (e: ChangeEvent<HTMLInputElement>): void => {
  console.log(e.currentTarget.value)
}
```

---

### Zusammenfassung

* Parameter werden nach dem Namen, Rückgabewerte nach dem Parameterblock typisiert: `fn(a: A, b: B): R`.
* Verwende optionale (`?`), Default- und Rest-Parameter je nach Bedarf.
* Nutze `void`/`never` zielgerichtet; für unbekannte Rückgaben `unknown` + Narrowing.
* Funktions-Typen per **Type Alias** oder **Call-Signature in Interfaces**; Generics für Wiederverwendbarkeit.
* Overloads: mehrere Signaturen, **eine** Implementierung.
* In React Events streng typisieren (z. B. `ChangeEvent<HTMLInputElement>`).

**Quellen:**

* [TypeScript Docs – Functions](https://www.typescriptlang.org/docs/handbook/2/functions.html)
* [TypeScript Docs – Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
* [React TypeScript Cheatsheet – Event Handling](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/event_handling/)
* [MDN – Functions (JS-Grundlagen)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Functions)
* [React Docs](https://react.dev/)

  **[⬆ Наверх](#top)**

42. ### <a name="42"></a> Was sind optionale Parameter in Funktionen?

### Optionale Parameter in TypeScript-Funktionen

**Definition:**
Ein **optionaler Parameter** ist ein Funktionsparameter, der beim Aufruf **nicht zwingend angegeben** werden muss.
Man kennzeichnet ihn mit einem **Fragezeichen (`?`)** nach dem Parameternamen.

---

### Beispiel 1 – Einfacher optionaler Parameter

```ts
export function greet(name: string, title?: string): string {
  return title ? `${title} ${name}` : `Hallo ${name}`
}

greet("Sergii")            // Hallo Sergii
greet("Sergii", "Herr")    // Herr Sergii
```

➡️ `title` ist optional (`string | undefined`).

---

### Beispiel 2 – Kombination mit Default-Werten

```ts
export function pow(base: number, exp: number = 2): number {
  return base ** exp
}

pow(3)      // 9
pow(3, 3)   // 27
```

➡️ Unterschied: `?` → kann fehlen, `= Default` → hat immer einen Wert.

---

### Beispiel 3 – Mehrere optionale Parameter

```ts
export function createUser(id: number, name?: string, age?: number) {
  return { id, name, age }
}

createUser(1)                // { id: 1 }
createUser(2, "Anna")        // { id: 2, name: "Anna" }
createUser(3, "Tom", 25)     // { id: 3, name: "Tom", age: 25 }
```

---

### Einschränkungen

* Optionale Parameter müssen **am Ende der Parameterliste** stehen.
* Sie sind implizit `Typ | undefined`.

---

### Zusammenfassung

* **Optionale Parameter** (`param?: Type`) = Argumente, die beim Funktionsaufruf nicht zwingend übergeben werden müssen.
* Standardmäßig sind sie `Type | undefined`.
* Typischer Einsatz: flexible APIs, optionale Konfigurationen.

🔗 Quellen:

* [TypeScript Handbook – Functions](https://www.typescriptlang.org/docs/handbook/2/functions.html#optional-parameters)
* [MDN – Functions](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Functions)

  **[⬆ Наверх](#top)**

43. ### <a name="43"></a> Wie deklariert man Standardwerte für Parameter mit Typisierung?

### Standardwerte (Default Parameter) mit Typisierung in TypeScript

**Definition:**
Ein **Default-Parameter** ist ein Funktionsparameter, der einen **Standardwert** erhält, falls kein Argument übergeben wird.
In TypeScript wird der Typ entweder automatisch aus dem Standardwert **inferred** oder explizit angegeben.

---

### Beispiel 1 – Automatische Typinferenz

```ts
export function greet(name: string, title = "Herr"): string {
  return `${title} ${name}`
}

greet("Sergii")          // Herr Sergii
greet("Sergii", "Dr.")   // Dr. Sergii
```

➡️ `title` wird automatisch als `string` typisiert, weil der Standardwert `"Herr"` ist.

---

### Beispiel 2 – Explizite Typannotation

```ts
export function pow(base: number, exp: number = 2): number {
  return base ** exp
}

pow(3)    // 9
pow(3, 3) // 27
```

➡️ `exp: number = 2` → expliziter Typ + Default-Wert.

---

### Beispiel 3 – Union-Typ mit Default

```ts
type Role = "admin" | "user" | "guest"

export function createUser(name: string, role: Role = "user") {
  return { name, role }
}

createUser("Sergii")          // role = "user"
createUser("Anna", "admin")   // role = "admin"
```

---

### Beispiel 4 – Kombination mit Optionalem Parameter (selten nötig)

```ts
export function log(msg?: string, level: "info" | "error" = "info") {
  console.log(`[${level}]`, msg ?? "leer")
}
```

---

### Regeln

* Parameter mit Default-Werten sind **implizit optional**.
* Sie müssen nicht am Ende der Parameterliste stehen (anders als `?`).
* Typ wird **vom Wert oder Annotation** bestimmt.

---

### Zusammenfassung

* Default-Parameter = `param: Typ = Wert`.
* Typ wird entweder **inferred** oder **explizit angegeben**.
* Vorteil: klare Signaturen, weniger `undefined`.

🔗 Quellen:

* [TypeScript Handbook – Functions](https://www.typescriptlang.org/docs/handbook/2/functions.html#optional-parameters)
* [MDN – Default Parameters](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Default_parameters)

  **[⬆ Наверх](#top)**

44. ### <a name="44"></a> Was sind Rest-Parameter und wie typisiert man sie?

### Rest-Parameter in TypeScript

**Definition:**
Rest-Parameter (`...`) erlauben es, **eine variable Anzahl von Argumenten** an eine Funktion zu übergeben.
Sie werden in TypeScript als **Array eines Typs** typisiert.

---

### Beispiel 1 – Einfache Typisierung

```ts
export function sum(...numbers: number[]): number {
  return numbers.reduce((acc, n) => acc + n, 0)
}

sum(1, 2, 3, 4) // 10
```

➡️ `numbers: number[]` → alle Argumente müssen `number` sein.

---

### Beispiel 2 – Strings

```ts
export function concat(...parts: string[]): string {
  return parts.join(" ")
}

concat("TypeScript", "macht", "Spaß")
```

---

### Beispiel 3 – Kombination mit festen Parametern

```ts
export function greet(greeting: string, ...names: string[]): string {
  return `${greeting}, ${names.join(" und ")}!`
}

greet("Hallo", "Sergii", "Anna") // Hallo, Sergii und Anna!
```

---

### Beispiel 4 – Generics für Rest-Parameter

```ts
export function first<T>(...items: T[]): T {
  return items[0]
}

const num = first(1, 2, 3)         // number
const str = first("a", "b", "c")   // string
```

---

### Beispiel 5 – Tupel als Rest-Parameter (variadische Tupel, TS 4.0+)

```ts
type Point = [number, number]

export function logCoordinates(...coords: Point) {
  const [x, y] = coords
  console.log(`X=${x}, Y=${y}`)
}

logCoordinates(10, 20)
```

➡️ Rest-Parameter können auch **feste Strukturen** (Tupel) erzwingen.

---

### Zusammenfassung

* **Rest-Parameter** = `...args: Typ[]`.
* Erfassen variable Argumentlisten als Array.
* Erweiterbar mit **Generics** und **Tupeln** (seit TS 4.0).
* Typische Nutzung: Utility-Funktionen, Logging, flexible APIs.

🔗 Quellen:

* [TypeScript Handbook – Functions (Rest Parameters)](https://www.typescriptlang.org/docs/handbook/2/functions.html#rest-parameters-and-arguments)
* [MDN – Rest Parameters](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/rest_parameters)

  **[⬆ Наверх](#top)**

45. ### <a name="45"></a> Wie typisiert man Arrow Functions?

### Arrow Functions in TypeScript typisieren

Arrow Functions werden in TypeScript genauso typisiert wie normale Funktionen – nur mit der **Lambda-Syntax**.

---

### 1. Parameter- und Rückgabetyp explizit

```ts
export const add = (a: number, b: number): number => {
  return a + b
}
```

---

### 2. Typinferenz (Compiler erkennt den Rückgabewert selbst)

```ts
export const double = (x: number) => x * 2
// Rückgabewert: number (inferred)
```

---

### 3. Funktions-Typ mit Type Alias

```ts
type Comparator = (a: number, b: number) => number

export const compare: Comparator = (a, b) => a - b
```

---

### 4. Funktions-Typ mit Interface

```ts
interface Logger {
  (msg: string): void
}

export const log: Logger = (message) => console.log(message)
```

---

### 5. Arrow Function mit Generics

```ts
export const identity = <T>(value: T): T => value

const s = identity("Sergii") // string
const n = identity(42)       // number
```

---

### 6. React-Event-Handler (sehr häufig)

```ts
import type { ChangeEvent } from "react"

export const handleChange = (e: ChangeEvent<HTMLInputElement>): void => {
  console.log(e.currentTarget.value)
}
```

---

### Zusammenfassung

* Arrow Functions typisiert man mit `(param: Typ): RückgabeTyp => {}`.
* Rückgabetyp kann oft **inferred** werden.
* Für Wiederverwendbarkeit: **Type Alias** oder **Interface** für Funktionssignaturen.
* Generics ermöglichen flexible Arrow Functions.
* In React wichtig: Eventtypen (`ChangeEvent<HTMLInputElement>` usw.).

🔗 Quellen:

* [TypeScript Handbook – Functions](https://www.typescriptlang.org/docs/handbook/2/functions.html)
* [React TypeScript Cheatsheet – Event Handling](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/event_handling/)

  **[⬆ Наверх](#top)**

46. ### <a name="46"></a> Was sind Funktionsüberladungen?

### Funktionsüberladungen (Function Overloads) in TypeScript

**Definition:**
Funktionsüberladungen erlauben es, für **eine Funktion mehrere Signaturen** zu definieren.
Der Aufrufer sieht unterschiedliche Signaturen, aber die **Implementierung existiert nur einmal**.
→ Damit kann eine Funktion verschiedene **Argumenttypen** und **Rückgabewerte** unterstützen.

---

### Beispiel 1 – String vs. Number

```ts
// Überladungen (Signaturen)
function reverse(value: string): string
function reverse(value: number): number

// Implementierung (gemeinsam)
function reverse(value: string | number): string | number {
  if (typeof value === "string") {
    return value.split("").reverse().join("")
  }
  return Number(value.toString().split("").reverse().join(""))
}

reverse("Sergii") // string → "iigreS"
reverse(12345)    // number → 54321
```

---

### Beispiel 2 – Mehrere Argumenttypen

```ts
function getLength(value: string): number
function getLength(value: any[]): number

function getLength(value: string | any[]): number {
  return value.length
}

getLength("Hallo")   // 5
getLength([1, 2, 3]) // 3
```

---

### Beispiel 3 – Unterschiedliche Rückgabewerte

```ts
function combine(a: number, b: number): number
function combine(a: string, b: string): string

function combine(a: number | string, b: number | string): number | string {
  if (typeof a === "string" && typeof b === "string") {
    return a + b // string
  }
  if (typeof a === "number" && typeof b === "number") {
    return a + b // number
  }
  throw new Error("Ungültige Argumente")
}
```

---

### Regeln für Overloads

* **Signaturen oben**, **Implementierung unten**.
* Implementierung muss alle Fälle abdecken.
* TypeScript wählt anhand der Argumente die passende Signatur.

---

### Zusammenfassung

* **Funktionsüberladungen** = mehrere Signaturen für eine Funktion.
* Nützlich für Funktionen, die mit verschiedenen Eingabetypen arbeiten.
* Syntax: `function name(param: Typ): RückgabeTyp` (mehrfach), dann eine gemeinsame Implementierung.

🔗 Quellen:

* [TypeScript Handbook – Function Overloads](https://www.typescriptlang.org/docs/handbook/2/functions.html#function-overloads)
* [React TS Cheatsheet – Functions](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example#function-overloads)

  **[⬆ Наверх](#top)**

47. ### <a name="47"></a> Was sind Generics?

### Generics in TypeScript

**Definition:**
**Generics** sind Platzhalter für Typen, die es ermöglichen, **flexiblen, wiederverwendbaren und typsicheren Code** zu schreiben.
Man definiert einen Typ erst **zur Nutzung**, nicht beim Schreiben der Funktion oder Klasse.

---

### Beispiel 1 – Generische Funktion

```ts
function identity<T>(value: T): T {
  return value
}

const num = identity(42)         // T = number
const str = identity("Sergii")   // T = string
```

👉 Der Typ `T` wird automatisch **inferred**.

---

### Beispiel 2 – Generisches Array

```ts
function getFirst<T>(arr: T[]): T {
  return arr[0]
}

getFirst([1, 2, 3])      // number
getFirst(["a", "b", "c"]) // string
```

---

### Beispiel 3 – Generics mit Einschränkungen (`extends`)

```ts
interface HasLength {
  length: number
}

function logLength<T extends HasLength>(item: T): void {
  console.log(item.length)
}

logLength("Hallo")       // string (hat length)
logLength([1, 2, 3])     // Array (hat length)
```

---

### Beispiel 4 – Mehrere Typ-Parameter

```ts
function pair<K, V>(key: K, value: V): [K, V] {
  return [key, value]
}

const entry = pair("id", 123) // [string, number]
```

---

### Beispiel 5 – Generics in Klassen

```ts
class Box<T> {
  content: T
  constructor(value: T) {
    this.content = value
  }
}

const stringBox = new Box("Text") // T = string
const numBox = new Box(99)        // T = number
```

---

### Beispiel 6 – Generics in React (häufig)

```tsx
import { useState } from "react"

const [count, setCount] = useState<number>(0)
```

👉 `useState<number>` ist ein generischer Hook.

---

### Zusammenfassung

* **Generics** = Typparameter (`<T>`) für wiederverwendbaren, typsicheren Code.
* Vorteile: Flexibilität + Typprüfung gleichzeitig.
* Einsatz: Funktionen, Klassen, Interfaces, React-Hooks.

🔗 Quellen:

* [TypeScript Handbook – Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
* [React TypeScript Cheatsheet – Generics](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/hooks/#generic-hooks)

  **[⬆ Наверх](#top)**

48. ### <a name="48"></a> Wie erstellt man eine generische Funktion?

### Generische Funktion in TypeScript erstellen

**Definition:**
Eine **generische Funktion** nutzt Typparameter (`<T>`), um flexibel mit unterschiedlichen Typen zu arbeiten, ohne die Typ-Sicherheit zu verlieren.

---

### 1. Syntax – einfaches Beispiel

```ts
export function identity<T>(value: T): T {
  return value
}

const num = identity(42)        // T = number
const str = identity("Sergii")  // T = string
```

👉 `T` ist ein Platzhalter, der beim Aufruf ersetzt wird.

---

### 2. Mit Arrays

```ts
export function firstElement<T>(arr: T[]): T {
  return arr[0]
}

const n = firstElement([1, 2, 3])     // number
const s = firstElement(["a", "b", "c"]) // string
```

---

### 3. Mehrere Typparameter

```ts
export function pair<K, V>(key: K, value: V): [K, V] {
  return [key, value]
}

const entry = pair("id", 123) // [string, number]
```

---

### 4. Einschränkungen mit `extends`

```ts
interface HasLength {
  length: number
}

export function logLength<T extends HasLength>(item: T): void {
  console.log(item.length)
}

logLength("Hallo")   // string ✅
logLength([1, 2, 3]) // number[] ✅
```

---

### 5. Default-Typen

```ts
export function toArray<T = string>(value: T): T[] {
  return [value]
}

const a = toArray("hi")   // string[]
const b = toArray(42)     // number[]
const c = toArray()       // string[] (Default)
```

---

### Zusammenfassung

* Generische Funktionen nutzt man mit `<T>` oder mehreren Parametern (`<K, V>`).
* Vorteil: **flexibel + typsicher**.
* Erweiterbar mit `extends` (Constraints) oder Defaults.
* Typische Einsatzgebiete: Utility-Funktionen, Datenstrukturen, React-Hooks.

🔗 Quellen:

* [TypeScript Handbook – Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
* [React TypeScript Cheatsheet – Generics](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/hooks/#generic-hooks)

  **[⬆ Наверх](#top)**

49. ### <a name="49"></a> Was sind Generic Constraints (extends)?

### Generic Constraints (`extends`) in TypeScript

**Definition:**
Mit **Generic Constraints** (`extends`) kann man den **Gültigkeitsbereich** eines Generics einschränken.
👉 Ohne Constraint: `T` kann *alles* sein.
👉 Mit Constraint: `T` muss bestimmte Eigenschaften haben oder von einem Typ erben.

---

### 1. Einfaches Constraint

```ts
function logLength<T extends { length: number }>(item: T): void {
  console.log(item.length)
}

logLength("Hallo")       // string ✅
logLength([1, 2, 3])     // number[] ✅
// logLength(123)        // ❌ Fehler: number hat kein length
```

➡️ `T` muss ein Objekt mit `length: number` sein.

---

### 2. Constraint auf Interface

```ts
interface User {
  id: number
  name: string
}

function getName<T extends User>(obj: T): string {
  return obj.name
}

getName({ id: 1, name: "Sergii" }) // ✅
```

➡️ `T` muss mindestens die Struktur von `User` haben.

---

### 3. Constraint auf Union-Typ

```ts
type Role = "admin" | "user" | "guest"

function setRole<T extends Role>(role: T) {
  console.log(`Neue Rolle: ${role}`)
}

setRole("admin") // ✅
setRole("root")  // ❌ Fehler
```

---

### 4. Mehrere Constraints (`extends` + `extends`)

```ts
function merge<T extends object, U extends object>(a: T, b: U): T & U {
  return { ...a, ...b }
}

const obj = merge({ id: 1 }, { role: "admin" })
// Typ: { id: number } & { role: string }
```

---

### 5. Generics mit `keyof` Constraint

```ts
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key]
}

const user = { id: 1, name: "Sergii" }
getProperty(user, "name") // string
// getProperty(user, "age") ❌ Fehler
```

➡️ `K` darf nur ein Schlüssel von `T` sein.

---

### Zusammenfassung

* **Generic Constraints (`extends`)** = Eingrenzung, welche Typen ein Generic akzeptieren darf.
* Ermöglicht: Zugriff auf Eigenschaften, sichere Schlüsselprüfung, Wiederverwendbarkeit.
* Typische Muster: `extends {}`, `extends Interface`, `extends keyof T`.

🔗 Quellen:

* [TypeScript Handbook – Generic Constraints](https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-constraints)
* [React TypeScript Cheatsheet – Generics](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/hooks/#generic-hooks)

  **[⬆ Наверх](#top)**

50. ### <a name="50"></a> Wie funktioniert T extends keyof U?

### `T extends keyof U` in TypeScript

**Definition:**
`T extends keyof U` bedeutet:
👉 `T` darf nur Werte annehmen, die **ein Schlüssel von `U`** sind.
So lassen sich Generics auf gültige Property-Namen einschränken.

---

### Beispiel 1 – Grundprinzip

```ts
interface User {
  id: number
  name: string
  isAdmin: boolean
}

function getProperty<T extends keyof User>(obj: User, key: T): User[T] {
  return obj[key]
}

const u: User = { id: 1, name: "Sergii", isAdmin: true }

getProperty(u, "name")    // ✅ string
getProperty(u, "isAdmin") // ✅ boolean
// getProperty(u, "age")  // ❌ Fehler: "age" ist kein Schlüssel von User
```

---

### Beispiel 2 – Generische Objektfunktion

```ts
function pluck<T, K extends keyof T>(obj: T, keys: K[]): T[K][] {
  return keys.map(key => obj[key])
}

const user = { id: 1, name: "Sergii", active: true }

const values = pluck(user, ["id", "name"])
// Typ: (string | number)[]
```

---

### Beispiel 3 – Rückgabewerte typisieren

```ts
type Person = { name: string; age: number }

function pickValue<T extends keyof Person>(key: T): Person[T] {
  const dummy: Person = { name: "Anna", age: 25 }
  return dummy[key]
}

const age = pickValue("age")   // number
const name = pickValue("name") // string
```

---

### Beispiel 4 – Kombination mit `Record`

```ts
function mapObject<T, K extends keyof T>(obj: T, keys: K[]): Record<K, T[K]> {
  const result = {} as Record<K, T[K]>
  keys.forEach(k => {
    result[k] = obj[k]
  })
  return result
}

const person = { id: 1, name: "Tom", active: true }
const subset = mapObject(person, ["id", "active"])
// Typ: { id: number; active: boolean }
```

---

### Zusammenfassung

* `keyof U` = Union aller Schlüssel von `U`.
* `T extends keyof U` = `T` darf nur einer dieser Schlüssel sein.
* Einsatz: **Property-Zugriffe, `pluck`/`getProperty`-Utilities, sichere Schlüssel-Prüfungen.**

🔗 Quellen:

* [TypeScript Handbook – keyof and Lookup Types](https://www.typescriptlang.org/docs/handbook/2/keyof-types.html)
* [TypeScript Generics – Constraints](https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-constraints)

  **[⬆ Наверх](#top)**  

51. ### <a name="51"></a> Was sind Utility Types (Partial, Pick, Omit, Record usw.)?

### Utility Types in TypeScript

**Definition:**
Utility Types sind vordefinierte Generics, die bestehende Typen **transformieren oder anpassen**.
Sie sparen Boilerplate und erhöhen die Typ-Sicherheit.

---

## 🔑 Die wichtigsten Utility Types

### 1. **`Partial<T>`**

Macht alle Eigenschaften von `T` optional.

```ts
interface User {
  id: number
  name: string
}

type PartialUser = Partial<User>
// { id?: number; name?: string }
```

---

### 2. **`Required<T>`**

Macht alle Eigenschaften von `T` verpflichtend.

```ts
interface User {
  id?: number
  name?: string
}

type RequiredUser = Required<User>
// { id: number; name: string }
```

---

### 3. **`Readonly<T>`**

Macht alle Eigenschaften von `T` schreibgeschützt.

```ts
interface User {
  id: number
  name: string
}

type ReadonlyUser = Readonly<User>
// { readonly id: number; readonly name: string }
```

---

### 4. **`Pick<T, K>`**

Wählt bestimmte Eigenschaften aus `T`.

```ts
interface User {
  id: number
  name: string
  email: string
}

type UserPreview = Pick<User, "id" | "name">
// { id: number; name: string }
```

---

### 5. **`Omit<T, K>`**

Entfernt bestimmte Eigenschaften aus `T`.

```ts
type UserWithoutEmail = Omit<User, "email">
// { id: number; name: string }
```

---

### 6. **`Record<K, T>`**

Erzeugt ein Objekt mit Schlüsseln vom Typ `K` und Werten vom Typ `T`.

```ts
type Role = "admin" | "user" | "guest"

type RolePermissions = Record<Role, boolean>
// { admin: boolean; user: boolean; guest: boolean }
```

---

### 7. **`Exclude<T, U>`**

Entfernt aus `T` alle Typen, die auch in `U` enthalten sind.

```ts
type Status = "success" | "error" | "loading"
type WithoutLoading = Exclude<Status, "loading">
// "success" | "error"
```

---

### 8. **`Extract<T, U>`**

Beinhaltet nur die Typen, die in beiden enthalten sind.

```ts
type A = "a" | "b" | "c"
type B = "b" | "c" | "d"

type Common = Extract<A, B> // "b" | "c"
```

---

### 9. **`NonNullable<T>`**

Entfernt `null` und `undefined`.

```ts
type Value = string | null | undefined
type SafeValue = NonNullable<Value>
// string
```

---

### 10. **`ReturnType<T>`**

Ermittelt den Rückgabetyp einer Funktion.

```ts
function getUser() {
  return { id: 1, name: "Sergii" }
}

type User = ReturnType<typeof getUser>
// { id: number; name: string }
```

---

### 11. **`Parameters<T>`**

Ermittelt die Parametertypen einer Funktion als Tupel.

```ts
function login(user: string, password: string) {}

type LoginParams = Parameters<typeof login>
// [user: string, password: string]
```

---

### Zusammenfassung

* **Utility Types** = vordefinierte Generics für schnelle Typtransformation.
* Häufige Kandidaten: `Partial`, `Required`, `Readonly`, `Pick`, `Omit`, `Record`.
* Weitere mächtige Tools: `Exclude`, `Extract`, `NonNullable`, `ReturnType`, `Parameters`.
* Typischer Einsatz: **Modelle anpassen, DTOs, React-Props, API-Typisierung.**

🔗 Quellen:

* [TypeScript Handbook – Utility Types](https://www.typescriptlang.org/docs/handbook/utility-types.html)
* [React TS Cheatsheet – Utility Types](https://react-typescript-cheatsheet.netlify.app/docs/advanced/utility_types/)

  **[⬆ Наверх](#top)**

52. ### <a name="52"></a> Was ist der Unterschied zwischen Partial<T> und Required<T>?

### Unterschied zwischen `Partial<T>` und `Required<T>` in TypeScript

---

### **1. `Partial<T>`**

* Macht **alle Properties** eines Typs **optional** (`?`).
* Typische Nutzung: bei **Update-Objekten** (z. B. nur einige Felder eines Users ändern).

```ts
interface User {
  id: number
  name: string
  email: string
}

type PartialUser = Partial<User>
// { id?: number; name?: string; email?: string }

const updateUser: PartialUser = { name: "Sergii" } // ✅ nur name
```

---

### **2. `Required<T>`**

* Macht **alle Properties** eines Typs **pflichtig** (auch solche, die ursprünglich optional waren).
* Typische Nutzung: wenn du sicherstellen willst, dass **komplette Daten** übergeben werden.

```ts
interface User {
  id?: number
  name?: string
  email?: string
}

type RequiredUser = Required<User>
// { id: number; name: string; email: string }

const fullUser: RequiredUser = {
  id: 1,
  name: "Sergii",
  email: "sergii@mail.com"
} // ✅ alles Pflicht
```

---

### **Vergleichstabelle**

| Utility Type  | Wirkung                              | Beispiel                         |
| ------------- | ------------------------------------ | -------------------------------- |
| `Partial<T>`  | Alle Properties werden **optional**  | `{ id?: number; name?: string }` |
| `Required<T>` | Alle Properties werden **pflichtig** | `{ id: number; name: string }`   |

---

### Zusammenfassung

* **`Partial<T>`** = macht alle Felder **optional** → nützlich für Updates oder Teilobjekte.
* **`Required<T>`** = macht alle Felder **zwingend** → nützlich für Validierung oder vollständige Daten.

🔗 Quellen:

* [TypeScript Handbook – Utility Types](https://www.typescriptlang.org/docs/handbook/utility-types.html)

  **[⬆ Наверх](#top)**

53. ### <a name="53"></a> Wie funktioniert Readonly<T>?

### `Readonly<T>` in TypeScript

**Definition:**
Der Utility Type **`Readonly<T>`** macht **alle Eigenschaften** eines Typs **schreibgeschützt** (`readonly`).
Das bedeutet: einmal gesetzte Werte können nicht mehr verändert werden.

---

### Beispiel 1 – Einfaches Interface

```ts
interface User {
  id: number
  name: string
}

type ReadonlyUser = Readonly<User>
// { readonly id: number; readonly name: string }

const u: ReadonlyUser = { id: 1, name: "Sergii" }

u.name = "Anna" // ❌ Fehler: name ist readonly
```

---

### Beispiel 2 – Readonly Arrays

```ts
const numbers: Readonly<number[]> = [1, 2, 3]

numbers.push(4)   // ❌ Fehler: push existiert nicht
numbers[0] = 99   // ❌ Fehler
```

Alternative:

```ts
const tuple: Readonly<[number, number]> = [10, 20]
```

---

### Beispiel 3 – In Kombination mit `Partial`

```ts
interface Config {
  host: string
  port: number
}

type ImmutableConfig = Readonly<Partial<Config>>
// { readonly host?: string; readonly port?: number }
```

---

### Beispiel 4 – Praktisch in React (Props)

```tsx
type ButtonProps = Readonly<{
  label: string
  onClick: () => void
}>

// Props sind automatisch readonly → Schutz vor Änderungen
const Button = (props: ButtonProps) => {
  // props.label = "Neu" ❌ nicht erlaubt
  return <button onClick={props.onClick}>{props.label}</button>
}
```

---

### Zusammenfassung

* **`Readonly<T>`** → macht alle Felder **immutable** (nur lesbar).
* Nützlich für: **Props in React**, Konfigurationen, sichere Datenmodelle.
* Kombination mit anderen Utility Types (`Partial`, `Pick`, etc.) sehr mächtig.

🔗 Quellen:

* [TypeScript Handbook – Readonly](https://www.typescriptlang.org/docs/handbook/utility-types.html#readonlytype)
* [React TS Cheatsheet – Props Readonly](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example/#readonly-and-const)

  **[⬆ Наверх](#top)**

54. ### <a name="54"></a> Wie funktionieren Pick<T, K> und Omit<T, K>?

### `Pick<T, K>` und `Omit<T, K>` in TypeScript

Beide sind **Utility Types**, die auf bestehenden Typen basieren.
👉 `Pick` = bestimmte Properties auswählen
👉 `Omit` = bestimmte Properties ausschließen

---

### **1. Pick<T, K>**

* Baut aus Typ `T` einen neuen Typ mit **nur den ausgewählten Keys `K`**.

```ts
interface User {
  id: number
  name: string
  email: string
  isAdmin: boolean
}

type UserPreview = Pick<User, "id" | "name">
// { id: number; name: string }

const preview: UserPreview = { id: 1, name: "Sergii" }
```

---

### **2. Omit<T, K>**

* Baut aus Typ `T` einen neuen Typ mit **allen Properties außer `K`**.

```ts
type UserWithoutEmail = Omit<User, "email" | "isAdmin">
// { id: number; name: string }

const simpleUser: UserWithoutEmail = { id: 2, name: "Anna" }
```

---

### **3. Vergleich**

```ts
// Pick -> nur bestimmte Eigenschaften
type OnlyName = Pick<User, "name">
// { name: string }

// Omit -> bestimmte Eigenschaften entfernen
type WithoutName = Omit<User, "name">
// { id: number; email: string; isAdmin: boolean }
```

---

### **4. Typische Einsatzgebiete**

* **Pick**: DTOs, kurze Vorschau-Typen (z. B. für UI).
* **Omit**: Typen für "Create" oder "Update", wenn bestimmte Felder nicht erlaubt sind.

```ts
// Beispiel: API CreateUser ohne id und isAdmin
type CreateUserDto = Omit<User, "id" | "isAdmin">
```

---

### Zusammenfassung

* **`Pick<T, K>`** → erstellt neuen Typ mit **nur K** aus T.
* **`Omit<T, K>`** → erstellt neuen Typ mit **allen außer K**.
* Sehr nützlich für **DTOs, API-Modelle, React-Props**.

🔗 Quellen:

* [TypeScript Handbook – Utility Types](https://www.typescriptlang.org/docs/handbook/utility-types.html)
* [React TS Cheatsheet – Utility Types](https://react-typescript-cheatsheet.netlify.app/docs/advanced/utility_types/)

  **[⬆ Наверх](#top)**

55. ### <a name="55"></a> Was macht Record<K, T>?

### `Record<K, T>` in TypeScript

**Definition:**
`Record<K, T>` erstellt einen **Objekttyp**, bei dem:

* alle Schlüssel (`K`) denselben Typ haben,
* und die Werte vom Typ `T` sind.

Es ist eine **kurze Schreibweise** für Objekte mit einheitlichen Keys/Werten.

---

### Beispiel 1 – Einfache Verwendung

```ts
type Role = "admin" | "user" | "guest"

type RolePermissions = Record<Role, boolean>
// { admin: boolean; user: boolean; guest: boolean }

const permissions: RolePermissions = {
  admin: true,
  user: false,
  guest: false
}
```

---

### Beispiel 2 – Index als Zahl

```ts
type ScoreBoard = Record<number, string>

const scores: ScoreBoard = {
  1: "Anna",
  2: "Sergii"
}
```

---

### Beispiel 3 – Mit komplexen Werten

```ts
interface User {
  id: number
  name: string
}

type UserDictionary = Record<string, User>

const users: UserDictionary = {
  a1: { id: 1, name: "Anna" },
  b2: { id: 2, name: "Sergii" }
}
```

---

### Beispiel 4 – Kombination mit `keyof`

```ts
interface Config {
  host: string
  port: number
}

type ConfigMap = Record<keyof Config, string>
// { host: string; port: string }
```

---

### Vergleich zu **Index Signatures**

```ts
// Mit Index Signature
type Dict = { [key: string]: number }

// Mit Record
type Dict2 = Record<string, number>
```

👉 Beide ähnlich – aber `Record` ist **kürzer** und wird oft bevorzugt.

---

### Zusammenfassung

* **`Record<K, T>`** = Objekt mit Schlüsseln aus `K` und Werten vom Typ `T`.
* Kurzform für Dictionaries und Maps.
* Praktisch für **Mappings, Lookups, Konfigurationen**.

🔗 Quellen:

* [TypeScript Handbook – Record](https://www.typescriptlang.org/docs/handbook/utility-types.html#recordkeys-type)
* [React TS Cheatsheet – Record](https://react-typescript-cheatsheet.netlify.app/docs/advanced/utility_types/)

  **[⬆ Наверх](#top)**

56. ### <a name="56"></a> Was macht ReturnType<T>?

### `ReturnType<T>` in TypeScript

**Definition:**
Der Utility Type **`ReturnType<T>`** extrahiert den **Rückgabewert-Typ** einer Funktion.
👉 `T` muss dabei eine **Funktionssignatur** oder der Typ einer Funktion sein.

---

### Beispiel 1 – Einfache Funktion

```ts
function getUser() {
  return { id: 1, name: "Sergii" }
}

type User = ReturnType<typeof getUser>
// { id: number; name: string }

const u: User = { id: 2, name: "Anna" }
```

---

### Beispiel 2 – Mit Arrow Function

```ts
const add = (a: number, b: number) => a + b

type SumReturn = ReturnType<typeof add>
// number
```

---

### Beispiel 3 – Async Funktionen

```ts
async function fetchData() {
  return { ok: true, data: [1, 2, 3] }
}

type FetchResult = ReturnType<typeof fetchData>
// Promise<{ ok: boolean; data: number[] }>
```

---

### Beispiel 4 – In Kombination mit `InstanceType`

```ts
class Person {
  constructor(public name: string) {}
}

function createPerson() {
  return new Person("Sergii")
}

type PersonReturn = ReturnType<typeof createPerson>
// Person
```

---

### Typischer Nutzen

* Vermeidung von **doppelter Typdefinition**.
* Rückgabewerte **automatisch ableiten**.
* Besonders nützlich bei **Utility-Funktionen**, **Hooks** in React oder **Factory Functions**.

---

### Zusammenfassung

* **`ReturnType<T>`** = extrahiert den Rückgabewert einer Funktion.
* Spart Boilerplate und verhindert Inkonsistenzen.
* Funktioniert mit normalen, Arrow- und async-Funktionen.

🔗 Quellen:

* [TypeScript Handbook – ReturnType](https://www.typescriptlang.org/docs/handbook/utility-types.html#returntypetype)
* [React TS Cheatsheet – Utility Types](https://react-typescript-cheatsheet.netlify.app/docs/advanced/utility_types/)

  **[⬆ Наверх](#top)**

57. ### <a name="57"></a> Was macht Parameters<T>?

### `Parameters<T>` in TypeScript

**Definition:**
Der Utility Type **`Parameters<T>`** extrahiert die **Parametertypen** einer Funktion als **Tupel**.
👉 `T` muss eine Funktion oder Funktionssignatur sein.

---

### Beispiel 1 – Normale Funktion

```ts
function login(user: string, password: string) {}

type LoginParams = Parameters<typeof login>
// [user: string, password: string]

const args: LoginParams = ["Sergii", "1234"]
login(...args) // ✅ korrekt
```

---

### Beispiel 2 – Arrow Function

```ts
const add = (a: number, b: number) => a + b

type AddParams = Parameters<typeof add>
// [a: number, b: number]
```

---

### Beispiel 3 – Optional & Default Parameter

```ts
function greet(name: string, title?: string) {}

type GreetParams = Parameters<typeof greet>
// [name: string, title?: string | undefined]
```

---

### Beispiel 4 – Async Funktion

```ts
async function fetchData(url: string, retries: number) {
  return `Fetch: ${url} (${retries})`
}

type FetchParams = Parameters<typeof fetchData>
// [url: string, retries: number]
```

---

### Beispiel 5 – Generisch kombinieren

```ts
function callFn<T extends (...args: any[]) => any>(fn: T, ...args: Parameters<T>): ReturnType<T> {
  return fn(...args)
}

function multiply(x: number, y: number) {
  return x * y
}

const result = callFn(multiply, 3, 4) // number
```

---

### Zusammenfassung

* **`Parameters<T>`** = extrahiert Parametertypen als **Tupel**.
* Nützlich für **Wrapper-Funktionen**, **Middleware**, **Decorator-Pattern**.
* Oft in Kombination mit **`ReturnType<T>`**.

🔗 Quellen:

* [TypeScript Handbook – Parameters](https://www.typescriptlang.org/docs/handbook/utility-types.html#parameterstype)
* [React TS Cheatsheet – Utility Types](https://react-typescript-cheatsheet.netlify.app/docs/advanced/utility_types/)

  **[⬆ Наверх](#top)**

58. ### <a name="58"></a> Was macht ConstructorParameters<T>?

### `ConstructorParameters<T>` in TypeScript

**Definition:**
Der Utility Type **`ConstructorParameters<T>`** extrahiert die **Parameter-Typen eines Konstruktors** als **Tupel**.
👉 `T` muss ein Konstruktor-Typ (z. B. eine Klasse oder `new (...args) => any`) sein.

---

### Beispiel 1 – Einfache Klasse

```ts
class User {
  constructor(public id: number, public name: string) {}
}

type UserArgs = ConstructorParameters<typeof User>
// [id: number, name: string]

const args: UserArgs = [1, "Sergii"]
const u = new User(...args) // ✅
```

---

### Beispiel 2 – Mit optionalen Parametern

```ts
class Book {
  constructor(public title: string, public pages?: number) {}
}

type BookArgs = ConstructorParameters<typeof Book>
// [title: string, pages?: number | undefined]

const args: BookArgs = ["TS Handbook"]
const b = new Book(...args)
```

---

### Beispiel 3 – Factory Function mit ConstructorParameters

```ts
function createInstance<T extends new (...args: any) => any>(
  Ctor: T,
  ...args: ConstructorParameters<T>
): InstanceType<T> {
  return new Ctor(...args)
}

class Car {
  constructor(public brand: string, public year: number) {}
}

const myCar = createInstance(Car, "BMW", 2025) // Car
```

---

### Beispiel 4 – Mit eingebauten Klassen

```ts
type DateArgs = ConstructorParameters<typeof Date>
// [value?: string | number | Date]

const d = new Date(...(["2025-01-01"] as DateArgs))
```

---

### Zusammenfassung

* **`ConstructorParameters<T>`** = extrahiert **Konstruktor-Argumente** als Tupel.
* Einsatz: Factories, Wrapper, Dependency Injection.
* Nützlich in Kombination mit **`InstanceType<T>`**.

🔗 Quellen:

* [TypeScript Handbook – ConstructorParameters](https://www.typescriptlang.org/docs/handbook/utility-types.html#constructorparameterstype)
* [TypeScript Handbook – InstanceType](https://www.typescriptlang.org/docs/handbook/utility-types.html#instancetypetype)

  **[⬆ Наверх](#top)**

59. ### <a name="59"></a> Wie funktionieren Extract und Exclude?

### `Extract<T, U>` und `Exclude<T, U>` in TypeScript

Beide Utility Types arbeiten mit **Union Types** und helfen, Typen zu filtern.

---

## **1. `Exclude<T, U>`**

Entfernt aus `T` alle Typen, die auch in `U` enthalten sind.
👉 „Alles außer“

```ts
type Status = "success" | "error" | "loading"

type WithoutLoading = Exclude<Status, "loading">
// "success" | "error"
```

**Beispiel mit mehreren:**

```ts
type Letters = "a" | "b" | "c" | "d"

type WithoutBC = Exclude<Letters, "b" | "c">
// "a" | "d"
```

---

## **2. `Extract<T, U>`**

Behält nur die Typen aus `T`, die auch in `U` vorkommen.
👉 „Schnittmenge“

```ts
type Status = "success" | "error" | "loading"

type OnlyError = Extract<Status, "error" | "fatal">
// "error"
```

**Beispiel mit mehreren:**

```ts
type Letters = "a" | "b" | "c" | "d"

type OnlyBC = Extract<Letters, "b" | "c" | "z">
// "b" | "c"
```

---

## **Vergleichsübersicht**

| Utility Type    | Bedeutung                            | Beispiel     |                  |             |
| --------------- | ------------------------------------ | ------------ | ---------------- | ----------- |
| `Exclude<T, U>` | Entfernt Typen von `U` aus `T`       | `Exclude<"a" | "b", "b">`→`"a"` |             |
| `Extract<T, U>` | Behalte nur gemeinsame Typen mit `U` | `Extract<"a" | "b", "b"         | "c">`→`"b"` |

---

## **Praktische Anwendung**

* **`Exclude`**: Bestimmte Werte/Typszenarien ausschließen.

  ```ts
  type EventType = "click" | "change" | "hover"
  type NonInteractive = Exclude<EventType, "click">
  // "change" | "hover"
  ```
* **`Extract`**: Nur erlaubte Schnittmenge behalten.

  ```ts
  type AllEvents = "click" | "change" | "hover"
  type UiEvents = "click" | "hover"

  type Allowed = Extract<AllEvents, UiEvents>
  // "click" | "hover"
  ```

---

### Zusammenfassung

* **`Exclude<T, U>`** = entfernt Typen von `U` aus `T`.
* **`Extract<T, U>`** = behält nur gemeinsame Typen zwischen `T` und `U`.
* Einsatz: Union-Typen filtern, APIs einschränken, erlaubte/unerlaubte Werte modellieren.

🔗 Quellen:

* [TypeScript Handbook – Utility Types](https://www.typescriptlang.org/docs/handbook/utility-types.html)

  **[⬆ Наверх](#top)**

60. ### <a name="60"></a> Was macht NonNullable<T>?

### `NonNullable<T>` in TypeScript

**Definition:**
Der Utility Type **`NonNullable<T>`** entfernt **`null`** und **`undefined`** aus einem Typ.
👉 Praktisch, wenn man einen Typ sicher ohne diese beiden Werte verwenden möchte.

---

### Beispiel 1 – Einfacher Typ

```ts
type Value = string | null | undefined

type SafeValue = NonNullable<Value>
// string
```

---

### Beispiel 2 – Mit Union Types

```ts
type Status = "success" | "error" | null | undefined

type CleanStatus = NonNullable<Status>
// "success" | "error"
```

---

### Beispiel 3 – In Funktionen

```ts
function printName(name: NonNullable<string | null | undefined>) {
  console.log(name.toUpperCase())
}

printName("Sergii")   // ✅
printName(null)       // ❌ Fehler
```

---

### Beispiel 4 – In Kombination mit `strictNullChecks`

```ts
interface User {
  id: number
  email?: string | null
}

type SafeEmail = NonNullable<User["email"]>
// string
```

---

### Zusammenfassung

* **`NonNullable<T>`** = entfernt `null` und `undefined` aus Typ `T`.
* Typische Nutzung: Eingaben absichern, optionale Properties bereinigen, Union Types aufräumen.
* Besonders nützlich in Projekten mit **`strictNullChecks`**.

🔗 Quellen:

* [TypeScript Handbook – NonNullable](https://www.typescriptlang.org/docs/handbook/utility-types.html#nonnullabletype)

  **[⬆ Наверх](#top)**

61. ### <a name="61"></a> Wie deklariert man eine Klasse in TypeScript?

### Klassen in TypeScript deklarieren

In TypeScript funktionieren Klassen wie in JavaScript, können aber zusätzlich **Typen, Sichtbarkeiten und Interfaces** nutzen.

---

### 1. Basis-Syntax

```ts
export class Person {
  name: string
  age: number

  constructor(name: string, age: number) {
    this.name = name
    this.age = age
  }

  greet(): void {
    console.log(`Hallo, ich heiße ${this.name}`)
  }
}

const p = new Person("Sergii", 34)
p.greet() // Hallo, ich heiße Sergii
```

---

### 2. Sichtbarkeitsmodifikatoren

* **`public`** (Standard) → überall sichtbar
* **`private`** → nur in der Klasse sichtbar
* **`protected`** → in der Klasse und Subklassen sichtbar
* **`readonly`** → Wert nur im Konstruktor setzbar

```ts
class User {
  readonly id: number
  private password: string
  protected role: string
  public name: string

  constructor(id: number, name: string, password: string, role: string) {
    this.id = id
    this.name = name
    this.password = password
    this.role = role
  }
}
```

---

### 3. Verkürzte Schreibweise im Konstruktor

```ts
class Car {
  constructor(public brand: string, private year: number) {}
}

const c = new Car("BMW", 2025)
console.log(c.brand) // BMW
// console.log(c.year) ❌ Fehler: private
```

---

### 4. Vererbung (`extends`)

```ts
class Animal {
  move() {
    console.log("Bewegt sich")
  }
}

class Dog extends Animal {
  bark() {
    console.log("Wuff!")
  }
}

const d = new Dog()
d.move() // von Animal
d.bark() // von Dog
```

---

### 5. Abstrakte Klassen

```ts
abstract class Shape {
  abstract area(): number
}

class Square extends Shape {
  constructor(public side: number) {
    super()
  }

  area(): number {
    return this.side * this.side
  }
}
```

---

### 6. Klassen + Interfaces

```ts
interface Flyable {
  fly(): void
}

class Bird implements Flyable {
  fly() {
    console.log("Der Vogel fliegt")
  }
}
```

---

### Zusammenfassung

* Klassen werden mit `class` deklariert.
* **Features in TS:** Typisierung, Sichtbarkeitsmodifikatoren, `readonly`.
* Unterstützt: **Vererbung**, **abstrakte Klassen**, **Interfaces**.
* Vorteile: bessere Struktur und Typsicherheit gegenüber reinem JS.

🔗 Quellen:

* [TypeScript Handbook – Classes](https://www.typescriptlang.org/docs/handbook/2/classes.html)
* [MDN – Classes in JS](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes)

  **[⬆ Наверх](#top)**

62. ### <a name="62"></a> Was sind Zugriffsmodifikatoren (public, private, protected)?

### Zugriffsmodifikatoren in TypeScript (`public`, `private`, `protected`)

TypeScript erweitert JavaScript-Klassen um **Zugriffsmodifikatoren**, die steuern, **wo Eigenschaften und Methoden sichtbar sind**.

---

### 1. **public** (Standard)

* Zugriff von überall: innerhalb der Klasse, in Subklassen, von außen.
* Ist der **Default**, auch wenn man nichts angibt.

```ts
class User {
  public name: string
  constructor(name: string) {
    this.name = name
  }
}

const u = new User("Sergii")
console.log(u.name) // ✅ erlaubt
```

---

### 2. **private**

* Zugriff nur innerhalb der **gleichen Klasse**.
* Nicht von Subklassen oder von außen sichtbar.

```ts
class Account {
  private balance: number
  constructor(balance: number) {
    this.balance = balance
  }

  deposit(amount: number) {
    this.balance += amount
  }
}

const acc = new Account(100)
// acc.balance // ❌ Fehler: private
acc.deposit(50) // ✅ erlaubt
```

---

### 3. **protected**

* Zugriff in der Klasse **und in Subklassen**.
* Nicht von außen sichtbar.

```ts
class Animal {
  protected move() {
    console.log("Bewegt sich")
  }
}

class Dog extends Animal {
  bark() {
    this.move() // ✅ erlaubt, da protected
    console.log("Wuff!")
  }
}

const d = new Dog()
// d.move() ❌ Fehler
d.bark() // ✅ erlaubt
```

---

### 4. **readonly** (Sonderfall)

* Kein Zugriffsmodifikator, aber oft in Kombination genutzt.
* Wert darf **nur im Konstruktor oder bei Deklaration gesetzt** werden.

```ts
class Config {
  readonly version: string = "1.0"
}

const c = new Config()
// c.version = "2.0" ❌ Fehler
```

---

### Vergleichstabelle

| Modifikator | Zugriff in Klasse | Zugriff in Subklasse | Zugriff von außen |
| ----------- | ----------------- | -------------------- | ----------------- |
| `public`    | ✅                 | ✅                    | ✅                 |
| `protected` | ✅                 | ✅                    | ❌                 |
| `private`   | ✅                 | ❌                    | ❌                 |

---

### Zusammenfassung

* **public** = überall sichtbar (Default).
* **private** = nur in der Klasse.
* **protected** = in Klasse + Subklassen.
* **readonly** = Wert nicht änderbar (Ergänzung).

🔗 Quellen:

* [TypeScript Handbook – Classes](https://www.typescriptlang.org/docs/handbook/2/classes.html#public-private-and-protected-modifiers)

  **[⬆ Наверх](#top)**

63. ### <a name="63"></a> Was sind readonly-Eigenschaften in Klassen?

### `readonly` Eigenschaften in TypeScript-Klassen

**Definition:**
Eine **`readonly`-Eigenschaft** in einer Klasse kann **nur einmal** gesetzt werden:

* bei der **Deklaration**, oder
* im **Konstruktor**.

Danach ist sie **unveränderlich** (immutable).

---

### Beispiel 1 – `readonly` bei Deklaration

```ts
class Config {
  readonly version: string = "1.0"
}

const c = new Config()
// c.version = "2.0" ❌ Fehler: version ist readonly
```

---

### Beispiel 2 – `readonly` im Konstruktor

```ts
class User {
  readonly id: number
  name: string

  constructor(id: number, name: string) {
    this.id = id   // ✅ erlaubt
    this.name = name
  }
}

const u = new User(1, "Sergii")
u.name = "Anna"   // ✅ veränderbar
// u.id = 2       // ❌ Fehler: readonly
```

---

### Beispiel 3 – Kombination mit Modifikatoren

```ts
class Token {
  private readonly secret: string

  constructor(secret: string) {
    this.secret = secret
  }

  getSecret(): string {
    return this.secret // ✅ nur lesbar
  }
}
```

---

### Beispiel 4 – `readonly` Arrays (nicht tief eingefroren!)

```ts
class Data {
  readonly items: string[] = ["a", "b"]
}

const d = new Data()
d.items.push("c")    // ✅ erlaubt, weil Array selbst mutable
// d.items = []       // ❌ Fehler: Referenz ist readonly
```

👉 Für wirklich **immutable Arrays** → `ReadonlyArray<T>`.

---

### Zusammenfassung

* **`readonly`** = Eigenschaft ist nach Zuweisung nicht mehr überschreibbar.
* Initialisierung: in **Deklaration** oder im **Konstruktor**.
* Kombinierbar mit `public`, `private`, `protected`.
* Wichtig: bei Arrays/Objekten schützt es nur die **Referenz**, nicht den Inhalt.

🔗 Quellen:

* [TypeScript Handbook – Classes: readonly](https://www.typescriptlang.org/docs/handbook/2/classes.html#readonly)
* [MDN – const vs. readonly (Unterschied)](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#readonly-properties)

  **[⬆ Наверх](#top)**

64. ### <a name="64"></a> Wie deklariert man statische Eigenschaften und Methoden?

### Statische Eigenschaften und Methoden in TypeScript

**Definition:**
Mit dem Schlüsselwort **`static`** deklariert man **Eigenschaften oder Methoden**, die **zur Klasse selbst gehören**, nicht zu deren Instanzen.
👉 Zugriff erfolgt über den **Klassennamen**, nicht über `this`.

---

### 1. Statische Eigenschaft

```ts
class Config {
  static readonly version: string = "1.0"
}

console.log(Config.version) // ✅ Zugriff über Klasse
// new Config().version ❌ Fehler
```

---

### 2. Statische Methode

```ts
class MathUtils {
  static add(a: number, b: number): number {
    return a + b
  }
}

console.log(MathUtils.add(2, 3)) // 5
```

---

### 3. Kombination von static + private

```ts
class Counter {
  private static count = 0

  static increment(): number {
    return ++this.count
  }
}

console.log(Counter.increment()) // 1
console.log(Counter.increment()) // 2
```

---

### 4. Zugriff aus Instanzmethoden (z. B. Singleton-Pattern)

```ts
class Database {
  private static instance: Database

  private constructor() {}

  static getInstance(): Database {
    if (!Database.instance) {
      Database.instance = new Database()
    }
    return Database.instance
  }
}

const db1 = Database.getInstance()
const db2 = Database.getInstance()

console.log(db1 === db2) // true
```

---

### 5. Einschränkung: kein Zugriff über `this` in Instanzmethoden

```ts
class Example {
  static x = 10

  logX() {
    // console.log(this.x) ❌ Fehler
    console.log(Example.x) // ✅
  }
}
```

---

### Zusammenfassung

* **`static`** → gehört zur Klasse, nicht zur Instanz.
* Zugriff: **`Klassenname.member`**.
* Typische Nutzung: **Hilfsfunktionen, Konstanten, Singleton-Pattern, Counter, Factories**.

🔗 Quellen:

* [TypeScript Handbook – Classes: static](https://www.typescriptlang.org/docs/handbook/2/classes.html#static-members)
* [MDN – static keyword (JS)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes/static)

  **[⬆ Наверх](#top)**

65. ### <a name="65"></a> Was ist der Unterschied zwischen einer abstrakten und einer normalen Klasse?

### Unterschied: Abstrakte Klasse vs. Normale Klasse in TypeScript

---

### **1. Normale Klasse**

* Kann **direkt instanziiert** werden (`new`).
* Enthält **komplette Implementierungen** von Eigenschaften und Methoden.

```ts
class Person {
  constructor(public name: string) {}

  greet(): void {
    console.log(`Hallo, ich heiße ${this.name}`)
  }
}

const p = new Person("Sergii") // ✅ erlaubt
p.greet() // Hallo, ich heiße Sergii
```

---

### **2. Abstrakte Klasse**

* Kann **nicht direkt instanziiert** werden (`new` ist verboten).
* Kann **abstrakte Methoden** enthalten → nur **Signatur**, keine Implementierung.
* Dient als **Basisklasse** für Spezialisierungen.

```ts
abstract class Animal {
  constructor(public name: string) {}

  abstract makeSound(): void // nur Signatur

  move(): void {
    console.log(`${this.name} bewegt sich`)
  }
}

class Dog extends Animal {
  makeSound(): void {
    console.log("Wuff!")
  }
}

const d = new Dog("Bello") // ✅ erlaubt
d.makeSound() // Wuff!

// const a = new Animal("X") ❌ Fehler: abstrakte Klasse
```

---

### **3. Typische Nutzung von abstrakten Klassen**

* Gemeinsame **Grundlogik** in der Basisklasse.
* Unterschiedliche Subklassen müssen **abstrakte Methoden implementieren**.
* Beispiel: **Template Method Pattern**, **Basis-Modelle** in OOP.

---

### **Vergleichstabelle**

| Merkmal            | Normale Klasse    | Abstrakte Klasse                          |
| ------------------ | ----------------- | ----------------------------------------- |
| Instanziierung     | ✅ möglich (`new`) | ❌ nicht möglich                           |
| Abstrakte Methoden | ❌ nicht erlaubt   | ✅ erlaubt (Signatur ohne Body)            |
| Implementierung    | ✅ vollständig     | ✅ teilweise + abstrakte Methoden          |
| Einsatz            | konkrete Objekte  | Basis für Spezialisierungen (Polymorphie) |

---

### Zusammenfassung

* **Normale Klasse** = vollständige Implementierung, direkt instanziierbar.
* **Abstrakte Klasse** = kann nicht instanziiert werden, enthält evtl. abstrakte Methoden, zwingt Subklassen zur Implementierung.
* Einsatz: **OOP-Design, Polymorphismus, Code-Wiederverwendung**.

🔗 Quellen:

* [TypeScript Handbook – Classes: abstract](https://www.typescriptlang.org/docs/handbook/2/classes.html#abstract-classes)
* [MDN – Classes](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes)

  **[⬆ Наверх](#top)**

66. ### <a name="66"></a> Kann man Interfaces mit Klassen implementieren?

### Interfaces mit Klassen implementieren

**Antwort:**
Ja ✅ — eine Klasse kann ein oder mehrere **Interfaces implementieren**, indem sie deren Struktur erfüllt.
👉 Interfaces definieren nur die **Form** (keine Implementierung).
👉 Klassen müssen dann **alle Eigenschaften und Methoden** implementieren.

---

### Beispiel 1 – Einfaches Interface

```ts
interface Greetable {
  name: string
  greet(): void
}

class Person implements Greetable {
  constructor(public name: string) {}

  greet(): void {
    console.log(`Hallo, ich heiße ${this.name}`)
  }
}

const p = new Person("Sergii")
p.greet() // Hallo, ich heiße Sergii
```

---

### Beispiel 2 – Mehrere Interfaces

```ts
interface CanRun {
  run(): void
}

interface CanJump {
  jump(): void
}

class Athlete implements CanRun, CanJump {
  run(): void {
    console.log("Ich laufe")
  }
  jump(): void {
    console.log("Ich springe")
  }
}
```

---

### Beispiel 3 – Interface als Vertrag für Klassen

```ts
interface Repository<T> {
  getAll(): T[]
  add(item: T): void
}

class UserRepository implements Repository<string> {
  private users: string[] = []

  getAll(): string[] {
    return this.users
  }

  add(user: string): void {
    this.users.push(user)
  }
}
```

---

### Regeln

* `implements` = **Interface einhalten**.
* Anders als `extends` → keine Vererbung von Implementierung, nur von **Struktur**.
* Klassen können **mehrere Interfaces** implementieren, aber nur **eine Klasse** erweitern.

---

### Zusammenfassung

* **Interfaces + Klassen** = Vertrag + konkrete Umsetzung.
* Syntax: `class X implements InterfaceA, InterfaceB`.
* Typisch für: Architektur, Code-Wiederverwendung, Polymorphismus.

🔗 Quellen:

* [TypeScript Handbook – Classes: implements](https://www.typescriptlang.org/docs/handbook/2/classes.html#implements-clauses)

  **[⬆ Наверх](#top)**

67. ### <a name="67"></a> Was ist der Unterschied zwischen implements und extends?

### Unterschied: `implements` vs. `extends` in TypeScript

---

### **1. `extends`**

* Wird für **Vererbung** genutzt.
* Eine Klasse kann **nur eine andere Klasse** erweitern.
* Subklasse erbt **Eigenschaften + Methoden** der Superklasse.

```ts
class Animal {
  move() {
    console.log("Bewegt sich")
  }
}

class Dog extends Animal {
  bark() {
    console.log("Wuff!")
  }
}

const d = new Dog()
d.move() // von Animal
d.bark() // von Dog
```

---

### **2. `implements`**

* Wird genutzt, um eine Klasse an ein **Interface** (oder mehrere) zu binden.
* Klasse muss alle **Properties und Methoden-Signaturen** des Interfaces implementieren.
* Interfaces geben nur die **Struktur** vor, keine Logik.

```ts
interface Flyable {
  fly(): void
}

class Bird implements Flyable {
  fly() {
    console.log("Der Vogel fliegt")
  }
}
```

---

### **3. Kombination**

Eine Klasse kann **gleichzeitig** eine Klasse erweitern und Interfaces implementieren.

```ts
interface Swimmable {
  swim(): void
}

class Animal {
  eat() {
    console.log("Frisst")
  }
}

class Fish extends Animal implements Swimmable {
  swim() {
    console.log("Schwimmt")
  }
}
```

---

### **Vergleichstabelle**

| Merkmal         | `extends`                        | `implements`                            |
| --------------- | -------------------------------- | --------------------------------------- |
| Zweck           | Vererbung (Code wiederverwenden) | Vertrag erfüllen (Struktur einhalten)   |
| Quelle          | Klasse oder abstrakte Klasse     | Interface(s)                            |
| Mehrfachnutzung | Nur **eine** Superklasse möglich | Mehrere Interfaces gleichzeitig möglich |
| Enthält Logik   | ✅ Ja                             | ❌ Nur Signaturen                        |

---

### Zusammenfassung

* **`extends`** = Vererbung: Klasse erbt Implementierungen.
* **`implements`** = Vertrag: Klasse muss Interface erfüllen.
* Kombination möglich: `class X extends Y implements Z`.

🔗 Quellen:

* [TypeScript Handbook – Classes](https://www.typescriptlang.org/docs/handbook/2/classes.html)
* [TypeScript Handbook – Interfaces](https://www.typescriptlang.org/docs/handbook/2/objects.html)

  **[⬆ Наверх](#top)**

68. ### <a name="68"></a> Was ist this und wie typisiert man es?

### `this` in TypeScript

**Definition:**
`this` verweist im Kontext einer Funktion oder Methode auf das **aktuelle Objekt**, in dem die Funktion ausgeführt wird.
In TypeScript kann man `this` **explizit typisieren**, um Typ-Sicherheit zu gewährleisten.

---

## 1. `this` in Klassen

Automatisch auf die **Instanz** der Klasse gebunden.

```ts
class User {
  name: string
  constructor(name: string) {
    this.name = name
  }

  greet(): void {
    console.log(`Hallo, ich bin ${this.name}`)
  }
}

const u = new User("Sergii")
u.greet() // Hallo, ich bin Sergii
```

👉 Hier ist `this: User`.

---

## 2. `this` als expliziter Typ in Funktionen

Man kann `this` als **ersten Pseudoparameter** typisieren.

> Wichtig: Dieser Parameter existiert nur für die Typprüfung, nicht im Runtime-Code!

```ts
interface User {
  name: string
}

function greet(this: User, greeting: string) {
  console.log(`${greeting}, ich bin ${this.name}`)
}

const u: User = { name: "Anna" }
greet.call(u, "Hallo") // Hallo, ich bin Anna
```

👉 Ohne `this: User` würde `this.name` einen Fehler auslösen.

---

## 3. Arrow Functions und `this`

Arrow Functions **binden kein eigenes `this`**, sondern übernehmen es aus dem umgebenden Kontext.

```ts
class Counter {
  count = 0

  // normales this -> muss gebunden werden
  incNormal() {
    setTimeout(function () {
      // console.log(this.count) ❌ Fehler
    }, 1000)
  }

  // Arrow Function -> this bleibt auf Instanz gebunden
  incArrow() {
    setTimeout(() => {
      this.count++  // ✅ korrekt
      console.log(this.count)
    }, 1000)
  }
}
```

---

## 4. `this` als Rückgabewert (Fluent API)

Man kann `this` typisieren, damit Methoden **Method Chaining** unterstützen.

```ts
class Builder {
  private content: string = ""

  add(text: string): this {
    this.content += text
    return this // Typ = Builder
  }

  print(): void {
    console.log(this.content)
  }
}

new Builder().add("Hallo ").add("Welt!").print()
```

---

## 5. Typische Nutzung in Generics (`this` Types)

TypeScript erlaubt **polymorphe this-Typen** für bessere Rückgabetypen.

```ts
class Base {
  withBase(): this {
    return this
  }
}

class Sub extends Base {
  withSub(): this {
    return this
  }
}

const obj = new Sub().withBase().withSub() // ✅ Sub
```

---

### Zusammenfassung

* `this` = aktuelles Objekt im Kontext.
* Typisierbar: `function fn(this: Typ, ...)`.
* In **Klassen** automatisch Instanz-Typ.
* **Arrow Functions** → übernehmen `this` vom äußeren Kontext.
* Unterstützt **Method Chaining** via `this`-Rückgabetyp.

🔗 Quellen:

* [TypeScript Handbook – this parameters](https://www.typescriptlang.org/docs/handbook/2/functions.html#this-parameters)
* [MDN – this (JavaScript)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/this)

  **[⬆ Наверх](#top)**

69. ### <a name="69"></a> Kann man generische Klassen erstellen?

### Generische Klassen in TypeScript

**Antwort:**
Ja ✅ — Klassen können wie Funktionen **Generics** verwenden.
👉 Damit können Klassen flexibel mit unterschiedlichen Typen arbeiten, ohne die Typ-Sicherheit zu verlieren.

---

## 1. Einfache generische Klasse

```ts
class Box<T> {
  private content: T

  constructor(value: T) {
    this.content = value
  }

  getContent(): T {
    return this.content
  }
}

const stringBox = new Box("Hallo") // Box<string>
const numBox = new Box(42)         // Box<number>

console.log(stringBox.getContent()) // Hallo
console.log(numBox.getContent())    // 42
```

---

## 2. Generische Klasse mit mehreren Typ-Parametern

```ts
class Pair<K, V> {
  constructor(public key: K, public value: V) {}
}

const entry = new Pair("id", 123) // Pair<string, number>
```

---

## 3. Mit `extends` (Constraints)

```ts
interface Identifiable {
  id: number
}

class Repository<T extends Identifiable> {
  private items: T[] = []

  add(item: T) {
    this.items.push(item)
  }

  getById(id: number): T | undefined {
    return this.items.find(item => item.id === id)
  }
}

const repo = new Repository<{ id: number; name: string }>()
repo.add({ id: 1, name: "Sergii" })
console.log(repo.getById(1)) // { id: 1, name: "Sergii" }
```

---

## 4. Generische Klassen + Interfaces

```ts
interface Storage<T> {
  add(item: T): void
  getAll(): T[]
}

class MemoryStorage<T> implements Storage<T> {
  private items: T[] = []

  add(item: T): void {
    this.items.push(item)
  }

  getAll(): T[] {
    return this.items
  }
}

const store = new MemoryStorage<string>()
store.add("Hello")
store.add("World")
console.log(store.getAll()) // ["Hello", "World"]
```

---

### Zusammenfassung

* **Generische Klassen** = Klassen mit Typparametern (`class MyClass<T> {}`).
* Erlauben **flexible, typsichere Datenstrukturen** (z. B. Box, Repository, Storage).
* Unterstützen mehrere Typparameter (`<K, V>`), Constraints (`extends`) und Implementierungen von Interfaces.

🔗 Quellen:

* [TypeScript Handbook – Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-classes)

  **[⬆ Наверх](#top)**

70. ### <a name="70"></a> Wie erstellt man ein React-Projekt mit TypeScript?

### Schnellstart: React + TypeScript

#### **Option A – Vite (empfohlen, schnell & leicht)**

```bash
# Node 18+ empfohlen
npm create vite@latest my-app -- --template react-ts
cd my-app
npm install
npm run dev
```

**Beispiel-Komponente**

```js
// src/components/Hello.tsx
import { useState } from "react"

export function Hello({ name }: { name: string }) {
  const [count, setCount] = useState<number>(0)
  return (
    <button onClick={() => setCount((c) => c + 1)}>
      Hallo {name}! Klicks: {count}
    </button>
  )
}
```

**Pfadalias (optional)**

```js
// tsconfig.json (Auszug)
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": { "@/*": ["src/*"] },
    "strict": true,
    "jsx": "react-jsx"
  }
}
```

```js
// vite.config.ts (Auszug)
import { defineConfig } from "vite"
import react from "@vitejs/plugin-react"
import path from "node:path"

export default defineConfig({
  plugins: [react()],
  resolve: { alias: { "@": path.resolve(__dirname, "src") } }
})
```

---

#### **Option B – Next.js (SSR/SSG, Full-stack)**

```bash
npx create-next-app@latest my-app --ts
cd my-app
npm run dev
```

**Client-Komponente**

```js
// app/page.tsx (Next.js App Router)
export default function Page() {
  return <h1>Hallo Next.js + TypeScript</h1>
}
```

---

### Typische TS/React-Patterns

**Props & Events**

```js
// src/components/Input.tsx
import type { ChangeEvent } from "react"

export function Input({ onChange }: { onChange: (v: string) => void }) {
  const handle = (e: ChangeEvent<HTMLInputElement>) => onChange(e.target.value)
  return <input onChange={handle} />
}
```

**Generische Utility-Komponente**

```js
// src/components/List.tsx
export function List<T>({ items, render }: { items: T[]; render: (x: T) => JSX.Element }) {
  return <ul>{items.map(render)}</ul>
}
```

---

### Qualität & DX (optional, kurz)

* **ESLint/Prettier**

  ```bash
  npm i -D eslint @typescript-eslint/{parser,eslint-plugin} prettier
  ```
* **Strict** aktiv lassen (`"strict": true`) für bessere Typprüfung.
* **Testing**: Vitest + React Testing Library in Vite-Projekten.

---

### Zusammenfassung

* **Vite + `react-ts`** für SPA: schnell, minimal.
* **Next.js + `--ts`** für SSR/SSG/Full-stack.
* Aktiviere **`strict`** & nutze **`jsx: "react-jsx"`**.
* Typisiere Props/Events explizit; nutze Generics bei Wiederverwendung.

**Quellen:**

* [React Offizielle Doku – Einstieg](https://react.dev/learn)
* [TypeScript – React mit TS (JSX/TSX)](https://www.typescriptlang.org/docs/handbook/jsx.html)
* [React + TypeScript Cheatsheet – Setup](https://react-typescript-cheatsheet.netlify.app/docs/basic/setup)
* [Vite – React TS Template](https://vitejs.dev/guide/)
* [Next.js – TypeScript](https://nextjs.org/docs/basic-features/typescript)

  **[⬆ Наверх](#top)**

71. ### <a name="71"></a> Wie typisiert man eine React-Komponente (FC)?

### Typisierung von React-Komponenten in TypeScript

---

## **1. Funktionale Komponente mit Props**

```tsx
type HelloProps = {
  name: string
  age?: number // optional
}

export function Hello({ name, age }: HelloProps) {
  return <h1>Hallo {name}, Alter: {age}</h1>
}
```

👉 Standard: Props mit einem **Type** oder **Interface** typisieren.

---

## **2. Mit `React.FC` (funktioniert, wird aber weniger empfohlen)**

```tsx
import type { FC } from "react"

type HelloProps = {
  name: string
}

export const Hello: FC<HelloProps> = ({ name, children }) => (
  <div>
    <h1>Hallo {name}</h1>
    {children} {/* children automatisch typisiert */}
  </div>
)
```

⚠️ Nachteile von `React.FC`:

* `children` wird **immer erlaubt** (auch wenn nicht erwünscht).
* Manche HOCs/Generics funktionieren schlechter.

---

## **3. Mit Generics (z. B. List-Komponente)**

```tsx
type ListProps<T> = {
  items: T[]
  render: (item: T) => JSX.Element
}

export function List<T>({ items, render }: ListProps<T>) {
  return <ul>{items.map(render)}</ul>
}

// Verwendung:
<List items={["A", "B", "C"]} render={(item) => <li>{item}</li>} />
```

---

## **4. Event-Handler in Props**

```tsx
import type { MouseEventHandler } from "react"

type ButtonProps = {
  label: string
  onClick: MouseEventHandler<HTMLButtonElement>
}

export function Button({ label, onClick }: ButtonProps) {
  return <button onClick={onClick}>{label}</button>
}
```

---

## **5. Default Props (via Default-Parameter)**

```tsx
type TitleProps = {
  text?: string
}

export function Title({ text = "Standardtitel" }: TitleProps) {
  return <h2>{text}</h2>
}
```

---

## Zusammenfassung

* **Empfohlen:** Props über **Type oder Interface** definieren und direkt in der Funktion nutzen.
* **`React.FC`** möglich, aber Nachteile (immer `children`).
* Für wiederverwendbare Komponenten → **Generics** verwenden.
* Events immer mit **React-Eventtypen** (`MouseEvent`, `ChangeEvent`, …) typisieren.

🔗 Quellen:

* [React TypeScript Cheatsheet – Function Components](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/function_components/)
* [React Docs](https://react.dev/)
* [TypeScript Handbook – Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)

  **[⬆ Наверх](#top)**

72. ### <a name="72"></a> Was ist React.FC und wann sollte man es vermeiden?

### `React.FC` in TypeScript

---

## **1. Definition**

`React.FC` (Function Component) ist ein vordefinierter Typ in `@types/react`, um **funktionale Komponenten** zu typisieren:

```tsx
import type { FC } from "react"

type HelloProps = { name: string }

export const Hello: FC<HelloProps> = ({ name }) => <h1>Hallo {name}</h1>
```

---

## **2. Vorteile von `React.FC`**

* Bietet **automatische Typisierung von `children`**.
* Klare Signatur: `const Comp: FC<Props>`.
* Einfacher für Einsteiger.

---

## **3. Nachteile von `React.FC` (Gründe zum Vermeiden)**

1. **`children` ist immer erlaubt**, auch wenn man es gar nicht will.

   ```tsx
   type Props = { name: string }
   const A: FC<Props> = ({ name, children }) => <>{name}{children}</>
   <A name="Sergii">❌ children wird automatisch zugelassen</A>
   ```

2. **Keine Unterstützung für `defaultProps`/`propTypes`** (deprecated Pattern).

3. **Generics schwieriger einzusetzen** (z. B. `FC<ListProps<T>>`).

4. **Nicht nötig**, weil Typisierung ohne `React.FC` präziser und flexibler ist.

---

## **4. Empfohlene Alternative (ohne React.FC)**

```tsx
type HelloProps = { name: string }

export function Hello({ name }: HelloProps) {
  return <h1>Hallo {name}</h1>
}
```

👉 Props direkt typisieren → mehr Kontrolle, keine unnötigen `children`.

---

## **5. Wann `React.FC` verwenden?**

* Kleine Projekte oder **schneller Prototyping-Code**.
* Wenn man **immer `children`** benötigt (z. B. Layout-Komponenten).
* Aber: In größeren Projekten wird **Vermeidung empfohlen** → klarere Typen, weniger Fehler.

---

### Zusammenfassung

* **`React.FC`** = Typalias für Function Components, inkl. implizitem `children`.
* **Problem:** macht `children` immer verfügbar, erschwert Generics.
* **Empfehlung:** Props **direkt typisieren** (statt `React.FC`).
* Nutzen: nur, wenn man absichtlich `children` erzwingen will.

🔗 Quellen:

* [React TypeScript Cheatsheet – Function Components](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/function_components/)
* [React Docs](https://react.dev/)

  **[⬆ Наверх](#top)**

73. ### <a name="73"></a> Wie typisiert man Props in einer React-Komponente?

### Props in React-Komponenten typisieren (TypeScript)

---

## **1. Mit `type`**

```tsx
type GreetingProps = {
  name: string
  age?: number // optional
}

export function Greeting({ name, age }: GreetingProps) {
  return <h1>Hallo {name}, Alter: {age}</h1>
}
```

👉 Empfehlung: `type` für Props, da es auch Unions, Utility Types usw. unterstützt.

---

## **2. Mit `interface`**

```tsx
interface ButtonProps {
  label: string
  onClick: () => void
}

export function Button({ label, onClick }: ButtonProps) {
  return <button onClick={onClick}>{label}</button>
}
```

👉 Vorteil: `interface` lässt sich **erweitern** (`extends`).

---

## **3. Mit `children`**

```tsx
type CardProps = {
  title: string
  children: React.ReactNode
}

export function Card({ title, children }: CardProps) {
  return (
    <div>
      <h2>{title}</h2>
      <div>{children}</div>
    </div>
  )
}
```

---

## **4. Mit Events**

```tsx
import type { MouseEvent } from "react"

type ButtonProps = {
  onClick: (e: MouseEvent<HTMLButtonElement>) => void
}

export function Button({ onClick }: ButtonProps) {
  return <button onClick={onClick}>Klick mich</button>
}
```

---

## **5. Mit Generics (z. B. Listen-Komponente)**

```tsx
type ListProps<T> = {
  items: T[]
  render: (item: T) => JSX.Element
}

export function List<T>({ items, render }: ListProps<T>) {
  return <ul>{items.map(render)}</ul>
}

// Nutzung
<List items={["A", "B", "C"]} render={(i) => <li>{i}</li>} />
```

---

## Zusammenfassung

* **Props** typisiert man über `type` oder `interface`.
* **Optional** mit `?`, **children** mit `React.ReactNode`.
* Events strikt mit **React-Eventtypen** (`MouseEvent`, `ChangeEvent`, …).
* Für wiederverwendbare Komponenten → **Generics**.

🔗 Quellen:

* [React TypeScript Cheatsheet – Props](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example/)
* [React Docs – Passing Props](https://react.dev/learn/passing-props-to-a-component)

  **[⬆ Наверх](#top)**

74. ### <a name="74"></a> Wie typisiert man optionale Props?

### Optionale Props in React mit TypeScript

---

## **1. Mit `?` (Standardmethode)**

```tsx
type GreetingProps = {
  name: string
  age?: number // optional
}

export function Greeting({ name, age }: GreetingProps) {
  return <h1>Hallo {name}, Alter: {age ?? "unbekannt"}</h1>
}
```

👉 `age` ist automatisch `number | undefined`.

---

## **2. Mit Default-Wert im Destructuring**

```tsx
type TitleProps = {
  text?: string
}

export function Title({ text = "Standardtitel" }: TitleProps) {
  return <h2>{text}</h2>
}
```

👉 So wird `text` im Body **immer ein `string`**.

---

## **3. In Kombination mit `React.ReactNode` (children optional)**

```tsx
type CardProps = {
  title: string
  children?: React.ReactNode
}

export function Card({ title, children }: CardProps) {
  return (
    <div>
      <h2>{title}</h2>
      {children && <div>{children}</div>}
    </div>
  )
}
```

---

## **4. Utility Types für optionale Props (`Partial`)**

```tsx
type User = { id: number; name: string; email: string }

type OptionalUserProps = Partial<User>
// alle Props jetzt optional
```

---

### Zusammenfassung

* Optionale Props mit **`?`** markieren.
* Optional + Default-Wert → verhindert `undefined` im Body.
* `children` oft als optionales `React.ReactNode`.
* Utility Type **`Partial<T>`** macht alle Props optional.

🔗 Quellen:

* [TypeScript Handbook – Optional Properties](https://www.typescriptlang.org/docs/handbook/2/objects.html#optional-properties)
* [React TS Cheatsheet – Props](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example/)

  **[⬆ Наверх](#top)**

75. ### <a name="75"></a> Wie deklariert man Default Props in TypeScript?

### Default Props in React + TypeScript

In modernen React-Projekten mit TypeScript setzt man **Default-Werte direkt im Funktionsparameter**.
👉 Die alte Lösung mit `Component.defaultProps` ist **deprecated**.

---

## **1. Default Props über Destructuring**

```tsx
type GreetingProps = {
  name: string
  age?: number
}

export function Greeting({ name, age = 18 }: GreetingProps) {
  return <h1>Hallo {name}, Alter: {age}</h1>
}

// Verwendung:
<Greeting name="Sergii" />       // Alter: 18
<Greeting name="Anna" age={25} /> // Alter: 25
```

➡️ `age` ist im Body immer `number`, kein `undefined`.

---

## **2. Default Props bei `children`**

```tsx
type CardProps = {
  title?: string
  children?: React.ReactNode
}

export function Card({ title = "Ohne Titel", children }: CardProps) {
  return (
    <div>
      <h2>{title}</h2>
      {children}
    </div>
  )
}
```

---

## **3. Mit `Partial<T>` für flexible Defaults**

```tsx
type ButtonProps = {
  label: string
  size?: "small" | "medium" | "large"
}

const defaultProps: Partial<ButtonProps> = {
  size: "medium"
}

export function Button({ label, size = defaultProps.size }: ButtonProps) {
  return <button>{`${label} (${size})`}</button>
}
```

---

## **4. Generische Komponente mit Defaults**

```tsx
type ListProps<T> = {
  items?: T[]
  render: (item: T) => JSX.Element
}

export function List<T>({ items = [], render }: ListProps<T>) {
  return <ul>{items.map(render)}</ul>
}
```

---

### Zusammenfassung

* **Empfohlene Methode**: Default-Werte direkt beim **Destructuring** setzen.
* Props bleiben **optional** (`?`), aber im Funktionskörper ist der Typ **bereinigt**.
* `defaultProps` (alte Syntax) → vermeiden.

🔗 Quellen:

* [React TS Cheatsheet – Props mit Defaults](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example/#default-props)
* [React Docs – Passing Props](https://react.dev/learn/passing-props-to-a-component)

  **[⬆ Наверх](#top)**

76. ### <a name="76"></a> Wie typisiert man children in React-Komponenten?

### `children` in React-Komponenten typisieren

---

## **1. Mit `React.ReactNode` (Standard)**

```tsx
type CardProps = {
  children: React.ReactNode
}

export function Card({ children }: CardProps) {
  return <div className="card">{children}</div>
}

// Nutzung:
<Card>
  <h2>Hallo</h2>
  <p>Inhalt</p>
</Card>
```

👉 `React.ReactNode` erlaubt: JSX, Strings, Zahlen, Arrays, `null`, `undefined`.

---

## **2. Mit `ReactElement` (nur JSX erlaubt)**

```tsx
import type { ReactElement } from "react"

type WrapperProps = {
  children: ReactElement
}

export function Wrapper({ children }: WrapperProps) {
  return <section>{children}</section>
}

// <Wrapper><h1>✅ nur ein Element</h1></Wrapper>
// <Wrapper>Text ❌ Fehler</Wrapper>
```

---

## **3. Array von React-Elementen**

```tsx
import type { ReactElement } from "react"

type ListProps = {
  children: ReactElement[]
}

export function List({ children }: ListProps) {
  return <ul>{children}</ul>
}

// <List><li>A</li><li>B</li></List> ✅
```

---

## **4. Funktion als Children (Render Prop)**

```tsx
type RenderPropProps = {
  children: (count: number) => React.ReactNode
}

export function Counter({ children }: RenderPropProps) {
  return <div>{children(5)}</div>
}

// <Counter>{(n) => <span>Zahl: {n}</span>}</Counter>
```

---

## **5. Optionales `children`**

```tsx
type ContainerProps = {
  children?: React.ReactNode
}

export function Container({ children }: ContainerProps) {
  return <main>{children ?? "Kein Inhalt"}</main>
}
```

---

### Zusammenfassung

* **`React.ReactNode`** → flexibel, Standard für `children`.
* **`ReactElement`** → nur gültige JSX-Elemente (kein Text, kein Array).
* **Arrays** explizit als `ReactElement[]`.
* **Render Props** typisieren mit Funktionssignatur.
* `children` optional machen mit `?`.

🔗 Quellen:

* [React TypeScript Cheatsheet – Children](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example/#children)
* [React Docs – Passing Children](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children)

  **[⬆ Наверх](#top)**

77. ### <a name="77"></a> Was ist der Unterschied zwischen ReactNode, JSX.Element und ReactElement?

### Unterschied: `ReactNode` vs. `JSX.Element` vs. `ReactElement`

Diese drei Typen werden in React/TypeScript oft verwechselt, haben aber **verschiedene Bedeutungen**.

---

## **1. `ReactNode`**

👉 Der **allgemeinste Typ** für Inhalte, die in JSX gerendert werden können.
Enthält:

* `string`, `number`, `boolean` (teilweise),
* `null`, `undefined`,
* `JSX.Element`, `ReactElement`,
* Arrays dieser Typen.

```tsx
type ExampleProps = {
  children: React.ReactNode
}

export function Example({ children }: ExampleProps) {
  return <div>{children}</div>
}

// ✅ erlaubt:
<Example>Hallo</Example>
<Example>{123}</Example>
<Example><span>Text</span></Example>
<Example>{["A", "B", <b key="x">C</b>]}</Example>
```

---

## **2. `JSX.Element`**

👉 Typ, den der **JSX-Compiler** (`<div>...</div>`) zurückgibt.

* Wird von `React.createElement` erzeugt.
* Ist **genauer** als `ReactNode`.
* Entspricht in der Praxis **einem einzelnen React-Element**.

```tsx
const el: JSX.Element = <h1>Hello</h1>
// el = React.createElement("h1", null, "Hello")
```

---

## **3. `ReactElement`**

👉 Generischer Typ für ein Element, erzeugt durch `React.createElement`.

```tsx
const el: React.ReactElement = <button>Klick</button>
```

* Kann generisch spezifiziert werden:

```tsx
const el: React.ReactElement<{ onClick: () => void }> = (
  <button onClick={() => {}}>Klick</button>
)
```

* Typisch in **Bibliotheken und Low-Level-APIs**, seltener in App-Code.

---

## **Vergleichstabelle**

| Typ            | Beschreibung                                   | Beispiel-Einsatz             |
| -------------- | ---------------------------------------------- | ---------------------------- |
| `ReactNode`    | **Alles**, was in JSX gerendert werden kann    | Props: `children: ReactNode` |
| `JSX.Element`  | Ergebnis von JSX-Ausdrücken (`<div>...</div>`) | Rückgabewert von Komponenten |
| `ReactElement` | Konkretes React-Element (mit Props & Type)     | Low-Level-APIs, Tests, Libs  |

---

## **4. Typische Verwendung**

* **`ReactNode`** → für `children` (flexibel).
* **`JSX.Element`** → für Rückgabewerte von Komponenten.
* **`ReactElement`** → für präzise Typisierung einzelner Elemente.

---

### Zusammenfassung

* **`ReactNode`** = Union aller renderbaren Typen → am breitesten.
* **`JSX.Element`** = konkretes JSX-Ergebnis → Standard für `return` einer Komponente.
* **`ReactElement`** = generischer Typ eines React-Elements, inkl. Props.

🔗 Quellen:

* [React TypeScript Cheatsheet – JSX, ReactNode, ReactElement](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/jsx)
* [React Docs – JSX](https://react.dev/learn/writing-markup-with-jsx)

  **[⬆ Наверх](#top)**

78. ### <a name="78"></a> Wie typisiert man Events (z. B. onClick, onChange)?

### Events in React mit TypeScript typisieren

React liefert für jedes DOM-Element eigene **Event-Typen**.
👉 Diese sind in `@types/react` vordefiniert und basieren auf **`SyntheticEvent`**.

---

## **1. Allgemeiner Typ**

```tsx
import type { SyntheticEvent } from "react"

function handleEvent(e: SyntheticEvent) {
  console.log(e.type) // z. B. "click"
}
```

👉 Gut für Basisevents, aber unpräzise.

---

## **2. `onClick` – Button Klick**

```tsx
import type { MouseEvent } from "react"

function handleClick(e: MouseEvent<HTMLButtonElement>) {
  console.log("Button geklickt:", e.currentTarget)
}

export function App() {
  return <button onClick={handleClick}>Klick mich</button>
}
```

---

## **3. `onChange` – Input ändern**

```tsx
import type { ChangeEvent } from "react"

function handleChange(e: ChangeEvent<HTMLInputElement>) {
  console.log("Wert:", e.target.value)
}

export function Input() {
  return <input type="text" onChange={handleChange} />
}
```

---

## **4. Formular-Submit**

```tsx
import type { FormEvent } from "react"

function handleSubmit(e: FormEvent<HTMLFormElement>) {
  e.preventDefault()
  console.log("Formular gesendet")
}

export function Form() {
  return <form onSubmit={handleSubmit}><button>Senden</button></form>
}
```

---

## **5. Weitere Beispiele**

* **Mouse Events**:
  `MouseEvent<HTMLDivElement>` → `onMouseEnter`, `onMouseLeave`, `onContextMenu`
* **Keyboard Events**:
  `KeyboardEvent<HTMLInputElement>` → `onKeyDown`, `onKeyUp`
* **Focus Events**:
  `FocusEvent<HTMLInputElement>` → `onFocus`, `onBlur`

```tsx
import type { KeyboardEvent } from "react"

function handleKeyDown(e: KeyboardEvent<HTMLInputElement>) {
  if (e.key === "Enter") console.log("Enter gedrückt")
}
```

---

## **6. Inline-Handler (kurz)**

```tsx
export function Btn() {
  return (
    <button
      onClick={(e: React.MouseEvent<HTMLButtonElement>) => console.log(e.currentTarget)}
    >
      Klick
    </button>
  )
}
```

---

### Zusammenfassung

* Basis: `SyntheticEvent`.
* Genaue Typen: `MouseEvent`, `ChangeEvent`, `KeyboardEvent`, `FormEvent` usw.
* Generische Signatur: `Event<HTMLTagElement>`.
* Faustregel: **Immer den passenden DOM-Typ** einsetzen (z. B. `HTMLInputElement`, `HTMLButtonElement`).

🔗 Quellen:

* [React TS Cheatsheet – Events](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/event_handling/)
* [MDN – DOM Events](https://developer.mozilla.org/ru/docs/Web/Events)

  **[⬆ Наверх](#top)**

79. ### <a name="79"></a> Wie typisiert man Refs in React?

### Refs in React mit TypeScript typisieren

Refs werden in React über **`useRef`** oder **`createRef`** erstellt. Mit TypeScript kann man genau angeben, **auf welchen Typ** sie verweisen.

---

## **1. Ref auf DOM-Element**

```tsx
import { useRef, useEffect } from "react"

export function InputFocus() {
  const inputRef = useRef<HTMLInputElement>(null)

  useEffect(() => {
    inputRef.current?.focus()
  }, [])

  return <input ref={inputRef} />
}
```

👉 Typ: `HTMLInputElement | null`.

---

## **2. Ref auf andere DOM-Elemente**

* `HTMLDivElement`
* `HTMLButtonElement`
* `HTMLTextAreaElement`
* `HTMLCanvasElement` usw.

```tsx
const divRef = useRef<HTMLDivElement>(null)
```

---

## **3. Ref auf einen Wert (Mutable Ref)**

👉 Wenn man kein DOM-Element, sondern **einen beliebigen Wert** speichern will.

```tsx
const countRef = useRef<number>(0)

function increment() {
  countRef.current += 1
}
```

* Kein `null` nötig → direkt `useRef<number>(0)`
* Typ: `MutableRefObject<number>`

---

## **4. `createRef` (meist für Klassenkomponenten)**

```tsx
import { createRef, Component } from "react"

class MyForm extends Component {
  inputRef = createRef<HTMLInputElement>()

  focusInput = () => {
    this.inputRef.current?.focus()
  }

  render() {
    return <input ref={this.inputRef} />
  }
}
```

---

## **5. Weitergabe von Refs mit `forwardRef`**

```tsx
import { forwardRef } from "react"

type InputProps = { placeholder?: string }

export const CustomInput = forwardRef<HTMLInputElement, InputProps>(
  ({ placeholder }, ref) => <input ref={ref} placeholder={placeholder} />
)

// Nutzung:
import { useRef } from "react"

export function Form() {
  const ref = useRef<HTMLInputElement>(null)
  return <CustomInput ref={ref} placeholder="Name" />
}
```

---

## Zusammenfassung

* DOM-Ref: `useRef<HTMLTagElement>(null)`
* Wert-Ref: `useRef<T>(initialValue)` → `MutableRefObject<T>`
* `forwardRef` für Weitergabe von Refs typisieren mit `forwardRef<HTMLTag, Props>`.
* `createRef` → selten, v. a. für Klassenkomponenten.

🔗 Quellen:

* [React TypeScript Cheatsheet – Refs](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/hooks/#useref)
* [React Docs – Refs](https://react.dev/learn/referencing-values-with-refs)

  **[⬆ Наверх](#top)**

80. ### <a name="80"></a> Wie typisiert man State mit useState?

### State mit `useState` typisieren

React’s **`useState`** ist ein generischer Hook (`useState<S>()`).
👉 Man kann den Typ explizit angeben oder TypeScript lässt ihn **inferen**.

---

## **1. Einfache Typisierung**

```tsx
import { useState } from "react"

export function Counter() {
  const [count, setCount] = useState<number>(0)

  return <button onClick={() => setCount(count + 1)}>{count}</button>
}
```

➡️ `count: number`, `setCount: Dispatch<SetStateAction<number>>`

---

## **2. Typ wird automatisch inferred**

```tsx
const [name, setName] = useState("Sergii")
// Typ: string (kein <string> nötig)
```

---

## **3. Union Types**

```tsx
type Status = "loading" | "success" | "error"

const [status, setStatus] = useState<Status>("loading")

setStatus("success") // ✅
setStatus("failed")  // ❌ Fehler
```

---

## **4. Nullbare Werte**

```tsx
interface User {
  id: number
  name: string
}

const [user, setUser] = useState<User | null>(null)

if (user) {
  console.log(user.name) // sicher
}
```

---

## **5. useState mit Funktion (Lazy Init)**

```tsx
const [expensive, setExpensive] = useState<number>(() => {
  return Math.random() * 1000 // nur einmal beim Mount
})
```

---

## **6. useState mit Objekt**

```tsx
type FormState = {
  username: string
  age: number
}

const [form, setForm] = useState<FormState>({ username: "", age: 0 })

setForm(prev => ({ ...prev, username: "Anna" }))
```

---

### Zusammenfassung

* **`useState<T>()`** → Typ explizit oder inferred.
* Union-Typen für begrenzte Werte (`"success" | "error"`).
* Für optionale Werte: `T | null`.
* Bei Objekten: State-Updates immutabel mit Spread.

🔗 Quellen:

* [React TypeScript Cheatsheet – useState](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/hooks/#usestate)
* [React Docs – useState](https://react.dev/reference/react/useState)

  **[⬆ Наверх](#top)**  

81. ### <a name="81"></a> Wie typisiert man useReducer?

### `useReducer` in React mit TypeScript typisieren

Der Hook **`useReducer`** ist generisch und erlaubt eine sehr präzise Typisierung von **State** und **Actions**.

---

## **1. Basis-Signatur**

```ts
const [state, dispatch] = useReducer<Reducer<State, Action>>(reducer, initialState)
```

oder einfach:

```ts
const [state, dispatch] = useReducer(reducer, initialState)
```

👉 TypeScript inferiert die Typen, wenn `reducer` und `initialState` sauber typisiert sind.

---

## **2. Beispiel – Counter**

```tsx
import { useReducer } from "react"

// State-Typ
type State = { count: number }

// Action-Typ (Union)
type Action = { type: "increment" } | { type: "decrement" } | { type: "reset"; payload: number }

// Reducer
function reducer(state: State, action: Action): State {
  switch (action.type) {
    case "increment":
      return { count: state.count + 1 }
    case "decrement":
      return { count: state.count - 1 }
    case "reset":
      return { count: action.payload }
    default:
      return state
  }
}

// Nutzung
export function Counter() {
  const [state, dispatch] = useReducer(reducer, { count: 0 })

  return (
    <>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: "increment" })}>+</button>
      <button onClick={() => dispatch({ type: "decrement" })}>-</button>
      <button onClick={() => dispatch({ type: "reset", payload: 10 })}>Reset</button>
    </>
  )
}
```

👉 `dispatch` ist automatisch auf den Typ `Action` eingeschränkt.

---

## **3. Mit Generics (explizit)**

```tsx
import { useReducer, Reducer } from "react"

type State = { name: string }
type Action = { type: "setName"; payload: string }

const reducer: Reducer<State, Action> = (state, action) => {
  switch (action.type) {
    case "setName":
      return { ...state, name: action.payload }
  }
}

const [state, dispatch] = useReducer(reducer, { name: "Sergii" })
```

---

## **4. Mit komplexeren Payloads**

```tsx
type Todo = { id: number; text: string; done: boolean }

type Action =
  | { type: "add"; payload: string }
  | { type: "toggle"; payload: number }
  | { type: "remove"; payload: number }
```

👉 Payload-Typen sind individuell je Action.

---

## **5. Lazy Initialization (dritter Parameter)**

```tsx
function init(count: number): State {
  return { count }
}

const [state, dispatch] = useReducer(reducer, 5, init)
// initialisiert mit { count: 5 }
```

---

### Zusammenfassung

* `useReducer` typisiert man mit **State** und **Action**.
* Action-Typen meist als **Discriminated Unions**.
* `dispatch` ist automatisch korrekt typisiert.
* Option für Lazy Init mit drittem Parameter.

🔗 Quellen:

* [React Docs – useReducer](https://react.dev/reference/react/useReducer)
* [React TypeScript Cheatsheet – useReducer](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/hooks/#usereducer)

  **[⬆ Наверх](#top)**

82. ### <a name="82"></a> Wie typisiert man useRef mit initial null?

### `useRef` mit initial `null` typisieren

In React ist ein **DOM-Ref** oder ein **nullable Ref** typisch → `T | null`.

---

## **1. Ref auf DOM-Element**

```tsx
import { useRef, useEffect } from "react"

export function InputFocus() {
  // HTMLInputElement | null
  const inputRef = useRef<HTMLInputElement>(null)

  useEffect(() => {
    inputRef.current?.focus()
  }, [])

  return <input ref={inputRef} />
}
```

👉 `inputRef.current` hat den Typ `HTMLInputElement | null`.

---

## **2. Ref auf generische Werte**

```tsx
const timerRef = useRef<number | null>(null)

function startTimer() {
  timerRef.current = window.setTimeout(() => {
    console.log("Timer!")
  }, 1000)
}

function clearTimer() {
  if (timerRef.current !== null) {
    clearTimeout(timerRef.current)
  }
}
```

---

## **3. Unterschied: `useRef<T>(null)` vs. `useRef<T | null>(null)`**

* **`useRef<T>(null)`** → Fehler, weil `null` nicht `T` ist.
* **`useRef<T | null>(null)`** → korrekt, `current` kann `null` sein.

---

## **4. Zugriff absichern**

```tsx
if (inputRef.current) {
  inputRef.current.value = "Hallo"
}
```

oder mit **Optional Chaining**:

```tsx
inputRef.current?.focus()
```

---

### Zusammenfassung

* Für DOM-Elemente: `useRef<HTMLDivElement | null>(null)`.
* Für Werte: `useRef<T | null>(null)`.
* Immer `| null` hinzufügen, da beim Initialisieren `null` gesetzt wird.
* Zugriff absichern mit `if` oder `?.`.

🔗 Quellen:

* [React Docs – Refs](https://react.dev/learn/referencing-values-with-refs)
* [React TS Cheatsheet – useRef](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/hooks/#useref)

  **[⬆ Наверх](#top)**

83. ### <a name="83"></a> Wie typisiert man einen Custom Hook?

### Custom Hook in TypeScript typisieren

---

## 1) Einfacher Hook (Rückgabetyp inferieren lassen)

```js
import { useEffect, useState } from "react"

export function useOnline() {
  const [online, setOnline] = useState<boolean>(navigator.onLine)

  useEffect(() => {
    const on = () => setOnline(true)
    const off = () => setOnline(false)
    window.addEventListener("online", on)
    window.addEventListener("offline", off)
    return () => {
      window.removeEventListener("online", on)
      window.removeEventListener("offline", off)
    }
  }, [])

  return online // boolean
}
```

---

## 2) Hook mit explizitem Rückgabetyp (Objekt / Tupel)

```js
import { useCallback, useState } from "react"

type Counter = {
  count: number
  inc: () => void
  dec: () => void
  reset: () => void
}

export function useCounter(initial = 0): Counter {
  const [count, setCount] = useState<number>(initial)
  const inc = useCallback(() => setCount((c) => c + 1), [])
  const dec = useCallback(() => setCount((c) => c - 1), [])
  const reset = useCallback(() => setCount(initial), [initial])
  return { count, inc, dec, reset }
}
```

```js
// Tupel-Variante
import { useState } from "react"

export function useToggle(initial = false): [boolean, () => void] {
  const [on, setOn] = useState<boolean>(initial)
  return [on, () => setOn((v) => !v)]
}
```

---

## 3) Generischer Hook (mit Constraints)

```js
import { useMemo } from "react"

export function usePick<T extends object, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> {
  return useMemo(() => {
    const out = {} as Pick<T, K>
    for (const k of keys) out[k] = obj[k]
    return out
  }, [obj, keys.join("|")])
}

// Nutzung
const user = { id: 1, name: "Sergii", admin: true }
const partial = usePick(user, ["id", "name"]) // Typ: { id: number; name: string }
```

---

## 4) Hook, der Promise-Status kapselt (Union/Discriminated Union)

```js
import { useEffect, useState } from "react"

type AsyncState<T> =
  | { status: "idle" }
  | { status: "loading" }
  | { status: "success"; data: T }
  | { status: "error"; error: Error }

export function useAsync<T>(fn: () => Promise<T>, deps: unknown[] = []) {
  const [state, setState] = useState<AsyncState<T>>({ status: "idle" })

  useEffect(() => {
    let alive = true
    setState({ status: "loading" })
    fn()
      .then((data) => alive && setState({ status: "success", data }))
      .catch((error) => alive && setState({ status: "error", error }))
    return () => { alive = false }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, deps)

  return state
}
```

---

## 5) Hook mit Ref im Rückgabewert

```js
import { useEffect, useRef } from "react"

export function useFocus<T extends HTMLElement>() {
  const ref = useRef<T | null>(null)
  useEffect(() => { ref.current?.focus() }, [])
  return ref // RefObject<T | null>
}
```

---

## 6) Typ-Tipps

* Parameter und Rückgabewert klar typisieren; bei einfachen Fällen **Inference** nutzen.
* Für Tupel-Rückgaben **exakten Tupeltyp** angeben (`[T, U]`).
* Bei generischen Hooks **Constraints** setzen (`<T extends object>`).
* Für `null`-bare Werte explizit `| null`.
* Für komplexe Status **discriminated unions** nutzen.

---

### Zusammenfassung

* Custom Hooks sind normale Funktionen: **Parameter- & Rückgabetyp** angeben; bei Bedarf **Generics** und **Unions** einsetzen.
* Tupel oder Objekt als Rückgabewert klar typisieren.
* Refs als `RefObject<T | null>`, asynchrone Zustände über **discriminated unions**.

**Quellen:**

* [React Docs – Reusing Logic with Custom Hooks](https://react.dev/learn/reusing-logic-with-custom-hooks)
* [React TypeScript Cheatsheet – Hooks & Patterns](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/hooks/)
* [TypeScript Handbook – Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)

  **[⬆ Наверх](#top)**

84. ### <a name="84"></a> Wie typisiert man Komponenten mit forwardRef?

### Komponenten mit `forwardRef` typisieren (TypeScript + React)

---

## **1. Grundsyntax**

`forwardRef` ist ein **Generic**: `forwardRef<T, P>`

* **`T`** = Typ des Referenz-Elements (z. B. `HTMLInputElement`)
* **`P`** = Typ der Props

```tsx
import { forwardRef } from "react"

type InputProps = {
  label: string
}

export const Input = forwardRef<HTMLInputElement, InputProps>(
  ({ label, ...props }, ref) => (
    <label>
      {label}
      <input ref={ref} {...props} />
    </label>
  )
)

// Nutzung
import { useRef } from "react"

export function Form() {
  const inputRef = useRef<HTMLInputElement>(null)
  return <Input ref={inputRef} label="Name" />
}
```

---

## **2. Mit optionalen Props + `children`**

```tsx
type ButtonProps = {
  children: React.ReactNode
  onClick?: () => void
}

export const Button = forwardRef<HTMLButtonElement, ButtonProps>(
  ({ children, onClick }, ref) => (
    <button ref={ref} onClick={onClick}>
      {children}
    </button>
  )
)
```

---

## **3. Generischer Typ in `forwardRef`**

```tsx
type ListProps<T> = {
  items: T[]
  render: (item: T) => JSX.Element
}

function ListInner<T>(
  { items, render }: ListProps<T>,
  ref: React.Ref<HTMLUListElement>
) {
  return <ul ref={ref}>{items.map(render)}</ul>
}

export const List = forwardRef(ListInner) as <T>(
  props: ListProps<T> & { ref?: React.Ref<HTMLUListElement> }
) => JSX.Element

// Nutzung
<List items={[1, 2, 3]} render={(i) => <li>{i}</li>} />
```

---

## **4. Mit `useImperativeHandle` (Custom Ref API)**

```tsx
import { forwardRef, useImperativeHandle, useRef } from "react"

type FocusInputHandle = {
  focus: () => void
}

export const FocusInput = forwardRef<FocusInputHandle, {}>((_, ref) => {
  const inputRef = useRef<HTMLInputElement>(null)

  useImperativeHandle(ref, () => ({
    focus: () => inputRef.current?.focus(),
  }))

  return <input ref={inputRef} />
})

// Nutzung
export function App() {
  const ref = useRef<FocusInputHandle>(null)
  return (
    <>
      <FocusInput ref={ref} />
      <button onClick={() => ref.current?.focus()}>Fokus setzen</button>
    </>
  )
}
```

---

### Zusammenfassung

* `forwardRef<T, P>` → `T` = Ref-Element-Typ, `P` = Props.
* Rückgabe: `JSX.Element`.
* Mit `useImperativeHandle` → eigene Methoden im Ref freigeben.
* Für Generics → `as`-Casting notwendig.

🔗 Quellen:

* [React Docs – forwardRef](https://react.dev/reference/react/forwardRef)
* [React TypeScript Cheatsheet – forwardRef](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/forms_and_events/#forwardref-createref)

  **[⬆ Наверх](#top)**

85. ### <a name="85"></a> Wie typisiert man Context (React Context API)?

### React Context API mit TypeScript typisieren

---

## **1. Einfacher Context (nicht nullbar)**

```tsx
import { createContext, useContext } from "react"

type Theme = "light" | "dark"

const ThemeContext = createContext<Theme>("light")

export function useTheme() {
  return useContext(ThemeContext)
}

// Nutzung
export function App() {
  return (
    <ThemeContext.Provider value="dark">
      <Child />
    </ThemeContext.Provider>
  )
}

function Child() {
  const theme = useTheme()
  return <p>Aktuelles Theme: {theme}</p>
}
```

👉 Typ des Context-Werts: `Theme`.

---

## **2. Context mit `null` als Default**

⚠️ Häufig: Provider setzt später einen Wert → Default = `null`.

```tsx
type AuthContextValue = {
  user: string
  login: (name: string) => void
}

const AuthContext = createContext<AuthContextValue | null>(null)

export function useAuth() {
  const ctx = useContext(AuthContext)
  if (!ctx) throw new Error("useAuth muss innerhalb von AuthProvider genutzt werden")
  return ctx
}

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const login = (name: string) => console.log("Login:", name)
  return (
    <AuthContext.Provider value={{ user: "Sergii", login }}>
      {children}
    </AuthContext.Provider>
  )
}
```

---

## **3. Context mit State (useState + Context)**

```tsx
import { useState } from "react"

type CounterContextValue = {
  count: number
  setCount: React.Dispatch<React.SetStateAction<number>>
}

const CounterContext = createContext<CounterContextValue | null>(null)

export function CounterProvider({ children }: { children: React.ReactNode }) {
  const [count, setCount] = useState(0)
  return (
    <CounterContext.Provider value={{ count, setCount }}>
      {children}
    </CounterContext.Provider>
  )
}

export function useCounter() {
  const ctx = useContext(CounterContext)
  if (!ctx) throw new Error("useCounter muss in CounterProvider genutzt werden")
  return ctx
}
```

---

## **4. Context mit Generics (z. B. Repository Pattern)**

```tsx
type RepoContext<T> = {
  items: T[]
  add: (item: T) => void
}

function createRepoContext<T>() {
  return createContext<RepoContext<T> | null>(null)
}

const UserRepoContext = createRepoContext<{ id: number; name: string }>()
```

---

### Zusammenfassung

* Context wird mit `createContext<T>()` erstellt.
* Default-Wert → entweder **konkreter Wert** oder **`null`**.
* Mit `null` → immer Custom Hook bauen, der `useContext` kapselt + Fehler wirft.
* Typisch: `Context + Provider + useXyz-Hook`.
* Mit Generics → wiederverwendbare Contexts möglich.

🔗 Quellen:

* [React Docs – Context](https://react.dev/reference/react/createContext)
* [React TypeScript Cheatsheet – Context](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/context/)

  **[⬆ Наверх](#top)**

86. ### <a name="86"></a> Wie typisiert man HOCs (Higher-Order Components)?

### HOCs (Higher-Order Components) typisieren

**Definition:**
Ein HOC ist eine Funktion, die eine Komponente **entgegennimmt** und eine **neue Komponente zurückgibt**. In TypeScript nutzt man Generics, um die **Props des Wrapped Components** zu erhalten und ggf. **injizierte Props** nach außen zu entfernen.

---

## 1) Basis-HOC (ohne Prop-Änderung)

```js
import type { ComponentType } from "react"

export function withLogger<P>(Wrapped: ComponentType<P>) {
  return function ComponentWithLogger(props: P) {
    console.log("props:", props)
    return <Wrapped {...props} />
  }
}
```

* `P` repräsentiert die Props des Wrapped Components.
* Rückgabe akzeptiert **die gleichen Props** wie `Wrapped`.

---

## 2) HOC mit **injizierten Props** (nach außen entfernen)

```js
import type { ComponentType } from "react"

type Injected = { user: { id: number; name: string } }

export function withUser<P extends Injected>(
  Wrapped: ComponentType<P>
) {
  // nach außen entferne "user", weil HOC ihn liefert
  type OuterProps = Omit<P, keyof Injected>

  return function WithUser(props: OuterProps) {
    const injected: Injected = { user: { id: 1, name: "Sergii" } }
    return <Wrapped {...(props as P)} {...injected} />
  }
}

// Nutzung
type ProfileProps = { user: { id: number; name: string }; editable?: boolean }
function Profile({ user, editable }: ProfileProps) {
  return <div>{user.name} {editable ? "(edit)" : ""}</div>
}
export const ProfileWithUser = withUser(Profile)
// <ProfileWithUser editable />  // ✅ user wird vom HOC gesetzt
```

* **Wichtig:** `P extends Injected` und `OuterProps = Omit<P, keyof Injected>`.

---

## 3) HOC, der Props transformiert (z. B. Loading)

```js
import type { ComponentType } from "react"

type WithLoadingProps = { loading: boolean }

export function withLoading<P>(
  Wrapped: ComponentType<P>
) {
  return function WithLoading(props: P & WithLoadingProps) {
    if (props.loading) return <span>Lädt…</span>
    const { loading, ...rest } = props as WithLoadingProps & P
    return <Wrapped {...(rest as P)} />
  }
}
```

* HOC **erweitert** die äußeren Props um `loading`.

---

## 4) HOC + `forwardRef` (Ref durchleiten)

```js
import { forwardRef } from "react"
import type { ComponentType, Ref } from "react"

export function withRef<P, T>(Wrapped: ComponentType<P & { ref?: Ref<T> }>) {
  // äußere Props sollen die internen "ref"-Props nicht enthalten
  type OuterProps = P

  const Component = (props: OuterProps, ref: Ref<T>) => {
    return <Wrapped {...props} ref={ref} />
  }

  return forwardRef<T, OuterProps>(Component)
}

// Beispiel: DOM-Ref auf <input>
type InputProps = { placeholder?: string }
const RawInput = (p: InputProps, ref: Ref<HTMLInputElement>) => (
  <input ref={ref} {...p} />
)
const Input = forwardRef<HTMLInputElement, InputProps>(RawInput)

export const InputWithRef = withRef<InputProps, HTMLInputElement>(Input)
// Nutzung: const r = useRef<HTMLInputElement>(null); <InputWithRef ref={r} />
```

---

## 5) Statische Eigenschaften „hoisten“

HOCs verlieren i. d. R. **statische Properties** des Wrapped Components.
→ In Bibliotheken nutzt man oft `hoist-non-react-statics`, um sie zu kopieren.
*(Tipp fürs Interview erwähnen, Code hier weggelassen.)*

---

## 6) Typ-Tipps & Fallstricke

* Verwende **`ComponentType<P>`** statt `FC<P>`, um auch Klassenkomponenten zu unterstützen.
* Für injizierte Props immer **`Omit`** nach außen nutzen.
* Bei Refs: HOC mit **`forwardRef`** typisieren (siehe oben).
* Bei generischen Wrapped Components ggf. explizit casten (Constraint auf `P` setzen).

---

### Zusammenfassung

* HOCs mit Generics: `function withX<P>(Comp: ComponentType<P>) => (props: P|Omit<P,…>) => JSX.Element`.
* **Injected Props** nach außen mit `Omit` entfernen.
* **Refs** via `forwardRef<T, P>` korrekt weiterreichen.
* Optional: **statische Properties hoisten** (Lib-Nennung reicht im Interview).

**Quellen:**

* [React TypeScript Cheatsheet – HOCs](https://react-typescript-cheatsheet.netlify.app/docs/hoc/react_hoc_docs/)
* [React Offizielle Doku – HOCs (Konzept)](https://react.dev/learn/reusing-logic-with-custom-hooks)
* [TypeScript Handbook – Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)

**Zusammenfassung:**
HOCs typisiert man generisch über `ComponentType<P>`, entfernt **injizierte Props** per `Omit`, leitet **Refs** mit `forwardRef` durch und achtet bei Bedarf aufs **Hoisten statischer Properties**.

  **[⬆ Наверх](#top)**

87. ### <a name="87"></a> Wie typisiert man asynchrone Funktionen in React-Komponenten?

### Asynchrone Funktionen in React-Komponenten typisieren

---

## 1) Async-Eventhandler: immer `Promise<void>`

```js
import type { MouseEvent, FormEvent, ChangeEvent } from "react"

export function Actions() {
  const onClick = async (e: MouseEvent<HTMLButtonElement>): Promise<void> => {
    e.preventDefault()
    await fetch("/api/click")
  }

  const onSubmit = async (e: FormEvent<HTMLFormElement>): Promise<void> => {
    e.preventDefault()
    // …
  }

  const onChange = async (e: ChangeEvent<HTMLInputElement>): Promise<void> => {
    // …
  }

  return (
    <form onSubmit={onSubmit}>
      <input onChange={onChange} />
      <button onClick={onClick}>Senden</button>
      <button type="submit">Submit</button>
    </form>
  )
}
```

**Faustregel:** UI-Handler `async` → Rückgabetyp **`Promise<void>`**.

---

## 2) Async mit `useCallback`

```js
import { useCallback, useState } from "react"

export function Loader() {
  const [data, setData] = useState<string | null>(null)
  const [error, setError] = useState<Error | null>(null)
  const [loading, setLoading] = useState(false)

  const load = useCallback(async (): Promise<void> => {
    try {
      setLoading(true)
      const res = await fetch("/api/text")
      const text = await res.text()
      setData(text)
    } catch (e) {
      setError(e as Error)
    } finally {
      setLoading(false)
    }
  }, [])

  return <button onClick={load} disabled={loading}>{loading ? "…" : "Laden"}</button>
}
```

---

## 3) Async Funktionen mit Rückgabewert

```js
async function getUser(): Promise<{ id: number; name: string }> {
  const res = await fetch("/api/user")
  return res.json()
}

export function Profile() {
  // Nutzung: Rückgabetyp ist Promise<{ id; name }>
  // In Handlern weiterhin Promise<void> zurückgeben:
  const handle = async (): Promise<void> => {
    const user = await getUser()
    console.log(user.name)
  }
  return <button onClick={handle}>Profil laden</button>
}
```

---

## 4) Async Props (Funktionen als Props)

```js
type SaveFn = (payload: { id: number }) => Promise<void>

export function SaveButton({ onSave }: { onSave: SaveFn }) {
  const handle = async (): Promise<void> => {
    await onSave({ id: 1 })
  }
  return <button onClick={handle}>Speichern</button>
}
```

---

## 5) Abbrechen mit `AbortController` (typisiert)

```js
export function Fetcher() {
  const handle = async (): Promise<void> => {
    const controller = new AbortController()
    const id = setTimeout(() => controller.abort(), 3000)
    try {
      const res = await fetch("/api/data", { signal: controller.signal })
      await res.json()
    } finally {
      clearTimeout(id)
    }
  }
  return <button onClick={handle}>Fetch (3s Timeout)</button>
}
```

---

## 6) Typische Fehler vermeiden

* **Kein ungetyptes `any`**: Ergebnis immer mit **`Promise<T>`** annotieren.
* **Eventtypen korrekt** (`MouseEvent<HTMLButtonElement>`, `FormEvent<HTMLFormElement>`, …).
* **State-Typen** präzise halten (`T | null`, Discriminated Unions für Lade/Error-Status).
* **Handler** sollen keine Werte returnen, die React ignoriert → `Promise<void>`.

---

### Zusammenfassung

* Eventhandler als `async` → **`Promise<void>`** + passender **React-Eventtyp**.
* Datenfunktionen geben **`Promise<T>`** zurück; Handler nutzen sie und bleiben bei `Promise<void>`.
* `useCallback` für stabile Referenzen; Fehler/Loading in State modellieren.
* Abbrechen über **`AbortController`** korrekt typisieren.

**Quellen:**

* [React Docs – Events & Handlers](https://react.dev/learn/responding-to-events)
* [React TypeScript Cheatsheet – Event Handling & Hooks](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/event_handling/)
* [TypeScript Docs – Promises & async/await](https://www.typescriptlang.org/docs/handbook/2/functions.html#async-functions)
* [MDN – AbortController](https://developer.mozilla.org/ru/docs/Web/API/AbortController)

  **[⬆ Наверх](#top)**

88. ### <a name="88"></a> Wie typisiert man Event-Handler in Formularen?

### Event-Handler in Formularen typisieren (React + TypeScript)

React nutzt **synthetische Events** (`SyntheticEvent`) mit spezifischen Subtypen für Formulareingaben.
👉 Immer den **richtigen DOM-Typ** mitgeben (`HTMLFormElement`, `HTMLInputElement`, `HTMLSelectElement` …).

---

## **1. Formular-Submit (`onSubmit`)**

```tsx
import type { FormEvent } from "react"

function Form() {
  const handleSubmit = (e: FormEvent<HTMLFormElement>): void => {
    e.preventDefault()
    console.log("Formular gesendet")
  }

  return (
    <form onSubmit={handleSubmit}>
      <button type="submit">Senden</button>
    </form>
  )
}
```

---

## **2. Input-Felder (`onChange`)**

```tsx
import type { ChangeEvent } from "react"

function TextInput() {
  const handleChange = (e: ChangeEvent<HTMLInputElement>): void => {
    console.log("Neuer Wert:", e.target.value)
  }

  return <input type="text" onChange={handleChange} />
}
```

---

## **3. Select (`onChange`)**

```tsx
function SelectBox() {
  const handleChange = (e: React.ChangeEvent<HTMLSelectElement>): void => {
    console.log("Gewählt:", e.target.value)
  }

  return (
    <select onChange={handleChange}>
      <option value="a">A</option>
      <option value="b">B</option>
    </select>
  )
}
```

---

## **4. Textarea (`onChange`)**

```tsx
function TextArea() {
  const handleChange = (e: React.ChangeEvent<HTMLTextAreaElement>): void => {
    console.log("Text:", e.target.value)
  }

  return <textarea onChange={handleChange} />
}
```

---

## **5. Checkbox & Radio (`onChange`)**

```tsx
function Checkbox() {
  const handleCheck = (e: React.ChangeEvent<HTMLInputElement>): void => {
    console.log("Checked:", e.target.checked)
  }

  return <input type="checkbox" onChange={handleCheck} />
}
```

---

## **6. Generische Variante**

Falls man den Typ nicht kennt:

```tsx
function GenericHandler() {
  const handle = (e: React.SyntheticEvent): void => {
    console.log(e.type)
  }

  return <form onSubmit={handle}></form>
}
```

👉 Besser immer präzise statt `SyntheticEvent`.

---

### Zusammenfassung

* **`FormEvent<HTMLFormElement>`** → für `onSubmit`.
* **`ChangeEvent<HTMLInputElement>`** → Text, Checkbox, Radio.
* **`ChangeEvent<HTMLSelectElement>`** → Select.
* **`ChangeEvent<HTMLTextAreaElement>`** → Textarea.
* Faustregel: **`ChangeEvent<T>`**, wobei `T` = konkretes HTML-Element.

🔗 Quellen:

* [React TypeScript Cheatsheet – Events](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/event_handling/)
* [React Docs – Form Handling](https://react.dev/learn/managing-state#updating-state-based-on-input-fields)

  **[⬆ Наверх](#top)**

89. ### <a name="89"></a> Wie typisiert man API-Requests und Responses?

### API-Requests und -Responses typisieren (TypeScript + Fetch/Axios)

---

## 1) DTOs (Request/Response-Modelle) definieren

```js
// types.ts
export type CreateUserReq = {
  name: string
  email: string
}

export type User = {
  id: number
  name: string
  email: string
}

export type ApiError = {
  status: number
  message: string
}
```

---

## 2) `fetch`-Wrapper mit Generics (`Promise<T>`)

```js
// api.ts
export async function apiGet<T>(url: string, init?: RequestInit): Promise<T> {
  const res = await fetch(url, { ...init, method: "GET" })
  if (!res.ok) {
    throw { status: res.status, message: res.statusText } // ApiError-ähnlich
  }
  const data: unknown = await res.json()
  return data as T // besser: runtime-validate, siehe unten
}

export async function apiPost<TReq, TRes>(url: string, body: TReq, init?: RequestInit): Promise<TRes> {
  const res = await fetch(url, {
    method: "POST",
    headers: { "Content-Type": "application/json", ...(init?.headers ?? {}) },
    body: JSON.stringify(body),
    ...init
  })
  if (!res.ok) {
    throw { status: res.status, message: await res.text() }
  }
  const data: unknown = await res.json()
  return data as TRes
}
```

**Verwendung:**

```js
import { apiGet, apiPost } from "./api.js"
import type { CreateUserReq, User } from "./types.js"

const user = await apiGet<User>("/api/user/1")
const created = await apiPost<CreateUserReq, User>("/api/users", { name: "Sergii", email: "s@ex.com" })
```

---

## 3) Axios mit Generics

```js
import axios from "axios"
import type { CreateUserReq, User } from "./types.js"

export async function getUser(id: number) {
  const res = await axios.get<User>(`/api/users/${id}`)
  return res.data // User
}

export async function createUser(dto: CreateUserReq) {
  const res = await axios.post<User>("/api/users", dto)
  return res.data // User
}
```

---

## 4) Runtime-Validierung (Zod) statt blindem `as`

```js
import { z } from "zod"

export const UserSchema = z.object({
  id: z.number(),
  name: z.string(),
  email: z.string().email()
})
export type User = z.infer<typeof UserSchema>

export async function safeGetUser(id: number): Promise<User> {
  const res = await fetch(`/api/users/${id}`)
  if (!res.ok) throw new Error("HTTP " + res.status)
  const json: unknown = await res.json()
  return UserSchema.parse(json) // ✅ Laufzeit-Check + Typ
}
```

---

## 5) API-Status als Discriminated Union (für UI-States)

```js
export type ApiState<T> =
  | { status: "idle" }
  | { status: "loading" }
  | { status: "success"; data: T }
  | { status: "error"; error: string }
```

```js
import { useEffect, useState } from "react"
import type { User } from "./types.js"

export function useUser(id: number) {
  const [state, setState] = useState<ApiState<User>>({ status: "idle" })

  useEffect(() => {
    let alive = true
    setState({ status: "loading" })
    fetch(`/api/users/${id}`)
      .then(r => r.json())
      .then((j: unknown) => {
        // hier idealerweise Zod-Parse
        if (alive) setState({ status: "success", data: j as User })
      })
      .catch(e => alive && setState({ status: "error", error: String(e) }))
    return () => { alive = false }
  }, [id])

  return state
}
```

---

## 6) Pagination/Envelope-Typen

```js
export type Page<T> = {
  items: T[]
  total: number
  page: number
  pageSize: number
}

const page = await apiGet<Page<User>>("/api/users?page=1&pageSize=20")
```

---

## 7) Endpunkt-Map (sicher via `satisfies`)

```js
export const endpoints = {
  getUser: { path: (id: number) => `/api/users/${id}`, method: "GET" },
  createUser: { path: () => "/api/users", method: "POST" }
} as const satisfies Record<string, { path: (...a: any[]) => string; method: "GET" | "POST" }>
```

---

## 8) Fehler-Typen & Narrowing

```js
try {
  const data = await apiGet<User>("/api/user/1")
} catch (e) {
  const err = e as { status?: number; message?: string }
  console.error(err.status ?? 0, err.message ?? "Unknown")
}
```

---

## 9) Request-Bodies typisieren (FormData/Query)

```js
export type SearchParams = { q: string; limit?: number }

export function toQuery(params: SearchParams): string {
  const usp = new URLSearchParams()
  usp.set("q", params.q)
  if (params.limit != null) usp.set("limit", String(params.limit))
  return usp.toString()
}
```

---

### Zusammenfassung

* **DTOs** für Requests/Responses definieren; **Generics** nutzen (`apiGet<T>`, Axios `<T>`).
* Responses nie als `any` akzeptieren → **Runtime-Validation** (z. B. **Zod**) ist best practice.
* UI-Status via **Discriminated Union** modellieren.
* **Envelope-/Pagination-Typen** standardisieren; **satisfies** für Endpoint-Maps.
* Fehler konsequent typisieren und per **Narrowing** behandeln.

**Quellen:**

* [TypeScript Docs – Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
* [TypeScript Docs – Utility Types](https://www.typescriptlang.org/docs/handbook/utility-types.html)
* [React TypeScript Cheatsheet – Basic/Typing Functions & Hooks](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/)
* [MDN – Fetch API](https://developer.mozilla.org/ru/docs/Web/API/Fetch_API)
* [React Docs](https://react.dev/)

**Zusammenfassung:**
Typisierte API-Kommunikation = **Generics für Fetch/Axios**, **DTO-Typen**, **Runtime-Validation (Zod)**, **Union-Status** für UI und sauberes **Error-Handling**.


  **[⬆ Наверх](#top)**

90. ### <a name="90"></a> Wie typisiert man React-Router-Komponenten?

### React Router mit TypeScript typisieren (v6.4+)

---

## 1) `useParams`

```js
import { useParams } from "react-router-dom"

// Generics definieren NUR die Param-Namen, Werte bleiben string | undefined
type Params = { id: string }

export function UserPage() {
  const { id } = useParams<Params>() // id: string | undefined
  if (!id) return <p>Kein ID-Parameter</p>
  return <h1>User {id}</h1>
}
```

**Sicherer mit Assertion/Narrowing:**

```js
function assertString(v: unknown): asserts v is string {
  if (typeof v !== "string") throw new Error("Expected string")
}

const { id } = useParams<{ id: string }>()
assertString(id) // ab hier: id: string
```

---

## 2) `useSearchParams`

```js
import { useSearchParams } from "react-router-dom"

export function List() {
  const [sp, setSp] = useSearchParams()
  const page = Number(sp.get("page") ?? "1") // page: number
  // setSp(prev => { prev.set("page", String(page+1)); return prev })
  return <div>Seite {page}</div>
}
```

---

## 3) `useNavigate`

```js
import { useNavigate } from "react-router-dom"

export function BackButton() {
  const navigate = useNavigate()
  return <button onClick={() => navigate(-1)}>Zurück</button>
}
```

---

## 4) Route-Objekte, Loader & Actions (Data Router)

```js
import { createBrowserRouter, RouterProvider } from "react-router-dom"

type User = { id: number; name: string }

async function usersLoader(): Promise<User[]> {
  const res = await fetch("/api/users")
  return res.json() // besser mit Zod validieren
}

function Users() {
  return <UsersList />
}

const router = createBrowserRouter([
  {
    path: "/users",
    element: <Users />,
    loader: usersLoader,
  }
])

export default function App() {
  return <RouterProvider router={router} />
}
```

**Loader-Daten konsumieren:**

```js
import { useLoaderData } from "react-router-dom"

export function UsersList() {
  const users = useLoaderData() as User[] // oder: useLoaderData<User[]>()
  return <ul>{users.map(u => <li key={u.id}>{u.name}</li>)}</ul>
}
```

---

## 5) `useRouteError` (Fehler typisieren)

```js
import { isRouteErrorResponse, useRouteError } from "react-router-dom"

export function ErrorBoundary() {
  const err = useRouteError()
  if (isRouteErrorResponse(err)) {
    return <p>HTTP {err.status}: {err.statusText}</p>
  }
  return <p>Unbekannter Fehler</p>
}
```

---

## 6) `Outlet`-Context typisieren

```js
import { Outlet, useOutletContext } from "react-router-dom"

type LayoutCtx = { locale: "de" | "en" }

export function Layout() {
  const ctx: LayoutCtx = { locale: "de" }
  return <Outlet context={ctx} />
}

export function Child() {
  const { locale } = useOutletContext<LayoutCtx>()
  return <p>Sprache: {locale}</p>
}
```

---

## 7) `Link`/`NavLink` (Props sind bereits typisiert)

```js
import { Link, NavLink } from "react-router-dom"

export function Nav() {
  return (
    <nav>
      <NavLink to="/users">Users</NavLink>
      <Link to={{ pathname: "/search", search: "?q=ts" }}>Suche</Link>
    </nav>
  )
}
```

---

## 8) Routen-Definitionen als Typhilfe (optional)

```js
const routes = {
  user: (id: string) => `/users/${id}`,
  search: (q: string) => `/search?q=${encodeURIComponent(q)}`
} as const

type AppRoutes = typeof routes
// routes.user("42") // string (typsicher konstruiert)
```

---

## 9) Zod/Runtime-Validation für Param/Suchwerte (Best Practice)

```js
import { z } from "zod"
const PageSchema = z.coerce.number().int().positive().default(1)

const [sp] = useSearchParams()
const page = PageSchema.parse(sp.get("page")) // number sicher validiert
```

---

### Zusammenfassung

* `useParams<Params>`: Generics definieren Schlüssel; Werte bleiben `string | undefined` → per Assertion/Narrowing absichern.
* Data Router: Loader/Action **Rückgabewerte** typisieren und mit `useLoaderData<T>()` konsumieren.
* `useRouteError`, `useOutletContext<T>()`, `useNavigate`, `useSearchParams` sind bereits TS-typisiert.
* Für robuste Apps: **Runtime-Validation** (z. B. Zod) bei Params/Query/Loader-Daten.

**Quellen**

* [React Router Docs – TypeScript](https://reactrouter.com/en/main/guides/typescript)
* [React Offizielle Doku](https://react.dev/)
* [TypeScript Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
* [React TypeScript Cheatsheet – Router](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/react_router/)

**Zusammenfassung**
React Router in TS: Params `string | undefined`, Loader per `useLoaderData<T>`, Fehler via `useRouteError`, Outlet-Kontext mit `useOutletContext<T>()`, Query über `useSearchParams`; bei Bedarf Zod einsetzen.

  **[⬆ Наверх](#top)**  

91. ### <a name="91"></a> 



  **[⬆ Наверх](#top)**

92. ### <a name="92"></a> 



  **[⬆ Наверх](#top)**

93. ### <a name="93"></a> 



  **[⬆ Наверх](#top)**

94. ### <a name="94"></a> 



  **[⬆ Наверх](#top)**

95. ### <a name="95"></a> 



  **[⬆ Наверх](#top)**

96. ### <a name="96"></a> 



  **[⬆ Наверх](#top)**

97. ### <a name="97"></a> 



  **[⬆ Наверх](#top)**

98. ### <a name="98"></a> 



  **[⬆ Наверх](#top)**

99. ### <a name="99"></a> 



  **[⬆ Наверх](#top)**

100. ### <a name="100"></a> 



  **[⬆ Наверх](#top)**    

101. ### <a name="101"></a> 



  **[⬆ Наверх](#top)**

102. ### <a name="102"></a> 



  **[⬆ Наверх](#top)**

103. ### <a name="103"></a> 



  **[⬆ Наверх](#top)**

104. ### <a name="104"></a> 



  **[⬆ Наверх](#top)**

105. ### <a name="105"></a> 



  **[⬆ Наверх](#top)**

106. ### <a name="106"></a> 



  **[⬆ Наверх](#top)**

107. ### <a name="107"></a> 



  **[⬆ Наверх](#top)**

108. ### <a name="108"></a> 



  **[⬆ Наверх](#top)**

109. ### <a name="109"></a> 



  **[⬆ Наверх](#top)**

110. ### <a name="110"></a> 



  **[⬆ Наверх](#top)**

111. ### <a name="111"></a> 



  **[⬆ Наверх](#top)**

112. ### <a name="112"></a> 



  **[⬆ Наверх](#top)**

113. ### <a name="113"></a> 



  **[⬆ Наверх](#top)**

114. ### <a name="114"></a> 



  **[⬆ Наверх](#top)**

115. ### <a name="115"></a> 



  **[⬆ Наверх](#top)**

116. ### <a name="116"></a> 



  **[⬆ Наверх](#top)**

117. ### <a name="117"></a> 



  **[⬆ Наверх](#top)**

118. ### <a name="118"></a> 



  **[⬆ Наверх](#top)**

119. ### <a name="119"></a> 



  **[⬆ Наверх](#top)**

120. ### <a name="120"></a> 



  **[⬆ Наверх](#top)**

121. ### <a name="121"></a> 



  **[⬆ Наверх](#top)**

122. ### <a name="122"></a> 



  **[⬆ Наверх](#top)**

123. ### <a name="123"></a> 



  **[⬆ Наверх](#top)**

124. ### <a name="124"></a> 



  **[⬆ Наверх](#top)**

125. ### <a name="125"></a> 



  **[⬆ Наверх](#top)**

126. ### <a name="126"></a> 



  **[⬆ Наверх](#top)**

127. ### <a name="127"></a> 



  **[⬆ Наверх](#top)**

128. ### <a name="128"></a> 



  **[⬆ Наверх](#top)**

129. ### <a name="129"></a> 



  **[⬆ Наверх](#top)**

130. ### <a name="130"></a> 



  **[⬆ Наверх](#top)**  

131. ### <a name="131"></a> 



  **[⬆ Наверх](#top)**

132. ### <a name="132"></a> 



  **[⬆ Наверх](#top)**

133. ### <a name="133"></a> 



  **[⬆ Наверх](#top)**

134. ### <a name="134"></a> 



  **[⬆ Наверх](#top)**

135. ### <a name="135"></a> 



  **[⬆ Наверх](#top)**

136. ### <a name="136"></a> 



  **[⬆ Наверх](#top)**

137. ### <a name="137"></a> 



  **[⬆ Наверх](#top)**

138. ### <a name="138"></a> 



  **[⬆ Наверх](#top)**

139. ### <a name="139"></a> 



  **[⬆ Наверх](#top)**

140. ### <a name="140"></a> 



  **[⬆ Наверх](#top)**  

141. ### <a name="141"></a> 



  **[⬆ Наверх](#top)**

142. ### <a name="142"></a> 



  **[⬆ Наверх](#top)**

143. ### <a name="143"></a> 



  **[⬆ Наверх](#top)**

144. ### <a name="144"></a> 



  **[⬆ Наверх](#top)**

145. ### <a name="145"></a> 



  **[⬆ Наверх](#top)**

146. ### <a name="146"></a> 



  **[⬆ Наверх](#top)**

147. ### <a name="147"></a> 



  **[⬆ Наверх](#top)**

148. ### <a name="148"></a> 



  **[⬆ Наверх](#top)**

149. ### <a name="149"></a> 



  **[⬆ Наверх](#top)**

150. ### <a name="150"></a> 



  **[⬆ Наверх](#top)**  

151. ### <a name="151"></a> 



  **[⬆ Наверх](#top)**

152. ### <a name="152"></a> 



  **[⬆ Наверх](#top)**

153. ### <a name="153"></a> 



  **[⬆ Наверх](#top)**

154. ### <a name="154"></a> 



  **[⬆ Наверх](#top)**

155. ### <a name="155"></a> 



  **[⬆ Наверх](#top)**

156. ### <a name="156"></a> 



  **[⬆ Наверх](#top)**

157. ### <a name="157"></a> 



  **[⬆ Наверх](#top)**

158. ### <a name="158"></a> 



  **[⬆ Наверх](#top)**

159. ### <a name="159"></a> 



  **[⬆ Наверх](#top)**

160. ### <a name="160"></a> 



  **[⬆ Наверх](#top)**

161. ### <a name="161"></a> 



  **[⬆ Наверх](#top)**

162. ### <a name="162"></a> 



  **[⬆ Наверх](#top)**

163. ### <a name="163"></a> 



  **[⬆ Наверх](#top)**

164. ### <a name="164"></a> 



  **[⬆ Наверх](#top)**

165. ### <a name="165"></a> 



  **[⬆ Наверх](#top)**

166. ### <a name="166"></a> 



  **[⬆ Наверх](#top)**

167. ### <a name="167"></a> 



  **[⬆ Наверх](#top)**

168. ### <a name="168"></a> 



  **[⬆ Наверх](#top)**

169. ### <a name="169"></a> 



  **[⬆ Наверх](#top)**

170. ### <a name="170"></a> 



  **[⬆ Наверх](#top)**

171. ### <a name="171"></a> 



  **[⬆ Наверх](#top)**

172. ### <a name="172"></a> 



  **[⬆ Наверх](#top)**

173. ### <a name="173"></a> 



  **[⬆ Наверх](#top)**

174. ### <a name="174"></a> 



  **[⬆ Наверх](#top)**

175. ### <a name="175"></a> 



  **[⬆ Наверх](#top)**

176. ### <a name="176"></a> 



  **[⬆ Наверх](#top)**

177. ### <a name="177"></a> 



  **[⬆ Наверх](#top)**

178. ### <a name="178"></a> 



  **[⬆ Наверх](#top)**

179. ### <a name="179"></a> 



  **[⬆ Наверх](#top)**

180. ### <a name="180"></a> 



  **[⬆ Наверх](#top)**  

181. ### <a name="181"></a> 



  **[⬆ Наверх](#top)**

182. ### <a name="182"></a> 



  **[⬆ Наверх](#top)**

183. ### <a name="183"></a> 



  **[⬆ Наверх](#top)**

184. ### <a name="184"></a> 



  **[⬆ Наверх](#top)**

185. ### <a name="185"></a> 



  **[⬆ Наверх](#top)**

186. ### <a name="186"></a> 



  **[⬆ Наверх](#top)**

187. ### <a name="187"></a> 



  **[⬆ Наверх](#top)**

188. ### <a name="188"></a> 



  **[⬆ Наверх](#top)**

189. ### <a name="189"></a> 



  **[⬆ Наверх](#top)**

190. ### <a name="190"></a> 



  **[⬆ Наверх](#top)**  

191. ### <a name="191"></a> 



  **[⬆ Наверх](#top)**

192. ### <a name="192"></a> 



  **[⬆ Наверх](#top)**

193. ### <a name="193"></a> 



  **[⬆ Наверх](#top)**

194. ### <a name="194"></a> 



  **[⬆ Наверх](#top)**

195. ### <a name="195"></a> 



  **[⬆ Наверх](#top)**

196. ### <a name="196"></a> 



  **[⬆ Наверх](#top)**

197. ### <a name="197"></a> 



  **[⬆ Наверх](#top)**

198. ### <a name="198"></a> 



  **[⬆ Наверх](#top)**

199. ### <a name="199"></a> 



  **[⬆ Наверх](#top)**

200. ### <a name="200"></a> 



  **[⬆ Наверх](#top)**      
