<a name="top"></a>

[На главную](../../README.md)

[Перейти к вопросам](#questions)

| №. | Вопрос |
| --- | --------- |
|   | TypeScript — Grundlagen |
|1 | [Was ist TypeScript und wie unterscheidet es sich von JavaScript?](#1) |
|2 | [Welche Vorteile bietet die Verwendung von TypeScript?](#2) |
|3 | [Was ist Typisierung (static typing)?](#3) |
|4 | [Welche grundlegenden Typen gibt es in TypeScript?](#4) |
|5 | [Worin besteht der Unterschied zwischen any und unknown?](#5) |
|6 | [Was ist never und wann wird es verwendet?](#6) |
|7 | [Was ist der Unterschied zwischen null und undefined?](#7) |
|8 | [Was ist void?](#8) |
|9 | [Was sind Union Types? Gib ein Beispiel.](#9) |
|10 | [Was sind Intersection Types? Gib ein Beispiel.](#10) |
|11 | [Was sind Literal Types?](#11) |
|12 | [Wie funktioniert type inference in TypeScript?](#12) |
|13 | [Was ist ein Type Alias (type) und wie unterscheidet er sich von interface?](#13) |
|14 | [Was ist der Unterschied zwischen interface und type?](#14) |
|15 | [Kann man Interfaces zusammenführen (extend)?](#15) |
|16 | [Was sind optionale Eigenschaften in Interfaces?](#16) |
|17 | [Wie deklariert man readonly-Eigenschaften?](#17) |
|18 | [Was sind Tupel (tuples) in TypeScript?](#18) |
|19 | [Was ist ein Enum und wann sollte man es verwenden?](#19) |
|20 | [Was ist der Unterschied zwischen const enum und einem normalen enum?](#20) |
|21 | [Was ist Type Narrowing (Typschränkung)?](#21) |
|22 | [Was sind Type Guards? Gib ein Beispiel.](#22) |
|23 | [Wie funktioniert der Operator in bei der Typprüfung?](#23) |
|24 | [Wie funktioniert typeof in TypeScript?](#24) |
|25 | [Wie funktioniert instanceof?](#25) |
|26 | [Was sind Discriminated Unions (diskriminierte Typen)?](#26) |
|27 | [Was ist der Unterschied zwischen interface und abstract class?](#27) |
|28 | [Wie implementiert man Funktionsüberladungen (function overloads) in TypeScript?](#28) |
|29 | [Was sind Index Signatures?](#29) |
|30 | [Was ist keyof und wofür wird es verwendet?](#30) |
|31 | [Wie funktioniert der Operator as?](#31) |
|32 | [Was ist der Unterschied zwischen as const und einem normalen const?](#32) |
|33 | [Was macht der Operator satisfies (TS 4.9+)?](#33) |
|34 | [Was sind Assertion Functions?](#34) |
|35 | [Was ist der Unterschied zwischen struktureller Typisierung (structural typing) und nominaler Typisierung (nominal typing)?](#35) |
|36 | [Was sind Deklarationsdateien (.d.ts)?](#36) |
|37 | [Wie bindet man eine externe JS-Bibliothek ohne Typen ein?](#37) |
|38 | [Was sind Ambient Declarations (declare)?](#38) |
|39 | [Was ist strict mode in TypeScript?](#39) |
|40 | [Wozu dient strictNullChecks?](#40) |
|   | TypeScript — Funktionen und Generics |
|41 | [Wie typisiert man Parameter und Rückgabewerte von Funktionen?](#41) |
|42 | [Was sind optionale Parameter in Funktionen?](#42) |
|43 | [Wie deklariert man Standardwerte für Parameter mit Typisierung?](#43) |
|44 | [Was sind Rest-Parameter und wie typisiert man sie?](#44) |
|45 | [Wie typisiert man Arrow Functions?](#45) |
|46 | [Was sind Funktionsüberladungen?](#46) |
|47 | [Was sind Generics?](#47) |
|48 | [Wie erstellt man eine generische Funktion?](#48) |
|49 | [Was sind Generic Constraints (extends)?](#49) |
|50 | [Wie funktioniert T extends keyof U?](#50) |
|51 | [Was sind Utility Types (Partial, Pick, Omit, Record usw.)?](#51) |
|52 | [Was ist der Unterschied zwischen Partial<T> und Required<T>?](#52) |
|53 | [Wie funktioniert Readonly<T>?](#53) |
|54 | [Wie funktionieren Pick<T, K> und Omit<T, K>?](#54) |
|55 | [Was macht Record<K, T>?](#55) |
|56 | [Was macht ReturnType<T>?](#56) |
|57 | [Was macht Parameters<T>?](#57) |
|58 | [Was macht ConstructorParameters<T>?](#58) |
|59 | [Wie funktionieren Extract und Exclude?](#59) |
|60 | [Was macht NonNullable<T>?](#60) |
|   | TypeScript — Klassen und OOP |
|61 | [Wie deklariert man eine Klasse in TypeScript?](#61) |
|62 | [Was sind Zugriffsmodifikatoren (public, private, protected)?](#62) |
|63 | [Was sind readonly-Eigenschaften in Klassen?](#63) |
|64 | [Wie deklariert man statische Eigenschaften und Methoden?](#64) |
|65 | [Was ist der Unterschied zwischen einer abstrakten und einer normalen Klasse?](#65) |
|66 | [Kann man Interfaces mit Klassen implementieren?](#66) |
|67 | [Was ist der Unterschied zwischen implements und extends?](#67) |
|68 | [Was ist this und wie typisiert man es?](#68) |
|69 | [Kann man generische Klassen erstellen?](#69) |
|   | React + TypeScript — Grundlagen |
|70 | [Wie erstellt man ein React-Projekt mit TypeScript?](#70) |
|71 | [Wie typisiert man eine React-Komponente (FC)?](#71) |
|72 | [Was ist React.FC und wann sollte man es vermeiden?](#72) |
|73 | [Wie typisiert man Props in einer React-Komponente?](#73) |
|74 | [Wie typisiert man optionale Props?](#74) |
|75 | [Wie deklariert man Default Props in TypeScript?](#75) |
|76 | [Wie typisiert man children in React-Komponenten?](#76) |
|77 | [Was ist der Unterschied zwischen ReactNode, JSX.Element und ReactElement?](#77) |
|78 | [Wie typisiert man Events (z. B. onClick, onChange)?](#78) |
|79 | [Wie typisiert man Refs in React?](#79) |
|80 | [Wie typisiert man State mit useState?](#80) |
|81 | [Wie typisiert man useReducer?](#81) |
|82 | [Wie typisiert man useRef mit initial null?](#82) |
|83 | [Wie typisiert man einen Custom Hook?](#83) |
|84 | [Wie typisiert man Komponenten mit forwardRef?](#84) |
|85 | [Wie typisiert man Context (React Context API)?](#85) |
|86 | [Wie typisiert man HOCs (Higher-Order Components)?](#86) |
|87 | [Wie typisiert man asynchrone Funktionen in React-Komponenten?](#87) |
|88 | [Wie typisiert man Event-Handler in Formularen?](#88) |
|89 | [Wie typisiert man API-Requests und Responses?](#89) |
|90 | [Wie typisiert man React-Router-Komponenten?](#90) |
|   | React + TypeScript — Praxis und Architektur |
|91 | [Wie organisiert man Typen für ein gesamtes Projekt?](#91) |
|92 | [Wo speichert man gemeinsame Typen (z. B. User, Product)?](#92) |
|93 | [Wie typisiert man den globalen Store (Redux/RTK)?](#93) |
|94 | [Wie typisiert man Actions und Reducer im Redux Toolkit?](#94) |
|95 | [Wie typisiert man useSelector und useDispatch?](#95) |
|96 | [Wie typisiert man einen Zustand-Store (Zustand)?](#96) |
|97 | [Wie typisiert man Async Thunks?](#97) |
|98 | [Wie typisiert man Query Hooks in RTK Query?](#98) |
|99 | [Wie verwendet man Enums für Redux-Actions?](#99) |
|100 | [Wie typisiert man Formulare mit React Hook Form?](#100) |
|101 | [Wie typisiert man axios-Requests?](#101) |
|102 | [Wie typisiert man fetch-Requests mit Generics?](#102) |
|103 | [Wie geht man mit Typen bei API-Fehlern um?](#103) |
|104 | [Wie verwendet man Utility Types für API-Modelle?](#104) |
|105 | [Wie typisiert man Dynamic Imports in React?](#105) |
|106 | [Wie verwendet man keyof für dynamische Eigenschaften in Komponenten?](#106) |
|107 | [Wie erstellt man typsichere Styles (z. B. mit styled-components)?](#107) |
|108 | [Wie typisiert man Props für Bibliothekskomponenten (z. B. Material UI)?](#108) |
|109 | [Wie typisiert man React.memo?](#109) |
|110 | [Wie typisiert man React.lazy und Suspense?](#110) |
|   | Fragen auf Middle-Level |
|111 | [Wie verwendet man Conditional Types (T extends U ? X : Y)?](#111) |
|112 | [Was sind Mapped Types?](#112) |
|113 | [Wie funktionieren Template Literal Types?](#113) |
|114 | [Was ist infer?](#114) |
|115 | [Wie schreibt man eigene Utility Types?](#115) |
|116 | [Wie kombiniert man mehrere Generics?](#116) |
|117 | [Was sind polymorphe Komponenten in React?](#117) |
|118 | [Wie erstellt man eine generische React-Komponente?](#118) |
|119 | [Wie verbindet man Generics in Props und State?](#119) |
|120 | [Wie stellt man vollständige Typsicherheit bei der Arbeit mit APIs sicher?](#120) |
|121 | [](#121) |
|122 | [](#122) |
|123 | [](#123) |
|124 | [](#124) |
|125 | [](#125) |
|126 | [](#126) |
|127 | [](#127) |
|128 | [](#128) |
|129 | [](#129) |
|130 | [](#130) |
|131 | [](#131) |
|132 | [](#132) |
|133 | [](#133) |
|134 | [](#134) |
|135 | [](#135) |
|136 | [](#136) |
|137 | [](#137) |
|138 | [](#138) |
|139 | [](#139) |
|140 | [](#140) |
|141 | [](#141) |
|142 | [](#142) |
|143 | [](#143) |
|144 | [](#144) |
|145 | [](#145) |
|146 | [](#146) |
|147 | [](#147) |
|148 | [](#148) |
|149 | [](#149) |
|150 | [](#150) |
|151 | [](#151) |
|152 | [](#152) |
|153 | [](#153) |
|154 | [](#154) |
|155 | [](#155) |
|156 | [](#156) |
|157 | [](#157) |
|158 | [](#158) |
|159 | [](#159) |
|160 | [](#160) |
|161 | [](#161) |
|162 | [](#162) |
|163 | [](#163) |
|164 | [](#164) |
|165 | [](#165) |
|166 | [](#166) |
|167 | [](#167) |
|168 | [](#168) |
|169 | [](#169) |
|170 | [](#170) |
|171 | [](#171) |
|172 | [](#172) |
|173 | [](#173) |
|174 | [](#174) |
|175 | [](#175) |
|176 | [](#176) |
|177 | [](#177) |
|178 | [](#178) |
|179 | [](#179) |
|180 | [](#180) |
|181 | [](#181) |
|182 | [](#182) |
|183 | [](#183) |
|184 | [](#184) |
|185 | [](#185) |
|186 | [](#186) |
|187 | [](#187) |
|188 | [](#188) |
|189 | [](#189) |
|190 | [](#190) |
|191 | [](#191) |
|192 | [](#192) |
|193 | [](#193) |
|194 | [](#194) |
|195 | [](#195) |
|196 | [](#196) |
|197 | [](#197) |
|198 | [](#198) |
|199 | [](#199) |
|200 | [](#200) |



<a name="questions"></a>

## ReactJS 

  **[⬆ Наверх](#top)**
  
1. ### <a name="1"></a> Was ist TypeScript und wie unterscheidet es sich von JavaScript?

**TypeScript** ist eine von Microsoft entwickelte Programmiersprache, die auf **JavaScript** basiert und dieses um **statische Typisierung** erweitert. Jeder gültige JavaScript-Code ist auch gültiger TypeScript-Code.

### Hauptunterschiede zu JavaScript

1. **Statische Typisierung**

   * In JavaScript sind Variablen dynamisch typisiert.
   * In TypeScript kann man Typen explizit angeben, was Fehler schon während der Entwicklung verhindert.

   ```js
   // JavaScript (dynamisch, Fehler erst zur Laufzeit möglich)
   let name = "Sergii"
   name = 42 // kein Fehler beim Schreiben, nur Laufzeitproblem

   // TypeScript (statisch, Fehler beim Kompilieren)
   let name: string = "Sergii"
   name = 42 // ❌ Fehler: Type 'number' is not assignable to type 'string'
   ```

2. **Typinferenz**

   * TypeScript erkennt oft automatisch den Typ einer Variable.

   ```js
   let age = 33 // Typ: number (automatisch erkannt)
   ```

3. **Erweiterte Features**

   * Interfaces, Enums, Generics, Union- und Intersection-Types, Utility-Types.

   ```js
   interface User {
     id: number
     name: string
   }

   const user: User = { id: 1, name: "Sergii" }
   ```

4. **Kompilierung**

   * TypeScript wird in **JavaScript** transpiliert (mittels `tsc` oder Bundler wie Vite/Webpack).
   * Läuft nicht direkt im Browser, sondern wird vorher in JavaScript konvertiert.

5. **Entwicklerfreundlichkeit**

   * Bessere **IntelliSense**, Autovervollständigung und Fehlererkennung in IDEs.

---

### Zusammenfassung

* **JavaScript**: dynamisch typisiert, direkt im Browser lauffähig.
* **TypeScript**: superset von JavaScript mit **statischer Typisierung** und zusätzlichen Features; erfordert Transpilation.
* Vorteil: Weniger Laufzeitfehler, besserer Code-Support.

🔗 Quellen:

* [TypeScript: What is TypeScript?](https://www.typescriptlang.org/docs/handbook/intro.html)
* [React TypeScript Cheatsheet: Setup](https://react-typescript-cheatsheet.netlify.app/docs/basic/setup)

  **[⬆ Наверх](#top)**

2. ### <a name="2"></a> Welche Vorteile bietet die Verwendung von TypeScript?

### Vorteile von TypeScript

1. **Frühe Fehlererkennung**

   * Typfehler werden bereits beim Kompilieren gefunden, bevor der Code ausgeführt wird.

   ```js
   let price: number = 50
   price = "fünfzig" // ❌ Fehler beim Kompilieren
   ```

2. **Bessere Entwicklererfahrung (DX)**

   * IntelliSense, Autovervollständigung, Hover-Infos und Refactoring sind präziser.

3. **Klarheit und Wartbarkeit**

   * Durch Typannotationen und Interfaces ist der Code selbstdokumentierend.

   ```js
   interface Product {
     id: number
     name: string
     price: number
   }
   ```

4. **Skalierbarkeit**

   * Besonders nützlich in großen Projekten mit vielen Entwicklern.
   * Änderungen sind sicherer, da Typen sofort Konflikte zeigen.

5. **Moderne Features**

   * Unterstützung von Generics, Union/Intersection Types, Enums, Utility-Types.

   ```js
   function wrapValue<T>(value: T): T[] {
     return [value]
   }
   const result = wrapValue<string>("Hallo") // result: string[]
   ```

6. **Kompatibilität mit JavaScript**

   * Jeder JS-Code läuft auch in TS.
   * Migration von bestehenden Projekten möglich (schrittweise Einführung).

---

### Zusammenfassung

* **TypeScript** bringt Typensicherheit, bessere Entwickler-Tools, klareren und wartbareren Code, Skalierbarkeit in großen Projekten und moderne Sprachfeatures.
* Besonders vorteilhaft bei **langfristigen, komplexen Projekten** mit mehreren Teammitgliedern.

🔗 Quellen:

* [TypeScript Handbook – Why TypeScript](https://www.typescriptlang.org/docs/handbook/2/basic-types.html)
* [React TypeScript Cheatsheet – Vorteile](https://react-typescript-cheatsheet.netlify.app/docs/basic/setup)

  **[⬆ Наверх](#top)**

3. ### <a name="3"></a> Was ist Typisierung (static typing)?

### Typisierung (Static Typing)

**Definition:**
Statische Typisierung bedeutet, dass der Datentyp einer Variable oder Funktion **zur Compile-Zeit** festgelegt wird und nicht erst zur Laufzeit.

### Merkmale

1. **Fester Typ während der gesamten Lebenszeit**

   * Eine Variable behält den einmal festgelegten Typ.
   * Zuweisungen anderer Typen führen zu einem Kompilierungsfehler.

   ```js
   let username: string = "Sergii"
   username = 42 // ❌ Fehler: number ist nicht string
   ```

2. **Frühe Fehlererkennung**

   * Tippfehler oder falsche Funktionsaufrufe werden direkt angezeigt.

   ```js
   function add(a: number, b: number): number {
     return a + b
   }

   add(5, "10") // ❌ Fehler: Argument vom Typ 'string' ist nicht zuweisbar
   ```

3. **Verbesserte Autovervollständigung und Dokumentation**

   * IDEs können anhand der Typen Vorschläge und Hilfen anzeigen.

4. **Generics und komplexe Typen**

   * Flexible, aber dennoch sichere Strukturen möglich.

   ```js
   function identity<T>(value: T): T {
     return value
   }
   const result = identity<number>(10) // Typ: number
   ```

---

### Unterschied zu dynamischer Typisierung (JavaScript)

* **Dynamisch:** Typen werden erst zur Laufzeit geprüft.
* **Statisch:** Typen werden bereits vor der Ausführung geprüft.

---

### Zusammenfassung

* **Static Typing** = feste Typprüfung während der Kompilierung.
* Vorteile: weniger Laufzeitfehler, klarer Code, bessere Tool-Unterstützung.
* In TypeScript zwingend (mit Ausnahmen wie `any`), in JavaScript nicht vorhanden.

🔗 Quellen:

* [TypeScript Handbook – Basic Types](https://www.typescriptlang.org/docs/handbook/2/basic-types.html)
* [MDN – JavaScript Datentypen](https://developer.mozilla.org/ru/docs/Web/JavaScript/Data_structures)

  **[⬆ Наверх](#top)**

4. ### <a name="4"></a> Welche grundlegenden Typen gibt es in TypeScript?

### Grundlegende Typen in TypeScript

TypeScript erweitert JavaScript um **statische Typisierung**. Die wichtigsten **Basis-Typen** sind:

---

#### 1. **Primitives**

* **string**

  ```js
  let username: string = "Sergii"
  ```
* **number** (Ganzzahlen & Fließkommazahlen)

  ```js
  let age: number = 34
  ```
* **boolean**

  ```js
  let isOnline: boolean = true
  ```
* **null** und **undefined**

  ```js
  let value: null = null
  let notAssigned: undefined = undefined
  ```
* **bigint** (für sehr große Zahlen)

  ```js
  let big: bigint = 9007199254740991n
  ```
* **symbol** (einzigartige Werte)

  ```js
  let uniqueId: symbol = Symbol("id")
  ```

---

#### 2. **Arrays**

```js
let numbers: number[] = [1, 2, 3]
let names: Array<string> = ["Anna", "Tom"] // Generics-Schreibweise
```

---

#### 3. **Tuples**

* Feste Anzahl von Elementen mit festen Typen.

```js
let person: [string, number] = ["Sergii", 34]
```

---

#### 4. **Enums**

* Sammlung von benannten Konstanten.

```js
enum Role {
  Admin,
  User,
  Guest
}

let currentRole: Role = Role.Admin
```

---

#### 5. **Any**

* Deaktiviert Typprüfung (sollte vermieden werden).

```js
let data: any = 5
data = "Text"
```

---

#### 6. **Unknown**

* Sicherere Alternative zu `any`, erfordert Typprüfung vor Verwendung.

```js
let value: unknown = "Hallo"

if (typeof value === "string") {
  console.log(value.toUpperCase())
}
```

---

#### 7. **Void**

* Wird für Funktionen verwendet, die nichts zurückgeben.

```js
function logMessage(message: string): void {
  console.log(message)
}
```

---

#### 8. **Never**

* Für Funktionen, die niemals einen Wert zurückgeben (z. B. Fehler werfen).

```js
function throwError(msg: string): never {
  throw new Error(msg)
}
```

---

### Zusammenfassung

* **Primitive Typen**: string, number, boolean, null, undefined, bigint, symbol
* **Spezielle Typen**: any, unknown, void, never
* **Strukturierte Typen**: arrays, tuples, enums

🔗 Quellen:

* [TypeScript Handbook – Basic Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html)
* [React TypeScript Cheatsheet – Basic Setup](https://react-typescript-cheatsheet.netlify.app/docs/basic/setup)

  **[⬆ Наверх](#top)**

5. ### <a name="5"></a> Worin besteht der Unterschied zwischen any und unknown?

### Unterschied zwischen `any` und `unknown`

#### **1. `any`**

* Deaktiviert **jegliche Typprüfung**.
* Man kann jede Operation auf `any` ausführen, ohne Fehler beim Kompilieren.
* Gefahr: Laufzeitfehler, da TypeScript keine Sicherheit bietet.

```js
let value: any = "Hallo"
value = 123
value.toUpperCase() // ✅ Kein Fehler beim Kompilieren, aber Laufzeitfehler möglich
```

---

#### **2. `unknown`**

* Ist ein **sicherer Gegenspieler zu `any`**.
* Man kann einen Wert vom Typ `unknown` nicht direkt verwenden, ohne ihn vorher zu prüfen oder zu casten.
* Erzwingt **Type-Safety** durch Typabfragen.

```js
let input: unknown = "Hallo"

// ❌ Direkt nicht erlaubt
// input.toUpperCase()

// ✅ Mit Typprüfung
if (typeof input === "string") {
  console.log(input.toUpperCase())
}
```

---

#### **Vergleich**

| Merkmal            | `any`                 | `unknown`                            |
| ------------------ | --------------------- | ------------------------------------ |
| Typprüfung         | Keine                 | Erforderlich                         |
| Sicherheit         | Niedrig               | Hoch                                 |
| Nutzungsempfehlung | Nur in Ausnahmefällen | Besser als `any` für unsichere Werte |

---

### Zusammenfassung

* **`any`**: erlaubt alles, keine Typprüfung → unsicher.
* **`unknown`**: erfordert Typprüfung oder Casting → sicherer, bevorzugt für unbekannte Werte (z. B. API-Response).

🔗 Quellen:

* [TypeScript Handbook – unknown](https://www.typescriptlang.org/docs/handbook/2/functions.html#unknown)
* [React TypeScript Cheatsheet – any vs. unknown](https://react-typescript-cheatsheet.netlify.app/docs/basic/troubleshooting/types)

  **[⬆ Наверх](#top)**

6. ### <a name="6"></a> Was ist never und wann wird es verwendet?

### `never` in TypeScript

**Definition:**
`never` ist ein spezieller Typ für Werte, die **niemals existieren können**.
Eine Funktion oder ein Ausdruck vom Typ `never` beendet entweder den Programmfluss (z. B. durch einen Fehler) oder läuft unendlich weiter.

---

### Anwendungsfälle

#### 1. **Funktionen, die immer Fehler werfen**

```js
function throwError(message: string): never {
  throw new Error(message)
}
```

* Rückgabewert: niemals erreichbar, da die Funktion das Programm mit einem Fehler abbricht.

---

#### 2. **Endlose Schleifen**

```js
function infiniteLoop(): never {
  while (true) {
    console.log("läuft ewig...")
  }
}
```

* Die Funktion verlässt nie die Schleife → daher `never`.

---

#### 3. **Exhaustiveness Checking** (Typprüfung bei `switch` / `if-else`)

* `never` wird verwendet, um sicherzustellen, dass alle möglichen Fälle abgedeckt sind.

```js
type Shape = "circle" | "square"

function getArea(shape: Shape): number {
  switch (shape) {
    case "circle":
      return Math.PI * 10 ** 2
    case "square":
      return 10 * 10
    default:
      const exhaustiveCheck: never = shape
      return exhaustiveCheck
  }
}
```

* Vorteil: Falls später ein neuer Typ (`"triangle"`) hinzugefügt wird, zeigt TypeScript einen Fehler an, solange er nicht im `switch` behandelt wird.

---

### Unterschied zu `void`

* **`void`**: Funktion gibt keinen **Wert** zurück.
* **`never`**: Funktion gibt **nie** etwas zurück (nicht mal `undefined`).

---

### Zusammenfassung

* **`never`** = Typ für Werte, die nie vorkommen können.
* Typische Nutzung: Funktionen, die Fehler werfen, unendliche Schleifen oder Exhaustiveness Checking.
* Unterschied zu `void`: `void` = kein Rückgabewert, `never` = niemals Rückgabe.

🔗 Quellen:

* [TypeScript Handbook – never](https://www.typescriptlang.org/docs/handbook/2/functions.html#never)
* [MDN – JavaScript Error](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Error)

  **[⬆ Наверх](#top)**

7. ### <a name="7"></a> Was ist der Unterschied zwischen null und undefined?

### Unterschied zwischen `null` und `undefined` in TypeScript / JavaScript

#### **1. `undefined`**

* Automatischer Standardwert für nicht initialisierte Variablen oder fehlende Eigenschaften.
* Bedeutet: *"nicht zugewiesen"*.

```js
let a
console.log(a) // undefined

const obj = {}
console.log(obj.prop) // undefined
```

---

#### **2. `null`**

* Wird explizit vom Entwickler gesetzt.
* Bedeutet: *"absichtlich leer / kein Wert"*.

```js
let b: string | null = null
console.log(b) // null
```

---

#### **3. Vergleich**

```js
console.log(null == undefined)  // true  (lockerer Vergleich)
console.log(null === undefined) // false (strenger Vergleich)
```

---

#### **4. In TypeScript**

* `undefined` und `null` sind eigene Typen.
* Standardmäßig sind sie **Zuweisungen an andere Typen erlaubt** (abhängig von `--strictNullChecks`).

```js
let x: string | null = null   // erlaubt
let y: string | undefined     // muss initialisiert oder geprüft werden
```

---

#### **5. Typische Verwendung**

* **`undefined`**: vom System vergeben, wenn nichts zugewiesen wurde.
* **`null`**: vom Entwickler gesetzt, um „keinen Wert“ darzustellen.

---

### Zusammenfassung

* **`undefined`** = Wert fehlt automatisch (nicht initialisiert, nicht vorhanden).
* **`null`** = Wert wurde absichtlich auf „kein Wert“ gesetzt.
* Unterschied deutlich machen mit `===`: `null !== undefined`.

🔗 Quellen:

* [TypeScript Handbook – Everyday Types: null & undefined](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#null-and-undefined)
* [MDN – null](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/null)
* [MDN – undefined](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/undefined)

  **[⬆ Наверх](#top)**

8. ### <a name="8"></a> Was ist void?

### `void` in TypeScript

**Definition:**
`void` ist ein spezieller Typ in TypeScript, der bedeutet, dass eine Funktion **keinen Rückgabewert** hat.

---

### Anwendungsfälle

#### 1. **Funktion ohne Rückgabewert**

```js
function logMessage(message: string): void {
  console.log(message)
}

const result = logMessage("Hallo")
// result hat den Typ void → es wird nichts zurückgegeben
```

---

#### 2. **Callbacks, die nichts zurückgeben**

```js
function forEachItem(items: string[], callback: (item: string) => void) {
  for (const item of items) {
    callback(item)
  }
}

forEachItem(["A", "B"], (el) => console.log(el))
```

---

#### 3. **Unterschied zu `undefined`**

* `void` ≠ `undefined`, auch wenn Funktionen implizit `undefined` zurückgeben.
* Mit `void` sagt man ausdrücklich: *„Kein Rückgabewert ist relevant“*.

```js
function test(): void {
  return // erlaubt, implizit undefined
}

function test2(): undefined {
  return undefined // nur explizit erlaubt
}
```

---

#### 4. **Besonderheit bei Promises**

* `Promise<void>` → Funktion gibt ein Promise zurück, dessen Wert nicht benutzt werden soll.

```js
async function saveData(): Promise<void> {
  await fetch("/api/save")
}
```

---

### Zusammenfassung

* **`void`** kennzeichnet Funktionen ohne Rückgabewert.
* Typischer Einsatz: `console.log`, Event-Handler, Callbacks.
* Unterschied zu `undefined`: `void` betont die Abwesenheit eines Rückgabewerts, `undefined` ist ein Wert selbst.

🔗 Quellen:

* [TypeScript Handbook – void](https://www.typescriptlang.org/docs/handbook/2/functions.html#void)
* [React TS Cheatsheet – void in Callbacks](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/event-handling/)

  **[⬆ Наверх](#top)**

9. ### <a name="9"></a> Was sind Union Types? Gib ein Beispiel.

### Union Types in TypeScript

**Definition:**
Ein **Union Type** erlaubt es, dass eine Variable oder ein Parameter **mehrere mögliche Typen** haben kann. Er wird mit dem **`|`-Operator** geschrieben.

---

### Beispiel 1 – Variable mit mehreren Typen

```js
let id: string | number

id = 42      // ✅ erlaubt
id = "abc"   // ✅ erlaubt
id = true    // ❌ Fehler: boolean nicht erlaubt
```

---

### Beispiel 2 – Funktion mit Union Types

```js
function printId(id: string | number): void {
  if (typeof id === "string") {
    console.log("ID als Text:", id.toUpperCase())
  } else {
    console.log("ID als Zahl:", id.toFixed(2))
  }
}

printId("abc") // ID als Text: ABC
printId(123.456) // ID als Zahl: 123.46
```

---

### Beispiel 3 – Union in Arrays

```js
let values: (string | number)[] = [1, "zwei", 3, "vier"]
```

---

### Zusammenfassung

* **Union Types** = Typen, die **mehrere mögliche Werte** annehmen können.
* Verwendung: `string | number`, `(string | number)[]`.
* Nützlich für Werte mit mehreren erlaubten Formen (z. B. API-Response: `string | null`).

🔗 Quellen:

* [TypeScript Handbook – Union Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types)
* [React TypeScript Cheatsheet – Union Types](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example)

  **[⬆ Наверх](#top)**

10. ### <a name="10"></a> Was sind Intersection Types? Gib ein Beispiel.

### Intersection Types in TypeScript

**Definition:**
Ein **Intersection Type** (`&`) kombiniert mehrere Typen zu einem **neuen Typ**, der **alle Eigenschaften** der beteiligten Typen enthalten muss.
→ Während `Union (|)` **entweder-oder** bedeutet, ist `Intersection (&)` ein **sowohl-als-auch**.

---

### Beispiel 1 – Kombination von Interfaces

```js
interface Person {
  name: string
}

interface Employee {
  company: string
}

type EmployeePerson = Person & Employee

const worker: EmployeePerson = {
  name: "Sergii",
  company: "Tech GmbH"
}
```

---

### Beispiel 2 – Kombination von Typen

```js
type A = { x: number }
type B = { y: number }

type AB = A & B

const point: AB = { x: 10, y: 20 } // Muss beide Eigenschaften haben
```

---

### Beispiel 3 – Praktisch in Generics

```js
function merge<T, U>(objA: T, objB: U): T & U {
  return { ...objA, ...objB }
}

const merged = merge({ id: 1 }, { role: "admin" })
// Typ: { id: number } & { role: string }
```

---

### Zusammenfassung

* **Intersection Types (`&`)** = Kombination mehrerer Typen zu einem Typ, der **alle Eigenschaften** enthält.
* Unterschied zu Union:

  * **Union (`|`)** → entweder-oder.
  * **Intersection (`&`)** → sowohl-als-auch.

🔗 Quellen:

* [TypeScript Handbook – Intersection Types](https://www.typescriptlang.org/docs/handbook/2/objects.html#intersection-types)
* [React TS Cheatsheet – Utility Types & Intersections](https://react-typescript-cheatsheet.netlify.app/docs/advanced/types_react_api/)

  **[⬆ Наверх](#top)**

11. ### <a name="11"></a> Was sind Literal Types?

### Literal Types in TypeScript

**Definition:**
Ein **Literal Type** schränkt eine Variable auf einen **konkreten Wert** ein, anstatt nur auf den allgemeinen Typ (z. B. `string` oder `number`).
So kann man Variablen oder Parameter **nur bestimmte erlaubte Werte** zuweisen.

---

### Beispiel 1 – String-Literals

```js
let direction: "left" | "right"

direction = "left"   // ✅ erlaubt
direction = "right"  // ✅ erlaubt
direction = "up"     // ❌ Fehler
```

---

### Beispiel 2 – Number-Literals

```js
let diceRoll: 1 | 2 | 3 | 4 | 5 | 6

diceRoll = 3  // ✅ erlaubt
diceRoll = 7  // ❌ Fehler
```

---

### Beispiel 3 – In Kombination mit Unions

```js
type Status = "success" | "error" | "loading"

function handleStatus(status: Status): void {
  if (status === "success") {
    console.log("Alles gut ✅")
  } else if (status === "error") {
    console.log("Fehler ❌")
  } else {
    console.log("Lädt ⏳")
  }
}

handleStatus("success")
```

---

### Beispiel 4 – Literal Inferenz mit `const`

```js
const role = "admin"
// Typ ist "admin", nicht string
```

---

### Zusammenfassung

* **Literal Types** = feste, konkrete Werte als Typen.
* Nützlich für: erlaubte Werte (Enums-ähnlich), Statusangaben, Konstanten.
* Oft in Kombination mit **Union Types** genutzt.

🔗 Quellen:

* [TypeScript Handbook – Literal Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-types)
* [React TS Cheatsheet – Discriminated Unions](https://react-typescript-cheatsheet.netlify.app/docs/advanced/discriminated_unions/)

  **[⬆ Наверх](#top)**

12. ### <a name="12"></a> Wie funktioniert type inference in TypeScript?

### Type Inference in TypeScript

**Definition:**
**Type Inference (Typinferenz)** bedeutet, dass TypeScript den Typ einer Variable, Funktion oder eines Ausdrucks **automatisch ableitet**, wenn kein expliziter Typ angegeben wird.

---

### Regeln der Typinferenz

#### 1. **Variable-Zuweisung**

```js
let count = 10
// Typ wird automatisch als number erkannt
// count: number
```

---

#### 2. **Funktionsergebnisse**

```js
function add(a: number, b: number) {
  return a + b
}
// Rückgabetyp: number (wird automatisch erkannt)
```

---

#### 3. **Best Common Type**

Wenn verschiedene Typen in einem Array vorkommen, wählt TypeScript den "allgemeinsten" Typ.

```js
let values = [1, "zwei", 3]
// Typ: (string | number)[]
```

---

#### 4. **Contextual Typing**

Der Typ kann auch aus dem **Kontext** abgeleitet werden.

```js
window.addEventListener("click", (event) => {
  console.log(event.clientX) // event: MouseEvent
})
```

---

#### 5. **Default Inference für `any`**

Wenn keine Information vorliegt, wird `any` angenommen (außer bei `--noImplicitAny`).

```js
function log(value) {
  console.log(value)
}
// value: any
```

---

### Vorteile

* Weniger Schreibarbeit (man muss nicht überall Typen manuell angeben).
* Bessere Lesbarkeit.
* Trotzdem Typ-Sicherheit, solange genug Information vorhanden ist.

---

### Zusammenfassung

* **Type Inference** = automatische Typbestimmung durch TypeScript.
* Regeln: Variablenzuweisung, Funktionsrückgaben, Arrays (Best Common Type), Kontextabhängigkeit.
* Vorteil: weniger Code, aber trotzdem Typ-Sicherheit.

🔗 Quellen:

* [TypeScript Handbook – Type Inference](https://www.typescriptlang.org/docs/handbook/type-inference.html)
* [React TS Cheatsheet – Inference](https://react-typescript-cheatsheet.netlify.app/docs/basic/troubleshooting/types/#type-inference)

  **[⬆ Наверх](#top)**

13. ### <a name="13"></a> Was ist ein Type Alias (type) und wie unterscheidet er sich von interface?

### **Type Alias (`type`) in TypeScript**

**Definition:**
Ein **Type Alias** erstellt einen neuen Namen für einen bestehenden Typ.
Er kann primitive Typen, Union/Intersection Types, Funktionen oder komplexe Strukturen beschreiben.

```js
type UserID = string | number

type User = {
  id: UserID
  name: string
}
```

---

### **Interface in TypeScript**

**Definition:**
Ein **Interface** beschreibt die **Struktur eines Objekts** (Shape).
Es wird häufig für Klassen, Objekte und die Definition von Verträgen verwendet.

```js
interface User {
  id: number
  name: string
}
```

---

### **Hauptunterschiede**

| Aspekt                   | `type`                                                               | `interface`                                    |
| ------------------------ | -------------------------------------------------------------------- | ---------------------------------------------- |
| **Einsatz**              | Alias für jeden Typ (Primitives, Unions, Functions, Tuples, Objects) | Nur Objekte und Klassen-Strukturen             |
| **Erweiterung**          | Mit `&` (Intersection)                                               | Mit `extends`                                  |
| **Deklarations-Merging** | ❌ Nicht möglich                                                      | ✅ Mehrfachdeklarationen werden zusammengeführt |
| **Flexibilität**         | Sehr vielseitig                                                      | Speziell für objektorientierte Modelle         |

---

### **Beispiele für Unterschiede**

#### 1. Type für Union

```js
type Status = "success" | "error" | "loading"
```

Mit `interface` nicht möglich.

---

#### 2. Interface-Erweiterung

```js
interface Person {
  name: string
}

interface Employee extends Person {
  company: string
}
```

---

#### 3. Type-Erweiterung mit Intersection

```js
type Person = { name: string }
type Employee = Person & { company: string }
```

---

#### 4. Deklarations-Merging

```js
interface Window {
  title: string
}

interface Window {
  size: number
}

const w: Window = { title: "App", size: 800 }
// ✅ erlaubt, beide Interfaces verschmelzen
```

Mit `type` nicht möglich.

---

### Zusammenfassung

* **`type`** = Alias für beliebige Typen (Primitives, Union, Intersection, Functions, Tuples, Objekte).
* **`interface`** = Vertrag für Objekt- oder Klassen-Strukturen, unterstützt Deklarations-Merging.
* Empfehlung:

  * **Objektmodelle → `interface`**
  * **Komplexe Typ-Kombinationen → `type`**

🔗 Quellen:

* [TypeScript Handbook – Type Aliases](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-aliases)
* [TypeScript Handbook – Interfaces](https://www.typescriptlang.org/docs/handbook/2/objects.html)
* [React TS Cheatsheet – Types vs. Interfaces](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example#types-vs-interfaces)

  **[⬆ Наверх](#top)**

14. ### <a name="14"></a> Was ist der Unterschied zwischen interface und type?

### Unterschied zwischen `interface` und `type` in TypeScript

#### **1. Gemeinsamkeiten**

* Beide können Objekte beschreiben.
* Beide unterstützen Erweiterung und Wiederverwendung.
* Beide sind strukturell (nicht nominal) → entscheidend ist die Form, nicht der Name.

---

#### **2. Unterschiede**

| Aspekt                   | `interface`                                       | `type`                                                             |
| ------------------------ | ------------------------------------------------- | ------------------------------------------------------------------ |
| **Verwendungszweck**     | Hauptsächlich für Objekte und Klassen-Contracts   | Alias für jeden Typ (auch Primitives, Union, Tuple, Function etc.) |
| **Erweiterung**          | `extends`                                         | Intersection (`&`)                                                 |
| **Deklarations-Merging** | ✅ Ja (mehrfach definierbar, wird zusammengeführt) | ❌ Nein                                                             |
| **Flexibilität**         | Eingeschränkter (nur für Objekt-ähnliche Typen)   | Sehr flexibel, kann alles beschreiben                              |
| **Lesbarkeit**           | Oft bevorzugt für Props, Klassen, API-Schemas     | Bevorzugt für komplexe Typkombinationen, Union/Intersection        |

---

#### **3. Beispiele**

**Interface für Objekte**

```js
interface Person {
  name: string
  age: number
}

interface Employee extends Person {
  company: string
}

const dev: Employee = { name: "Sergii", age: 34, company: "Tech GmbH" }
```

**Type für komplexe Kombinationen**

```js
type Status = "success" | "error" | "loading"

type UserID = string | number

type Point = [number, number] // Tuple
```

**Deklarations-Merging (nur bei Interface)**

```js
interface Window {
  title: string
}

interface Window {
  size: number
}

const w: Window = { title: "App", size: 800 } // ✅ erlaubt
```

---

### Zusammenfassung

* **`interface`** = objektorientiert, erweiterbar (`extends`), unterstützt Deklarations-Merging.
* **`type`** = flexibler, geeignet für Unions, Primitives, Funktionen, Tuples.
* Empfehlung:

  * **Objekte/Klassen** → `interface`
  * **Union/Intersection/Primitives** → `type`

🔗 Quellen:

* [TypeScript Handbook – Interfaces](https://www.typescriptlang.org/docs/handbook/2/objects.html)
* [TypeScript Handbook – Type Aliases](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-aliases)
* [React TS Cheatsheet – Types vs Interfaces](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example#types-vs-interfaces)

  **[⬆ Наверх](#top)**

15. ### <a name="15"></a> Kann man Interfaces zusammenführen (extend)?

### Interfaces zusammenführen in TypeScript

Ja – **Interfaces** können auf zwei Arten zusammengeführt werden:

---

#### **1. Erweiterung mit `extends`**

Ein Interface kann ein anderes Interface erweitern.

```js
interface Person {
  name: string
}

interface Employee extends Person {
  company: string
}

const dev: Employee = {
  name: "Sergii",
  company: "Tech GmbH"
}
```

* `Employee` erbt alle Eigenschaften von `Person`.

---

#### **2. Deklarations-Merging**

Wenn mehrere **gleichnamige Interfaces** existieren, werden sie automatisch zusammengeführt.

```js
interface Window {
  title: string
}

interface Window {
  size: number
}

const w: Window = {
  title: "App",
  size: 1200
}
```

* TypeScript kombiniert beide Definitionen → Ergebnis ist ein Interface mit `title` **und** `size`.

---

#### Unterschied zu `type`

* `type` kann **nicht** gemerged werden.
* Nur `interface` unterstützt Deklarations-Merging.

---

### Zusammenfassung

* **Ja, Interfaces können zusammengeführt werden.**
* Zwei Wege:

  1. **`extends`** → Vererbung.
  2. **Deklarations-Merging** → mehrere gleiche Namen = automatisch kombiniert.
* Vorteil: Flexibel für API-Erweiterungen oder globale Typdefinitionen.

🔗 Quellen:

* [TypeScript Handbook – Interfaces](https://www.typescriptlang.org/docs/handbook/2/objects.html#extending-interfaces)
* [TypeScript Handbook – Declaration Merging](https://www.typescriptlang.org/docs/handbook/declaration-merging.html)

  **[⬆ Наверх](#top)**

16. ### <a name="16"></a> Was sind optionale Eigenschaften in Interfaces?

### Optionale Eigenschaften in Interfaces

**Definition:**
Optionale Eigenschaften in einem Interface sind Felder, die beim Erstellen eines Objekts **nicht zwingend angegeben** werden müssen.
Man markiert sie mit einem **Fragezeichen (`?`)** nach dem Eigenschaftsnamen.

---

### Beispiel 1 – Einfaches Interface mit optionalen Feldern

```js
interface User {
  id: number
  name: string
  age?: number // optional
}

const user1: User = { id: 1, name: "Sergii" }       // ✅ ohne age
const user2: User = { id: 2, name: "Anna", age: 30 } // ✅ mit age
```

---

### Beispiel 2 – Optional in Kombination mit Funktionen

```js
interface Config {
  url: string
  timeout?: number
}

function fetchData(config: Config) {
  console.log(`Hole Daten von ${config.url}`)
  if (config.timeout) {
    console.log(`Timeout: ${config.timeout}ms`)
  }
}

fetchData({ url: "/api" })
fetchData({ url: "/api", timeout: 5000 })
```

---

### Beispiel 3 – Unterschied zu `undefined`

Ein optionales Feld kann fehlen **oder explizit `undefined` sein**.

```js
interface Product {
  name: string
  price?: number
}

const p1: Product = { name: "Buch" }                 // kein price
const p2: Product = { name: "Buch", price: undefined } // explizit undefined
```

---

### Zusammenfassung

* **Optionale Eigenschaften** (`?`) = nicht verpflichtend in Objekten.
* Können weggelassen oder explizit auf `undefined` gesetzt werden.
* Nützlich für **Konfigurationsobjekte, optionale Props, flexible Datenstrukturen**.

🔗 Quellen:

* [TypeScript Handbook – Interfaces](https://www.typescriptlang.org/docs/handbook/2/objects.html#optional-properties)
* [React TS Cheatsheet – Optional Props](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example#optional-props)

  **[⬆ Наверх](#top)**

17. ### <a name="17"></a> Wie deklariert man readonly-Eigenschaften?

### `readonly` Eigenschaften in TypeScript

**Definition:**
Mit dem Schlüsselwort **`readonly`** kann man Eigenschaften in Interfaces, Types oder Klassen so deklarieren, dass sie **nach der Initialisierung nicht mehr verändert** werden dürfen.

---

### Beispiel 1 – Interface mit `readonly`

```js
interface User {
  readonly id: number
  name: string
}

const user: User = { id: 1, name: "Sergii" }

user.name = "Anna"   // ✅ erlaubt
user.id = 2          // ❌ Fehler: id ist readonly
```

---

### Beispiel 2 – Type mit `readonly`

```js
type Point = {
  readonly x: number
  readonly y: number
}

const p: Point = { x: 10, y: 20 }
p.x = 30 // ❌ Fehler
```

---

### Beispiel 3 – Klassen mit `readonly`

```js
class Person {
  readonly id: number
  name: string

  constructor(id: number, name: string) {
    this.id = id      // ✅ Initialisierung erlaubt
    this.name = name
  }
}

const dev = new Person(1, "Sergii")
dev.name = "Anna"   // ✅ erlaubt
dev.id = 2          // ❌ Fehler
```

---

### Beispiel 4 – Readonly Arrays

```js
const numbers: ReadonlyArray<number> = [1, 2, 3]

numbers.push(4) // ❌ Fehler: push ist nicht erlaubt
```

---

### Zusammenfassung

* **`readonly`** = Eigenschaft kann nur bei der Initialisierung gesetzt werden.
* Einsatz in: **Interfaces, Types, Klassen, Arrays**.
* Vorteil: bessere **Immutabilität** und Sicherheit vor unbeabsichtigten Änderungen.

🔗 Quellen:

* [TypeScript Handbook – readonly](https://www.typescriptlang.org/docs/handbook/2/objects.html#readonly-properties)
* [React TS Cheatsheet – readonly usage](https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase#readonly-and-const-assertions)

  **[⬆ Наверх](#top)**

18. ### <a name="18"></a> Was sind Tupel (tuples) in TypeScript?

### Tupel (Tuples) in TypeScript

**Definition:**
Ein **Tuple** ist ein spezielles Array mit **fester Länge** und **fest definierten Typen** an den jeweiligen Positionen.
→ Anders als bei Arrays kann jedes Element einen eigenen Typ haben, der an einer bestimmten Stelle erwartet wird.

---

### Beispiel 1 – Einfaches Tuple

```js
let user: [string, number]

user = ["Sergii", 34]   // ✅ korrekt
user = [34, "Sergii"]   // ❌ Fehler: Reihenfolge stimmt nicht
```

---

### Beispiel 2 – Tuple mit optionalem Element

```js
let point: [number, number, number?]

point = [10, 20]       // ✅ erlaubt
point = [10, 20, 30]   // ✅ erlaubt
```

---

### Beispiel 3 – Mit `readonly` (immutable Tuple)

```js
let coordinates: readonly [number, number] = [50, 100]

coordinates[0] = 10 // ❌ Fehler: readonly
```

---

### Beispiel 4 – Einsatz in Funktionen

```js
function useCoordinates(): [number, number] {
  return [10, 20]
}

const [x, y] = useCoordinates()
```

---

### Beispiel 5 – Variadische Tupel (seit TS 4.0)

```js
type Pair<T> = [T, T]
type Triple<T> = [T, T, T]

let pair: Pair<string> = ["a", "b"]
let triple: Triple<number> = [1, 2, 3]
```

---

### Zusammenfassung

* **Tuple** = Array mit **fester Länge** und **definierten Typen pro Index**.
* Nützlich für: Rückgabewerte von Funktionen, koordinatenartige Werte, kleine feste Strukturen.
* Erweiterungen: optionale Elemente, `readonly`, variadische Tupel.

🔗 Quellen:

* [TypeScript Handbook – Tuples](https://www.typescriptlang.org/docs/handbook/2/objects.html#tuple-types)
* [MDN – Arrays (als Grundlage)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array)

  **[⬆ Наверх](#top)**

19. ### <a name="19"></a> Was ist ein Enum und wann sollte man es verwenden?

### Enum in TypeScript

**Definition:**
Ein **Enum** (Aufzählungstyp) ist eine Sammlung von **benannten Konstanten**.
Es wird verwendet, um Wertegruppen besser lesbar und verständlich zu machen.

---

### Arten von Enums

#### 1. **Numerische Enums (Standard)**

```js
enum Direction {
  Up,    // 0
  Down,  // 1
  Left,  // 2
  Right  // 3
}

let move: Direction = Direction.Up
console.log(move) // 0
```

Man kann auch Startwerte vergeben:

```js
enum Status {
  Success = 1,
  Error = 2,
  Loading = 3
}
```

---

#### 2. **String Enums**

```js
enum Role {
  Admin = "ADMIN",
  User = "USER",
  Guest = "GUEST"
}

let current: Role = Role.Admin
```

---

#### 3. **Const Enums (Kompilierungsoptimierung)**

```js
const enum LogLevel {
  Info,
  Warning,
  Error
}

let level: LogLevel = LogLevel.Error
```

👉 Vorteile: wird zu einfachen Konstanten kompiliert → bessere Performance.

---

### Wann verwenden?

✅ **Geeignet für:**

* Feste, klar definierte Wertegruppen (z. B. Rollen, Status, Richtungen).
* Lesbarkeit: statt `"ADMIN"` oder `1` → `Role.Admin`.
* Weniger Tippfehler durch Autovervollständigung.

⚠️ **Alternativen:**

* **Union Types** mit Literal-Typen sind oft schlanker und flexibler.

  ```js
  type Role = "ADMIN" | "USER" | "GUEST"
  ```
* Empfehlung: In modernen Projekten werden häufig **Union Types** anstelle von Enums bevorzugt, da sie besser mit TypeScript-Features wie Narrowing und Type Inference harmonieren.

---

### Zusammenfassung

* **Enum** = Sammlung von benannten Konstanten (numeric, string, const).
* Vorteile: bessere Lesbarkeit, Fehlervermeidung, klare Struktur.
* Verwendung: feste Wertemengen (Status, Rollen, Richtungen).
* Alternative: **Union Types** → oft moderner und einfacher.

🔗 Quellen:

* [TypeScript Handbook – Enums](https://www.typescriptlang.org/docs/handbook/enums.html)
* [React TS Cheatsheet – Union vs Enums](https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase#enums-vs-union-types)

  **[⬆ Наверх](#top)**

20. ### <a name="20"></a> Was ist der Unterschied zwischen const enum und einem normalen enum?

### Unterschied zwischen `enum` und `const enum` in TypeScript

#### **1. Normales `enum`**

* Wird zur **Laufzeit** in JavaScript-Code kompiliert.
* TypeScript erzeugt ein **Objekt** mit Schlüssel/Wert-Zuordnung.
* Bidirektionale Abbildung: man kann von Namen auf Wert und umgekehrt zugreifen.

```js
enum Direction {
  Up,
  Down,
  Left,
  Right
}

console.log(Direction.Up)    // 0
console.log(Direction[0])    // "Up"
```

➡️ Nach der Kompilierung entsteht ein JS-Objekt:

```js
var Direction;
(function (Direction) {
    Direction[Direction["Up"] = 0] = "Up";
    Direction[Direction["Down"] = 1] = "Down";
    Direction[Direction["Left"] = 2] = "Left";
    Direction[Direction["Right"] = 3] = "Right";
})(Direction || (Direction = {}));
```

---

#### **2. `const enum`**

* Wird **zur Compile-Zeit** durch seine Werte ersetzt.
* Kein Objekt im generierten JavaScript.
* Spart Code und verbessert Performance.

```js
const enum Direction {
  Up,
  Down,
  Left,
  Right
}

let move = Direction.Up
console.log(move) // 0
```

➡️ Nach der Kompilierung:

```js
let move = 0 /* Up */
```

* Kein `Direction`-Objekt vorhanden → keine bidirektionale Abbildung möglich.

---

#### **3. Vergleich**

| Aspekt              | `enum`                                      | `const enum`                     |
| ------------------- | ------------------------------------------- | -------------------------------- |
| **Kompilierung**    | JS-Objekt wird erzeugt                      | Ersetzt durch Werte, kein Objekt |
| **Performance**     | Mehr Overhead                               | Weniger Overhead                 |
| **Reverse Mapping** | ✅ möglich (`Direction[0] → "Up"`)           | ❌ nicht möglich                  |
| **Codegröße**       | Größer                                      | Kleiner                          |
| **Verwendung**      | Wenn bidirektionales Mapping gebraucht wird | Für reine Konstantenwerte        |

---

### Zusammenfassung

* **`enum`**: erzeugt ein JavaScript-Objekt → erlaubt Zugriff in beide Richtungen, größerer Output.
* **`const enum`**: wird während der Kompilierung inline ersetzt → effizienter, aber ohne Reverse Mapping.

🔗 Quellen:

* [TypeScript Handbook – Enums](https://www.typescriptlang.org/docs/handbook/enums.html#const-enums)
* [React TS Cheatsheet – Enums](https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase#enums-vs-union-types)

  **[⬆ Наверх](#top)**

21. ### <a name="21"></a> Was ist Type Narrowing (Typschränkung)?

### Type Narrowing (Typschränkung) in TypeScript

**Definition:**
**Type Narrowing** bedeutet, dass TypeScript den Typ einer Variable während des Codes **einschränkt** (von einem breiteren Union-Typ auf einen spezifischeren Typ), basierend auf **Kontrollstrukturen oder Type Guards**.

---

### Beispiel 1 – `typeof` Narrowing

```js
function printId(id: string | number) {
  if (typeof id === "string") {
    console.log(id.toUpperCase()) // id: string
  } else {
    console.log(id.toFixed(2))    // id: number
  }
}
```

---

### Beispiel 2 – `instanceof` Narrowing

```js
class Dog {
  bark() { console.log("Wuff!") }
}
class Cat {
  meow() { console.log("Miau!") }
}

function makeSound(animal: Dog | Cat) {
  if (animal instanceof Dog) {
    animal.bark() // animal: Dog
  } else {
    animal.meow() // animal: Cat
  }
}
```

---

### Beispiel 3 – Property Check (`in` Operator)

```js
type Fish = { swim: () => void }
type Bird = { fly: () => void }

function move(animal: Fish | Bird) {
  if ("swim" in animal) {
    animal.swim() // Typ: Fish
  } else {
    animal.fly()  // Typ: Bird
  }
}
```

---

### Beispiel 4 – Gleichheitsprüfung (Literal Narrowing)

```js
type Status = "success" | "error" | "loading"

function handleStatus(status: Status) {
  if (status === "success") {
    console.log("Alles gut ✅")
  }
}
```

---

### Beispiel 5 – Exhaustive Check mit `never`

```js
type Shape = { kind: "circle"; radius: number } 
           | { kind: "square"; side: number }

function area(shape: Shape): number {
  switch (shape.kind) {
    case "circle": return Math.PI * shape.radius ** 2
    case "square": return shape.side * shape.side
    default:
      const exhaustive: never = shape // Fehler, falls ein neuer Typ fehlt
      return exhaustive
  }
}
```

---

### Zusammenfassung

* **Type Narrowing** = Einschränkung von Union-Typen auf spezifische Typen.
* Methoden: `typeof`, `instanceof`, `in`, Gleichheitsprüfungen, Kontrollfluss.
* Vorteil: bessere Typ-Sicherheit, weniger Fehler, klarer Code.

🔗 Quellen:

* [TypeScript Handbook – Narrowing](https://www.typescriptlang.org/docs/handbook/2/narrowing.html)
* [React TS Cheatsheet – Type Narrowing](https://react-typescript-cheatsheet.netlify.app/docs/basic/troubleshooting/types/#type-narrowing)

  **[⬆ Наверх](#top)**

22. ### <a name="22"></a> Was sind Type Guards? Gib ein Beispiel.

### Type Guards in TypeScript

**Definition:**
Ein **Type Guard** ist eine spezielle Bedingung oder Funktion, mit der TypeScript erkennt, welchen konkreten Typ eine Variable in einem Union-Type-Kontext hat.
→ Er hilft beim **Type Narrowing**, sodass TypeScript innerhalb des Blocks mit dem spezifischen Typ arbeiten kann.

---

### Beispiel 1 – `typeof` als Type Guard

```js
function printValue(value: string | number) {
  if (typeof value === "string") {
    console.log(value.toUpperCase()) // value: string
  } else {
    console.log(value.toFixed(2))    // value: number
  }
}
```

---

### Beispiel 2 – `instanceof` als Type Guard

```js
class Dog {
  bark() { console.log("Wuff!") }
}
class Cat {
  meow() { console.log("Miau!") }
}

function makeSound(animal: Dog | Cat) {
  if (animal instanceof Dog) {
    animal.bark() // animal: Dog
  } else {
    animal.meow() // animal: Cat
  }
}
```

---

### Beispiel 3 – Property Check (`in` Operator)

```js
type Fish = { swim: () => void }
type Bird = { fly: () => void }

function move(animal: Fish | Bird) {
  if ("swim" in animal) {
    animal.swim() // animal: Fish
  } else {
    animal.fly()  // animal: Bird
  }
}
```

---

### Beispiel 4 – Benutzerdefinierter Type Guard (`is`-Syntax)

```js
type Car = { drive: () => void }
type Boat = { sail: () => void }

function isCar(vehicle: Car | Boat): vehicle is Car {
  return (vehicle as Car).drive !== undefined
}

function useVehicle(vehicle: Car | Boat) {
  if (isCar(vehicle)) {
    vehicle.drive() // Typ: Car
  } else {
    vehicle.sail()  // Typ: Boat
  }
}
```

---

### Zusammenfassung

* **Type Guards** = Bedingungen/Funktionen, die Typen präzisieren.
* Varianten:

  * `typeof` (für primitive Typen)
  * `instanceof` (für Klassen)
  * `in` Operator (für Properties)
  * benutzerdefinierte Type Guards (`is`-Syntax)
* Zweck: **sicheres Type Narrowing** in Union Types.

🔗 Quellen:

* [TypeScript Handbook – Narrowing](https://www.typescriptlang.org/docs/handbook/2/narrowing.html)
* [React TS Cheatsheet – Type Guards](https://react-typescript-cheatsheet.netlify.app/docs/basic/troubleshooting/types/#type-guards)

  **[⬆ Наверх](#top)**

23. ### <a name="23"></a> Wie funktioniert der Operator in bei der Typprüfung?

### Der `in`-Operator bei der Typprüfung in TypeScript

**Definition:**
Der **`in`-Operator** prüft, ob ein bestimmtes Property in einem Objekt existiert.
In TypeScript wird er als **Type Guard** genutzt, um zwischen verschiedenen Typen in einer Union zu unterscheiden.

---

### Beispiel 1 – Unterschiedliche Objekt-Typen

```js
type Dog = { bark: () => void }
type Cat = { meow: () => void }

function makeSound(animal: Dog | Cat) {
  if ("bark" in animal) {
    animal.bark() // animal: Dog
  } else {
    animal.meow() // animal: Cat
  }
}
```

➡️ Der `in`-Check sagt TypeScript:

* Wenn `bark` vorhanden ist → Typ ist `Dog`.
* Ansonsten → Typ ist `Cat`.

---

### Beispiel 2 – Optionale Properties

```js
interface User {
  id: number
  name: string
  email?: string
}

function hasEmail(user: User) {
  if ("email" in user) {
    console.log("User hat eine Email:", user.email)
  } else {
    console.log("Keine Email")
  }
}
```

---

### Beispiel 3 – Discriminated Unions

```js
type Circle = { kind: "circle"; radius: number }
type Square = { kind: "square"; side: number }

function area(shape: Circle | Square) {
  if ("radius" in shape) {
    return Math.PI * shape.radius ** 2 // Circle
  } else {
    return shape.side * shape.side     // Square
  }
}
```

---

### Zusammenfassung

* **`in`-Operator** prüft, ob ein Property existiert.
* In TypeScript dient er als **Type Guard** für Union Types.
* Typische Nutzung: Unterscheidung zwischen Objekten mit unterschiedlichen Eigenschaften oder optionalen Feldern.

🔗 Quellen:

* [TypeScript Handbook – Narrowing mit `in`](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-the-in-operator)
* [MDN – in Operator](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/in)

  **[⬆ Наверх](#top)**

24. ### <a name="24"></a> Wie funktioniert typeof in TypeScript?

### `typeof` in TypeScript

**Definition:**
In TypeScript hat `typeof` **zwei unterschiedliche Einsatzmöglichkeiten**:

1. **Zur Laufzeit** → wie in JavaScript, um den Typ eines Wertes zu prüfen.
2. **Zur Compile-Zeit** → um den Typ einer Variablen/Funktion zu extrahieren und wiederzuverwenden.

---

## 1. `typeof` zur Laufzeit (Type Guard)

Verhält sich wie in JavaScript, gibt einen **String** mit dem Typ zurück.
Wird in TypeScript für **Type Narrowing** genutzt.

```js
function printValue(value: string | number) {
  if (typeof value === "string") {
    console.log(value.toUpperCase()) // value: string
  } else {
    console.log(value.toFixed(2))    // value: number
  }
}
```

Mögliche Ergebnisse: `"string"`, `"number"`, `"boolean"`, `"object"`, `"function"`, `"undefined"`, `"symbol"`, `"bigint"`.

---

## 2. `typeof` zur Compile-Zeit (Type Query Operator)

Damit kann man den **Typ einer bestehenden Variable/Funktion** für eine Typdefinition wiederverwenden.

```js
let user = { id: 1, name: "Sergii" }

// Extrahiert den Typ von user
type User = typeof user

const admin: User = { id: 2, name: "Anna" } // ✅ korrekt
```

---

## 3. `typeof` für Funktionen

```js
function add(a: number, b: number) {
  return a + b
}

type AddFunction = typeof add
// AddFunction ist: (a: number, b: number) => number
```

---

### Zusammenfassung

* **Laufzeit (`typeof` als Operator):** gibt den primitiven JS-Typ zurück, nutzbar als Type Guard.
* **Compile-Zeit (`typeof` als Type Query):** extrahiert den Typ einer bestehenden Variablen oder Funktion.
* Vorteil: weniger Code-Duplikation, sicheres Type Narrowing.

🔗 Quellen:

* [TypeScript Handbook – typeof](https://www.typescriptlang.org/docs/handbook/2/typeof-types.html)
* [TypeScript Handbook – Narrowing mit typeof](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#typeof-type-guards)

  **[⬆ Наверх](#top)**

25. ### <a name="25"></a> Wie funktioniert instanceof?

### `instanceof` in TypeScript

**Definition:**
Der Operator **`instanceof`** prüft **zur Laufzeit**, ob ein Objekt von einer bestimmten **Klasse oder einem Konstruktor** erstellt wurde.
In TypeScript wird er als **Type Guard** verwendet, um den Typ innerhalb eines Blocks einzugrenzen (**Type Narrowing**).

---

### Beispiel 1 – Klassenprüfung

```js
class Dog {
  bark() { console.log("Wuff!") }
}

class Cat {
  meow() { console.log("Miau!") }
}

function makeSound(animal: Dog | Cat) {
  if (animal instanceof Dog) {
    animal.bark() // animal: Dog
  } else {
    animal.meow() // animal: Cat
  }
}
```

---

### Beispiel 2 – Mit eingebauten Objekten

```js
function logDate(date: Date | string) {
  if (date instanceof Date) {
    console.log("Datum:", date.toISOString()) // date: Date
  } else {
    console.log("String:", date.toUpperCase()) // date: string
  }
}
```

---

### Beispiel 3 – Nicht für primitive Typen

```js
let value = "Hallo"

console.log(value instanceof String) // ❌ false (Primitives sind keine Instanzen)
```

👉 Für Primitives verwendet man `typeof`, nicht `instanceof`.

---

### Vergleich zu anderen Type Guards

* **`typeof`** → für primitive Typen (`string`, `number`, `boolean`, …).
* **`instanceof`** → für Klassen und Objekte, die mit `new` erstellt wurden.
* **`in`** → für Property-Prüfungen in Objekten.

---

### Zusammenfassung

* **`instanceof`** prüft, ob ein Objekt von einer bestimmten Klasse/Konstruktor stammt.
* Dient als **Type Guard** in Union Types.
* Funktioniert nur bei **Objekten/Klassen**, nicht bei Primitives.

🔗 Quellen:

* [TypeScript Handbook – Narrowing mit `instanceof`](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#instanceof-narrowing)
* [MDN – instanceof](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/instanceof)

  **[⬆ Наверх](#top)**

26. ### <a name="26"></a> Was sind Discriminated Unions (diskriminierte Typen)?

### Discriminated Unions (diskriminierte Typen) in TypeScript

**Definition:**
Ein **Discriminated Union** ist ein **Union Type**, bei dem jede Variante ein gemeinsames, eindeutiges Feld (das sog. **Discriminant**) enthält.
TypeScript kann dadurch den Typ automatisch unterscheiden (**Type Narrowing**).

---

### Beispiel 1 – Shapes

```js
interface Circle {
  kind: "circle"   // Discriminant
  radius: number
}

interface Square {
  kind: "square"   // Discriminant
  side: number
}

type Shape = Circle | Square

function area(shape: Shape): number {
  switch (shape.kind) {
    case "circle":
      return Math.PI * shape.radius ** 2
    case "square":
      return shape.side * shape.side
  }
}
```

➡️ `kind` diskriminiert zwischen `Circle` und `Square`.

---

### Beispiel 2 – API-Status

```js
type ApiResponse =
  | { status: "success"; data: string }
  | { status: "error"; error: Error }
  | { status: "loading" }

function handleResponse(res: ApiResponse) {
  if (res.status === "success") {
    console.log("Data:", res.data)
  } else if (res.status === "error") {
    console.error("Fehler:", res.error.message)
  } else {
    console.log("Lädt...")
  }
}
```

---

### Beispiel 3 – Exhaustive Checking mit `never`

```js
function exhaustiveCheck(x: never): never {
  throw new Error("Unreachable code")
}

function handleShape(shape: Shape) {
  switch (shape.kind) {
    case "circle": return Math.PI * shape.radius ** 2
    case "square": return shape.side * shape.side
    default: return exhaustiveCheck(shape) // ⛔ Compiler-Fehler, falls neuer Typ fehlt
  }
}
```

---

### Vorteile

* Bessere **Typ-Sicherheit** bei Union Types.
* TypeScript erkennt automatisch, welcher Typ in welchem Zweig vorliegt.
* Erleichtert **Fehlerprävention** durch Exhaustive Checks.

---

### Zusammenfassung

* **Discriminated Unions** = Union Types mit einem gemeinsamen Feld (`kind`, `status`, etc.).
* Dienen zur klaren Typunterscheidung.
* Sehr nützlich in **Switch-Statements** und bei **API-Responses** oder **React-Props**.

🔗 Quellen:

* [TypeScript Handbook – Discriminated Unions](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#discriminated-unions)
* [React TS Cheatsheet – Discriminated Unions](https://react-typescript-cheatsheet.netlify.app/docs/advanced/discriminated_unions/)

  **[⬆ Наверх](#top)**

27. ### <a name="27"></a> Was ist der Unterschied zwischen interface und abstract class?

### Unterschied zwischen `interface` und `abstract class` in TypeScript

#### **1. Interface**

* Beschreibt **nur die Struktur** (Vertrag), aber keine Implementierung.
* Enthält **keinen Code**, nur Signaturen (Properties, Methoden).
* Eine Klasse kann mehrere Interfaces implementieren.

```js
interface Flyable {
  fly(): void
}

class Bird implements Flyable {
  fly() {
    console.log("Der Vogel fliegt 🕊️")
  }
}
```

---

#### **2. Abstract Class**

* Kann sowohl **abstrakte Methoden** (ohne Implementierung) als auch **konkrete Methoden** (mit Code) enthalten.
* Kann **Felder** und **Konstruktoren** haben.
* Klassen können nur **eine abstrakte Klasse** erweitern (Einzelvererbung).

```js
abstract class Animal {
  constructor(public name: string) {}

  abstract makeSound(): void // muss implementiert werden

  move(): void {
    console.log(`${this.name} bewegt sich`)
  }
}

class Dog extends Animal {
  makeSound() {
    console.log("Wuff!")
  }
}

const rex = new Dog("Rex")
rex.makeSound() // Wuff!
rex.move()      // Rex bewegt sich
```

---

### **3. Vergleichstabelle**

| Aspekt                 | `interface`                     | `abstract class`                           |
| ---------------------- | ------------------------------- | ------------------------------------------ |
| **Implementierung**    | Keine, nur Vertrag              | Kann Code enthalten                        |
| **Konstruktor**        | ❌ Nein                          | ✅ Ja                                       |
| **Felder mit Werten**  | ❌ Nein                          | ✅ Ja                                       |
| **Abstrakte Methoden** | ✅ Nur Signaturen                | ✅ Ja                                       |
| **Normale Methoden**   | ❌ Nein                          | ✅ Ja                                       |
| **Mehrfachverwendung** | ✅ Mehrere Interfaces pro Klasse | ❌ Nur eine abstrakte Klasse pro Klasse     |
| **Verwendung**         | Für reine Strukturdefinition    | Für Basisklassen mit gemeinsamem Verhalten |

---

### **Wann verwenden?**

* **Interface** → wenn du nur einen Vertrag beschreiben willst (z. B. Props, Data Models, API-Schemas).
* **Abstract Class** → wenn du **gemeinsames Verhalten + Vertrag** für Subklassen definieren willst.

---

### Zusammenfassung

* **`interface`** = reine Struktur, keine Implementierung, unterstützt Mehrfach-Implementierung.
* **`abstract class`** = Kombination aus Vertrag und (teilweiser) Implementierung, mit Konstruktor und Feldern.

🔗 Quellen:

* [TypeScript Handbook – Interfaces](https://www.typescriptlang.org/docs/handbook/2/objects.html)
* [TypeScript Handbook – Classes](https://www.typescriptlang.org/docs/handbook/2/classes.html#abstract-classes)

  **[⬆ Наверх](#top)**

28. ### <a name="28"></a> Wie implementiert man Funktionsüberladungen (function overloads) in TypeScript?

### Funktionsüberladungen (Function Overloads) in TypeScript

**Definition:**
Mit **Function Overloads** kann eine Funktion **mehrere Signaturen** haben, aber nur **eine Implementierung**.
Dadurch können unterschiedliche Argumenttypen oder Rückgabewerte abgebildet werden.

---

### Syntax

1. **Mehrere Signaturen (Overloads)**
2. **Eine gemeinsame Implementierung**

---

### Beispiel 1 – String vs. Number Eingabe

```js
// Overload-Signaturen
function reverse(value: string): string
function reverse(value: number): number

// Implementierung
function reverse(value: string | number): string | number {
  if (typeof value === "string") {
    return value.split("").reverse().join("")
  } else {
    return Number(value.toString().split("").reverse().join(""))
  }
}

console.log(reverse("Sergii")) // iigreS
console.log(reverse(12345))    // 54321
```

➡️ Der Aufrufer sieht die Überladungen (`string → string`, `number → number`),
aber die Implementierung deckt beide Fälle ab.

---

### Beispiel 2 – Mehrere Argumenttypen

```js
function getLength(value: string): number
function getLength(value: any[]): number

function getLength(value: string | any[]): number {
  return value.length
}

console.log(getLength("Hallo"))   // 5
console.log(getLength([1, 2, 3])) // 3
```

---

### Beispiel 3 – Optional und Union

```js
function combine(a: number, b: number): number
function combine(a: string, b: string): string

function combine(a: number | string, b: number | string): number | string {
  if (typeof a === "string" && typeof b === "string") {
    return a + b
  }
  if (typeof a === "number" && typeof b === "number") {
    return a + b
  }
  throw new Error("Ungültige Argumente")
}

console.log(combine(5, 10))      // 15
console.log(combine("Hi ", "TS")) // Hi TS
```

---

### Zusammenfassung

* **Function Overloads** = mehrere Signaturen, eine Implementierung.
* Vorteil: bessere Typ-Sicherheit und IntelliSense.
* Syntax: **Signaturen oben**, **Implementierung unten**.

🔗 Quellen:

* [TypeScript Handbook – Functions (Overloads)](https://www.typescriptlang.org/docs/handbook/2/functions.html#function-overloads)
* [MDN – Funktionen in JS (Grundlage)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Functions)

  **[⬆ Наверх](#top)**

29. ### <a name="29"></a> Was sind Index Signatures?

### Index Signatures in TypeScript

**Definition:**
Eine **Index Signature** erlaubt es, die Typen von Objekten zu beschreiben, deren Schlüssel **nicht im Voraus bekannt** sind.
Damit sagt man: *„Dieses Objekt kann beliebig viele Properties haben, und ihre Schlüssel/Werte haben einen bestimmten Typ.“*

---

### Beispiel 1 – Einfache Index Signature

```js
interface StringArray {
  [index: number]: string
}

const names: StringArray = ["Anna", "Tom", "Sergii"]
console.log(names[0]) // Anna
```

➡️ Jeder numerische Index (`number`) muss einen `string` liefern.

---

### Beispiel 2 – String-Keys

```js
interface Dictionary {
  [key: string]: string
}

const translations: Dictionary = {
  hello: "Hallo",
  bye: "Tschüss"
}

console.log(translations["hello"]) // Hallo
```

---

### Beispiel 3 – Mischung mit festen Properties

```js
interface User {
  id: number
  name: string
  [key: string]: string | number // erlaubt zusätzliche Properties
}

const u: User = {
  id: 1,
  name: "Sergii",
  role: "Admin"
}
```

---

### Beispiel 4 – Readonly Index Signature

```js
interface ReadonlyArrayLike {
  readonly [index: number]: string
}

const arr: ReadonlyArrayLike = ["A", "B"]
// arr[0] = "X" // ❌ Fehler: readonly
```

---

### Einschränkungen

* Der Werttyp der Index Signature muss **alle festen Properties** abdecken.

  ```js
  interface Bad {
    name: string
    [key: string]: number // ❌ Fehler, da name: string nicht kompatibel
  }
  ```

---

### Zusammenfassung

* **Index Signatures** = definieren Typen für unbekannte Schlüssel/Werte.
* Syntax: `[key: string]: WertTyp` oder `[index: number]: WertTyp`.
* Einsatz: Dictionaries, flexible Objekte, Maps.

🔗 Quellen:

* [TypeScript Handbook – Index Signatures](https://www.typescriptlang.org/docs/handbook/2/objects.html#index-signatures)
* [React TS Cheatsheet – Index Signatures](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example#index-signatures)

  **[⬆ Наверх](#top)**

30. ### <a name="30"></a> Was ist keyof und wofür wird es verwendet?

### `keyof` in TypeScript

**Definition:**
Der **`keyof` Operator** erzeugt einen Typ, der alle **Schlüssel** (Property-Namen) eines Objekttyps als **Union Type** enthält.

---

### Beispiel 1 – Einfaches Objekt

```js
interface User {
  id: number
  name: string
  isAdmin: boolean
}

type UserKeys = keyof User
// UserKeys = "id" | "name" | "isAdmin"
```

➡️ `keyof` extrahiert `"id" | "name" | "isAdmin"` als Union.

---

### Beispiel 2 – Nutzung in Funktionen

```js
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key]
}

const user: User = { id: 1, name: "Sergii", isAdmin: true }

const name = getProperty(user, "name")   // string
const admin = getProperty(user, "isAdmin") // boolean
// getProperty(user, "age") ❌ Fehler: "age" existiert nicht in User
```

➡️ Vorteil: **sichere Property-Zugriffe** ohne Magic Strings.

---

### Beispiel 3 – Mit `typeof`

```js
const config = {
  url: "/api",
  timeout: 5000
}

type ConfigKeys = keyof typeof config
// "url" | "timeout"
```

---

### Beispiel 4 – Kombination mit Mapped Types

```js
type ReadonlyUser = {
  readonly [K in keyof User]: User[K]
}

// Alle Properties von User werden readonly
```

---

### Zusammenfassung

* **`keyof`** = erzeugt Union der Schlüssel eines Typs.
* Verwendung: generische Funktionen, sichere Property-Zugriffe, Mapped Types.
* Typische Kombination: `keyof`, `typeof`, `in`.

🔗 Quellen:

* [TypeScript Handbook – keyof](https://www.typescriptlang.org/docs/handbook/2/keyof-types.html)
* [React TS Cheatsheet – keyof usage](https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase#keyof-and-typeof)

  **[⬆ Наверх](#top)**  

31. ### <a name="31"></a> Wie funktioniert der Operator as?

### Der `as` Operator in TypeScript

**Definition:**
Der **`as` Operator** wird für **Type Assertions (Typumwandlungen)** verwendet.
Damit sagt man dem Compiler: *„Vertraue mir, dieser Wert hat einen bestimmten Typ.“*
Er ändert nichts am **Laufzeitwert**, sondern nur an der **Typprüfung** von TypeScript.

---

### Beispiel 1 – Einfache Typumwandlung

```js
let value: unknown = "Hallo TypeScript"
let strLength: number = (value as string).length

console.log(strLength) // 16
```

➡️ Der Compiler behandelt `value` innerhalb der Klammern als `string`.

---

### Beispiel 2 – DOM-Manipulation

```js
const input = document.querySelector("input") as HTMLInputElement
input.value = "Sergii"
```

➡️ Ohne `as` kennt TypeScript nur den Typ `Element | null`.
Mit `as` wird er auf `HTMLInputElement` eingeschränkt.

---

### Beispiel 3 – Union Type Spezifizierung

```js
type Bird = { fly: () => void }
type Fish = { swim: () => void }

let pet: Bird | Fish = { swim: () => console.log("Schwimmt") }

;(pet as Fish).swim() // ✅ erlaubt
```

---

### Beispiel 4 – Doppelte Typumwandlung (Edge Case)

```js
let num: number = 10
let str = num as unknown as string // ❌ unsicher, aber manchmal genutzt
```

---

### Wichtige Hinweise

* `as` ist **keine Typkonvertierung** wie in anderen Sprachen (z. B. `int → string`),
  sondern nur ein Hinweis für den Compiler.
* Missbrauch kann zu **Laufzeitfehlern** führen, wenn man falsche Annahmen macht.

---

### Zusammenfassung

* **`as` Operator** = Type Assertion, ändert nur den Typ für den Compiler, nicht den Wert zur Laufzeit.
* Typische Nutzung: DOM-Elemente, Union Types, `unknown` → spezifischer Typ.
* Vorsicht: kann Sicherheit unterlaufen, sollte sparsam und bewusst eingesetzt werden.

🔗 Quellen:

* [TypeScript Handbook – Type Assertions](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-assertions)
* [MDN – DOM querySelector](https://developer.mozilla.org/ru/docs/Web/API/Document/querySelector)

  **[⬆ Наверх](#top)**

32. ### <a name="32"></a> Was ist der Unterschied zwischen as const und einem normalen const?

### Unterschied zwischen `const` und `as const` in TypeScript

---

#### **1. Normales `const` (JavaScript/TypeScript)**

* Bedeutet, dass die **Variable nicht neu zugewiesen** werden kann.
* Der Wert selbst bleibt aber oft **mutierbar** (bei Objekten/Arrays).
* Typ wird **verallgemeinert** (z. B. `string`, `number`).

```js
const role = "admin"
// Typ: string (kein Literal), Wert: "admin"
```

---

#### **2. `as const` (TypeScript)**

* Erzwingt eine **Literal Inferenz**:

  * Der Wert bekommt den **engsten möglichen Typ** (statt `string` → `"admin"`).
* Macht **alle Properties readonly** (bei Objekten und Arrays).

```js
const role = "admin" as const
// Typ: "admin" (Literal), Wert: "admin"
```

---

### Beispiele

#### **Beispiel 1 – String vs. Literal**

```js
const status = "success"
// Typ: string

const status2 = "success" as const
// Typ: "success" (Literal)
```

---

#### **Beispiel 2 – Objekte**

```js
const user = { id: 1, role: "admin" }
// Typ: { id: number; role: string }

const user2 = { id: 1, role: "admin" } as const
// Typ: { readonly id: 1; readonly role: "admin" }
```

---

#### **Beispiel 3 – Arrays**

```js
const numbers = [1, 2, 3]
// Typ: number[]

const numbers2 = [1, 2, 3] as const
// Typ: readonly [1, 2, 3]
```

---

### **Vergleichstabelle**

| Aspekt           | `const`                              | `as const`                              |
| ---------------- | ------------------------------------ | --------------------------------------- |
| Variablenbindung | unveränderlich                       | unveränderlich                          |
| Typ-Inferenz     | allgemeiner Typ (`string`, `number`) | Literal-Typ (`"admin"`, `1`)            |
| Objekte/Arrays   | veränderbar                          | `readonly`                              |
| Einsatzgebiet    | normales JS-Verhalten                | für präzise Typisierung & Immutabilität |

---

### Zusammenfassung

* **`const`** = normale Konstantenbindung, Typ wird verallgemeinert.
* **`as const`** = engste mögliche Typen (Literal), zusätzlich `readonly`.
* Nützlich für:

  * **Discriminated Unions**
  * **Objekte/Arrays als feste Konfigurationen**
  * **Props in React**

🔗 Quellen:

* [TypeScript Handbook – const assertions](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-inference)
* [React TS Cheatsheet – as const](https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase#literal-types-as-const)

  **[⬆ Наверх](#top)**

33. ### <a name="33"></a> Was macht der Operator satisfies (TS 4.9+)?

### Der `satisfies` Operator in TypeScript (seit 4.9)

**Definition:**
Der Operator **`satisfies`** prüft, ob ein Wert einen bestimmten Typ erfüllt (**Type Constraint**), **ohne** den engeren Typ des Werts zu verlieren.
Er ist eine Art *Kompromiss zwischen Type Assertion (`as`) und direkter Typannotation (`: Type`)*.

---

### Beispiel 1 – Normale Typannotation

```ts
type Role = "admin" | "user" | "guest"

const role: Role = "admin"
// Typ von role: "admin" | "user" | "guest"
```

👉 Nach der Annotation verliert `role` den spezifischen Literal-Typ `"admin"` und wird zum Union-Type.

---

### Beispiel 2 – Mit `as` (unsafe)

```ts
const role = "admin" as Role
// Typ von role: Role ("admin" | "user" | "guest")
```

👉 Compiler nimmt an, dass es passt – aber kein echter Check, da `as` nur „erzwingt“.

---

### Beispiel 3 – Mit `satisfies` ✅

```ts
type Role = "admin" | "user" | "guest"

const role = "admin" satisfies Role
// Typ von role: "admin" (Literal bleibt erhalten)
// Compiler prüft: "admin" ist Teil von Role → ✅ korrekt
```

👉 Vorteil: Wert bleibt **eng getypt** (`"admin"`) und erfüllt trotzdem die Bedingung `Role`.

---

### Beispiel 4 – Praktisch bei Objekten

```ts
type Config = {
  url: string
  method: "GET" | "POST"
}

const config = {
  url: "/api",
  method: "GET"
} satisfies Config

// Typ von config.method = "GET" (Literal, nicht nur "GET" | "POST")
```

👉 Mit `: Config` wäre `config.method` nur `"GET" | "POST"`.
👉 Mit `satisfies` bleibt es `"GET"`.

---

### Beispiel 5 – Exhaustiveness Checks

```ts
type Status = "success" | "error" | "loading"

const states = ["success", "error", "loading"] satisfies Status[]
// Typ: ("success" | "error" | "loading")[]
// Compiler prüft: alle Elemente gehören zu Status
```

---

### Zusammenfassung

* **`satisfies`** prüft, ob ein Wert zu einem Typ passt, **ohne den präzisen Typ zu verlieren**.
* Unterschied zu anderen Varianten:

  * `: Type` → Typ wird erweitert/verallgemeinert.
  * `as Type` → Compiler vertraut blind, keine echte Prüfung.
  * `satisfies Type` → Typprüfung + Beibehaltung der Literaltypen.

🔗 Quellen:

* [TypeScript 4.9 – satisfies Operator](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html#the-satisfies-operator)
* [React TS Cheatsheet – satisfies](https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase#satisfies-operator)

  **[⬆ Наверх](#top)**

34. ### <a name="34"></a> Was sind Assertion Functions?

### Assertion Functions in TypeScript

**Definition:**
Eine **Assertion Function** ist eine spezielle Funktion, die TypeScript mitteilt:
*"Wenn diese Funktion erfolgreich zurückkehrt, kannst du davon ausgehen, dass eine bestimmte Bedingung erfüllt ist."*
→ Sie werden mit dem Rückgabetyp `asserts` deklariert und dienen der **Typprüfung** (Type Narrowing).

---

### Beispiel 1 – Einfache Assertion Function

```ts
function assertIsString(value: unknown): asserts value is string {
  if (typeof value !== "string") {
    throw new Error("Wert ist kein String")
  }
}

function printUppercase(value: unknown) {
  assertIsString(value) 
  // Ab hier: value hat Typ string
  console.log(value.toUpperCase())
}
```

➡️ Ohne `assertIsString` müsste man jedes Mal manuell prüfen.

---

### Beispiel 2 – Non-Null Assertion

```ts
function assertNotNull<T>(value: T): asserts value is NonNullable<T> {
  if (value === null || value === undefined) {
    throw new Error("Wert darf nicht null oder undefined sein")
  }
}

function process(value?: string | null) {
  assertNotNull(value)
  // Ab hier: value ist string
  console.log(value.trim())
}
```

---

### Beispiel 3 – Für komplexe Typen

```ts
type User = { id: number; name: string }

function assertIsUser(obj: any): asserts obj is User {
  if (typeof obj !== "object" || typeof obj.id !== "number" || typeof obj.name !== "string") {
    throw new Error("Kein gültiger User")
  }
}

const data: unknown = { id: 1, name: "Sergii" }

assertIsUser(data)
// Ab hier: data hat Typ User
console.log(data.name.toUpperCase())
```

---

### Vorteile

* Verhindern unnötige Type Assertions (`as`).
* Ermöglichen **saubere Typ Narrowing**.
* Praktisch für **Input-Validierung, API-Responses, Guards in React/Express**.

---

### Zusammenfassung

* **Assertion Functions** = Funktionen mit Rückgabetyp `asserts`, die Typen validieren.
* Nutzen: automatische Typ-Einschränkung, wenn die Assertion erfolgreich ist.
* Typische Form: `asserts value is Type`.

🔗 Quellen:

* [TypeScript Handbook – Assertion Functions](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#assertion-functions)
* [React TS Cheatsheet – Type Guards & Assertions](https://react-typescript-cheatsheet.netlify.app/docs/basic/troubleshooting/types/#user-defined-type-guards)

  **[⬆ Наверх](#top)**

35. ### <a name="35"></a> Was ist der Unterschied zwischen struktureller Typisierung (structural typing) und nominaler Typisierung (nominal typing)?

### Unterschied zwischen **struktureller Typisierung** und **nominaler Typisierung**

---

#### **1. Strukturelle Typisierung (Structural Typing)**

* In **TypeScript** verwendet.
* Zwei Typen sind **kompatibel**, wenn ihre **Struktur** (Shape) gleich ist – unabhängig vom Namen.
* „Duck Typing“: *Wenn es aussieht wie eine Ente und quakt wie eine Ente, ist es eine Ente.*

**Beispiel:**

```ts
interface Point {
  x: number
  y: number
}

interface Coordinate {
  x: number
  y: number
}

let p: Point = { x: 10, y: 20 }
let c: Coordinate = { x: 30, y: 40 }

p = c // ✅ erlaubt, gleiche Struktur
```

---

#### **2. Nominale Typisierung (Nominal Typing)**

* In Sprachen wie **Java, C#** üblich.
* Typen sind nur dann kompatibel, wenn sie **explizit denselben Namen** oder dieselbe Vererbung haben.
* Die Struktur allein reicht nicht.

**Beispiel (in TS simuliert):**

```ts
type USD = number & { readonly brand: unique symbol }
type EUR = number & { readonly brand: unique symbol }

let usd: USD = 10 as USD
let eur: EUR = 20 as EUR

usd = eur // ❌ Fehler, trotz gleicher Struktur (Nominalisierung durch unique symbol)
```

---

### Vergleich

| Merkmal             | Strukturell (TS)                        | Nominal (Java, C#)      |
| ------------------- | --------------------------------------- | ----------------------- |
| Vergleichsgrundlage | Struktur (Properties & Methoden)        | Name/Erklärung des Typs |
| Flexibilität        | Hoch                                    | Niedrig                 |
| Fehleranfälligkeit  | Kann ungewollte Kompatibilität zulassen | Strenger, sicherer      |
| Beispielsprachen    | TypeScript, Go                          | Java, C#, Rust          |

---

### Zusammenfassung

* **Structural Typing (TS):** Kompatibilität hängt nur von der **Form** ab.
* **Nominal Typing:** Kompatibilität hängt vom **Namen/Erklärung** ab.
* TypeScript ist **strukturell typisiert**, man kann aber nominale Typisierung mit Tricks (`unique symbol`) erzwingen.

🔗 Quellen:

* [TypeScript Handbook – Structural Typing](https://www.typescriptlang.org/docs/handbook/type-compatibility.html)
* [MDN – TypeScript Type System](https://www.typescriptlang.org/docs/)

  **[⬆ Наверх](#top)**

36. ### <a name="36"></a> Was sind Deklarationsdateien (.d.ts)?

### Deklarationsdateien (`.d.ts`) in TypeScript

**Definition:**
Eine **Deklarationsdatei** (`.d.ts`) enthält **nur Typinformationen** (Signaturen, Interfaces, Typen), aber **keinen ausführbaren Code**.
Sie dient dazu, JavaScript-Bibliotheken oder bereits kompilierte TypeScript-Module für den TypeScript-Compiler **typisiert verfügbar** zu machen.

---

### Eigenschaften

* Endung: **`.d.ts`**
* Enthält keine Implementierungen → nur Typdefinitionen.
* Wird automatisch von TypeScript verwendet, wenn eine Bibliothek Typen mitliefert.
* Häufig im Verzeichnis `@types/` (z. B. aus **DefinitelyTyped**).

---

### Beispiel 1 – Eigene Deklarationsdatei

`math.d.ts`:

```ts
declare module "math-lib" {
  export function add(a: number, b: number): number
  export const PI: number
}
```

Nutzung:

```ts
import { add, PI } from "math-lib"

console.log(add(2, 3))  // 5
console.log(PI)         // number
```

---

### Beispiel 2 – Globale Deklaration

```ts
// global.d.ts
declare global {
  interface Window {
    myAppVersion: string
  }
}
```

Nutzung:

```ts
console.log(window.myAppVersion)
```

---

### Beispiel 3 – Typen für externe Bibliotheken

Wenn eine JS-Library keine Typen mitliefert:

```bash
npm install @types/lodash --save-dev
```

👉 Installiert Deklarationsdateien von **DefinitelyTyped**.

---

### Zusammenfassung

* **`.d.ts` Dateien** = Typdefinitionen ohne Implementierung.
* Nutzen: Typprüfung und IntelliSense für **JS-Bibliotheken** oder eigene APIs.
* Typische Orte:

  * Bibliotheken mitgeliefert (`node_modules/@types/`)
  * Eigene Projekte (`global.d.ts`)

🔗 Quellen:

* [TypeScript Handbook – Declaration Files](https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html)
* [DefinitelyTyped Repository](https://github.com/DefinitelyTyped/DefinitelyTyped)

  **[⬆ Наверх](#top)**

37. ### <a name="37"></a> Wie bindet man eine externe JS-Bibliothek ohne Typen ein?

### Externe JS-Bibliothek **ohne Typen** in TypeScript einbinden

#### 1) Prüfen, ob Typen existieren

```bash
npm i -D @types/<libname>
```

Wenn vorhanden → normal importieren. Wenn **nicht** vorhanden, weiter mit 2–5.

---

#### 2) Schneller Start: eigenes **Shims**-Modul (`global.d.ts` oder `types/<lib>.d.ts`)

```ts
// types/untyped-lib.d.ts
declare module "untyped-lib" {
  // minimaler Start – alles als any
  const api: any
  export default api
}
```

Verwendung:

```js
import lib from "untyped-lib"
lib.doSomething() // Typprüfung ausgesetzt (any)
```

---

#### 3) Besser: **gezielte Typen** statt `any`

```ts
// types/untyped-lib.d.ts
declare module "untyped-lib" {
  export interface Options {
    retry?: number
    baseUrl: string
  }
  export function createClient(opts: Options): {
    get(path: string): Promise<string>
    post<T>(path: string, body: T): Promise<void>
  }
}
```

```js
import { createClient } from "untyped-lib"

const client = createClient({ baseUrl: "/api", retry: 2 })
const text = await client.get("/status")
```

---

#### 4) Globales Script (CDN) typisieren

```ts
// global.d.ts
declare global {
  interface Window {
    MyLib: {
      version: string
      init(config: { key: string }): void
    }
  }
}
export {} // macht die Datei zum Modul
```

```js
// nach <script src=".../mylib.js"></script>
window.MyLib.init({ key: "abc" })
```

---

#### 5) Übergangsweise absichern: `unknown` + Laufzeit-Guards (statt `any`)

```js
import lib from "untyped-lib"

function isClient(x: unknown): x is { get: (p: string) => Promise<string> } {
  return !!x && typeof (x as any).get === "function"
}

const client: unknown = lib.createClient?.({ baseUrl: "/api" })
if (isClient(client)) {
  const s = await client.get("/health")
}
```

---

#### 6) Notfalls (kurzfristig) unterdrücken

```js
// @ts-ignore: untyped third-party export
import lib from "untyped-lib"
```

> Nur punktuell verwenden; besser früh eigene `.d.ts` anlegen.

---

#### 7) tsconfig-Hinweise

* Eigene Typen einbinden: `"typeRoots": ["./types", "./node_modules/@types"]`
* Keine Fremdtypfehler beim Build: `"skipLibCheck": true` (optional, nicht sicherheitsrelevant)

---

### Zusammenfassung

* Falls keine offiziellen Typen existieren: **eigene `.d.ts`** schreiben.
* Start mit einfachem `declare module`, dann **gezielt typisieren** (Interfaces/Funktionssignaturen).
* Für globale Skripte: **`declare global`**.
* **`unknown` + Type Guards** statt `any` für mehr Sicherheit.
* `@ts-ignore` nur ausnahmsweise.

🔗 Quellen:

* [TypeScript Docs – Declaration Files](https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html)
* [TypeScript Docs – Modules & `declare module`](https://www.typescriptlang.org/docs/handbook/modules.html)
* [React TypeScript Cheatsheet – Working with 3rd-Party Libs](https://react-typescript-cheatsheet.netlify.app/docs/basic/troubleshooting/types/#third-party-libraries)
* [MDN – `window`](https://developer.mozilla.org/ru/docs/Web/API/Window)

  **[⬆ Наверх](#top)**

38. ### <a name="38"></a> Was sind Ambient Declarations (declare)?

### Ambient Declarations (`declare`) in TypeScript

**Definition:**
Ambient Declarations sind **Typdefinitionen für bereits existierenden Code** (meist JavaScript), damit der TypeScript-Compiler weiß, welche Variablen, Funktionen oder Module es gibt – auch wenn sie **nicht in TypeScript implementiert** sind.
👉 Sie enthalten **nur Typinformationen**, aber keine Implementierungen.

---

### 1. Globale Variablen deklarieren

```ts
// global.d.ts
declare const VERSION: string
```

Nutzung:

```ts
console.log(VERSION) // Compiler weiß: VERSION ist string
```

---

### 2. Funktionen deklarieren

```ts
declare function logMessage(message: string): void

logMessage("Hallo") // gültig, auch ohne Implementierung in TS
```

---

### 3. Klassen deklarieren

```ts
declare class Person {
  constructor(name: string)
  greet(): void
}

let p = new Person("Sergii")
p.greet()
```

---

### 4. Module deklarieren

```ts
// math-lib.d.ts
declare module "math-lib" {
  export function add(a: number, b: number): number
}
```

Nutzung:

```ts
import { add } from "math-lib"
console.log(add(2, 3))
```

---

### 5. Namespace / Global erweitern

```ts
declare namespace NodeJS {
  interface ProcessEnv {
    NODE_ENV: "development" | "production"
  }
}
```

---

### Wann verwendet?

✅ Typische Einsatzfälle:

* **Externe JS-Bibliotheken ohne Typen** (eigene `.d.ts`).
* **Globale Variablen/Objekte** (z. B. `window`, `process`).
* **Erweiterung von bestehenden Typen** (z. B. Express `Request`).

---

### Zusammenfassung

* **Ambient Declarations (`declare`)** = reine Typinfos ohne Code.
* Nutzen: Beschreiben von vorhandenen Variablen, Funktionen, Klassen oder Modulen.
* Typische Orte: **`.d.ts`-Dateien**, Third-Party-Libs, globale Variablen.

🔗 Quellen:

* [TypeScript Handbook – Declaration Files](https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html)
* [TypeScript Handbook – Ambient Declarations](https://www.typescriptlang.org/docs/handbook/declaration-files/by-example.html)

  **[⬆ Наверх](#top)**

39. ### <a name="39"></a> Was ist strict mode in TypeScript?

### Strict Mode in TypeScript

**Definition:**
Der **Strict Mode** ist eine Sammlung von Compiler-Optionen in TypeScript, die die **strengste Typprüfung** aktivieren.
Er wird mit `"strict": true` in der `tsconfig.json` eingeschaltet.

---

### Enthaltene Optionen (ab Werk in `strict` enthalten)

1. **`strictNullChecks`**

   * `null` und `undefined` müssen explizit behandelt werden.

   ```ts
   let name: string = "Sergii"
   name = null // ❌ Fehler bei strictNullChecks
   ```

2. **`noImplicitAny`**

   * Variablen oder Parameter ohne Typ dürfen nicht automatisch `any` sein.

   ```ts
   function log(msg) { // ❌ Fehler
     console.log(msg)
   }
   ```

3. **`strictBindCallApply`**

   * Typprüfung für Methoden wie `bind`, `call`, `apply`.

4. **`strictFunctionTypes`**

   * Strengere Überprüfung bei Funktionszuweisungen.

5. **`strictPropertyInitialization`**

   * Klassen-Eigenschaften müssen im Konstruktor oder direkt initialisiert werden.

   ```ts
   class User {
     name: string // ❌ Fehler ohne Initialisierung
     constructor(name: string) {
       this.name = name // ✅
     }
   }
   ```

6. **`alwaysStrict`**

   * Alle Dateien werden im **JavaScript Strict Mode** kompiliert (`"use strict"`).

---

### Vorteile

* Weniger Laufzeitfehler durch strengere Typprüfung.
* Sicherere und besser wartbare Codebasis.
* Erhöht Codequalität besonders in großen Projekten.

---

### Zusammenfassung

* **Strict Mode** (`"strict": true`) = aktiviert alle wichtigen Sicherheitsprüfungen des Compilers.
* Beinhaltet u. a. `strictNullChecks`, `noImplicitAny`, `strictPropertyInitialization`.
* Ziel: maximale Typ-Sicherheit und Fehlervermeidung.

🔗 Quellen:

* [TypeScript Handbook – Strict Mode](https://www.typescriptlang.org/tsconfig#strict)
* [TSConfig Reference – Strict Options](https://www.typescriptlang.org/tsconfig#strictNullChecks)

  **[⬆ Наверх](#top)**

40. ### <a name="40"></a> Wozu dient strictNullChecks?

### `strictNullChecks` in TypeScript

**Definition:**
Die Option **`strictNullChecks`** erzwingt, dass `null` und `undefined` **nicht automatisch jedem Typ zugewiesen** werden dürfen.
👉 Ohne diese Option: `null` und `undefined` sind **Teil aller Typen**.
👉 Mit dieser Option: sie müssen **explizit** erlaubt werden (`| null`, `| undefined`).

---

### Beispiel 1 – Ohne `strictNullChecks` (unsicher)

```ts
let name: string = "Sergii"
name = null       // ✅ erlaubt (unsicher)
```

---

### Beispiel 2 – Mit `strictNullChecks: true` (sicher)

```ts
let name: string = "Sergii"
name = null       // ❌ Fehler: null nicht zuweisbar zu string

let safeName: string | null = "Sergii"
safeName = null   // ✅ erlaubt
```

---

### Beispiel 3 – Funktionen

```ts
function greet(user: string | null) {
  if (user !== null) {
    console.log("Hallo", user.toUpperCase())
  }
}

greet(null) // ✅ funktioniert, sicher geprüft
```

---

### Beispiel 4 – Optional Properties

```ts
interface User {
  id: number
  email?: string
}

function printEmail(user: User) {
  // user.email: string | undefined
  if (user.email) {
    console.log(user.email.toUpperCase())
  }
}
```

---

### Zusammenfassung

* **`strictNullChecks`** verhindert, dass `null` und `undefined` stillschweigend überall zugewiesen werden können.
* Erzwingt **explizite Behandlung** von `null` und `undefined`.
* Vorteil: weniger `Cannot read property of undefined`-Fehler zur Laufzeit.

🔗 Quellen:

* [TypeScript Handbook – strictNullChecks](https://www.typescriptlang.org/tsconfig#strictNullChecks)
* [Everyday Types – null & undefined](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#null-and-undefined)

  **[⬆ Наверх](#top)**  

41. ### <a name="41"></a> Wie typisiert man Parameter und Rückgabewerte von Funktionen?

### Funktionen typisieren: Parameter & Rückgabewerte

#### 1) Basis: Parameter- und Rückgabetyp

```js
// ESM-Export
export function add(a: number, b: number): number {
  return a + b
}
```

#### 2) Arrow Functions

```js
export const toUpper = (s: string): string => s.toUpperCase()
```

#### 3) Optional-, Default- und Rest-Parameter

```js
export function greet(name: string, title?: string): string {
  return title ? `${title} ${name}` : `Hallo ${name}`
}

export function pow(base: number, exp: number = 2): number {
  return base ** exp
}

export function sum(...nums: number[]): number {
  return nums.reduce((acc, n) => acc + n, 0)
}
```

#### 4) Void, Never, Union/Unknown in Signaturen

```js
export function log(msg: string): void {
  console.log(msg) // kein Rückgabewert
}

export function fail(message: string): never {
  throw new Error(message) // kehrt nie zurück
}

export function parseJson(json: string): unknown {
  return JSON.parse(json) // Callsite muss narrowen
}
```

#### 5) Funktions-Typen (Alias/Interface)

```js
export type Comparator<T> = (a: T, b: T) => number

export interface Fetcher {
  (url: string): Promise<string>
}

export const byLength: Comparator<string> = (a, b) => a.length - b.length
```

#### 6) Generische Funktionen

```js
export function identity<T>(value: T): T {
  return value
}

export function pick<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key]
}
```

#### 7) Async/Promise-Rückgaben

```js
export async function getText(url: string): Promise<string> {
  const res = await fetch(url)
  return res.text()
}
```

#### 8) Overloads (mehrere Signaturen, eine Implementierung)

```js
export function len(x: string): number
export function len<T>(x: T[]): number
export function len(x: string | unknown[]): number {
  return (x as any).length
}
```

#### 9) Kontext: React-Event-Handler (häufig im Frontend)

```js
// Beispiel: React + TS (ESM)
import type { ChangeEvent } from "react"

export const onChange = (e: ChangeEvent<HTMLInputElement>): void => {
  console.log(e.currentTarget.value)
}
```

---

### Zusammenfassung

* Parameter werden nach dem Namen, Rückgabewerte nach dem Parameterblock typisiert: `fn(a: A, b: B): R`.
* Verwende optionale (`?`), Default- und Rest-Parameter je nach Bedarf.
* Nutze `void`/`never` zielgerichtet; für unbekannte Rückgaben `unknown` + Narrowing.
* Funktions-Typen per **Type Alias** oder **Call-Signature in Interfaces**; Generics für Wiederverwendbarkeit.
* Overloads: mehrere Signaturen, **eine** Implementierung.
* In React Events streng typisieren (z. B. `ChangeEvent<HTMLInputElement>`).

**Quellen:**

* [TypeScript Docs – Functions](https://www.typescriptlang.org/docs/handbook/2/functions.html)
* [TypeScript Docs – Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
* [React TypeScript Cheatsheet – Event Handling](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/event_handling/)
* [MDN – Functions (JS-Grundlagen)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Functions)
* [React Docs](https://react.dev/)

  **[⬆ Наверх](#top)**

42. ### <a name="42"></a> Was sind optionale Parameter in Funktionen?

### Optionale Parameter in TypeScript-Funktionen

**Definition:**
Ein **optionaler Parameter** ist ein Funktionsparameter, der beim Aufruf **nicht zwingend angegeben** werden muss.
Man kennzeichnet ihn mit einem **Fragezeichen (`?`)** nach dem Parameternamen.

---

### Beispiel 1 – Einfacher optionaler Parameter

```ts
export function greet(name: string, title?: string): string {
  return title ? `${title} ${name}` : `Hallo ${name}`
}

greet("Sergii")            // Hallo Sergii
greet("Sergii", "Herr")    // Herr Sergii
```

➡️ `title` ist optional (`string | undefined`).

---

### Beispiel 2 – Kombination mit Default-Werten

```ts
export function pow(base: number, exp: number = 2): number {
  return base ** exp
}

pow(3)      // 9
pow(3, 3)   // 27
```

➡️ Unterschied: `?` → kann fehlen, `= Default` → hat immer einen Wert.

---

### Beispiel 3 – Mehrere optionale Parameter

```ts
export function createUser(id: number, name?: string, age?: number) {
  return { id, name, age }
}

createUser(1)                // { id: 1 }
createUser(2, "Anna")        // { id: 2, name: "Anna" }
createUser(3, "Tom", 25)     // { id: 3, name: "Tom", age: 25 }
```

---

### Einschränkungen

* Optionale Parameter müssen **am Ende der Parameterliste** stehen.
* Sie sind implizit `Typ | undefined`.

---

### Zusammenfassung

* **Optionale Parameter** (`param?: Type`) = Argumente, die beim Funktionsaufruf nicht zwingend übergeben werden müssen.
* Standardmäßig sind sie `Type | undefined`.
* Typischer Einsatz: flexible APIs, optionale Konfigurationen.

🔗 Quellen:

* [TypeScript Handbook – Functions](https://www.typescriptlang.org/docs/handbook/2/functions.html#optional-parameters)
* [MDN – Functions](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Functions)

  **[⬆ Наверх](#top)**

43. ### <a name="43"></a> Wie deklariert man Standardwerte für Parameter mit Typisierung?

### Standardwerte (Default Parameter) mit Typisierung in TypeScript

**Definition:**
Ein **Default-Parameter** ist ein Funktionsparameter, der einen **Standardwert** erhält, falls kein Argument übergeben wird.
In TypeScript wird der Typ entweder automatisch aus dem Standardwert **inferred** oder explizit angegeben.

---

### Beispiel 1 – Automatische Typinferenz

```ts
export function greet(name: string, title = "Herr"): string {
  return `${title} ${name}`
}

greet("Sergii")          // Herr Sergii
greet("Sergii", "Dr.")   // Dr. Sergii
```

➡️ `title` wird automatisch als `string` typisiert, weil der Standardwert `"Herr"` ist.

---

### Beispiel 2 – Explizite Typannotation

```ts
export function pow(base: number, exp: number = 2): number {
  return base ** exp
}

pow(3)    // 9
pow(3, 3) // 27
```

➡️ `exp: number = 2` → expliziter Typ + Default-Wert.

---

### Beispiel 3 – Union-Typ mit Default

```ts
type Role = "admin" | "user" | "guest"

export function createUser(name: string, role: Role = "user") {
  return { name, role }
}

createUser("Sergii")          // role = "user"
createUser("Anna", "admin")   // role = "admin"
```

---

### Beispiel 4 – Kombination mit Optionalem Parameter (selten nötig)

```ts
export function log(msg?: string, level: "info" | "error" = "info") {
  console.log(`[${level}]`, msg ?? "leer")
}
```

---

### Regeln

* Parameter mit Default-Werten sind **implizit optional**.
* Sie müssen nicht am Ende der Parameterliste stehen (anders als `?`).
* Typ wird **vom Wert oder Annotation** bestimmt.

---

### Zusammenfassung

* Default-Parameter = `param: Typ = Wert`.
* Typ wird entweder **inferred** oder **explizit angegeben**.
* Vorteil: klare Signaturen, weniger `undefined`.

🔗 Quellen:

* [TypeScript Handbook – Functions](https://www.typescriptlang.org/docs/handbook/2/functions.html#optional-parameters)
* [MDN – Default Parameters](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Default_parameters)

  **[⬆ Наверх](#top)**

44. ### <a name="44"></a> Was sind Rest-Parameter und wie typisiert man sie?

### Rest-Parameter in TypeScript

**Definition:**
Rest-Parameter (`...`) erlauben es, **eine variable Anzahl von Argumenten** an eine Funktion zu übergeben.
Sie werden in TypeScript als **Array eines Typs** typisiert.

---

### Beispiel 1 – Einfache Typisierung

```ts
export function sum(...numbers: number[]): number {
  return numbers.reduce((acc, n) => acc + n, 0)
}

sum(1, 2, 3, 4) // 10
```

➡️ `numbers: number[]` → alle Argumente müssen `number` sein.

---

### Beispiel 2 – Strings

```ts
export function concat(...parts: string[]): string {
  return parts.join(" ")
}

concat("TypeScript", "macht", "Spaß")
```

---

### Beispiel 3 – Kombination mit festen Parametern

```ts
export function greet(greeting: string, ...names: string[]): string {
  return `${greeting}, ${names.join(" und ")}!`
}

greet("Hallo", "Sergii", "Anna") // Hallo, Sergii und Anna!
```

---

### Beispiel 4 – Generics für Rest-Parameter

```ts
export function first<T>(...items: T[]): T {
  return items[0]
}

const num = first(1, 2, 3)         // number
const str = first("a", "b", "c")   // string
```

---

### Beispiel 5 – Tupel als Rest-Parameter (variadische Tupel, TS 4.0+)

```ts
type Point = [number, number]

export function logCoordinates(...coords: Point) {
  const [x, y] = coords
  console.log(`X=${x}, Y=${y}`)
}

logCoordinates(10, 20)
```

➡️ Rest-Parameter können auch **feste Strukturen** (Tupel) erzwingen.

---

### Zusammenfassung

* **Rest-Parameter** = `...args: Typ[]`.
* Erfassen variable Argumentlisten als Array.
* Erweiterbar mit **Generics** und **Tupeln** (seit TS 4.0).
* Typische Nutzung: Utility-Funktionen, Logging, flexible APIs.

🔗 Quellen:

* [TypeScript Handbook – Functions (Rest Parameters)](https://www.typescriptlang.org/docs/handbook/2/functions.html#rest-parameters-and-arguments)
* [MDN – Rest Parameters](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/rest_parameters)

  **[⬆ Наверх](#top)**

45. ### <a name="45"></a> Wie typisiert man Arrow Functions?

### Arrow Functions in TypeScript typisieren

Arrow Functions werden in TypeScript genauso typisiert wie normale Funktionen – nur mit der **Lambda-Syntax**.

---

### 1. Parameter- und Rückgabetyp explizit

```ts
export const add = (a: number, b: number): number => {
  return a + b
}
```

---

### 2. Typinferenz (Compiler erkennt den Rückgabewert selbst)

```ts
export const double = (x: number) => x * 2
// Rückgabewert: number (inferred)
```

---

### 3. Funktions-Typ mit Type Alias

```ts
type Comparator = (a: number, b: number) => number

export const compare: Comparator = (a, b) => a - b
```

---

### 4. Funktions-Typ mit Interface

```ts
interface Logger {
  (msg: string): void
}

export const log: Logger = (message) => console.log(message)
```

---

### 5. Arrow Function mit Generics

```ts
export const identity = <T>(value: T): T => value

const s = identity("Sergii") // string
const n = identity(42)       // number
```

---

### 6. React-Event-Handler (sehr häufig)

```ts
import type { ChangeEvent } from "react"

export const handleChange = (e: ChangeEvent<HTMLInputElement>): void => {
  console.log(e.currentTarget.value)
}
```

---

### Zusammenfassung

* Arrow Functions typisiert man mit `(param: Typ): RückgabeTyp => {}`.
* Rückgabetyp kann oft **inferred** werden.
* Für Wiederverwendbarkeit: **Type Alias** oder **Interface** für Funktionssignaturen.
* Generics ermöglichen flexible Arrow Functions.
* In React wichtig: Eventtypen (`ChangeEvent<HTMLInputElement>` usw.).

🔗 Quellen:

* [TypeScript Handbook – Functions](https://www.typescriptlang.org/docs/handbook/2/functions.html)
* [React TypeScript Cheatsheet – Event Handling](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/event_handling/)

  **[⬆ Наверх](#top)**

46. ### <a name="46"></a> Was sind Funktionsüberladungen?

### Funktionsüberladungen (Function Overloads) in TypeScript

**Definition:**
Funktionsüberladungen erlauben es, für **eine Funktion mehrere Signaturen** zu definieren.
Der Aufrufer sieht unterschiedliche Signaturen, aber die **Implementierung existiert nur einmal**.
→ Damit kann eine Funktion verschiedene **Argumenttypen** und **Rückgabewerte** unterstützen.

---

### Beispiel 1 – String vs. Number

```ts
// Überladungen (Signaturen)
function reverse(value: string): string
function reverse(value: number): number

// Implementierung (gemeinsam)
function reverse(value: string | number): string | number {
  if (typeof value === "string") {
    return value.split("").reverse().join("")
  }
  return Number(value.toString().split("").reverse().join(""))
}

reverse("Sergii") // string → "iigreS"
reverse(12345)    // number → 54321
```

---

### Beispiel 2 – Mehrere Argumenttypen

```ts
function getLength(value: string): number
function getLength(value: any[]): number

function getLength(value: string | any[]): number {
  return value.length
}

getLength("Hallo")   // 5
getLength([1, 2, 3]) // 3
```

---

### Beispiel 3 – Unterschiedliche Rückgabewerte

```ts
function combine(a: number, b: number): number
function combine(a: string, b: string): string

function combine(a: number | string, b: number | string): number | string {
  if (typeof a === "string" && typeof b === "string") {
    return a + b // string
  }
  if (typeof a === "number" && typeof b === "number") {
    return a + b // number
  }
  throw new Error("Ungültige Argumente")
}
```

---

### Regeln für Overloads

* **Signaturen oben**, **Implementierung unten**.
* Implementierung muss alle Fälle abdecken.
* TypeScript wählt anhand der Argumente die passende Signatur.

---

### Zusammenfassung

* **Funktionsüberladungen** = mehrere Signaturen für eine Funktion.
* Nützlich für Funktionen, die mit verschiedenen Eingabetypen arbeiten.
* Syntax: `function name(param: Typ): RückgabeTyp` (mehrfach), dann eine gemeinsame Implementierung.

🔗 Quellen:

* [TypeScript Handbook – Function Overloads](https://www.typescriptlang.org/docs/handbook/2/functions.html#function-overloads)
* [React TS Cheatsheet – Functions](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example#function-overloads)

  **[⬆ Наверх](#top)**

47. ### <a name="47"></a> Was sind Generics?

### Generics in TypeScript

**Definition:**
**Generics** sind Platzhalter für Typen, die es ermöglichen, **flexiblen, wiederverwendbaren und typsicheren Code** zu schreiben.
Man definiert einen Typ erst **zur Nutzung**, nicht beim Schreiben der Funktion oder Klasse.

---

### Beispiel 1 – Generische Funktion

```ts
function identity<T>(value: T): T {
  return value
}

const num = identity(42)         // T = number
const str = identity("Sergii")   // T = string
```

👉 Der Typ `T` wird automatisch **inferred**.

---

### Beispiel 2 – Generisches Array

```ts
function getFirst<T>(arr: T[]): T {
  return arr[0]
}

getFirst([1, 2, 3])      // number
getFirst(["a", "b", "c"]) // string
```

---

### Beispiel 3 – Generics mit Einschränkungen (`extends`)

```ts
interface HasLength {
  length: number
}

function logLength<T extends HasLength>(item: T): void {
  console.log(item.length)
}

logLength("Hallo")       // string (hat length)
logLength([1, 2, 3])     // Array (hat length)
```

---

### Beispiel 4 – Mehrere Typ-Parameter

```ts
function pair<K, V>(key: K, value: V): [K, V] {
  return [key, value]
}

const entry = pair("id", 123) // [string, number]
```

---

### Beispiel 5 – Generics in Klassen

```ts
class Box<T> {
  content: T
  constructor(value: T) {
    this.content = value
  }
}

const stringBox = new Box("Text") // T = string
const numBox = new Box(99)        // T = number
```

---

### Beispiel 6 – Generics in React (häufig)

```tsx
import { useState } from "react"

const [count, setCount] = useState<number>(0)
```

👉 `useState<number>` ist ein generischer Hook.

---

### Zusammenfassung

* **Generics** = Typparameter (`<T>`) für wiederverwendbaren, typsicheren Code.
* Vorteile: Flexibilität + Typprüfung gleichzeitig.
* Einsatz: Funktionen, Klassen, Interfaces, React-Hooks.

🔗 Quellen:

* [TypeScript Handbook – Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
* [React TypeScript Cheatsheet – Generics](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/hooks/#generic-hooks)

  **[⬆ Наверх](#top)**

48. ### <a name="48"></a> Wie erstellt man eine generische Funktion?

### Generische Funktion in TypeScript erstellen

**Definition:**
Eine **generische Funktion** nutzt Typparameter (`<T>`), um flexibel mit unterschiedlichen Typen zu arbeiten, ohne die Typ-Sicherheit zu verlieren.

---

### 1. Syntax – einfaches Beispiel

```ts
export function identity<T>(value: T): T {
  return value
}

const num = identity(42)        // T = number
const str = identity("Sergii")  // T = string
```

👉 `T` ist ein Platzhalter, der beim Aufruf ersetzt wird.

---

### 2. Mit Arrays

```ts
export function firstElement<T>(arr: T[]): T {
  return arr[0]
}

const n = firstElement([1, 2, 3])     // number
const s = firstElement(["a", "b", "c"]) // string
```

---

### 3. Mehrere Typparameter

```ts
export function pair<K, V>(key: K, value: V): [K, V] {
  return [key, value]
}

const entry = pair("id", 123) // [string, number]
```

---

### 4. Einschränkungen mit `extends`

```ts
interface HasLength {
  length: number
}

export function logLength<T extends HasLength>(item: T): void {
  console.log(item.length)
}

logLength("Hallo")   // string ✅
logLength([1, 2, 3]) // number[] ✅
```

---

### 5. Default-Typen

```ts
export function toArray<T = string>(value: T): T[] {
  return [value]
}

const a = toArray("hi")   // string[]
const b = toArray(42)     // number[]
const c = toArray()       // string[] (Default)
```

---

### Zusammenfassung

* Generische Funktionen nutzt man mit `<T>` oder mehreren Parametern (`<K, V>`).
* Vorteil: **flexibel + typsicher**.
* Erweiterbar mit `extends` (Constraints) oder Defaults.
* Typische Einsatzgebiete: Utility-Funktionen, Datenstrukturen, React-Hooks.

🔗 Quellen:

* [TypeScript Handbook – Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
* [React TypeScript Cheatsheet – Generics](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/hooks/#generic-hooks)

  **[⬆ Наверх](#top)**

49. ### <a name="49"></a> Was sind Generic Constraints (extends)?

### Generic Constraints (`extends`) in TypeScript

**Definition:**
Mit **Generic Constraints** (`extends`) kann man den **Gültigkeitsbereich** eines Generics einschränken.
👉 Ohne Constraint: `T` kann *alles* sein.
👉 Mit Constraint: `T` muss bestimmte Eigenschaften haben oder von einem Typ erben.

---

### 1. Einfaches Constraint

```ts
function logLength<T extends { length: number }>(item: T): void {
  console.log(item.length)
}

logLength("Hallo")       // string ✅
logLength([1, 2, 3])     // number[] ✅
// logLength(123)        // ❌ Fehler: number hat kein length
```

➡️ `T` muss ein Objekt mit `length: number` sein.

---

### 2. Constraint auf Interface

```ts
interface User {
  id: number
  name: string
}

function getName<T extends User>(obj: T): string {
  return obj.name
}

getName({ id: 1, name: "Sergii" }) // ✅
```

➡️ `T` muss mindestens die Struktur von `User` haben.

---

### 3. Constraint auf Union-Typ

```ts
type Role = "admin" | "user" | "guest"

function setRole<T extends Role>(role: T) {
  console.log(`Neue Rolle: ${role}`)
}

setRole("admin") // ✅
setRole("root")  // ❌ Fehler
```

---

### 4. Mehrere Constraints (`extends` + `extends`)

```ts
function merge<T extends object, U extends object>(a: T, b: U): T & U {
  return { ...a, ...b }
}

const obj = merge({ id: 1 }, { role: "admin" })
// Typ: { id: number } & { role: string }
```

---

### 5. Generics mit `keyof` Constraint

```ts
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key]
}

const user = { id: 1, name: "Sergii" }
getProperty(user, "name") // string
// getProperty(user, "age") ❌ Fehler
```

➡️ `K` darf nur ein Schlüssel von `T` sein.

---

### Zusammenfassung

* **Generic Constraints (`extends`)** = Eingrenzung, welche Typen ein Generic akzeptieren darf.
* Ermöglicht: Zugriff auf Eigenschaften, sichere Schlüsselprüfung, Wiederverwendbarkeit.
* Typische Muster: `extends {}`, `extends Interface`, `extends keyof T`.

🔗 Quellen:

* [TypeScript Handbook – Generic Constraints](https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-constraints)
* [React TypeScript Cheatsheet – Generics](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/hooks/#generic-hooks)

  **[⬆ Наверх](#top)**

50. ### <a name="50"></a> Wie funktioniert T extends keyof U?

### `T extends keyof U` in TypeScript

**Definition:**
`T extends keyof U` bedeutet:
👉 `T` darf nur Werte annehmen, die **ein Schlüssel von `U`** sind.
So lassen sich Generics auf gültige Property-Namen einschränken.

---

### Beispiel 1 – Grundprinzip

```ts
interface User {
  id: number
  name: string
  isAdmin: boolean
}

function getProperty<T extends keyof User>(obj: User, key: T): User[T] {
  return obj[key]
}

const u: User = { id: 1, name: "Sergii", isAdmin: true }

getProperty(u, "name")    // ✅ string
getProperty(u, "isAdmin") // ✅ boolean
// getProperty(u, "age")  // ❌ Fehler: "age" ist kein Schlüssel von User
```

---

### Beispiel 2 – Generische Objektfunktion

```ts
function pluck<T, K extends keyof T>(obj: T, keys: K[]): T[K][] {
  return keys.map(key => obj[key])
}

const user = { id: 1, name: "Sergii", active: true }

const values = pluck(user, ["id", "name"])
// Typ: (string | number)[]
```

---

### Beispiel 3 – Rückgabewerte typisieren

```ts
type Person = { name: string; age: number }

function pickValue<T extends keyof Person>(key: T): Person[T] {
  const dummy: Person = { name: "Anna", age: 25 }
  return dummy[key]
}

const age = pickValue("age")   // number
const name = pickValue("name") // string
```

---

### Beispiel 4 – Kombination mit `Record`

```ts
function mapObject<T, K extends keyof T>(obj: T, keys: K[]): Record<K, T[K]> {
  const result = {} as Record<K, T[K]>
  keys.forEach(k => {
    result[k] = obj[k]
  })
  return result
}

const person = { id: 1, name: "Tom", active: true }
const subset = mapObject(person, ["id", "active"])
// Typ: { id: number; active: boolean }
```

---

### Zusammenfassung

* `keyof U` = Union aller Schlüssel von `U`.
* `T extends keyof U` = `T` darf nur einer dieser Schlüssel sein.
* Einsatz: **Property-Zugriffe, `pluck`/`getProperty`-Utilities, sichere Schlüssel-Prüfungen.**

🔗 Quellen:

* [TypeScript Handbook – keyof and Lookup Types](https://www.typescriptlang.org/docs/handbook/2/keyof-types.html)
* [TypeScript Generics – Constraints](https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-constraints)

  **[⬆ Наверх](#top)**  

51. ### <a name="51"></a> Was sind Utility Types (Partial, Pick, Omit, Record usw.)?

### Utility Types in TypeScript

**Definition:**
Utility Types sind vordefinierte Generics, die bestehende Typen **transformieren oder anpassen**.
Sie sparen Boilerplate und erhöhen die Typ-Sicherheit.

---

## 🔑 Die wichtigsten Utility Types

### 1. **`Partial<T>`**

Macht alle Eigenschaften von `T` optional.

```ts
interface User {
  id: number
  name: string
}

type PartialUser = Partial<User>
// { id?: number; name?: string }
```

---

### 2. **`Required<T>`**

Macht alle Eigenschaften von `T` verpflichtend.

```ts
interface User {
  id?: number
  name?: string
}

type RequiredUser = Required<User>
// { id: number; name: string }
```

---

### 3. **`Readonly<T>`**

Macht alle Eigenschaften von `T` schreibgeschützt.

```ts
interface User {
  id: number
  name: string
}

type ReadonlyUser = Readonly<User>
// { readonly id: number; readonly name: string }
```

---

### 4. **`Pick<T, K>`**

Wählt bestimmte Eigenschaften aus `T`.

```ts
interface User {
  id: number
  name: string
  email: string
}

type UserPreview = Pick<User, "id" | "name">
// { id: number; name: string }
```

---

### 5. **`Omit<T, K>`**

Entfernt bestimmte Eigenschaften aus `T`.

```ts
type UserWithoutEmail = Omit<User, "email">
// { id: number; name: string }
```

---

### 6. **`Record<K, T>`**

Erzeugt ein Objekt mit Schlüsseln vom Typ `K` und Werten vom Typ `T`.

```ts
type Role = "admin" | "user" | "guest"

type RolePermissions = Record<Role, boolean>
// { admin: boolean; user: boolean; guest: boolean }
```

---

### 7. **`Exclude<T, U>`**

Entfernt aus `T` alle Typen, die auch in `U` enthalten sind.

```ts
type Status = "success" | "error" | "loading"
type WithoutLoading = Exclude<Status, "loading">
// "success" | "error"
```

---

### 8. **`Extract<T, U>`**

Beinhaltet nur die Typen, die in beiden enthalten sind.

```ts
type A = "a" | "b" | "c"
type B = "b" | "c" | "d"

type Common = Extract<A, B> // "b" | "c"
```

---

### 9. **`NonNullable<T>`**

Entfernt `null` und `undefined`.

```ts
type Value = string | null | undefined
type SafeValue = NonNullable<Value>
// string
```

---

### 10. **`ReturnType<T>`**

Ermittelt den Rückgabetyp einer Funktion.

```ts
function getUser() {
  return { id: 1, name: "Sergii" }
}

type User = ReturnType<typeof getUser>
// { id: number; name: string }
```

---

### 11. **`Parameters<T>`**

Ermittelt die Parametertypen einer Funktion als Tupel.

```ts
function login(user: string, password: string) {}

type LoginParams = Parameters<typeof login>
// [user: string, password: string]
```

---

### Zusammenfassung

* **Utility Types** = vordefinierte Generics für schnelle Typtransformation.
* Häufige Kandidaten: `Partial`, `Required`, `Readonly`, `Pick`, `Omit`, `Record`.
* Weitere mächtige Tools: `Exclude`, `Extract`, `NonNullable`, `ReturnType`, `Parameters`.
* Typischer Einsatz: **Modelle anpassen, DTOs, React-Props, API-Typisierung.**

🔗 Quellen:

* [TypeScript Handbook – Utility Types](https://www.typescriptlang.org/docs/handbook/utility-types.html)
* [React TS Cheatsheet – Utility Types](https://react-typescript-cheatsheet.netlify.app/docs/advanced/utility_types/)

  **[⬆ Наверх](#top)**

52. ### <a name="52"></a> Was ist der Unterschied zwischen Partial<T> und Required<T>?

### Unterschied zwischen `Partial<T>` und `Required<T>` in TypeScript

---

### **1. `Partial<T>`**

* Macht **alle Properties** eines Typs **optional** (`?`).
* Typische Nutzung: bei **Update-Objekten** (z. B. nur einige Felder eines Users ändern).

```ts
interface User {
  id: number
  name: string
  email: string
}

type PartialUser = Partial<User>
// { id?: number; name?: string; email?: string }

const updateUser: PartialUser = { name: "Sergii" } // ✅ nur name
```

---

### **2. `Required<T>`**

* Macht **alle Properties** eines Typs **pflichtig** (auch solche, die ursprünglich optional waren).
* Typische Nutzung: wenn du sicherstellen willst, dass **komplette Daten** übergeben werden.

```ts
interface User {
  id?: number
  name?: string
  email?: string
}

type RequiredUser = Required<User>
// { id: number; name: string; email: string }

const fullUser: RequiredUser = {
  id: 1,
  name: "Sergii",
  email: "sergii@mail.com"
} // ✅ alles Pflicht
```

---

### **Vergleichstabelle**

| Utility Type  | Wirkung                              | Beispiel                         |
| ------------- | ------------------------------------ | -------------------------------- |
| `Partial<T>`  | Alle Properties werden **optional**  | `{ id?: number; name?: string }` |
| `Required<T>` | Alle Properties werden **pflichtig** | `{ id: number; name: string }`   |

---

### Zusammenfassung

* **`Partial<T>`** = macht alle Felder **optional** → nützlich für Updates oder Teilobjekte.
* **`Required<T>`** = macht alle Felder **zwingend** → nützlich für Validierung oder vollständige Daten.

🔗 Quellen:

* [TypeScript Handbook – Utility Types](https://www.typescriptlang.org/docs/handbook/utility-types.html)

  **[⬆ Наверх](#top)**

53. ### <a name="53"></a> Wie funktioniert Readonly<T>?

### `Readonly<T>` in TypeScript

**Definition:**
Der Utility Type **`Readonly<T>`** macht **alle Eigenschaften** eines Typs **schreibgeschützt** (`readonly`).
Das bedeutet: einmal gesetzte Werte können nicht mehr verändert werden.

---

### Beispiel 1 – Einfaches Interface

```ts
interface User {
  id: number
  name: string
}

type ReadonlyUser = Readonly<User>
// { readonly id: number; readonly name: string }

const u: ReadonlyUser = { id: 1, name: "Sergii" }

u.name = "Anna" // ❌ Fehler: name ist readonly
```

---

### Beispiel 2 – Readonly Arrays

```ts
const numbers: Readonly<number[]> = [1, 2, 3]

numbers.push(4)   // ❌ Fehler: push existiert nicht
numbers[0] = 99   // ❌ Fehler
```

Alternative:

```ts
const tuple: Readonly<[number, number]> = [10, 20]
```

---

### Beispiel 3 – In Kombination mit `Partial`

```ts
interface Config {
  host: string
  port: number
}

type ImmutableConfig = Readonly<Partial<Config>>
// { readonly host?: string; readonly port?: number }
```

---

### Beispiel 4 – Praktisch in React (Props)

```tsx
type ButtonProps = Readonly<{
  label: string
  onClick: () => void
}>

// Props sind automatisch readonly → Schutz vor Änderungen
const Button = (props: ButtonProps) => {
  // props.label = "Neu" ❌ nicht erlaubt
  return <button onClick={props.onClick}>{props.label}</button>
}
```

---

### Zusammenfassung

* **`Readonly<T>`** → macht alle Felder **immutable** (nur lesbar).
* Nützlich für: **Props in React**, Konfigurationen, sichere Datenmodelle.
* Kombination mit anderen Utility Types (`Partial`, `Pick`, etc.) sehr mächtig.

🔗 Quellen:

* [TypeScript Handbook – Readonly](https://www.typescriptlang.org/docs/handbook/utility-types.html#readonlytype)
* [React TS Cheatsheet – Props Readonly](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example/#readonly-and-const)

  **[⬆ Наверх](#top)**

54. ### <a name="54"></a> Wie funktionieren Pick<T, K> und Omit<T, K>?

### `Pick<T, K>` und `Omit<T, K>` in TypeScript

Beide sind **Utility Types**, die auf bestehenden Typen basieren.
👉 `Pick` = bestimmte Properties auswählen
👉 `Omit` = bestimmte Properties ausschließen

---

### **1. Pick<T, K>**

* Baut aus Typ `T` einen neuen Typ mit **nur den ausgewählten Keys `K`**.

```ts
interface User {
  id: number
  name: string
  email: string
  isAdmin: boolean
}

type UserPreview = Pick<User, "id" | "name">
// { id: number; name: string }

const preview: UserPreview = { id: 1, name: "Sergii" }
```

---

### **2. Omit<T, K>**

* Baut aus Typ `T` einen neuen Typ mit **allen Properties außer `K`**.

```ts
type UserWithoutEmail = Omit<User, "email" | "isAdmin">
// { id: number; name: string }

const simpleUser: UserWithoutEmail = { id: 2, name: "Anna" }
```

---

### **3. Vergleich**

```ts
// Pick -> nur bestimmte Eigenschaften
type OnlyName = Pick<User, "name">
// { name: string }

// Omit -> bestimmte Eigenschaften entfernen
type WithoutName = Omit<User, "name">
// { id: number; email: string; isAdmin: boolean }
```

---

### **4. Typische Einsatzgebiete**

* **Pick**: DTOs, kurze Vorschau-Typen (z. B. für UI).
* **Omit**: Typen für "Create" oder "Update", wenn bestimmte Felder nicht erlaubt sind.

```ts
// Beispiel: API CreateUser ohne id und isAdmin
type CreateUserDto = Omit<User, "id" | "isAdmin">
```

---

### Zusammenfassung

* **`Pick<T, K>`** → erstellt neuen Typ mit **nur K** aus T.
* **`Omit<T, K>`** → erstellt neuen Typ mit **allen außer K**.
* Sehr nützlich für **DTOs, API-Modelle, React-Props**.

🔗 Quellen:

* [TypeScript Handbook – Utility Types](https://www.typescriptlang.org/docs/handbook/utility-types.html)
* [React TS Cheatsheet – Utility Types](https://react-typescript-cheatsheet.netlify.app/docs/advanced/utility_types/)

  **[⬆ Наверх](#top)**

55. ### <a name="55"></a> Was macht Record<K, T>?

### `Record<K, T>` in TypeScript

**Definition:**
`Record<K, T>` erstellt einen **Objekttyp**, bei dem:

* alle Schlüssel (`K`) denselben Typ haben,
* und die Werte vom Typ `T` sind.

Es ist eine **kurze Schreibweise** für Objekte mit einheitlichen Keys/Werten.

---

### Beispiel 1 – Einfache Verwendung

```ts
type Role = "admin" | "user" | "guest"

type RolePermissions = Record<Role, boolean>
// { admin: boolean; user: boolean; guest: boolean }

const permissions: RolePermissions = {
  admin: true,
  user: false,
  guest: false
}
```

---

### Beispiel 2 – Index als Zahl

```ts
type ScoreBoard = Record<number, string>

const scores: ScoreBoard = {
  1: "Anna",
  2: "Sergii"
}
```

---

### Beispiel 3 – Mit komplexen Werten

```ts
interface User {
  id: number
  name: string
}

type UserDictionary = Record<string, User>

const users: UserDictionary = {
  a1: { id: 1, name: "Anna" },
  b2: { id: 2, name: "Sergii" }
}
```

---

### Beispiel 4 – Kombination mit `keyof`

```ts
interface Config {
  host: string
  port: number
}

type ConfigMap = Record<keyof Config, string>
// { host: string; port: string }
```

---

### Vergleich zu **Index Signatures**

```ts
// Mit Index Signature
type Dict = { [key: string]: number }

// Mit Record
type Dict2 = Record<string, number>
```

👉 Beide ähnlich – aber `Record` ist **kürzer** und wird oft bevorzugt.

---

### Zusammenfassung

* **`Record<K, T>`** = Objekt mit Schlüsseln aus `K` und Werten vom Typ `T`.
* Kurzform für Dictionaries und Maps.
* Praktisch für **Mappings, Lookups, Konfigurationen**.

🔗 Quellen:

* [TypeScript Handbook – Record](https://www.typescriptlang.org/docs/handbook/utility-types.html#recordkeys-type)
* [React TS Cheatsheet – Record](https://react-typescript-cheatsheet.netlify.app/docs/advanced/utility_types/)

  **[⬆ Наверх](#top)**

56. ### <a name="56"></a> Was macht ReturnType<T>?

### `ReturnType<T>` in TypeScript

**Definition:**
Der Utility Type **`ReturnType<T>`** extrahiert den **Rückgabewert-Typ** einer Funktion.
👉 `T` muss dabei eine **Funktionssignatur** oder der Typ einer Funktion sein.

---

### Beispiel 1 – Einfache Funktion

```ts
function getUser() {
  return { id: 1, name: "Sergii" }
}

type User = ReturnType<typeof getUser>
// { id: number; name: string }

const u: User = { id: 2, name: "Anna" }
```

---

### Beispiel 2 – Mit Arrow Function

```ts
const add = (a: number, b: number) => a + b

type SumReturn = ReturnType<typeof add>
// number
```

---

### Beispiel 3 – Async Funktionen

```ts
async function fetchData() {
  return { ok: true, data: [1, 2, 3] }
}

type FetchResult = ReturnType<typeof fetchData>
// Promise<{ ok: boolean; data: number[] }>
```

---

### Beispiel 4 – In Kombination mit `InstanceType`

```ts
class Person {
  constructor(public name: string) {}
}

function createPerson() {
  return new Person("Sergii")
}

type PersonReturn = ReturnType<typeof createPerson>
// Person
```

---

### Typischer Nutzen

* Vermeidung von **doppelter Typdefinition**.
* Rückgabewerte **automatisch ableiten**.
* Besonders nützlich bei **Utility-Funktionen**, **Hooks** in React oder **Factory Functions**.

---

### Zusammenfassung

* **`ReturnType<T>`** = extrahiert den Rückgabewert einer Funktion.
* Spart Boilerplate und verhindert Inkonsistenzen.
* Funktioniert mit normalen, Arrow- und async-Funktionen.

🔗 Quellen:

* [TypeScript Handbook – ReturnType](https://www.typescriptlang.org/docs/handbook/utility-types.html#returntypetype)
* [React TS Cheatsheet – Utility Types](https://react-typescript-cheatsheet.netlify.app/docs/advanced/utility_types/)

  **[⬆ Наверх](#top)**

57. ### <a name="57"></a> Was macht Parameters<T>?

### `Parameters<T>` in TypeScript

**Definition:**
Der Utility Type **`Parameters<T>`** extrahiert die **Parametertypen** einer Funktion als **Tupel**.
👉 `T` muss eine Funktion oder Funktionssignatur sein.

---

### Beispiel 1 – Normale Funktion

```ts
function login(user: string, password: string) {}

type LoginParams = Parameters<typeof login>
// [user: string, password: string]

const args: LoginParams = ["Sergii", "1234"]
login(...args) // ✅ korrekt
```

---

### Beispiel 2 – Arrow Function

```ts
const add = (a: number, b: number) => a + b

type AddParams = Parameters<typeof add>
// [a: number, b: number]
```

---

### Beispiel 3 – Optional & Default Parameter

```ts
function greet(name: string, title?: string) {}

type GreetParams = Parameters<typeof greet>
// [name: string, title?: string | undefined]
```

---

### Beispiel 4 – Async Funktion

```ts
async function fetchData(url: string, retries: number) {
  return `Fetch: ${url} (${retries})`
}

type FetchParams = Parameters<typeof fetchData>
// [url: string, retries: number]
```

---

### Beispiel 5 – Generisch kombinieren

```ts
function callFn<T extends (...args: any[]) => any>(fn: T, ...args: Parameters<T>): ReturnType<T> {
  return fn(...args)
}

function multiply(x: number, y: number) {
  return x * y
}

const result = callFn(multiply, 3, 4) // number
```

---

### Zusammenfassung

* **`Parameters<T>`** = extrahiert Parametertypen als **Tupel**.
* Nützlich für **Wrapper-Funktionen**, **Middleware**, **Decorator-Pattern**.
* Oft in Kombination mit **`ReturnType<T>`**.

🔗 Quellen:

* [TypeScript Handbook – Parameters](https://www.typescriptlang.org/docs/handbook/utility-types.html#parameterstype)
* [React TS Cheatsheet – Utility Types](https://react-typescript-cheatsheet.netlify.app/docs/advanced/utility_types/)

  **[⬆ Наверх](#top)**

58. ### <a name="58"></a> Was macht ConstructorParameters<T>?

### `ConstructorParameters<T>` in TypeScript

**Definition:**
Der Utility Type **`ConstructorParameters<T>`** extrahiert die **Parameter-Typen eines Konstruktors** als **Tupel**.
👉 `T` muss ein Konstruktor-Typ (z. B. eine Klasse oder `new (...args) => any`) sein.

---

### Beispiel 1 – Einfache Klasse

```ts
class User {
  constructor(public id: number, public name: string) {}
}

type UserArgs = ConstructorParameters<typeof User>
// [id: number, name: string]

const args: UserArgs = [1, "Sergii"]
const u = new User(...args) // ✅
```

---

### Beispiel 2 – Mit optionalen Parametern

```ts
class Book {
  constructor(public title: string, public pages?: number) {}
}

type BookArgs = ConstructorParameters<typeof Book>
// [title: string, pages?: number | undefined]

const args: BookArgs = ["TS Handbook"]
const b = new Book(...args)
```

---

### Beispiel 3 – Factory Function mit ConstructorParameters

```ts
function createInstance<T extends new (...args: any) => any>(
  Ctor: T,
  ...args: ConstructorParameters<T>
): InstanceType<T> {
  return new Ctor(...args)
}

class Car {
  constructor(public brand: string, public year: number) {}
}

const myCar = createInstance(Car, "BMW", 2025) // Car
```

---

### Beispiel 4 – Mit eingebauten Klassen

```ts
type DateArgs = ConstructorParameters<typeof Date>
// [value?: string | number | Date]

const d = new Date(...(["2025-01-01"] as DateArgs))
```

---

### Zusammenfassung

* **`ConstructorParameters<T>`** = extrahiert **Konstruktor-Argumente** als Tupel.
* Einsatz: Factories, Wrapper, Dependency Injection.
* Nützlich in Kombination mit **`InstanceType<T>`**.

🔗 Quellen:

* [TypeScript Handbook – ConstructorParameters](https://www.typescriptlang.org/docs/handbook/utility-types.html#constructorparameterstype)
* [TypeScript Handbook – InstanceType](https://www.typescriptlang.org/docs/handbook/utility-types.html#instancetypetype)

  **[⬆ Наверх](#top)**

59. ### <a name="59"></a> Wie funktionieren Extract und Exclude?

### `Extract<T, U>` und `Exclude<T, U>` in TypeScript

Beide Utility Types arbeiten mit **Union Types** und helfen, Typen zu filtern.

---

## **1. `Exclude<T, U>`**

Entfernt aus `T` alle Typen, die auch in `U` enthalten sind.
👉 „Alles außer“

```ts
type Status = "success" | "error" | "loading"

type WithoutLoading = Exclude<Status, "loading">
// "success" | "error"
```

**Beispiel mit mehreren:**

```ts
type Letters = "a" | "b" | "c" | "d"

type WithoutBC = Exclude<Letters, "b" | "c">
// "a" | "d"
```

---

## **2. `Extract<T, U>`**

Behält nur die Typen aus `T`, die auch in `U` vorkommen.
👉 „Schnittmenge“

```ts
type Status = "success" | "error" | "loading"

type OnlyError = Extract<Status, "error" | "fatal">
// "error"
```

**Beispiel mit mehreren:**

```ts
type Letters = "a" | "b" | "c" | "d"

type OnlyBC = Extract<Letters, "b" | "c" | "z">
// "b" | "c"
```

---

## **Vergleichsübersicht**

| Utility Type    | Bedeutung                            | Beispiel     |                  |             |
| --------------- | ------------------------------------ | ------------ | ---------------- | ----------- |
| `Exclude<T, U>` | Entfernt Typen von `U` aus `T`       | `Exclude<"a" | "b", "b">`→`"a"` |             |
| `Extract<T, U>` | Behalte nur gemeinsame Typen mit `U` | `Extract<"a" | "b", "b"         | "c">`→`"b"` |

---

## **Praktische Anwendung**

* **`Exclude`**: Bestimmte Werte/Typszenarien ausschließen.

  ```ts
  type EventType = "click" | "change" | "hover"
  type NonInteractive = Exclude<EventType, "click">
  // "change" | "hover"
  ```
* **`Extract`**: Nur erlaubte Schnittmenge behalten.

  ```ts
  type AllEvents = "click" | "change" | "hover"
  type UiEvents = "click" | "hover"

  type Allowed = Extract<AllEvents, UiEvents>
  // "click" | "hover"
  ```

---

### Zusammenfassung

* **`Exclude<T, U>`** = entfernt Typen von `U` aus `T`.
* **`Extract<T, U>`** = behält nur gemeinsame Typen zwischen `T` und `U`.
* Einsatz: Union-Typen filtern, APIs einschränken, erlaubte/unerlaubte Werte modellieren.

🔗 Quellen:

* [TypeScript Handbook – Utility Types](https://www.typescriptlang.org/docs/handbook/utility-types.html)

  **[⬆ Наверх](#top)**

60. ### <a name="60"></a> Was macht NonNullable<T>?

### `NonNullable<T>` in TypeScript

**Definition:**
Der Utility Type **`NonNullable<T>`** entfernt **`null`** und **`undefined`** aus einem Typ.
👉 Praktisch, wenn man einen Typ sicher ohne diese beiden Werte verwenden möchte.

---

### Beispiel 1 – Einfacher Typ

```ts
type Value = string | null | undefined

type SafeValue = NonNullable<Value>
// string
```

---

### Beispiel 2 – Mit Union Types

```ts
type Status = "success" | "error" | null | undefined

type CleanStatus = NonNullable<Status>
// "success" | "error"
```

---

### Beispiel 3 – In Funktionen

```ts
function printName(name: NonNullable<string | null | undefined>) {
  console.log(name.toUpperCase())
}

printName("Sergii")   // ✅
printName(null)       // ❌ Fehler
```

---

### Beispiel 4 – In Kombination mit `strictNullChecks`

```ts
interface User {
  id: number
  email?: string | null
}

type SafeEmail = NonNullable<User["email"]>
// string
```

---

### Zusammenfassung

* **`NonNullable<T>`** = entfernt `null` und `undefined` aus Typ `T`.
* Typische Nutzung: Eingaben absichern, optionale Properties bereinigen, Union Types aufräumen.
* Besonders nützlich in Projekten mit **`strictNullChecks`**.

🔗 Quellen:

* [TypeScript Handbook – NonNullable](https://www.typescriptlang.org/docs/handbook/utility-types.html#nonnullabletype)

  **[⬆ Наверх](#top)**

61. ### <a name="61"></a> Wie deklariert man eine Klasse in TypeScript?

### Klassen in TypeScript deklarieren

In TypeScript funktionieren Klassen wie in JavaScript, können aber zusätzlich **Typen, Sichtbarkeiten und Interfaces** nutzen.

---

### 1. Basis-Syntax

```ts
export class Person {
  name: string
  age: number

  constructor(name: string, age: number) {
    this.name = name
    this.age = age
  }

  greet(): void {
    console.log(`Hallo, ich heiße ${this.name}`)
  }
}

const p = new Person("Sergii", 34)
p.greet() // Hallo, ich heiße Sergii
```

---

### 2. Sichtbarkeitsmodifikatoren

* **`public`** (Standard) → überall sichtbar
* **`private`** → nur in der Klasse sichtbar
* **`protected`** → in der Klasse und Subklassen sichtbar
* **`readonly`** → Wert nur im Konstruktor setzbar

```ts
class User {
  readonly id: number
  private password: string
  protected role: string
  public name: string

  constructor(id: number, name: string, password: string, role: string) {
    this.id = id
    this.name = name
    this.password = password
    this.role = role
  }
}
```

---

### 3. Verkürzte Schreibweise im Konstruktor

```ts
class Car {
  constructor(public brand: string, private year: number) {}
}

const c = new Car("BMW", 2025)
console.log(c.brand) // BMW
// console.log(c.year) ❌ Fehler: private
```

---

### 4. Vererbung (`extends`)

```ts
class Animal {
  move() {
    console.log("Bewegt sich")
  }
}

class Dog extends Animal {
  bark() {
    console.log("Wuff!")
  }
}

const d = new Dog()
d.move() // von Animal
d.bark() // von Dog
```

---

### 5. Abstrakte Klassen

```ts
abstract class Shape {
  abstract area(): number
}

class Square extends Shape {
  constructor(public side: number) {
    super()
  }

  area(): number {
    return this.side * this.side
  }
}
```

---

### 6. Klassen + Interfaces

```ts
interface Flyable {
  fly(): void
}

class Bird implements Flyable {
  fly() {
    console.log("Der Vogel fliegt")
  }
}
```

---

### Zusammenfassung

* Klassen werden mit `class` deklariert.
* **Features in TS:** Typisierung, Sichtbarkeitsmodifikatoren, `readonly`.
* Unterstützt: **Vererbung**, **abstrakte Klassen**, **Interfaces**.
* Vorteile: bessere Struktur und Typsicherheit gegenüber reinem JS.

🔗 Quellen:

* [TypeScript Handbook – Classes](https://www.typescriptlang.org/docs/handbook/2/classes.html)
* [MDN – Classes in JS](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes)

  **[⬆ Наверх](#top)**

62. ### <a name="62"></a> Was sind Zugriffsmodifikatoren (public, private, protected)?

### Zugriffsmodifikatoren in TypeScript (`public`, `private`, `protected`)

TypeScript erweitert JavaScript-Klassen um **Zugriffsmodifikatoren**, die steuern, **wo Eigenschaften und Methoden sichtbar sind**.

---

### 1. **public** (Standard)

* Zugriff von überall: innerhalb der Klasse, in Subklassen, von außen.
* Ist der **Default**, auch wenn man nichts angibt.

```ts
class User {
  public name: string
  constructor(name: string) {
    this.name = name
  }
}

const u = new User("Sergii")
console.log(u.name) // ✅ erlaubt
```

---

### 2. **private**

* Zugriff nur innerhalb der **gleichen Klasse**.
* Nicht von Subklassen oder von außen sichtbar.

```ts
class Account {
  private balance: number
  constructor(balance: number) {
    this.balance = balance
  }

  deposit(amount: number) {
    this.balance += amount
  }
}

const acc = new Account(100)
// acc.balance // ❌ Fehler: private
acc.deposit(50) // ✅ erlaubt
```

---

### 3. **protected**

* Zugriff in der Klasse **und in Subklassen**.
* Nicht von außen sichtbar.

```ts
class Animal {
  protected move() {
    console.log("Bewegt sich")
  }
}

class Dog extends Animal {
  bark() {
    this.move() // ✅ erlaubt, da protected
    console.log("Wuff!")
  }
}

const d = new Dog()
// d.move() ❌ Fehler
d.bark() // ✅ erlaubt
```

---

### 4. **readonly** (Sonderfall)

* Kein Zugriffsmodifikator, aber oft in Kombination genutzt.
* Wert darf **nur im Konstruktor oder bei Deklaration gesetzt** werden.

```ts
class Config {
  readonly version: string = "1.0"
}

const c = new Config()
// c.version = "2.0" ❌ Fehler
```

---

### Vergleichstabelle

| Modifikator | Zugriff in Klasse | Zugriff in Subklasse | Zugriff von außen |
| ----------- | ----------------- | -------------------- | ----------------- |
| `public`    | ✅                 | ✅                    | ✅                 |
| `protected` | ✅                 | ✅                    | ❌                 |
| `private`   | ✅                 | ❌                    | ❌                 |

---

### Zusammenfassung

* **public** = überall sichtbar (Default).
* **private** = nur in der Klasse.
* **protected** = in Klasse + Subklassen.
* **readonly** = Wert nicht änderbar (Ergänzung).

🔗 Quellen:

* [TypeScript Handbook – Classes](https://www.typescriptlang.org/docs/handbook/2/classes.html#public-private-and-protected-modifiers)

  **[⬆ Наверх](#top)**

63. ### <a name="63"></a> Was sind readonly-Eigenschaften in Klassen?

### `readonly` Eigenschaften in TypeScript-Klassen

**Definition:**
Eine **`readonly`-Eigenschaft** in einer Klasse kann **nur einmal** gesetzt werden:

* bei der **Deklaration**, oder
* im **Konstruktor**.

Danach ist sie **unveränderlich** (immutable).

---

### Beispiel 1 – `readonly` bei Deklaration

```ts
class Config {
  readonly version: string = "1.0"
}

const c = new Config()
// c.version = "2.0" ❌ Fehler: version ist readonly
```

---

### Beispiel 2 – `readonly` im Konstruktor

```ts
class User {
  readonly id: number
  name: string

  constructor(id: number, name: string) {
    this.id = id   // ✅ erlaubt
    this.name = name
  }
}

const u = new User(1, "Sergii")
u.name = "Anna"   // ✅ veränderbar
// u.id = 2       // ❌ Fehler: readonly
```

---

### Beispiel 3 – Kombination mit Modifikatoren

```ts
class Token {
  private readonly secret: string

  constructor(secret: string) {
    this.secret = secret
  }

  getSecret(): string {
    return this.secret // ✅ nur lesbar
  }
}
```

---

### Beispiel 4 – `readonly` Arrays (nicht tief eingefroren!)

```ts
class Data {
  readonly items: string[] = ["a", "b"]
}

const d = new Data()
d.items.push("c")    // ✅ erlaubt, weil Array selbst mutable
// d.items = []       // ❌ Fehler: Referenz ist readonly
```

👉 Für wirklich **immutable Arrays** → `ReadonlyArray<T>`.

---

### Zusammenfassung

* **`readonly`** = Eigenschaft ist nach Zuweisung nicht mehr überschreibbar.
* Initialisierung: in **Deklaration** oder im **Konstruktor**.
* Kombinierbar mit `public`, `private`, `protected`.
* Wichtig: bei Arrays/Objekten schützt es nur die **Referenz**, nicht den Inhalt.

🔗 Quellen:

* [TypeScript Handbook – Classes: readonly](https://www.typescriptlang.org/docs/handbook/2/classes.html#readonly)
* [MDN – const vs. readonly (Unterschied)](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#readonly-properties)

  **[⬆ Наверх](#top)**

64. ### <a name="64"></a> Wie deklariert man statische Eigenschaften und Methoden?

### Statische Eigenschaften und Methoden in TypeScript

**Definition:**
Mit dem Schlüsselwort **`static`** deklariert man **Eigenschaften oder Methoden**, die **zur Klasse selbst gehören**, nicht zu deren Instanzen.
👉 Zugriff erfolgt über den **Klassennamen**, nicht über `this`.

---

### 1. Statische Eigenschaft

```ts
class Config {
  static readonly version: string = "1.0"
}

console.log(Config.version) // ✅ Zugriff über Klasse
// new Config().version ❌ Fehler
```

---

### 2. Statische Methode

```ts
class MathUtils {
  static add(a: number, b: number): number {
    return a + b
  }
}

console.log(MathUtils.add(2, 3)) // 5
```

---

### 3. Kombination von static + private

```ts
class Counter {
  private static count = 0

  static increment(): number {
    return ++this.count
  }
}

console.log(Counter.increment()) // 1
console.log(Counter.increment()) // 2
```

---

### 4. Zugriff aus Instanzmethoden (z. B. Singleton-Pattern)

```ts
class Database {
  private static instance: Database

  private constructor() {}

  static getInstance(): Database {
    if (!Database.instance) {
      Database.instance = new Database()
    }
    return Database.instance
  }
}

const db1 = Database.getInstance()
const db2 = Database.getInstance()

console.log(db1 === db2) // true
```

---

### 5. Einschränkung: kein Zugriff über `this` in Instanzmethoden

```ts
class Example {
  static x = 10

  logX() {
    // console.log(this.x) ❌ Fehler
    console.log(Example.x) // ✅
  }
}
```

---

### Zusammenfassung

* **`static`** → gehört zur Klasse, nicht zur Instanz.
* Zugriff: **`Klassenname.member`**.
* Typische Nutzung: **Hilfsfunktionen, Konstanten, Singleton-Pattern, Counter, Factories**.

🔗 Quellen:

* [TypeScript Handbook – Classes: static](https://www.typescriptlang.org/docs/handbook/2/classes.html#static-members)
* [MDN – static keyword (JS)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes/static)

  **[⬆ Наверх](#top)**

65. ### <a name="65"></a> Was ist der Unterschied zwischen einer abstrakten und einer normalen Klasse?

### Unterschied: Abstrakte Klasse vs. Normale Klasse in TypeScript

---

### **1. Normale Klasse**

* Kann **direkt instanziiert** werden (`new`).
* Enthält **komplette Implementierungen** von Eigenschaften und Methoden.

```ts
class Person {
  constructor(public name: string) {}

  greet(): void {
    console.log(`Hallo, ich heiße ${this.name}`)
  }
}

const p = new Person("Sergii") // ✅ erlaubt
p.greet() // Hallo, ich heiße Sergii
```

---

### **2. Abstrakte Klasse**

* Kann **nicht direkt instanziiert** werden (`new` ist verboten).
* Kann **abstrakte Methoden** enthalten → nur **Signatur**, keine Implementierung.
* Dient als **Basisklasse** für Spezialisierungen.

```ts
abstract class Animal {
  constructor(public name: string) {}

  abstract makeSound(): void // nur Signatur

  move(): void {
    console.log(`${this.name} bewegt sich`)
  }
}

class Dog extends Animal {
  makeSound(): void {
    console.log("Wuff!")
  }
}

const d = new Dog("Bello") // ✅ erlaubt
d.makeSound() // Wuff!

// const a = new Animal("X") ❌ Fehler: abstrakte Klasse
```

---

### **3. Typische Nutzung von abstrakten Klassen**

* Gemeinsame **Grundlogik** in der Basisklasse.
* Unterschiedliche Subklassen müssen **abstrakte Methoden implementieren**.
* Beispiel: **Template Method Pattern**, **Basis-Modelle** in OOP.

---

### **Vergleichstabelle**

| Merkmal            | Normale Klasse    | Abstrakte Klasse                          |
| ------------------ | ----------------- | ----------------------------------------- |
| Instanziierung     | ✅ möglich (`new`) | ❌ nicht möglich                           |
| Abstrakte Methoden | ❌ nicht erlaubt   | ✅ erlaubt (Signatur ohne Body)            |
| Implementierung    | ✅ vollständig     | ✅ teilweise + abstrakte Methoden          |
| Einsatz            | konkrete Objekte  | Basis für Spezialisierungen (Polymorphie) |

---

### Zusammenfassung

* **Normale Klasse** = vollständige Implementierung, direkt instanziierbar.
* **Abstrakte Klasse** = kann nicht instanziiert werden, enthält evtl. abstrakte Methoden, zwingt Subklassen zur Implementierung.
* Einsatz: **OOP-Design, Polymorphismus, Code-Wiederverwendung**.

🔗 Quellen:

* [TypeScript Handbook – Classes: abstract](https://www.typescriptlang.org/docs/handbook/2/classes.html#abstract-classes)
* [MDN – Classes](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes)

  **[⬆ Наверх](#top)**

66. ### <a name="66"></a> Kann man Interfaces mit Klassen implementieren?

### Interfaces mit Klassen implementieren

**Antwort:**
Ja ✅ — eine Klasse kann ein oder mehrere **Interfaces implementieren**, indem sie deren Struktur erfüllt.
👉 Interfaces definieren nur die **Form** (keine Implementierung).
👉 Klassen müssen dann **alle Eigenschaften und Methoden** implementieren.

---

### Beispiel 1 – Einfaches Interface

```ts
interface Greetable {
  name: string
  greet(): void
}

class Person implements Greetable {
  constructor(public name: string) {}

  greet(): void {
    console.log(`Hallo, ich heiße ${this.name}`)
  }
}

const p = new Person("Sergii")
p.greet() // Hallo, ich heiße Sergii
```

---

### Beispiel 2 – Mehrere Interfaces

```ts
interface CanRun {
  run(): void
}

interface CanJump {
  jump(): void
}

class Athlete implements CanRun, CanJump {
  run(): void {
    console.log("Ich laufe")
  }
  jump(): void {
    console.log("Ich springe")
  }
}
```

---

### Beispiel 3 – Interface als Vertrag für Klassen

```ts
interface Repository<T> {
  getAll(): T[]
  add(item: T): void
}

class UserRepository implements Repository<string> {
  private users: string[] = []

  getAll(): string[] {
    return this.users
  }

  add(user: string): void {
    this.users.push(user)
  }
}
```

---

### Regeln

* `implements` = **Interface einhalten**.
* Anders als `extends` → keine Vererbung von Implementierung, nur von **Struktur**.
* Klassen können **mehrere Interfaces** implementieren, aber nur **eine Klasse** erweitern.

---

### Zusammenfassung

* **Interfaces + Klassen** = Vertrag + konkrete Umsetzung.
* Syntax: `class X implements InterfaceA, InterfaceB`.
* Typisch für: Architektur, Code-Wiederverwendung, Polymorphismus.

🔗 Quellen:

* [TypeScript Handbook – Classes: implements](https://www.typescriptlang.org/docs/handbook/2/classes.html#implements-clauses)

  **[⬆ Наверх](#top)**

67. ### <a name="67"></a> Was ist der Unterschied zwischen implements und extends?

### Unterschied: `implements` vs. `extends` in TypeScript

---

### **1. `extends`**

* Wird für **Vererbung** genutzt.
* Eine Klasse kann **nur eine andere Klasse** erweitern.
* Subklasse erbt **Eigenschaften + Methoden** der Superklasse.

```ts
class Animal {
  move() {
    console.log("Bewegt sich")
  }
}

class Dog extends Animal {
  bark() {
    console.log("Wuff!")
  }
}

const d = new Dog()
d.move() // von Animal
d.bark() // von Dog
```

---

### **2. `implements`**

* Wird genutzt, um eine Klasse an ein **Interface** (oder mehrere) zu binden.
* Klasse muss alle **Properties und Methoden-Signaturen** des Interfaces implementieren.
* Interfaces geben nur die **Struktur** vor, keine Logik.

```ts
interface Flyable {
  fly(): void
}

class Bird implements Flyable {
  fly() {
    console.log("Der Vogel fliegt")
  }
}
```

---

### **3. Kombination**

Eine Klasse kann **gleichzeitig** eine Klasse erweitern und Interfaces implementieren.

```ts
interface Swimmable {
  swim(): void
}

class Animal {
  eat() {
    console.log("Frisst")
  }
}

class Fish extends Animal implements Swimmable {
  swim() {
    console.log("Schwimmt")
  }
}
```

---

### **Vergleichstabelle**

| Merkmal         | `extends`                        | `implements`                            |
| --------------- | -------------------------------- | --------------------------------------- |
| Zweck           | Vererbung (Code wiederverwenden) | Vertrag erfüllen (Struktur einhalten)   |
| Quelle          | Klasse oder abstrakte Klasse     | Interface(s)                            |
| Mehrfachnutzung | Nur **eine** Superklasse möglich | Mehrere Interfaces gleichzeitig möglich |
| Enthält Logik   | ✅ Ja                             | ❌ Nur Signaturen                        |

---

### Zusammenfassung

* **`extends`** = Vererbung: Klasse erbt Implementierungen.
* **`implements`** = Vertrag: Klasse muss Interface erfüllen.
* Kombination möglich: `class X extends Y implements Z`.

🔗 Quellen:

* [TypeScript Handbook – Classes](https://www.typescriptlang.org/docs/handbook/2/classes.html)
* [TypeScript Handbook – Interfaces](https://www.typescriptlang.org/docs/handbook/2/objects.html)

  **[⬆ Наверх](#top)**

68. ### <a name="68"></a> Was ist this und wie typisiert man es?

### `this` in TypeScript

**Definition:**
`this` verweist im Kontext einer Funktion oder Methode auf das **aktuelle Objekt**, in dem die Funktion ausgeführt wird.
In TypeScript kann man `this` **explizit typisieren**, um Typ-Sicherheit zu gewährleisten.

---

## 1. `this` in Klassen

Automatisch auf die **Instanz** der Klasse gebunden.

```ts
class User {
  name: string
  constructor(name: string) {
    this.name = name
  }

  greet(): void {
    console.log(`Hallo, ich bin ${this.name}`)
  }
}

const u = new User("Sergii")
u.greet() // Hallo, ich bin Sergii
```

👉 Hier ist `this: User`.

---

## 2. `this` als expliziter Typ in Funktionen

Man kann `this` als **ersten Pseudoparameter** typisieren.

> Wichtig: Dieser Parameter existiert nur für die Typprüfung, nicht im Runtime-Code!

```ts
interface User {
  name: string
}

function greet(this: User, greeting: string) {
  console.log(`${greeting}, ich bin ${this.name}`)
}

const u: User = { name: "Anna" }
greet.call(u, "Hallo") // Hallo, ich bin Anna
```

👉 Ohne `this: User` würde `this.name` einen Fehler auslösen.

---

## 3. Arrow Functions und `this`

Arrow Functions **binden kein eigenes `this`**, sondern übernehmen es aus dem umgebenden Kontext.

```ts
class Counter {
  count = 0

  // normales this -> muss gebunden werden
  incNormal() {
    setTimeout(function () {
      // console.log(this.count) ❌ Fehler
    }, 1000)
  }

  // Arrow Function -> this bleibt auf Instanz gebunden
  incArrow() {
    setTimeout(() => {
      this.count++  // ✅ korrekt
      console.log(this.count)
    }, 1000)
  }
}
```

---

## 4. `this` als Rückgabewert (Fluent API)

Man kann `this` typisieren, damit Methoden **Method Chaining** unterstützen.

```ts
class Builder {
  private content: string = ""

  add(text: string): this {
    this.content += text
    return this // Typ = Builder
  }

  print(): void {
    console.log(this.content)
  }
}

new Builder().add("Hallo ").add("Welt!").print()
```

---

## 5. Typische Nutzung in Generics (`this` Types)

TypeScript erlaubt **polymorphe this-Typen** für bessere Rückgabetypen.

```ts
class Base {
  withBase(): this {
    return this
  }
}

class Sub extends Base {
  withSub(): this {
    return this
  }
}

const obj = new Sub().withBase().withSub() // ✅ Sub
```

---

### Zusammenfassung

* `this` = aktuelles Objekt im Kontext.
* Typisierbar: `function fn(this: Typ, ...)`.
* In **Klassen** automatisch Instanz-Typ.
* **Arrow Functions** → übernehmen `this` vom äußeren Kontext.
* Unterstützt **Method Chaining** via `this`-Rückgabetyp.

🔗 Quellen:

* [TypeScript Handbook – this parameters](https://www.typescriptlang.org/docs/handbook/2/functions.html#this-parameters)
* [MDN – this (JavaScript)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/this)

  **[⬆ Наверх](#top)**

69. ### <a name="69"></a> Kann man generische Klassen erstellen?

### Generische Klassen in TypeScript

**Antwort:**
Ja ✅ — Klassen können wie Funktionen **Generics** verwenden.
👉 Damit können Klassen flexibel mit unterschiedlichen Typen arbeiten, ohne die Typ-Sicherheit zu verlieren.

---

## 1. Einfache generische Klasse

```ts
class Box<T> {
  private content: T

  constructor(value: T) {
    this.content = value
  }

  getContent(): T {
    return this.content
  }
}

const stringBox = new Box("Hallo") // Box<string>
const numBox = new Box(42)         // Box<number>

console.log(stringBox.getContent()) // Hallo
console.log(numBox.getContent())    // 42
```

---

## 2. Generische Klasse mit mehreren Typ-Parametern

```ts
class Pair<K, V> {
  constructor(public key: K, public value: V) {}
}

const entry = new Pair("id", 123) // Pair<string, number>
```

---

## 3. Mit `extends` (Constraints)

```ts
interface Identifiable {
  id: number
}

class Repository<T extends Identifiable> {
  private items: T[] = []

  add(item: T) {
    this.items.push(item)
  }

  getById(id: number): T | undefined {
    return this.items.find(item => item.id === id)
  }
}

const repo = new Repository<{ id: number; name: string }>()
repo.add({ id: 1, name: "Sergii" })
console.log(repo.getById(1)) // { id: 1, name: "Sergii" }
```

---

## 4. Generische Klassen + Interfaces

```ts
interface Storage<T> {
  add(item: T): void
  getAll(): T[]
}

class MemoryStorage<T> implements Storage<T> {
  private items: T[] = []

  add(item: T): void {
    this.items.push(item)
  }

  getAll(): T[] {
    return this.items
  }
}

const store = new MemoryStorage<string>()
store.add("Hello")
store.add("World")
console.log(store.getAll()) // ["Hello", "World"]
```

---

### Zusammenfassung

* **Generische Klassen** = Klassen mit Typparametern (`class MyClass<T> {}`).
* Erlauben **flexible, typsichere Datenstrukturen** (z. B. Box, Repository, Storage).
* Unterstützen mehrere Typparameter (`<K, V>`), Constraints (`extends`) und Implementierungen von Interfaces.

🔗 Quellen:

* [TypeScript Handbook – Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-classes)

  **[⬆ Наверх](#top)**

70. ### <a name="70"></a> Wie erstellt man ein React-Projekt mit TypeScript?

### Schnellstart: React + TypeScript

#### **Option A – Vite (empfohlen, schnell & leicht)**

```bash
# Node 18+ empfohlen
npm create vite@latest my-app -- --template react-ts
cd my-app
npm install
npm run dev
```

**Beispiel-Komponente**

```js
// src/components/Hello.tsx
import { useState } from "react"

export function Hello({ name }: { name: string }) {
  const [count, setCount] = useState<number>(0)
  return (
    <button onClick={() => setCount((c) => c + 1)}>
      Hallo {name}! Klicks: {count}
    </button>
  )
}
```

**Pfadalias (optional)**

```js
// tsconfig.json (Auszug)
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": { "@/*": ["src/*"] },
    "strict": true,
    "jsx": "react-jsx"
  }
}
```

```js
// vite.config.ts (Auszug)
import { defineConfig } from "vite"
import react from "@vitejs/plugin-react"
import path from "node:path"

export default defineConfig({
  plugins: [react()],
  resolve: { alias: { "@": path.resolve(__dirname, "src") } }
})
```

---

#### **Option B – Next.js (SSR/SSG, Full-stack)**

```bash
npx create-next-app@latest my-app --ts
cd my-app
npm run dev
```

**Client-Komponente**

```js
// app/page.tsx (Next.js App Router)
export default function Page() {
  return <h1>Hallo Next.js + TypeScript</h1>
}
```

---

### Typische TS/React-Patterns

**Props & Events**

```js
// src/components/Input.tsx
import type { ChangeEvent } from "react"

export function Input({ onChange }: { onChange: (v: string) => void }) {
  const handle = (e: ChangeEvent<HTMLInputElement>) => onChange(e.target.value)
  return <input onChange={handle} />
}
```

**Generische Utility-Komponente**

```js
// src/components/List.tsx
export function List<T>({ items, render }: { items: T[]; render: (x: T) => JSX.Element }) {
  return <ul>{items.map(render)}</ul>
}
```

---

### Qualität & DX (optional, kurz)

* **ESLint/Prettier**

  ```bash
  npm i -D eslint @typescript-eslint/{parser,eslint-plugin} prettier
  ```
* **Strict** aktiv lassen (`"strict": true`) für bessere Typprüfung.
* **Testing**: Vitest + React Testing Library in Vite-Projekten.

---

### Zusammenfassung

* **Vite + `react-ts`** für SPA: schnell, minimal.
* **Next.js + `--ts`** für SSR/SSG/Full-stack.
* Aktiviere **`strict`** & nutze **`jsx: "react-jsx"`**.
* Typisiere Props/Events explizit; nutze Generics bei Wiederverwendung.

**Quellen:**

* [React Offizielle Doku – Einstieg](https://react.dev/learn)
* [TypeScript – React mit TS (JSX/TSX)](https://www.typescriptlang.org/docs/handbook/jsx.html)
* [React + TypeScript Cheatsheet – Setup](https://react-typescript-cheatsheet.netlify.app/docs/basic/setup)
* [Vite – React TS Template](https://vitejs.dev/guide/)
* [Next.js – TypeScript](https://nextjs.org/docs/basic-features/typescript)

  **[⬆ Наверх](#top)**

71. ### <a name="71"></a> Wie typisiert man eine React-Komponente (FC)?

### Typisierung von React-Komponenten in TypeScript

---

## **1. Funktionale Komponente mit Props**

```tsx
type HelloProps = {
  name: string
  age?: number // optional
}

export function Hello({ name, age }: HelloProps) {
  return <h1>Hallo {name}, Alter: {age}</h1>
}
```

👉 Standard: Props mit einem **Type** oder **Interface** typisieren.

---

## **2. Mit `React.FC` (funktioniert, wird aber weniger empfohlen)**

```tsx
import type { FC } from "react"

type HelloProps = {
  name: string
}

export const Hello: FC<HelloProps> = ({ name, children }) => (
  <div>
    <h1>Hallo {name}</h1>
    {children} {/* children automatisch typisiert */}
  </div>
)
```

⚠️ Nachteile von `React.FC`:

* `children` wird **immer erlaubt** (auch wenn nicht erwünscht).
* Manche HOCs/Generics funktionieren schlechter.

---

## **3. Mit Generics (z. B. List-Komponente)**

```tsx
type ListProps<T> = {
  items: T[]
  render: (item: T) => JSX.Element
}

export function List<T>({ items, render }: ListProps<T>) {
  return <ul>{items.map(render)}</ul>
}

// Verwendung:
<List items={["A", "B", "C"]} render={(item) => <li>{item}</li>} />
```

---

## **4. Event-Handler in Props**

```tsx
import type { MouseEventHandler } from "react"

type ButtonProps = {
  label: string
  onClick: MouseEventHandler<HTMLButtonElement>
}

export function Button({ label, onClick }: ButtonProps) {
  return <button onClick={onClick}>{label}</button>
}
```

---

## **5. Default Props (via Default-Parameter)**

```tsx
type TitleProps = {
  text?: string
}

export function Title({ text = "Standardtitel" }: TitleProps) {
  return <h2>{text}</h2>
}
```

---

## Zusammenfassung

* **Empfohlen:** Props über **Type oder Interface** definieren und direkt in der Funktion nutzen.
* **`React.FC`** möglich, aber Nachteile (immer `children`).
* Für wiederverwendbare Komponenten → **Generics** verwenden.
* Events immer mit **React-Eventtypen** (`MouseEvent`, `ChangeEvent`, …) typisieren.

🔗 Quellen:

* [React TypeScript Cheatsheet – Function Components](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/function_components/)
* [React Docs](https://react.dev/)
* [TypeScript Handbook – Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)

  **[⬆ Наверх](#top)**

72. ### <a name="72"></a> Was ist React.FC und wann sollte man es vermeiden?

### `React.FC` in TypeScript

---

## **1. Definition**

`React.FC` (Function Component) ist ein vordefinierter Typ in `@types/react`, um **funktionale Komponenten** zu typisieren:

```tsx
import type { FC } from "react"

type HelloProps = { name: string }

export const Hello: FC<HelloProps> = ({ name }) => <h1>Hallo {name}</h1>
```

---

## **2. Vorteile von `React.FC`**

* Bietet **automatische Typisierung von `children`**.
* Klare Signatur: `const Comp: FC<Props>`.
* Einfacher für Einsteiger.

---

## **3. Nachteile von `React.FC` (Gründe zum Vermeiden)**

1. **`children` ist immer erlaubt**, auch wenn man es gar nicht will.

   ```tsx
   type Props = { name: string }
   const A: FC<Props> = ({ name, children }) => <>{name}{children}</>
   <A name="Sergii">❌ children wird automatisch zugelassen</A>
   ```

2. **Keine Unterstützung für `defaultProps`/`propTypes`** (deprecated Pattern).

3. **Generics schwieriger einzusetzen** (z. B. `FC<ListProps<T>>`).

4. **Nicht nötig**, weil Typisierung ohne `React.FC` präziser und flexibler ist.

---

## **4. Empfohlene Alternative (ohne React.FC)**

```tsx
type HelloProps = { name: string }

export function Hello({ name }: HelloProps) {
  return <h1>Hallo {name}</h1>
}
```

👉 Props direkt typisieren → mehr Kontrolle, keine unnötigen `children`.

---

## **5. Wann `React.FC` verwenden?**

* Kleine Projekte oder **schneller Prototyping-Code**.
* Wenn man **immer `children`** benötigt (z. B. Layout-Komponenten).
* Aber: In größeren Projekten wird **Vermeidung empfohlen** → klarere Typen, weniger Fehler.

---

### Zusammenfassung

* **`React.FC`** = Typalias für Function Components, inkl. implizitem `children`.
* **Problem:** macht `children` immer verfügbar, erschwert Generics.
* **Empfehlung:** Props **direkt typisieren** (statt `React.FC`).
* Nutzen: nur, wenn man absichtlich `children` erzwingen will.

🔗 Quellen:

* [React TypeScript Cheatsheet – Function Components](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/function_components/)
* [React Docs](https://react.dev/)

  **[⬆ Наверх](#top)**

73. ### <a name="73"></a> Wie typisiert man Props in einer React-Komponente?

### Props in React-Komponenten typisieren (TypeScript)

---

## **1. Mit `type`**

```tsx
type GreetingProps = {
  name: string
  age?: number // optional
}

export function Greeting({ name, age }: GreetingProps) {
  return <h1>Hallo {name}, Alter: {age}</h1>
}
```

👉 Empfehlung: `type` für Props, da es auch Unions, Utility Types usw. unterstützt.

---

## **2. Mit `interface`**

```tsx
interface ButtonProps {
  label: string
  onClick: () => void
}

export function Button({ label, onClick }: ButtonProps) {
  return <button onClick={onClick}>{label}</button>
}
```

👉 Vorteil: `interface` lässt sich **erweitern** (`extends`).

---

## **3. Mit `children`**

```tsx
type CardProps = {
  title: string
  children: React.ReactNode
}

export function Card({ title, children }: CardProps) {
  return (
    <div>
      <h2>{title}</h2>
      <div>{children}</div>
    </div>
  )
}
```

---

## **4. Mit Events**

```tsx
import type { MouseEvent } from "react"

type ButtonProps = {
  onClick: (e: MouseEvent<HTMLButtonElement>) => void
}

export function Button({ onClick }: ButtonProps) {
  return <button onClick={onClick}>Klick mich</button>
}
```

---

## **5. Mit Generics (z. B. Listen-Komponente)**

```tsx
type ListProps<T> = {
  items: T[]
  render: (item: T) => JSX.Element
}

export function List<T>({ items, render }: ListProps<T>) {
  return <ul>{items.map(render)}</ul>
}

// Nutzung
<List items={["A", "B", "C"]} render={(i) => <li>{i}</li>} />
```

---

## Zusammenfassung

* **Props** typisiert man über `type` oder `interface`.
* **Optional** mit `?`, **children** mit `React.ReactNode`.
* Events strikt mit **React-Eventtypen** (`MouseEvent`, `ChangeEvent`, …).
* Für wiederverwendbare Komponenten → **Generics**.

🔗 Quellen:

* [React TypeScript Cheatsheet – Props](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example/)
* [React Docs – Passing Props](https://react.dev/learn/passing-props-to-a-component)

  **[⬆ Наверх](#top)**

74. ### <a name="74"></a> Wie typisiert man optionale Props?

### Optionale Props in React mit TypeScript

---

## **1. Mit `?` (Standardmethode)**

```tsx
type GreetingProps = {
  name: string
  age?: number // optional
}

export function Greeting({ name, age }: GreetingProps) {
  return <h1>Hallo {name}, Alter: {age ?? "unbekannt"}</h1>
}
```

👉 `age` ist automatisch `number | undefined`.

---

## **2. Mit Default-Wert im Destructuring**

```tsx
type TitleProps = {
  text?: string
}

export function Title({ text = "Standardtitel" }: TitleProps) {
  return <h2>{text}</h2>
}
```

👉 So wird `text` im Body **immer ein `string`**.

---

## **3. In Kombination mit `React.ReactNode` (children optional)**

```tsx
type CardProps = {
  title: string
  children?: React.ReactNode
}

export function Card({ title, children }: CardProps) {
  return (
    <div>
      <h2>{title}</h2>
      {children && <div>{children}</div>}
    </div>
  )
}
```

---

## **4. Utility Types für optionale Props (`Partial`)**

```tsx
type User = { id: number; name: string; email: string }

type OptionalUserProps = Partial<User>
// alle Props jetzt optional
```

---

### Zusammenfassung

* Optionale Props mit **`?`** markieren.
* Optional + Default-Wert → verhindert `undefined` im Body.
* `children` oft als optionales `React.ReactNode`.
* Utility Type **`Partial<T>`** macht alle Props optional.

🔗 Quellen:

* [TypeScript Handbook – Optional Properties](https://www.typescriptlang.org/docs/handbook/2/objects.html#optional-properties)
* [React TS Cheatsheet – Props](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example/)

  **[⬆ Наверх](#top)**

75. ### <a name="75"></a> Wie deklariert man Default Props in TypeScript?

### Default Props in React + TypeScript

In modernen React-Projekten mit TypeScript setzt man **Default-Werte direkt im Funktionsparameter**.
👉 Die alte Lösung mit `Component.defaultProps` ist **deprecated**.

---

## **1. Default Props über Destructuring**

```tsx
type GreetingProps = {
  name: string
  age?: number
}

export function Greeting({ name, age = 18 }: GreetingProps) {
  return <h1>Hallo {name}, Alter: {age}</h1>
}

// Verwendung:
<Greeting name="Sergii" />       // Alter: 18
<Greeting name="Anna" age={25} /> // Alter: 25
```

➡️ `age` ist im Body immer `number`, kein `undefined`.

---

## **2. Default Props bei `children`**

```tsx
type CardProps = {
  title?: string
  children?: React.ReactNode
}

export function Card({ title = "Ohne Titel", children }: CardProps) {
  return (
    <div>
      <h2>{title}</h2>
      {children}
    </div>
  )
}
```

---

## **3. Mit `Partial<T>` für flexible Defaults**

```tsx
type ButtonProps = {
  label: string
  size?: "small" | "medium" | "large"
}

const defaultProps: Partial<ButtonProps> = {
  size: "medium"
}

export function Button({ label, size = defaultProps.size }: ButtonProps) {
  return <button>{`${label} (${size})`}</button>
}
```

---

## **4. Generische Komponente mit Defaults**

```tsx
type ListProps<T> = {
  items?: T[]
  render: (item: T) => JSX.Element
}

export function List<T>({ items = [], render }: ListProps<T>) {
  return <ul>{items.map(render)}</ul>
}
```

---

### Zusammenfassung

* **Empfohlene Methode**: Default-Werte direkt beim **Destructuring** setzen.
* Props bleiben **optional** (`?`), aber im Funktionskörper ist der Typ **bereinigt**.
* `defaultProps` (alte Syntax) → vermeiden.

🔗 Quellen:

* [React TS Cheatsheet – Props mit Defaults](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example/#default-props)
* [React Docs – Passing Props](https://react.dev/learn/passing-props-to-a-component)

  **[⬆ Наверх](#top)**

76. ### <a name="76"></a> Wie typisiert man children in React-Komponenten?

### `children` in React-Komponenten typisieren

---

## **1. Mit `React.ReactNode` (Standard)**

```tsx
type CardProps = {
  children: React.ReactNode
}

export function Card({ children }: CardProps) {
  return <div className="card">{children}</div>
}

// Nutzung:
<Card>
  <h2>Hallo</h2>
  <p>Inhalt</p>
</Card>
```

👉 `React.ReactNode` erlaubt: JSX, Strings, Zahlen, Arrays, `null`, `undefined`.

---

## **2. Mit `ReactElement` (nur JSX erlaubt)**

```tsx
import type { ReactElement } from "react"

type WrapperProps = {
  children: ReactElement
}

export function Wrapper({ children }: WrapperProps) {
  return <section>{children}</section>
}

// <Wrapper><h1>✅ nur ein Element</h1></Wrapper>
// <Wrapper>Text ❌ Fehler</Wrapper>
```

---

## **3. Array von React-Elementen**

```tsx
import type { ReactElement } from "react"

type ListProps = {
  children: ReactElement[]
}

export function List({ children }: ListProps) {
  return <ul>{children}</ul>
}

// <List><li>A</li><li>B</li></List> ✅
```

---

## **4. Funktion als Children (Render Prop)**

```tsx
type RenderPropProps = {
  children: (count: number) => React.ReactNode
}

export function Counter({ children }: RenderPropProps) {
  return <div>{children(5)}</div>
}

// <Counter>{(n) => <span>Zahl: {n}</span>}</Counter>
```

---

## **5. Optionales `children`**

```tsx
type ContainerProps = {
  children?: React.ReactNode
}

export function Container({ children }: ContainerProps) {
  return <main>{children ?? "Kein Inhalt"}</main>
}
```

---

### Zusammenfassung

* **`React.ReactNode`** → flexibel, Standard für `children`.
* **`ReactElement`** → nur gültige JSX-Elemente (kein Text, kein Array).
* **Arrays** explizit als `ReactElement[]`.
* **Render Props** typisieren mit Funktionssignatur.
* `children` optional machen mit `?`.

🔗 Quellen:

* [React TypeScript Cheatsheet – Children](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example/#children)
* [React Docs – Passing Children](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children)

  **[⬆ Наверх](#top)**

77. ### <a name="77"></a> Was ist der Unterschied zwischen ReactNode, JSX.Element und ReactElement?

### Unterschied: `ReactNode` vs. `JSX.Element` vs. `ReactElement`

Diese drei Typen werden in React/TypeScript oft verwechselt, haben aber **verschiedene Bedeutungen**.

---

## **1. `ReactNode`**

👉 Der **allgemeinste Typ** für Inhalte, die in JSX gerendert werden können.
Enthält:

* `string`, `number`, `boolean` (teilweise),
* `null`, `undefined`,
* `JSX.Element`, `ReactElement`,
* Arrays dieser Typen.

```tsx
type ExampleProps = {
  children: React.ReactNode
}

export function Example({ children }: ExampleProps) {
  return <div>{children}</div>
}

// ✅ erlaubt:
<Example>Hallo</Example>
<Example>{123}</Example>
<Example><span>Text</span></Example>
<Example>{["A", "B", <b key="x">C</b>]}</Example>
```

---

## **2. `JSX.Element`**

👉 Typ, den der **JSX-Compiler** (`<div>...</div>`) zurückgibt.

* Wird von `React.createElement` erzeugt.
* Ist **genauer** als `ReactNode`.
* Entspricht in der Praxis **einem einzelnen React-Element**.

```tsx
const el: JSX.Element = <h1>Hello</h1>
// el = React.createElement("h1", null, "Hello")
```

---

## **3. `ReactElement`**

👉 Generischer Typ für ein Element, erzeugt durch `React.createElement`.

```tsx
const el: React.ReactElement = <button>Klick</button>
```

* Kann generisch spezifiziert werden:

```tsx
const el: React.ReactElement<{ onClick: () => void }> = (
  <button onClick={() => {}}>Klick</button>
)
```

* Typisch in **Bibliotheken und Low-Level-APIs**, seltener in App-Code.

---

## **Vergleichstabelle**

| Typ            | Beschreibung                                   | Beispiel-Einsatz             |
| -------------- | ---------------------------------------------- | ---------------------------- |
| `ReactNode`    | **Alles**, was in JSX gerendert werden kann    | Props: `children: ReactNode` |
| `JSX.Element`  | Ergebnis von JSX-Ausdrücken (`<div>...</div>`) | Rückgabewert von Komponenten |
| `ReactElement` | Konkretes React-Element (mit Props & Type)     | Low-Level-APIs, Tests, Libs  |

---

## **4. Typische Verwendung**

* **`ReactNode`** → für `children` (flexibel).
* **`JSX.Element`** → für Rückgabewerte von Komponenten.
* **`ReactElement`** → für präzise Typisierung einzelner Elemente.

---

### Zusammenfassung

* **`ReactNode`** = Union aller renderbaren Typen → am breitesten.
* **`JSX.Element`** = konkretes JSX-Ergebnis → Standard für `return` einer Komponente.
* **`ReactElement`** = generischer Typ eines React-Elements, inkl. Props.

🔗 Quellen:

* [React TypeScript Cheatsheet – JSX, ReactNode, ReactElement](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/jsx)
* [React Docs – JSX](https://react.dev/learn/writing-markup-with-jsx)

  **[⬆ Наверх](#top)**

78. ### <a name="78"></a> Wie typisiert man Events (z. B. onClick, onChange)?

### Events in React mit TypeScript typisieren

React liefert für jedes DOM-Element eigene **Event-Typen**.
👉 Diese sind in `@types/react` vordefiniert und basieren auf **`SyntheticEvent`**.

---

## **1. Allgemeiner Typ**

```tsx
import type { SyntheticEvent } from "react"

function handleEvent(e: SyntheticEvent) {
  console.log(e.type) // z. B. "click"
}
```

👉 Gut für Basisevents, aber unpräzise.

---

## **2. `onClick` – Button Klick**

```tsx
import type { MouseEvent } from "react"

function handleClick(e: MouseEvent<HTMLButtonElement>) {
  console.log("Button geklickt:", e.currentTarget)
}

export function App() {
  return <button onClick={handleClick}>Klick mich</button>
}
```

---

## **3. `onChange` – Input ändern**

```tsx
import type { ChangeEvent } from "react"

function handleChange(e: ChangeEvent<HTMLInputElement>) {
  console.log("Wert:", e.target.value)
}

export function Input() {
  return <input type="text" onChange={handleChange} />
}
```

---

## **4. Formular-Submit**

```tsx
import type { FormEvent } from "react"

function handleSubmit(e: FormEvent<HTMLFormElement>) {
  e.preventDefault()
  console.log("Formular gesendet")
}

export function Form() {
  return <form onSubmit={handleSubmit}><button>Senden</button></form>
}
```

---

## **5. Weitere Beispiele**

* **Mouse Events**:
  `MouseEvent<HTMLDivElement>` → `onMouseEnter`, `onMouseLeave`, `onContextMenu`
* **Keyboard Events**:
  `KeyboardEvent<HTMLInputElement>` → `onKeyDown`, `onKeyUp`
* **Focus Events**:
  `FocusEvent<HTMLInputElement>` → `onFocus`, `onBlur`

```tsx
import type { KeyboardEvent } from "react"

function handleKeyDown(e: KeyboardEvent<HTMLInputElement>) {
  if (e.key === "Enter") console.log("Enter gedrückt")
}
```

---

## **6. Inline-Handler (kurz)**

```tsx
export function Btn() {
  return (
    <button
      onClick={(e: React.MouseEvent<HTMLButtonElement>) => console.log(e.currentTarget)}
    >
      Klick
    </button>
  )
}
```

---

### Zusammenfassung

* Basis: `SyntheticEvent`.
* Genaue Typen: `MouseEvent`, `ChangeEvent`, `KeyboardEvent`, `FormEvent` usw.
* Generische Signatur: `Event<HTMLTagElement>`.
* Faustregel: **Immer den passenden DOM-Typ** einsetzen (z. B. `HTMLInputElement`, `HTMLButtonElement`).

🔗 Quellen:

* [React TS Cheatsheet – Events](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/event_handling/)
* [MDN – DOM Events](https://developer.mozilla.org/ru/docs/Web/Events)

  **[⬆ Наверх](#top)**

79. ### <a name="79"></a> Wie typisiert man Refs in React?

### Refs in React mit TypeScript typisieren

Refs werden in React über **`useRef`** oder **`createRef`** erstellt. Mit TypeScript kann man genau angeben, **auf welchen Typ** sie verweisen.

---

## **1. Ref auf DOM-Element**

```tsx
import { useRef, useEffect } from "react"

export function InputFocus() {
  const inputRef = useRef<HTMLInputElement>(null)

  useEffect(() => {
    inputRef.current?.focus()
  }, [])

  return <input ref={inputRef} />
}
```

👉 Typ: `HTMLInputElement | null`.

---

## **2. Ref auf andere DOM-Elemente**

* `HTMLDivElement`
* `HTMLButtonElement`
* `HTMLTextAreaElement`
* `HTMLCanvasElement` usw.

```tsx
const divRef = useRef<HTMLDivElement>(null)
```

---

## **3. Ref auf einen Wert (Mutable Ref)**

👉 Wenn man kein DOM-Element, sondern **einen beliebigen Wert** speichern will.

```tsx
const countRef = useRef<number>(0)

function increment() {
  countRef.current += 1
}
```

* Kein `null` nötig → direkt `useRef<number>(0)`
* Typ: `MutableRefObject<number>`

---

## **4. `createRef` (meist für Klassenkomponenten)**

```tsx
import { createRef, Component } from "react"

class MyForm extends Component {
  inputRef = createRef<HTMLInputElement>()

  focusInput = () => {
    this.inputRef.current?.focus()
  }

  render() {
    return <input ref={this.inputRef} />
  }
}
```

---

## **5. Weitergabe von Refs mit `forwardRef`**

```tsx
import { forwardRef } from "react"

type InputProps = { placeholder?: string }

export const CustomInput = forwardRef<HTMLInputElement, InputProps>(
  ({ placeholder }, ref) => <input ref={ref} placeholder={placeholder} />
)

// Nutzung:
import { useRef } from "react"

export function Form() {
  const ref = useRef<HTMLInputElement>(null)
  return <CustomInput ref={ref} placeholder="Name" />
}
```

---

## Zusammenfassung

* DOM-Ref: `useRef<HTMLTagElement>(null)`
* Wert-Ref: `useRef<T>(initialValue)` → `MutableRefObject<T>`
* `forwardRef` für Weitergabe von Refs typisieren mit `forwardRef<HTMLTag, Props>`.
* `createRef` → selten, v. a. für Klassenkomponenten.

🔗 Quellen:

* [React TypeScript Cheatsheet – Refs](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/hooks/#useref)
* [React Docs – Refs](https://react.dev/learn/referencing-values-with-refs)

  **[⬆ Наверх](#top)**

80. ### <a name="80"></a> Wie typisiert man State mit useState?

### State mit `useState` typisieren

React’s **`useState`** ist ein generischer Hook (`useState<S>()`).
👉 Man kann den Typ explizit angeben oder TypeScript lässt ihn **inferen**.

---

## **1. Einfache Typisierung**

```tsx
import { useState } from "react"

export function Counter() {
  const [count, setCount] = useState<number>(0)

  return <button onClick={() => setCount(count + 1)}>{count}</button>
}
```

➡️ `count: number`, `setCount: Dispatch<SetStateAction<number>>`

---

## **2. Typ wird automatisch inferred**

```tsx
const [name, setName] = useState("Sergii")
// Typ: string (kein <string> nötig)
```

---

## **3. Union Types**

```tsx
type Status = "loading" | "success" | "error"

const [status, setStatus] = useState<Status>("loading")

setStatus("success") // ✅
setStatus("failed")  // ❌ Fehler
```

---

## **4. Nullbare Werte**

```tsx
interface User {
  id: number
  name: string
}

const [user, setUser] = useState<User | null>(null)

if (user) {
  console.log(user.name) // sicher
}
```

---

## **5. useState mit Funktion (Lazy Init)**

```tsx
const [expensive, setExpensive] = useState<number>(() => {
  return Math.random() * 1000 // nur einmal beim Mount
})
```

---

## **6. useState mit Objekt**

```tsx
type FormState = {
  username: string
  age: number
}

const [form, setForm] = useState<FormState>({ username: "", age: 0 })

setForm(prev => ({ ...prev, username: "Anna" }))
```

---

### Zusammenfassung

* **`useState<T>()`** → Typ explizit oder inferred.
* Union-Typen für begrenzte Werte (`"success" | "error"`).
* Für optionale Werte: `T | null`.
* Bei Objekten: State-Updates immutabel mit Spread.

🔗 Quellen:

* [React TypeScript Cheatsheet – useState](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/hooks/#usestate)
* [React Docs – useState](https://react.dev/reference/react/useState)

  **[⬆ Наверх](#top)**  

81. ### <a name="81"></a> Wie typisiert man useReducer?

### `useReducer` in React mit TypeScript typisieren

Der Hook **`useReducer`** ist generisch und erlaubt eine sehr präzise Typisierung von **State** und **Actions**.

---

## **1. Basis-Signatur**

```ts
const [state, dispatch] = useReducer<Reducer<State, Action>>(reducer, initialState)
```

oder einfach:

```ts
const [state, dispatch] = useReducer(reducer, initialState)
```

👉 TypeScript inferiert die Typen, wenn `reducer` und `initialState` sauber typisiert sind.

---

## **2. Beispiel – Counter**

```tsx
import { useReducer } from "react"

// State-Typ
type State = { count: number }

// Action-Typ (Union)
type Action = { type: "increment" } | { type: "decrement" } | { type: "reset"; payload: number }

// Reducer
function reducer(state: State, action: Action): State {
  switch (action.type) {
    case "increment":
      return { count: state.count + 1 }
    case "decrement":
      return { count: state.count - 1 }
    case "reset":
      return { count: action.payload }
    default:
      return state
  }
}

// Nutzung
export function Counter() {
  const [state, dispatch] = useReducer(reducer, { count: 0 })

  return (
    <>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: "increment" })}>+</button>
      <button onClick={() => dispatch({ type: "decrement" })}>-</button>
      <button onClick={() => dispatch({ type: "reset", payload: 10 })}>Reset</button>
    </>
  )
}
```

👉 `dispatch` ist automatisch auf den Typ `Action` eingeschränkt.

---

## **3. Mit Generics (explizit)**

```tsx
import { useReducer, Reducer } from "react"

type State = { name: string }
type Action = { type: "setName"; payload: string }

const reducer: Reducer<State, Action> = (state, action) => {
  switch (action.type) {
    case "setName":
      return { ...state, name: action.payload }
  }
}

const [state, dispatch] = useReducer(reducer, { name: "Sergii" })
```

---

## **4. Mit komplexeren Payloads**

```tsx
type Todo = { id: number; text: string; done: boolean }

type Action =
  | { type: "add"; payload: string }
  | { type: "toggle"; payload: number }
  | { type: "remove"; payload: number }
```

👉 Payload-Typen sind individuell je Action.

---

## **5. Lazy Initialization (dritter Parameter)**

```tsx
function init(count: number): State {
  return { count }
}

const [state, dispatch] = useReducer(reducer, 5, init)
// initialisiert mit { count: 5 }
```

---

### Zusammenfassung

* `useReducer` typisiert man mit **State** und **Action**.
* Action-Typen meist als **Discriminated Unions**.
* `dispatch` ist automatisch korrekt typisiert.
* Option für Lazy Init mit drittem Parameter.

🔗 Quellen:

* [React Docs – useReducer](https://react.dev/reference/react/useReducer)
* [React TypeScript Cheatsheet – useReducer](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/hooks/#usereducer)

  **[⬆ Наверх](#top)**

82. ### <a name="82"></a> Wie typisiert man useRef mit initial null?

### `useRef` mit initial `null` typisieren

In React ist ein **DOM-Ref** oder ein **nullable Ref** typisch → `T | null`.

---

## **1. Ref auf DOM-Element**

```tsx
import { useRef, useEffect } from "react"

export function InputFocus() {
  // HTMLInputElement | null
  const inputRef = useRef<HTMLInputElement>(null)

  useEffect(() => {
    inputRef.current?.focus()
  }, [])

  return <input ref={inputRef} />
}
```

👉 `inputRef.current` hat den Typ `HTMLInputElement | null`.

---

## **2. Ref auf generische Werte**

```tsx
const timerRef = useRef<number | null>(null)

function startTimer() {
  timerRef.current = window.setTimeout(() => {
    console.log("Timer!")
  }, 1000)
}

function clearTimer() {
  if (timerRef.current !== null) {
    clearTimeout(timerRef.current)
  }
}
```

---

## **3. Unterschied: `useRef<T>(null)` vs. `useRef<T | null>(null)`**

* **`useRef<T>(null)`** → Fehler, weil `null` nicht `T` ist.
* **`useRef<T | null>(null)`** → korrekt, `current` kann `null` sein.

---

## **4. Zugriff absichern**

```tsx
if (inputRef.current) {
  inputRef.current.value = "Hallo"
}
```

oder mit **Optional Chaining**:

```tsx
inputRef.current?.focus()
```

---

### Zusammenfassung

* Für DOM-Elemente: `useRef<HTMLDivElement | null>(null)`.
* Für Werte: `useRef<T | null>(null)`.
* Immer `| null` hinzufügen, da beim Initialisieren `null` gesetzt wird.
* Zugriff absichern mit `if` oder `?.`.

🔗 Quellen:

* [React Docs – Refs](https://react.dev/learn/referencing-values-with-refs)
* [React TS Cheatsheet – useRef](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/hooks/#useref)

  **[⬆ Наверх](#top)**

83. ### <a name="83"></a> Wie typisiert man einen Custom Hook?

### Custom Hook in TypeScript typisieren

---

## 1) Einfacher Hook (Rückgabetyp inferieren lassen)

```js
import { useEffect, useState } from "react"

export function useOnline() {
  const [online, setOnline] = useState<boolean>(navigator.onLine)

  useEffect(() => {
    const on = () => setOnline(true)
    const off = () => setOnline(false)
    window.addEventListener("online", on)
    window.addEventListener("offline", off)
    return () => {
      window.removeEventListener("online", on)
      window.removeEventListener("offline", off)
    }
  }, [])

  return online // boolean
}
```

---

## 2) Hook mit explizitem Rückgabetyp (Objekt / Tupel)

```js
import { useCallback, useState } from "react"

type Counter = {
  count: number
  inc: () => void
  dec: () => void
  reset: () => void
}

export function useCounter(initial = 0): Counter {
  const [count, setCount] = useState<number>(initial)
  const inc = useCallback(() => setCount((c) => c + 1), [])
  const dec = useCallback(() => setCount((c) => c - 1), [])
  const reset = useCallback(() => setCount(initial), [initial])
  return { count, inc, dec, reset }
}
```

```js
// Tupel-Variante
import { useState } from "react"

export function useToggle(initial = false): [boolean, () => void] {
  const [on, setOn] = useState<boolean>(initial)
  return [on, () => setOn((v) => !v)]
}
```

---

## 3) Generischer Hook (mit Constraints)

```js
import { useMemo } from "react"

export function usePick<T extends object, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> {
  return useMemo(() => {
    const out = {} as Pick<T, K>
    for (const k of keys) out[k] = obj[k]
    return out
  }, [obj, keys.join("|")])
}

// Nutzung
const user = { id: 1, name: "Sergii", admin: true }
const partial = usePick(user, ["id", "name"]) // Typ: { id: number; name: string }
```

---

## 4) Hook, der Promise-Status kapselt (Union/Discriminated Union)

```js
import { useEffect, useState } from "react"

type AsyncState<T> =
  | { status: "idle" }
  | { status: "loading" }
  | { status: "success"; data: T }
  | { status: "error"; error: Error }

export function useAsync<T>(fn: () => Promise<T>, deps: unknown[] = []) {
  const [state, setState] = useState<AsyncState<T>>({ status: "idle" })

  useEffect(() => {
    let alive = true
    setState({ status: "loading" })
    fn()
      .then((data) => alive && setState({ status: "success", data }))
      .catch((error) => alive && setState({ status: "error", error }))
    return () => { alive = false }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, deps)

  return state
}
```

---

## 5) Hook mit Ref im Rückgabewert

```js
import { useEffect, useRef } from "react"

export function useFocus<T extends HTMLElement>() {
  const ref = useRef<T | null>(null)
  useEffect(() => { ref.current?.focus() }, [])
  return ref // RefObject<T | null>
}
```

---

## 6) Typ-Tipps

* Parameter und Rückgabewert klar typisieren; bei einfachen Fällen **Inference** nutzen.
* Für Tupel-Rückgaben **exakten Tupeltyp** angeben (`[T, U]`).
* Bei generischen Hooks **Constraints** setzen (`<T extends object>`).
* Für `null`-bare Werte explizit `| null`.
* Für komplexe Status **discriminated unions** nutzen.

---

### Zusammenfassung

* Custom Hooks sind normale Funktionen: **Parameter- & Rückgabetyp** angeben; bei Bedarf **Generics** und **Unions** einsetzen.
* Tupel oder Objekt als Rückgabewert klar typisieren.
* Refs als `RefObject<T | null>`, asynchrone Zustände über **discriminated unions**.

**Quellen:**

* [React Docs – Reusing Logic with Custom Hooks](https://react.dev/learn/reusing-logic-with-custom-hooks)
* [React TypeScript Cheatsheet – Hooks & Patterns](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/hooks/)
* [TypeScript Handbook – Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)

  **[⬆ Наверх](#top)**

84. ### <a name="84"></a> Wie typisiert man Komponenten mit forwardRef?

### Komponenten mit `forwardRef` typisieren (TypeScript + React)

---

## **1. Grundsyntax**

`forwardRef` ist ein **Generic**: `forwardRef<T, P>`

* **`T`** = Typ des Referenz-Elements (z. B. `HTMLInputElement`)
* **`P`** = Typ der Props

```tsx
import { forwardRef } from "react"

type InputProps = {
  label: string
}

export const Input = forwardRef<HTMLInputElement, InputProps>(
  ({ label, ...props }, ref) => (
    <label>
      {label}
      <input ref={ref} {...props} />
    </label>
  )
)

// Nutzung
import { useRef } from "react"

export function Form() {
  const inputRef = useRef<HTMLInputElement>(null)
  return <Input ref={inputRef} label="Name" />
}
```

---

## **2. Mit optionalen Props + `children`**

```tsx
type ButtonProps = {
  children: React.ReactNode
  onClick?: () => void
}

export const Button = forwardRef<HTMLButtonElement, ButtonProps>(
  ({ children, onClick }, ref) => (
    <button ref={ref} onClick={onClick}>
      {children}
    </button>
  )
)
```

---

## **3. Generischer Typ in `forwardRef`**

```tsx
type ListProps<T> = {
  items: T[]
  render: (item: T) => JSX.Element
}

function ListInner<T>(
  { items, render }: ListProps<T>,
  ref: React.Ref<HTMLUListElement>
) {
  return <ul ref={ref}>{items.map(render)}</ul>
}

export const List = forwardRef(ListInner) as <T>(
  props: ListProps<T> & { ref?: React.Ref<HTMLUListElement> }
) => JSX.Element

// Nutzung
<List items={[1, 2, 3]} render={(i) => <li>{i}</li>} />
```

---

## **4. Mit `useImperativeHandle` (Custom Ref API)**

```tsx
import { forwardRef, useImperativeHandle, useRef } from "react"

type FocusInputHandle = {
  focus: () => void
}

export const FocusInput = forwardRef<FocusInputHandle, {}>((_, ref) => {
  const inputRef = useRef<HTMLInputElement>(null)

  useImperativeHandle(ref, () => ({
    focus: () => inputRef.current?.focus(),
  }))

  return <input ref={inputRef} />
})

// Nutzung
export function App() {
  const ref = useRef<FocusInputHandle>(null)
  return (
    <>
      <FocusInput ref={ref} />
      <button onClick={() => ref.current?.focus()}>Fokus setzen</button>
    </>
  )
}
```

---

### Zusammenfassung

* `forwardRef<T, P>` → `T` = Ref-Element-Typ, `P` = Props.
* Rückgabe: `JSX.Element`.
* Mit `useImperativeHandle` → eigene Methoden im Ref freigeben.
* Für Generics → `as`-Casting notwendig.

🔗 Quellen:

* [React Docs – forwardRef](https://react.dev/reference/react/forwardRef)
* [React TypeScript Cheatsheet – forwardRef](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/forms_and_events/#forwardref-createref)

  **[⬆ Наверх](#top)**

85. ### <a name="85"></a> Wie typisiert man Context (React Context API)?

### React Context API mit TypeScript typisieren

---

## **1. Einfacher Context (nicht nullbar)**

```tsx
import { createContext, useContext } from "react"

type Theme = "light" | "dark"

const ThemeContext = createContext<Theme>("light")

export function useTheme() {
  return useContext(ThemeContext)
}

// Nutzung
export function App() {
  return (
    <ThemeContext.Provider value="dark">
      <Child />
    </ThemeContext.Provider>
  )
}

function Child() {
  const theme = useTheme()
  return <p>Aktuelles Theme: {theme}</p>
}
```

👉 Typ des Context-Werts: `Theme`.

---

## **2. Context mit `null` als Default**

⚠️ Häufig: Provider setzt später einen Wert → Default = `null`.

```tsx
type AuthContextValue = {
  user: string
  login: (name: string) => void
}

const AuthContext = createContext<AuthContextValue | null>(null)

export function useAuth() {
  const ctx = useContext(AuthContext)
  if (!ctx) throw new Error("useAuth muss innerhalb von AuthProvider genutzt werden")
  return ctx
}

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const login = (name: string) => console.log("Login:", name)
  return (
    <AuthContext.Provider value={{ user: "Sergii", login }}>
      {children}
    </AuthContext.Provider>
  )
}
```

---

## **3. Context mit State (useState + Context)**

```tsx
import { useState } from "react"

type CounterContextValue = {
  count: number
  setCount: React.Dispatch<React.SetStateAction<number>>
}

const CounterContext = createContext<CounterContextValue | null>(null)

export function CounterProvider({ children }: { children: React.ReactNode }) {
  const [count, setCount] = useState(0)
  return (
    <CounterContext.Provider value={{ count, setCount }}>
      {children}
    </CounterContext.Provider>
  )
}

export function useCounter() {
  const ctx = useContext(CounterContext)
  if (!ctx) throw new Error("useCounter muss in CounterProvider genutzt werden")
  return ctx
}
```

---

## **4. Context mit Generics (z. B. Repository Pattern)**

```tsx
type RepoContext<T> = {
  items: T[]
  add: (item: T) => void
}

function createRepoContext<T>() {
  return createContext<RepoContext<T> | null>(null)
}

const UserRepoContext = createRepoContext<{ id: number; name: string }>()
```

---

### Zusammenfassung

* Context wird mit `createContext<T>()` erstellt.
* Default-Wert → entweder **konkreter Wert** oder **`null`**.
* Mit `null` → immer Custom Hook bauen, der `useContext` kapselt + Fehler wirft.
* Typisch: `Context + Provider + useXyz-Hook`.
* Mit Generics → wiederverwendbare Contexts möglich.

🔗 Quellen:

* [React Docs – Context](https://react.dev/reference/react/createContext)
* [React TypeScript Cheatsheet – Context](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/context/)

  **[⬆ Наверх](#top)**

86. ### <a name="86"></a> Wie typisiert man HOCs (Higher-Order Components)?

### HOCs (Higher-Order Components) typisieren

**Definition:**
Ein HOC ist eine Funktion, die eine Komponente **entgegennimmt** und eine **neue Komponente zurückgibt**. In TypeScript nutzt man Generics, um die **Props des Wrapped Components** zu erhalten und ggf. **injizierte Props** nach außen zu entfernen.

---

## 1) Basis-HOC (ohne Prop-Änderung)

```js
import type { ComponentType } from "react"

export function withLogger<P>(Wrapped: ComponentType<P>) {
  return function ComponentWithLogger(props: P) {
    console.log("props:", props)
    return <Wrapped {...props} />
  }
}
```

* `P` repräsentiert die Props des Wrapped Components.
* Rückgabe akzeptiert **die gleichen Props** wie `Wrapped`.

---

## 2) HOC mit **injizierten Props** (nach außen entfernen)

```js
import type { ComponentType } from "react"

type Injected = { user: { id: number; name: string } }

export function withUser<P extends Injected>(
  Wrapped: ComponentType<P>
) {
  // nach außen entferne "user", weil HOC ihn liefert
  type OuterProps = Omit<P, keyof Injected>

  return function WithUser(props: OuterProps) {
    const injected: Injected = { user: { id: 1, name: "Sergii" } }
    return <Wrapped {...(props as P)} {...injected} />
  }
}

// Nutzung
type ProfileProps = { user: { id: number; name: string }; editable?: boolean }
function Profile({ user, editable }: ProfileProps) {
  return <div>{user.name} {editable ? "(edit)" : ""}</div>
}
export const ProfileWithUser = withUser(Profile)
// <ProfileWithUser editable />  // ✅ user wird vom HOC gesetzt
```

* **Wichtig:** `P extends Injected` und `OuterProps = Omit<P, keyof Injected>`.

---

## 3) HOC, der Props transformiert (z. B. Loading)

```js
import type { ComponentType } from "react"

type WithLoadingProps = { loading: boolean }

export function withLoading<P>(
  Wrapped: ComponentType<P>
) {
  return function WithLoading(props: P & WithLoadingProps) {
    if (props.loading) return <span>Lädt…</span>
    const { loading, ...rest } = props as WithLoadingProps & P
    return <Wrapped {...(rest as P)} />
  }
}
```

* HOC **erweitert** die äußeren Props um `loading`.

---

## 4) HOC + `forwardRef` (Ref durchleiten)

```js
import { forwardRef } from "react"
import type { ComponentType, Ref } from "react"

export function withRef<P, T>(Wrapped: ComponentType<P & { ref?: Ref<T> }>) {
  // äußere Props sollen die internen "ref"-Props nicht enthalten
  type OuterProps = P

  const Component = (props: OuterProps, ref: Ref<T>) => {
    return <Wrapped {...props} ref={ref} />
  }

  return forwardRef<T, OuterProps>(Component)
}

// Beispiel: DOM-Ref auf <input>
type InputProps = { placeholder?: string }
const RawInput = (p: InputProps, ref: Ref<HTMLInputElement>) => (
  <input ref={ref} {...p} />
)
const Input = forwardRef<HTMLInputElement, InputProps>(RawInput)

export const InputWithRef = withRef<InputProps, HTMLInputElement>(Input)
// Nutzung: const r = useRef<HTMLInputElement>(null); <InputWithRef ref={r} />
```

---

## 5) Statische Eigenschaften „hoisten“

HOCs verlieren i. d. R. **statische Properties** des Wrapped Components.
→ In Bibliotheken nutzt man oft `hoist-non-react-statics`, um sie zu kopieren.
*(Tipp fürs Interview erwähnen, Code hier weggelassen.)*

---

## 6) Typ-Tipps & Fallstricke

* Verwende **`ComponentType<P>`** statt `FC<P>`, um auch Klassenkomponenten zu unterstützen.
* Für injizierte Props immer **`Omit`** nach außen nutzen.
* Bei Refs: HOC mit **`forwardRef`** typisieren (siehe oben).
* Bei generischen Wrapped Components ggf. explizit casten (Constraint auf `P` setzen).

---

### Zusammenfassung

* HOCs mit Generics: `function withX<P>(Comp: ComponentType<P>) => (props: P|Omit<P,…>) => JSX.Element`.
* **Injected Props** nach außen mit `Omit` entfernen.
* **Refs** via `forwardRef<T, P>` korrekt weiterreichen.
* Optional: **statische Properties hoisten** (Lib-Nennung reicht im Interview).

**Quellen:**

* [React TypeScript Cheatsheet – HOCs](https://react-typescript-cheatsheet.netlify.app/docs/hoc/react_hoc_docs/)
* [React Offizielle Doku – HOCs (Konzept)](https://react.dev/learn/reusing-logic-with-custom-hooks)
* [TypeScript Handbook – Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)

**Zusammenfassung:**
HOCs typisiert man generisch über `ComponentType<P>`, entfernt **injizierte Props** per `Omit`, leitet **Refs** mit `forwardRef` durch und achtet bei Bedarf aufs **Hoisten statischer Properties**.

  **[⬆ Наверх](#top)**

87. ### <a name="87"></a> Wie typisiert man asynchrone Funktionen in React-Komponenten?

### Asynchrone Funktionen in React-Komponenten typisieren

---

## 1) Async-Eventhandler: immer `Promise<void>`

```js
import type { MouseEvent, FormEvent, ChangeEvent } from "react"

export function Actions() {
  const onClick = async (e: MouseEvent<HTMLButtonElement>): Promise<void> => {
    e.preventDefault()
    await fetch("/api/click")
  }

  const onSubmit = async (e: FormEvent<HTMLFormElement>): Promise<void> => {
    e.preventDefault()
    // …
  }

  const onChange = async (e: ChangeEvent<HTMLInputElement>): Promise<void> => {
    // …
  }

  return (
    <form onSubmit={onSubmit}>
      <input onChange={onChange} />
      <button onClick={onClick}>Senden</button>
      <button type="submit">Submit</button>
    </form>
  )
}
```

**Faustregel:** UI-Handler `async` → Rückgabetyp **`Promise<void>`**.

---

## 2) Async mit `useCallback`

```js
import { useCallback, useState } from "react"

export function Loader() {
  const [data, setData] = useState<string | null>(null)
  const [error, setError] = useState<Error | null>(null)
  const [loading, setLoading] = useState(false)

  const load = useCallback(async (): Promise<void> => {
    try {
      setLoading(true)
      const res = await fetch("/api/text")
      const text = await res.text()
      setData(text)
    } catch (e) {
      setError(e as Error)
    } finally {
      setLoading(false)
    }
  }, [])

  return <button onClick={load} disabled={loading}>{loading ? "…" : "Laden"}</button>
}
```

---

## 3) Async Funktionen mit Rückgabewert

```js
async function getUser(): Promise<{ id: number; name: string }> {
  const res = await fetch("/api/user")
  return res.json()
}

export function Profile() {
  // Nutzung: Rückgabetyp ist Promise<{ id; name }>
  // In Handlern weiterhin Promise<void> zurückgeben:
  const handle = async (): Promise<void> => {
    const user = await getUser()
    console.log(user.name)
  }
  return <button onClick={handle}>Profil laden</button>
}
```

---

## 4) Async Props (Funktionen als Props)

```js
type SaveFn = (payload: { id: number }) => Promise<void>

export function SaveButton({ onSave }: { onSave: SaveFn }) {
  const handle = async (): Promise<void> => {
    await onSave({ id: 1 })
  }
  return <button onClick={handle}>Speichern</button>
}
```

---

## 5) Abbrechen mit `AbortController` (typisiert)

```js
export function Fetcher() {
  const handle = async (): Promise<void> => {
    const controller = new AbortController()
    const id = setTimeout(() => controller.abort(), 3000)
    try {
      const res = await fetch("/api/data", { signal: controller.signal })
      await res.json()
    } finally {
      clearTimeout(id)
    }
  }
  return <button onClick={handle}>Fetch (3s Timeout)</button>
}
```

---

## 6) Typische Fehler vermeiden

* **Kein ungetyptes `any`**: Ergebnis immer mit **`Promise<T>`** annotieren.
* **Eventtypen korrekt** (`MouseEvent<HTMLButtonElement>`, `FormEvent<HTMLFormElement>`, …).
* **State-Typen** präzise halten (`T | null`, Discriminated Unions für Lade/Error-Status).
* **Handler** sollen keine Werte returnen, die React ignoriert → `Promise<void>`.

---

### Zusammenfassung

* Eventhandler als `async` → **`Promise<void>`** + passender **React-Eventtyp**.
* Datenfunktionen geben **`Promise<T>`** zurück; Handler nutzen sie und bleiben bei `Promise<void>`.
* `useCallback` für stabile Referenzen; Fehler/Loading in State modellieren.
* Abbrechen über **`AbortController`** korrekt typisieren.

**Quellen:**

* [React Docs – Events & Handlers](https://react.dev/learn/responding-to-events)
* [React TypeScript Cheatsheet – Event Handling & Hooks](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/event_handling/)
* [TypeScript Docs – Promises & async/await](https://www.typescriptlang.org/docs/handbook/2/functions.html#async-functions)
* [MDN – AbortController](https://developer.mozilla.org/ru/docs/Web/API/AbortController)

  **[⬆ Наверх](#top)**

88. ### <a name="88"></a> Wie typisiert man Event-Handler in Formularen?

### Event-Handler in Formularen typisieren (React + TypeScript)

React nutzt **synthetische Events** (`SyntheticEvent`) mit spezifischen Subtypen für Formulareingaben.
👉 Immer den **richtigen DOM-Typ** mitgeben (`HTMLFormElement`, `HTMLInputElement`, `HTMLSelectElement` …).

---

## **1. Formular-Submit (`onSubmit`)**

```tsx
import type { FormEvent } from "react"

function Form() {
  const handleSubmit = (e: FormEvent<HTMLFormElement>): void => {
    e.preventDefault()
    console.log("Formular gesendet")
  }

  return (
    <form onSubmit={handleSubmit}>
      <button type="submit">Senden</button>
    </form>
  )
}
```

---

## **2. Input-Felder (`onChange`)**

```tsx
import type { ChangeEvent } from "react"

function TextInput() {
  const handleChange = (e: ChangeEvent<HTMLInputElement>): void => {
    console.log("Neuer Wert:", e.target.value)
  }

  return <input type="text" onChange={handleChange} />
}
```

---

## **3. Select (`onChange`)**

```tsx
function SelectBox() {
  const handleChange = (e: React.ChangeEvent<HTMLSelectElement>): void => {
    console.log("Gewählt:", e.target.value)
  }

  return (
    <select onChange={handleChange}>
      <option value="a">A</option>
      <option value="b">B</option>
    </select>
  )
}
```

---

## **4. Textarea (`onChange`)**

```tsx
function TextArea() {
  const handleChange = (e: React.ChangeEvent<HTMLTextAreaElement>): void => {
    console.log("Text:", e.target.value)
  }

  return <textarea onChange={handleChange} />
}
```

---

## **5. Checkbox & Radio (`onChange`)**

```tsx
function Checkbox() {
  const handleCheck = (e: React.ChangeEvent<HTMLInputElement>): void => {
    console.log("Checked:", e.target.checked)
  }

  return <input type="checkbox" onChange={handleCheck} />
}
```

---

## **6. Generische Variante**

Falls man den Typ nicht kennt:

```tsx
function GenericHandler() {
  const handle = (e: React.SyntheticEvent): void => {
    console.log(e.type)
  }

  return <form onSubmit={handle}></form>
}
```

👉 Besser immer präzise statt `SyntheticEvent`.

---

### Zusammenfassung

* **`FormEvent<HTMLFormElement>`** → für `onSubmit`.
* **`ChangeEvent<HTMLInputElement>`** → Text, Checkbox, Radio.
* **`ChangeEvent<HTMLSelectElement>`** → Select.
* **`ChangeEvent<HTMLTextAreaElement>`** → Textarea.
* Faustregel: **`ChangeEvent<T>`**, wobei `T` = konkretes HTML-Element.

🔗 Quellen:

* [React TypeScript Cheatsheet – Events](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/event_handling/)
* [React Docs – Form Handling](https://react.dev/learn/managing-state#updating-state-based-on-input-fields)

  **[⬆ Наверх](#top)**

89. ### <a name="89"></a> Wie typisiert man API-Requests und Responses?

### API-Requests und -Responses typisieren (TypeScript + Fetch/Axios)

---

## 1) DTOs (Request/Response-Modelle) definieren

```js
// types.ts
export type CreateUserReq = {
  name: string
  email: string
}

export type User = {
  id: number
  name: string
  email: string
}

export type ApiError = {
  status: number
  message: string
}
```

---

## 2) `fetch`-Wrapper mit Generics (`Promise<T>`)

```js
// api.ts
export async function apiGet<T>(url: string, init?: RequestInit): Promise<T> {
  const res = await fetch(url, { ...init, method: "GET" })
  if (!res.ok) {
    throw { status: res.status, message: res.statusText } // ApiError-ähnlich
  }
  const data: unknown = await res.json()
  return data as T // besser: runtime-validate, siehe unten
}

export async function apiPost<TReq, TRes>(url: string, body: TReq, init?: RequestInit): Promise<TRes> {
  const res = await fetch(url, {
    method: "POST",
    headers: { "Content-Type": "application/json", ...(init?.headers ?? {}) },
    body: JSON.stringify(body),
    ...init
  })
  if (!res.ok) {
    throw { status: res.status, message: await res.text() }
  }
  const data: unknown = await res.json()
  return data as TRes
}
```

**Verwendung:**

```js
import { apiGet, apiPost } from "./api.js"
import type { CreateUserReq, User } from "./types.js"

const user = await apiGet<User>("/api/user/1")
const created = await apiPost<CreateUserReq, User>("/api/users", { name: "Sergii", email: "s@ex.com" })
```

---

## 3) Axios mit Generics

```js
import axios from "axios"
import type { CreateUserReq, User } from "./types.js"

export async function getUser(id: number) {
  const res = await axios.get<User>(`/api/users/${id}`)
  return res.data // User
}

export async function createUser(dto: CreateUserReq) {
  const res = await axios.post<User>("/api/users", dto)
  return res.data // User
}
```

---

## 4) Runtime-Validierung (Zod) statt blindem `as`

```js
import { z } from "zod"

export const UserSchema = z.object({
  id: z.number(),
  name: z.string(),
  email: z.string().email()
})
export type User = z.infer<typeof UserSchema>

export async function safeGetUser(id: number): Promise<User> {
  const res = await fetch(`/api/users/${id}`)
  if (!res.ok) throw new Error("HTTP " + res.status)
  const json: unknown = await res.json()
  return UserSchema.parse(json) // ✅ Laufzeit-Check + Typ
}
```

---

## 5) API-Status als Discriminated Union (für UI-States)

```js
export type ApiState<T> =
  | { status: "idle" }
  | { status: "loading" }
  | { status: "success"; data: T }
  | { status: "error"; error: string }
```

```js
import { useEffect, useState } from "react"
import type { User } from "./types.js"

export function useUser(id: number) {
  const [state, setState] = useState<ApiState<User>>({ status: "idle" })

  useEffect(() => {
    let alive = true
    setState({ status: "loading" })
    fetch(`/api/users/${id}`)
      .then(r => r.json())
      .then((j: unknown) => {
        // hier idealerweise Zod-Parse
        if (alive) setState({ status: "success", data: j as User })
      })
      .catch(e => alive && setState({ status: "error", error: String(e) }))
    return () => { alive = false }
  }, [id])

  return state
}
```

---

## 6) Pagination/Envelope-Typen

```js
export type Page<T> = {
  items: T[]
  total: number
  page: number
  pageSize: number
}

const page = await apiGet<Page<User>>("/api/users?page=1&pageSize=20")
```

---

## 7) Endpunkt-Map (sicher via `satisfies`)

```js
export const endpoints = {
  getUser: { path: (id: number) => `/api/users/${id}`, method: "GET" },
  createUser: { path: () => "/api/users", method: "POST" }
} as const satisfies Record<string, { path: (...a: any[]) => string; method: "GET" | "POST" }>
```

---

## 8) Fehler-Typen & Narrowing

```js
try {
  const data = await apiGet<User>("/api/user/1")
} catch (e) {
  const err = e as { status?: number; message?: string }
  console.error(err.status ?? 0, err.message ?? "Unknown")
}
```

---

## 9) Request-Bodies typisieren (FormData/Query)

```js
export type SearchParams = { q: string; limit?: number }

export function toQuery(params: SearchParams): string {
  const usp = new URLSearchParams()
  usp.set("q", params.q)
  if (params.limit != null) usp.set("limit", String(params.limit))
  return usp.toString()
}
```

---

### Zusammenfassung

* **DTOs** für Requests/Responses definieren; **Generics** nutzen (`apiGet<T>`, Axios `<T>`).
* Responses nie als `any` akzeptieren → **Runtime-Validation** (z. B. **Zod**) ist best practice.
* UI-Status via **Discriminated Union** modellieren.
* **Envelope-/Pagination-Typen** standardisieren; **satisfies** für Endpoint-Maps.
* Fehler konsequent typisieren und per **Narrowing** behandeln.

**Quellen:**

* [TypeScript Docs – Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
* [TypeScript Docs – Utility Types](https://www.typescriptlang.org/docs/handbook/utility-types.html)
* [React TypeScript Cheatsheet – Basic/Typing Functions & Hooks](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/)
* [MDN – Fetch API](https://developer.mozilla.org/ru/docs/Web/API/Fetch_API)
* [React Docs](https://react.dev/)

**Zusammenfassung:**
Typisierte API-Kommunikation = **Generics für Fetch/Axios**, **DTO-Typen**, **Runtime-Validation (Zod)**, **Union-Status** für UI und sauberes **Error-Handling**.


  **[⬆ Наверх](#top)**

90. ### <a name="90"></a> Wie typisiert man React-Router-Komponenten?

### React Router mit TypeScript typisieren (v6.4+)

---

## 1) `useParams`

```js
import { useParams } from "react-router-dom"

// Generics definieren NUR die Param-Namen, Werte bleiben string | undefined
type Params = { id: string }

export function UserPage() {
  const { id } = useParams<Params>() // id: string | undefined
  if (!id) return <p>Kein ID-Parameter</p>
  return <h1>User {id}</h1>
}
```

**Sicherer mit Assertion/Narrowing:**

```js
function assertString(v: unknown): asserts v is string {
  if (typeof v !== "string") throw new Error("Expected string")
}

const { id } = useParams<{ id: string }>()
assertString(id) // ab hier: id: string
```

---

## 2) `useSearchParams`

```js
import { useSearchParams } from "react-router-dom"

export function List() {
  const [sp, setSp] = useSearchParams()
  const page = Number(sp.get("page") ?? "1") // page: number
  // setSp(prev => { prev.set("page", String(page+1)); return prev })
  return <div>Seite {page}</div>
}
```

---

## 3) `useNavigate`

```js
import { useNavigate } from "react-router-dom"

export function BackButton() {
  const navigate = useNavigate()
  return <button onClick={() => navigate(-1)}>Zurück</button>
}
```

---

## 4) Route-Objekte, Loader & Actions (Data Router)

```js
import { createBrowserRouter, RouterProvider } from "react-router-dom"

type User = { id: number; name: string }

async function usersLoader(): Promise<User[]> {
  const res = await fetch("/api/users")
  return res.json() // besser mit Zod validieren
}

function Users() {
  return <UsersList />
}

const router = createBrowserRouter([
  {
    path: "/users",
    element: <Users />,
    loader: usersLoader,
  }
])

export default function App() {
  return <RouterProvider router={router} />
}
```

**Loader-Daten konsumieren:**

```js
import { useLoaderData } from "react-router-dom"

export function UsersList() {
  const users = useLoaderData() as User[] // oder: useLoaderData<User[]>()
  return <ul>{users.map(u => <li key={u.id}>{u.name}</li>)}</ul>
}
```

---

## 5) `useRouteError` (Fehler typisieren)

```js
import { isRouteErrorResponse, useRouteError } from "react-router-dom"

export function ErrorBoundary() {
  const err = useRouteError()
  if (isRouteErrorResponse(err)) {
    return <p>HTTP {err.status}: {err.statusText}</p>
  }
  return <p>Unbekannter Fehler</p>
}
```

---

## 6) `Outlet`-Context typisieren

```js
import { Outlet, useOutletContext } from "react-router-dom"

type LayoutCtx = { locale: "de" | "en" }

export function Layout() {
  const ctx: LayoutCtx = { locale: "de" }
  return <Outlet context={ctx} />
}

export function Child() {
  const { locale } = useOutletContext<LayoutCtx>()
  return <p>Sprache: {locale}</p>
}
```

---

## 7) `Link`/`NavLink` (Props sind bereits typisiert)

```js
import { Link, NavLink } from "react-router-dom"

export function Nav() {
  return (
    <nav>
      <NavLink to="/users">Users</NavLink>
      <Link to={{ pathname: "/search", search: "?q=ts" }}>Suche</Link>
    </nav>
  )
}
```

---

## 8) Routen-Definitionen als Typhilfe (optional)

```js
const routes = {
  user: (id: string) => `/users/${id}`,
  search: (q: string) => `/search?q=${encodeURIComponent(q)}`
} as const

type AppRoutes = typeof routes
// routes.user("42") // string (typsicher konstruiert)
```

---

## 9) Zod/Runtime-Validation für Param/Suchwerte (Best Practice)

```js
import { z } from "zod"
const PageSchema = z.coerce.number().int().positive().default(1)

const [sp] = useSearchParams()
const page = PageSchema.parse(sp.get("page")) // number sicher validiert
```

---

### Zusammenfassung

* `useParams<Params>`: Generics definieren Schlüssel; Werte bleiben `string | undefined` → per Assertion/Narrowing absichern.
* Data Router: Loader/Action **Rückgabewerte** typisieren und mit `useLoaderData<T>()` konsumieren.
* `useRouteError`, `useOutletContext<T>()`, `useNavigate`, `useSearchParams` sind bereits TS-typisiert.
* Für robuste Apps: **Runtime-Validation** (z. B. Zod) bei Params/Query/Loader-Daten.

**Quellen**

* [React Router Docs – TypeScript](https://reactrouter.com/en/main/guides/typescript)
* [React Offizielle Doku](https://react.dev/)
* [TypeScript Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
* [React TypeScript Cheatsheet – Router](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/react_router/)

**Zusammenfassung**
React Router in TS: Params `string | undefined`, Loader per `useLoaderData<T>`, Fehler via `useRouteError`, Outlet-Kontext mit `useOutletContext<T>()`, Query über `useSearchParams`; bei Bedarf Zod einsetzen.

  **[⬆ Наверх](#top)**  

91. ### <a name="91"></a> Wie organisiert man Typen für ein gesamtes Projekt?

### Projektweite Typorganisation (Best Practices)

---

## 1) Ordnerstruktur – **Feature-first & nahe am Code**

```txt
src/
  features/
    users/
      api/
        types.ts        // DTOs/Server-Contracts
        schemas.ts      // Zod-Schemata + z.infer
      model/
        types.ts        // Domänen-/ViewModel-Typen
      ui/
        UserCard.tsx    // Props lokal in derselben Datei oder ui/types.ts
  shared/
    types/              // globale, wiederverwendbare Typen (Utility, IDs)
      index.ts
  app/
    types.ts            // App-weite Basistypen (Route-Maps, Feature-Flags)
  global.d.ts           // Ambient/Module Augmentation
```

**Grundsatz:** *Types so nah wie möglich beim Verbrauch* (Komponente/Feature), *global nur wirklich globales*.

---

## 2) **DTOs vs. Domänen-Typen** klar trennen

```js
// features/users/api/types.ts (Serververtrag)
export type UserDto = { id: number; first_name: string; email: string }

// features/users/model/types.ts (UI/Domain)
export type User = { id: number; name: string; email: string }
```

Mapping getrennt halten, damit API-Änderungen nicht die ganze App brechen.

---

## 3) **Runtime-Validation** + Typableitung (Zod)

```js
// features/users/api/schemas.ts
import { z } from "zod"

export const UserSchema = z.object({
  id: z.number().int().positive(),
  first_name: z.string(),
  email: z.string().email()
})
export type UserDto = z.infer<typeof UserSchema>
```

→ Ein Source of Truth für **Laufzeit** und **Compile-Zeit**.

---

## 4) **Barrel Files** (sparsam & gezielt)

```js
// shared/types/index.ts
export type Brand<K, T extends string> = K & { readonly __brand: T }
export type ID = Brand<number, "ID">
```

In Features lieber direkte Importe vermeiden wie `features/*/index.ts`, um **Zyklen** zu verhindern.

---

## 5) **Utility/Helper-Typen** zentral halten

```js
// shared/types/result.ts
export type Result<T, E = Error> =
  | { ok: true;  value: T }
  | { ok: false; error: E }
```

Wiederverwendbare Patterns (Result, Nullable, DeepReadonly, ValueObject-Branding) hier bündeln.

---

## 6) **React-spezifische Typen** nahe an Komponenten

```js
// features/users/ui/UserCard.tsx
type UserCardProps = { user: import("../model/types").User; onClick?: () => void }
export function UserCard({ user }: UserCardProps) { /* … */ }
```

Props im selben File halten (oder `ui/types.ts`), damit API klar zum UI gehört.

---

## 7) **Strict Mode** aktiv + Linting für Typen

`tsconfig.json`:

```js
{
  "compilerOptions": {
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "exactOptionalPropertyTypes": true,
    "noImplicitOverride": true,
    "useUnknownInCatchVariables": true,
    "moduleResolution": "bundler",
    "paths": { "@/*": ["src/*"] }
  }
}
```

Ergänze ESLint-Regeln (z. B. `@typescript-eslint/consistent-type-definitions`).

---

## 8) **Globale/ambient** Typen klar kapseln

```js
// global.d.ts
declare namespace AppEnv {
  type Mode = "development" | "production"
}
declare global {
  interface Window { __APP_MODE__: AppEnv.Mode }
}
export {}
```

Nur hier **`declare`**/Module Augmentation; meide Wildwuchs in vielen `.d.ts`.

---

## 9) **API-Layer** generisch & typisiert

```js
// shared/api/http.ts
export async function get<T>(url: string, init?: RequestInit): Promise<T> {
  const r = await fetch(url, init)
  const json: unknown = await r.json()
  return json as T // besser: Schema.parse(json)
}
```

Verbrauch pro Feature:

```js
import { UserSchema } from "@/features/users/api/schemas"
const dto = UserSchema.parse(await get<unknown>("/api/users/1"))
```

---

## 10) **Namenskonventionen**

* `FooDto` (Server), `Foo` (Domain), `FooInput`/`FooUpdate` (Forms), `FooProps` (React).
* Für Marken-/Nominaltypen: `Brand<T, Name>` oder `type UserId = Brand<number, "UserId">`.

---

## 11) **Generics, Utility Types und Discriminated Unions** standardisieren

```js
// shared/types/async.ts
export type AsyncState<T> =
  | { status: "idle" }
  | { status: "loading" }
  | { status: "success"; data: T }
  | { status: "error"; error: string }
```

Einmal definieren, überall nutzen (Loader, Hooks, Komponenten).

---

## 12) **Exports nur als Typen**, um Bundles sauber zu halten

```js
// types-only barrel
export type { User } from "./model/types"
```

Nutze `import type`/`export type` konsequent.

---

## 13) **Path-Aliases** für klare Imports

```js
// tsconfig.json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": { "@/*": ["src/*"], "@users/*": ["src/features/users/*"] }
  }
}
```

---

## 14) **Tests**: Typen separat prüfen

* `tsd`/`expect-type` für Typ-Tests.
* Edge-Cases: `exactOptionalPropertyTypes`, readonly/immutables, Union-Narrowing.

---

## 15) **Dokumentation**

Kurze README je Feature: *Welche Typen sind DTO, welche Domain, welche Props?*
Ergänze JSDoc an öffentliche Typen/Functions.

---

### Beispiel-Minipaket (Feature „users“)

```js
// features/users/model/types.ts
export type User = { id: number; name: string; email: string }

// features/users/ui/types.ts
export type UserCardProps = { user: User; compact?: boolean }

// features/users/ui/UserCard.tsx
import type { UserCardProps } from "./types"
export function UserCard({ user }: UserCardProps) { /* … */ }
```

---

### Zusammenfassung

* **Feature-first**: Typen nahe am Verbrauch; global nur truly-shared.
* **Trenne DTO ↔ Domain**, nutze **Zod** (oder ähnliches) für **Runtime-Validation** + `z.infer`.
* **Strict tsconfig**, klare **Namenskonventionen**, **types-only**-Exporte.
* **Utility/Async/Result**-Typen zentral; **Unions** für UI-Status.
* **Path-Aliases** & maßvolle **Barrels** zur Wartbarkeit.

**Quellen:**

* [TypeScript Handbook – Project Config](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html)
* [TypeScript Docs – Utility Types & Generics](https://www.typescriptlang.org/docs/handbook/utility-types.html)
* [React TypeScript Cheatsheet – Setup & Patterns](https://react-typescript-cheatsheet.netlify.app/docs/basic/setup)
* [React Offizielle Doku](https://react.dev/)

**Zusammenfassung**
Organisiere Typen **feature-basiert**, trenne **DTO/Domain**, sichere Daten per **Runtime-Validation**, halte **strict** aktiv, verwende **Utility/Unions** zentral und **types-only Exports** mit sauberen **Aliases**.

  **[⬆ Наверх](#top)**

92. ### <a name="92"></a> Wo speichert man gemeinsame Typen (z. B. User, Product)?

### Gemeinsame Typen sinnvoll ablegen

**Grundsatz:** *So nah wie möglich am Verbrauch, nur wirklich übergreifende Typen zentralisieren.*

---

## 1) Feature-first – bevorzugt

* **Domänen-/UI-Typen** (z. B. `User`, `Product`) leben im jeweiligen Feature.
* Vorteile: geringe Kopplung, klare Ownership, weniger Konflikte.

```txt
src/
  features/
    users/
      model/types.ts        // User (Domain)
      api/schemas.ts        // Zod + z.infer DTOs
    products/
      model/types.ts        // Product (Domain)
```

**Import (types-only):**

```js
import type { User } from "@/features/users/model/types"
```

---

## 2) Shared-Layer nur für wirklich gemeinsame Typen

* **Beispiele:** `ID`, `Result<T>`, `Pagination<T>`, Feature-übergreifende Value Objects.
* Kein “Mülleimer”: keine Feature-spezifischen Typen hier ablegen.

```txt
src/
  shared/
    types/
      result.ts     // Result<T, E>
      pagination.ts // Page<T>
      index.ts
```

```js
// shared/types/result.ts
export type Result<T, E = Error> =
  | { ok: true; value: T }
  | { ok: false; error: E }
```

---

## 3) DTOs vs. Domain trennen

* **API-DTOs** im jeweiligen Feature unter `api/` (plus *Zod* Schemas).
* **UI/Domain-Typen** unter `model/`.

```js
// features/users/api/schemas.ts
import { z } from "zod"
export const UserDtoSchema = z.object({
  id: z.number().int(),
  first_name: z.string(),
  email: z.string().email()
})
export type UserDto = z.infer<typeof UserDtoSchema>
```

---

## 4) Path-Aliases & Barrel Files (maßvoll)

```js
// tsconfig.json (Auszug)
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": { "@/*": ["src/*"] },
    "strict": true
  }
}
```

* **Barrels** (`index.ts`) nur, wenn sie keine **Zyklen** erzeugen.
* `import type` / `export type` nutzen, um unnötiges Bundling zu vermeiden.

---

## 5) Monorepo / geteilte Nutzung (Front+Back)

* Eigene **`packages/types`** (reines Type/Schema-Paket).
* Enthält **Schemas + `z.infer`-Typen** für Contracts (ein *Source of Truth*).

```txt
packages/
  types/
    src/
      user.ts       // Zod + Types
      product.ts
```

---

## 6) `global.d.ts` nur für Ambient/Erweiterungen

* **Nur** globale Augmentationen (z. B. `Window`, Env-Variablen), keine normalen Domänen-Typen.

```js
// global.d.ts
declare global {
  interface Window { __APP_MODE__: "development" | "production" }
}
export {}
```

---

### Zusammenfassung

* **Feature-nah** speichern (Domain/Props), **DTOs** im Feature-API-Layer, **wirklich gemeinsame** Utility-Typen nach `shared/types`.
* **Schemas (Zod)** + `z.infer` als Contract-Quelle; in Monorepos eigenes **types-Paket**.
* **Path-Aliases**, **types-only Exports**, **keine** wildwüchsigen globalen `.d.ts`.

🔗 Quellen:

* [TypeScript Docs – Project Config (`tsconfig`)](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html)
* [TypeScript Docs – Modules & `import type`](https://www.typescriptlang.org/docs/handbook/modules.html)
* [React TypeScript Cheatsheet – Setup & Patterns](https://react-typescript-cheatsheet.netlify.app/docs/basic/setup)
* [MDN – Module Basics](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Modules)

  **[⬆ Наверх](#top)**

93. ### <a name="93"></a> Wie typisiert man den globalen Store (Redux/RTK)?

### Globalen Store (Redux Toolkit) typisieren

---

## 1) Store & Root-Typen

```js
// store.ts
import { configureStore } from "@reduxjs/toolkit"
import counterReducer from "./features/counter/slice.js"

export const store = configureStore({
  reducer: {
    counter: counterReducer,
  }
})

// Globale Typen
export type RootState = ReturnType<typeof store.getState>
export type AppDispatch = typeof store.dispatch
```

---

## 2) Typisierte Hooks (`useAppDispatch`, `useAppSelector`)

```js
// hooks.ts
import { useDispatch, useSelector, type TypedUseSelectorHook } from "react-redux"
import type { RootState, AppDispatch } from "./store.js"

export const useAppDispatch = () => useDispatch<AppDispatch>()
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector
```

**Nutzung in Komponenten**

```js
import { useAppDispatch, useAppSelector } from "@/store/hooks.js"
import { increment } from "@/features/counter/slice.js"

export function Counter() {
  const n = useAppSelector(s => s.counter.value)
  const dispatch = useAppDispatch()
  return <button onClick={() => dispatch(increment())}>{n}</button>
}
```

---

## 3) Slice typisieren

```js
// features/counter/slice.ts
import { createSlice, PayloadAction } from "@reduxjs/toolkit"

type CounterState = { value: number }
const initialState: CounterState = { value: 0 }

const counterSlice = createSlice({
  name: "counter",
  initialState,
  reducers: {
    increment: (s) => { s.value += 1 },
    addBy: (s, a: PayloadAction<number>) => { s.value += a.payload },
  },
})

export const { increment, addBy } = counterSlice.actions
export default counterSlice.reducer
```

---

## 4) `createAsyncThunk` typisieren

```js
// features/users/thunks.ts
import { createAsyncThunk } from "@reduxjs/toolkit"

type User = { id: number; name: string }
type FetchUsersArg = { q?: string }

export const fetchUsers = createAsyncThunk<User[], FetchUsersArg>(
  "users/fetch",
  async (arg) => {
    const res = await fetch(`/api/users?q=${encodeURIComponent(arg.q ?? "")}`)
    return (await res.json()) as User[]
  }
)
```

**Extra-Argumente/Middleware (optional)**

```js
// Beispiel: getState/dispatch Typen sind aus RootState/AppDispatch abgeleitet
createAsyncThunk<User[], void, { state: RootState }>(
  "x/fetch",
  async (_, { getState }) => {
    const token = getState().auth.token
    // ...
    return []
  }
)
```

---

## 5) Store-Setup für Tests (PreloadedState)

```js
// testStore.ts
import { configureStore, type PreloadedState } from "@reduxjs/toolkit"
import type { RootState } from "./store.js"
import counter from "./features/counter/slice.js"

export function setupStore(preloadedState?: PreloadedState<RootState>) {
  return configureStore({ reducer: { counter }, preloadedState })
}
```

---

## 6) Selektoren typisieren

```js
// features/counter/selectors.ts
import type { RootState } from "@/store/store.js"
export const selectCount = (s: RootState) => s.counter.value
```

---

## 7) Typen exportieren (nur als Typ)

```js
// index.ts
export { store } from "./store.js"
export type { RootState, AppDispatch } from "./store.js"
```

---

### Zusammenfassung

* `configureStore` erstellen → `RootState = ReturnType<typeof store.getState>`, `AppDispatch = typeof store.dispatch`.
* Eigene Hooks: `useAppDispatch`, `useAppSelector<RootState>`.
* Slices mit `PayloadAction<T>` typisieren; `createAsyncThunk<Returned, Arg, { state: RootState }>` für Async.
* Selektoren mit `RootState` typisieren; Tests via `PreloadedState<RootState>`.

**Quellen:**

* [Redux Toolkit – TypeScript Quick Start](https://redux-toolkit.js.org/tutorials/typescript)
* [Redux Docs – TypeScript](https://redux.js.org/usage/usage-with-typescript)
* [React TypeScript Cheatsheet – Redux](https://react-typescript-cheatsheet.netlify.app/docs/basic/redux/)

**Zusammenfassung**
Store-Typen aus dem echten Store ableiten, **typed Hooks** exportieren, Actions/Thunks/Selektoren strikt mit generischen Signaturen typisieren.

  **[⬆ Наверх](#top)**

94. ### <a name="94"></a> Wie typisiert man Actions und Reducer im Redux Toolkit?

### Actions & Reducer im **Redux Toolkit** typisieren

---

## 1) `createSlice`: State & `PayloadAction<T>`

```js
import { createSlice } from "@reduxjs/toolkit"
import type { PayloadAction } from "@reduxjs/toolkit"

type CounterState = { value: number }
const initialState: CounterState = { value: 0 }

const counterSlice = createSlice({
  name: "counter",
  initialState, // → State-Typ wird aus initialState inferred
  reducers: {
    increment(state) {
      state.value += 1
    },
    addBy(state, action: PayloadAction<number>) {
      state.value += action.payload           // payload: number
    },
    setLabel(state, action: PayloadAction<{ id: number; text: string }>) {
      // action.payload: { id: number; text: string }
    }
  }
})

export const { increment, addBy, setLabel } = counterSlice.actions
export default counterSlice.reducer
```

*State-Typ:* aus `initialState` abgeleitet (oder explizit als Generics/Annotation angeben).
*Action-Typ:* pro Reducer via `PayloadAction<Payload>`.

---

## 2) `prepare`-Callback für strengere Payloads

```js
const todosSlice = createSlice({
  name: "todos",
  initialState: [] as { id: string; text: string; done: boolean }[],
  reducers: {
    add: {
      reducer(state, action: PayloadAction<{ id: string; text: string }>) {
        state.push({ ...action.payload, done: false })
      },
      prepare(text: string) {
        return { payload: { id: crypto.randomUUID(), text } }
      }
    }
  }
})
```

→ `prepare` definiert die *exakte* Payload-Form; der Reducer erhält sie typsicher.

---

## 3) Eigene Actions mit `createAction<T>()`

```js
import { createAction } from "@reduxjs/toolkit"

export const userLoaded = createAction<{ id: number; name: string }>("user/loaded")

// In extraReducers:
builder.addCase(userLoaded, (state, action) => {
  // action.payload: { id: number; name: string }
})
```

---

## 4) `createAsyncThunk` und `extraReducers` typisieren

```js
import { createAsyncThunk, createSlice } from "@reduxjs/toolkit"
import type { PayloadAction } from "@reduxjs/toolkit"

type User = { id: number; name: string }

// Returned = User[], Arg = string (query)
export const fetchUsers = createAsyncThunk<User[], string>(
  "users/fetch",
  async (q) => {
    const r = await fetch(`/api/users?q=${encodeURIComponent(q)}`)
    return (await r.json()) as User[]
  }
)

type UsersState = { items: User[]; loading: boolean; error?: string }
const initialUsers: UsersState = { items: [], loading: false }

const usersSlice = createSlice({
  name: "users",
  initialState: initialUsers,
  reducers: {
    clear(state) { state.items = [] }
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchUsers.pending, (state) => {
        state.loading = true
        state.error = undefined
      })
      .addCase(fetchUsers.fulfilled, (state, action) => {
        state.loading = false
        state.items = action.payload        // payload: User[]
      })
      .addCase(fetchUsers.rejected, (state, action) => {
        state.loading = false
        state.error = action.error.message  // string | undefined
      })
  }
})
```

`builder.addCase(thunk.fulfilled, …)` liefert **typsichere Payloads** (Returned-Type vom Thunk).

---

## 5) Matchers und mehrere Actions

```js
import { isAnyOf } from "@reduxjs/toolkit"

builder.addMatcher(
  isAnyOf(fetchUsers.pending, /* andere pending Actions */),
  (state) => { state.loading = true }
)
```

→ Matcher signalisieren die Form; die Payload ist je nach Matcher ggf. `unknown` oder eng, abhängig vom Prädikat.

---

## 6) Action-Typen ableiten (falls nötig)

```js
const a = usersSlice.actions
type UsersAction = ReturnType<typeof a.clear | typeof fetchUsers.fulfilled>
```

→ Praktisch für manuelle Typen (Middleware, Tests).

---

## 7) Reducer separat typisieren (selten nötig)

```js
import type { Reducer } from "@reduxjs/toolkit"

type S = { count: number }
type A = { type: "inc" } | { type: "add"; payload: number }

const reducer: Reducer<S, A> = (state = { count: 0 }, action) => {
  switch (action.type) {
    case "inc":  return { count: state.count + 1 }
    case "add":  return { count: state.count + action.payload }
    default:     return state
  }
}
```

→ In RTK meist über `createSlice` einfacher/typsicherer.

---

### Zusammenfassung

* **`PayloadAction<T>`** in `reducers` typisiert die `action.payload`.
* **`prepare`** erzwingt exakte Payload-Form.
* **`createAction<T>()`** für stand-alone Actions.
* **`createAsyncThunk<Returned, Arg>`** + `extraReducers` geben typsichere Payloads für `pending/fulfilled/rejected`.
* **Matcher** für Gruppen von Actions; **ReturnType** nützlich für Action-Typ-Ableitungen.

**Quellen:**

* [Redux Toolkit – TypeScript Quick Start](https://redux-toolkit.js.org/tutorials/typescript)
* [Redux – Usage with TypeScript](https://redux.js.org/usage/usage-with-typescript)
* [TypeScript Handbook – Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
* [React TypeScript Cheatsheet – Redux](https://react-typescript-cheatsheet.netlify.app/docs/basic/redux/)

**Zusammenfassung**
Actions typisiert man mit **`PayloadAction<T>`** (oder `createAction<T>()`), Reducer via **`createSlice`** (State aus `initialState` abgeleitet). Async-Flow über **`createAsyncThunk`** und **`extraReducers`** mit automatisch passender Payload.

  **[⬆ Наверх](#top)**

95. ### <a name="95"></a> Wie typisiert man useSelector und useDispatch?

**useSelector und useDispatch typisieren (Redux Toolkit + TypeScript)**

Damit TypeScript im ganzen Projekt korrekt mit dem Redux-Store arbeitet, werden üblicherweise zwei Hilfstypen erstellt:

1. **RootState** – der kombinierte Zustand des Stores.
2. **AppDispatch** – der Dispatch-Typ.

Diese Typen werden anschließend in eigenen Hooks genutzt:

```js
// store.ts
import { configureStore } from '@reduxjs/toolkit'
import counterReducer from './counterSlice.js'

export const store = configureStore({
  reducer: {
    counter: counterReducer,
  },
})

// RootState = abgeleitet aus dem Store-State
export type RootState = ReturnType<typeof store.getState>

// AppDispatch = Typ der Dispatch-Funktion
export type AppDispatch = typeof store.dispatch
```

👉 Danach erstellt man **typed Hooks**:

```js
// hooks.ts
import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux'
import type { RootState, AppDispatch } from './store.js'

// Typed Dispatch
export const useAppDispatch = () => useDispatch<AppDispatch>()

// Typed Selector
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector
```

👉 Beispiel in einer Komponente:

```js
// Counter.tsx
import React from 'react'
import { useAppSelector, useAppDispatch } from './hooks.js'
import { increment } from './counterSlice.js'

export default function Counter() {
  const count = useAppSelector(state => state.counter.value) // RootState korrekt typisiert
  const dispatch = useAppDispatch() // kennt AppDispatch

  return (
    <div>
      <p>{count}</p>
      <button onClick={() => dispatch(increment())}>
        Increment
      </button>
    </div>
  )
}
```

---

**Zusammenfassung**

* `RootState = ReturnType<typeof store.getState>` → Typ für gesamten State.
* `AppDispatch = typeof store.dispatch` → Typ für Dispatch.
* Mit **custom Hooks** (`useAppSelector`, `useAppDispatch`) werden Selektoren und Dispatch **typsicher** gemacht.

📚 Quellen:

* [Redux Toolkit – TypeScript Quick Start](https://redux-toolkit.js.org/tutorials/typescript)
* [React-Redux TypeScript Cheatsheet](https://react-typescript-cheatsheet.netlify.app/docs/react-redux/typed-hooks)

---

  **[⬆ Наверх](#top)**

96. ### <a name="96"></a> Wie typisiert man einen Zustand-Store (Zustand)?

**Zustand Store typisieren (TypeScript)**

Bei [Zustand](https://docs.pmnd.rs/zustand/getting-started/introduction) wird der Zustand typischerweise über ein Interface definiert. Dieses Interface beschreibt die **State-Werte** und **Actions**.

---

### Beispiel: einfacher Counter-Store

```js
// store.ts
import { create } from 'zustand'

// 1. State-Interface definieren
interface CounterState {
  count: number
  increment: () => void
  decrement: () => void
}

// 2. Store mit generischem Typ anlegen
export const useCounterStore = create<CounterState>((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
  decrement: () => set((state) => ({ count: state.count - 1 })),
}))
```

---

### Verwendung in einer Komponente

```js
// Counter.tsx
import React from 'react'
import { useCounterStore } from './store.js'

export default function Counter() {
  const count = useCounterStore((state) => state.count)
  const increment = useCounterStore((state) => state.increment)

  return (
    <div>
      <p>{count}</p>
      <button onClick={increment}>+1</button>
    </div>
  )
}
```

---

### Erweiterung: get + set im Store

Wenn man Zugriff auf den kompletten Zustand braucht (z. B. asynchrone Logik), kann man `set` und `get` typisieren:

```js
interface UserState {
  user: string | null
  setUser: (name: string) => void
  reset: () => void
}

export const useUserStore = create<UserState>((set, get) => ({
  user: null,
  setUser: (name) => set({ user: name }),
  reset: () => set({ user: null }),
}))
```

---

**Zusammenfassung**

* Zustand-Store wird über ein Interface für State + Actions typisiert.
* `create<StateType>((set, get) => …)` nutzt das Interface als generischen Typ.
* Dadurch sind sowohl State-Werte als auch Actions in Komponenten **typsicher**.

📚 Quellen:

* [Zustand – TypeScript Usage](https://docs.pmnd.rs/zustand/guides/typescript)
* [TypeScript Docs: Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)

---

  **[⬆ Наверх](#top)**

97. ### <a name="97"></a> Wie typisiert man Async Thunks?

**Async Thunks typisieren (Redux Toolkit + TypeScript)**

---

### Grundidee: Generics von `createAsyncThunk`

```ts
createAsyncThunk<Returned, ThunkArg, ThunkApiConfig>(type, payloadCreator)
```

* **Returned**: Erfolgs‐Payload (was `payloadCreator` zurückgibt).
* **ThunkArg**: Argument, das beim Dispatch übergeben wird.
* **ThunkApiConfig**: Optionale Typen für `{ state, dispatch, extra, rejectValue }`.

---

### Basisbeispiel mit erfolgreicher Payload

```js
// features/users/usersThunks.ts
import { createAsyncThunk } from '@reduxjs/toolkit'

// API-Modelle
export type User = { id: string; name: string }
export type FetchUserArg = { id: string }

// Returned = User, ThunkArg = FetchUserArg
export const fetchUser = createAsyncThunk<User, FetchUserArg>(
  'users/fetchUser',
  async ({ id }) => {
    const res = await fetch(`/api/users/${id}`)
    if (!res.ok) throw new Error('Network error')
    return res.json() // => User
  }
)
```

---

### Mit `rejectWithValue` (typisierte Fehler-Payload)

```js
// features/users/usersThunks.ts
import { createAsyncThunk } from '@reduxjs/toolkit'

type User = { id: string; name: string }
type FetchUserArg = { id: string }
type ApiError = { code: string; message: string }

// ThunkApiConfig mit rejectValue
export const fetchUserSafe = createAsyncThunk<
  User,                      // Returned
  FetchUserArg,              // ThunkArg
  { rejectValue: ApiError }  // ThunkApiConfig
>(
  'users/fetchUserSafe',
  async ({ id }, { rejectWithValue }) => {
    const res = await fetch(`/api/users/${id}`)
    if (!res.ok) {
      const err = await res.json()
      return rejectWithValue(err) // err: ApiError
    }
    return res.json()
  }
)
```

---

### Mit `RootState`, `AppDispatch` und `extra`

```js
// app/store.ts
import { configureStore } from '@reduxjs/toolkit'
import usersReducer from '../features/users/usersSlice.js'

export const store = configureStore({
  reducer: { users: usersReducer },
  // optional: extra für Services, z. B. API-Client
  // middleware: (gDM) => gDM({ thunk: { extraArgument: apiClient } }),
})

export type RootState = ReturnType<typeof store.getState>
export type AppDispatch = typeof store.dispatch
```

```js
// features/users/usersThunks.ts
import { createAsyncThunk } from '@reduxjs/toolkit'
import type { RootState, AppDispatch } from '../../app/store.js'

// Returned, Arg, ThunkApiConfig inkl. state/dispatch/extra
export const fetchMe = createAsyncThunk<
  { id: string; name: string },                 // Returned
  void,                                         // Arg
  { state: RootState; dispatch: AppDispatch }   // ThunkApiConfig
>(
  'users/fetchMe',
  async (_arg, { getState, dispatch }) => {
    const token = getState().auth.token
    const res = await fetch('/api/me', { headers: { Authorization: `Bearer ${token}` } })
    if (!res.ok) throw new Error('Unauthorized')
    const me = await res.json()
    // dispatch(...) wäre hier typisiert
    return me
  }
)
```

---

### Verwendung im Slice (Typen werden automatisch abgeleitet)

```js
// features/users/usersSlice.ts
import { createSlice } from '@reduxjs/toolkit'
import { fetchUserSafe } from './usersThunks.js'

const initialState = { entity: null, loading: false, error: null }

const usersSlice = createSlice({
  name: 'users',
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchUserSafe.pending, (state) => {
        state.loading = true
        state.error = null
      })
      .addCase(fetchUserSafe.fulfilled, (state, action) => {
        state.loading = false
        state.entity = action.payload // payload: User
      })
      .addCase(fetchUserSafe.rejected, (state, action) => {
        state.loading = false
        // action.payload ist ApiError | undefined (bei rejectWithValue gesetzt)
        state.error = action.payload ?? { code: 'UNKNOWN', message: action.error.message }
      })
  },
})

export default usersSlice.reducer
```

---

### Verwendung in Komponenten mit `.unwrap()` (typsicheres Error-Handling)

```js
// components/ProfileButton.tsx
import React from 'react'
import { useAppDispatch } from '../app/hooks.js'
import { fetchUserSafe } from '../features/users/usersThunks.js'

export default function ProfileButton() {
  const dispatch = useAppDispatch()

  const onClick = async () => {
    try {
      const user = await dispatch(fetchUserSafe({ id: '42' })).unwrap()
      console.log('OK:', user) // user: User
    } catch (err) {
      // err: ApiError (wenn rejectWithValue genutzt), sonst Error
      console.error('FAILED:', err)
    }
  }

  return <button onClick={onClick}>Load Profile</button>
}
```

---

**Zusammenfassung**

* `createAsyncThunk<Returned, Arg, { state, dispatch, extra, rejectValue }>()` präzise typisieren.
* Für Fehlerpfade `rejectWithValue` + eigenes Fehlermodell nutzen.
* `RootState`/`AppDispatch` im `ThunkApiConfig` verfügbar machen.
* In Komponenten `.unwrap()` für typsichere Erfolg/Fehler-Zweige.

**Quellen**

* Redux Toolkit: *TypeScript Quick Start* & *createAsyncThunk* (aktuell): [https://redux-toolkit.js.org/tutorials/typescript](https://redux-toolkit.js.org/tutorials/typescript) , [https://redux-toolkit.js.org/api/createAsyncThunk](https://redux-toolkit.js.org/api/createAsyncThunk)
* TypeScript Generics: [https://www.typescriptlang.org/docs/handbook/2/generics.html](https://www.typescriptlang.org/docs/handbook/2/generics.html)
* MDN (RU) – `fetch`: [https://developer.mozilla.org/ru/docs/Web/API/fetch](https://developer.mozilla.org/ru/docs/Web/API/fetch)
* React TypeScript Cheatsheet (React-Redux Abschnitt): [https://react-typescript-cheatsheet.netlify.app/docs/react-redux/overview/](https://react-typescript-cheatsheet.netlify.app/docs/react-redux/overview/)

  **[⬆ Наверх](#top)**

98. ### <a name="98"></a> Wie typisiert man Query Hooks in RTK Query?

**RTK Query: Query-Hooks korrekt typisieren**

> Kernidee: Die Typen der Hooks (`useXxxQuery`, `useLazyXxxQuery`) werden **automatisch** aus den generischen Typen der Endpoints abgeleitet: `builder.query<ResultType, QueryArg>()`.

---

### 1) API mit typisierten Endpoints definieren

```js
// services/api.ts
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'

// Domänen-Typen
export type User = { id: string; name: string }
export type GetUserArg = { id: string }

// ResultType = User, QueryArg = GetUserArg
export const api = createApi({
  reducerPath: 'api',
  baseQuery: fetchBaseQuery({ baseUrl: '/api' }),
  endpoints: (build) => ({
    getUser: build.query<User, GetUserArg>({
      query: ({ id }) => `/users/${id}`,
      // optional: transformResponse: (raw: unknown) => raw as User
    }),
  }),
})

// Auto-generierte, TYPISIERTE Hooks
export const { useGetUserQuery, useLazyGetUserQuery } = api
```

**Ergebnis:**

* `useGetUserQuery({ id: string })` erwartet genau `GetUserArg` und liefert `data?: User`.
* `useLazyGetUserQuery()` liefert ein Tupel: `[trigger, { data?: User, ... }]` – beides streng typisiert.

---

### 2) Nutzung der Query-Hooks in Komponenten

```js
// components/Profile.tsx
import React from 'react'
import { useGetUserQuery } from '../services/api.js'

export default function Profile() {
  // arg ist typsicher: { id: string }
  const { data, isLoading, isError } = useGetUserQuery({ id: '42' })

  if (isLoading) return <p>Laden…</p>
  if (isError) return <p>Fehler</p>

  return <div>{data?.name}</div> // data: User | undefined
}
```

---

### 3) Bedingtes Laden: `skipToken` statt `skip` (bewahrt Typen)

```js
// components/MaybeProfile.tsx
import React from 'react'
import { skipToken } from '@reduxjs/toolkit/query'
import { useGetUserQuery } from '../services/api.js'

export default function MaybeProfile({ id }) {
  // Wenn id nicht vorhanden -> Query wird übersprungen,
  // *ohne* die Typen zu verlieren.
  const result = useGetUserQuery(id ? { id } : skipToken)

  // result.data bleibt: User | undefined
  return <pre>{JSON.stringify(result.data)}</pre>
}
```

---

### 4) Selektoren aus Hooks: `selectFromResult` (feingranulare Typen)

```js
// components/UserName.tsx
import React from 'react'
import { useGetUserQuery } from '../services/api.js'

export default function UserName({ id }) {
  const { name } = useGetUserQuery({ id }, {
    // name: string | undefined — korrekt abgeleitet aus User
    selectFromResult: ({ data }) => ({ name: data?.name }),
  })
  return <span>{name ?? '—'}</span>
}
```

---

### 5) Generics bei `queryFn` / `transformResponse` (falls nötig)

```js
// services/api-advanced.ts
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'
export type Post = { id: number; title: string }

export const api2 = createApi({
  reducerPath: 'api2',
  baseQuery: fetchBaseQuery({ baseUrl: '/api' }),
  endpoints: (b) => ({
    //          ResultType  QueryArg
    getPost: b.query<Post, number>({
      query: (id) => `/posts/${id}`,
      transformResponse: (raw) => raw, // raw -> Post (durch Generics erzwungen)
    }),
  }),
})
```

---

### 6) Fehler-Typen auslesen (Hook-Result)

```js
// components/Post.tsx
import React from 'react'
import { useGetPostQuery } from '../services/api-advanced.js'
import type { FetchBaseQueryError } from '@reduxjs/toolkit/query'

export default function Post({ id }) {
  const { data, error } = useGetPostQuery(id)
  // error: FetchBaseQueryError | SerializedError | undefined
  const fbq = error as FetchBaseQueryError | undefined
  const status = fbq && 'status' in fbq ? fbq.status : undefined

  return <div>{data?.title ?? `Fehler: ${String(status ?? '')}`}</div>
}
```

---

### 7) Prefetch & Caching-Helfer bleiben typisiert

```js
// components/PrefetchButton.tsx
import React from 'react'
import { api } from '../services/api.js'

export default function PrefetchButton() {
  const prefetchUser = api.usePrefetch('getUser') // Endpoint-Name ist typgeprüft
  return (
    <button onMouseEnter={() => prefetchUser({ id: '42' }, { force: false })}>
      Prefetch User 42
    </button>
  )
}
```

---

**Zusammenfassung**

* Typen der Query-Hooks werden aus `builder.query<Result, Arg>` **automatisch** abgeleitet.
* `skipToken` für konditionelles Laden nutzen, ohne Typen zu verlieren.
* `selectFromResult` für schmale, strikt typisierte Slices aus Hook-Resultaten.
* Fehlerzugriff via `FetchBaseQueryError | SerializedError`.
* `useLazyXxxQuery`, `usePrefetch` und Helfer sind endpoint-basiert typisiert.

**Quellen**

* RTK Query – *Usage With TypeScript*: ([redux-toolkit.js.org][1])
* RTK Query – *Queries* & React-Hooks API: ([redux-toolkit.js.org][2])
* RTK Query – *Conditional Fetching* (`skipToken`): ([redux-toolkit.js.org][3])
* React TypeScript Cheatsheets: ([react-typescript-cheatsheet.netlify.app][4])
* TypeScript Generics (off. Docs): [https://www.typescriptlang.org/docs/handbook/2/generics.html](https://www.typescriptlang.org/docs/handbook/2/generics.html)

[1]: https://redux-toolkit.js.org/rtk-query/usage-with-typescript?utm_source=chatgpt.com "Usage With TypeScript"
[2]: https://redux-toolkit.js.org/rtk-query/usage/queries?utm_source=chatgpt.com "Queries"
[3]: https://redux-toolkit.js.org/rtk-query/usage/conditional-fetching?utm_source=chatgpt.com "Conditional Fetching"
[4]: https://react-typescript-cheatsheet.netlify.app/?utm_source=chatgpt.com "React TypeScript Cheatsheets"

  **[⬆ Наверх](#top)**

99. ### <a name="99"></a> Wie verwendet man Enums für Redux-Actions?

**Enums für Redux-Actions (TypeScript)**

Enums helfen, **Action-Typen typsicher und konsistent** zu definieren. Damit verhindert man Tippfehler bei Strings und erhält Autovervollständigung.

---

### 1) Enum für Action Types definieren

```ts
// actionTypes.ts
export enum CounterActionType {
  INCREMENT = 'counter/increment',
  DECREMENT = 'counter/decrement',
  RESET = 'counter/reset',
}
```

---

### 2) Action Creator mit Enum nutzen

```ts
// actions.ts
import { CounterActionType } from './actionTypes.js'

export const increment = () => ({
  type: CounterActionType.INCREMENT as const,
})

export const decrement = () => ({
  type: CounterActionType.DECREMENT as const,
})

export const reset = () => ({
  type: CounterActionType.RESET as const,
})
```

---

### 3) Union-Typ für Actions ableiten

```ts
// types.ts
import * as actions from './actions.js'

export type CounterAction = 
  | ReturnType<typeof actions.increment>
  | ReturnType<typeof actions.decrement>
  | ReturnType<typeof actions.reset>
```

---

### 4) Reducer mit Enum typisieren

```ts
// reducer.ts
import { CounterActionType } from './actionTypes.js'
import type { CounterAction } from './types.js'

interface CounterState {
  value: number
}

const initialState: CounterState = { value: 0 }

export function counterReducer(
  state: CounterState = initialState,
  action: CounterAction
): CounterState {
  switch (action.type) {
    case CounterActionType.INCREMENT:
      return { value: state.value + 1 }
    case CounterActionType.DECREMENT:
      return { value: state.value - 1 }
    case CounterActionType.RESET:
      return { value: 0 }
    default:
      return state
  }
}
```

---

### 5) Verwendung in Komponenten

```tsx
// Counter.tsx
import React from 'react'
import { useDispatch, useSelector } from 'react-redux'
import { increment, decrement, reset } from './actions.js'
import type { RootState } from './store.js'

export default function Counter() {
  const count = useSelector((state: RootState) => state.counter.value)
  const dispatch = useDispatch()

  return (
    <div>
      <p>{count}</p>
      <button onClick={() => dispatch(increment())}>+1</button>
      <button onClick={() => dispatch(decrement())}>-1</button>
      <button onClick={() => dispatch(reset())}>Reset</button>
    </div>
  )
}
```

---

### Hinweis: Redux Toolkit

Wenn du Redux Toolkit benutzt, brauchst du **keine Enums** – Action-Typen werden automatisch erzeugt (`slice.actions`). Enums sind eher für **klassische Redux-Setups** sinnvoll.

---

**Zusammenfassung**

* Mit `enum` werden Action-Typen zentral und typsicher verwaltet.
* Action Creators + Reducer nutzen Enum-Werte statt String-Literale.
* Vorteil: Autovervollständigung, weniger Fehler, konsistentes Handling.
* In Redux Toolkit oft überflüssig, da dort Action-Typen automatisch generiert werden.

📚 Quellen:

* [TypeScript Handbook – Enums](https://www.typescriptlang.org/docs/handbook/enums.html)
* [Redux Fundamentals: Actions](https://redux.js.org/tutorials/fundamentals/part-2-concepts-data-flow#actions)
* [Redux Toolkit vs. Vanilla Redux](https://redux-toolkit.js.org/introduction/getting-started)

---

  **[⬆ Наверх](#top)**

100. ### <a name="100"></a> Wie typisiert man Formulare mit React Hook Form?

**Formulare mit React Hook Form typisieren (TypeScript)**

---

### 1) Grundstruktur: `useForm<FormValues>()`

```js
// Form.tsx
import React from 'react'
import { useForm } from 'react-hook-form'

type FormValues = {
  email: string
  age: number
}

export default function BasicForm() {
  const { register, handleSubmit, formState: { errors } } =
    useForm<FormValues>({
      defaultValues: { email: '', age: 18 }, // passt zu FormValues
    })

  const onSubmit = (data: FormValues) => console.log(data)

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input {...register('email', { required: 'E-Mail ist Pflicht' })} />
      {errors.email && <span>{errors.email.message}</span>}

      <input type="number" {...register('age', { min: { value: 18, message: '≥ 18' } })} />
      {errors.age && <span>{errors.age.message}</span>}

      <button type="submit">Senden</button>
    </form>
  )
}
```

*`register('email')`/`errors.email` sind streng an `FormValues` gebunden.* ([react-hook-form.com][1])

---

### 2) Kontrollierte Komponenten: `Controller`

```js
// WithController.tsx
import React from 'react'
import { useForm, Controller } from 'react-hook-form'

type FormValues = { country: string }

export default function WithController() {
  const { control, handleSubmit } = useForm<FormValues>({ defaultValues: { country: 'DE' } })

  return (
    <form onSubmit={handleSubmit(console.log)}>
      <Controller
        name="country"             // keyof FormValues → typgeprüft
        control={control}
        render={({ field }) => (
          <select {...field}>
            <option value="DE">Deutschland</option>
            <option value="AT">Österreich</option>
          </select>
        )}
      />
      <button type="submit">OK</button>
    </form>
  )
}
```

*`Controller` hält Typen und verbindet kontrollierte UI-Komponenten (z. B. Select).* ([react-hook-form.com][2])

---

### 3) Schema-Validierung + Typen aus Zod ableiten

```js
// WithZod.tsx
import React from 'react'
import { useForm } from 'react-hook-form'
import { z } from 'zod'
import { zodResolver } from '@hookform/resolvers/zod'

const schema = z.object({
  email: z.string().email(),
  age: z.number().min(18),
})

type FormValues = z.infer<typeof schema>

export default function WithZod() {
  const { register, handleSubmit, formState: { errors } } =
    useForm<FormValues>({ resolver: zodResolver(schema) })

  return (
    <form onSubmit={handleSubmit(console.log)}>
      <input {...register('email')} />
      <span>{errors.email?.message}</span>

      <input type="number" {...register('age', { valueAsNumber: true })} />
      <span>{errors.age?.message}</span>

      <button type="submit">Save</button>
    </form>
  )
}
```

*Resolver integriert externe Validatoren; `z.infer` hält Formtypen in Sync.* ([GitHub][3])

---

### 4) Verschachtelte/Mehrteilige Formulare: `FormProvider` + `useFormContext`

```js
// FormProviderExample.tsx
import React from 'react'
import { useForm, FormProvider, useFormContext } from 'react-hook-form'

type FormValues = { user: { name: string; skills: string[] } }

function NameField() {
  const { register } = useFormContext<FormValues>()
  return <input {...register('user.name')} placeholder="Name" />
}

export default function ParentForm() {
  const methods = useForm<FormValues>({ defaultValues: { user: { name: '', skills: [] } } })

  return (
    <FormProvider {...methods}>
      <form onSubmit={methods.handleSubmit(console.log)}>
        <NameField />
        <button type="submit">Submit</button>
      </form>
    </FormProvider>
  )
}
```

*`FormProvider` stellt getypte Methoden tief verschachtelt bereit.* ([react-hook-form.com][4])

---

### 5) Dynamische Felder: `useFieldArray`

```js
// FieldArray.tsx
import React from 'react'
import { useForm, useFieldArray } from 'react-hook-form'

type FormValues = {
  users: { name: string }[]
}

export default function FieldArrayForm() {
  const { control, register, handleSubmit } = useForm<FormValues>({
    defaultValues: { users: [{ name: '' }] },
  })

  const { fields, append, remove } = useFieldArray<FormValues>({
    control,
    name: 'users', // keyof FormValues → korrekt typisiert
  })

  return (
    <form onSubmit={handleSubmit(console.log)}>
      {fields.map((f, i) => (
        <div key={f.id}>
          <input {...register(`users.${i}.name`)} />
          <button type="button" onClick={() => remove(i)}>X</button>
        </div>
      ))}
      <button type="button" onClick={() => append({ name: '' })}>Add</button>
      <button type="submit">Save</button>
    </form>
  )
}
```

*`useFieldArray` liefert getypte `fields/append/remove`; `name` muss zum Schema passen.* ([react-hook-form.com][5])

---

### 6) Form-Errors sind abgeleitet

```js
// Errors.tsx
import React from 'react'
import { useForm } from 'react-hook-form'

type FormValues = { email: string }
export default function Errors() {
  const { register, handleSubmit, formState: { errors, isSubmitting, isValid } } =
    useForm<FormValues>({ mode: 'onBlur' })

  // errors.email: FieldError | undefined, basierend auf FormValues
  return (
    <form onSubmit={handleSubmit(console.log)} noValidate>
      <input {...register('email', { required: 'Pflichtfeld' })} />
      <span>{errors.email?.message}</span>
      <button disabled={!isValid || isSubmitting}>Senden</button>
    </form>
  )
}
```

*RHFs TS-Support exportiert Typen für Fehler und Feldnamen (z. B. `FieldError`, `Path`).* ([react-hook-form.com][6])

---

**Zusammenfassung**

* `useForm<FormValues>()` ist die Basis; `register`, `errors` etc. werden daraus streng typisiert.
* Kontrollierte Inputs über `Controller`; verschachtelte Strukturen via `FormProvider`/`useFormContext`.
* Schema-Validierung mit Zod/Yup: `zodResolver(schema)` + `z.infer<typeof schema>`.
* Dynamische Listen mit `useFieldArray<FormValues>`, `name` entspricht dem Datenpfad.

**Quellen**

* RHF Docs: `useForm`, `Controller`, `useFieldArray`, `FormProvider`, `useFormContext`, TS-Support, Getting Started. ([react-hook-form.com][7])
* `react-hook-form/resolvers` (Zod/Yup/Joi …): ([GitHub][3])
* React TypeScript Cheatsheets – Forms & Events: ([react-typescript-cheatsheet.netlify.app][8])
* MDN – Client-side Form Validation / Constraint Validation API (RU/EN): ([developer.mozilla.org][9])
* TypeScript – Generics (für Schema- und Hook-Typen): [https://www.typescriptlang.org/docs/handbook/2/generics.html](https://www.typescriptlang.org/docs/handbook/2/generics.html)

[1]: https://www.react-hook-form.com/api/useform/?utm_source=chatgpt.com "useForm | React Hook Form - Simple React forms validation"
[2]: https://react-hook-form.com/docs/usecontroller/controller?utm_source=chatgpt.com "Controller"
[3]: https://github.com/react-hook-form/resolvers?utm_source=chatgpt.com "react-hook-form/resolvers"
[4]: https://react-hook-form.com/docs/formprovider?utm_source=chatgpt.com "FormProvider"
[5]: https://react-hook-form.com/docs/usefieldarray?utm_source=chatgpt.com "useFieldArray"
[6]: https://react-hook-form.com/ts?utm_source=chatgpt.com "Typescript Support"
[7]: https://react-hook-form.com/docs/useform?utm_source=chatgpt.com "useForm"
[8]: https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/forms_and_events/?utm_source=chatgpt.com "Forms and Events"
[9]: https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Forms/Form_validation?utm_source=chatgpt.com "Client-side form validation - Learn web development - MDN"

  **[⬆ Наверх](#top)**    

101. ### <a name="101"></a> Wie typisiert man axios-Requests?

**Axios-Requests typisieren (TypeScript)**

---

### 1) Basis: Rückgabe‐ und Body-Typen per Generics

```js
// api/users.ts
import axios from 'axios'

// Domänen-Typen
export type User = { id: string; name: string }
export type CreateUserBody = { name: string }

// GET: <T> = Datentyp der Response (response.data)
export async function getUsers() {
  const { data } = await axios.get<User[]>('/api/users')
  // data: User[]
  return data
}

// POST: <T, R, D> = Data, AxiosResponse, Request-Body
export async function createUser(body: CreateUserBody) {
  const { data } = await axios.post<User, import('axios').AxiosResponse<User>, CreateUserBody>(
    '/api/users',
    body
  )
  // data: User
  return data
}
```

> Axios-Signatur (vereinfacht): `axios.get<T, R = AxiosResponse<T>, D = any>(url, config)` – meist reicht **nur `T`**. ([axios-http.com][1])

---

### 2) Axios-Instanz + Typen konsistent nutzen

```js
// api/client.ts
import axios from 'axios'

export const api = axios.create({
  baseURL: '/api',
  timeout: 10_000,
})
```

```js
// api/posts.ts
import { api } from './client.js'
export type Post = { id: number; title: string }

export async function getPost(id) {
  const { data } = await api.get<Post>(`/posts/${id}`)
  return data // Post
}
```

> Instanzen kapseln Config/Interceptor; Generics funktionieren identisch. ([axios-http.com][2])

---

### 3) Fehler typisieren: `AxiosError<E>` + Narrowing

```js
// api/errors.ts
import axios, { AxiosError } from 'axios'

export type ApiError = { code: string; message: string }

export async function loadSafe() {
  try {
    const { data } = await axios.get<{ ok: true }>('/api/safe')
    return data
  } catch (err) {
    if (axios.isAxiosError(err)) {
      const e = err as AxiosError<ApiError>
      // e.response?.data: ApiError | undefined
      throw new Error(e.response?.data?.message ?? 'Unknown error')
    }
    throw err
  }
}
```

> Fehlerstruktur & Handling, inkl. `isAxiosError` und `validateStatus`. ([axios-http.com][3])

---

### 4) Request-Abbruch/Timeout mit `AbortController` (typisiert)

```js
// api/cancellable.ts
import axios from 'axios'

export async function fetchWithTimeout(url, ms = 5000) {
  const controller = new AbortController()
  const to = setTimeout(() => controller.abort(), ms)
  try {
    const res = await axios.get<string>(url, { signal: controller.signal })
    return res.data
  } finally {
    clearTimeout(to)
  }
}
```

> Axios unterstützt `signal` (AbortController); `cancelToken` ist veraltet. ([axios-http.com][4])

---

### 5) Interceptors ohne „any“

```js
// api/interceptors.ts
import { api } from './client.js'

api.interceptors.response.use(
  (res) => res, // behält AxiosResponse<T>
  (error) => {
    // hier kann error als AxiosError<unknown> behandelt und veredelt werden
    return Promise.reject(error)
  }
)
```

> Die generischen Typen der Antwort bleiben über Interceptors erhalten. ([axios-http.com][2])

---

### 6) Runtime-Validierung (optional) mit Zod — Typen bleiben synchron

```js
// api/validated.ts
import axios from 'axios'
import { z } from 'zod'

const UserSchema = z.object({ id: z.string(), name: z.string() })
type User = z.infer<typeof UserSchema>

export async function getUser(id) {
  const { data } = await axios.get<User>(`/api/users/${id}`)
  return UserSchema.parse(data) // Laufzeit-Check + TS-Typ
}
```

> TS-Generics sichern statische Typen; Schema validiert zur Laufzeit. (TS: Generics) ([typescriptlang.org][5])

---

### 7) Rückgabewerte der API-Funktionen explizit halten

```js
// Gute Praxis: explizite Promise-Typen
export async function login(creds) {
  const { data } = await axios.post<{ token: string }>('/api/login', creds)
  return data
}
// Aufrufer-Seite: `await login(...)` → { token: string }
```

> Generics + explizite Rückgabetypen erleichtern Autovervollständigung. (TS: Generics, Cheatsheet) ([typescriptlang.org][5])

---

**Zusammenfassung**

* `axios.get<T>()` → **`T` = `response.data`**; weitere Generics selten nötig.
* Für POST/PUT kann man zusätzlich **Request-Body `D`** typisieren.
* Fehlerpfade mit **`AxiosError<E>`** + `isAxiosError` sauber typisieren.
* **Instanz** + **AbortController** für sauberes API-Design.
* Optional **Schema-Validierung** (z. B. Zod) zur Laufzeit; Typen via `z.infer`.

**Quellen**

* Axios – API/Instance/Errors/Cancellation: ([axios-http.com][1])
* TypeScript – Generics: [https://www.typescriptlang.org/docs/handbook/2/generics.html](https://www.typescriptlang.org/docs/handbook/2/generics.html)
* React TypeScript Cheatsheets (Allg. Tipps): ([react-typescript-cheatsheet.netlify.app][6])

[1]: https://axios-http.com/docs/api_intro?utm_source=chatgpt.com "Axios API | Axios Docs"
[2]: https://axios-http.com/docs/instance?utm_source=chatgpt.com "The Axios Instance | Axios Docs"
[3]: https://axios-http.com/docs/handling_errors?utm_source=chatgpt.com "Handling Errors | Axios Docs"
[4]: https://axios-http.com/docs/cancellation?utm_source=chatgpt.com "Cancellation | Axios Docs"
[5]: https://www.typescriptlang.org/docs/handbook/2/generics.html?utm_source=chatgpt.com "Generics - TypeScript: Documentation"
[6]: https://react-typescript-cheatsheet.netlify.app/?utm_source=chatgpt.com "React TypeScript Cheatsheets"

  **[⬆ Наверх](#top)**

102. ### <a name="102"></a> Wie typisiert man fetch-Requests mit Generics?

**fetch-Requests mit Generics typisieren (TypeScript)**

---

### 1) Minimaler, generischer JSON-Fetcher

```js
// api/fetcher.ts
export async function getJSON<T>(input, init) {
  const res = await fetch(input, init)
  if (!res.ok) throw new Error(`HTTP ${res.status}`)
  // Response.json() liefert Promise<any> → wir erzwingen T
  return res.json() /** @type {Promise<T>} */
}
```

*`Response.json()` ist formal `Promise<any>`; wir geben T per Generics vor.* ([developer.mozilla.org][1])

---

### 2) GET/POST mit Request- und Response-Typen

```js
// api/users.ts
import { getJSON } from './fetcher.js'

/** @typedef {{ id: string; name: string }} User */
/** @typedef {{ name: string }} CreateUserBody */

export async function getUser(id) {
  return getJSON/** @type {<T>(...args: any[]) => Promise<T>} */(`/api/users/${id}`)
  // Aufrufer: const u = await getUser<User>('42')
}

export async function postJSON<R, B>(url, body) {
  const res = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body),
  })
  if (!res.ok) throw new Error(`HTTP ${res.status}`)
  return /** @type {Promise<R>} */ (res.json())
}

// Verwendung:
export async function createUser(body /*: CreateUserBody */) {
  return postJSON/** @type {<R,B>(u: string, b: B) => Promise<R>} */('/api/users', body)
  // Aufrufer: const u = await createUser/*<User, CreateUserBody>*/({ name: 'Sergii' })
}
```

*POST erfordert `JSON.stringify` und `Content-Type`. `Response.status` prüfen.* ([developer.mozilla.org][2])

---

### 3) Sicherer: erst `unknown`, dann validieren (z. B. Zod)

```js
// api/validated.ts
import { z } from 'zod'

const UserSchema = z.object({ id: z.string(), name: z.string() })
/** @typedef {z.infer<typeof UserSchema>} User */

export async function getUserSafe(id) {
  const res = await fetch(`/api/users/${id}`)
  if (!res.ok) throw new Error(`HTTP ${res.status}`)
  const data = /** @type {unknown} */ (await res.json())
  return UserSchema.parse(data) // Runtime-Validierung + TS-Typ
}
```

*`json()` → unbekannter Inhalt; Schema hält Typen & Laufzeit in Sync.* ([developer.mozilla.org][1])

---

### 4) Abbrechen/Timeout per `AbortController`

```js
// api/cancellable.ts
export async function fetchWithTimeout(url, ms = 8000) {
  const controller = new AbortController()
  const timer = setTimeout(() => controller.abort(), ms)
  try {
    const res = await fetch(url, { signal: controller.signal })
    if (!res.ok) throw new Error(`HTTP ${res.status}`)
    return res.json()
  } finally {
    clearTimeout(timer)
  }
}
```

*`signal` an `fetch` übergeben; `abort()` beendet Request.* ([developer.mozilla.org][3])

---

### 5) Typischer Wrapper mit generischer Fehlerform

```js
// api/wrapper.ts
/** @typedef {{ code: string; message: string }} ApiError */

export async function request<R, B = undefined>(url, init) {
  const res = await fetch(url, init)
  const text = await res.text()
  const parsed = text ? JSON.parse(text) : null
  if (!res.ok) {
    // parsed kann ApiError sein → eng tippen, wenn bekannt
    const err = /** @type {ApiError | null} */ (parsed)
    throw new Error(err?.message ?? `HTTP ${res.status}`)
  }
  return /** @type {R} */ (parsed)
}

// Verwendung:
export async function putUser(id, body /*: { name: string } */) {
  return request/** @type {<R,B>(u: string, i: RequestInit) => Promise<R>} */(
    `/api/users/${id}`,
    { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) }
  )
  // Aufrufer: const u = await putUser/*<User, {name:string}>*/('42', { name: 'Max' })
}
```

*Text lesen, manuell parsen → differenziertes Fehlerhandling möglich.* ([developer.mozilla.org][4])

---

**Zusammenfassung**

* Generische Helfer: `getJSON<T>()`, `postJSON<R,B>()` → `T/R` = Response, `B` = Body.
* `Response.json()` ist `any`; sicherer über `unknown` + Schema-Validierung (z. B. Zod).
* Status prüfen und Fehler modellieren; bei Bedarf `AbortController` für Abbruch/Timeout.
* Typen zentral kapseln, Aufrufer geben konkrete `<T>` an.

**Quellen**

* MDN – Fetch API (RU/EN), Using Fetch, `Response.json()`, `Response.status`, `RequestInit`. ([developer.mozilla.org][5])
* MDN – AbortController/`signal`/`abort()`. ([developer.mozilla.org][6])
* TypeScript – Generics (offizielle Doku). ([typescriptlang.org][7])

[1]: https://developer.mozilla.org/en-US/docs/Web/API/Response/json?utm_source=chatgpt.com "Response: json() method - Web APIs | MDN - Mozilla"
[2]: https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify?utm_source=chatgpt.com "JSON.stringify() - JavaScript | MDN - Mozilla"
[3]: https://developer.mozilla.org/en-US/docs/Web/API/AbortController/signal?utm_source=chatgpt.com "AbortController: signal property - Web APIs - MDN - Mozilla"
[4]: https://developer.mozilla.org/en-US/docs/Web/API/Response?utm_source=chatgpt.com "Response - Web APIs | MDN - Mozilla"
[5]: https://developer.mozilla.org/ru/docs/Web/API/Fetch_API?utm_source=chatgpt.com "Fetch API - Интерфейсы веб API - MDN"
[6]: https://developer.mozilla.org/en-US/docs/Web/API/AbortController?utm_source=chatgpt.com "AbortController - Web APIs - MDN - Mozilla"
[7]: https://www.typescriptlang.org/docs/handbook/2/generics.html?utm_source=chatgpt.com "Generics - TypeScript: Documentation"

  **[⬆ Наверх](#top)**

103. ### <a name="103"></a> Wie geht man mit Typen bei API-Fehlern um?

**API-Fehler typsicher behandeln (TypeScript)**

---

### 1) Grundprinzip: **`unknown` statt `any`**, dann Narrowing/Validierung

```js
// errors.ts
export type ApiError = {
  status: number
  message: string
  details?: unknown
}

// Hilfsfunktion für Exhaustiveness
export function assertNever(x /**: never */) {
  throw new Error(`Unexpected value: ${String(x)}`)
}
```

* Eingehende Fehlerdaten zuerst als `unknown` behandeln und dann per **Type Guards**/**Schema** validieren (z. B. Zod).
* Exhaustive Checks mit `never` verhindern „vergessene“ Fälle.
  ↗️ TS-Doku: Type Narrowing, `never`.
  [TypeScript: Narrowing](https://www.typescriptlang.org/docs/handbook/2/narrowing.html) · [TypeScript: never](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#the-never-type)

---

### 2) `fetch`: Fehler-Hülle + Discriminated Union (`Result<T, E>`)

```js
// http.ts
export type Ok<T> = { ok: true; data: T }
export type Err<E> = { ok: false; error: E }
export type Result<T, E> = Ok<T> | Err<E>

export async function requestJSON<T, E = ApiError>(input, init) {
  const res = await fetch(input, init)
  const text = await res.text()
  const parsed = text ? JSON.parse(text) : null

  if (res.ok) {
    return { ok: true, data: parsed /** @type {T} */ }
  }

  const error = /** @type {E} */ ({
    status: res.status,
    message: (parsed && parsed.message) ?? `HTTP ${res.status}`,
    details: parsed,
  })
  return { ok: false, error }
}
```

```js
// usage.ts
import { requestJSON } from './http.js'

/** @typedef {{ id: string; name: string }} User */
/** @typedef {{ code: string; message: string }} ApiErr */

export async function loadUser(id) {
  const res = await requestJSON/** @type {<T,E>(u:any,i?:any)=>Promise<{ok:true,data:T}|{ok:false,error:E}>} */(
    `/api/users/${id}`
  )
  if (res.ok) {
    // res.data: User
    return res.data
  }
  // res.error: ApiErr
  if ('code' in res.error) {
    throw new Error(`[${res.error.code}] ${res.error.message}`)
  }
  throw new Error(res.error.message)
}
```

* `res.ok` diskriminiert den Union-Typ → **typsicheres** Erfolgs-/Fehler-Handling.
* `fetch`-Basics & `Response.ok/status`.
  [MDN: Fetch API](https://developer.mozilla.org/ru/docs/Web/API/Fetch_API) · [MDN: Response](https://developer.mozilla.org/ru/docs/Web/API/Response)

---

### 3) **Runtime-Validierung** der Fehlerstruktur (Zod)

```js
// error-schema.ts
import { z } from 'zod'

export const ApiErrorSchema = z.object({
  code: z.string().optional(),
  message: z.string(),
  status: z.number().optional(),
  details: z.unknown().optional(),
})
export const parseApiError = (u) => ApiErrorSchema.parse(u)
```

```js
// http-validated.ts
import { parseApiError } from './error-schema.js'

export async function requestSafe(input, init) {
  const res = await fetch(input, init)
  const json = (await res.json().catch(() => null))
  if (res.ok) return json
  throw new Error(parseApiError(json).message)
}
```

* TS-Generics + Schema halten **Typen und Laufzeit** synchron.
  [TypeScript: Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)

---

### 4) Axios: `AxiosError<E>` + `isAxiosError`

```js
// axios-errors.ts
import axios, { AxiosError } from 'axios'

/** @typedef {{ code?: string; message: string }} ApiErr */

export async function loadSafe() {
  try {
    const { data } = await axios.get/** @type {<T>(u:string)=>Promise<import('axios').AxiosResponse<T>>} */('/api/safe')
    return data
  } catch (e) {
    if (axios.isAxiosError(e)) {
      const err = /** @type {AxiosError<ApiErr>} */ (e)
      const msg = err.response?.data?.message ?? err.message
      throw new Error(msg)
    }
    throw e
  }
}
```

* `AxiosError<E>` macht `response.data` im Fehlerfall **typisiert** zugreifbar.
* Abbruch via `AbortController` (Axios unterstützt `signal`).
  [Axios: Handling Errors](https://axios-http.com/docs/handling_errors) · [Axios: Cancellation](https://axios-http.com/docs/cancellation)

---

### 5) Redux Toolkit: `rejectWithValue<E>` für **typisierte** Fehler

```js
// usersThunks.ts
import { createAsyncThunk } from '@reduxjs/toolkit'

/** @typedef {{ id: string; name: string }} User */
/** @typedef {{ code: string; message: string }} ApiErr */

export const fetchUser = createAsyncThunk<
  User,                          // Returned
  { id: string },                // Arg
  { rejectValue: ApiErr }        // Fehler-Typ
>(
  'users/fetch',
  async ({ id }, { rejectWithValue }) => {
    const res = await fetch(`/api/users/${id}`)
    if (!res.ok) {
      const err = await res.json().catch(() => null)
      return rejectWithValue(/** @type {ApiErr} */(err ?? { code: 'UNKNOWN', message: 'Fail' }))
    }
    return res.json()
  }
)
```

```js
// slice.ts
import { createSlice } from '@reduxjs/toolkit'
import { fetchUser } from './usersThunks.js'

const slice = createSlice({
  name: 'users',
  initialState: { entity: null, error: null, loading: false },
  reducers: {},
  extraReducers: (b) => {
    b.addCase(fetchUser.pending, (s) => { s.loading = true; s.error = null })
    b.addCase(fetchUser.fulfilled, (s, a) => { s.loading = false; s.entity = a.payload })
    b.addCase(fetchUser.rejected, (s, a) => {
      // a.payload: ApiErr | undefined
      s.loading = false
      s.error = a.payload?.message ?? a.error.message
    })
  },
})
export default slice.reducer
```

* `rejectWithValue<E>` erzwingt ein **konsistentes Fehlerobjekt** im Store.
  [RTK: createAsyncThunk](https://redux-toolkit.js.org/api/createAsyncThunk) · [RTK TS-Guide](https://redux-toolkit.js.org/tutorials/typescript)

---

### 6) RTK Query: Fehler-Typen korrekt **narrowen**

```js
// rtkq.tsx
import React from 'react'
import type { FetchBaseQueryError } from '@reduxjs/toolkit/query'
import { useGetUserQuery } from './api.js'

export default function View({ id }) {
  const { data, error } = useGetUserQuery({ id })
  if (error) {
    const fbq = /** @type {FetchBaseQueryError} */ (error)
    const status = 'status' in fbq ? fbq.status : 'ERR'
    return <p>Fehler: {String(status)}</p>
  }
  return <pre>{JSON.stringify(data)}</pre>
}
```

* Hook-Fehler: `FetchBaseQueryError | SerializedError`; per `in`-Check unterscheidbar.
  [RTK Query: Errors](https://redux-toolkit.js.org/rtk-query/usage/customizing-queries#handling-errors)

---

### 7) HTTP-Status → **disziplinierte** Fehlerklassen (optional)

```js
// mapping.ts
export const toErrorCategory = (status) => {
  if (status >= 500) return 'ServerError'
  if (status === 401) return 'AuthError'
  if (status === 403) return 'Forbidden'
  if (status === 404) return 'NotFound'
  if (status >= 400) return 'ClientError'
  return 'Unknown'
}
```

* Klare Kategorien erleichtern UI/Retry-Strategien; mit `assertNever` absichern.

---

**Zusammenfassung**

* **`unknown` → Narrowing/Schema** statt `any`.
* Mit **`Result<T, E>`** (Discriminated Union) Erfolg/Fehler sauber trennen.
* **Axios**: `AxiosError<E>` + `isAxiosError`; **fetch**: `Response.ok/status` prüfen.
* **Redux Toolkit**: `rejectWithValue<E>` für typisierte Fehlerpfade; **RTK Query**: Fehler union-typen korrekt narrowen.
* Optional **Zod** für Laufzeit-Validierung, `never`/Exhaustiveness für Vollständigkeit.

**Quellen**

* TypeScript: [Narrowing](https://www.typescriptlang.org/docs/handbook/2/narrowing.html), [Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
* MDN: [Fetch API](https://developer.mozilla.org/ru/docs/Web/API/Fetch_API), [Response](https://developer.mozilla.org/ru/docs/Web/API/Response)
* Axios: [Handling Errors](https://axios-http.com/docs/handling_errors), [Cancellation](https://axios-http.com/docs/cancellation)
* Redux Toolkit: [createAsyncThunk](https://redux-toolkit.js.org/api/createAsyncThunk), [RTK Query Error Handling](https://redux-toolkit.js.org/rtk-query/usage/customizing-queries#handling-errors)
* React TypeScript Cheatsheets: [API / Data Fetching Hinweise](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/)

  **[⬆ Наверх](#top)**

104. ### <a name="104"></a> Wie verwendet man Utility Types für API-Modelle?

**Utility Types für API-Modelle (TypeScript)**

---

### 1) CRUD-DTOs aus Domänenmodell ableiten

```js
// models/user.ts
export type User = {
  id: string
  email: string
  name: string
  createdAt: string
  updatedAt: string
}

// Create: Felder, die der Server setzt, weglassen
export type CreateUserDto = Omit<User, 'id' | 'createdAt' | 'updatedAt'>

// Update (PATCH): nur erlaubte Felder optional
export type UpdateUserDto = Partial<Pick<User, 'email' | 'name'>>

// Serverantwort schreibgeschützt
export type UserResponse = Readonly<User>
```

---

### 2) Listen, Maps und Lookups

```js
// Paginierte Antwort
export type Page<T> = {
  items: T[]
  total: number
  page: number
  pageSize: number
}

// Index nach ID (z. B. Cache)
export type UserById = Record<User['id'], User>

// Sicherstellen, dass leere Felder nicht null/undefined sind
export type NonNullUser = {
  [K in keyof User]-?: NonNullable<User[K]>
}
```

---

### 3) Fehler- und Statusmodelle

```js
// Discriminated Union für API-Ergebnis
export type Ok<T> = { ok: true; data: T }
export type Err<E> = { ok: false; error: E }
export type Result<T, E> = Ok<T> | Err<E>

// Fehlerteil aus Server-Union extrahieren
type ApiError = { code: string; message: string }
type AnyResult = Result<User, ApiError>

// Beispiel für Utility Types:
type ErrorOnly = Extract<AnyResult, { ok: false }>['error'] // ApiError
type DataOnly = Extract<AnyResult, { ok: true }>['data']     // User
```

---

### 4) Request/Response je Endpoint präzisieren

```js
// services/users.ts
export type GetUserParams = { id: string }

// Response generisch
export type ApiResponse<T> = Promise<T>

// GET /users/:id
export type GetUserResponse = ApiResponse<UserResponse>

// POST /users
export type CreateUserResponse = ApiResponse<UserResponse>
export type CreateUserRequest = CreateUserDto

// PATCH /users/:id
export type UpdateUserRequest = UpdateUserDto
export type UpdateUserResponse = ApiResponse<UserResponse>
```

---

### 5) Ableitungen aus Funktionen (ReturnType/Parameters/Awaited)

```js
// api.ts
export async function fetchUser(id) {
  const res = await fetch(`/api/users/${id}`)
  return /** @type {Promise<UserResponse>} */ (res.json())
}

// Abgeleitete Typen:
export type FetchUserParams = Parameters<typeof fetchUser> // [id: string]
export type FetchUserReturn = ReturnType<typeof fetchUser> // Promise<UserResponse>
export type FetchUserData = Awaited<FetchUserReturn>       // UserResponse
```

---

### 6) DTOs für Teilmodelle (Komposition)

```js
export type UserPublic = Pick<User, 'id' | 'name'>
export type UserPrivate = Omit<User, 'createdAt' | 'updatedAt'>
export type SafeUserList = ReadonlyArray<UserPublic>
```

---

### 7) Deep-Partial (für komplexe PATCH-Bodies)

```js
// Hilfstyp für tiefes Partial
export type DeepPartial<T> = {
  [K in keyof T]?: T[K] extends object ? DeepPartial<T[K]> : T[K]
}

// Beispiel:
type Settings = { ui: { theme: 'light' | 'dark'; lang: string }; emails: { marketing: boolean } }
export type UpdateSettingsDto = DeepPartial<Settings>
```

---

### 8) Konstante Literale für enge Typen

```js
export const USER_ROLES = ['admin', 'editor', 'viewer'] as const
export type UserRole = typeof USER_ROLES[number] // 'admin' | 'editor' | 'viewer'

export type UserWithRole = User & { role: UserRole }
```

---

**Zusammenfassung**

* `Omit`, `Pick`, `Partial`, `Required`, `Readonly`, `Record`, `NonNullable` für CRUD-DTOs und Caches.
* `Extract`/`Exclude` für Union-Selektion; `ReturnType`/`Parameters`/`Awaited` für Ableitungen aus Funktionen.
* `as const` für enge String-Literale; optional eigener `DeepPartial` für verschachtelte PATCH-Bodies.
* So bleiben Request-/Response-Modelle **konsistent, präzise und wiederverwendbar**.

**Quellen**

* TypeScript Utility Types: [https://www.typescriptlang.org/docs/handbook/utility-types.html](https://www.typescriptlang.org/docs/handbook/utility-types.html)
* TypeScript Generics & Unions: [https://www.typescriptlang.org/docs/handbook/2/generics.html](https://www.typescriptlang.org/docs/handbook/2/generics.html) , [https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types)
* React TypeScript Cheatsheet (Modelle/Typen): [https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/)
* MDN – Fetch API (für Response-Modelle): [https://developer.mozilla.org/ru/docs/Web/API/Fetch_API](https://developer.mozilla.org/ru/docs/Web/API/Fetch_API)

  **[⬆ Наверх](#top)**

105. ### <a name="105"></a> Wie typisiert man Dynamic Imports in React?

**Dynamic Imports in React typisieren (TypeScript)**

---

### 1) Basis: `import()` in TS typisieren

```js
// Beliebiges Modul dynamisch laden und typisieren
export async function loadUtils() {
  const mod = await import('./utils.js')
  // Typ: typeof import('./utils.js')
  return mod
}

// Einzelnes Symbol:
export async function loadFn() {
  const { formatDate } = await import('./utils.js')
  // formatDate hat den Typ aus utils.js
  return formatDate
}
```

* Typableitung: `typeof import('./utils.js')`.
* Für reine Typen: `import type { UtilsType } from './utils.js'`.
* Nützlich: `Awaited<ReturnType<typeof import>>` für abgeleitete Typen.

---

### 2) `React.lazy` für **Default-Export**

```js
// Foo.tsx – default export
export default function Foo() { return <div>Foo</div> }
```

```js
// LazyFoo.tsx
import React, { lazy, Suspense } from 'react'

const Foo = lazy(() => import('./Foo.js')) // Typ: LazyExoticComponent<ComponentType<any>>

export default function Page() {
  return (
    <Suspense fallback={<p>Laden…</p>}>
      <Foo />
    </Suspense>
  )
}
```

* `React.lazy` erwartet eine Funktion, die **ein Promise mit `{ default: Component }`** zurückgibt.

---

### 3) `React.lazy` für **named export**

```js
// widgets.tsx – named export
export function Chart({ title }) { return <h3>{title}</h3> }
export type ChartProps = { title: string }
```

```js
// LazyChart.tsx
import React, { lazy, Suspense } from 'react'
import type { ChartProps } from './widgets.js'

// `then`-Mapping auf default:
const Chart = lazy(async () =>
  import('./widgets.js').then((m) => ({ default: m.Chart }))
)
// Typ von `Chart` wird zu LazyExoticComponent<ComponentType<ChartProps>>

export default function Panel() {
  return (
    <Suspense fallback={<span>…</span>}>
      <Chart title="Sales" />
    </Suspense>
  )
}
```

* Durch das `then`-Mapping bleibt der **Props-Typ** des named Exports erhalten.

---

### 4) Props explizit annotieren (optional)

```js
import React, { lazy, Suspense, type ComponentType, type LazyExoticComponent } from 'react'
type ProfileProps = { id: string }

// Falls nötig, den Props-Typ erzwingen:
const Profile: LazyExoticComponent<ComponentType<ProfileProps>> = lazy(() =>
  import('./Profile.js')
)

export function View() {
  return (
    <Suspense fallback={null}>
      <Profile id="42" />
    </Suspense>
  )
}
```

---

### 5) Typen aus dynamisch importiertem Modul ableiten

```js
// helpers.ts
export function calc(a, b) { return a + b }
export type CalcFn = typeof calc
```

```js
// derive.ts
type HelpersModule = typeof import('./helpers.js')
type Calc = HelpersModule['calc'] // = (a: number, b: number) => number
// oder:
type Loaded = Awaited<ReturnType<typeof import('./helpers.js')>>
type AlsoCalc = Loaded['calc']
```

---

### 6) Code-Splitting in Routen/Feature-Modulen

```js
// Route.tsx
import React, { lazy, Suspense } from 'react'

// Chunk nur bei Bedarf laden
const SettingsPage = lazy(() => import('./pages/SettingsPage.js'))

export function AppRoutes() {
  return (
    <Suspense fallback={<p>…</p>}>
      <SettingsPage />
    </Suspense>
  )
}
```

* **Wichtig:** Immer innerhalb von `<Suspense>` rendern (Fallback!).

---

### 7) Häufige Stolpersteine

* **Kein default export?** → über `then` in `{ default: m.Named }` mappen.
* **SSR/Next.js:** `React.lazy` rendert nur clientseitig; für SSR ggf. framework-spezifische Helpers (z. B. `next/dynamic`).
* **Typen prüfen:** Bei komplexen Re-Exports `typeof import()` oder `Awaited<…>` nutzen.

---

**Zusammenfassung**

* `typeof import('…')`, `Awaited<…>` und `import type` helfen bei exakter Typableitung.
* `React.lazy(() => import(...))` für Default-Exports; named Exports via `then({ default: m.Named })`.
* Props bleiben erhalten; optional `LazyExoticComponent<ComponentType<Props>>` annotieren.
* Immer `<Suspense>` mit Fallback verwenden.

**Quellen**

* React – *Code-Splitting* / `React.lazy` & `Suspense`: [https://react.dev/reference/react/lazy](https://react.dev/reference/react/lazy)
* MDN – *Dynamic import()*: [https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/import](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/import)
* TypeScript – *ES Module Syntax & import types*: [https://www.typescriptlang.org/docs/handbook/2/modules.html](https://www.typescriptlang.org/docs/handbook/2/modules.html)
* TypeScript – *Utility & Built-in Types* (`Awaited`, `ReturnType`): [https://www.typescriptlang.org/docs/handbook/utility-types.html](https://www.typescriptlang.org/docs/handbook/utility-types.html)
* React TypeScript Cheatsheet – *Code Splitting/Lazy*: [https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase#code-splitting](https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase#code-splitting)

  **[⬆ Наверх](#top)**

106. ### <a name="106"></a> Wie verwendet man keyof für dynamische Eigenschaften in Komponenten?

**`keyof` für dynamische Eigenschaften in React-Komponenten (TypeScript)**

Mit `keyof` kann man Props so typisieren, dass nur **gültige Schlüssel eines Objekts** erlaubt sind. Besonders nützlich für dynamische Property-Namen (z. B. generische Tabellen, Formulare, UI-Komponenten).

---

### 1) Basisidee mit `keyof`

```ts
type User = {
  id: string
  name: string
  age: number
}

type UserKeys = keyof User // "id" | "name" | "age"
```

---

### 2) Komponente: dynamisch ein Feld anzeigen

```tsx
import React from 'react'

type User = { id: string; name: string; age: number }

type UserFieldProps = {
  user: User
  field: keyof User // "id" | "name" | "age"
}

export function UserField({ user, field }: UserFieldProps) {
  return <span>{user[field]}</span>
}

// Nutzung:
const u: User = { id: '42', name: 'Sergii', age: 34 }

<UserField user={u} field="name" />   // ✅
<UserField user={u} field="email" />  // ❌ TypeScript-Error
```

* `user[field]` ist automatisch `string | number` → TS erzwingt Type-Safety.

---

### 3) Mit generischen Typen (wiederverwendbar)

```tsx
type FieldProps<T> = {
  entity: T
  field: keyof T
}

export function Field<T extends object>({ entity, field }: FieldProps<T>) {
  return <span>{String(entity[field])}</span>
}

// Nutzung mit User:
<Field entity={{ id: '1', name: 'Max' }} field="name" /> // OK
```

* `T` wird beim Aufruf inferiert → wiederverwendbar für beliebige Modelle.

---

### 4) Kombiniert mit `Pick` / `Omit`

```tsx
type User = { id: string; name: string; age: number }

type EditableProps<T> = {
  model: T
  editable: (keyof T)[]
}

function EditableForm<T extends object>({ model, editable }: EditableProps<T>) {
  return (
    <form>
      {editable.map((key) => (
        <input key={String(key)} defaultValue={String(model[key])} />
      ))}
    </form>
  )
}

// Nur bestimmte Felder editierbar:
<EditableForm model={{ id: '1', name: 'Anna', age: 30 }} editable={['name', 'age']} />
```

* `editable` ist auf gültige Keys eingeschränkt.

---

### 5) Dynamische Styles oder Attribute

```tsx
type StyleKeys = keyof React.CSSProperties // alle CSS-Eigenschaften

type DynamicStyleProps = {
  prop: StyleKeys
  value: string | number
}

function DynamicStyle({ prop, value }: DynamicStyleProps) {
  return <div style={{ [prop]: value }} />
}

<DynamicStyle prop="backgroundColor" value="red" /> // ✅
<DynamicStyle prop="foobar" value="123" />          // ❌ Fehler
```

* Typ-Sicherheit sogar für CSS-Properties.

---

### 6) Optional: Typen verfeinern

Manchmal möchte man sicherstellen, dass der Wert zum Key passt. Dafür nutzt man **Mapped Types**:

```tsx
type FieldProps<T, K extends keyof T> = {
  entity: T
  field: K
  onChange: (value: T[K]) => void
}

function Field<T, K extends keyof T>({ entity, field, onChange }: FieldProps<T, K>) {
  return (
    <input
      value={String(entity[field])}
      onChange={(e) => onChange(e.target.value as T[K])}
    />
  )
}

// Nutzung:
const user = { id: '42', name: 'Max', age: 30 }

<Field entity={user} field="age" onChange={(v) => console.log(v.toFixed(2))} /> 
// v: number
```

* Durch `<T, K extends keyof T>` ist `onChange`-Wert **an den Feldtyp gebunden**.

---

**Zusammenfassung**

* `keyof` erzeugt **Union aus Property-Namen** eines Typs.
* Props wie `field: keyof T` erlauben nur gültige Schlüssel → typsichere dynamische Properties.
* Mit Generics `<T, K extends keyof T>` kann man den Werttyp an den Schlüssel koppeln.
* Hilfreich für **generische Komponenten**: Tabellen, Formulare, dynamische Styles.

**Quellen**

* TypeScript: [keyof Type Operator](https://www.typescriptlang.org/docs/handbook/2/keyof-types.html)
* TypeScript: [Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
* React TypeScript Cheatsheet: [Typing Dynamic Props](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/)

---

  **[⬆ Наверх](#top)**

107. ### <a name="107"></a> Wie erstellt man typsichere Styles (z. B. mit styled-components)?

**Typsichere Styles mit styled-components (TypeScript)**

Mit [styled-components](https://styled-components.com/) bekommt man dank `@types/styled-components` bereits Typsicherheit für CSS-Properties. Für Props, Themes und dynamische Styles kann man Typen explizit erweitern.

---

### 1) Basis: Styled Component mit Props

```tsx
// Button.tsx
import styled from 'styled-components'

// Props definieren
type ButtonProps = {
  primary?: boolean
}

// Props im Template verwenden
export const Button = styled.button<ButtonProps>`
  background: ${({ primary }) => (primary ? 'palevioletred' : 'white')};
  color: ${({ primary }) => (primary ? 'white' : 'palevioletred')};
  border: 2px solid palevioletred;
  padding: 0.5rem 1rem;
`
```

* `primary` ist optional und streng typisiert.
* Autovervollständigung in `props` funktioniert.

---

### 2) Typsichere Themes

```tsx
// theme.ts
import 'styled-components'

export const theme = {
  colors: {
    primary: 'palevioletred',
    secondary: 'white',
  },
  spacing: (factor: number) => `${0.25 * factor}rem`,
}

// styled-components Theme überschreiben
declare module 'styled-components' {
  export interface DefaultTheme {
    colors: {
      primary: string
      secondary: string
    }
    spacing: (factor: number) => string
  }
}
```

```tsx
// App.tsx
import { ThemeProvider } from 'styled-components'
import { theme } from './theme.js'
import { Button } from './Button.js'

export default function App() {
  return (
    <ThemeProvider theme={theme}>
      <Button primary>Click</Button>
    </ThemeProvider>
  )
}
```

* Zugriff auf `props.theme.colors.primary` ist jetzt **typsicher**.

---

### 3) Generische Styles für dynamische Properties

```tsx
type BoxProps = {
  width?: string
  height?: string
}

export const Box = styled.div<BoxProps>`
  width: ${({ width }) => width ?? '100%'};
  height: ${({ height }) => height ?? 'auto'};
`
```

* Props sind mit `BoxProps` typisiert → Fehler bei falschem Wert.

---

### 4) Reusable Variants über Union Types

```tsx
type Variant = 'primary' | 'secondary'

interface BadgeProps {
  variant: Variant
}

export const Badge = styled.span<BadgeProps>`
  background: ${({ variant, theme }) =>
    variant === 'primary' ? theme.colors.primary : theme.colors.secondary};
  color: ${({ variant }) => (variant === 'primary' ? 'white' : 'black')};
`
```

* `variant` ist nur `'primary' | 'secondary'` erlaubt.

---

### 5) Utility: Polymorphe Komponenten (`as` Prop)

```tsx
export const Text = styled.p<{ size?: 'sm' | 'lg' }>`
  font-size: ${({ size }) => (size === 'lg' ? '1.5rem' : '0.875rem')};
`

// Nutzung
<Text size="lg" as="span">Großer Text als Span</Text>
```

* `as` ist eingebaut → Komponente bleibt typisiert.

---

### 6) Kombination mit `CSSProperties`

Für frei konfigurierbare Inline-Styles:

```tsx
import { CSSProperties } from 'react'

type FlexProps = {
  style?: Pick<CSSProperties, 'justifyContent' | 'alignItems'>
}

export const Flex = styled.div<FlexProps>`
  display: flex;
  justify-content: ${({ style }) => style?.justifyContent ?? 'flex-start'};
  align-items: ${({ style }) => style?.alignItems ?? 'stretch'};
`
```

* Nur erlaubte Keys aus `CSSProperties` sind zugänglich.

---

### 7) Alternative: Utility Types für Styles

```tsx
// Nur Farb-Props zulassen
type ColorProps = {
  color?: CSSProperties['color']
  backgroundColor?: CSSProperties['backgroundColor']
}

export const ColoredBox = styled.div<ColorProps>`
  color: ${({ color }) => color};
  background-color: ${({ backgroundColor }) => backgroundColor};
`
```

* Autovervollständigung für gültige CSS-Farben.

---

**Zusammenfassung**

* `styled.button<Props>`: Props generisch typisieren.
* Mit `declare module 'styled-components'` das Theme **typsicher** erweitern.
* `keyof CSSProperties` oder Utility Types für gezielte CSS-Props.
* Union Types (`'primary' | 'secondary'`) für Varianten.
* Ergebnis: **Fehler bei ungültigen Props/Styles** → sichere, wartbare Komponenten.

**Quellen**

* TypeScript Utility Types: [https://www.typescriptlang.org/docs/handbook/utility-types.html](https://www.typescriptlang.org/docs/handbook/utility-types.html)
* styled-components: [TypeScript Support](https://styled-components.com/docs/api#typescript)
* React TypeScript Cheatsheets – [Styling](https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase#styling)

---

  **[⬆ Наверх](#top)**

108. ### <a name="108"></a> Wie typisiert man Props für Bibliothekskomponenten (z. B. Material UI)?

**Props für Bibliothekskomponenten (z. B. Material UI) typsicher machen**

---

### 1) Direkt den exportierten Prop-Typ verwenden

```js
// Wrapper um MUI-Button mit zusätzlichen Props
import React from 'react'
import Button from '@mui/material/Button'
import type { ButtonProps } from '@mui/material/Button'

type Extra = { loading?: boolean }

export function PrimaryButton(props: ButtonProps & Extra) {
  const { loading, children, disabled, ...rest } = props
  return (
    <Button variant="contained" color="primary" disabled={disabled || loading} {...rest}>
      {loading ? '…' : children}
    </Button>
  )
}
```

*Vorteil: exakt der gleiche Prop-Typ wie die MUI-Komponente.*

---

### 2) Falls kein Prop-Typ exportiert ist: `ComponentProps<typeof X>`

```js
import React from 'react'
import TextField from '@mui/material/TextField'
import type { ComponentProps } from 'react'

type TFProps = ComponentProps<typeof TextField>

export function LabeledTextField(props: TFProps) {
  return <TextField variant="outlined" fullWidth {...props} />
}
```

*Generisch aus dem Value von `typeof Komponente` abgeleitet.*

---

### 3) Polymorphe Komponenten (`component`/`as`) sauber typisieren

```js
// Link-Button, der als <a> rendert
import React from 'react'
import Button from '@mui/material/Button'
import type { ButtonProps } from '@mui/material/Button'

type LinkButtonProps = ButtonProps<'a'> & { to: string }

export function LinkButton({ to, ...rest }: LinkButtonProps) {
  return <Button component="a" href={to} {...rest} />
}
```

*Viele MUI-Komponenten sind polymorph; `ButtonProps<'a'>` erzwingt die richtigen HTML-Attribute.*

---

### 4) `sx` und Theme typisieren

```js
import React from 'react'
import Box from '@mui/material/Box'
import type { SxProps, Theme } from '@mui/material/styles'

type CardProps = {
  sx?: SxProps<Theme> // volle Autocomplete auf Theme-Tokens
  children?: React.ReactNode
}

export function Card({ sx, children }: CardProps) {
  return <Box sx={{ p: 2, borderRadius: 2, boxShadow: 1, ...sx }}>{children}</Box>
}
```

---

### 5) Controlled Wrapper: Props präzisieren (Omit/Override)

```js
import React from 'react'
import TextField from '@mui/material/TextField'
import type { TextFieldProps } from '@mui/material/TextField'

type ControlledTextFieldProps =
  Omit<TextFieldProps, 'value' | 'onChange'> & {
    value: string
    onChange: (value: string) => void
  }

export function ControlledTextField({ onChange, ...rest }: ControlledTextFieldProps) {
  return (
    <TextField
      {...rest}
      onChange={(e) => onChange(e.target.value)}
    />
  )
}
```

*Überschreibt gezielt `value`/`onChange`, um den Werttyp zu fixieren.*

---

### 6) Refs korrekt weiterleiten (`forwardRef`)

```js
import React, { forwardRef } from 'react'
import Button from '@mui/material/Button'
import type { ButtonProps } from '@mui/material/Button'

export const IconButtonLink = forwardRef<HTMLAnchorElement, ButtonProps<'a'>>(
  function IconButtonLink(props, ref) {
    return <Button component="a" ref={ref} {...props} />
  }
)
```

*`forwardRef` mit Element-Ref + polymorphem Prop-Typ.*

---

### 7) System-Props/Box ableiten (für Layout-Helfer)

```js
import React from 'react'
import Box from '@mui/material/Box'
import type { BoxProps } from '@mui/material/Box'

type StackProps = BoxProps & { gap?: number }

export function Stack({ gap = 2, ...rest }: StackProps) {
  return <Box display="flex" gap={gap} {...rest} />
}
```

---

### 8) Fallback: Native HTML-Props zusammenführen

```js
import React from 'react'
import type { ComponentPropsWithoutRef } from 'react'

type AnchorLikeProps = {
  active?: boolean
} & ComponentPropsWithoutRef<'a'>

export function AnchorLike({ active, ...rest }: AnchorLikeProps) {
  return <a data-active={active ? '1' : '0'} {...rest} />
}
```

*Nützlich, wenn eine Bibliothek keine Typen liefert.*

---

**Zusammenfassung**

* Bevorzugt **exportierte Prop-Typen** der Bibliothek nutzen (z. B. `ButtonProps`).
* Alternativ **`ComponentProps<typeof X>`** bzw. HTML-Fallbacks (`ComponentPropsWithoutRef<'button'>`).
* **Polymorphie**: bei MUI mit `ButtonProps<'a'>` & Co. typisieren.
* **`sx` als `SxProps<Theme>`**, Events/Refs exakt typisieren; bei Wrappern gezielt mit `Omit`/Override arbeiten.

**Quellen**

* TypeScript Utility Types: [https://www.typescriptlang.org/docs/handbook/utility-types.html](https://www.typescriptlang.org/docs/handbook/utility-types.html)
* React – `forwardRef`: [https://react.dev/reference/react/forwardRef](https://react.dev/reference/react/forwardRef)
* React TypeScript Cheatsheet – *Props & Patterns*: [https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/)
* MUI – TypeScript Guide (Props, polymorphe Komponenten): [https://mui.com/material-ui/guides/typescript/](https://mui.com/material-ui/guides/typescript/)

  **[⬆ Наверх](#top)**

109. ### <a name="109"></a> Wie typisiert man React.memo?

**`React.memo` typisieren (TypeScript)**

---

### 1) Standardfall – Typen werden aus der Komponente abgeleitet

```js
// UserCard.tsx
import React, { memo } from 'react'

type UserCardProps = { name: string; age?: number }

function UserCard({ name, age }: UserCardProps) {
  return <div>{name} {age ?? ''}</div>
}

export const MemoUserCard = memo(UserCard) // Props korrekt abgeleitet
MemoUserCard.displayName = 'UserCard'
```

*Kein `React.FC` nötig; Props werden automatisch übernommen.*

---

### 2) Mit `propsAreEqual` (Custom Vergleich) – streng typisiert

```js
// Strict compare function ist an Props gebunden
const areEqual = (prev: Readonly<UserCardProps>, next: Readonly<UserCardProps>) =>
  prev.name === next.name && prev.age === next.age

export const MemoUserCardEq = memo(UserCard, areEqual)
```

*`Readonly` spiegelt die tatsächliche Immutability von Props wider.*

---

### 3) `forwardRef` + `memo` kombiniert

```js
import React, { forwardRef, memo } from 'react'

type InputProps = { value: string; onChange: (v: string) => void }

const InputBase = forwardRef<HTMLInputElement, InputProps>(function InputBase(
  { value, onChange }, ref
) {
  return <input ref={ref} value={value} onChange={(e) => onChange(e.target.value)} />
})

export const Input = memo(InputBase) // Props & Ref-Typ bleiben erhalten
```

---

### 4) Generische Komponenten: Typen nach `memo` erhalten

`memo` „vergisst“ Generics. Lösung: **Assertion**/Wrapper-Funktion.

```js
// List.tsx
import React, { memo } from 'react'

export type ListProps<T> = {
  items: T[]
  render: (item: T, index: number) => React.ReactNode
}

function ListInner<T>({ items, render }: ListProps<T>) {
  return <ul>{items.map((it, i) => <li key={i}>{render(it, i)}</li>)}</ul>
}

// Variante A: Assertion auf generische Signatur
export const List = memo(ListInner) as <T>(p: ListProps<T>) => JSX.Element

// Nutzung:
<List items={[{ id: 1 }]} render={(x) => x.id} />
```

Oder als **Hilfsfunktion**, die Generics bewahrt:

```js
function memoGeneric<TProps>(c: (p: TProps) => JSX.Element) {
  return memo(c) as (p: TProps) => JSX.Element
}
export const List2 = memoGeneric(ListInner)<any> // ggf. mit explizitem Typparameter an Aufrufstellen
```

---

### 5) Polymorphe Komponenten (optional, mit `as`/`component`)

```js
import React, { memo } from 'react'
import type { ComponentPropsWithoutRef, ElementType } from 'react'

type PolymorphProps<T extends ElementType> = {
  as?: T
  children?: React.ReactNode
} & Omit<ComponentPropsWithoutRef<T>, 'as' | 'children'>

function Box<T extends ElementType = 'div'>({ as, children, ...rest }: PolymorphProps<T>) {
  const Comp = (as ?? 'div') as ElementType
  return <Comp {...rest}>{children}</Comp>
}

export const MemoBox = memo(Box) as <T extends ElementType = 'div'>(p: PolymorphProps<T>) => JSX.Element
```

*Bewahrt die Attribut-Typen des gewählten Tags.*

---

### 6) Häufige Hinweise

* **Kein `React.FC` nötig**: explizite Props sind klarer (keine impliziten `children`).
* **Comparator sparsam** einsetzen: nur wenn wirklich teure Re-Renders; sonst Overhead.
* **Stabile Props** (Memoization bei Callbacks/Objekten) sind Voraussetzung, damit `memo` wirkt.

---

**Zusammenfassung**

* Standard: `memo(Component)` – Props werden automatisch abgeleitet.
* Custom-Vergleich: `(prev: Readonly<Props>, next: Readonly<Props>) => boolean`.
* `forwardRef` + `memo`: `forwardRef<Element, Props>(...)` und dann `memo(...)`.
* Generische Komponenten: nach `memo` per **Assertion** (`as <T>(p: Props<T>) => JSX.Element`) oder Helper typisieren.
* Polymorphe Komponenten: generische Props mit `ElementType` + Assertion erhalten.

**Quellen**

* React – `memo`: [https://react.dev/reference/react/memo](https://react.dev/reference/react/memo)
* React – `forwardRef`: [https://react.dev/reference/react/forwardRef](https://react.dev/reference/react/forwardRef)
* TypeScript – Generics & Utility Types: [https://www.typescriptlang.org/docs/handbook/2/generics.html](https://www.typescriptlang.org/docs/handbook/2/generics.html) , [https://www.typescriptlang.org/docs/handbook/utility-types.html](https://www.typescriptlang.org/docs/handbook/utility-types.html)
* React TypeScript Cheatsheet – *Patterns (Memo, forwardRef, Generics)*: [https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase](https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase)

  **[⬆ Наверх](#top)**

110. ### <a name="110"></a> Wie typisiert man React.lazy und Suspense?

**`React.lazy` und `Suspense` typisieren (TypeScript)**

---

### 1) Default-Export lazy laden – Typen werden abgeleitet

```js
// Profile.tsx
import React from 'react'
export default function Profile() { return <div>Profile</div> }
```

```js
// App.tsx
import React, { lazy, Suspense } from 'react'

const Profile = lazy(() => import('./Profile.js')) // Props werden automatisch abgeleitet

export default function App() {
  return (
    <Suspense fallback={<span>Laden…</span>}>
      <Profile />
    </Suspense>
  )
}
```

*`lazy` erwartet ein Promise, dessen Auflösung `{ default: Component }` enthält.*

---

### 2) Named Export lazy laden (mit Mapping auf `default`)

```js
// widgets.tsx
import React from 'react'
export type ChartProps = { title: string }
export function Chart({ title }: ChartProps) { return <h3>{title}</h3> }
```

```js
// LazyChart.tsx
import React, { lazy, Suspense } from 'react'
import type { ChartProps } from './widgets.js'

const Chart = lazy(async () =>
  import('./widgets.js').then(m => ({ default: m.Chart }))
)
// Typ: LazyExoticComponent<ComponentType<ChartProps>>

export function Panel() {
  return (
    <Suspense fallback={null}>
      <Chart title="Sales" />
    </Suspense>
  )
}
```

---

### 3) Props explizit machen (optional, z. B. bei komplexen Generics)

```js
import React, { lazy, Suspense, type ComponentType, type LazyExoticComponent } from 'react'

type DetailsProps = { id: string }

const Details: LazyExoticComponent<ComponentType<DetailsProps>> = lazy(
  () => import('./Details.js')
)

export function View() {
  return (
    <Suspense fallback={<i>…</i>}>
      <Details id="42" />
    </Suspense>
  )
}
```

---

### 4) `forwardRef` + `lazy` kombinieren (Ref-Typ bleibt erhalten)

```js
// Input.tsx
import React, { forwardRef } from 'react'
export type InputProps = { value: string; onChange: (v: string) => void }
const Input = forwardRef<HTMLInputElement, InputProps>(function Input({ value, onChange }, ref) {
  return <input ref={ref} value={value} onChange={e => onChange(e.target.value)} />
})
export default Input
```

```js
// LazyInput.tsx
import React, { lazy, Suspense, useRef } from 'react'
import type { InputProps } from './Input.js'

const LazyInput = lazy(() => import('./Input.js')) // Ref- und Prop-Typen bleiben erhalten

export function Form() {
  const ref = useRef<HTMLInputElement>(null)
  return (
    <Suspense fallback={null}>
      <LazyInput ref={ref} value="" onChange={() => {}} />
    </Suspense>
  )
}
```

---

### 5) Generische Komponenten und `lazy`

`lazy` „vergisst“ Typparameter. Lösung: Assertion/Wrapper mit generischer Signatur.

```js
// List.tsx
import React from 'react'
export type ListProps<T> = { items: T[]; render: (item: T) => React.ReactNode }
export default function List<T>({ items, render }: ListProps<T>) {
  return <ul>{items.map((it, i) => <li key={i}>{render(it)}</li>)}</ul>
}
```

```js
// LazyList.tsx
import React, { lazy, Suspense } from 'react'
import type { ListProps } from './List.js'

const LazyList = lazy(() => import('./List.js')) as <T>(p: ListProps<T>) => JSX.Element

export function Demo() {
  return (
    <Suspense fallback="…">
      <LazyList items={[{ id: 1 }]} render={x => x.id} />
    </Suspense>
  )
}
```

---

### 6) Typen von `Suspense` (Fallback & Boundary)

```js
import React, { Suspense } from 'react'

export function Boundary({ children }: { children: React.ReactNode }) {
  return <Suspense fallback={<div>Loading…</div>}>{children}</Suspense>
}
```

* `fallback: React.ReactNode`
* `children: React.ReactNode`

---

### 7) Häufige Hinweise

* Immer innerhalb von `<Suspense>` rendern (sonst Laufzeitfehler).
* Bei SSR-Frameworks (z. B. Next.js) ggf. deren `dynamic()`/`next/dynamic` verwenden.
* Für named Exports stets via `then(m => ({ default: m.Named }))` mappen.
* Bei generischen Komponenten Typsignatur per Assertion erhalten.

---

**Zusammenfassung**

* `lazy(() => import(...))` leitet Props automatisch ab; für named Exports via `then` auf `default` mappen.
* `Suspense` verlangt `fallback: ReactNode`; `children` sind typisiert als `ReactNode`.
* Generische/komplizierte Komponenten: Props via Assertion sichern; `forwardRef` bleibt mit `lazy` typstark.

**Quellen**

* React – `lazy` & `Suspense`: [https://react.dev/reference/react/lazy](https://react.dev/reference/react/lazy) , [https://react.dev/reference/react/Suspense](https://react.dev/reference/react/Suspense)
* TypeScript – Module & Generics: [https://www.typescriptlang.org/docs/handbook/2/modules.html](https://www.typescriptlang.org/docs/handbook/2/modules.html) , [https://www.typescriptlang.org/docs/handbook/2/generics.html](https://www.typescriptlang.org/docs/handbook/2/generics.html)
* React TypeScript Cheatsheet – Code Splitting/Lazy: [https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase#code-splitting](https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase#code-splitting)

  **[⬆ Наверх](#top)**

111. ### <a name="111"></a> Wie verwendet man Conditional Types (T extends U ? X : Y)?

**Conditional Types (`T extends U ? X : Y`) in TypeScript**

---

### 1) Grundidee

Ein **Conditional Type** ist ein ternärer Operator auf Typ-Ebene:

```ts
type IsString<T> = T extends string ? 'yes' : 'no'

type A = IsString<string>   // 'yes'
type B = IsString<number>   // 'no'
```

* Wenn `T` in `U` assignable ist → `X`.
* Sonst → `Y`.

📚 [TypeScript Docs – Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)

---

### 2) Praktische Nutzung: API-Modelle

```ts
type ApiResponse<T> = T extends Error ? { ok: false; error: T } : { ok: true; data: T }

type R1 = ApiResponse<string> // { ok: true; data: string }
type R2 = ApiResponse<Error>  // { ok: false; error: Error }
```

*So lassen sich Erfolg/Fehler-Strukturen automatisch ableiten.*

---

### 3) Verfeinerung von Props in React

```tsx
type ButtonProps<T extends 'a' | 'button'> =
  T extends 'a'
    ? { as: 'a'; href: string }
    : { as: 'button'; onClick: () => void }

// Nutzung:
const link: ButtonProps<'a'> = { as: 'a', href: '/home' }        // ✅
const btn: ButtonProps<'button'> = { as: 'button', onClick() {} } // ✅
```

*Props variieren abhängig von einem Discriminator.*

---

### 4) Extract / Exclude als Conditional Types

`Extract<T, U>` und `Exclude<T, U>` sind in TS **vordefinierte Conditional Types**:

```ts
type A = string | number | boolean

type OnlyString = Extract<A, string>  // string
type NoString = Exclude<A, string>    // number | boolean
```

---

### 5) Inference (`infer`) innerhalb von Conditional Types

```ts
type UnwrapPromise<T> = T extends Promise<infer U> ? U : T

type A = UnwrapPromise<Promise<number>> // number
type B = UnwrapPromise<string>          // string
```

* `infer U` erstellt einen neuen Typ-Platzhalter, wenn das Pattern matched.

---

### 6) Mehrstufige Verzweigungen

```ts
type TypeName<T> =
  T extends string ? 'string' :
  T extends number ? 'number' :
  T extends boolean ? 'boolean' :
  'object'

type A = TypeName<string>   // 'string'
type B = TypeName<boolean>  // 'boolean'
type C = TypeName<Date>     // 'object'
```

---

### 7) Anwendung für API-Generics (Optional/Required)

```ts
type Nullable<T, Fallback = null> = T extends undefined ? Fallback : T

type A = Nullable<string | undefined>  // string | null
type B = Nullable<number>              // number
```

---

### 8) Verteilung über Union Types

Conditional Types sind **distributiv**, wenn das Subject ein Union ist:

```ts
type ToArray<T> = T extends any ? T[] : never

type R = ToArray<string | number> // string[] | number[]
```

* Jeder Union-Member wird einzeln geprüft.
* Verhindern via `[T] extends [U]`.

---

**Zusammenfassung**

* Syntax: `T extends U ? X : Y`.
* Grundlage für viele eingebaute Utility Types (`Extract`, `Exclude`, `ReturnType`, `Awaited`).
* Einsatz: API-Result-Wrapper, Props abhängig machen, Typen transformieren (`Promise<T>` → `T`).
* Mit `infer` kann man Typen aus Strukturen extrahieren.
* Distributiv über Union Types – wichtiges Verhalten.

**Quellen**

* [TypeScript Docs – Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* [TypeScript Docs – Utility Types](https://www.typescriptlang.org/docs/handbook/utility-types.html)
* React TypeScript Cheatsheet – Advanced Patterns: [https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase](https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase)

---

  **[⬆ Наверх](#top)**

112. ### <a name="112"></a> Was sind Mapped Types?

**Mapped Types in TypeScript**

---

### 1) Grundidee

Ein **Mapped Type** erlaubt es, über die Schlüssel (`keyof`) eines Typs zu iterieren und daraus neue Typen zu erzeugen.

```ts
type User = { id: string; name: string; age: number }

type ReadonlyUser = {
  readonly [K in keyof User]: User[K]
}
```

* `[K in keyof User]` = Schleife über alle Keys (`"id" | "name" | "age"`).
* `User[K]` = jeweiliger Wert-Typ.

📚 [TS Docs – Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)

---

### 2) Built-in Utility Types sind Mapped Types

```ts
type User = { id: string; name: string; age?: number }

type PartialUser = Partial<User>     // alle Props optional
type RequiredUser = Required<User>   // alle Props required
type ReadonlyUser = Readonly<User>   // alle Props readonly
type PickUser = Pick<User, 'id'>     // nur id
type RecordMap = Record<string, number> // {[key: string]: number}
```

---

### 3) Custom Transformation – optional/readonly

```ts
type Optional<T> = {
  [K in keyof T]?: T[K]
}

type ReadonlyProps<T> = {
  readonly [K in keyof T]: T[K]
}
```

---

### 4) Mit Modifikatoren (`+` | `-`)

```ts
type User = { id: string; name?: string }

// -? entfernt Optionalität
type StrictUser = {
  [K in keyof User]-?: User[K]
}
// { id: string; name: string }
```

---

### 5) Keys remappen (`as`)

```ts
type User = { id: string; name: string }

type PrefixKeys<T> = {
  [K in keyof T as `user_${Extract<K, string>}`]: T[K]
}

type Prefixed = PrefixKeys<User>
// { user_id: string; user_name: string }
```

---

### 6) Dynamische Transformationen

```ts
type Nullable<T> = {
  [K in keyof T]: T[K] | null
}

type User = { id: string; age: number }
type NullableUser = Nullable<User>
// { id: string | null; age: number | null }
```

---

### 7) Kombination mit Conditional Types

```ts
type FunctionProps<T> = {
  [K in keyof T as T[K] extends Function ? K : never]: T[K]
}

type Example = {
  id: string
  onClick: () => void
  onChange: (v: string) => void
}

type OnlyFuncs = FunctionProps<Example>
// { onClick: () => void; onChange: (v: string) => void }
```

---

### 8) Praxis in React/Frontend

* **Formulare**: `Partial<T>` für optionale Felder.
* **Redux State**: `Readonly<T>` für Immutability.
* **API Models**: `Omit<T, 'serverOnly'>` für Client-DTOs.
* **CSS-in-JS**: Mapped Types über `keyof CSSProperties`.

---

**Zusammenfassung**

* Mapped Types = Typ-Transformation über alle Keys eines Typs.
* Syntax: `{ [K in keyof T]: … }`.
* Unterstützt Modifikatoren (`+?`, `-?`, `+readonly`, `-readonly`) und Key-Remapping (`as`).
* Grundlage für viele Utility Types (`Partial`, `Required`, `Readonly`, `Pick`, `Record`).
* Nützlich für API-Modelle, State-Management, UI-Props und dynamische Typableitung.

**Quellen**

* [TypeScript Docs – Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
* [TypeScript Docs – Utility Types](https://www.typescriptlang.org/docs/handbook/utility-types.html)
* React TypeScript Cheatsheet – Patterns & Utility Types: [https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase](https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase)

---

  **[⬆ Наверх](#top)**

113. ### <a name="113"></a> Wie funktionieren Template Literal Types?

**Template Literal Types in TypeScript**

---

### 1) Grundidee

Template Literal Types kombinieren **String Literal Types** mit **String Interpolation**.
Ähnlich wie bei JavaScript Template Strings (`${}`), aber auf **Typ-Ebene**.

```ts
type Lang = "de" | "en"
type Key = "title" | "description"

type TranslationKey = `${Lang}_${Key}`
// "de_title" | "de_description" | "en_title" | "en_description"
```

📚 [TS Docs – Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)

---

### 2) Kombination mit `keyof`

```ts
type User = { id: string; name: string; age: number }

type UserGetters = `get${Capitalize<keyof User & string>}`
// "getId" | "getName" | "getAge"
```

---

### 3) Utility mit eingebaute String-Manipulation

TypeScript bietet Hilfstypen:

* `Uppercase<T>`
* `Lowercase<T>`
* `Capitalize<T>`
* `Uncapitalize<T>`

```ts
type Msg = "hello world"
type U = Uppercase<Msg>      // "HELLO WORLD"
type C = Capitalize<Msg>     // "Hello world"
```

---

### 4) Props in React dynamisch ableiten

```ts
type Size = "sm" | "lg"
type Variant = "primary" | "secondary"

type ButtonClass = `btn-${Size}-${Variant}`
// "btn-sm-primary" | "btn-sm-secondary" | "btn-lg-primary" | "btn-lg-secondary"

type ButtonProps = {
  className: ButtonClass
}
```

*Komponente akzeptiert nur gültige Kombinationen.*

---

### 5) API-Endpunkte modellieren

```ts
type Method = "GET" | "POST"
type Resource = "users" | "products"

type Endpoint = `${Method}/${Resource}`
// "GET/users" | "GET/products" | "POST/users" | "POST/products"
```

---

### 6) Mit Conditional Types kombinieren

```ts
type EventName<T extends string> = T extends `on${infer U}` ? U : never

type A = EventName<"onClick">  // "Click"
type B = EventName<"onChange"> // "Change"
type C = EventName<"hover">    // never
```

*`infer` extrahiert Teilstrings aus dem Typ.*

---

### 7) Remapping von Keys in Mapped Types

```ts
type User = { id: string; name: string }

type Prefixed<T> = {
  [K in keyof T as `user_${string & K}`]: T[K]
}

type UserDb = Prefixed<User>
// { user_id: string; user_name: string }
```

---

### 8) Typische Praxis-Fälle

* **CSS-Klassen** (`btn-lg-primary`).
* **Internationalisierung** (`de_title`).
* **Events/Handler** (`onClick`, `onChange`).
* **API-Routen** (`GET/users`).
* **Key-Remapping** in Mapped Types.

---

**Zusammenfassung**

* Template Literal Types = String-Literal-Typen mit Interpolation.
* Kombinierbar mit Union, `keyof`, Utility-Types (`Uppercase`, `Capitalize`, …).
* Sehr nützlich für **strikte Schlüssel**: Routen, Events, CSS-Klassen, Übersetzungen.
* Mit `infer` → Teilstrings extrahieren, für flexible Typtransformationen.

**Quellen**

* [TypeScript Docs – Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)
* [TypeScript Utility Types (String Manipulation)](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html#string-manipulation)
* React TypeScript Cheatsheet – Advanced Patterns: [https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase](https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase)

---

  **[⬆ Наверх](#top)**

114. ### <a name="114"></a> Was ist infer?

**`infer` in TypeScript**

---

### 1) Grundidee

* `infer` („infer = ableiten“) wird **nur innerhalb von Conditional Types** verwendet.
* Damit können **Typvariablen innerhalb eines Typs** aus einem Pattern extrahiert werden.

```ts
type UnwrapPromise<T> = T extends Promise<infer U> ? U : T

type A = UnwrapPromise<Promise<number>> // number
type B = UnwrapPromise<string>          // string
```

📚 [TypeScript Docs – Conditional Types & infer](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#infer)

---

### 2) Typ aus Funktion extrahieren

```ts
type Return<T> = T extends (...args: any[]) => infer R ? R : never

type A = Return<() => string>  // string
type B = Return<(x: number) => boolean> // boolean
```

---

### 3) Parameter-Typen extrahieren

```ts
type FirstArg<T> = T extends (arg: infer P, ...args: any[]) => any ? P : never

type A = FirstArg<(id: number, name: string) => void> // number
type B = FirstArg<() => void>                        // never
```

---

### 4) Mehrere `infer` Variablen gleichzeitig

```ts
type Args<T> = T extends (...args: infer A) => any ? A : never

type A = Args<(x: string, y: number) => void>
// [x: string, y: number]
```

---

### 5) Mit Array/Promise-Strukturen

```ts
type ElementType<T> = T extends (infer U)[] ? U : T

type A = ElementType<string[]>   // string
type B = ElementType<number>     // number
```

```ts
type Awaited<T> = T extends Promise<infer U> ? Awaited<U> : T

type A = Awaited<Promise<Promise<string>>> // string
```

(*So ist der eingebaute Utility-Typ `Awaited<T>` definiert.*)

---

### 6) Template Literal Types + `infer`

```ts
type EventName<T> = T extends `on${infer U}` ? U : never

type A = EventName<'onClick'>   // "Click"
type B = EventName<'hover'>     // never
```

---

### 7) Praxisfälle

* Rückgabewerte und Parameter von Funktionen extrahieren.
* Promise-/Array-/Observable-Inhalte herausziehen.
* Eventnamen oder Stringteile analysieren.
* Utility-Types bauen (`ReturnType`, `Parameters`, `Awaited` nutzen `infer`).

---

**Zusammenfassung**

* `infer` = Platzhalter für einen Typ, den TS aus einem Muster **ableitet**.
* Nur in **Conditional Types** einsetzbar.
* Ermöglicht flexible Utility-Types (z. B. `ReturnType`, `Awaited`).
* Typisches Muster: `T extends Something<infer U> ? … : …`.

**Quellen**

* [TypeScript Docs – infer](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#infer)
* [Utility Types in TS](https://www.typescriptlang.org/docs/handbook/utility-types.html)
* React TS Cheatsheet – Advanced Patterns: [https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase](https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase)

---

  **[⬆ Наверх](#top)**

115. ### <a name="115"></a> Wie schreibt man eigene Utility Types?

**Eigene Utility Types in TypeScript**

---

### 1) Grundlagen: Bausteine

* **Conditional Types**: `T extends U ? X : Y`
* **Mapped Types**: `{ [K in keyof T]: … }` (+ Modifikatoren `-?`, `+readonly`, `-readonly`)
* **Template Literal Types**: Remapping von Keys via ``as \`prefix_${K}\` ``
* **`infer`**: Typen aus Strukturen extrahieren

📚 Docs:
[Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html) · [Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html) · [Utility Types](https://www.typescriptlang.org/docs/handbook/utility-types.html) · [Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)

---

### 2) Häufige selbstgeschriebene Utilities

```js
// 2.1 DeepPartial – rekursiv optionale Felder (für PATCH-DTOs)
export type DeepPartial<T> = {
  [K in keyof T]?: T[K] extends object ? DeepPartial<T[K]> : T[K]
}

// 2.2 DeepReadonly – rekursiv readonly (z. B. für State-Snapshots)
export type DeepReadonly<T> = {
  readonly [K in keyof T]: T[K] extends object ? DeepReadonly<T[K]> : T[K]
}

// 2.3 Mutable – entfernt readonly (auch rekursiv möglich)
export type Mutable<T> = { -readonly [K in keyof T]: T[K] }

// 2.4 ValueOf – Wertetypen einer Map/Record
export type ValueOf<T> = T[keyof T]

// 2.5 Exact – verhindert „excess properties“
export type Exact<T, U extends T> = T & { [K in Exclude<keyof U, keyof T>]: never }

// 2.6 Merge – „flaches“ Mergen von Typen (B gewinnt)
export type Merge<A, B> = Omit<A, keyof B> & B

// 2.7 Overwrite – gezielt Felder überschreiben
export type Overwrite<T, R> = Merge<T, Pick<R, keyof R>>

// 2.8 UnionToIntersection – nützlich bei zusammengesetzten Props
export type UnionToIntersection<U> =
  (U extends any ? (x: U) => void : never) extends (x: infer I) => void ? I : never

// 2.9 RequireAtLeastOne – mindestens ein Feld Pflicht
export type RequireAtLeastOne<T, K extends keyof T = keyof T> =
  Omit<T, K> & { [P in K]-?: Required<Pick<T, P>> & Partial<Omit<T, K>> }[K]

// 2.10 XOR – genau eine von zwei Gruppen
export type XOR<A, B> = (A | B) extends object
  ? (A & { [K in keyof B]?: never }) | (B & { [K in keyof A]?: never })
  : A | B

// 2.11 NonEmptyArray – Arrays mit min. 1 Element
export type NonEmptyArray<T> = [T, ...T[]]

// 2.12 Brand – „gebrandete“ Primitive (IDs typisieren)
export type Brand<T, B extends string> = T & { __brand: B }

// 2.13 KeysMatching – alle Keys, deren Werte-Typ auf U passt
export type KeysMatching<T, U> = { [K in keyof T]-?: T[K] extends U ? K : never }[keyof T]

// 2.14 PropType – Typ eines Props einer React-Komponente
export type PropType<C, K extends keyof C> =
  C extends (p: infer P) => any ? P[K & keyof P] : never

// 2.15 Prettify – Intersection „glätten“ (bessere IntelliSense)
export type Prettify<T> = { [K in keyof T]: T[K] } & {}
```

---

### 3) Beispiele in Praxis (API/React)

```js
// 3.1 API: DeepPartial für PATCH
type User = { id: string; name: string; profile: { bio: string; avatarUrl?: string } }
type UpdateUserDto = DeepPartial<Omit<User, 'id'>> // id nicht erlauben, Rest optional (rekursiv)

// 3.2 Form-Layer: mindestens 'email' ODER 'username'
type LoginByEmail = { email: string; password: string }
type LoginByUser  = { username: string; password: string }
type LoginInput = XOR<LoginByEmail, LoginByUser>

// 3.3 Events-API: RequireAtLeastOne für Filter
type Filter = { userId?: string; since?: string; until?: string }
type StrictFilter = RequireAtLeastOne<Filter> // mindestens eins muss gesetzt sein

// 3.4 IDs mit Brand
type UserId = Brand<string, 'UserId'>
const uid = '42' as UserId // verhindert versehentlichen Tausch mit z. B. ProductId

// 3.5 React: „genau eine“ Variante erlauben (XOR)
type ButtonBase = { children?: React.ReactNode }
type ButtonAsLink = { as: 'a'; href: string }
type ButtonAsButton = { as?: 'button'; onClick: () => void }
type ButtonProps = ButtonBase & XOR<ButtonAsLink, ButtonAsButton>

// 3.6 React: Props überarbeiten (Controlled Wrapper)
import type { ComponentProps } from 'react'
type InputProps = ComponentProps<'input'>
type ControlledInputProps = Overwrite<InputProps, {
  value: string
  onChange: (v: string) => void
}>

// 3.7 Selective Keys: nur Callback-Props extrahieren
type OnlyHandlers<T> = Pick<T, KeysMatching<T, (...a: any[]) => any>>
type Handlers = OnlyHandlers<{ onClick: () => void; id: string; onChange(v: string): void }>
// => { onClick: () => void; onChange(v: string): void }
```

---

### 4) Key-Remapping mit Template Literals

```js
// Präfixe für API-Felder hinzufügen
type Api<T> = {
  [K in keyof T as `api_${K & string}`]: T[K]
}
type ApiUser = Api<{ id: string; name: string }>
// { api_id: string; api_name: string }
```

---

### 5) Tipps

* Kleine Utilities in **/types** bündeln, mit JSDoc dokumentieren.
* Erst prüfen, ob ein **Built-in Utility** genügt (`Partial`, `Pick`, `Record`, `Required`, `Readonly`, `NonNullable`, `ReturnType`, `Parameters`, `Awaited` …).
* Komplexe Intersections via `Prettify<>` „glätten“ für bessere DX.
* Bei Runtime-Validierung (Zod/Yup) die Typen via `z.infer` synchron halten.

---

**Zusammenfassung**

* Eigene Utility Types entstehen durch **Conditional + Mapped + Template Literal Types** und `infer`.
* Typische Patterns: `DeepPartial`, `RequireAtLeastOne`, `XOR`, `Merge/Overwrite`, `Brand`.
* Nützlich für **API-DTOs**, **Form-Validierung**, **React-Props** und **State-Modelle**.
* Erst Built-ins nutzen, dann gezielt spezialisieren – sauber versionieren und testen.

**Quellen**

* TypeScript: [Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html), [Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html), [Utility Types](https://www.typescriptlang.org/docs/handbook/utility-types.html), [Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)
* React TypeScript Cheatsheets – Advanced Patterns: [https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase](https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase)

  **[⬆ Наверх](#top)**

116. ### <a name="116"></a> Wie kombiniert man mehrere Generics?

**Mehrere Generics kombinieren (TypeScript)**

---

### 1) Funktionen mit mehreren Typparametern

```js
// Relation zwischen T und U, plus Rückgabe R
export function mapPair<T, U, R>(a, b, fn) {
  return fn(a, b) /** @type {R} */
}

// Nutzung:
// const out = mapPair<number, string, boolean>(1, 'x', (n, s) => n > 0 && !!s)
```

* Mehrere Parameter `<T, U, R>`; Reihenfolge ist beliebig, aber **konsistent** halten.

---

### 2) Abhängige Generics (Constraints)

```js
// K ist ein Key von T; Value-Typ über T[K]
export function getProp<T, K extends keyof T>(obj, key) {
  return obj[key] /** @type {T[K]} */
}

// const v = getProp({ id: 1, name: 'Max' }, 'name') // v: string
```

* Klassischer Pattern: `<T, K extends keyof T>`.

---

### 3) Defaults für Generics

```js
// V defaultet auf string
export type Dict<V = string, K extends string = string> = Record<K, V>

// type D1 = Dict            // Record<string, string>
// type D2 = Dict<number>    // Record<string, number>
```

* **Default-Typen** reduzieren Boilerplate bei häufigen Fällen.

---

### 4) Kombi aus Constraints + Conditional Types

```js
// Wenn T ein Array ist → Elementtyp, sonst T selbst
export type Elem<T> = T extends (infer U)[] ? U : T

// Nur schreibbare Keys (ohne readonly) extrahieren
export type WritableKeys<T> = {
  [P in keyof T]-?: (<X>() => X extends { [Q in P]: T[P] } ? 1 : 2) extends
                   (<X>() => X extends { -readonly [Q in P]: T[P] } ? 1 : 2) ? P : never
}[keyof T]
```

* Mehrere Typparameter/`infer` lassen sich in einem Utility kombinieren.

---

### 5) Re-usable HOC/Wrapper mit mehreren Generics (React)

```js
// Table.tsx — generische Tabelle mit Datentyp T und Key K
import React from 'react'

export type Column<T, K extends keyof T> = {
  key: K
  title: string
  render?: (value: T[K], row: T) => React.ReactNode
}

export function DataTable<T, K extends keyof T>({ rows, columns }) {
  return (
    <table>
      <thead><tr>{columns.map(c => <th key={String(c.key)}>{c.title}</th>)}</tr></thead>
      <tbody>
        {rows.map((r, i) => (
          <tr key={i}>
            {columns.map(c => <td key={String(c.key)}>{c.render?.(r[c.key], r) ?? String(r[c.key])}</td>)}
          </tr>
        ))}
      </tbody>
    </table>
  )
}
/*
<DataTable
  rows={[{ id: 1, name: 'A' }]}
  columns={[
    { key: 'id', title: 'ID' },
    { key: 'name', title: 'Name', render: (v) => v.toUpperCase() }, // v: string
  ]}
/>
*/
```

* `<T, K extends keyof T>` verbindet **Spaltenschlüssel** eng mit dem **Row-Typ**.

---

### 6) Mehrfach-Generics in Utility-Typen (Merge/Override)

```js
export type Merge<A, B> = Omit<A, keyof B> & B

export type Override<T, R> = Merge<T, Pick<R, keyof R>>

// Beispiel:
type A = { id: string; age: number }
type B = { age: string }
type C = Override<A, B> // { id: string; age: string }
```

---

### 7) Event-Handler präzisieren (Wert an Key binden)

```js
type OnChange<T, K extends keyof T> = (key: K, value: T[K]) => void

export function setValue<T, K extends keyof T>(obj, key, value) {
  obj[key] = value /** @type {T[K]} */
}
```

* Mehrere Generics koppeln **Parameter** logisch (Key ↔ Wertetyp).

---

### 8) Interop mit `ComponentProps`/`ReturnType` (abgeleitete Generics)

```js
import type { ComponentProps } from 'react'

export type WithOn<T extends (...a: any[]) => any, P = ReturnType<T>> = {
  onDone: T
  payload: P
}

type Click = (ok: boolean) => number
type Props = WithOn<Click> // { onDone: (ok: boolean) => number; payload: number }
```

* Generics können andere **Generics/Utility Types** als Bausteine nutzen.

---

**Zusammenfassung**

* Mehrere Generics via `<T, U, R>` kombinieren; mit `extends` **Beziehungen** erzwingen.
* Häufiges Pattern: `<T, K extends keyof T>` für key-gebundene Werte.
* Defaults (`<V = string>`) reduzieren Boilerplate.
* In React helfen Mehrfach-Generics bei **typsicheren Tabellen/HOCs**.
* Conditional/`infer` + Mapped Types lassen mächtige **Utility Types** entstehen.

**Quellen**

* TypeScript: [Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html), [keyof](https://www.typescriptlang.org/docs/handbook/2/keyof-types.html), [Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html), [Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
* React TypeScript Cheatsheet – Patterns mit Generics: [https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase](https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase)

  **[⬆ Наверх](#top)**

117. ### <a name="117"></a> Was sind polymorphe Komponenten in React?

**Polymorphe Komponenten in React (TypeScript)**

---

### 1) Grundidee

Eine **polymorphe Komponente** ist eine Komponente, die mit dem Prop `as` (oder `component`) entscheidet, **welches HTML- oder UI-Element gerendert wird**.
👉 Props und Typen passen sich dynamisch an den gewählten Elementtyp an.

Beispiele in UI-Libraries:

* **Material UI**: `<Button component="a" href="…">`
* **Chakra UI**: `<Box as="section">`

---

### 2) Einfaches Beispiel ohne Typisierung

```tsx
function Text({ as: Comp = 'span', children, ...rest }) {
  return <Comp {...rest}>{children}</Comp>
}

// Nutzung
<Text as="a" href="/home">Link</Text>
<Text as="button" onClick={() => {}}>Click</Text>
```

⚠️ Problem: TypeScript weiß hier nicht, dass bei `as="a"` ein `href`-Prop nötig ist.

---

### 3) Typsicher mit `ComponentPropsWithoutRef` und Generics

```tsx
import React, { ElementType, ComponentPropsWithoutRef } from 'react'

type PolymorphicProps<T extends ElementType> = {
  as?: T
  children?: React.ReactNode
} & ComponentPropsWithoutRef<T>

function Text<T extends ElementType = 'span'>({ as, children, ...rest }: PolymorphicProps<T>) {
  const Component = as || 'span'
  return <Component {...rest}>{children}</Component>
}

// Nutzung
<Text as="a" href="/home">Link</Text>        // ✅ kennt href
<Text as="button" onClick={() => {}}>Click</Text> // ✅ kennt onClick
<Text>Default span</Text>
```

* `T` bestimmt den gerenderten Tag.
* Mit `ComponentPropsWithoutRef<T>` übernimmt TS alle nativen Props.

---

### 4) Polymorphe + eigene Props

```tsx
type BaseProps = { color?: 'red' | 'blue' }

type PolymorphicProps<T extends ElementType> = BaseProps & {
  as?: T
  children?: React.ReactNode
} & Omit<ComponentPropsWithoutRef<T>, keyof BaseProps>

function Box<T extends ElementType = 'div'>({ as, color, children, ...rest }: PolymorphicProps<T>) {
  const Component = as || 'div'
  return <Component style={{ color }} {...rest}>{children}</Component>
}

// Nutzung
<Box as="a" href="/home" color="red">Link</Box>
<Box as="button" onClick={() => {}}>Button</Box>
```

* Konflikte (`color` überschreibt native `color`-Prop) mit `Omit<>` vermeiden.

---

### 5) Mit `forwardRef`

```tsx
import React, { forwardRef } from 'react'

type PolymorphicProps<T extends ElementType> = {
  as?: T
  children?: React.ReactNode
} & ComponentPropsWithoutRef<T>

const Polymorphic = forwardRef(
  <T extends ElementType = 'div'>(
    { as, children, ...rest }: PolymorphicProps<T>,
    ref: React.Ref<Element>
  ) => {
    const Component = as || 'div'
    return <Component ref={ref} {...rest}>{children}</Component>
  }
)
```

* Ref bleibt korrekt typisiert.

---

### 6) Praxis-Einsatz

* **Design-Systeme** (einheitliche Komponenten wie `Box`, `Text`).
* **UI-Libraries** (MUI, Chakra, Radix).
* **Accessibility** (z. B. ein Button, der semantisch ein `<a>` ist).

---

**Zusammenfassung**

* Polymorphe Komponenten ändern den gerenderten Tag/Komponententyp via `as`/`component`.
* Mit `Generics + ComponentPropsWithoutRef<T>` bleiben Props typsicher.
* Konflikte durch `Omit<>` lösen.
* In UI-Libraries Standardpattern für flexible, wiederverwendbare Komponenten.

**Quellen**

* TypeScript Docs – [Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
* React TypeScript Cheatsheet – [Polymorphic Components](https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase#polymorphic-components)
* Material UI – [Polymorphic `component` Prop](https://mui.com/material-ui/guides/typescript/#using-the-component-prop)

---

  **[⬆ Наверх](#top)**

118. ### <a name="118"></a> Wie erstellt man eine generische React-Komponente?

**Generische React-Komponente (TypeScript)**

---

### 1) Einfaches, wiederverwendbares List-Pattern

```js
// List.tsx
import React from 'react'

export type ListProps<T> = {
  items: T[]
  renderItem: (item: T, index: number) => React.ReactNode
  getKey?: (item: T, index: number) => React.Key
}

export default function List<T>({ items, renderItem, getKey }: ListProps<T>) {
  return (
    <ul>
      {items.map((it, i) => (
        <li key={getKey?.(it, i) ?? i}>{renderItem(it, i)}</li>
      ))}
    </ul>
  )
}
```

```js
// Usage.tsx
import React from 'react'
import List from './List.js'

export default function Usage() {
  return (
    <List
      items={[{ id: 1, name: 'Max' }]}
      renderItem={(u) => <span>{u.name}</span>}
      getKey={(u) => u.id}
    />
  )
}
```

*`<T>` wird automatisch inferiert.*

---

### 2) Mit Constraints: `K extends keyof T` (z. B. Tabelle/Picker)

```js
// DataTable.tsx
import React from 'react'

export type Column<T, K extends keyof T> = {
  key: K
  header: string
  cell?: (value: T[K], row: T) => React.ReactNode
}

export function DataTable<T, K extends keyof T>({
  rows,
  columns,
}: {
  rows: T[]
  columns: Column<T, K>[]
}) {
  return (
    <table>
      <thead>
        <tr>{columns.map(c => <th key={String(c.key)}>{c.header}</th>)}</tr>
      </thead>
      <tbody>
        {rows.map((r, i) => (
          <tr key={i}>
            {columns.map(c => (
              <td key={String(c.key)}>{c.cell?.(r[c.key], r) ?? String(r[c.key])}</td>
            ))}
          </tr>
        ))}
      </tbody>
    </table>
  )
}
```

---

### 3) Generische Form-Felder (Werttyp an Key binden)

```js
// FormField.tsx
import React from 'react'

export function FormField<T, K extends keyof T>({
  entity,
  name,
  onChange,
}: {
  entity: T
  name: K
  onChange: (next: T[K]) => void
}) {
  return (
    <input
      value={String(entity[name])}
      onChange={(e) => onChange(e.target.value as unknown as T[K])}
    />
  )
}
```

---

### 4) Generics mit `forwardRef` korrekt bewahren

```js
// Select.tsx
import React, { forwardRef } from 'react'

export type SelectProps<T> = {
  options: T[]
  getLabel: (opt: T) => string
  getValue: (opt: T) => string
  onChange: (opt: T) => void
}

function SelectInner<T>(
  { options, getLabel, getValue, onChange }: SelectProps<T>,
  ref: React.Ref<HTMLSelectElement>
) {
  return (
    <select ref={ref} onChange={(e) => {
      const opt = options.find(o => getValue(o) === e.target.value)!
      onChange(opt)
    }}>
      {options.map(o => (
        <option key={getValue(o)} value={getValue(o)}>
          {getLabel(o)}
        </option>
      ))}
    </select>
  )
}

export const Select = forwardRef(SelectInner) as <T>(
  p: SelectProps<T> & { ref?: React.Ref<HTMLSelectElement> }
) => JSX.Element
```

*Casting nach `forwardRef` nötig, um die generische Signatur zu erhalten.*

---

### 5) Generische Komponente + `memo` (Generics erhalten)

```js
// memoGeneric.ts
import React, { memo } from 'react'

export function memoGeneric<P>(c: (p: P) => JSX.Element) {
  return memo(c) as (p: P) => JSX.Element
}

// Nutzung:
import { memoGeneric } from './memoGeneric.js'
import { DataTable } from './DataTable.js'

export const MemoDataTable = memoGeneric(DataTable)<any> // i. d. R. genügt memoGeneric(DataTable)
```

*`React.memo` „vergisst“ Generics → per Helper/Assertion sichern.*

---

### 6) Default-Typen für generische Props (weniger Boilerplate)

```js
// Dict.ts
export type Dict<V = string, K extends string = string> = Record<K, V>
```

---

### 7) Tipps & Stolpersteine

* JSX erfordert `.tsx`, damit `<>`-Generics korrekt erkannt werden.
* **Keine `React.FC`-Zwang** – explizite Props sind klarer (keine impliziten `children`).
* Für polymorphe Komponenten (`as`) `ComponentPropsWithoutRef<T>` + Generics nutzen.
* Typen an Aufrufstellen möglichst **inferieren lassen**, nur bei Bedarf explizit `<>`.

---

**Zusammenfassung**

* Generische Komponenten definierst du mit `<T>` und optionalen Constraints wie `<T, K extends keyof T>`.
* `forwardRef`/`memo` verlieren oft Generics → per Assertion/Helper bewahren.
* Praxis-Patterns: generische `List`, `DataTable`, formulargebundene `FormField`, `Select` mit Callbacks.
* Ziel: **Typsichere Wiederverwendung** ohne `any`, mit maximaler Inferenz.

**Quellen**

* TypeScript: [Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html), [keyof](https://www.typescriptlang.org/docs/handbook/2/keyof-types.html), [Utility Types](https://www.typescriptlang.org/docs/handbook/utility-types.html)
* React: [`forwardRef`](https://react.dev/reference/react/forwardRef), [`memo`](https://react.dev/reference/react/memo)
* React TypeScript Cheatsheet – *Advanced Patterns (Generics, Polymorphic, HOCs)*: [https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase](https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase)

  **[⬆ Наверх](#top)**

119. ### <a name="119"></a> Wie verbindet man Generics in Props und State?

**Generics in Props und State verbinden (TypeScript + React)**

---

### 1) `Props<T>` ↔ `useState<T>`: gemeinsamer Typparameter

```js
// GenericForm.tsx
import React from 'react'

export type FieldUpdate<T, K extends keyof T> = { name: K; value: T[K] }

export type GenericFormProps<T> = {
  initial: T
  onChange?: (next: T) => void
}

export default function GenericForm<T>({ initial, onChange }: GenericFormProps<T>) {
  const [model, setModel] = React.useState<T>(initial) // State an Props-Generic gebunden

  // generischer Updater: Key↔Wert-Typ bleiben konsistent
  function update<K extends keyof T>({ name, value }: FieldUpdate<T, K>) {
    setModel(prev => {
      const next = { ...prev, [name]: value } as T
      onChange?.(next)
      return next
    })
  }

  // Beispielhafte Nutzung (in echten UIs per Inputs)
  // update({ name: 'age', value: 30 }) // nur gültig, wenn T['age'] number ist

  return <pre>{JSON.stringify(model)}</pre>
}
```

* **Ein Typparameter `T`** steuert sowohl Props als auch State.
* `FieldUpdate<T, K>` koppelt Key und Wert-Typ (`K extends keyof T` → `value: T[K]`).

---

### 2) Generischer `useReducer<T>`: Actions an `T` binden

```js
// useModelReducer.ts
import React from 'react'

export type ModelAction<T> =
  | { type: 'set'; payload: T }
  | { type: 'patch'; payload: Partial<T> }

function reducer<T>(state: T, action: ModelAction<T>): T {
  switch (action.type) {
    case 'set':   return action.payload
    case 'patch': return { ...state, ...action.payload } as T
  }
}

export function useModelReducer<T>(initial: T) {
  return React.useReducer(reducer<T>, initial)
}
```

```js
// Usage.tsx
import React from 'react'
import { useModelReducer } from './useModelReducer.js'

type User = { id: string; name: string; age: number }

export default function UserEditor() {
  const [user, dispatch] = useModelReducer<User>({ id: '1', name: 'Sergii', age: 34 })
  // dispatch({ type: 'patch', payload: { age: 35 } }) // payload typgeprüft gegen User
  return <pre>{JSON.stringify(user)}</pre>
}
```

* Actions sind **diszipliniert** an `T` gekoppelt (`Partial<T>` für Patch).

---

### 3) Generischer State mit abgeleitetem Teilzustand

```js
// useSelected.ts
import React from 'react'

export function useSelected<T, K extends keyof T>(initial: T, key: K) {
  const [state, setState] = React.useState<T>(initial)
  const selected: T[K] = state[key] // abgeleiteter Teilzustand

  function setSelected(value: T[K]) {
    setState(prev => ({ ...prev, [key]: value }))
  }

  return { state, selected, setSelected }
}
```

* **Verbinden von Generics**: `T` (Objekt) + `K` (Key) → abgeleiteter Wert `T[K]`.

---

### 4) Generischer Controlled-Wrapper: Props überschreiben + State halten

```js
// ControlledInput.tsx
import React from 'react'
import type { ComponentProps } from 'react'

type Base = ComponentProps<'input'>
type Controlled<T> = Omit<Base, 'value' | 'onChange'> & {
  value: T
  onChange: (v: T) => void
}

export function ControlledInput<T extends string | number>({
  value, onChange, ...rest
}: Controlled<T>) {
  // interner State optional (z. B. für Debounce), bleibt an T gekoppelt
  const [inner, setInner] = React.useState<T>(value)

  React.useEffect(() => setInner(value), [value])

  return (
    <input
      {...rest}
      value={inner as unknown as string}
      onChange={(e) => {
        const next = (typeof inner === 'number' ? Number(e.target.value) : e.target.value) as T
        setInner(next)
        onChange(next) // T bleibt konsistent zwischen Props & State
      }}
    />
  )
}
```

* **Props-Generic `T`** bestimmt zugleich den **State-Typ**.

---

### 5) Generische Komponente + `forwardRef` + State

```js
// Select.tsx
import React, { forwardRef } from 'react'

export type Option<T> = { label: string; value: T }
export type SelectProps<T> = {
  options: Option<T>[]
  value: T | null
  onChange: (v: T) => void
}

function SelectInner<T>(
  { options, value, onChange }: SelectProps<T>,
  ref: React.Ref<HTMLSelectElement>
) {
  return (
    <select
      ref={ref}
      value={value == null ? '' : String(options.find(o => o.value === value)?.label ?? '')}
      onChange={(e) => {
        const picked = options.find(o => o.label === e.target.value)!
        onChange(picked.value) // T bleibt intakt
      }}
    >
      {options.map(o => <option key={o.label}>{o.label}</option>)}
    </select>
  )
}

// Generische Signatur nach forwardRef bewahren
export const Select = forwardRef(SelectInner) as <T>(
  p: SelectProps<T> & { ref?: React.Ref<HTMLSelectElement> }
) => JSX.Element
```

* `forwardRef` „vergisst“ Generics → mit **Assertion** signieren.

---

### 6) Tipps für stabile Typinferenz

* **Initialwerte** passend typisieren (`useState<T>(initial)` oder `useState(() => initial)` für Lazy-Init).
* **Kein `React.FC`** nötig; explizite Props geben klarere Generics (keine impliziten `children`).
* **Updaters** als **funktionale Updates** schreiben (`setState(prev => …)`), damit `T` sauber erhalten bleibt.
* Bei komplexen Patterns **Utility Types** nutzen: `Partial<T>`, `Pick<T, …>`, `Omit<T, …>`, `Readonly<T>`.

---

**Zusammenfassung**

* Ein gemeinsamer Typparameter `T` verbindet **Props und State** (`useState<T>`, `useReducer<T>`).
* Mit `K extends keyof T` koppelt man **Key und Wert** (`value: T[K]`).
* `forwardRef`/`memo` benötigen **Assertion/Helper**, um Generics zu bewahren.
* Ziel: maximale **Inferenz** ohne `any`, konsistente Typen über Komponenten-API und internen Zustand.

**Quellen**

* TypeScript: [Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html), [keyof](https://www.typescriptlang.org/docs/handbook/2/keyof-types.html), [Utility Types](https://www.typescriptlang.org/docs/handbook/utility-types.html)
* React: [`useState`](https://react.dev/reference/react/useState), [`useReducer`](https://react.dev/reference/react/useReducer), [`forwardRef`](https://react.dev/reference/react/forwardRef)
* React TypeScript Cheatsheet – *Advanced Patterns (Generics, State, forwardRef)*: [https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase](https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase)

  **[⬆ Наверх](#top)**

120. ### <a name="120"></a> Wie stellt man vollständige Typsicherheit bei der Arbeit mit APIs sicher?

**Vollständige Typsicherheit bei API-Arbeit (TypeScript + React/TS)**

---

### 1) Trenne **Design-Zeit** (TypeScript) und **Laufzeit** (Validierung)

* **Compile-Time:** strikte Typen, `unknown` statt `any`, generische Wrapper.
* **Run-Time:** Schema-Validierung (z. B. Zod) gegen untrusted Daten, bevor sie ins Typsystem „gelassen“ werden.

```js
// api/schema.ts
import { z } from 'zod'

export const UserSchema = z.object({
  id: z.string(),
  name: z.string(),
  age: z.number().int().nonnegative(),
})
export type User = z.infer<typeof UserSchema>
```

```js
// api/fetch.ts
export async function getJSON(url, init) {
  const res = await fetch(url, init)
  if (!res.ok) throw new Error(`HTTP ${res.status}`)
  return /** @type {Promise<unknown>} */ (res.json())
}
```

```js
// api/users.ts
import { UserSchema } from './schema.js'
import { getJSON } from './fetch.js'

export async function getUser(id) {
  const data = await getJSON(`/api/users/${id}`) // unknown
  return UserSchema.parse(data)                  // -> User (typsicher + validiert)
}
```

*`Response.json()` ist `any`; erst **parse**n, dann als `User` verwenden.*
Quellen: MDN Fetch/Response; TS Generics.

---

### 2) Baue einen **typsicheren Request-Wrapper** (Result-Pattern)

```js
// api/request.ts
export type Ok<T>  = { ok: true; data: T }
export type Err<E> = { ok: false; error: E }
export type Result<T, E> = Ok<T> | Err<E>

export async function request<T, E = { message: string }>(url, init) {
  try {
    const res = await fetch(url, init)
    const json = await res.json().catch(() => null)
    if (!res.ok) return { ok: false, error: (json ?? { message: `HTTP ${res.status}` }) }
    return { ok: true, data: /** @type {T} */ (json) }
  } catch (e) {
    return { ok: false, error: /** @type {E} */ ({ message: String(e) }) }
  }
}
```

```js
// Verwendung mit Zod-Guard:
import { UserSchema } from './schema.js'
import { request } from './request.js'

export async function loadUser(id) {
  const r = await request(`/api/users/${id}`)
  if (!r.ok) throw new Error(r.error.message)
  return UserSchema.parse(r.data) // Laufzeit-Check
}
```

*Discriminated Union → sichere Erfolg/Fehler-Zweige ohne `try/catch` an jeder Stelle.*

---

### 3) **Axios** generisch + Fehler typsicher (optional)

```js
// api/axios.ts
import axios, { AxiosError } from 'axios'
export type ApiErr = { code?: string; message: string }

export async function getUserAxios(id) {
  try {
    const { data } = await axios.get/** @type {<T>(u:string)=>Promise<import('axios').AxiosResponse<T>>} */(`/api/users/${id}`)
    return data // T
  } catch (e) {
    if (axios.isAxiosError(e)) {
      const err = /** @type {AxiosError<ApiErr>} */ (e)
      throw new Error(err.response?.data?.message ?? err.message)
    }
    throw e
  }
}
```

*Fehlerpfade via `AxiosError<E>` präzise modellieren.*

---

### 4) **Strict Types** für Requests/DTOs (Utility Types)

```js
// models.ts
export type User = { id: string; name: string; age: number; createdAt: string }
export type CreateUserDto = Omit<User, 'id' | 'createdAt'>
export type UpdateUserDto = Partial<Pick<User, 'name' | 'age'>>
```

*Nur erlaubte Felder an den Endpunkten: `Omit`, `Pick`, `Partial`.*

---

### 5) **Hooks**: Eingänge/Ausgänge getypt halten

```js
// hooks/useUser.ts
import React from 'react'
import { getUser } from '../api/users.js'
import type { User } from '../api/schema.js'

export function useUser(id) {
  const [data, setData] = React.useState/** @type {User | null} */(null)
  const [error, setError] = React.useState/** @type {string | null} */(null)
  React.useEffect(() => {
    let alive = true
    getUser(id).then(u => alive && setData(u)).catch(e => alive && setError(String(e)))
    return () => { alive = false }
  }, [id])
  return { data, error }
}
```

*State-Typen exakt halten; niemals unvalidierte Daten in globale Stores.*

---

### 6) **Redux Toolkit**: Fehler & Erfolg strikt

```js
// features/users/thunks.ts
import { createAsyncThunk } from '@reduxjs/toolkit'
import type { User } from '../../api/schema.js'
type ApiError = { message: string }

export const fetchUser = createAsyncThunk<
  User, { id: string }, { rejectValue: ApiError }
>('users/fetch', async ({ id }, { rejectWithValue }) => {
  const res = await fetch(`/api/users/${id}`)
  if (!res.ok) return rejectWithValue(await res.json())
  const data = await res.json()
  // hier idealerweise UserSchema.parse(data)
  return data
})
```

*`rejectWithValue<E>` garantiert ein konsistentes Fehlerobjekt im Store.*

---

### 7) **Ende-zu-Ende**: Verträge prüfen (Build/Runtime)

* **Build-Zeit:** strikte Typen, keine `any`-Leaks (`noImplicitAny`, `strict` in `tsconfig`).
* **Runtime:** Schemas per Response prüfen (Zod/Yup); bei Änderungen **fail fast**.
* Optional: API-Vertrag zentralisieren (OpenAPI → Codegen Typen, dann weiterhin **Schema-Check zur Laufzeit** für externe Quellen).

---

### 8) **Sichere Defaults** und Abbruch

```js
// abortable.ts
export async function fetchWithTimeout(url, ms = 8000) {
  const controller = new AbortController()
  const t = setTimeout(() => controller.abort(), ms)
  try {
    const res = await fetch(url, { signal: controller.signal })
    if (!res.ok) throw new Error(`HTTP ${res.status}`)
    return res
  } finally {
    clearTimeout(t)
  }
}
```

*Vermeidet hängende Requests; Fehler bleiben typisiert verarbeitet.*

---

**Zusammenfassung**

* **Compile-Time:** strikte Typen, generische Wrapper, Utility Types für DTOs.
* **Run-Time:** **Schema-Validierung** (z. B. Zod) *vor* Nutzung der Daten.
* **Result-Pattern**/discriminated unions für sauberes Error-Handling.
* In Redux/RTK Query/Async Thunks **Fehlertypen** explicit machen.
* **Keine unvalidierten Daten** in State/Store; `unknown` > `any`.
* Optional: OpenAPI-Codegen + zusätzliche Runtime-Checks bei externen APIs.

**Quellen**

* TypeScript Docs: [Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html), [Utility Types](https://www.typescriptlang.org/docs/handbook/utility-types.html), [Narrowing](https://www.typescriptlang.org/docs/handbook/2/narrowing.html), [Template Literal / Mapped / Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
* React TypeScript Cheatsheet: [https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/)
* MDN Web Docs (RU): [Fetch API](https://developer.mozilla.org/ru/docs/Web/API/Fetch_API), [AbortController](https://developer.mozilla.org/ru/docs/Web/API/AbortController)
* React Offizielle Doku (Hooks/Patterns): [https://react.dev/](https://react.dev/)

  **[⬆ Наверх](#top)**

121. ### <a name="121"></a> 



  **[⬆ Наверх](#top)**

122. ### <a name="122"></a> 



  **[⬆ Наверх](#top)**

123. ### <a name="123"></a> 



  **[⬆ Наверх](#top)**

124. ### <a name="124"></a> 



  **[⬆ Наверх](#top)**

125. ### <a name="125"></a> 



  **[⬆ Наверх](#top)**

126. ### <a name="126"></a> 



  **[⬆ Наверх](#top)**

127. ### <a name="127"></a> 



  **[⬆ Наверх](#top)**

128. ### <a name="128"></a> 



  **[⬆ Наверх](#top)**

129. ### <a name="129"></a> 



  **[⬆ Наверх](#top)**

130. ### <a name="130"></a> 



  **[⬆ Наверх](#top)**  

131. ### <a name="131"></a> 



  **[⬆ Наверх](#top)**

132. ### <a name="132"></a> 



  **[⬆ Наверх](#top)**

133. ### <a name="133"></a> 



  **[⬆ Наверх](#top)**

134. ### <a name="134"></a> 



  **[⬆ Наверх](#top)**

135. ### <a name="135"></a> 



  **[⬆ Наверх](#top)**

136. ### <a name="136"></a> 



  **[⬆ Наверх](#top)**

137. ### <a name="137"></a> 



  **[⬆ Наверх](#top)**

138. ### <a name="138"></a> 



  **[⬆ Наверх](#top)**

139. ### <a name="139"></a> 



  **[⬆ Наверх](#top)**

140. ### <a name="140"></a> 



  **[⬆ Наверх](#top)**  

141. ### <a name="141"></a> 



  **[⬆ Наверх](#top)**

142. ### <a name="142"></a> 



  **[⬆ Наверх](#top)**

143. ### <a name="143"></a> 



  **[⬆ Наверх](#top)**

144. ### <a name="144"></a> 



  **[⬆ Наверх](#top)**

145. ### <a name="145"></a> 



  **[⬆ Наверх](#top)**

146. ### <a name="146"></a> 



  **[⬆ Наверх](#top)**

147. ### <a name="147"></a> 



  **[⬆ Наверх](#top)**

148. ### <a name="148"></a> 



  **[⬆ Наверх](#top)**

149. ### <a name="149"></a> 



  **[⬆ Наверх](#top)**

150. ### <a name="150"></a> 



  **[⬆ Наверх](#top)**  

151. ### <a name="151"></a> 



  **[⬆ Наверх](#top)**

152. ### <a name="152"></a> 



  **[⬆ Наверх](#top)**

153. ### <a name="153"></a> 



  **[⬆ Наверх](#top)**

154. ### <a name="154"></a> 



  **[⬆ Наверх](#top)**

155. ### <a name="155"></a> 



  **[⬆ Наверх](#top)**

156. ### <a name="156"></a> 



  **[⬆ Наверх](#top)**

157. ### <a name="157"></a> 



  **[⬆ Наверх](#top)**

158. ### <a name="158"></a> 



  **[⬆ Наверх](#top)**

159. ### <a name="159"></a> 



  **[⬆ Наверх](#top)**

160. ### <a name="160"></a> 



  **[⬆ Наверх](#top)**

161. ### <a name="161"></a> 



  **[⬆ Наверх](#top)**

162. ### <a name="162"></a> 



  **[⬆ Наверх](#top)**

163. ### <a name="163"></a> 



  **[⬆ Наверх](#top)**

164. ### <a name="164"></a> 



  **[⬆ Наверх](#top)**

165. ### <a name="165"></a> 



  **[⬆ Наверх](#top)**

166. ### <a name="166"></a> 



  **[⬆ Наверх](#top)**

167. ### <a name="167"></a> 



  **[⬆ Наверх](#top)**

168. ### <a name="168"></a> 



  **[⬆ Наверх](#top)**

169. ### <a name="169"></a> 



  **[⬆ Наверх](#top)**

170. ### <a name="170"></a> 



  **[⬆ Наверх](#top)**

171. ### <a name="171"></a> 



  **[⬆ Наверх](#top)**

172. ### <a name="172"></a> 



  **[⬆ Наверх](#top)**

173. ### <a name="173"></a> 



  **[⬆ Наверх](#top)**

174. ### <a name="174"></a> 



  **[⬆ Наверх](#top)**

175. ### <a name="175"></a> 



  **[⬆ Наверх](#top)**

176. ### <a name="176"></a> 



  **[⬆ Наверх](#top)**

177. ### <a name="177"></a> 



  **[⬆ Наверх](#top)**

178. ### <a name="178"></a> 



  **[⬆ Наверх](#top)**

179. ### <a name="179"></a> 



  **[⬆ Наверх](#top)**

180. ### <a name="180"></a> 



  **[⬆ Наверх](#top)**  

181. ### <a name="181"></a> 



  **[⬆ Наверх](#top)**

182. ### <a name="182"></a> 



  **[⬆ Наверх](#top)**

183. ### <a name="183"></a> 



  **[⬆ Наверх](#top)**

184. ### <a name="184"></a> 



  **[⬆ Наверх](#top)**

185. ### <a name="185"></a> 



  **[⬆ Наверх](#top)**

186. ### <a name="186"></a> 



  **[⬆ Наверх](#top)**

187. ### <a name="187"></a> 



  **[⬆ Наверх](#top)**

188. ### <a name="188"></a> 



  **[⬆ Наверх](#top)**

189. ### <a name="189"></a> 



  **[⬆ Наверх](#top)**

190. ### <a name="190"></a> 



  **[⬆ Наверх](#top)**  

191. ### <a name="191"></a> 



  **[⬆ Наверх](#top)**

192. ### <a name="192"></a> 



  **[⬆ Наверх](#top)**

193. ### <a name="193"></a> 



  **[⬆ Наверх](#top)**

194. ### <a name="194"></a> 



  **[⬆ Наверх](#top)**

195. ### <a name="195"></a> 



  **[⬆ Наверх](#top)**

196. ### <a name="196"></a> 



  **[⬆ Наверх](#top)**

197. ### <a name="197"></a> 



  **[⬆ Наверх](#top)**

198. ### <a name="198"></a> 



  **[⬆ Наверх](#top)**

199. ### <a name="199"></a> 



  **[⬆ Наверх](#top)**

200. ### <a name="200"></a> 



  **[⬆ Наверх](#top)**      
