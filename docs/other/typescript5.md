<a name="top"></a>

[На главную](../README.md)

[Перейти к вопросам](#questions)

| №. | Вопрос |
| --- | --------- |
|   | TypeScript — Grundlagen |
|1 | [Was ist TypeScript und wie unterscheidet es sich von JavaScript?](#1) |
|2 | [Welche Vorteile bietet die Verwendung von TypeScript?](#2) |
|3 | [Was ist Typisierung (static typing)?](#3) |
|4 | [Welche grundlegenden Typen gibt es in TypeScript?](#4) |
|5 | [Worin besteht der Unterschied zwischen any und unknown?](#5) |
|6 | [Was ist never und wann wird es verwendet?](#6) |
|7 | [Was ist der Unterschied zwischen null und undefined?](#7) |
|8 | [Was ist void?](#8) |
|9 | [Was sind Union Types? Gib ein Beispiel.](#9) |
|10 | [Was sind Intersection Types? Gib ein Beispiel.](#10) |
|11 | [Was sind Literal Types?](#11) |
|12 | [Wie funktioniert type inference in TypeScript?](#12) |
|13 | [Was ist ein Type Alias (type) und wie unterscheidet er sich von interface?](#13) |
|14 | [Was ist der Unterschied zwischen interface und type?](#14) |
|15 | [Kann man Interfaces zusammenführen (extend)?](#15) |
|16 | [Was sind optionale Eigenschaften in Interfaces?](#16) |
|17 | [Wie deklariert man readonly-Eigenschaften?](#17) |
|18 | [Was sind Tupel (tuples) in TypeScript?](#18) |
|19 | [Was ist ein Enum und wann sollte man es verwenden?](#19) |
|20 | [Was ist der Unterschied zwischen const enum und einem normalen enum?](#20) |
|21 | [Was ist Type Narrowing (Typschränkung)?](#21) |
|22 | [Was sind Type Guards? Gib ein Beispiel.](#22) |
|23 | [Wie funktioniert der Operator in bei der Typprüfung?](#23) |
|24 | [Wie funktioniert typeof in TypeScript?](#24) |
|25 | [Wie funktioniert instanceof?](#25) |
|26 | [Was sind Discriminated Unions (diskriminierte Typen)?](#26) |
|27 | [Was ist der Unterschied zwischen interface und abstract class?](#27) |
|28 | [Wie implementiert man Funktionsüberladungen (function overloads) in TypeScript?](#28) |
|29 | [Was sind Index Signatures?](#29) |
|30 | [Was ist keyof und wofür wird es verwendet?](#30) |
|31 | [Wie funktioniert der Operator as?](#31) |
|32 | [Was ist der Unterschied zwischen as const und einem normalen const?](#32) |
|33 | [Was macht der Operator satisfies (TS 4.9+)?](#33) |
|34 | [Was sind Assertion Functions?](#34) |
|35 | [Was ist der Unterschied zwischen struktureller Typisierung (structural typing) und nominaler Typisierung (nominal typing)?](#35) |
|36 | [Was sind Deklarationsdateien (.d.ts)?](#36) |
|37 | [Wie bindet man eine externe JS-Bibliothek ohne Typen ein?](#37) |
|38 | [Was sind Ambient Declarations (declare)?](#38) |
|39 | [Was ist strict mode in TypeScript?](#39) |
|40 | [Wozu dient strictNullChecks?](#40) |
|   | TypeScript — Funktionen und Generics |
|41 | [Wie typisiert man Parameter und Rückgabewerte von Funktionen?](#41) |
|42 | [Was sind optionale Parameter in Funktionen?](#42) |
|43 | [Wie deklariert man Standardwerte für Parameter mit Typisierung?](#43) |
|44 | [Was sind Rest-Parameter und wie typisiert man sie?](#44) |
|45 | [Wie typisiert man Arrow Functions?](#45) |
|46 | [Was sind Funktionsüberladungen?](#46) |
|47 | [Was sind Generics?](#47) |
|48 | [Wie erstellt man eine generische Funktion?](#48) |
|49 | [Was sind Generic Constraints (extends)?](#49) |
|50 | [Wie funktioniert T extends keyof U?](#50) |
|51 | [Was sind Utility Types (Partial, Pick, Omit, Record usw.)?](#51) |
|52 | [Was ist der Unterschied zwischen Partial<T> und Required<T>?](#52) |
|53 | [Wie funktioniert Readonly<T>?](#53) |
|54 | [Wie funktionieren Pick<T, K> und Omit<T, K>?](#54) |
|55 | [Was macht Record<K, T>?](#55) |
|56 | [Was macht ReturnType<T>?](#56) |
|57 | [Was macht Parameters<T>?](#57) |
|58 | [Was macht ConstructorParameters<T>?](#58) |
|59 | [Wie funktionieren Extract und Exclude?](#59) |
|60 | [Was macht NonNullable<T>?](#60) |
|   | TypeScript — Klassen und OOP |
|61 | [Wie deklariert man eine Klasse in TypeScript?](#61) |
|62 | [Was sind Zugriffsmodifikatoren (public, private, protected)?](#62) |
|63 | [Was sind readonly-Eigenschaften in Klassen?](#63) |
|64 | [Wie deklariert man statische Eigenschaften und Methoden?](#64) |
|65 | [Was ist der Unterschied zwischen einer abstrakten und einer normalen Klasse?](#65) |
|66 | [Kann man Interfaces mit Klassen implementieren?](#66) |
|67 | [Was ist der Unterschied zwischen implements und extends?](#67) |
|68 | [Was ist this und wie typisiert man es?](#68) |
|69 | [Kann man generische Klassen erstellen?](#69) |
|   | React + TypeScript — Grundlagen |
|70 | [Wie erstellt man ein React-Projekt mit TypeScript?](#70) |
|71 | [Wie typisiert man eine React-Komponente (FC)?](#71) |
|72 | [Was ist React.FC und wann sollte man es vermeiden?](#72) |
|73 | [Wie typisiert man Props in einer React-Komponente?](#73) |
|74 | [Wie typisiert man optionale Props?](#74) |
|75 | [Wie deklariert man Default Props in TypeScript?](#75) |
|76 | [Wie typisiert man children in React-Komponenten?](#76) |
|77 | [Was ist der Unterschied zwischen ReactNode, JSX.Element und ReactElement?](#77) |
|78 | [Wie typisiert man Events (z. B. onClick, onChange)?](#78) |
|79 | [Wie typisiert man Refs in React?](#79) |
|80 | [Wie typisiert man State mit useState?](#80) |
|81 | [Wie typisiert man useReducer?](#81) |
|82 | [Wie typisiert man useRef mit initial null?](#82) |
|83 | [Wie typisiert man einen Custom Hook?](#83) |
|84 | [Wie typisiert man Komponenten mit forwardRef?](#84) |
|85 | [Wie typisiert man Context (React Context API)?](#85) |
|86 | [Wie typisiert man HOCs (Higher-Order Components)?](#86) |
|87 | [Wie typisiert man asynchrone Funktionen in React-Komponenten?](#87) |
|88 | [Wie typisiert man Event-Handler in Formularen?](#88) |
|89 | [Wie typisiert man API-Requests und Responses?](#89) |
|90 | [Wie typisiert man React-Router-Komponenten?](#90) |
|   | React + TypeScript — Praxis und Architektur |
|91 | [Wie organisiert man Typen für ein gesamtes Projekt?](#91) |
|92 | [Wo speichert man gemeinsame Typen (z. B. User, Product)?](#92) |
|93 | [Wie typisiert man den globalen Store (Redux/RTK)?](#93) |
|94 | [Wie typisiert man Actions und Reducer im Redux Toolkit?](#94) |
|95 | [Wie typisiert man useSelector und useDispatch?](#95) |
|96 | [Wie typisiert man einen Zustand-Store (Zustand)?](#96) |
|97 | [Wie typisiert man Async Thunks?](#97) |
|98 | [Wie typisiert man Query Hooks in RTK Query?](#98) |
|99 | [Wie verwendet man Enums für Redux-Actions?](#99) |
|100 | [Wie typisiert man Formulare mit React Hook Form?](#100) |
|101 | [Wie typisiert man axios-Requests?](#101) |
|102 | [Wie typisiert man fetch-Requests mit Generics?](#102) |
|103 | [Wie geht man mit Typen bei API-Fehlern um?](#103) |
|104 | [Wie verwendet man Utility Types für API-Modelle?](#104) |
|105 | [Wie typisiert man Dynamic Imports in React?](#105) |
|106 | [Wie verwendet man keyof für dynamische Eigenschaften in Komponenten?](#106) |
|107 | [Wie erstellt man typsichere Styles (z. B. mit styled-components)?](#107) |
|108 | [Wie typisiert man Props für Bibliothekskomponenten (z. B. Material UI)?](#108) |
|109 | [Wie typisiert man React.memo?](#109) |
|110 | [Wie typisiert man React.lazy und Suspense?](#110) |
|   | Fragen auf Middle-Level |
|111 | [Wie verwendet man Conditional Types (T extends U ? X : Y)?](#111) |
|112 | [Was sind Mapped Types?](#112) |
|113 | [Wie funktionieren Template Literal Types?](#113) |
|114 | [Was ist infer?](#114) |
|115 | [Wie schreibt man eigene Utility Types?](#115) |
|116 | [Wie kombiniert man mehrere Generics?](#116) |
|117 | [Was sind polymorphe Komponenten in React?](#117) |
|118 | [Wie erstellt man eine generische React-Komponente?](#118) |
|119 | [Wie verbindet man Generics in Props und State?](#119) |
|120 | [Wie stellt man vollständige Typsicherheit bei der Arbeit mit APIs sicher?](#120) |
|121 | [](#121) |
|122 | [](#122) |
|123 | [](#123) |
|124 | [](#124) |
|125 | [](#125) |
|126 | [](#126) |
|127 | [](#127) |
|128 | [](#128) |
|129 | [](#129) |
|130 | [](#130) |
|131 | [](#131) |
|132 | [](#132) |
|133 | [](#133) |
|134 | [](#134) |
|135 | [](#135) |
|136 | [](#136) |
|137 | [](#137) |
|138 | [](#138) |
|139 | [](#139) |
|140 | [](#140) |
|141 | [](#141) |
|142 | [](#142) |
|143 | [](#143) |
|144 | [](#144) |
|145 | [](#145) |
|146 | [](#146) |
|147 | [](#147) |
|148 | [](#148) |
|149 | [](#149) |
|150 | [](#150) |
|151 | [](#151) |
|152 | [](#152) |
|153 | [](#153) |
|154 | [](#154) |
|155 | [](#155) |
|156 | [](#156) |
|157 | [](#157) |
|158 | [](#158) |
|159 | [](#159) |
|160 | [](#160) |
|161 | [](#161) |
|162 | [](#162) |
|163 | [](#163) |
|164 | [](#164) |
|165 | [](#165) |
|166 | [](#166) |
|167 | [](#167) |
|168 | [](#168) |
|169 | [](#169) |
|170 | [](#170) |
|171 | [](#171) |
|172 | [](#172) |
|173 | [](#173) |
|174 | [](#174) |
|175 | [](#175) |
|176 | [](#176) |
|177 | [](#177) |
|178 | [](#178) |
|179 | [](#179) |
|180 | [](#180) |
|181 | [](#181) |
|182 | [](#182) |
|183 | [](#183) |
|184 | [](#184) |
|185 | [](#185) |
|186 | [](#186) |
|187 | [](#187) |
|188 | [](#188) |
|189 | [](#189) |
|190 | [](#190) |
|191 | [](#191) |
|192 | [](#192) |
|193 | [](#193) |
|194 | [](#194) |
|195 | [](#195) |
|196 | [](#196) |
|197 | [](#197) |
|198 | [](#198) |
|199 | [](#199) |
|200 | [](#200) |



<a name="questions"></a>

## ReactJS 

  **[⬆ Наверх](#top)**
  
1. ### <a name="1"></a> Was ist TypeScript und wie unterscheidet es sich von JavaScript?

**TypeScript** ist eine von Microsoft entwickelte Programmiersprache, die auf **JavaScript** basiert und dieses um **statische Typisierung** erweitert. Jeder gültige JavaScript-Code ist auch gültiger TypeScript-Code.

### Hauptunterschiede zu JavaScript

1. **Statische Typisierung**

   * In JavaScript sind Variablen dynamisch typisiert.
   * In TypeScript kann man Typen explizit angeben, was Fehler schon während der Entwicklung verhindert.

   ```js
   // JavaScript (dynamisch, Fehler erst zur Laufzeit möglich)
   let name = "Sergii"
   name = 42 // kein Fehler beim Schreiben, nur Laufzeitproblem

   // TypeScript (statisch, Fehler beim Kompilieren)
   let name: string = "Sergii"
   name = 42 // ❌ Fehler: Type 'number' is not assignable to type 'string'
   ```

2. **Typinferenz**

   * TypeScript erkennt oft automatisch den Typ einer Variable.

   ```js
   let age = 33 // Typ: number (automatisch erkannt)
   ```

3. **Erweiterte Features**

   * Interfaces, Enums, Generics, Union- und Intersection-Types, Utility-Types.

   ```js
   interface User {
     id: number
     name: string
   }

   const user: User = { id: 1, name: "Sergii" }
   ```

4. **Kompilierung**

   * TypeScript wird in **JavaScript** transpiliert (mittels `tsc` oder Bundler wie Vite/Webpack).
   * Läuft nicht direkt im Browser, sondern wird vorher in JavaScript konvertiert.

5. **Entwicklerfreundlichkeit**

   * Bessere **IntelliSense**, Autovervollständigung und Fehlererkennung in IDEs.

---

### Zusammenfassung

* **JavaScript**: dynamisch typisiert, direkt im Browser lauffähig.
* **TypeScript**: superset von JavaScript mit **statischer Typisierung** und zusätzlichen Features; erfordert Transpilation.
* Vorteil: Weniger Laufzeitfehler, besserer Code-Support.

🔗 Quellen:

* [TypeScript: What is TypeScript?](https://www.typescriptlang.org/docs/handbook/intro.html)
* [React TypeScript Cheatsheet: Setup](https://react-typescript-cheatsheet.netlify.app/docs/basic/setup)

  **[⬆ Наверх](#top)**

2. ### <a name="2"></a> Welche Vorteile bietet die Verwendung von TypeScript?

### Vorteile von TypeScript

1. **Frühe Fehlererkennung**

   * Typfehler werden bereits beim Kompilieren gefunden, bevor der Code ausgeführt wird.

   ```js
   let price: number = 50
   price = "fünfzig" // ❌ Fehler beim Kompilieren
   ```

2. **Bessere Entwicklererfahrung (DX)**

   * IntelliSense, Autovervollständigung, Hover-Infos und Refactoring sind präziser.

3. **Klarheit und Wartbarkeit**

   * Durch Typannotationen und Interfaces ist der Code selbstdokumentierend.

   ```js
   interface Product {
     id: number
     name: string
     price: number
   }
   ```

4. **Skalierbarkeit**

   * Besonders nützlich in großen Projekten mit vielen Entwicklern.
   * Änderungen sind sicherer, da Typen sofort Konflikte zeigen.

5. **Moderne Features**

   * Unterstützung von Generics, Union/Intersection Types, Enums, Utility-Types.

   ```js
   function wrapValue<T>(value: T): T[] {
     return [value]
   }
   const result = wrapValue<string>("Hallo") // result: string[]
   ```

6. **Kompatibilität mit JavaScript**

   * Jeder JS-Code läuft auch in TS.
   * Migration von bestehenden Projekten möglich (schrittweise Einführung).

---

### Zusammenfassung

* **TypeScript** bringt Typensicherheit, bessere Entwickler-Tools, klareren und wartbareren Code, Skalierbarkeit in großen Projekten und moderne Sprachfeatures.
* Besonders vorteilhaft bei **langfristigen, komplexen Projekten** mit mehreren Teammitgliedern.

🔗 Quellen:

* [TypeScript Handbook – Why TypeScript](https://www.typescriptlang.org/docs/handbook/2/basic-types.html)
* [React TypeScript Cheatsheet – Vorteile](https://react-typescript-cheatsheet.netlify.app/docs/basic/setup)

  **[⬆ Наверх](#top)**

3. ### <a name="3"></a> Was ist Typisierung (static typing)?

### Typisierung (Static Typing)

**Definition:**
Statische Typisierung bedeutet, dass der Datentyp einer Variable oder Funktion **zur Compile-Zeit** festgelegt wird und nicht erst zur Laufzeit.

### Merkmale

1. **Fester Typ während der gesamten Lebenszeit**

   * Eine Variable behält den einmal festgelegten Typ.
   * Zuweisungen anderer Typen führen zu einem Kompilierungsfehler.

   ```js
   let username: string = "Sergii"
   username = 42 // ❌ Fehler: number ist nicht string
   ```

2. **Frühe Fehlererkennung**

   * Tippfehler oder falsche Funktionsaufrufe werden direkt angezeigt.

   ```js
   function add(a: number, b: number): number {
     return a + b
   }

   add(5, "10") // ❌ Fehler: Argument vom Typ 'string' ist nicht zuweisbar
   ```

3. **Verbesserte Autovervollständigung und Dokumentation**

   * IDEs können anhand der Typen Vorschläge und Hilfen anzeigen.

4. **Generics und komplexe Typen**

   * Flexible, aber dennoch sichere Strukturen möglich.

   ```js
   function identity<T>(value: T): T {
     return value
   }
   const result = identity<number>(10) // Typ: number
   ```

---

### Unterschied zu dynamischer Typisierung (JavaScript)

* **Dynamisch:** Typen werden erst zur Laufzeit geprüft.
* **Statisch:** Typen werden bereits vor der Ausführung geprüft.

---

### Zusammenfassung

* **Static Typing** = feste Typprüfung während der Kompilierung.
* Vorteile: weniger Laufzeitfehler, klarer Code, bessere Tool-Unterstützung.
* In TypeScript zwingend (mit Ausnahmen wie `any`), in JavaScript nicht vorhanden.

🔗 Quellen:

* [TypeScript Handbook – Basic Types](https://www.typescriptlang.org/docs/handbook/2/basic-types.html)
* [MDN – JavaScript Datentypen](https://developer.mozilla.org/ru/docs/Web/JavaScript/Data_structures)

  **[⬆ Наверх](#top)**

4. ### <a name="4"></a> Welche grundlegenden Typen gibt es in TypeScript?

### Grundlegende Typen in TypeScript

TypeScript erweitert JavaScript um **statische Typisierung**. Die wichtigsten **Basis-Typen** sind:

---

#### 1. **Primitives**

* **string**

  ```js
  let username: string = "Sergii"
  ```
* **number** (Ganzzahlen & Fließkommazahlen)

  ```js
  let age: number = 34
  ```
* **boolean**

  ```js
  let isOnline: boolean = true
  ```
* **null** und **undefined**

  ```js
  let value: null = null
  let notAssigned: undefined = undefined
  ```
* **bigint** (für sehr große Zahlen)

  ```js
  let big: bigint = 9007199254740991n
  ```
* **symbol** (einzigartige Werte)

  ```js
  let uniqueId: symbol = Symbol("id")
  ```

---

#### 2. **Arrays**

```js
let numbers: number[] = [1, 2, 3]
let names: Array<string> = ["Anna", "Tom"] // Generics-Schreibweise
```

---

#### 3. **Tuples**

* Feste Anzahl von Elementen mit festen Typen.

```js
let person: [string, number] = ["Sergii", 34]
```

---

#### 4. **Enums**

* Sammlung von benannten Konstanten.

```js
enum Role {
  Admin,
  User,
  Guest
}

let currentRole: Role = Role.Admin
```

---

#### 5. **Any**

* Deaktiviert Typprüfung (sollte vermieden werden).

```js
let data: any = 5
data = "Text"
```

---

#### 6. **Unknown**

* Sicherere Alternative zu `any`, erfordert Typprüfung vor Verwendung.

```js
let value: unknown = "Hallo"

if (typeof value === "string") {
  console.log(value.toUpperCase())
}
```

---

#### 7. **Void**

* Wird für Funktionen verwendet, die nichts zurückgeben.

```js
function logMessage(message: string): void {
  console.log(message)
}
```

---

#### 8. **Never**

* Für Funktionen, die niemals einen Wert zurückgeben (z. B. Fehler werfen).

```js
function throwError(msg: string): never {
  throw new Error(msg)
}
```

---

### Zusammenfassung

* **Primitive Typen**: string, number, boolean, null, undefined, bigint, symbol
* **Spezielle Typen**: any, unknown, void, never
* **Strukturierte Typen**: arrays, tuples, enums

🔗 Quellen:

* [TypeScript Handbook – Basic Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html)
* [React TypeScript Cheatsheet – Basic Setup](https://react-typescript-cheatsheet.netlify.app/docs/basic/setup)

  **[⬆ Наверх](#top)**

5. ### <a name="5"></a> Worin besteht der Unterschied zwischen any und unknown?

### Unterschied zwischen `any` und `unknown`

#### **1. `any`**

* Deaktiviert **jegliche Typprüfung**.
* Man kann jede Operation auf `any` ausführen, ohne Fehler beim Kompilieren.
* Gefahr: Laufzeitfehler, da TypeScript keine Sicherheit bietet.

```js
let value: any = "Hallo"
value = 123
value.toUpperCase() // ✅ Kein Fehler beim Kompilieren, aber Laufzeitfehler möglich
```

---

#### **2. `unknown`**

* Ist ein **sicherer Gegenspieler zu `any`**.
* Man kann einen Wert vom Typ `unknown` nicht direkt verwenden, ohne ihn vorher zu prüfen oder zu casten.
* Erzwingt **Type-Safety** durch Typabfragen.

```js
let input: unknown = "Hallo"

// ❌ Direkt nicht erlaubt
// input.toUpperCase()

// ✅ Mit Typprüfung
if (typeof input === "string") {
  console.log(input.toUpperCase())
}
```

---

#### **Vergleich**

| Merkmal            | `any`                 | `unknown`                            |
| ------------------ | --------------------- | ------------------------------------ |
| Typprüfung         | Keine                 | Erforderlich                         |
| Sicherheit         | Niedrig               | Hoch                                 |
| Nutzungsempfehlung | Nur in Ausnahmefällen | Besser als `any` für unsichere Werte |

---

### Zusammenfassung

* **`any`**: erlaubt alles, keine Typprüfung → unsicher.
* **`unknown`**: erfordert Typprüfung oder Casting → sicherer, bevorzugt für unbekannte Werte (z. B. API-Response).

🔗 Quellen:

* [TypeScript Handbook – unknown](https://www.typescriptlang.org/docs/handbook/2/functions.html#unknown)
* [React TypeScript Cheatsheet – any vs. unknown](https://react-typescript-cheatsheet.netlify.app/docs/basic/troubleshooting/types)

  **[⬆ Наверх](#top)**

6. ### <a name="6"></a> Was ist never und wann wird es verwendet?

### `never` in TypeScript

**Definition:**
`never` ist ein spezieller Typ für Werte, die **niemals existieren können**.
Eine Funktion oder ein Ausdruck vom Typ `never` beendet entweder den Programmfluss (z. B. durch einen Fehler) oder läuft unendlich weiter.

---

### Anwendungsfälle

#### 1. **Funktionen, die immer Fehler werfen**

```js
function throwError(message: string): never {
  throw new Error(message)
}
```

* Rückgabewert: niemals erreichbar, da die Funktion das Programm mit einem Fehler abbricht.

---

#### 2. **Endlose Schleifen**

```js
function infiniteLoop(): never {
  while (true) {
    console.log("läuft ewig...")
  }
}
```

* Die Funktion verlässt nie die Schleife → daher `never`.

---

#### 3. **Exhaustiveness Checking** (Typprüfung bei `switch` / `if-else`)

* `never` wird verwendet, um sicherzustellen, dass alle möglichen Fälle abgedeckt sind.

```js
type Shape = "circle" | "square"

function getArea(shape: Shape): number {
  switch (shape) {
    case "circle":
      return Math.PI * 10 ** 2
    case "square":
      return 10 * 10
    default:
      const exhaustiveCheck: never = shape
      return exhaustiveCheck
  }
}
```

* Vorteil: Falls später ein neuer Typ (`"triangle"`) hinzugefügt wird, zeigt TypeScript einen Fehler an, solange er nicht im `switch` behandelt wird.

---

### Unterschied zu `void`

* **`void`**: Funktion gibt keinen **Wert** zurück.
* **`never`**: Funktion gibt **nie** etwas zurück (nicht mal `undefined`).

---

### Zusammenfassung

* **`never`** = Typ für Werte, die nie vorkommen können.
* Typische Nutzung: Funktionen, die Fehler werfen, unendliche Schleifen oder Exhaustiveness Checking.
* Unterschied zu `void`: `void` = kein Rückgabewert, `never` = niemals Rückgabe.

🔗 Quellen:

* [TypeScript Handbook – never](https://www.typescriptlang.org/docs/handbook/2/functions.html#never)
* [MDN – JavaScript Error](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Error)

  **[⬆ Наверх](#top)**

7. ### <a name="7"></a> Was ist der Unterschied zwischen null und undefined?

### Unterschied zwischen `null` und `undefined` in TypeScript / JavaScript

#### **1. `undefined`**

* Automatischer Standardwert für nicht initialisierte Variablen oder fehlende Eigenschaften.
* Bedeutet: *"nicht zugewiesen"*.

```js
let a
console.log(a) // undefined

const obj = {}
console.log(obj.prop) // undefined
```

---

#### **2. `null`**

* Wird explizit vom Entwickler gesetzt.
* Bedeutet: *"absichtlich leer / kein Wert"*.

```js
let b: string | null = null
console.log(b) // null
```

---

#### **3. Vergleich**

```js
console.log(null == undefined)  // true  (lockerer Vergleich)
console.log(null === undefined) // false (strenger Vergleich)
```

---

#### **4. In TypeScript**

* `undefined` und `null` sind eigene Typen.
* Standardmäßig sind sie **Zuweisungen an andere Typen erlaubt** (abhängig von `--strictNullChecks`).

```js
let x: string | null = null   // erlaubt
let y: string | undefined     // muss initialisiert oder geprüft werden
```

---

#### **5. Typische Verwendung**

* **`undefined`**: vom System vergeben, wenn nichts zugewiesen wurde.
* **`null`**: vom Entwickler gesetzt, um „keinen Wert“ darzustellen.

---

### Zusammenfassung

* **`undefined`** = Wert fehlt automatisch (nicht initialisiert, nicht vorhanden).
* **`null`** = Wert wurde absichtlich auf „kein Wert“ gesetzt.
* Unterschied deutlich machen mit `===`: `null !== undefined`.

🔗 Quellen:

* [TypeScript Handbook – Everyday Types: null & undefined](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#null-and-undefined)
* [MDN – null](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/null)
* [MDN – undefined](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/undefined)

  **[⬆ Наверх](#top)**

8. ### <a name="8"></a> Was ist void?

### `void` in TypeScript

**Definition:**
`void` ist ein spezieller Typ in TypeScript, der bedeutet, dass eine Funktion **keinen Rückgabewert** hat.

---

### Anwendungsfälle

#### 1. **Funktion ohne Rückgabewert**

```js
function logMessage(message: string): void {
  console.log(message)
}

const result = logMessage("Hallo")
// result hat den Typ void → es wird nichts zurückgegeben
```

---

#### 2. **Callbacks, die nichts zurückgeben**

```js
function forEachItem(items: string[], callback: (item: string) => void) {
  for (const item of items) {
    callback(item)
  }
}

forEachItem(["A", "B"], (el) => console.log(el))
```

---

#### 3. **Unterschied zu `undefined`**

* `void` ≠ `undefined`, auch wenn Funktionen implizit `undefined` zurückgeben.
* Mit `void` sagt man ausdrücklich: *„Kein Rückgabewert ist relevant“*.

```js
function test(): void {
  return // erlaubt, implizit undefined
}

function test2(): undefined {
  return undefined // nur explizit erlaubt
}
```

---

#### 4. **Besonderheit bei Promises**

* `Promise<void>` → Funktion gibt ein Promise zurück, dessen Wert nicht benutzt werden soll.

```js
async function saveData(): Promise<void> {
  await fetch("/api/save")
}
```

---

### Zusammenfassung

* **`void`** kennzeichnet Funktionen ohne Rückgabewert.
* Typischer Einsatz: `console.log`, Event-Handler, Callbacks.
* Unterschied zu `undefined`: `void` betont die Abwesenheit eines Rückgabewerts, `undefined` ist ein Wert selbst.

🔗 Quellen:

* [TypeScript Handbook – void](https://www.typescriptlang.org/docs/handbook/2/functions.html#void)
* [React TS Cheatsheet – void in Callbacks](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/event-handling/)

  **[⬆ Наверх](#top)**

9. ### <a name="9"></a> Was sind Union Types? Gib ein Beispiel.

### Union Types in TypeScript

**Definition:**
Ein **Union Type** erlaubt es, dass eine Variable oder ein Parameter **mehrere mögliche Typen** haben kann. Er wird mit dem **`|`-Operator** geschrieben.

---

### Beispiel 1 – Variable mit mehreren Typen

```js
let id: string | number

id = 42      // ✅ erlaubt
id = "abc"   // ✅ erlaubt
id = true    // ❌ Fehler: boolean nicht erlaubt
```

---

### Beispiel 2 – Funktion mit Union Types

```js
function printId(id: string | number): void {
  if (typeof id === "string") {
    console.log("ID als Text:", id.toUpperCase())
  } else {
    console.log("ID als Zahl:", id.toFixed(2))
  }
}

printId("abc") // ID als Text: ABC
printId(123.456) // ID als Zahl: 123.46
```

---

### Beispiel 3 – Union in Arrays

```js
let values: (string | number)[] = [1, "zwei", 3, "vier"]
```

---

### Zusammenfassung

* **Union Types** = Typen, die **mehrere mögliche Werte** annehmen können.
* Verwendung: `string | number`, `(string | number)[]`.
* Nützlich für Werte mit mehreren erlaubten Formen (z. B. API-Response: `string | null`).

🔗 Quellen:

* [TypeScript Handbook – Union Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types)
* [React TypeScript Cheatsheet – Union Types](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example)

  **[⬆ Наверх](#top)**

10. ### <a name="10"></a> Was sind Intersection Types? Gib ein Beispiel.

### Intersection Types in TypeScript

**Definition:**
Ein **Intersection Type** (`&`) kombiniert mehrere Typen zu einem **neuen Typ**, der **alle Eigenschaften** der beteiligten Typen enthalten muss.
→ Während `Union (|)` **entweder-oder** bedeutet, ist `Intersection (&)` ein **sowohl-als-auch**.

---

### Beispiel 1 – Kombination von Interfaces

```js
interface Person {
  name: string
}

interface Employee {
  company: string
}

type EmployeePerson = Person & Employee

const worker: EmployeePerson = {
  name: "Sergii",
  company: "Tech GmbH"
}
```

---

### Beispiel 2 – Kombination von Typen

```js
type A = { x: number }
type B = { y: number }

type AB = A & B

const point: AB = { x: 10, y: 20 } // Muss beide Eigenschaften haben
```

---

### Beispiel 3 – Praktisch in Generics

```js
function merge<T, U>(objA: T, objB: U): T & U {
  return { ...objA, ...objB }
}

const merged = merge({ id: 1 }, { role: "admin" })
// Typ: { id: number } & { role: string }
```

---

### Zusammenfassung

* **Intersection Types (`&`)** = Kombination mehrerer Typen zu einem Typ, der **alle Eigenschaften** enthält.
* Unterschied zu Union:

  * **Union (`|`)** → entweder-oder.
  * **Intersection (`&`)** → sowohl-als-auch.

🔗 Quellen:

* [TypeScript Handbook – Intersection Types](https://www.typescriptlang.org/docs/handbook/2/objects.html#intersection-types)
* [React TS Cheatsheet – Utility Types & Intersections](https://react-typescript-cheatsheet.netlify.app/docs/advanced/types_react_api/)

  **[⬆ Наверх](#top)**

11. ### <a name="11"></a> Was sind Literal Types?

### Literal Types in TypeScript

**Definition:**
Ein **Literal Type** schränkt eine Variable auf einen **konkreten Wert** ein, anstatt nur auf den allgemeinen Typ (z. B. `string` oder `number`).
So kann man Variablen oder Parameter **nur bestimmte erlaubte Werte** zuweisen.

---

### Beispiel 1 – String-Literals

```js
let direction: "left" | "right"

direction = "left"   // ✅ erlaubt
direction = "right"  // ✅ erlaubt
direction = "up"     // ❌ Fehler
```

---

### Beispiel 2 – Number-Literals

```js
let diceRoll: 1 | 2 | 3 | 4 | 5 | 6

diceRoll = 3  // ✅ erlaubt
diceRoll = 7  // ❌ Fehler
```

---

### Beispiel 3 – In Kombination mit Unions

```js
type Status = "success" | "error" | "loading"

function handleStatus(status: Status): void {
  if (status === "success") {
    console.log("Alles gut ✅")
  } else if (status === "error") {
    console.log("Fehler ❌")
  } else {
    console.log("Lädt ⏳")
  }
}

handleStatus("success")
```

---

### Beispiel 4 – Literal Inferenz mit `const`

```js
const role = "admin"
// Typ ist "admin", nicht string
```

---

### Zusammenfassung

* **Literal Types** = feste, konkrete Werte als Typen.
* Nützlich für: erlaubte Werte (Enums-ähnlich), Statusangaben, Konstanten.
* Oft in Kombination mit **Union Types** genutzt.

🔗 Quellen:

* [TypeScript Handbook – Literal Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-types)
* [React TS Cheatsheet – Discriminated Unions](https://react-typescript-cheatsheet.netlify.app/docs/advanced/discriminated_unions/)

  **[⬆ Наверх](#top)**

12. ### <a name="12"></a> Wie funktioniert type inference in TypeScript?

### Type Inference in TypeScript

**Definition:**
**Type Inference (Typinferenz)** bedeutet, dass TypeScript den Typ einer Variable, Funktion oder eines Ausdrucks **automatisch ableitet**, wenn kein expliziter Typ angegeben wird.

---

### Regeln der Typinferenz

#### 1. **Variable-Zuweisung**

```js
let count = 10
// Typ wird automatisch als number erkannt
// count: number
```

---

#### 2. **Funktionsergebnisse**

```js
function add(a: number, b: number) {
  return a + b
}
// Rückgabetyp: number (wird automatisch erkannt)
```

---

#### 3. **Best Common Type**

Wenn verschiedene Typen in einem Array vorkommen, wählt TypeScript den "allgemeinsten" Typ.

```js
let values = [1, "zwei", 3]
// Typ: (string | number)[]
```

---

#### 4. **Contextual Typing**

Der Typ kann auch aus dem **Kontext** abgeleitet werden.

```js
window.addEventListener("click", (event) => {
  console.log(event.clientX) // event: MouseEvent
})
```

---

#### 5. **Default Inference für `any`**

Wenn keine Information vorliegt, wird `any` angenommen (außer bei `--noImplicitAny`).

```js
function log(value) {
  console.log(value)
}
// value: any
```

---

### Vorteile

* Weniger Schreibarbeit (man muss nicht überall Typen manuell angeben).
* Bessere Lesbarkeit.
* Trotzdem Typ-Sicherheit, solange genug Information vorhanden ist.

---

### Zusammenfassung

* **Type Inference** = automatische Typbestimmung durch TypeScript.
* Regeln: Variablenzuweisung, Funktionsrückgaben, Arrays (Best Common Type), Kontextabhängigkeit.
* Vorteil: weniger Code, aber trotzdem Typ-Sicherheit.

🔗 Quellen:

* [TypeScript Handbook – Type Inference](https://www.typescriptlang.org/docs/handbook/type-inference.html)
* [React TS Cheatsheet – Inference](https://react-typescript-cheatsheet.netlify.app/docs/basic/troubleshooting/types/#type-inference)

  **[⬆ Наверх](#top)**

13. ### <a name="13"></a> Was ist ein Type Alias (type) und wie unterscheidet er sich von interface?

### **Type Alias (`type`) in TypeScript**

**Definition:**
Ein **Type Alias** erstellt einen neuen Namen für einen bestehenden Typ.
Er kann primitive Typen, Union/Intersection Types, Funktionen oder komplexe Strukturen beschreiben.

```js
type UserID = string | number

type User = {
  id: UserID
  name: string
}
```

---

### **Interface in TypeScript**

**Definition:**
Ein **Interface** beschreibt die **Struktur eines Objekts** (Shape).
Es wird häufig für Klassen, Objekte und die Definition von Verträgen verwendet.

```js
interface User {
  id: number
  name: string
}
```

---

### **Hauptunterschiede**

| Aspekt                   | `type`                                                               | `interface`                                    |
| ------------------------ | -------------------------------------------------------------------- | ---------------------------------------------- |
| **Einsatz**              | Alias für jeden Typ (Primitives, Unions, Functions, Tuples, Objects) | Nur Objekte und Klassen-Strukturen             |
| **Erweiterung**          | Mit `&` (Intersection)                                               | Mit `extends`                                  |
| **Deklarations-Merging** | ❌ Nicht möglich                                                      | ✅ Mehrfachdeklarationen werden zusammengeführt |
| **Flexibilität**         | Sehr vielseitig                                                      | Speziell für objektorientierte Modelle         |

---

### **Beispiele für Unterschiede**

#### 1. Type für Union

```js
type Status = "success" | "error" | "loading"
```

Mit `interface` nicht möglich.

---

#### 2. Interface-Erweiterung

```js
interface Person {
  name: string
}

interface Employee extends Person {
  company: string
}
```

---

#### 3. Type-Erweiterung mit Intersection

```js
type Person = { name: string }
type Employee = Person & { company: string }
```

---

#### 4. Deklarations-Merging

```js
interface Window {
  title: string
}

interface Window {
  size: number
}

const w: Window = { title: "App", size: 800 }
// ✅ erlaubt, beide Interfaces verschmelzen
```

Mit `type` nicht möglich.

---

### Zusammenfassung

* **`type`** = Alias für beliebige Typen (Primitives, Union, Intersection, Functions, Tuples, Objekte).
* **`interface`** = Vertrag für Objekt- oder Klassen-Strukturen, unterstützt Deklarations-Merging.
* Empfehlung:

  * **Objektmodelle → `interface`**
  * **Komplexe Typ-Kombinationen → `type`**

🔗 Quellen:

* [TypeScript Handbook – Type Aliases](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-aliases)
* [TypeScript Handbook – Interfaces](https://www.typescriptlang.org/docs/handbook/2/objects.html)
* [React TS Cheatsheet – Types vs. Interfaces](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example#types-vs-interfaces)

  **[⬆ Наверх](#top)**

14. ### <a name="14"></a> Was ist der Unterschied zwischen interface und type?

### Unterschied zwischen `interface` und `type` in TypeScript

#### **1. Gemeinsamkeiten**

* Beide können Objekte beschreiben.
* Beide unterstützen Erweiterung und Wiederverwendung.
* Beide sind strukturell (nicht nominal) → entscheidend ist die Form, nicht der Name.

---

#### **2. Unterschiede**

| Aspekt                   | `interface`                                       | `type`                                                             |
| ------------------------ | ------------------------------------------------- | ------------------------------------------------------------------ |
| **Verwendungszweck**     | Hauptsächlich für Objekte und Klassen-Contracts   | Alias für jeden Typ (auch Primitives, Union, Tuple, Function etc.) |
| **Erweiterung**          | `extends`                                         | Intersection (`&`)                                                 |
| **Deklarations-Merging** | ✅ Ja (mehrfach definierbar, wird zusammengeführt) | ❌ Nein                                                             |
| **Flexibilität**         | Eingeschränkter (nur für Objekt-ähnliche Typen)   | Sehr flexibel, kann alles beschreiben                              |
| **Lesbarkeit**           | Oft bevorzugt für Props, Klassen, API-Schemas     | Bevorzugt für komplexe Typkombinationen, Union/Intersection        |

---

#### **3. Beispiele**

**Interface für Objekte**

```js
interface Person {
  name: string
  age: number
}

interface Employee extends Person {
  company: string
}

const dev: Employee = { name: "Sergii", age: 34, company: "Tech GmbH" }
```

**Type für komplexe Kombinationen**

```js
type Status = "success" | "error" | "loading"

type UserID = string | number

type Point = [number, number] // Tuple
```

**Deklarations-Merging (nur bei Interface)**

```js
interface Window {
  title: string
}

interface Window {
  size: number
}

const w: Window = { title: "App", size: 800 } // ✅ erlaubt
```

---

### Zusammenfassung

* **`interface`** = objektorientiert, erweiterbar (`extends`), unterstützt Deklarations-Merging.
* **`type`** = flexibler, geeignet für Unions, Primitives, Funktionen, Tuples.
* Empfehlung:

  * **Objekte/Klassen** → `interface`
  * **Union/Intersection/Primitives** → `type`

🔗 Quellen:

* [TypeScript Handbook – Interfaces](https://www.typescriptlang.org/docs/handbook/2/objects.html)
* [TypeScript Handbook – Type Aliases](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-aliases)
* [React TS Cheatsheet – Types vs Interfaces](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example#types-vs-interfaces)

  **[⬆ Наверх](#top)**

15. ### <a name="15"></a> Kann man Interfaces zusammenführen (extend)?

### Interfaces zusammenführen in TypeScript

Ja – **Interfaces** können auf zwei Arten zusammengeführt werden:

---

#### **1. Erweiterung mit `extends`**

Ein Interface kann ein anderes Interface erweitern.

```js
interface Person {
  name: string
}

interface Employee extends Person {
  company: string
}

const dev: Employee = {
  name: "Sergii",
  company: "Tech GmbH"
}
```

* `Employee` erbt alle Eigenschaften von `Person`.

---

#### **2. Deklarations-Merging**

Wenn mehrere **gleichnamige Interfaces** existieren, werden sie automatisch zusammengeführt.

```js
interface Window {
  title: string
}

interface Window {
  size: number
}

const w: Window = {
  title: "App",
  size: 1200
}
```

* TypeScript kombiniert beide Definitionen → Ergebnis ist ein Interface mit `title` **und** `size`.

---

#### Unterschied zu `type`

* `type` kann **nicht** gemerged werden.
* Nur `interface` unterstützt Deklarations-Merging.

---

### Zusammenfassung

* **Ja, Interfaces können zusammengeführt werden.**
* Zwei Wege:

  1. **`extends`** → Vererbung.
  2. **Deklarations-Merging** → mehrere gleiche Namen = automatisch kombiniert.
* Vorteil: Flexibel für API-Erweiterungen oder globale Typdefinitionen.

🔗 Quellen:

* [TypeScript Handbook – Interfaces](https://www.typescriptlang.org/docs/handbook/2/objects.html#extending-interfaces)
* [TypeScript Handbook – Declaration Merging](https://www.typescriptlang.org/docs/handbook/declaration-merging.html)

  **[⬆ Наверх](#top)**

16. ### <a name="16"></a> Was sind optionale Eigenschaften in Interfaces?

### Optionale Eigenschaften in Interfaces

**Definition:**
Optionale Eigenschaften in einem Interface sind Felder, die beim Erstellen eines Objekts **nicht zwingend angegeben** werden müssen.
Man markiert sie mit einem **Fragezeichen (`?`)** nach dem Eigenschaftsnamen.

---

### Beispiel 1 – Einfaches Interface mit optionalen Feldern

```js
interface User {
  id: number
  name: string
  age?: number // optional
}

const user1: User = { id: 1, name: "Sergii" }       // ✅ ohne age
const user2: User = { id: 2, name: "Anna", age: 30 } // ✅ mit age
```

---

### Beispiel 2 – Optional in Kombination mit Funktionen

```js
interface Config {
  url: string
  timeout?: number
}

function fetchData(config: Config) {
  console.log(`Hole Daten von ${config.url}`)
  if (config.timeout) {
    console.log(`Timeout: ${config.timeout}ms`)
  }
}

fetchData({ url: "/api" })
fetchData({ url: "/api", timeout: 5000 })
```

---

### Beispiel 3 – Unterschied zu `undefined`

Ein optionales Feld kann fehlen **oder explizit `undefined` sein**.

```js
interface Product {
  name: string
  price?: number
}

const p1: Product = { name: "Buch" }                 // kein price
const p2: Product = { name: "Buch", price: undefined } // explizit undefined
```

---

### Zusammenfassung

* **Optionale Eigenschaften** (`?`) = nicht verpflichtend in Objekten.
* Können weggelassen oder explizit auf `undefined` gesetzt werden.
* Nützlich für **Konfigurationsobjekte, optionale Props, flexible Datenstrukturen**.

🔗 Quellen:

* [TypeScript Handbook – Interfaces](https://www.typescriptlang.org/docs/handbook/2/objects.html#optional-properties)
* [React TS Cheatsheet – Optional Props](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example#optional-props)

  **[⬆ Наверх](#top)**

17. ### <a name="17"></a> Wie deklariert man readonly-Eigenschaften?

### `readonly` Eigenschaften in TypeScript

**Definition:**
Mit dem Schlüsselwort **`readonly`** kann man Eigenschaften in Interfaces, Types oder Klassen so deklarieren, dass sie **nach der Initialisierung nicht mehr verändert** werden dürfen.

---

### Beispiel 1 – Interface mit `readonly`

```js
interface User {
  readonly id: number
  name: string
}

const user: User = { id: 1, name: "Sergii" }

user.name = "Anna"   // ✅ erlaubt
user.id = 2          // ❌ Fehler: id ist readonly
```

---

### Beispiel 2 – Type mit `readonly`

```js
type Point = {
  readonly x: number
  readonly y: number
}

const p: Point = { x: 10, y: 20 }
p.x = 30 // ❌ Fehler
```

---

### Beispiel 3 – Klassen mit `readonly`

```js
class Person {
  readonly id: number
  name: string

  constructor(id: number, name: string) {
    this.id = id      // ✅ Initialisierung erlaubt
    this.name = name
  }
}

const dev = new Person(1, "Sergii")
dev.name = "Anna"   // ✅ erlaubt
dev.id = 2          // ❌ Fehler
```

---

### Beispiel 4 – Readonly Arrays

```js
const numbers: ReadonlyArray<number> = [1, 2, 3]

numbers.push(4) // ❌ Fehler: push ist nicht erlaubt
```

---

### Zusammenfassung

* **`readonly`** = Eigenschaft kann nur bei der Initialisierung gesetzt werden.
* Einsatz in: **Interfaces, Types, Klassen, Arrays**.
* Vorteil: bessere **Immutabilität** und Sicherheit vor unbeabsichtigten Änderungen.

🔗 Quellen:

* [TypeScript Handbook – readonly](https://www.typescriptlang.org/docs/handbook/2/objects.html#readonly-properties)
* [React TS Cheatsheet – readonly usage](https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase#readonly-and-const-assertions)

  **[⬆ Наверх](#top)**

18. ### <a name="18"></a> Was sind Tupel (tuples) in TypeScript?

### Tupel (Tuples) in TypeScript

**Definition:**
Ein **Tuple** ist ein spezielles Array mit **fester Länge** und **fest definierten Typen** an den jeweiligen Positionen.
→ Anders als bei Arrays kann jedes Element einen eigenen Typ haben, der an einer bestimmten Stelle erwartet wird.

---

### Beispiel 1 – Einfaches Tuple

```js
let user: [string, number]

user = ["Sergii", 34]   // ✅ korrekt
user = [34, "Sergii"]   // ❌ Fehler: Reihenfolge stimmt nicht
```

---

### Beispiel 2 – Tuple mit optionalem Element

```js
let point: [number, number, number?]

point = [10, 20]       // ✅ erlaubt
point = [10, 20, 30]   // ✅ erlaubt
```

---

### Beispiel 3 – Mit `readonly` (immutable Tuple)

```js
let coordinates: readonly [number, number] = [50, 100]

coordinates[0] = 10 // ❌ Fehler: readonly
```

---

### Beispiel 4 – Einsatz in Funktionen

```js
function useCoordinates(): [number, number] {
  return [10, 20]
}

const [x, y] = useCoordinates()
```

---

### Beispiel 5 – Variadische Tupel (seit TS 4.0)

```js
type Pair<T> = [T, T]
type Triple<T> = [T, T, T]

let pair: Pair<string> = ["a", "b"]
let triple: Triple<number> = [1, 2, 3]
```

---

### Zusammenfassung

* **Tuple** = Array mit **fester Länge** und **definierten Typen pro Index**.
* Nützlich für: Rückgabewerte von Funktionen, koordinatenartige Werte, kleine feste Strukturen.
* Erweiterungen: optionale Elemente, `readonly`, variadische Tupel.

🔗 Quellen:

* [TypeScript Handbook – Tuples](https://www.typescriptlang.org/docs/handbook/2/objects.html#tuple-types)
* [MDN – Arrays (als Grundlage)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array)

  **[⬆ Наверх](#top)**

19. ### <a name="19"></a> Was ist ein Enum und wann sollte man es verwenden?

### Enum in TypeScript

**Definition:**
Ein **Enum** (Aufzählungstyp) ist eine Sammlung von **benannten Konstanten**.
Es wird verwendet, um Wertegruppen besser lesbar und verständlich zu machen.

---

### Arten von Enums

#### 1. **Numerische Enums (Standard)**

```js
enum Direction {
  Up,    // 0
  Down,  // 1
  Left,  // 2
  Right  // 3
}

let move: Direction = Direction.Up
console.log(move) // 0
```

Man kann auch Startwerte vergeben:

```js
enum Status {
  Success = 1,
  Error = 2,
  Loading = 3
}
```

---

#### 2. **String Enums**

```js
enum Role {
  Admin = "ADMIN",
  User = "USER",
  Guest = "GUEST"
}

let current: Role = Role.Admin
```

---

#### 3. **Const Enums (Kompilierungsoptimierung)**

```js
const enum LogLevel {
  Info,
  Warning,
  Error
}

let level: LogLevel = LogLevel.Error
```

👉 Vorteile: wird zu einfachen Konstanten kompiliert → bessere Performance.

---

### Wann verwenden?

✅ **Geeignet für:**

* Feste, klar definierte Wertegruppen (z. B. Rollen, Status, Richtungen).
* Lesbarkeit: statt `"ADMIN"` oder `1` → `Role.Admin`.
* Weniger Tippfehler durch Autovervollständigung.

⚠️ **Alternativen:**

* **Union Types** mit Literal-Typen sind oft schlanker und flexibler.

  ```js
  type Role = "ADMIN" | "USER" | "GUEST"
  ```
* Empfehlung: In modernen Projekten werden häufig **Union Types** anstelle von Enums bevorzugt, da sie besser mit TypeScript-Features wie Narrowing und Type Inference harmonieren.

---

### Zusammenfassung

* **Enum** = Sammlung von benannten Konstanten (numeric, string, const).
* Vorteile: bessere Lesbarkeit, Fehlervermeidung, klare Struktur.
* Verwendung: feste Wertemengen (Status, Rollen, Richtungen).
* Alternative: **Union Types** → oft moderner und einfacher.

🔗 Quellen:

* [TypeScript Handbook – Enums](https://www.typescriptlang.org/docs/handbook/enums.html)
* [React TS Cheatsheet – Union vs Enums](https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase#enums-vs-union-types)

  **[⬆ Наверх](#top)**

20. ### <a name="20"></a> Was ist der Unterschied zwischen const enum und einem normalen enum?

### Unterschied zwischen `enum` und `const enum` in TypeScript

#### **1. Normales `enum`**

* Wird zur **Laufzeit** in JavaScript-Code kompiliert.
* TypeScript erzeugt ein **Objekt** mit Schlüssel/Wert-Zuordnung.
* Bidirektionale Abbildung: man kann von Namen auf Wert und umgekehrt zugreifen.

```js
enum Direction {
  Up,
  Down,
  Left,
  Right
}

console.log(Direction.Up)    // 0
console.log(Direction[0])    // "Up"
```

➡️ Nach der Kompilierung entsteht ein JS-Objekt:

```js
var Direction;
(function (Direction) {
    Direction[Direction["Up"] = 0] = "Up";
    Direction[Direction["Down"] = 1] = "Down";
    Direction[Direction["Left"] = 2] = "Left";
    Direction[Direction["Right"] = 3] = "Right";
})(Direction || (Direction = {}));
```

---

#### **2. `const enum`**

* Wird **zur Compile-Zeit** durch seine Werte ersetzt.
* Kein Objekt im generierten JavaScript.
* Spart Code und verbessert Performance.

```js
const enum Direction {
  Up,
  Down,
  Left,
  Right
}

let move = Direction.Up
console.log(move) // 0
```

➡️ Nach der Kompilierung:

```js
let move = 0 /* Up */
```

* Kein `Direction`-Objekt vorhanden → keine bidirektionale Abbildung möglich.

---

#### **3. Vergleich**

| Aspekt              | `enum`                                      | `const enum`                     |
| ------------------- | ------------------------------------------- | -------------------------------- |
| **Kompilierung**    | JS-Objekt wird erzeugt                      | Ersetzt durch Werte, kein Objekt |
| **Performance**     | Mehr Overhead                               | Weniger Overhead                 |
| **Reverse Mapping** | ✅ möglich (`Direction[0] → "Up"`)           | ❌ nicht möglich                  |
| **Codegröße**       | Größer                                      | Kleiner                          |
| **Verwendung**      | Wenn bidirektionales Mapping gebraucht wird | Für reine Konstantenwerte        |

---

### Zusammenfassung

* **`enum`**: erzeugt ein JavaScript-Objekt → erlaubt Zugriff in beide Richtungen, größerer Output.
* **`const enum`**: wird während der Kompilierung inline ersetzt → effizienter, aber ohne Reverse Mapping.

🔗 Quellen:

* [TypeScript Handbook – Enums](https://www.typescriptlang.org/docs/handbook/enums.html#const-enums)
* [React TS Cheatsheet – Enums](https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase#enums-vs-union-types)

  **[⬆ Наверх](#top)**

21. ### <a name="21"></a> Was ist Type Narrowing (Typschränkung)?

### Type Narrowing (Typschränkung) in TypeScript

**Definition:**
**Type Narrowing** bedeutet, dass TypeScript den Typ einer Variable während des Codes **einschränkt** (von einem breiteren Union-Typ auf einen spezifischeren Typ), basierend auf **Kontrollstrukturen oder Type Guards**.

---

### Beispiel 1 – `typeof` Narrowing

```js
function printId(id: string | number) {
  if (typeof id === "string") {
    console.log(id.toUpperCase()) // id: string
  } else {
    console.log(id.toFixed(2))    // id: number
  }
}
```

---

### Beispiel 2 – `instanceof` Narrowing

```js
class Dog {
  bark() { console.log("Wuff!") }
}
class Cat {
  meow() { console.log("Miau!") }
}

function makeSound(animal: Dog | Cat) {
  if (animal instanceof Dog) {
    animal.bark() // animal: Dog
  } else {
    animal.meow() // animal: Cat
  }
}
```

---

### Beispiel 3 – Property Check (`in` Operator)

```js
type Fish = { swim: () => void }
type Bird = { fly: () => void }

function move(animal: Fish | Bird) {
  if ("swim" in animal) {
    animal.swim() // Typ: Fish
  } else {
    animal.fly()  // Typ: Bird
  }
}
```

---

### Beispiel 4 – Gleichheitsprüfung (Literal Narrowing)

```js
type Status = "success" | "error" | "loading"

function handleStatus(status: Status) {
  if (status === "success") {
    console.log("Alles gut ✅")
  }
}
```

---

### Beispiel 5 – Exhaustive Check mit `never`

```js
type Shape = { kind: "circle"; radius: number } 
           | { kind: "square"; side: number }

function area(shape: Shape): number {
  switch (shape.kind) {
    case "circle": return Math.PI * shape.radius ** 2
    case "square": return shape.side * shape.side
    default:
      const exhaustive: never = shape // Fehler, falls ein neuer Typ fehlt
      return exhaustive
  }
}
```

---

### Zusammenfassung

* **Type Narrowing** = Einschränkung von Union-Typen auf spezifische Typen.
* Methoden: `typeof`, `instanceof`, `in`, Gleichheitsprüfungen, Kontrollfluss.
* Vorteil: bessere Typ-Sicherheit, weniger Fehler, klarer Code.

🔗 Quellen:

* [TypeScript Handbook – Narrowing](https://www.typescriptlang.org/docs/handbook/2/narrowing.html)
* [React TS Cheatsheet – Type Narrowing](https://react-typescript-cheatsheet.netlify.app/docs/basic/troubleshooting/types/#type-narrowing)

  **[⬆ Наверх](#top)**

22. ### <a name="22"></a> 



  **[⬆ Наверх](#top)**

23. ### <a name="23"></a> 



  **[⬆ Наверх](#top)**

24. ### <a name="24"></a> 



  **[⬆ Наверх](#top)**

25. ### <a name="25"></a> 



  **[⬆ Наверх](#top)**

26. ### <a name="26"></a> 



  **[⬆ Наверх](#top)**

27. ### <a name="27"></a> 



  **[⬆ Наверх](#top)**

28. ### <a name="28"></a> 



  **[⬆ Наверх](#top)**

29. ### <a name="29"></a> 



  **[⬆ Наверх](#top)**

30. ### <a name="30"></a> 



  **[⬆ Наверх](#top)**  

31. ### <a name="31"></a> 



  **[⬆ Наверх](#top)**

32. ### <a name="32"></a> 



  **[⬆ Наверх](#top)**

33. ### <a name="33"></a> 



  **[⬆ Наверх](#top)**

34. ### <a name="34"></a> 



  **[⬆ Наверх](#top)**

35. ### <a name="35"></a> 



  **[⬆ Наверх](#top)**

36. ### <a name="36"></a> 



  **[⬆ Наверх](#top)**

37. ### <a name="37"></a> 



  **[⬆ Наверх](#top)**

38. ### <a name="38"></a> 



  **[⬆ Наверх](#top)**

39. ### <a name="39"></a> 



  **[⬆ Наверх](#top)**

40. ### <a name="40"></a> 



  **[⬆ Наверх](#top)**  

41. ### <a name="41"></a> 



  **[⬆ Наверх](#top)**

42. ### <a name="42"></a> 



  **[⬆ Наверх](#top)**

43. ### <a name="43"></a> 



  **[⬆ Наверх](#top)**

44. ### <a name="44"></a> 



  **[⬆ Наверх](#top)**

45. ### <a name="45"></a> 



  **[⬆ Наверх](#top)**

46. ### <a name="46"></a> 



  **[⬆ Наверх](#top)**

47. ### <a name="47"></a> 



  **[⬆ Наверх](#top)**

48. ### <a name="48"></a> 



  **[⬆ Наверх](#top)**

49. ### <a name="49"></a> 



  **[⬆ Наверх](#top)**

50. ### <a name="50"></a> 



  **[⬆ Наверх](#top)**  

51. ### <a name="51"></a> 



  **[⬆ Наверх](#top)**

52. ### <a name="52"></a> 



  **[⬆ Наверх](#top)**

53. ### <a name="53"></a> 



  **[⬆ Наверх](#top)**

54. ### <a name="54"></a> 



  **[⬆ Наверх](#top)**

55. ### <a name="55"></a> 



  **[⬆ Наверх](#top)**

56. ### <a name="56"></a> 



  **[⬆ Наверх](#top)**

57. ### <a name="57"></a> 



  **[⬆ Наверх](#top)**

58. ### <a name="58"></a> 



  **[⬆ Наверх](#top)**

59. ### <a name="59"></a> 



  **[⬆ Наверх](#top)**

60. ### <a name="60"></a> 



  **[⬆ Наверх](#top)**

61. ### <a name="61"></a> 



  **[⬆ Наверх](#top)**

62. ### <a name="62"></a> 



  **[⬆ Наверх](#top)**

63. ### <a name="63"></a> 



  **[⬆ Наверх](#top)**

64. ### <a name="64"></a> 



  **[⬆ Наверх](#top)**

65. ### <a name="65"></a> 



  **[⬆ Наверх](#top)**

66. ### <a name="66"></a> 



  **[⬆ Наверх](#top)**

67. ### <a name="67"></a> 



  **[⬆ Наверх](#top)**

68. ### <a name="68"></a> 



  **[⬆ Наверх](#top)**

69. ### <a name="69"></a> 



  **[⬆ Наверх](#top)**

70. ### <a name="70"></a> 



  **[⬆ Наверх](#top)**

71. ### <a name="71"></a> 



  **[⬆ Наверх](#top)**

72. ### <a name="72"></a> 



  **[⬆ Наверх](#top)**

73. ### <a name="73"></a> 



  **[⬆ Наверх](#top)**

74. ### <a name="74"></a> 



  **[⬆ Наверх](#top)**

75. ### <a name="75"></a> 



  **[⬆ Наверх](#top)**

76. ### <a name="76"></a> 



  **[⬆ Наверх](#top)**

77. ### <a name="77"></a> 



  **[⬆ Наверх](#top)**

78. ### <a name="78"></a> 



  **[⬆ Наверх](#top)**

79. ### <a name="79"></a> 



  **[⬆ Наверх](#top)**

80. ### <a name="80"></a> 



  **[⬆ Наверх](#top)**  

81. ### <a name="81"></a> 



  **[⬆ Наверх](#top)**

82. ### <a name="82"></a> 



  **[⬆ Наверх](#top)**

83. ### <a name="83"></a> 



  **[⬆ Наверх](#top)**

84. ### <a name="84"></a> 



  **[⬆ Наверх](#top)**

85. ### <a name="85"></a> 



  **[⬆ Наверх](#top)**

86. ### <a name="86"></a> 



  **[⬆ Наверх](#top)**

87. ### <a name="87"></a> 



  **[⬆ Наверх](#top)**

88. ### <a name="88"></a> 



  **[⬆ Наверх](#top)**

89. ### <a name="89"></a> 



  **[⬆ Наверх](#top)**

90. ### <a name="90"></a> 



  **[⬆ Наверх](#top)**  

91. ### <a name="91"></a> 



  **[⬆ Наверх](#top)**

92. ### <a name="92"></a> 



  **[⬆ Наверх](#top)**

93. ### <a name="93"></a> 



  **[⬆ Наверх](#top)**

94. ### <a name="94"></a> 



  **[⬆ Наверх](#top)**

95. ### <a name="95"></a> 



  **[⬆ Наверх](#top)**

96. ### <a name="96"></a> 



  **[⬆ Наверх](#top)**

97. ### <a name="97"></a> 



  **[⬆ Наверх](#top)**

98. ### <a name="98"></a> 



  **[⬆ Наверх](#top)**

99. ### <a name="99"></a> 



  **[⬆ Наверх](#top)**

100. ### <a name="100"></a> 



  **[⬆ Наверх](#top)**    

101. ### <a name="101"></a> 



  **[⬆ Наверх](#top)**

102. ### <a name="102"></a> 



  **[⬆ Наверх](#top)**

103. ### <a name="103"></a> 



  **[⬆ Наверх](#top)**

104. ### <a name="104"></a> 



  **[⬆ Наверх](#top)**

105. ### <a name="105"></a> 



  **[⬆ Наверх](#top)**

106. ### <a name="106"></a> 



  **[⬆ Наверх](#top)**

107. ### <a name="107"></a> 



  **[⬆ Наверх](#top)**

108. ### <a name="108"></a> 



  **[⬆ Наверх](#top)**

109. ### <a name="109"></a> 



  **[⬆ Наверх](#top)**

110. ### <a name="110"></a> 



  **[⬆ Наверх](#top)**

111. ### <a name="111"></a> 



  **[⬆ Наверх](#top)**

112. ### <a name="112"></a> 



  **[⬆ Наверх](#top)**

113. ### <a name="113"></a> 



  **[⬆ Наверх](#top)**

114. ### <a name="114"></a> 



  **[⬆ Наверх](#top)**

115. ### <a name="115"></a> 



  **[⬆ Наверх](#top)**

116. ### <a name="116"></a> 



  **[⬆ Наверх](#top)**

117. ### <a name="117"></a> 



  **[⬆ Наверх](#top)**

118. ### <a name="118"></a> 



  **[⬆ Наверх](#top)**

119. ### <a name="119"></a> 



  **[⬆ Наверх](#top)**

120. ### <a name="120"></a> 



  **[⬆ Наверх](#top)**

121. ### <a name="121"></a> 



  **[⬆ Наверх](#top)**

122. ### <a name="122"></a> 



  **[⬆ Наверх](#top)**

123. ### <a name="123"></a> 



  **[⬆ Наверх](#top)**

124. ### <a name="124"></a> 



  **[⬆ Наверх](#top)**

125. ### <a name="125"></a> 



  **[⬆ Наверх](#top)**

126. ### <a name="126"></a> 



  **[⬆ Наверх](#top)**

127. ### <a name="127"></a> 



  **[⬆ Наверх](#top)**

128. ### <a name="128"></a> 



  **[⬆ Наверх](#top)**

129. ### <a name="129"></a> 



  **[⬆ Наверх](#top)**

130. ### <a name="130"></a> 



  **[⬆ Наверх](#top)**  

131. ### <a name="131"></a> 



  **[⬆ Наверх](#top)**

132. ### <a name="132"></a> 



  **[⬆ Наверх](#top)**

133. ### <a name="133"></a> 



  **[⬆ Наверх](#top)**

134. ### <a name="134"></a> 



  **[⬆ Наверх](#top)**

135. ### <a name="135"></a> 



  **[⬆ Наверх](#top)**

136. ### <a name="136"></a> 



  **[⬆ Наверх](#top)**

137. ### <a name="137"></a> 



  **[⬆ Наверх](#top)**

138. ### <a name="138"></a> 



  **[⬆ Наверх](#top)**

139. ### <a name="139"></a> 



  **[⬆ Наверх](#top)**

140. ### <a name="140"></a> 



  **[⬆ Наверх](#top)**  

141. ### <a name="141"></a> 



  **[⬆ Наверх](#top)**

142. ### <a name="142"></a> 



  **[⬆ Наверх](#top)**

143. ### <a name="143"></a> 



  **[⬆ Наверх](#top)**

144. ### <a name="144"></a> 



  **[⬆ Наверх](#top)**

145. ### <a name="145"></a> 



  **[⬆ Наверх](#top)**

146. ### <a name="146"></a> 



  **[⬆ Наверх](#top)**

147. ### <a name="147"></a> 



  **[⬆ Наверх](#top)**

148. ### <a name="148"></a> 



  **[⬆ Наверх](#top)**

149. ### <a name="149"></a> 



  **[⬆ Наверх](#top)**

150. ### <a name="150"></a> 



  **[⬆ Наверх](#top)**  

151. ### <a name="151"></a> 



  **[⬆ Наверх](#top)**

152. ### <a name="152"></a> 



  **[⬆ Наверх](#top)**

153. ### <a name="153"></a> 



  **[⬆ Наверх](#top)**

154. ### <a name="154"></a> 



  **[⬆ Наверх](#top)**

155. ### <a name="155"></a> 



  **[⬆ Наверх](#top)**

156. ### <a name="156"></a> 



  **[⬆ Наверх](#top)**

157. ### <a name="157"></a> 



  **[⬆ Наверх](#top)**

158. ### <a name="158"></a> 



  **[⬆ Наверх](#top)**

159. ### <a name="159"></a> 



  **[⬆ Наверх](#top)**

160. ### <a name="160"></a> 



  **[⬆ Наверх](#top)**

161. ### <a name="161"></a> 



  **[⬆ Наверх](#top)**

162. ### <a name="162"></a> 



  **[⬆ Наверх](#top)**

163. ### <a name="163"></a> 



  **[⬆ Наверх](#top)**

164. ### <a name="164"></a> 



  **[⬆ Наверх](#top)**

165. ### <a name="165"></a> 



  **[⬆ Наверх](#top)**

166. ### <a name="166"></a> 



  **[⬆ Наверх](#top)**

167. ### <a name="167"></a> 



  **[⬆ Наверх](#top)**

168. ### <a name="168"></a> 



  **[⬆ Наверх](#top)**

169. ### <a name="169"></a> 



  **[⬆ Наверх](#top)**

170. ### <a name="170"></a> 



  **[⬆ Наверх](#top)**

171. ### <a name="171"></a> 



  **[⬆ Наверх](#top)**

172. ### <a name="172"></a> 



  **[⬆ Наверх](#top)**

173. ### <a name="173"></a> 



  **[⬆ Наверх](#top)**

174. ### <a name="174"></a> 



  **[⬆ Наверх](#top)**

175. ### <a name="175"></a> 



  **[⬆ Наверх](#top)**

176. ### <a name="176"></a> 



  **[⬆ Наверх](#top)**

177. ### <a name="177"></a> 



  **[⬆ Наверх](#top)**

178. ### <a name="178"></a> 



  **[⬆ Наверх](#top)**

179. ### <a name="179"></a> 



  **[⬆ Наверх](#top)**

180. ### <a name="180"></a> 



  **[⬆ Наверх](#top)**  

181. ### <a name="181"></a> 



  **[⬆ Наверх](#top)**

182. ### <a name="182"></a> 



  **[⬆ Наверх](#top)**

183. ### <a name="183"></a> 



  **[⬆ Наверх](#top)**

184. ### <a name="184"></a> 



  **[⬆ Наверх](#top)**

185. ### <a name="185"></a> 



  **[⬆ Наверх](#top)**

186. ### <a name="186"></a> 



  **[⬆ Наверх](#top)**

187. ### <a name="187"></a> 



  **[⬆ Наверх](#top)**

188. ### <a name="188"></a> 



  **[⬆ Наверх](#top)**

189. ### <a name="189"></a> 



  **[⬆ Наверх](#top)**

190. ### <a name="190"></a> 



  **[⬆ Наверх](#top)**  

191. ### <a name="191"></a> 



  **[⬆ Наверх](#top)**

192. ### <a name="192"></a> 



  **[⬆ Наверх](#top)**

193. ### <a name="193"></a> 



  **[⬆ Наверх](#top)**

194. ### <a name="194"></a> 



  **[⬆ Наверх](#top)**

195. ### <a name="195"></a> 



  **[⬆ Наверх](#top)**

196. ### <a name="196"></a> 



  **[⬆ Наверх](#top)**

197. ### <a name="197"></a> 



  **[⬆ Наверх](#top)**

198. ### <a name="198"></a> 



  **[⬆ Наверх](#top)**

199. ### <a name="199"></a> 



  **[⬆ Наверх](#top)**

200. ### <a name="200"></a> 



  **[⬆ Наверх](#top)**      
