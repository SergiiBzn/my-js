<a name="top"></a>

[На главную](../README.md)

[Перейти к вопросам](#questions)

| №. | Вопрос |
| --- | --------- |
|   | TypeScript — Grundlagen |
|1 | [Was ist TypeScript und wie unterscheidet es sich von JavaScript?](#1) |
|2 | [Welche Vorteile bietet die Verwendung von TypeScript?](#2) |
|3 | [Was ist Typisierung (static typing)?](#3) |
|4 | [Welche grundlegenden Typen gibt es in TypeScript?](#4) |
|5 | [Worin besteht der Unterschied zwischen any und unknown?](#5) |
|6 | [Was ist never und wann wird es verwendet?](#6) |
|7 | [Was ist der Unterschied zwischen null und undefined?](#7) |
|8 | [Was ist void?](#8) |
|9 | [Was sind Union Types? Gib ein Beispiel.](#9) |
|10 | [Was sind Intersection Types? Gib ein Beispiel.](#10) |
|11 | [Was sind Literal Types?](#11) |
|12 | [Wie funktioniert type inference in TypeScript?](#12) |
|13 | [Was ist ein Type Alias (type) und wie unterscheidet er sich von interface?](#13) |
|14 | [Was ist der Unterschied zwischen interface und type?](#14) |
|15 | [Kann man Interfaces zusammenführen (extend)?](#15) |
|16 | [Was sind optionale Eigenschaften in Interfaces?](#16) |
|17 | [Wie deklariert man readonly-Eigenschaften?](#17) |
|18 | [Was sind Tupel (tuples) in TypeScript?](#18) |
|19 | [Was ist ein Enum und wann sollte man es verwenden?](#19) |
|20 | [Was ist der Unterschied zwischen const enum und einem normalen enum?](#20) |
|21 | [Was ist Type Narrowing (Typschränkung)?](#21) |
|22 | [Was sind Type Guards? Gib ein Beispiel.](#22) |
|23 | [Wie funktioniert der Operator in bei der Typprüfung?](#23) |
|24 | [Wie funktioniert typeof in TypeScript?](#24) |
|25 | [Wie funktioniert instanceof?](#25) |
|26 | [Was sind Discriminated Unions (diskriminierte Typen)?](#26) |
|27 | [Was ist der Unterschied zwischen interface und abstract class?](#27) |
|28 | [Wie implementiert man Funktionsüberladungen (function overloads) in TypeScript?](#28) |
|29 | [Was sind Index Signatures?](#29) |
|30 | [Was ist keyof und wofür wird es verwendet?](#30) |
|31 | [Wie funktioniert der Operator as?](#31) |
|32 | [Was ist der Unterschied zwischen as const und einem normalen const?](#32) |
|33 | [Was macht der Operator satisfies (TS 4.9+)?](#33) |
|34 | [Was sind Assertion Functions?](#34) |
|35 | [Was ist der Unterschied zwischen struktureller Typisierung (structural typing) und nominaler Typisierung (nominal typing)?](#35) |
|36 | [Was sind Deklarationsdateien (.d.ts)?](#36) |
|37 | [Wie bindet man eine externe JS-Bibliothek ohne Typen ein?](#37) |
|38 | [Was sind Ambient Declarations (declare)?](#38) |
|39 | [Was ist strict mode in TypeScript?](#39) |
|40 | [Wozu dient strictNullChecks?](#40) |
|   | TypeScript — Funktionen und Generics |
|41 | [Wie typisiert man Parameter und Rückgabewerte von Funktionen?](#41) |
|42 | [Was sind optionale Parameter in Funktionen?](#42) |
|43 | [Wie deklariert man Standardwerte für Parameter mit Typisierung?](#43) |
|44 | [Was sind Rest-Parameter und wie typisiert man sie?](#44) |
|45 | [Wie typisiert man Arrow Functions?](#45) |
|46 | [Was sind Funktionsüberladungen?](#46) |
|47 | [Was sind Generics?](#47) |
|48 | [Wie erstellt man eine generische Funktion?](#48) |
|49 | [Was sind Generic Constraints (extends)?](#49) |
|50 | [Wie funktioniert T extends keyof U?](#50) |
|51 | [Was sind Utility Types (Partial, Pick, Omit, Record usw.)?](#51) |
|52 | [Was ist der Unterschied zwischen Partial<T> und Required<T>?](#52) |
|53 | [Wie funktioniert Readonly<T>?](#53) |
|54 | [Wie funktionieren Pick<T, K> und Omit<T, K>?](#54) |
|55 | [Was macht Record<K, T>?](#55) |
|56 | [Was macht ReturnType<T>?](#56) |
|57 | [Was macht Parameters<T>?](#57) |
|58 | [Was macht ConstructorParameters<T>?](#58) |
|59 | [Wie funktionieren Extract und Exclude?](#59) |
|60 | [Was macht NonNullable<T>?](#60) |
|   | TypeScript — Klassen und OOP |
|61 | [Wie deklariert man eine Klasse in TypeScript?](#61) |
|62 | [Was sind Zugriffsmodifikatoren (public, private, protected)?](#62) |
|63 | [Was sind readonly-Eigenschaften in Klassen?](#63) |
|64 | [Wie deklariert man statische Eigenschaften und Methoden?](#64) |
|65 | [Was ist der Unterschied zwischen einer abstrakten und einer normalen Klasse?](#65) |
|66 | [Kann man Interfaces mit Klassen implementieren?](#66) |
|67 | [Was ist der Unterschied zwischen implements und extends?](#67) |
|68 | [Was ist this und wie typisiert man es?](#68) |
|69 | [Kann man generische Klassen erstellen?](#69) |
|   | React + TypeScript — Grundlagen |
|70 | [Wie erstellt man ein React-Projekt mit TypeScript?](#70) |
|71 | [Wie typisiert man eine React-Komponente (FC)?](#71) |
|72 | [Was ist React.FC und wann sollte man es vermeiden?](#72) |
|73 | [Wie typisiert man Props in einer React-Komponente?](#73) |
|74 | [Wie typisiert man optionale Props?](#74) |
|75 | [Wie deklariert man Default Props in TypeScript?](#75) |
|76 | [Wie typisiert man children in React-Komponenten?](#76) |
|77 | [Was ist der Unterschied zwischen ReactNode, JSX.Element und ReactElement?](#77) |
|78 | [Wie typisiert man Events (z. B. onClick, onChange)?](#78) |
|79 | [Wie typisiert man Refs in React?](#79) |
|80 | [Wie typisiert man State mit useState?](#80) |
|81 | [Wie typisiert man useReducer?](#81) |
|82 | [Wie typisiert man useRef mit initial null?](#82) |
|83 | [Wie typisiert man einen Custom Hook?](#83) |
|84 | [Wie typisiert man Komponenten mit forwardRef?](#84) |
|85 | [Wie typisiert man Context (React Context API)?](#85) |
|86 | [Wie typisiert man HOCs (Higher-Order Components)?](#86) |
|87 | [Wie typisiert man asynchrone Funktionen in React-Komponenten?](#87) |
|88 | [Wie typisiert man Event-Handler in Formularen?](#88) |
|89 | [Wie typisiert man API-Requests und Responses?](#89) |
|90 | [Wie typisiert man React-Router-Komponenten?](#90) |
|   | React + TypeScript — Praxis und Architektur |
|91 | [Wie organisiert man Typen für ein gesamtes Projekt?](#91) |
|92 | [Wo speichert man gemeinsame Typen (z. B. User, Product)?](#92) |
|93 | [Wie typisiert man den globalen Store (Redux/RTK)?](#93) |
|94 | [Wie typisiert man Actions und Reducer im Redux Toolkit?](#94) |
|95 | [Wie typisiert man useSelector und useDispatch?](#95) |
|96 | [Wie typisiert man einen Zustand-Store (Zustand)?](#96) |
|97 | [Wie typisiert man Async Thunks?](#97) |
|98 | [Wie typisiert man Query Hooks in RTK Query?](#98) |
|99 | [Wie verwendet man Enums für Redux-Actions?](#99) |
|100 | [Wie typisiert man Formulare mit React Hook Form?](#100) |
|101 | [Wie typisiert man axios-Requests?](#101) |
|102 | [Wie typisiert man fetch-Requests mit Generics?](#102) |
|103 | [Wie geht man mit Typen bei API-Fehlern um?](#103) |
|104 | [Wie verwendet man Utility Types für API-Modelle?](#104) |
|105 | [Wie typisiert man Dynamic Imports in React?](#105) |
|106 | [Wie verwendet man keyof für dynamische Eigenschaften in Komponenten?](#106) |
|107 | [Wie erstellt man typsichere Styles (z. B. mit styled-components)?](#107) |
|108 | [Wie typisiert man Props für Bibliothekskomponenten (z. B. Material UI)?](#108) |
|109 | [Wie typisiert man React.memo?](#109) |
|110 | [Wie typisiert man React.lazy und Suspense?](#110) |
|   | Fragen auf Middle-Level |
|111 | [Wie verwendet man Conditional Types (T extends U ? X : Y)?](#111) |
|112 | [Was sind Mapped Types?](#112) |
|113 | [Wie funktionieren Template Literal Types?](#113) |
|114 | [Was ist infer?](#114) |
|115 | [Wie schreibt man eigene Utility Types?](#115) |
|116 | [Wie kombiniert man mehrere Generics?](#116) |
|117 | [Was sind polymorphe Komponenten in React?](#117) |
|118 | [Wie erstellt man eine generische React-Komponente?](#118) |
|119 | [Wie verbindet man Generics in Props und State?](#119) |
|120 | [Wie stellt man vollständige Typsicherheit bei der Arbeit mit APIs sicher?](#120) |
|121 | [](#121) |
|122 | [](#122) |
|123 | [](#123) |
|124 | [](#124) |
|125 | [](#125) |
|126 | [](#126) |
|127 | [](#127) |
|128 | [](#128) |
|129 | [](#129) |
|130 | [](#130) |
|131 | [](#131) |
|132 | [](#132) |
|133 | [](#133) |
|134 | [](#134) |
|135 | [](#135) |
|136 | [](#136) |
|137 | [](#137) |
|138 | [](#138) |
|139 | [](#139) |
|140 | [](#140) |
|141 | [](#141) |
|142 | [](#142) |
|143 | [](#143) |
|144 | [](#144) |
|145 | [](#145) |
|146 | [](#146) |
|147 | [](#147) |
|148 | [](#148) |
|149 | [](#149) |
|150 | [](#150) |
|151 | [](#151) |
|152 | [](#152) |
|153 | [](#153) |
|154 | [](#154) |
|155 | [](#155) |
|156 | [](#156) |
|157 | [](#157) |
|158 | [](#158) |
|159 | [](#159) |
|160 | [](#160) |
|161 | [](#161) |
|162 | [](#162) |
|163 | [](#163) |
|164 | [](#164) |
|165 | [](#165) |
|166 | [](#166) |
|167 | [](#167) |
|168 | [](#168) |
|169 | [](#169) |
|170 | [](#170) |
|171 | [](#171) |
|172 | [](#172) |
|173 | [](#173) |
|174 | [](#174) |
|175 | [](#175) |
|176 | [](#176) |
|177 | [](#177) |
|178 | [](#178) |
|179 | [](#179) |
|180 | [](#180) |
|181 | [](#181) |
|182 | [](#182) |
|183 | [](#183) |
|184 | [](#184) |
|185 | [](#185) |
|186 | [](#186) |
|187 | [](#187) |
|188 | [](#188) |
|189 | [](#189) |
|190 | [](#190) |
|191 | [](#191) |
|192 | [](#192) |
|193 | [](#193) |
|194 | [](#194) |
|195 | [](#195) |
|196 | [](#196) |
|197 | [](#197) |
|198 | [](#198) |
|199 | [](#199) |
|200 | [](#200) |



<a name="questions"></a>

## ReactJS 

  **[⬆ Наверх](#top)**
  
1. ### <a name="1"></a> Was ist TypeScript und wie unterscheidet es sich von JavaScript?

**TypeScript** ist eine von Microsoft entwickelte Programmiersprache, die auf **JavaScript** basiert und dieses um **statische Typisierung** erweitert. Jeder gültige JavaScript-Code ist auch gültiger TypeScript-Code.

### Hauptunterschiede zu JavaScript

1. **Statische Typisierung**

   * In JavaScript sind Variablen dynamisch typisiert.
   * In TypeScript kann man Typen explizit angeben, was Fehler schon während der Entwicklung verhindert.

   ```js
   // JavaScript (dynamisch, Fehler erst zur Laufzeit möglich)
   let name = "Sergii"
   name = 42 // kein Fehler beim Schreiben, nur Laufzeitproblem

   // TypeScript (statisch, Fehler beim Kompilieren)
   let name: string = "Sergii"
   name = 42 // ❌ Fehler: Type 'number' is not assignable to type 'string'
   ```

2. **Typinferenz**

   * TypeScript erkennt oft automatisch den Typ einer Variable.

   ```js
   let age = 33 // Typ: number (automatisch erkannt)
   ```

3. **Erweiterte Features**

   * Interfaces, Enums, Generics, Union- und Intersection-Types, Utility-Types.

   ```js
   interface User {
     id: number
     name: string
   }

   const user: User = { id: 1, name: "Sergii" }
   ```

4. **Kompilierung**

   * TypeScript wird in **JavaScript** transpiliert (mittels `tsc` oder Bundler wie Vite/Webpack).
   * Läuft nicht direkt im Browser, sondern wird vorher in JavaScript konvertiert.

5. **Entwicklerfreundlichkeit**

   * Bessere **IntelliSense**, Autovervollständigung und Fehlererkennung in IDEs.

---

### Zusammenfassung

* **JavaScript**: dynamisch typisiert, direkt im Browser lauffähig.
* **TypeScript**: superset von JavaScript mit **statischer Typisierung** und zusätzlichen Features; erfordert Transpilation.
* Vorteil: Weniger Laufzeitfehler, besserer Code-Support.

🔗 Quellen:

* [TypeScript: What is TypeScript?](https://www.typescriptlang.org/docs/handbook/intro.html)
* [React TypeScript Cheatsheet: Setup](https://react-typescript-cheatsheet.netlify.app/docs/basic/setup)

  **[⬆ Наверх](#top)**

2. ### <a name="2"></a> Welche Vorteile bietet die Verwendung von TypeScript?

### Vorteile von TypeScript

1. **Frühe Fehlererkennung**

   * Typfehler werden bereits beim Kompilieren gefunden, bevor der Code ausgeführt wird.

   ```js
   let price: number = 50
   price = "fünfzig" // ❌ Fehler beim Kompilieren
   ```

2. **Bessere Entwicklererfahrung (DX)**

   * IntelliSense, Autovervollständigung, Hover-Infos und Refactoring sind präziser.

3. **Klarheit und Wartbarkeit**

   * Durch Typannotationen und Interfaces ist der Code selbstdokumentierend.

   ```js
   interface Product {
     id: number
     name: string
     price: number
   }
   ```

4. **Skalierbarkeit**

   * Besonders nützlich in großen Projekten mit vielen Entwicklern.
   * Änderungen sind sicherer, da Typen sofort Konflikte zeigen.

5. **Moderne Features**

   * Unterstützung von Generics, Union/Intersection Types, Enums, Utility-Types.

   ```js
   function wrapValue<T>(value: T): T[] {
     return [value]
   }
   const result = wrapValue<string>("Hallo") // result: string[]
   ```

6. **Kompatibilität mit JavaScript**

   * Jeder JS-Code läuft auch in TS.
   * Migration von bestehenden Projekten möglich (schrittweise Einführung).

---

### Zusammenfassung

* **TypeScript** bringt Typensicherheit, bessere Entwickler-Tools, klareren und wartbareren Code, Skalierbarkeit in großen Projekten und moderne Sprachfeatures.
* Besonders vorteilhaft bei **langfristigen, komplexen Projekten** mit mehreren Teammitgliedern.

🔗 Quellen:

* [TypeScript Handbook – Why TypeScript](https://www.typescriptlang.org/docs/handbook/2/basic-types.html)
* [React TypeScript Cheatsheet – Vorteile](https://react-typescript-cheatsheet.netlify.app/docs/basic/setup)

  **[⬆ Наверх](#top)**

3. ### <a name="3"></a> Was ist Typisierung (static typing)?

### Typisierung (Static Typing)

**Definition:**
Statische Typisierung bedeutet, dass der Datentyp einer Variable oder Funktion **zur Compile-Zeit** festgelegt wird und nicht erst zur Laufzeit.

### Merkmale

1. **Fester Typ während der gesamten Lebenszeit**

   * Eine Variable behält den einmal festgelegten Typ.
   * Zuweisungen anderer Typen führen zu einem Kompilierungsfehler.

   ```js
   let username: string = "Sergii"
   username = 42 // ❌ Fehler: number ist nicht string
   ```

2. **Frühe Fehlererkennung**

   * Tippfehler oder falsche Funktionsaufrufe werden direkt angezeigt.

   ```js
   function add(a: number, b: number): number {
     return a + b
   }

   add(5, "10") // ❌ Fehler: Argument vom Typ 'string' ist nicht zuweisbar
   ```

3. **Verbesserte Autovervollständigung und Dokumentation**

   * IDEs können anhand der Typen Vorschläge und Hilfen anzeigen.

4. **Generics und komplexe Typen**

   * Flexible, aber dennoch sichere Strukturen möglich.

   ```js
   function identity<T>(value: T): T {
     return value
   }
   const result = identity<number>(10) // Typ: number
   ```

---

### Unterschied zu dynamischer Typisierung (JavaScript)

* **Dynamisch:** Typen werden erst zur Laufzeit geprüft.
* **Statisch:** Typen werden bereits vor der Ausführung geprüft.

---

### Zusammenfassung

* **Static Typing** = feste Typprüfung während der Kompilierung.
* Vorteile: weniger Laufzeitfehler, klarer Code, bessere Tool-Unterstützung.
* In TypeScript zwingend (mit Ausnahmen wie `any`), in JavaScript nicht vorhanden.

🔗 Quellen:

* [TypeScript Handbook – Basic Types](https://www.typescriptlang.org/docs/handbook/2/basic-types.html)
* [MDN – JavaScript Datentypen](https://developer.mozilla.org/ru/docs/Web/JavaScript/Data_structures)

  **[⬆ Наверх](#top)**

4. ### <a name="4"></a> Welche grundlegenden Typen gibt es in TypeScript?

### Grundlegende Typen in TypeScript

TypeScript erweitert JavaScript um **statische Typisierung**. Die wichtigsten **Basis-Typen** sind:

---

#### 1. **Primitives**

* **string**

  ```js
  let username: string = "Sergii"
  ```
* **number** (Ganzzahlen & Fließkommazahlen)

  ```js
  let age: number = 34
  ```
* **boolean**

  ```js
  let isOnline: boolean = true
  ```
* **null** und **undefined**

  ```js
  let value: null = null
  let notAssigned: undefined = undefined
  ```
* **bigint** (für sehr große Zahlen)

  ```js
  let big: bigint = 9007199254740991n
  ```
* **symbol** (einzigartige Werte)

  ```js
  let uniqueId: symbol = Symbol("id")
  ```

---

#### 2. **Arrays**

```js
let numbers: number[] = [1, 2, 3]
let names: Array<string> = ["Anna", "Tom"] // Generics-Schreibweise
```

---

#### 3. **Tuples**

* Feste Anzahl von Elementen mit festen Typen.

```js
let person: [string, number] = ["Sergii", 34]
```

---

#### 4. **Enums**

* Sammlung von benannten Konstanten.

```js
enum Role {
  Admin,
  User,
  Guest
}

let currentRole: Role = Role.Admin
```

---

#### 5. **Any**

* Deaktiviert Typprüfung (sollte vermieden werden).

```js
let data: any = 5
data = "Text"
```

---

#### 6. **Unknown**

* Sicherere Alternative zu `any`, erfordert Typprüfung vor Verwendung.

```js
let value: unknown = "Hallo"

if (typeof value === "string") {
  console.log(value.toUpperCase())
}
```

---

#### 7. **Void**

* Wird für Funktionen verwendet, die nichts zurückgeben.

```js
function logMessage(message: string): void {
  console.log(message)
}
```

---

#### 8. **Never**

* Für Funktionen, die niemals einen Wert zurückgeben (z. B. Fehler werfen).

```js
function throwError(msg: string): never {
  throw new Error(msg)
}
```

---

### Zusammenfassung

* **Primitive Typen**: string, number, boolean, null, undefined, bigint, symbol
* **Spezielle Typen**: any, unknown, void, never
* **Strukturierte Typen**: arrays, tuples, enums

🔗 Quellen:

* [TypeScript Handbook – Basic Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html)
* [React TypeScript Cheatsheet – Basic Setup](https://react-typescript-cheatsheet.netlify.app/docs/basic/setup)

  **[⬆ Наверх](#top)**

5. ### <a name="5"></a> Worin besteht der Unterschied zwischen any und unknown?

### Unterschied zwischen `any` und `unknown`

#### **1. `any`**

* Deaktiviert **jegliche Typprüfung**.
* Man kann jede Operation auf `any` ausführen, ohne Fehler beim Kompilieren.
* Gefahr: Laufzeitfehler, da TypeScript keine Sicherheit bietet.

```js
let value: any = "Hallo"
value = 123
value.toUpperCase() // ✅ Kein Fehler beim Kompilieren, aber Laufzeitfehler möglich
```

---

#### **2. `unknown`**

* Ist ein **sicherer Gegenspieler zu `any`**.
* Man kann einen Wert vom Typ `unknown` nicht direkt verwenden, ohne ihn vorher zu prüfen oder zu casten.
* Erzwingt **Type-Safety** durch Typabfragen.

```js
let input: unknown = "Hallo"

// ❌ Direkt nicht erlaubt
// input.toUpperCase()

// ✅ Mit Typprüfung
if (typeof input === "string") {
  console.log(input.toUpperCase())
}
```

---

#### **Vergleich**

| Merkmal            | `any`                 | `unknown`                            |
| ------------------ | --------------------- | ------------------------------------ |
| Typprüfung         | Keine                 | Erforderlich                         |
| Sicherheit         | Niedrig               | Hoch                                 |
| Nutzungsempfehlung | Nur in Ausnahmefällen | Besser als `any` für unsichere Werte |

---

### Zusammenfassung

* **`any`**: erlaubt alles, keine Typprüfung → unsicher.
* **`unknown`**: erfordert Typprüfung oder Casting → sicherer, bevorzugt für unbekannte Werte (z. B. API-Response).

🔗 Quellen:

* [TypeScript Handbook – unknown](https://www.typescriptlang.org/docs/handbook/2/functions.html#unknown)
* [React TypeScript Cheatsheet – any vs. unknown](https://react-typescript-cheatsheet.netlify.app/docs/basic/troubleshooting/types)

  **[⬆ Наверх](#top)**

6. ### <a name="6"></a> Was ist never und wann wird es verwendet?

### `never` in TypeScript

**Definition:**
`never` ist ein spezieller Typ für Werte, die **niemals existieren können**.
Eine Funktion oder ein Ausdruck vom Typ `never` beendet entweder den Programmfluss (z. B. durch einen Fehler) oder läuft unendlich weiter.

---

### Anwendungsfälle

#### 1. **Funktionen, die immer Fehler werfen**

```js
function throwError(message: string): never {
  throw new Error(message)
}
```

* Rückgabewert: niemals erreichbar, da die Funktion das Programm mit einem Fehler abbricht.

---

#### 2. **Endlose Schleifen**

```js
function infiniteLoop(): never {
  while (true) {
    console.log("läuft ewig...")
  }
}
```

* Die Funktion verlässt nie die Schleife → daher `never`.

---

#### 3. **Exhaustiveness Checking** (Typprüfung bei `switch` / `if-else`)

* `never` wird verwendet, um sicherzustellen, dass alle möglichen Fälle abgedeckt sind.

```js
type Shape = "circle" | "square"

function getArea(shape: Shape): number {
  switch (shape) {
    case "circle":
      return Math.PI * 10 ** 2
    case "square":
      return 10 * 10
    default:
      const exhaustiveCheck: never = shape
      return exhaustiveCheck
  }
}
```

* Vorteil: Falls später ein neuer Typ (`"triangle"`) hinzugefügt wird, zeigt TypeScript einen Fehler an, solange er nicht im `switch` behandelt wird.

---

### Unterschied zu `void`

* **`void`**: Funktion gibt keinen **Wert** zurück.
* **`never`**: Funktion gibt **nie** etwas zurück (nicht mal `undefined`).

---

### Zusammenfassung

* **`never`** = Typ für Werte, die nie vorkommen können.
* Typische Nutzung: Funktionen, die Fehler werfen, unendliche Schleifen oder Exhaustiveness Checking.
* Unterschied zu `void`: `void` = kein Rückgabewert, `never` = niemals Rückgabe.

🔗 Quellen:

* [TypeScript Handbook – never](https://www.typescriptlang.org/docs/handbook/2/functions.html#never)
* [MDN – JavaScript Error](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Error)

  **[⬆ Наверх](#top)**

7. ### <a name="7"></a> Was ist der Unterschied zwischen null und undefined?

### Unterschied zwischen `null` und `undefined` in TypeScript / JavaScript

#### **1. `undefined`**

* Automatischer Standardwert für nicht initialisierte Variablen oder fehlende Eigenschaften.
* Bedeutet: *"nicht zugewiesen"*.

```js
let a
console.log(a) // undefined

const obj = {}
console.log(obj.prop) // undefined
```

---

#### **2. `null`**

* Wird explizit vom Entwickler gesetzt.
* Bedeutet: *"absichtlich leer / kein Wert"*.

```js
let b: string | null = null
console.log(b) // null
```

---

#### **3. Vergleich**

```js
console.log(null == undefined)  // true  (lockerer Vergleich)
console.log(null === undefined) // false (strenger Vergleich)
```

---

#### **4. In TypeScript**

* `undefined` und `null` sind eigene Typen.
* Standardmäßig sind sie **Zuweisungen an andere Typen erlaubt** (abhängig von `--strictNullChecks`).

```js
let x: string | null = null   // erlaubt
let y: string | undefined     // muss initialisiert oder geprüft werden
```

---

#### **5. Typische Verwendung**

* **`undefined`**: vom System vergeben, wenn nichts zugewiesen wurde.
* **`null`**: vom Entwickler gesetzt, um „keinen Wert“ darzustellen.

---

### Zusammenfassung

* **`undefined`** = Wert fehlt automatisch (nicht initialisiert, nicht vorhanden).
* **`null`** = Wert wurde absichtlich auf „kein Wert“ gesetzt.
* Unterschied deutlich machen mit `===`: `null !== undefined`.

🔗 Quellen:

* [TypeScript Handbook – Everyday Types: null & undefined](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#null-and-undefined)
* [MDN – null](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/null)
* [MDN – undefined](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/undefined)

  **[⬆ Наверх](#top)**

8. ### <a name="8"></a> Was ist void?

### `void` in TypeScript

**Definition:**
`void` ist ein spezieller Typ in TypeScript, der bedeutet, dass eine Funktion **keinen Rückgabewert** hat.

---

### Anwendungsfälle

#### 1. **Funktion ohne Rückgabewert**

```js
function logMessage(message: string): void {
  console.log(message)
}

const result = logMessage("Hallo")
// result hat den Typ void → es wird nichts zurückgegeben
```

---

#### 2. **Callbacks, die nichts zurückgeben**

```js
function forEachItem(items: string[], callback: (item: string) => void) {
  for (const item of items) {
    callback(item)
  }
}

forEachItem(["A", "B"], (el) => console.log(el))
```

---

#### 3. **Unterschied zu `undefined`**

* `void` ≠ `undefined`, auch wenn Funktionen implizit `undefined` zurückgeben.
* Mit `void` sagt man ausdrücklich: *„Kein Rückgabewert ist relevant“*.

```js
function test(): void {
  return // erlaubt, implizit undefined
}

function test2(): undefined {
  return undefined // nur explizit erlaubt
}
```

---

#### 4. **Besonderheit bei Promises**

* `Promise<void>` → Funktion gibt ein Promise zurück, dessen Wert nicht benutzt werden soll.

```js
async function saveData(): Promise<void> {
  await fetch("/api/save")
}
```

---

### Zusammenfassung

* **`void`** kennzeichnet Funktionen ohne Rückgabewert.
* Typischer Einsatz: `console.log`, Event-Handler, Callbacks.
* Unterschied zu `undefined`: `void` betont die Abwesenheit eines Rückgabewerts, `undefined` ist ein Wert selbst.

🔗 Quellen:

* [TypeScript Handbook – void](https://www.typescriptlang.org/docs/handbook/2/functions.html#void)
* [React TS Cheatsheet – void in Callbacks](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/event-handling/)

  **[⬆ Наверх](#top)**

9. ### <a name="9"></a> Was sind Union Types? Gib ein Beispiel.

### Union Types in TypeScript

**Definition:**
Ein **Union Type** erlaubt es, dass eine Variable oder ein Parameter **mehrere mögliche Typen** haben kann. Er wird mit dem **`|`-Operator** geschrieben.

---

### Beispiel 1 – Variable mit mehreren Typen

```js
let id: string | number

id = 42      // ✅ erlaubt
id = "abc"   // ✅ erlaubt
id = true    // ❌ Fehler: boolean nicht erlaubt
```

---

### Beispiel 2 – Funktion mit Union Types

```js
function printId(id: string | number): void {
  if (typeof id === "string") {
    console.log("ID als Text:", id.toUpperCase())
  } else {
    console.log("ID als Zahl:", id.toFixed(2))
  }
}

printId("abc") // ID als Text: ABC
printId(123.456) // ID als Zahl: 123.46
```

---

### Beispiel 3 – Union in Arrays

```js
let values: (string | number)[] = [1, "zwei", 3, "vier"]
```

---

### Zusammenfassung

* **Union Types** = Typen, die **mehrere mögliche Werte** annehmen können.
* Verwendung: `string | number`, `(string | number)[]`.
* Nützlich für Werte mit mehreren erlaubten Formen (z. B. API-Response: `string | null`).

🔗 Quellen:

* [TypeScript Handbook – Union Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types)
* [React TypeScript Cheatsheet – Union Types](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example)

  **[⬆ Наверх](#top)**

10. ### <a name="10"></a> Was sind Intersection Types? Gib ein Beispiel.

### Intersection Types in TypeScript

**Definition:**
Ein **Intersection Type** (`&`) kombiniert mehrere Typen zu einem **neuen Typ**, der **alle Eigenschaften** der beteiligten Typen enthalten muss.
→ Während `Union (|)` **entweder-oder** bedeutet, ist `Intersection (&)` ein **sowohl-als-auch**.

---

### Beispiel 1 – Kombination von Interfaces

```js
interface Person {
  name: string
}

interface Employee {
  company: string
}

type EmployeePerson = Person & Employee

const worker: EmployeePerson = {
  name: "Sergii",
  company: "Tech GmbH"
}
```

---

### Beispiel 2 – Kombination von Typen

```js
type A = { x: number }
type B = { y: number }

type AB = A & B

const point: AB = { x: 10, y: 20 } // Muss beide Eigenschaften haben
```

---

### Beispiel 3 – Praktisch in Generics

```js
function merge<T, U>(objA: T, objB: U): T & U {
  return { ...objA, ...objB }
}

const merged = merge({ id: 1 }, { role: "admin" })
// Typ: { id: number } & { role: string }
```

---

### Zusammenfassung

* **Intersection Types (`&`)** = Kombination mehrerer Typen zu einem Typ, der **alle Eigenschaften** enthält.
* Unterschied zu Union:

  * **Union (`|`)** → entweder-oder.
  * **Intersection (`&`)** → sowohl-als-auch.

🔗 Quellen:

* [TypeScript Handbook – Intersection Types](https://www.typescriptlang.org/docs/handbook/2/objects.html#intersection-types)
* [React TS Cheatsheet – Utility Types & Intersections](https://react-typescript-cheatsheet.netlify.app/docs/advanced/types_react_api/)

  **[⬆ Наверх](#top)**

11. ### <a name="11"></a> Was sind Literal Types?

### Literal Types in TypeScript

**Definition:**
Ein **Literal Type** schränkt eine Variable auf einen **konkreten Wert** ein, anstatt nur auf den allgemeinen Typ (z. B. `string` oder `number`).
So kann man Variablen oder Parameter **nur bestimmte erlaubte Werte** zuweisen.

---

### Beispiel 1 – String-Literals

```js
let direction: "left" | "right"

direction = "left"   // ✅ erlaubt
direction = "right"  // ✅ erlaubt
direction = "up"     // ❌ Fehler
```

---

### Beispiel 2 – Number-Literals

```js
let diceRoll: 1 | 2 | 3 | 4 | 5 | 6

diceRoll = 3  // ✅ erlaubt
diceRoll = 7  // ❌ Fehler
```

---

### Beispiel 3 – In Kombination mit Unions

```js
type Status = "success" | "error" | "loading"

function handleStatus(status: Status): void {
  if (status === "success") {
    console.log("Alles gut ✅")
  } else if (status === "error") {
    console.log("Fehler ❌")
  } else {
    console.log("Lädt ⏳")
  }
}

handleStatus("success")
```

---

### Beispiel 4 – Literal Inferenz mit `const`

```js
const role = "admin"
// Typ ist "admin", nicht string
```

---

### Zusammenfassung

* **Literal Types** = feste, konkrete Werte als Typen.
* Nützlich für: erlaubte Werte (Enums-ähnlich), Statusangaben, Konstanten.
* Oft in Kombination mit **Union Types** genutzt.

🔗 Quellen:

* [TypeScript Handbook – Literal Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-types)
* [React TS Cheatsheet – Discriminated Unions](https://react-typescript-cheatsheet.netlify.app/docs/advanced/discriminated_unions/)

  **[⬆ Наверх](#top)**

12. ### <a name="12"></a> Wie funktioniert type inference in TypeScript?

### Type Inference in TypeScript

**Definition:**
**Type Inference (Typinferenz)** bedeutet, dass TypeScript den Typ einer Variable, Funktion oder eines Ausdrucks **automatisch ableitet**, wenn kein expliziter Typ angegeben wird.

---

### Regeln der Typinferenz

#### 1. **Variable-Zuweisung**

```js
let count = 10
// Typ wird automatisch als number erkannt
// count: number
```

---

#### 2. **Funktionsergebnisse**

```js
function add(a: number, b: number) {
  return a + b
}
// Rückgabetyp: number (wird automatisch erkannt)
```

---

#### 3. **Best Common Type**

Wenn verschiedene Typen in einem Array vorkommen, wählt TypeScript den "allgemeinsten" Typ.

```js
let values = [1, "zwei", 3]
// Typ: (string | number)[]
```

---

#### 4. **Contextual Typing**

Der Typ kann auch aus dem **Kontext** abgeleitet werden.

```js
window.addEventListener("click", (event) => {
  console.log(event.clientX) // event: MouseEvent
})
```

---

#### 5. **Default Inference für `any`**

Wenn keine Information vorliegt, wird `any` angenommen (außer bei `--noImplicitAny`).

```js
function log(value) {
  console.log(value)
}
// value: any
```

---

### Vorteile

* Weniger Schreibarbeit (man muss nicht überall Typen manuell angeben).
* Bessere Lesbarkeit.
* Trotzdem Typ-Sicherheit, solange genug Information vorhanden ist.

---

### Zusammenfassung

* **Type Inference** = automatische Typbestimmung durch TypeScript.
* Regeln: Variablenzuweisung, Funktionsrückgaben, Arrays (Best Common Type), Kontextabhängigkeit.
* Vorteil: weniger Code, aber trotzdem Typ-Sicherheit.

🔗 Quellen:

* [TypeScript Handbook – Type Inference](https://www.typescriptlang.org/docs/handbook/type-inference.html)
* [React TS Cheatsheet – Inference](https://react-typescript-cheatsheet.netlify.app/docs/basic/troubleshooting/types/#type-inference)

  **[⬆ Наверх](#top)**

13. ### <a name="13"></a> Was ist ein Type Alias (type) und wie unterscheidet er sich von interface?

### **Type Alias (`type`) in TypeScript**

**Definition:**
Ein **Type Alias** erstellt einen neuen Namen für einen bestehenden Typ.
Er kann primitive Typen, Union/Intersection Types, Funktionen oder komplexe Strukturen beschreiben.

```js
type UserID = string | number

type User = {
  id: UserID
  name: string
}
```

---

### **Interface in TypeScript**

**Definition:**
Ein **Interface** beschreibt die **Struktur eines Objekts** (Shape).
Es wird häufig für Klassen, Objekte und die Definition von Verträgen verwendet.

```js
interface User {
  id: number
  name: string
}
```

---

### **Hauptunterschiede**

| Aspekt                   | `type`                                                               | `interface`                                    |
| ------------------------ | -------------------------------------------------------------------- | ---------------------------------------------- |
| **Einsatz**              | Alias für jeden Typ (Primitives, Unions, Functions, Tuples, Objects) | Nur Objekte und Klassen-Strukturen             |
| **Erweiterung**          | Mit `&` (Intersection)                                               | Mit `extends`                                  |
| **Deklarations-Merging** | ❌ Nicht möglich                                                      | ✅ Mehrfachdeklarationen werden zusammengeführt |
| **Flexibilität**         | Sehr vielseitig                                                      | Speziell für objektorientierte Modelle         |

---

### **Beispiele für Unterschiede**

#### 1. Type für Union

```js
type Status = "success" | "error" | "loading"
```

Mit `interface` nicht möglich.

---

#### 2. Interface-Erweiterung

```js
interface Person {
  name: string
}

interface Employee extends Person {
  company: string
}
```

---

#### 3. Type-Erweiterung mit Intersection

```js
type Person = { name: string }
type Employee = Person & { company: string }
```

---

#### 4. Deklarations-Merging

```js
interface Window {
  title: string
}

interface Window {
  size: number
}

const w: Window = { title: "App", size: 800 }
// ✅ erlaubt, beide Interfaces verschmelzen
```

Mit `type` nicht möglich.

---

### Zusammenfassung

* **`type`** = Alias für beliebige Typen (Primitives, Union, Intersection, Functions, Tuples, Objekte).
* **`interface`** = Vertrag für Objekt- oder Klassen-Strukturen, unterstützt Deklarations-Merging.
* Empfehlung:

  * **Objektmodelle → `interface`**
  * **Komplexe Typ-Kombinationen → `type`**

🔗 Quellen:

* [TypeScript Handbook – Type Aliases](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-aliases)
* [TypeScript Handbook – Interfaces](https://www.typescriptlang.org/docs/handbook/2/objects.html)
* [React TS Cheatsheet – Types vs. Interfaces](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example#types-vs-interfaces)

  **[⬆ Наверх](#top)**

14. ### <a name="14"></a> Was ist der Unterschied zwischen interface und type?

### Unterschied zwischen `interface` und `type` in TypeScript

#### **1. Gemeinsamkeiten**

* Beide können Objekte beschreiben.
* Beide unterstützen Erweiterung und Wiederverwendung.
* Beide sind strukturell (nicht nominal) → entscheidend ist die Form, nicht der Name.

---

#### **2. Unterschiede**

| Aspekt                   | `interface`                                       | `type`                                                             |
| ------------------------ | ------------------------------------------------- | ------------------------------------------------------------------ |
| **Verwendungszweck**     | Hauptsächlich für Objekte und Klassen-Contracts   | Alias für jeden Typ (auch Primitives, Union, Tuple, Function etc.) |
| **Erweiterung**          | `extends`                                         | Intersection (`&`)                                                 |
| **Deklarations-Merging** | ✅ Ja (mehrfach definierbar, wird zusammengeführt) | ❌ Nein                                                             |
| **Flexibilität**         | Eingeschränkter (nur für Objekt-ähnliche Typen)   | Sehr flexibel, kann alles beschreiben                              |
| **Lesbarkeit**           | Oft bevorzugt für Props, Klassen, API-Schemas     | Bevorzugt für komplexe Typkombinationen, Union/Intersection        |

---

#### **3. Beispiele**

**Interface für Objekte**

```js
interface Person {
  name: string
  age: number
}

interface Employee extends Person {
  company: string
}

const dev: Employee = { name: "Sergii", age: 34, company: "Tech GmbH" }
```

**Type für komplexe Kombinationen**

```js
type Status = "success" | "error" | "loading"

type UserID = string | number

type Point = [number, number] // Tuple
```

**Deklarations-Merging (nur bei Interface)**

```js
interface Window {
  title: string
}

interface Window {
  size: number
}

const w: Window = { title: "App", size: 800 } // ✅ erlaubt
```

---

### Zusammenfassung

* **`interface`** = objektorientiert, erweiterbar (`extends`), unterstützt Deklarations-Merging.
* **`type`** = flexibler, geeignet für Unions, Primitives, Funktionen, Tuples.
* Empfehlung:

  * **Objekte/Klassen** → `interface`
  * **Union/Intersection/Primitives** → `type`

🔗 Quellen:

* [TypeScript Handbook – Interfaces](https://www.typescriptlang.org/docs/handbook/2/objects.html)
* [TypeScript Handbook – Type Aliases](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-aliases)
* [React TS Cheatsheet – Types vs Interfaces](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example#types-vs-interfaces)

  **[⬆ Наверх](#top)**

15. ### <a name="15"></a> Kann man Interfaces zusammenführen (extend)?

### Interfaces zusammenführen in TypeScript

Ja – **Interfaces** können auf zwei Arten zusammengeführt werden:

---

#### **1. Erweiterung mit `extends`**

Ein Interface kann ein anderes Interface erweitern.

```js
interface Person {
  name: string
}

interface Employee extends Person {
  company: string
}

const dev: Employee = {
  name: "Sergii",
  company: "Tech GmbH"
}
```

* `Employee` erbt alle Eigenschaften von `Person`.

---

#### **2. Deklarations-Merging**

Wenn mehrere **gleichnamige Interfaces** existieren, werden sie automatisch zusammengeführt.

```js
interface Window {
  title: string
}

interface Window {
  size: number
}

const w: Window = {
  title: "App",
  size: 1200
}
```

* TypeScript kombiniert beide Definitionen → Ergebnis ist ein Interface mit `title` **und** `size`.

---

#### Unterschied zu `type`

* `type` kann **nicht** gemerged werden.
* Nur `interface` unterstützt Deklarations-Merging.

---

### Zusammenfassung

* **Ja, Interfaces können zusammengeführt werden.**
* Zwei Wege:

  1. **`extends`** → Vererbung.
  2. **Deklarations-Merging** → mehrere gleiche Namen = automatisch kombiniert.
* Vorteil: Flexibel für API-Erweiterungen oder globale Typdefinitionen.

🔗 Quellen:

* [TypeScript Handbook – Interfaces](https://www.typescriptlang.org/docs/handbook/2/objects.html#extending-interfaces)
* [TypeScript Handbook – Declaration Merging](https://www.typescriptlang.org/docs/handbook/declaration-merging.html)

  **[⬆ Наверх](#top)**

16. ### <a name="16"></a> Was sind optionale Eigenschaften in Interfaces?

### Optionale Eigenschaften in Interfaces

**Definition:**
Optionale Eigenschaften in einem Interface sind Felder, die beim Erstellen eines Objekts **nicht zwingend angegeben** werden müssen.
Man markiert sie mit einem **Fragezeichen (`?`)** nach dem Eigenschaftsnamen.

---

### Beispiel 1 – Einfaches Interface mit optionalen Feldern

```js
interface User {
  id: number
  name: string
  age?: number // optional
}

const user1: User = { id: 1, name: "Sergii" }       // ✅ ohne age
const user2: User = { id: 2, name: "Anna", age: 30 } // ✅ mit age
```

---

### Beispiel 2 – Optional in Kombination mit Funktionen

```js
interface Config {
  url: string
  timeout?: number
}

function fetchData(config: Config) {
  console.log(`Hole Daten von ${config.url}`)
  if (config.timeout) {
    console.log(`Timeout: ${config.timeout}ms`)
  }
}

fetchData({ url: "/api" })
fetchData({ url: "/api", timeout: 5000 })
```

---

### Beispiel 3 – Unterschied zu `undefined`

Ein optionales Feld kann fehlen **oder explizit `undefined` sein**.

```js
interface Product {
  name: string
  price?: number
}

const p1: Product = { name: "Buch" }                 // kein price
const p2: Product = { name: "Buch", price: undefined } // explizit undefined
```

---

### Zusammenfassung

* **Optionale Eigenschaften** (`?`) = nicht verpflichtend in Objekten.
* Können weggelassen oder explizit auf `undefined` gesetzt werden.
* Nützlich für **Konfigurationsobjekte, optionale Props, flexible Datenstrukturen**.

🔗 Quellen:

* [TypeScript Handbook – Interfaces](https://www.typescriptlang.org/docs/handbook/2/objects.html#optional-properties)
* [React TS Cheatsheet – Optional Props](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example#optional-props)

  **[⬆ Наверх](#top)**

17. ### <a name="17"></a> Wie deklariert man readonly-Eigenschaften?

### `readonly` Eigenschaften in TypeScript

**Definition:**
Mit dem Schlüsselwort **`readonly`** kann man Eigenschaften in Interfaces, Types oder Klassen so deklarieren, dass sie **nach der Initialisierung nicht mehr verändert** werden dürfen.

---

### Beispiel 1 – Interface mit `readonly`

```js
interface User {
  readonly id: number
  name: string
}

const user: User = { id: 1, name: "Sergii" }

user.name = "Anna"   // ✅ erlaubt
user.id = 2          // ❌ Fehler: id ist readonly
```

---

### Beispiel 2 – Type mit `readonly`

```js
type Point = {
  readonly x: number
  readonly y: number
}

const p: Point = { x: 10, y: 20 }
p.x = 30 // ❌ Fehler
```

---

### Beispiel 3 – Klassen mit `readonly`

```js
class Person {
  readonly id: number
  name: string

  constructor(id: number, name: string) {
    this.id = id      // ✅ Initialisierung erlaubt
    this.name = name
  }
}

const dev = new Person(1, "Sergii")
dev.name = "Anna"   // ✅ erlaubt
dev.id = 2          // ❌ Fehler
```

---

### Beispiel 4 – Readonly Arrays

```js
const numbers: ReadonlyArray<number> = [1, 2, 3]

numbers.push(4) // ❌ Fehler: push ist nicht erlaubt
```

---

### Zusammenfassung

* **`readonly`** = Eigenschaft kann nur bei der Initialisierung gesetzt werden.
* Einsatz in: **Interfaces, Types, Klassen, Arrays**.
* Vorteil: bessere **Immutabilität** und Sicherheit vor unbeabsichtigten Änderungen.

🔗 Quellen:

* [TypeScript Handbook – readonly](https://www.typescriptlang.org/docs/handbook/2/objects.html#readonly-properties)
* [React TS Cheatsheet – readonly usage](https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase#readonly-and-const-assertions)

  **[⬆ Наверх](#top)**

18. ### <a name="18"></a> Was sind Tupel (tuples) in TypeScript?

### Tupel (Tuples) in TypeScript

**Definition:**
Ein **Tuple** ist ein spezielles Array mit **fester Länge** und **fest definierten Typen** an den jeweiligen Positionen.
→ Anders als bei Arrays kann jedes Element einen eigenen Typ haben, der an einer bestimmten Stelle erwartet wird.

---

### Beispiel 1 – Einfaches Tuple

```js
let user: [string, number]

user = ["Sergii", 34]   // ✅ korrekt
user = [34, "Sergii"]   // ❌ Fehler: Reihenfolge stimmt nicht
```

---

### Beispiel 2 – Tuple mit optionalem Element

```js
let point: [number, number, number?]

point = [10, 20]       // ✅ erlaubt
point = [10, 20, 30]   // ✅ erlaubt
```

---

### Beispiel 3 – Mit `readonly` (immutable Tuple)

```js
let coordinates: readonly [number, number] = [50, 100]

coordinates[0] = 10 // ❌ Fehler: readonly
```

---

### Beispiel 4 – Einsatz in Funktionen

```js
function useCoordinates(): [number, number] {
  return [10, 20]
}

const [x, y] = useCoordinates()
```

---

### Beispiel 5 – Variadische Tupel (seit TS 4.0)

```js
type Pair<T> = [T, T]
type Triple<T> = [T, T, T]

let pair: Pair<string> = ["a", "b"]
let triple: Triple<number> = [1, 2, 3]
```

---

### Zusammenfassung

* **Tuple** = Array mit **fester Länge** und **definierten Typen pro Index**.
* Nützlich für: Rückgabewerte von Funktionen, koordinatenartige Werte, kleine feste Strukturen.
* Erweiterungen: optionale Elemente, `readonly`, variadische Tupel.

🔗 Quellen:

* [TypeScript Handbook – Tuples](https://www.typescriptlang.org/docs/handbook/2/objects.html#tuple-types)
* [MDN – Arrays (als Grundlage)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array)

  **[⬆ Наверх](#top)**

19. ### <a name="19"></a> Was ist ein Enum und wann sollte man es verwenden?

### Enum in TypeScript

**Definition:**
Ein **Enum** (Aufzählungstyp) ist eine Sammlung von **benannten Konstanten**.
Es wird verwendet, um Wertegruppen besser lesbar und verständlich zu machen.

---

### Arten von Enums

#### 1. **Numerische Enums (Standard)**

```js
enum Direction {
  Up,    // 0
  Down,  // 1
  Left,  // 2
  Right  // 3
}

let move: Direction = Direction.Up
console.log(move) // 0
```

Man kann auch Startwerte vergeben:

```js
enum Status {
  Success = 1,
  Error = 2,
  Loading = 3
}
```

---

#### 2. **String Enums**

```js
enum Role {
  Admin = "ADMIN",
  User = "USER",
  Guest = "GUEST"
}

let current: Role = Role.Admin
```

---

#### 3. **Const Enums (Kompilierungsoptimierung)**

```js
const enum LogLevel {
  Info,
  Warning,
  Error
}

let level: LogLevel = LogLevel.Error
```

👉 Vorteile: wird zu einfachen Konstanten kompiliert → bessere Performance.

---

### Wann verwenden?

✅ **Geeignet für:**

* Feste, klar definierte Wertegruppen (z. B. Rollen, Status, Richtungen).
* Lesbarkeit: statt `"ADMIN"` oder `1` → `Role.Admin`.
* Weniger Tippfehler durch Autovervollständigung.

⚠️ **Alternativen:**

* **Union Types** mit Literal-Typen sind oft schlanker und flexibler.

  ```js
  type Role = "ADMIN" | "USER" | "GUEST"
  ```
* Empfehlung: In modernen Projekten werden häufig **Union Types** anstelle von Enums bevorzugt, da sie besser mit TypeScript-Features wie Narrowing und Type Inference harmonieren.

---

### Zusammenfassung

* **Enum** = Sammlung von benannten Konstanten (numeric, string, const).
* Vorteile: bessere Lesbarkeit, Fehlervermeidung, klare Struktur.
* Verwendung: feste Wertemengen (Status, Rollen, Richtungen).
* Alternative: **Union Types** → oft moderner und einfacher.

🔗 Quellen:

* [TypeScript Handbook – Enums](https://www.typescriptlang.org/docs/handbook/enums.html)
* [React TS Cheatsheet – Union vs Enums](https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase#enums-vs-union-types)

  **[⬆ Наверх](#top)**

20. ### <a name="20"></a> Was ist der Unterschied zwischen const enum und einem normalen enum?

### Unterschied zwischen `enum` und `const enum` in TypeScript

#### **1. Normales `enum`**

* Wird zur **Laufzeit** in JavaScript-Code kompiliert.
* TypeScript erzeugt ein **Objekt** mit Schlüssel/Wert-Zuordnung.
* Bidirektionale Abbildung: man kann von Namen auf Wert und umgekehrt zugreifen.

```js
enum Direction {
  Up,
  Down,
  Left,
  Right
}

console.log(Direction.Up)    // 0
console.log(Direction[0])    // "Up"
```

➡️ Nach der Kompilierung entsteht ein JS-Objekt:

```js
var Direction;
(function (Direction) {
    Direction[Direction["Up"] = 0] = "Up";
    Direction[Direction["Down"] = 1] = "Down";
    Direction[Direction["Left"] = 2] = "Left";
    Direction[Direction["Right"] = 3] = "Right";
})(Direction || (Direction = {}));
```

---

#### **2. `const enum`**

* Wird **zur Compile-Zeit** durch seine Werte ersetzt.
* Kein Objekt im generierten JavaScript.
* Spart Code und verbessert Performance.

```js
const enum Direction {
  Up,
  Down,
  Left,
  Right
}

let move = Direction.Up
console.log(move) // 0
```

➡️ Nach der Kompilierung:

```js
let move = 0 /* Up */
```

* Kein `Direction`-Objekt vorhanden → keine bidirektionale Abbildung möglich.

---

#### **3. Vergleich**

| Aspekt              | `enum`                                      | `const enum`                     |
| ------------------- | ------------------------------------------- | -------------------------------- |
| **Kompilierung**    | JS-Objekt wird erzeugt                      | Ersetzt durch Werte, kein Objekt |
| **Performance**     | Mehr Overhead                               | Weniger Overhead                 |
| **Reverse Mapping** | ✅ möglich (`Direction[0] → "Up"`)           | ❌ nicht möglich                  |
| **Codegröße**       | Größer                                      | Kleiner                          |
| **Verwendung**      | Wenn bidirektionales Mapping gebraucht wird | Für reine Konstantenwerte        |

---

### Zusammenfassung

* **`enum`**: erzeugt ein JavaScript-Objekt → erlaubt Zugriff in beide Richtungen, größerer Output.
* **`const enum`**: wird während der Kompilierung inline ersetzt → effizienter, aber ohne Reverse Mapping.

🔗 Quellen:

* [TypeScript Handbook – Enums](https://www.typescriptlang.org/docs/handbook/enums.html#const-enums)
* [React TS Cheatsheet – Enums](https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase#enums-vs-union-types)

  **[⬆ Наверх](#top)**

21. ### <a name="21"></a> Was ist Type Narrowing (Typschränkung)?

### Type Narrowing (Typschränkung) in TypeScript

**Definition:**
**Type Narrowing** bedeutet, dass TypeScript den Typ einer Variable während des Codes **einschränkt** (von einem breiteren Union-Typ auf einen spezifischeren Typ), basierend auf **Kontrollstrukturen oder Type Guards**.

---

### Beispiel 1 – `typeof` Narrowing

```js
function printId(id: string | number) {
  if (typeof id === "string") {
    console.log(id.toUpperCase()) // id: string
  } else {
    console.log(id.toFixed(2))    // id: number
  }
}
```

---

### Beispiel 2 – `instanceof` Narrowing

```js
class Dog {
  bark() { console.log("Wuff!") }
}
class Cat {
  meow() { console.log("Miau!") }
}

function makeSound(animal: Dog | Cat) {
  if (animal instanceof Dog) {
    animal.bark() // animal: Dog
  } else {
    animal.meow() // animal: Cat
  }
}
```

---

### Beispiel 3 – Property Check (`in` Operator)

```js
type Fish = { swim: () => void }
type Bird = { fly: () => void }

function move(animal: Fish | Bird) {
  if ("swim" in animal) {
    animal.swim() // Typ: Fish
  } else {
    animal.fly()  // Typ: Bird
  }
}
```

---

### Beispiel 4 – Gleichheitsprüfung (Literal Narrowing)

```js
type Status = "success" | "error" | "loading"

function handleStatus(status: Status) {
  if (status === "success") {
    console.log("Alles gut ✅")
  }
}
```

---

### Beispiel 5 – Exhaustive Check mit `never`

```js
type Shape = { kind: "circle"; radius: number } 
           | { kind: "square"; side: number }

function area(shape: Shape): number {
  switch (shape.kind) {
    case "circle": return Math.PI * shape.radius ** 2
    case "square": return shape.side * shape.side
    default:
      const exhaustive: never = shape // Fehler, falls ein neuer Typ fehlt
      return exhaustive
  }
}
```

---

### Zusammenfassung

* **Type Narrowing** = Einschränkung von Union-Typen auf spezifische Typen.
* Methoden: `typeof`, `instanceof`, `in`, Gleichheitsprüfungen, Kontrollfluss.
* Vorteil: bessere Typ-Sicherheit, weniger Fehler, klarer Code.

🔗 Quellen:

* [TypeScript Handbook – Narrowing](https://www.typescriptlang.org/docs/handbook/2/narrowing.html)
* [React TS Cheatsheet – Type Narrowing](https://react-typescript-cheatsheet.netlify.app/docs/basic/troubleshooting/types/#type-narrowing)

  **[⬆ Наверх](#top)**

22. ### <a name="22"></a> Was sind Type Guards? Gib ein Beispiel.

### Type Guards in TypeScript

**Definition:**
Ein **Type Guard** ist eine spezielle Bedingung oder Funktion, mit der TypeScript erkennt, welchen konkreten Typ eine Variable in einem Union-Type-Kontext hat.
→ Er hilft beim **Type Narrowing**, sodass TypeScript innerhalb des Blocks mit dem spezifischen Typ arbeiten kann.

---

### Beispiel 1 – `typeof` als Type Guard

```js
function printValue(value: string | number) {
  if (typeof value === "string") {
    console.log(value.toUpperCase()) // value: string
  } else {
    console.log(value.toFixed(2))    // value: number
  }
}
```

---

### Beispiel 2 – `instanceof` als Type Guard

```js
class Dog {
  bark() { console.log("Wuff!") }
}
class Cat {
  meow() { console.log("Miau!") }
}

function makeSound(animal: Dog | Cat) {
  if (animal instanceof Dog) {
    animal.bark() // animal: Dog
  } else {
    animal.meow() // animal: Cat
  }
}
```

---

### Beispiel 3 – Property Check (`in` Operator)

```js
type Fish = { swim: () => void }
type Bird = { fly: () => void }

function move(animal: Fish | Bird) {
  if ("swim" in animal) {
    animal.swim() // animal: Fish
  } else {
    animal.fly()  // animal: Bird
  }
}
```

---

### Beispiel 4 – Benutzerdefinierter Type Guard (`is`-Syntax)

```js
type Car = { drive: () => void }
type Boat = { sail: () => void }

function isCar(vehicle: Car | Boat): vehicle is Car {
  return (vehicle as Car).drive !== undefined
}

function useVehicle(vehicle: Car | Boat) {
  if (isCar(vehicle)) {
    vehicle.drive() // Typ: Car
  } else {
    vehicle.sail()  // Typ: Boat
  }
}
```

---

### Zusammenfassung

* **Type Guards** = Bedingungen/Funktionen, die Typen präzisieren.
* Varianten:

  * `typeof` (für primitive Typen)
  * `instanceof` (für Klassen)
  * `in` Operator (für Properties)
  * benutzerdefinierte Type Guards (`is`-Syntax)
* Zweck: **sicheres Type Narrowing** in Union Types.

🔗 Quellen:

* [TypeScript Handbook – Narrowing](https://www.typescriptlang.org/docs/handbook/2/narrowing.html)
* [React TS Cheatsheet – Type Guards](https://react-typescript-cheatsheet.netlify.app/docs/basic/troubleshooting/types/#type-guards)

  **[⬆ Наверх](#top)**

23. ### <a name="23"></a> Wie funktioniert der Operator in bei der Typprüfung?

### Der `in`-Operator bei der Typprüfung in TypeScript

**Definition:**
Der **`in`-Operator** prüft, ob ein bestimmtes Property in einem Objekt existiert.
In TypeScript wird er als **Type Guard** genutzt, um zwischen verschiedenen Typen in einer Union zu unterscheiden.

---

### Beispiel 1 – Unterschiedliche Objekt-Typen

```js
type Dog = { bark: () => void }
type Cat = { meow: () => void }

function makeSound(animal: Dog | Cat) {
  if ("bark" in animal) {
    animal.bark() // animal: Dog
  } else {
    animal.meow() // animal: Cat
  }
}
```

➡️ Der `in`-Check sagt TypeScript:

* Wenn `bark` vorhanden ist → Typ ist `Dog`.
* Ansonsten → Typ ist `Cat`.

---

### Beispiel 2 – Optionale Properties

```js
interface User {
  id: number
  name: string
  email?: string
}

function hasEmail(user: User) {
  if ("email" in user) {
    console.log("User hat eine Email:", user.email)
  } else {
    console.log("Keine Email")
  }
}
```

---

### Beispiel 3 – Discriminated Unions

```js
type Circle = { kind: "circle"; radius: number }
type Square = { kind: "square"; side: number }

function area(shape: Circle | Square) {
  if ("radius" in shape) {
    return Math.PI * shape.radius ** 2 // Circle
  } else {
    return shape.side * shape.side     // Square
  }
}
```

---

### Zusammenfassung

* **`in`-Operator** prüft, ob ein Property existiert.
* In TypeScript dient er als **Type Guard** für Union Types.
* Typische Nutzung: Unterscheidung zwischen Objekten mit unterschiedlichen Eigenschaften oder optionalen Feldern.

🔗 Quellen:

* [TypeScript Handbook – Narrowing mit `in`](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-the-in-operator)
* [MDN – in Operator](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/in)

  **[⬆ Наверх](#top)**

24. ### <a name="24"></a> Wie funktioniert typeof in TypeScript?

### `typeof` in TypeScript

**Definition:**
In TypeScript hat `typeof` **zwei unterschiedliche Einsatzmöglichkeiten**:

1. **Zur Laufzeit** → wie in JavaScript, um den Typ eines Wertes zu prüfen.
2. **Zur Compile-Zeit** → um den Typ einer Variablen/Funktion zu extrahieren und wiederzuverwenden.

---

## 1. `typeof` zur Laufzeit (Type Guard)

Verhält sich wie in JavaScript, gibt einen **String** mit dem Typ zurück.
Wird in TypeScript für **Type Narrowing** genutzt.

```js
function printValue(value: string | number) {
  if (typeof value === "string") {
    console.log(value.toUpperCase()) // value: string
  } else {
    console.log(value.toFixed(2))    // value: number
  }
}
```

Mögliche Ergebnisse: `"string"`, `"number"`, `"boolean"`, `"object"`, `"function"`, `"undefined"`, `"symbol"`, `"bigint"`.

---

## 2. `typeof` zur Compile-Zeit (Type Query Operator)

Damit kann man den **Typ einer bestehenden Variable/Funktion** für eine Typdefinition wiederverwenden.

```js
let user = { id: 1, name: "Sergii" }

// Extrahiert den Typ von user
type User = typeof user

const admin: User = { id: 2, name: "Anna" } // ✅ korrekt
```

---

## 3. `typeof` für Funktionen

```js
function add(a: number, b: number) {
  return a + b
}

type AddFunction = typeof add
// AddFunction ist: (a: number, b: number) => number
```

---

### Zusammenfassung

* **Laufzeit (`typeof` als Operator):** gibt den primitiven JS-Typ zurück, nutzbar als Type Guard.
* **Compile-Zeit (`typeof` als Type Query):** extrahiert den Typ einer bestehenden Variablen oder Funktion.
* Vorteil: weniger Code-Duplikation, sicheres Type Narrowing.

🔗 Quellen:

* [TypeScript Handbook – typeof](https://www.typescriptlang.org/docs/handbook/2/typeof-types.html)
* [TypeScript Handbook – Narrowing mit typeof](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#typeof-type-guards)

  **[⬆ Наверх](#top)**

25. ### <a name="25"></a> Wie funktioniert instanceof?

### `instanceof` in TypeScript

**Definition:**
Der Operator **`instanceof`** prüft **zur Laufzeit**, ob ein Objekt von einer bestimmten **Klasse oder einem Konstruktor** erstellt wurde.
In TypeScript wird er als **Type Guard** verwendet, um den Typ innerhalb eines Blocks einzugrenzen (**Type Narrowing**).

---

### Beispiel 1 – Klassenprüfung

```js
class Dog {
  bark() { console.log("Wuff!") }
}

class Cat {
  meow() { console.log("Miau!") }
}

function makeSound(animal: Dog | Cat) {
  if (animal instanceof Dog) {
    animal.bark() // animal: Dog
  } else {
    animal.meow() // animal: Cat
  }
}
```

---

### Beispiel 2 – Mit eingebauten Objekten

```js
function logDate(date: Date | string) {
  if (date instanceof Date) {
    console.log("Datum:", date.toISOString()) // date: Date
  } else {
    console.log("String:", date.toUpperCase()) // date: string
  }
}
```

---

### Beispiel 3 – Nicht für primitive Typen

```js
let value = "Hallo"

console.log(value instanceof String) // ❌ false (Primitives sind keine Instanzen)
```

👉 Für Primitives verwendet man `typeof`, nicht `instanceof`.

---

### Vergleich zu anderen Type Guards

* **`typeof`** → für primitive Typen (`string`, `number`, `boolean`, …).
* **`instanceof`** → für Klassen und Objekte, die mit `new` erstellt wurden.
* **`in`** → für Property-Prüfungen in Objekten.

---

### Zusammenfassung

* **`instanceof`** prüft, ob ein Objekt von einer bestimmten Klasse/Konstruktor stammt.
* Dient als **Type Guard** in Union Types.
* Funktioniert nur bei **Objekten/Klassen**, nicht bei Primitives.

🔗 Quellen:

* [TypeScript Handbook – Narrowing mit `instanceof`](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#instanceof-narrowing)
* [MDN – instanceof](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/instanceof)

  **[⬆ Наверх](#top)**

26. ### <a name="26"></a> Was sind Discriminated Unions (diskriminierte Typen)?

### Discriminated Unions (diskriminierte Typen) in TypeScript

**Definition:**
Ein **Discriminated Union** ist ein **Union Type**, bei dem jede Variante ein gemeinsames, eindeutiges Feld (das sog. **Discriminant**) enthält.
TypeScript kann dadurch den Typ automatisch unterscheiden (**Type Narrowing**).

---

### Beispiel 1 – Shapes

```js
interface Circle {
  kind: "circle"   // Discriminant
  radius: number
}

interface Square {
  kind: "square"   // Discriminant
  side: number
}

type Shape = Circle | Square

function area(shape: Shape): number {
  switch (shape.kind) {
    case "circle":
      return Math.PI * shape.radius ** 2
    case "square":
      return shape.side * shape.side
  }
}
```

➡️ `kind` diskriminiert zwischen `Circle` und `Square`.

---

### Beispiel 2 – API-Status

```js
type ApiResponse =
  | { status: "success"; data: string }
  | { status: "error"; error: Error }
  | { status: "loading" }

function handleResponse(res: ApiResponse) {
  if (res.status === "success") {
    console.log("Data:", res.data)
  } else if (res.status === "error") {
    console.error("Fehler:", res.error.message)
  } else {
    console.log("Lädt...")
  }
}
```

---

### Beispiel 3 – Exhaustive Checking mit `never`

```js
function exhaustiveCheck(x: never): never {
  throw new Error("Unreachable code")
}

function handleShape(shape: Shape) {
  switch (shape.kind) {
    case "circle": return Math.PI * shape.radius ** 2
    case "square": return shape.side * shape.side
    default: return exhaustiveCheck(shape) // ⛔ Compiler-Fehler, falls neuer Typ fehlt
  }
}
```

---

### Vorteile

* Bessere **Typ-Sicherheit** bei Union Types.
* TypeScript erkennt automatisch, welcher Typ in welchem Zweig vorliegt.
* Erleichtert **Fehlerprävention** durch Exhaustive Checks.

---

### Zusammenfassung

* **Discriminated Unions** = Union Types mit einem gemeinsamen Feld (`kind`, `status`, etc.).
* Dienen zur klaren Typunterscheidung.
* Sehr nützlich in **Switch-Statements** und bei **API-Responses** oder **React-Props**.

🔗 Quellen:

* [TypeScript Handbook – Discriminated Unions](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#discriminated-unions)
* [React TS Cheatsheet – Discriminated Unions](https://react-typescript-cheatsheet.netlify.app/docs/advanced/discriminated_unions/)

  **[⬆ Наверх](#top)**

27. ### <a name="27"></a> Was ist der Unterschied zwischen interface und abstract class?

### Unterschied zwischen `interface` und `abstract class` in TypeScript

#### **1. Interface**

* Beschreibt **nur die Struktur** (Vertrag), aber keine Implementierung.
* Enthält **keinen Code**, nur Signaturen (Properties, Methoden).
* Eine Klasse kann mehrere Interfaces implementieren.

```js
interface Flyable {
  fly(): void
}

class Bird implements Flyable {
  fly() {
    console.log("Der Vogel fliegt 🕊️")
  }
}
```

---

#### **2. Abstract Class**

* Kann sowohl **abstrakte Methoden** (ohne Implementierung) als auch **konkrete Methoden** (mit Code) enthalten.
* Kann **Felder** und **Konstruktoren** haben.
* Klassen können nur **eine abstrakte Klasse** erweitern (Einzelvererbung).

```js
abstract class Animal {
  constructor(public name: string) {}

  abstract makeSound(): void // muss implementiert werden

  move(): void {
    console.log(`${this.name} bewegt sich`)
  }
}

class Dog extends Animal {
  makeSound() {
    console.log("Wuff!")
  }
}

const rex = new Dog("Rex")
rex.makeSound() // Wuff!
rex.move()      // Rex bewegt sich
```

---

### **3. Vergleichstabelle**

| Aspekt                 | `interface`                     | `abstract class`                           |
| ---------------------- | ------------------------------- | ------------------------------------------ |
| **Implementierung**    | Keine, nur Vertrag              | Kann Code enthalten                        |
| **Konstruktor**        | ❌ Nein                          | ✅ Ja                                       |
| **Felder mit Werten**  | ❌ Nein                          | ✅ Ja                                       |
| **Abstrakte Methoden** | ✅ Nur Signaturen                | ✅ Ja                                       |
| **Normale Methoden**   | ❌ Nein                          | ✅ Ja                                       |
| **Mehrfachverwendung** | ✅ Mehrere Interfaces pro Klasse | ❌ Nur eine abstrakte Klasse pro Klasse     |
| **Verwendung**         | Für reine Strukturdefinition    | Für Basisklassen mit gemeinsamem Verhalten |

---

### **Wann verwenden?**

* **Interface** → wenn du nur einen Vertrag beschreiben willst (z. B. Props, Data Models, API-Schemas).
* **Abstract Class** → wenn du **gemeinsames Verhalten + Vertrag** für Subklassen definieren willst.

---

### Zusammenfassung

* **`interface`** = reine Struktur, keine Implementierung, unterstützt Mehrfach-Implementierung.
* **`abstract class`** = Kombination aus Vertrag und (teilweiser) Implementierung, mit Konstruktor und Feldern.

🔗 Quellen:

* [TypeScript Handbook – Interfaces](https://www.typescriptlang.org/docs/handbook/2/objects.html)
* [TypeScript Handbook – Classes](https://www.typescriptlang.org/docs/handbook/2/classes.html#abstract-classes)

  **[⬆ Наверх](#top)**

28. ### <a name="28"></a> Wie implementiert man Funktionsüberladungen (function overloads) in TypeScript?

### Funktionsüberladungen (Function Overloads) in TypeScript

**Definition:**
Mit **Function Overloads** kann eine Funktion **mehrere Signaturen** haben, aber nur **eine Implementierung**.
Dadurch können unterschiedliche Argumenttypen oder Rückgabewerte abgebildet werden.

---

### Syntax

1. **Mehrere Signaturen (Overloads)**
2. **Eine gemeinsame Implementierung**

---

### Beispiel 1 – String vs. Number Eingabe

```js
// Overload-Signaturen
function reverse(value: string): string
function reverse(value: number): number

// Implementierung
function reverse(value: string | number): string | number {
  if (typeof value === "string") {
    return value.split("").reverse().join("")
  } else {
    return Number(value.toString().split("").reverse().join(""))
  }
}

console.log(reverse("Sergii")) // iigreS
console.log(reverse(12345))    // 54321
```

➡️ Der Aufrufer sieht die Überladungen (`string → string`, `number → number`),
aber die Implementierung deckt beide Fälle ab.

---

### Beispiel 2 – Mehrere Argumenttypen

```js
function getLength(value: string): number
function getLength(value: any[]): number

function getLength(value: string | any[]): number {
  return value.length
}

console.log(getLength("Hallo"))   // 5
console.log(getLength([1, 2, 3])) // 3
```

---

### Beispiel 3 – Optional und Union

```js
function combine(a: number, b: number): number
function combine(a: string, b: string): string

function combine(a: number | string, b: number | string): number | string {
  if (typeof a === "string" && typeof b === "string") {
    return a + b
  }
  if (typeof a === "number" && typeof b === "number") {
    return a + b
  }
  throw new Error("Ungültige Argumente")
}

console.log(combine(5, 10))      // 15
console.log(combine("Hi ", "TS")) // Hi TS
```

---

### Zusammenfassung

* **Function Overloads** = mehrere Signaturen, eine Implementierung.
* Vorteil: bessere Typ-Sicherheit und IntelliSense.
* Syntax: **Signaturen oben**, **Implementierung unten**.

🔗 Quellen:

* [TypeScript Handbook – Functions (Overloads)](https://www.typescriptlang.org/docs/handbook/2/functions.html#function-overloads)
* [MDN – Funktionen in JS (Grundlage)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Functions)

  **[⬆ Наверх](#top)**

29. ### <a name="29"></a> Was sind Index Signatures?

### Index Signatures in TypeScript

**Definition:**
Eine **Index Signature** erlaubt es, die Typen von Objekten zu beschreiben, deren Schlüssel **nicht im Voraus bekannt** sind.
Damit sagt man: *„Dieses Objekt kann beliebig viele Properties haben, und ihre Schlüssel/Werte haben einen bestimmten Typ.“*

---

### Beispiel 1 – Einfache Index Signature

```js
interface StringArray {
  [index: number]: string
}

const names: StringArray = ["Anna", "Tom", "Sergii"]
console.log(names[0]) // Anna
```

➡️ Jeder numerische Index (`number`) muss einen `string` liefern.

---

### Beispiel 2 – String-Keys

```js
interface Dictionary {
  [key: string]: string
}

const translations: Dictionary = {
  hello: "Hallo",
  bye: "Tschüss"
}

console.log(translations["hello"]) // Hallo
```

---

### Beispiel 3 – Mischung mit festen Properties

```js
interface User {
  id: number
  name: string
  [key: string]: string | number // erlaubt zusätzliche Properties
}

const u: User = {
  id: 1,
  name: "Sergii",
  role: "Admin"
}
```

---

### Beispiel 4 – Readonly Index Signature

```js
interface ReadonlyArrayLike {
  readonly [index: number]: string
}

const arr: ReadonlyArrayLike = ["A", "B"]
// arr[0] = "X" // ❌ Fehler: readonly
```

---

### Einschränkungen

* Der Werttyp der Index Signature muss **alle festen Properties** abdecken.

  ```js
  interface Bad {
    name: string
    [key: string]: number // ❌ Fehler, da name: string nicht kompatibel
  }
  ```

---

### Zusammenfassung

* **Index Signatures** = definieren Typen für unbekannte Schlüssel/Werte.
* Syntax: `[key: string]: WertTyp` oder `[index: number]: WertTyp`.
* Einsatz: Dictionaries, flexible Objekte, Maps.

🔗 Quellen:

* [TypeScript Handbook – Index Signatures](https://www.typescriptlang.org/docs/handbook/2/objects.html#index-signatures)
* [React TS Cheatsheet – Index Signatures](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example#index-signatures)

  **[⬆ Наверх](#top)**

30. ### <a name="30"></a> Was ist keyof und wofür wird es verwendet?

### `keyof` in TypeScript

**Definition:**
Der **`keyof` Operator** erzeugt einen Typ, der alle **Schlüssel** (Property-Namen) eines Objekttyps als **Union Type** enthält.

---

### Beispiel 1 – Einfaches Objekt

```js
interface User {
  id: number
  name: string
  isAdmin: boolean
}

type UserKeys = keyof User
// UserKeys = "id" | "name" | "isAdmin"
```

➡️ `keyof` extrahiert `"id" | "name" | "isAdmin"` als Union.

---

### Beispiel 2 – Nutzung in Funktionen

```js
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key]
}

const user: User = { id: 1, name: "Sergii", isAdmin: true }

const name = getProperty(user, "name")   // string
const admin = getProperty(user, "isAdmin") // boolean
// getProperty(user, "age") ❌ Fehler: "age" existiert nicht in User
```

➡️ Vorteil: **sichere Property-Zugriffe** ohne Magic Strings.

---

### Beispiel 3 – Mit `typeof`

```js
const config = {
  url: "/api",
  timeout: 5000
}

type ConfigKeys = keyof typeof config
// "url" | "timeout"
```

---

### Beispiel 4 – Kombination mit Mapped Types

```js
type ReadonlyUser = {
  readonly [K in keyof User]: User[K]
}

// Alle Properties von User werden readonly
```

---

### Zusammenfassung

* **`keyof`** = erzeugt Union der Schlüssel eines Typs.
* Verwendung: generische Funktionen, sichere Property-Zugriffe, Mapped Types.
* Typische Kombination: `keyof`, `typeof`, `in`.

🔗 Quellen:

* [TypeScript Handbook – keyof](https://www.typescriptlang.org/docs/handbook/2/keyof-types.html)
* [React TS Cheatsheet – keyof usage](https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase#keyof-and-typeof)

  **[⬆ Наверх](#top)**  

31. ### <a name="31"></a> Wie funktioniert der Operator as?

### Der `as` Operator in TypeScript

**Definition:**
Der **`as` Operator** wird für **Type Assertions (Typumwandlungen)** verwendet.
Damit sagt man dem Compiler: *„Vertraue mir, dieser Wert hat einen bestimmten Typ.“*
Er ändert nichts am **Laufzeitwert**, sondern nur an der **Typprüfung** von TypeScript.

---

### Beispiel 1 – Einfache Typumwandlung

```js
let value: unknown = "Hallo TypeScript"
let strLength: number = (value as string).length

console.log(strLength) // 16
```

➡️ Der Compiler behandelt `value` innerhalb der Klammern als `string`.

---

### Beispiel 2 – DOM-Manipulation

```js
const input = document.querySelector("input") as HTMLInputElement
input.value = "Sergii"
```

➡️ Ohne `as` kennt TypeScript nur den Typ `Element | null`.
Mit `as` wird er auf `HTMLInputElement` eingeschränkt.

---

### Beispiel 3 – Union Type Spezifizierung

```js
type Bird = { fly: () => void }
type Fish = { swim: () => void }

let pet: Bird | Fish = { swim: () => console.log("Schwimmt") }

;(pet as Fish).swim() // ✅ erlaubt
```

---

### Beispiel 4 – Doppelte Typumwandlung (Edge Case)

```js
let num: number = 10
let str = num as unknown as string // ❌ unsicher, aber manchmal genutzt
```

---

### Wichtige Hinweise

* `as` ist **keine Typkonvertierung** wie in anderen Sprachen (z. B. `int → string`),
  sondern nur ein Hinweis für den Compiler.
* Missbrauch kann zu **Laufzeitfehlern** führen, wenn man falsche Annahmen macht.

---

### Zusammenfassung

* **`as` Operator** = Type Assertion, ändert nur den Typ für den Compiler, nicht den Wert zur Laufzeit.
* Typische Nutzung: DOM-Elemente, Union Types, `unknown` → spezifischer Typ.
* Vorsicht: kann Sicherheit unterlaufen, sollte sparsam und bewusst eingesetzt werden.

🔗 Quellen:

* [TypeScript Handbook – Type Assertions](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-assertions)
* [MDN – DOM querySelector](https://developer.mozilla.org/ru/docs/Web/API/Document/querySelector)

  **[⬆ Наверх](#top)**

32. ### <a name="32"></a> Was ist der Unterschied zwischen as const und einem normalen const?

### Unterschied zwischen `const` und `as const` in TypeScript

---

#### **1. Normales `const` (JavaScript/TypeScript)**

* Bedeutet, dass die **Variable nicht neu zugewiesen** werden kann.
* Der Wert selbst bleibt aber oft **mutierbar** (bei Objekten/Arrays).
* Typ wird **verallgemeinert** (z. B. `string`, `number`).

```js
const role = "admin"
// Typ: string (kein Literal), Wert: "admin"
```

---

#### **2. `as const` (TypeScript)**

* Erzwingt eine **Literal Inferenz**:

  * Der Wert bekommt den **engsten möglichen Typ** (statt `string` → `"admin"`).
* Macht **alle Properties readonly** (bei Objekten und Arrays).

```js
const role = "admin" as const
// Typ: "admin" (Literal), Wert: "admin"
```

---

### Beispiele

#### **Beispiel 1 – String vs. Literal**

```js
const status = "success"
// Typ: string

const status2 = "success" as const
// Typ: "success" (Literal)
```

---

#### **Beispiel 2 – Objekte**

```js
const user = { id: 1, role: "admin" }
// Typ: { id: number; role: string }

const user2 = { id: 1, role: "admin" } as const
// Typ: { readonly id: 1; readonly role: "admin" }
```

---

#### **Beispiel 3 – Arrays**

```js
const numbers = [1, 2, 3]
// Typ: number[]

const numbers2 = [1, 2, 3] as const
// Typ: readonly [1, 2, 3]
```

---

### **Vergleichstabelle**

| Aspekt           | `const`                              | `as const`                              |
| ---------------- | ------------------------------------ | --------------------------------------- |
| Variablenbindung | unveränderlich                       | unveränderlich                          |
| Typ-Inferenz     | allgemeiner Typ (`string`, `number`) | Literal-Typ (`"admin"`, `1`)            |
| Objekte/Arrays   | veränderbar                          | `readonly`                              |
| Einsatzgebiet    | normales JS-Verhalten                | für präzise Typisierung & Immutabilität |

---

### Zusammenfassung

* **`const`** = normale Konstantenbindung, Typ wird verallgemeinert.
* **`as const`** = engste mögliche Typen (Literal), zusätzlich `readonly`.
* Nützlich für:

  * **Discriminated Unions**
  * **Objekte/Arrays als feste Konfigurationen**
  * **Props in React**

🔗 Quellen:

* [TypeScript Handbook – const assertions](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-inference)
* [React TS Cheatsheet – as const](https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase#literal-types-as-const)

  **[⬆ Наверх](#top)**

33. ### <a name="33"></a> Was macht der Operator satisfies (TS 4.9+)?

### Der `satisfies` Operator in TypeScript (seit 4.9)

**Definition:**
Der Operator **`satisfies`** prüft, ob ein Wert einen bestimmten Typ erfüllt (**Type Constraint**), **ohne** den engeren Typ des Werts zu verlieren.
Er ist eine Art *Kompromiss zwischen Type Assertion (`as`) und direkter Typannotation (`: Type`)*.

---

### Beispiel 1 – Normale Typannotation

```ts
type Role = "admin" | "user" | "guest"

const role: Role = "admin"
// Typ von role: "admin" | "user" | "guest"
```

👉 Nach der Annotation verliert `role` den spezifischen Literal-Typ `"admin"` und wird zum Union-Type.

---

### Beispiel 2 – Mit `as` (unsafe)

```ts
const role = "admin" as Role
// Typ von role: Role ("admin" | "user" | "guest")
```

👉 Compiler nimmt an, dass es passt – aber kein echter Check, da `as` nur „erzwingt“.

---

### Beispiel 3 – Mit `satisfies` ✅

```ts
type Role = "admin" | "user" | "guest"

const role = "admin" satisfies Role
// Typ von role: "admin" (Literal bleibt erhalten)
// Compiler prüft: "admin" ist Teil von Role → ✅ korrekt
```

👉 Vorteil: Wert bleibt **eng getypt** (`"admin"`) und erfüllt trotzdem die Bedingung `Role`.

---

### Beispiel 4 – Praktisch bei Objekten

```ts
type Config = {
  url: string
  method: "GET" | "POST"
}

const config = {
  url: "/api",
  method: "GET"
} satisfies Config

// Typ von config.method = "GET" (Literal, nicht nur "GET" | "POST")
```

👉 Mit `: Config` wäre `config.method` nur `"GET" | "POST"`.
👉 Mit `satisfies` bleibt es `"GET"`.

---

### Beispiel 5 – Exhaustiveness Checks

```ts
type Status = "success" | "error" | "loading"

const states = ["success", "error", "loading"] satisfies Status[]
// Typ: ("success" | "error" | "loading")[]
// Compiler prüft: alle Elemente gehören zu Status
```

---

### Zusammenfassung

* **`satisfies`** prüft, ob ein Wert zu einem Typ passt, **ohne den präzisen Typ zu verlieren**.
* Unterschied zu anderen Varianten:

  * `: Type` → Typ wird erweitert/verallgemeinert.
  * `as Type` → Compiler vertraut blind, keine echte Prüfung.
  * `satisfies Type` → Typprüfung + Beibehaltung der Literaltypen.

🔗 Quellen:

* [TypeScript 4.9 – satisfies Operator](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html#the-satisfies-operator)
* [React TS Cheatsheet – satisfies](https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase#satisfies-operator)

  **[⬆ Наверх](#top)**

34. ### <a name="34"></a> Was sind Assertion Functions?

### Assertion Functions in TypeScript

**Definition:**
Eine **Assertion Function** ist eine spezielle Funktion, die TypeScript mitteilt:
*"Wenn diese Funktion erfolgreich zurückkehrt, kannst du davon ausgehen, dass eine bestimmte Bedingung erfüllt ist."*
→ Sie werden mit dem Rückgabetyp `asserts` deklariert und dienen der **Typprüfung** (Type Narrowing).

---

### Beispiel 1 – Einfache Assertion Function

```ts
function assertIsString(value: unknown): asserts value is string {
  if (typeof value !== "string") {
    throw new Error("Wert ist kein String")
  }
}

function printUppercase(value: unknown) {
  assertIsString(value) 
  // Ab hier: value hat Typ string
  console.log(value.toUpperCase())
}
```

➡️ Ohne `assertIsString` müsste man jedes Mal manuell prüfen.

---

### Beispiel 2 – Non-Null Assertion

```ts
function assertNotNull<T>(value: T): asserts value is NonNullable<T> {
  if (value === null || value === undefined) {
    throw new Error("Wert darf nicht null oder undefined sein")
  }
}

function process(value?: string | null) {
  assertNotNull(value)
  // Ab hier: value ist string
  console.log(value.trim())
}
```

---

### Beispiel 3 – Für komplexe Typen

```ts
type User = { id: number; name: string }

function assertIsUser(obj: any): asserts obj is User {
  if (typeof obj !== "object" || typeof obj.id !== "number" || typeof obj.name !== "string") {
    throw new Error("Kein gültiger User")
  }
}

const data: unknown = { id: 1, name: "Sergii" }

assertIsUser(data)
// Ab hier: data hat Typ User
console.log(data.name.toUpperCase())
```

---

### Vorteile

* Verhindern unnötige Type Assertions (`as`).
* Ermöglichen **saubere Typ Narrowing**.
* Praktisch für **Input-Validierung, API-Responses, Guards in React/Express**.

---

### Zusammenfassung

* **Assertion Functions** = Funktionen mit Rückgabetyp `asserts`, die Typen validieren.
* Nutzen: automatische Typ-Einschränkung, wenn die Assertion erfolgreich ist.
* Typische Form: `asserts value is Type`.

🔗 Quellen:

* [TypeScript Handbook – Assertion Functions](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#assertion-functions)
* [React TS Cheatsheet – Type Guards & Assertions](https://react-typescript-cheatsheet.netlify.app/docs/basic/troubleshooting/types/#user-defined-type-guards)

  **[⬆ Наверх](#top)**

35. ### <a name="35"></a> Was ist der Unterschied zwischen struktureller Typisierung (structural typing) und nominaler Typisierung (nominal typing)?

### Unterschied zwischen **struktureller Typisierung** und **nominaler Typisierung**

---

#### **1. Strukturelle Typisierung (Structural Typing)**

* In **TypeScript** verwendet.
* Zwei Typen sind **kompatibel**, wenn ihre **Struktur** (Shape) gleich ist – unabhängig vom Namen.
* „Duck Typing“: *Wenn es aussieht wie eine Ente und quakt wie eine Ente, ist es eine Ente.*

**Beispiel:**

```ts
interface Point {
  x: number
  y: number
}

interface Coordinate {
  x: number
  y: number
}

let p: Point = { x: 10, y: 20 }
let c: Coordinate = { x: 30, y: 40 }

p = c // ✅ erlaubt, gleiche Struktur
```

---

#### **2. Nominale Typisierung (Nominal Typing)**

* In Sprachen wie **Java, C#** üblich.
* Typen sind nur dann kompatibel, wenn sie **explizit denselben Namen** oder dieselbe Vererbung haben.
* Die Struktur allein reicht nicht.

**Beispiel (in TS simuliert):**

```ts
type USD = number & { readonly brand: unique symbol }
type EUR = number & { readonly brand: unique symbol }

let usd: USD = 10 as USD
let eur: EUR = 20 as EUR

usd = eur // ❌ Fehler, trotz gleicher Struktur (Nominalisierung durch unique symbol)
```

---

### Vergleich

| Merkmal             | Strukturell (TS)                        | Nominal (Java, C#)      |
| ------------------- | --------------------------------------- | ----------------------- |
| Vergleichsgrundlage | Struktur (Properties & Methoden)        | Name/Erklärung des Typs |
| Flexibilität        | Hoch                                    | Niedrig                 |
| Fehleranfälligkeit  | Kann ungewollte Kompatibilität zulassen | Strenger, sicherer      |
| Beispielsprachen    | TypeScript, Go                          | Java, C#, Rust          |

---

### Zusammenfassung

* **Structural Typing (TS):** Kompatibilität hängt nur von der **Form** ab.
* **Nominal Typing:** Kompatibilität hängt vom **Namen/Erklärung** ab.
* TypeScript ist **strukturell typisiert**, man kann aber nominale Typisierung mit Tricks (`unique symbol`) erzwingen.

🔗 Quellen:

* [TypeScript Handbook – Structural Typing](https://www.typescriptlang.org/docs/handbook/type-compatibility.html)
* [MDN – TypeScript Type System](https://www.typescriptlang.org/docs/)

  **[⬆ Наверх](#top)**

36. ### <a name="36"></a> Was sind Deklarationsdateien (.d.ts)?

### Deklarationsdateien (`.d.ts`) in TypeScript

**Definition:**
Eine **Deklarationsdatei** (`.d.ts`) enthält **nur Typinformationen** (Signaturen, Interfaces, Typen), aber **keinen ausführbaren Code**.
Sie dient dazu, JavaScript-Bibliotheken oder bereits kompilierte TypeScript-Module für den TypeScript-Compiler **typisiert verfügbar** zu machen.

---

### Eigenschaften

* Endung: **`.d.ts`**
* Enthält keine Implementierungen → nur Typdefinitionen.
* Wird automatisch von TypeScript verwendet, wenn eine Bibliothek Typen mitliefert.
* Häufig im Verzeichnis `@types/` (z. B. aus **DefinitelyTyped**).

---

### Beispiel 1 – Eigene Deklarationsdatei

`math.d.ts`:

```ts
declare module "math-lib" {
  export function add(a: number, b: number): number
  export const PI: number
}
```

Nutzung:

```ts
import { add, PI } from "math-lib"

console.log(add(2, 3))  // 5
console.log(PI)         // number
```

---

### Beispiel 2 – Globale Deklaration

```ts
// global.d.ts
declare global {
  interface Window {
    myAppVersion: string
  }
}
```

Nutzung:

```ts
console.log(window.myAppVersion)
```

---

### Beispiel 3 – Typen für externe Bibliotheken

Wenn eine JS-Library keine Typen mitliefert:

```bash
npm install @types/lodash --save-dev
```

👉 Installiert Deklarationsdateien von **DefinitelyTyped**.

---

### Zusammenfassung

* **`.d.ts` Dateien** = Typdefinitionen ohne Implementierung.
* Nutzen: Typprüfung und IntelliSense für **JS-Bibliotheken** oder eigene APIs.
* Typische Orte:

  * Bibliotheken mitgeliefert (`node_modules/@types/`)
  * Eigene Projekte (`global.d.ts`)

🔗 Quellen:

* [TypeScript Handbook – Declaration Files](https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html)
* [DefinitelyTyped Repository](https://github.com/DefinitelyTyped/DefinitelyTyped)

  **[⬆ Наверх](#top)**

37. ### <a name="37"></a> Wie bindet man eine externe JS-Bibliothek ohne Typen ein?

### Externe JS-Bibliothek **ohne Typen** in TypeScript einbinden

#### 1) Prüfen, ob Typen existieren

```bash
npm i -D @types/<libname>
```

Wenn vorhanden → normal importieren. Wenn **nicht** vorhanden, weiter mit 2–5.

---

#### 2) Schneller Start: eigenes **Shims**-Modul (`global.d.ts` oder `types/<lib>.d.ts`)

```ts
// types/untyped-lib.d.ts
declare module "untyped-lib" {
  // minimaler Start – alles als any
  const api: any
  export default api
}
```

Verwendung:

```js
import lib from "untyped-lib"
lib.doSomething() // Typprüfung ausgesetzt (any)
```

---

#### 3) Besser: **gezielte Typen** statt `any`

```ts
// types/untyped-lib.d.ts
declare module "untyped-lib" {
  export interface Options {
    retry?: number
    baseUrl: string
  }
  export function createClient(opts: Options): {
    get(path: string): Promise<string>
    post<T>(path: string, body: T): Promise<void>
  }
}
```

```js
import { createClient } from "untyped-lib"

const client = createClient({ baseUrl: "/api", retry: 2 })
const text = await client.get("/status")
```

---

#### 4) Globales Script (CDN) typisieren

```ts
// global.d.ts
declare global {
  interface Window {
    MyLib: {
      version: string
      init(config: { key: string }): void
    }
  }
}
export {} // macht die Datei zum Modul
```

```js
// nach <script src=".../mylib.js"></script>
window.MyLib.init({ key: "abc" })
```

---

#### 5) Übergangsweise absichern: `unknown` + Laufzeit-Guards (statt `any`)

```js
import lib from "untyped-lib"

function isClient(x: unknown): x is { get: (p: string) => Promise<string> } {
  return !!x && typeof (x as any).get === "function"
}

const client: unknown = lib.createClient?.({ baseUrl: "/api" })
if (isClient(client)) {
  const s = await client.get("/health")
}
```

---

#### 6) Notfalls (kurzfristig) unterdrücken

```js
// @ts-ignore: untyped third-party export
import lib from "untyped-lib"
```

> Nur punktuell verwenden; besser früh eigene `.d.ts` anlegen.

---

#### 7) tsconfig-Hinweise

* Eigene Typen einbinden: `"typeRoots": ["./types", "./node_modules/@types"]`
* Keine Fremdtypfehler beim Build: `"skipLibCheck": true` (optional, nicht sicherheitsrelevant)

---

### Zusammenfassung

* Falls keine offiziellen Typen existieren: **eigene `.d.ts`** schreiben.
* Start mit einfachem `declare module`, dann **gezielt typisieren** (Interfaces/Funktionssignaturen).
* Für globale Skripte: **`declare global`**.
* **`unknown` + Type Guards** statt `any` für mehr Sicherheit.
* `@ts-ignore` nur ausnahmsweise.

🔗 Quellen:

* [TypeScript Docs – Declaration Files](https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html)
* [TypeScript Docs – Modules & `declare module`](https://www.typescriptlang.org/docs/handbook/modules.html)
* [React TypeScript Cheatsheet – Working with 3rd-Party Libs](https://react-typescript-cheatsheet.netlify.app/docs/basic/troubleshooting/types/#third-party-libraries)
* [MDN – `window`](https://developer.mozilla.org/ru/docs/Web/API/Window)

  **[⬆ Наверх](#top)**

38. ### <a name="38"></a> Was sind Ambient Declarations (declare)?

### Ambient Declarations (`declare`) in TypeScript

**Definition:**
Ambient Declarations sind **Typdefinitionen für bereits existierenden Code** (meist JavaScript), damit der TypeScript-Compiler weiß, welche Variablen, Funktionen oder Module es gibt – auch wenn sie **nicht in TypeScript implementiert** sind.
👉 Sie enthalten **nur Typinformationen**, aber keine Implementierungen.

---

### 1. Globale Variablen deklarieren

```ts
// global.d.ts
declare const VERSION: string
```

Nutzung:

```ts
console.log(VERSION) // Compiler weiß: VERSION ist string
```

---

### 2. Funktionen deklarieren

```ts
declare function logMessage(message: string): void

logMessage("Hallo") // gültig, auch ohne Implementierung in TS
```

---

### 3. Klassen deklarieren

```ts
declare class Person {
  constructor(name: string)
  greet(): void
}

let p = new Person("Sergii")
p.greet()
```

---

### 4. Module deklarieren

```ts
// math-lib.d.ts
declare module "math-lib" {
  export function add(a: number, b: number): number
}
```

Nutzung:

```ts
import { add } from "math-lib"
console.log(add(2, 3))
```

---

### 5. Namespace / Global erweitern

```ts
declare namespace NodeJS {
  interface ProcessEnv {
    NODE_ENV: "development" | "production"
  }
}
```

---

### Wann verwendet?

✅ Typische Einsatzfälle:

* **Externe JS-Bibliotheken ohne Typen** (eigene `.d.ts`).
* **Globale Variablen/Objekte** (z. B. `window`, `process`).
* **Erweiterung von bestehenden Typen** (z. B. Express `Request`).

---

### Zusammenfassung

* **Ambient Declarations (`declare`)** = reine Typinfos ohne Code.
* Nutzen: Beschreiben von vorhandenen Variablen, Funktionen, Klassen oder Modulen.
* Typische Orte: **`.d.ts`-Dateien**, Third-Party-Libs, globale Variablen.

🔗 Quellen:

* [TypeScript Handbook – Declaration Files](https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html)
* [TypeScript Handbook – Ambient Declarations](https://www.typescriptlang.org/docs/handbook/declaration-files/by-example.html)

  **[⬆ Наверх](#top)**

39. ### <a name="39"></a> Was ist strict mode in TypeScript?

### Strict Mode in TypeScript

**Definition:**
Der **Strict Mode** ist eine Sammlung von Compiler-Optionen in TypeScript, die die **strengste Typprüfung** aktivieren.
Er wird mit `"strict": true` in der `tsconfig.json` eingeschaltet.

---

### Enthaltene Optionen (ab Werk in `strict` enthalten)

1. **`strictNullChecks`**

   * `null` und `undefined` müssen explizit behandelt werden.

   ```ts
   let name: string = "Sergii"
   name = null // ❌ Fehler bei strictNullChecks
   ```

2. **`noImplicitAny`**

   * Variablen oder Parameter ohne Typ dürfen nicht automatisch `any` sein.

   ```ts
   function log(msg) { // ❌ Fehler
     console.log(msg)
   }
   ```

3. **`strictBindCallApply`**

   * Typprüfung für Methoden wie `bind`, `call`, `apply`.

4. **`strictFunctionTypes`**

   * Strengere Überprüfung bei Funktionszuweisungen.

5. **`strictPropertyInitialization`**

   * Klassen-Eigenschaften müssen im Konstruktor oder direkt initialisiert werden.

   ```ts
   class User {
     name: string // ❌ Fehler ohne Initialisierung
     constructor(name: string) {
       this.name = name // ✅
     }
   }
   ```

6. **`alwaysStrict`**

   * Alle Dateien werden im **JavaScript Strict Mode** kompiliert (`"use strict"`).

---

### Vorteile

* Weniger Laufzeitfehler durch strengere Typprüfung.
* Sicherere und besser wartbare Codebasis.
* Erhöht Codequalität besonders in großen Projekten.

---

### Zusammenfassung

* **Strict Mode** (`"strict": true`) = aktiviert alle wichtigen Sicherheitsprüfungen des Compilers.
* Beinhaltet u. a. `strictNullChecks`, `noImplicitAny`, `strictPropertyInitialization`.
* Ziel: maximale Typ-Sicherheit und Fehlervermeidung.

🔗 Quellen:

* [TypeScript Handbook – Strict Mode](https://www.typescriptlang.org/tsconfig#strict)
* [TSConfig Reference – Strict Options](https://www.typescriptlang.org/tsconfig#strictNullChecks)

  **[⬆ Наверх](#top)**

40. ### <a name="40"></a> Wozu dient strictNullChecks?

### `strictNullChecks` in TypeScript

**Definition:**
Die Option **`strictNullChecks`** erzwingt, dass `null` und `undefined` **nicht automatisch jedem Typ zugewiesen** werden dürfen.
👉 Ohne diese Option: `null` und `undefined` sind **Teil aller Typen**.
👉 Mit dieser Option: sie müssen **explizit** erlaubt werden (`| null`, `| undefined`).

---

### Beispiel 1 – Ohne `strictNullChecks` (unsicher)

```ts
let name: string = "Sergii"
name = null       // ✅ erlaubt (unsicher)
```

---

### Beispiel 2 – Mit `strictNullChecks: true` (sicher)

```ts
let name: string = "Sergii"
name = null       // ❌ Fehler: null nicht zuweisbar zu string

let safeName: string | null = "Sergii"
safeName = null   // ✅ erlaubt
```

---

### Beispiel 3 – Funktionen

```ts
function greet(user: string | null) {
  if (user !== null) {
    console.log("Hallo", user.toUpperCase())
  }
}

greet(null) // ✅ funktioniert, sicher geprüft
```

---

### Beispiel 4 – Optional Properties

```ts
interface User {
  id: number
  email?: string
}

function printEmail(user: User) {
  // user.email: string | undefined
  if (user.email) {
    console.log(user.email.toUpperCase())
  }
}
```

---

### Zusammenfassung

* **`strictNullChecks`** verhindert, dass `null` und `undefined` stillschweigend überall zugewiesen werden können.
* Erzwingt **explizite Behandlung** von `null` und `undefined`.
* Vorteil: weniger `Cannot read property of undefined`-Fehler zur Laufzeit.

🔗 Quellen:

* [TypeScript Handbook – strictNullChecks](https://www.typescriptlang.org/tsconfig#strictNullChecks)
* [Everyday Types – null & undefined](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#null-and-undefined)

  **[⬆ Наверх](#top)**  

41. ### <a name="41"></a> Wie typisiert man Parameter und Rückgabewerte von Funktionen?

### Funktionen typisieren: Parameter & Rückgabewerte

#### 1) Basis: Parameter- und Rückgabetyp

```js
// ESM-Export
export function add(a: number, b: number): number {
  return a + b
}
```

#### 2) Arrow Functions

```js
export const toUpper = (s: string): string => s.toUpperCase()
```

#### 3) Optional-, Default- und Rest-Parameter

```js
export function greet(name: string, title?: string): string {
  return title ? `${title} ${name}` : `Hallo ${name}`
}

export function pow(base: number, exp: number = 2): number {
  return base ** exp
}

export function sum(...nums: number[]): number {
  return nums.reduce((acc, n) => acc + n, 0)
}
```

#### 4) Void, Never, Union/Unknown in Signaturen

```js
export function log(msg: string): void {
  console.log(msg) // kein Rückgabewert
}

export function fail(message: string): never {
  throw new Error(message) // kehrt nie zurück
}

export function parseJson(json: string): unknown {
  return JSON.parse(json) // Callsite muss narrowen
}
```

#### 5) Funktions-Typen (Alias/Interface)

```js
export type Comparator<T> = (a: T, b: T) => number

export interface Fetcher {
  (url: string): Promise<string>
}

export const byLength: Comparator<string> = (a, b) => a.length - b.length
```

#### 6) Generische Funktionen

```js
export function identity<T>(value: T): T {
  return value
}

export function pick<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key]
}
```

#### 7) Async/Promise-Rückgaben

```js
export async function getText(url: string): Promise<string> {
  const res = await fetch(url)
  return res.text()
}
```

#### 8) Overloads (mehrere Signaturen, eine Implementierung)

```js
export function len(x: string): number
export function len<T>(x: T[]): number
export function len(x: string | unknown[]): number {
  return (x as any).length
}
```

#### 9) Kontext: React-Event-Handler (häufig im Frontend)

```js
// Beispiel: React + TS (ESM)
import type { ChangeEvent } from "react"

export const onChange = (e: ChangeEvent<HTMLInputElement>): void => {
  console.log(e.currentTarget.value)
}
```

---

### Zusammenfassung

* Parameter werden nach dem Namen, Rückgabewerte nach dem Parameterblock typisiert: `fn(a: A, b: B): R`.
* Verwende optionale (`?`), Default- und Rest-Parameter je nach Bedarf.
* Nutze `void`/`never` zielgerichtet; für unbekannte Rückgaben `unknown` + Narrowing.
* Funktions-Typen per **Type Alias** oder **Call-Signature in Interfaces**; Generics für Wiederverwendbarkeit.
* Overloads: mehrere Signaturen, **eine** Implementierung.
* In React Events streng typisieren (z. B. `ChangeEvent<HTMLInputElement>`).

**Quellen:**

* [TypeScript Docs – Functions](https://www.typescriptlang.org/docs/handbook/2/functions.html)
* [TypeScript Docs – Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
* [React TypeScript Cheatsheet – Event Handling](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/event_handling/)
* [MDN – Functions (JS-Grundlagen)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Functions)
* [React Docs](https://react.dev/)

  **[⬆ Наверх](#top)**

42. ### <a name="42"></a> Was sind optionale Parameter in Funktionen?

### Optionale Parameter in TypeScript-Funktionen

**Definition:**
Ein **optionaler Parameter** ist ein Funktionsparameter, der beim Aufruf **nicht zwingend angegeben** werden muss.
Man kennzeichnet ihn mit einem **Fragezeichen (`?`)** nach dem Parameternamen.

---

### Beispiel 1 – Einfacher optionaler Parameter

```ts
export function greet(name: string, title?: string): string {
  return title ? `${title} ${name}` : `Hallo ${name}`
}

greet("Sergii")            // Hallo Sergii
greet("Sergii", "Herr")    // Herr Sergii
```

➡️ `title` ist optional (`string | undefined`).

---

### Beispiel 2 – Kombination mit Default-Werten

```ts
export function pow(base: number, exp: number = 2): number {
  return base ** exp
}

pow(3)      // 9
pow(3, 3)   // 27
```

➡️ Unterschied: `?` → kann fehlen, `= Default` → hat immer einen Wert.

---

### Beispiel 3 – Mehrere optionale Parameter

```ts
export function createUser(id: number, name?: string, age?: number) {
  return { id, name, age }
}

createUser(1)                // { id: 1 }
createUser(2, "Anna")        // { id: 2, name: "Anna" }
createUser(3, "Tom", 25)     // { id: 3, name: "Tom", age: 25 }
```

---

### Einschränkungen

* Optionale Parameter müssen **am Ende der Parameterliste** stehen.
* Sie sind implizit `Typ | undefined`.

---

### Zusammenfassung

* **Optionale Parameter** (`param?: Type`) = Argumente, die beim Funktionsaufruf nicht zwingend übergeben werden müssen.
* Standardmäßig sind sie `Type | undefined`.
* Typischer Einsatz: flexible APIs, optionale Konfigurationen.

🔗 Quellen:

* [TypeScript Handbook – Functions](https://www.typescriptlang.org/docs/handbook/2/functions.html#optional-parameters)
* [MDN – Functions](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Functions)

  **[⬆ Наверх](#top)**

43. ### <a name="43"></a> Wie deklariert man Standardwerte für Parameter mit Typisierung?

### Standardwerte (Default Parameter) mit Typisierung in TypeScript

**Definition:**
Ein **Default-Parameter** ist ein Funktionsparameter, der einen **Standardwert** erhält, falls kein Argument übergeben wird.
In TypeScript wird der Typ entweder automatisch aus dem Standardwert **inferred** oder explizit angegeben.

---

### Beispiel 1 – Automatische Typinferenz

```ts
export function greet(name: string, title = "Herr"): string {
  return `${title} ${name}`
}

greet("Sergii")          // Herr Sergii
greet("Sergii", "Dr.")   // Dr. Sergii
```

➡️ `title` wird automatisch als `string` typisiert, weil der Standardwert `"Herr"` ist.

---

### Beispiel 2 – Explizite Typannotation

```ts
export function pow(base: number, exp: number = 2): number {
  return base ** exp
}

pow(3)    // 9
pow(3, 3) // 27
```

➡️ `exp: number = 2` → expliziter Typ + Default-Wert.

---

### Beispiel 3 – Union-Typ mit Default

```ts
type Role = "admin" | "user" | "guest"

export function createUser(name: string, role: Role = "user") {
  return { name, role }
}

createUser("Sergii")          // role = "user"
createUser("Anna", "admin")   // role = "admin"
```

---

### Beispiel 4 – Kombination mit Optionalem Parameter (selten nötig)

```ts
export function log(msg?: string, level: "info" | "error" = "info") {
  console.log(`[${level}]`, msg ?? "leer")
}
```

---

### Regeln

* Parameter mit Default-Werten sind **implizit optional**.
* Sie müssen nicht am Ende der Parameterliste stehen (anders als `?`).
* Typ wird **vom Wert oder Annotation** bestimmt.

---

### Zusammenfassung

* Default-Parameter = `param: Typ = Wert`.
* Typ wird entweder **inferred** oder **explizit angegeben**.
* Vorteil: klare Signaturen, weniger `undefined`.

🔗 Quellen:

* [TypeScript Handbook – Functions](https://www.typescriptlang.org/docs/handbook/2/functions.html#optional-parameters)
* [MDN – Default Parameters](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Default_parameters)

  **[⬆ Наверх](#top)**

44. ### <a name="44"></a> Was sind Rest-Parameter und wie typisiert man sie?

### Rest-Parameter in TypeScript

**Definition:**
Rest-Parameter (`...`) erlauben es, **eine variable Anzahl von Argumenten** an eine Funktion zu übergeben.
Sie werden in TypeScript als **Array eines Typs** typisiert.

---

### Beispiel 1 – Einfache Typisierung

```ts
export function sum(...numbers: number[]): number {
  return numbers.reduce((acc, n) => acc + n, 0)
}

sum(1, 2, 3, 4) // 10
```

➡️ `numbers: number[]` → alle Argumente müssen `number` sein.

---

### Beispiel 2 – Strings

```ts
export function concat(...parts: string[]): string {
  return parts.join(" ")
}

concat("TypeScript", "macht", "Spaß")
```

---

### Beispiel 3 – Kombination mit festen Parametern

```ts
export function greet(greeting: string, ...names: string[]): string {
  return `${greeting}, ${names.join(" und ")}!`
}

greet("Hallo", "Sergii", "Anna") // Hallo, Sergii und Anna!
```

---

### Beispiel 4 – Generics für Rest-Parameter

```ts
export function first<T>(...items: T[]): T {
  return items[0]
}

const num = first(1, 2, 3)         // number
const str = first("a", "b", "c")   // string
```

---

### Beispiel 5 – Tupel als Rest-Parameter (variadische Tupel, TS 4.0+)

```ts
type Point = [number, number]

export function logCoordinates(...coords: Point) {
  const [x, y] = coords
  console.log(`X=${x}, Y=${y}`)
}

logCoordinates(10, 20)
```

➡️ Rest-Parameter können auch **feste Strukturen** (Tupel) erzwingen.

---

### Zusammenfassung

* **Rest-Parameter** = `...args: Typ[]`.
* Erfassen variable Argumentlisten als Array.
* Erweiterbar mit **Generics** und **Tupeln** (seit TS 4.0).
* Typische Nutzung: Utility-Funktionen, Logging, flexible APIs.

🔗 Quellen:

* [TypeScript Handbook – Functions (Rest Parameters)](https://www.typescriptlang.org/docs/handbook/2/functions.html#rest-parameters-and-arguments)
* [MDN – Rest Parameters](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/rest_parameters)

  **[⬆ Наверх](#top)**

45. ### <a name="45"></a> 



  **[⬆ Наверх](#top)**

46. ### <a name="46"></a> 



  **[⬆ Наверх](#top)**

47. ### <a name="47"></a> 



  **[⬆ Наверх](#top)**

48. ### <a name="48"></a> 



  **[⬆ Наверх](#top)**

49. ### <a name="49"></a> 



  **[⬆ Наверх](#top)**

50. ### <a name="50"></a> 



  **[⬆ Наверх](#top)**  

51. ### <a name="51"></a> 



  **[⬆ Наверх](#top)**

52. ### <a name="52"></a> 



  **[⬆ Наверх](#top)**

53. ### <a name="53"></a> 



  **[⬆ Наверх](#top)**

54. ### <a name="54"></a> 



  **[⬆ Наверх](#top)**

55. ### <a name="55"></a> 



  **[⬆ Наверх](#top)**

56. ### <a name="56"></a> 



  **[⬆ Наверх](#top)**

57. ### <a name="57"></a> 



  **[⬆ Наверх](#top)**

58. ### <a name="58"></a> 



  **[⬆ Наверх](#top)**

59. ### <a name="59"></a> 



  **[⬆ Наверх](#top)**

60. ### <a name="60"></a> 



  **[⬆ Наверх](#top)**

61. ### <a name="61"></a> 



  **[⬆ Наверх](#top)**

62. ### <a name="62"></a> 



  **[⬆ Наверх](#top)**

63. ### <a name="63"></a> 



  **[⬆ Наверх](#top)**

64. ### <a name="64"></a> 



  **[⬆ Наверх](#top)**

65. ### <a name="65"></a> 



  **[⬆ Наверх](#top)**

66. ### <a name="66"></a> 



  **[⬆ Наверх](#top)**

67. ### <a name="67"></a> 



  **[⬆ Наверх](#top)**

68. ### <a name="68"></a> 



  **[⬆ Наверх](#top)**

69. ### <a name="69"></a> 



  **[⬆ Наверх](#top)**

70. ### <a name="70"></a> 



  **[⬆ Наверх](#top)**

71. ### <a name="71"></a> 



  **[⬆ Наверх](#top)**

72. ### <a name="72"></a> 



  **[⬆ Наверх](#top)**

73. ### <a name="73"></a> 



  **[⬆ Наверх](#top)**

74. ### <a name="74"></a> 



  **[⬆ Наверх](#top)**

75. ### <a name="75"></a> 



  **[⬆ Наверх](#top)**

76. ### <a name="76"></a> 



  **[⬆ Наверх](#top)**

77. ### <a name="77"></a> 



  **[⬆ Наверх](#top)**

78. ### <a name="78"></a> 



  **[⬆ Наверх](#top)**

79. ### <a name="79"></a> 



  **[⬆ Наверх](#top)**

80. ### <a name="80"></a> 



  **[⬆ Наверх](#top)**  

81. ### <a name="81"></a> 



  **[⬆ Наверх](#top)**

82. ### <a name="82"></a> 



  **[⬆ Наверх](#top)**

83. ### <a name="83"></a> 



  **[⬆ Наверх](#top)**

84. ### <a name="84"></a> 



  **[⬆ Наверх](#top)**

85. ### <a name="85"></a> 



  **[⬆ Наверх](#top)**

86. ### <a name="86"></a> 



  **[⬆ Наверх](#top)**

87. ### <a name="87"></a> 



  **[⬆ Наверх](#top)**

88. ### <a name="88"></a> 



  **[⬆ Наверх](#top)**

89. ### <a name="89"></a> 



  **[⬆ Наверх](#top)**

90. ### <a name="90"></a> 



  **[⬆ Наверх](#top)**  

91. ### <a name="91"></a> 



  **[⬆ Наверх](#top)**

92. ### <a name="92"></a> 



  **[⬆ Наверх](#top)**

93. ### <a name="93"></a> 



  **[⬆ Наверх](#top)**

94. ### <a name="94"></a> 



  **[⬆ Наверх](#top)**

95. ### <a name="95"></a> 



  **[⬆ Наверх](#top)**

96. ### <a name="96"></a> 



  **[⬆ Наверх](#top)**

97. ### <a name="97"></a> 



  **[⬆ Наверх](#top)**

98. ### <a name="98"></a> 



  **[⬆ Наверх](#top)**

99. ### <a name="99"></a> 



  **[⬆ Наверх](#top)**

100. ### <a name="100"></a> 



  **[⬆ Наверх](#top)**    

101. ### <a name="101"></a> 



  **[⬆ Наверх](#top)**

102. ### <a name="102"></a> 



  **[⬆ Наверх](#top)**

103. ### <a name="103"></a> 



  **[⬆ Наверх](#top)**

104. ### <a name="104"></a> 



  **[⬆ Наверх](#top)**

105. ### <a name="105"></a> 



  **[⬆ Наверх](#top)**

106. ### <a name="106"></a> 



  **[⬆ Наверх](#top)**

107. ### <a name="107"></a> 



  **[⬆ Наверх](#top)**

108. ### <a name="108"></a> 



  **[⬆ Наверх](#top)**

109. ### <a name="109"></a> 



  **[⬆ Наверх](#top)**

110. ### <a name="110"></a> 



  **[⬆ Наверх](#top)**

111. ### <a name="111"></a> 



  **[⬆ Наверх](#top)**

112. ### <a name="112"></a> 



  **[⬆ Наверх](#top)**

113. ### <a name="113"></a> 



  **[⬆ Наверх](#top)**

114. ### <a name="114"></a> 



  **[⬆ Наверх](#top)**

115. ### <a name="115"></a> 



  **[⬆ Наверх](#top)**

116. ### <a name="116"></a> 



  **[⬆ Наверх](#top)**

117. ### <a name="117"></a> 



  **[⬆ Наверх](#top)**

118. ### <a name="118"></a> 



  **[⬆ Наверх](#top)**

119. ### <a name="119"></a> 



  **[⬆ Наверх](#top)**

120. ### <a name="120"></a> 



  **[⬆ Наверх](#top)**

121. ### <a name="121"></a> 



  **[⬆ Наверх](#top)**

122. ### <a name="122"></a> 



  **[⬆ Наверх](#top)**

123. ### <a name="123"></a> 



  **[⬆ Наверх](#top)**

124. ### <a name="124"></a> 



  **[⬆ Наверх](#top)**

125. ### <a name="125"></a> 



  **[⬆ Наверх](#top)**

126. ### <a name="126"></a> 



  **[⬆ Наверх](#top)**

127. ### <a name="127"></a> 



  **[⬆ Наверх](#top)**

128. ### <a name="128"></a> 



  **[⬆ Наверх](#top)**

129. ### <a name="129"></a> 



  **[⬆ Наверх](#top)**

130. ### <a name="130"></a> 



  **[⬆ Наверх](#top)**  

131. ### <a name="131"></a> 



  **[⬆ Наверх](#top)**

132. ### <a name="132"></a> 



  **[⬆ Наверх](#top)**

133. ### <a name="133"></a> 



  **[⬆ Наверх](#top)**

134. ### <a name="134"></a> 



  **[⬆ Наверх](#top)**

135. ### <a name="135"></a> 



  **[⬆ Наверх](#top)**

136. ### <a name="136"></a> 



  **[⬆ Наверх](#top)**

137. ### <a name="137"></a> 



  **[⬆ Наверх](#top)**

138. ### <a name="138"></a> 



  **[⬆ Наверх](#top)**

139. ### <a name="139"></a> 



  **[⬆ Наверх](#top)**

140. ### <a name="140"></a> 



  **[⬆ Наверх](#top)**  

141. ### <a name="141"></a> 



  **[⬆ Наверх](#top)**

142. ### <a name="142"></a> 



  **[⬆ Наверх](#top)**

143. ### <a name="143"></a> 



  **[⬆ Наверх](#top)**

144. ### <a name="144"></a> 



  **[⬆ Наверх](#top)**

145. ### <a name="145"></a> 



  **[⬆ Наверх](#top)**

146. ### <a name="146"></a> 



  **[⬆ Наверх](#top)**

147. ### <a name="147"></a> 



  **[⬆ Наверх](#top)**

148. ### <a name="148"></a> 



  **[⬆ Наверх](#top)**

149. ### <a name="149"></a> 



  **[⬆ Наверх](#top)**

150. ### <a name="150"></a> 



  **[⬆ Наверх](#top)**  

151. ### <a name="151"></a> 



  **[⬆ Наверх](#top)**

152. ### <a name="152"></a> 



  **[⬆ Наверх](#top)**

153. ### <a name="153"></a> 



  **[⬆ Наверх](#top)**

154. ### <a name="154"></a> 



  **[⬆ Наверх](#top)**

155. ### <a name="155"></a> 



  **[⬆ Наверх](#top)**

156. ### <a name="156"></a> 



  **[⬆ Наверх](#top)**

157. ### <a name="157"></a> 



  **[⬆ Наверх](#top)**

158. ### <a name="158"></a> 



  **[⬆ Наверх](#top)**

159. ### <a name="159"></a> 



  **[⬆ Наверх](#top)**

160. ### <a name="160"></a> 



  **[⬆ Наверх](#top)**

161. ### <a name="161"></a> 



  **[⬆ Наверх](#top)**

162. ### <a name="162"></a> 



  **[⬆ Наверх](#top)**

163. ### <a name="163"></a> 



  **[⬆ Наверх](#top)**

164. ### <a name="164"></a> 



  **[⬆ Наверх](#top)**

165. ### <a name="165"></a> 



  **[⬆ Наверх](#top)**

166. ### <a name="166"></a> 



  **[⬆ Наверх](#top)**

167. ### <a name="167"></a> 



  **[⬆ Наверх](#top)**

168. ### <a name="168"></a> 



  **[⬆ Наверх](#top)**

169. ### <a name="169"></a> 



  **[⬆ Наверх](#top)**

170. ### <a name="170"></a> 



  **[⬆ Наверх](#top)**

171. ### <a name="171"></a> 



  **[⬆ Наверх](#top)**

172. ### <a name="172"></a> 



  **[⬆ Наверх](#top)**

173. ### <a name="173"></a> 



  **[⬆ Наверх](#top)**

174. ### <a name="174"></a> 



  **[⬆ Наверх](#top)**

175. ### <a name="175"></a> 



  **[⬆ Наверх](#top)**

176. ### <a name="176"></a> 



  **[⬆ Наверх](#top)**

177. ### <a name="177"></a> 



  **[⬆ Наверх](#top)**

178. ### <a name="178"></a> 



  **[⬆ Наверх](#top)**

179. ### <a name="179"></a> 



  **[⬆ Наверх](#top)**

180. ### <a name="180"></a> 



  **[⬆ Наверх](#top)**  

181. ### <a name="181"></a> 



  **[⬆ Наверх](#top)**

182. ### <a name="182"></a> 



  **[⬆ Наверх](#top)**

183. ### <a name="183"></a> 



  **[⬆ Наверх](#top)**

184. ### <a name="184"></a> 



  **[⬆ Наверх](#top)**

185. ### <a name="185"></a> 



  **[⬆ Наверх](#top)**

186. ### <a name="186"></a> 



  **[⬆ Наверх](#top)**

187. ### <a name="187"></a> 



  **[⬆ Наверх](#top)**

188. ### <a name="188"></a> 



  **[⬆ Наверх](#top)**

189. ### <a name="189"></a> 



  **[⬆ Наверх](#top)**

190. ### <a name="190"></a> 



  **[⬆ Наверх](#top)**  

191. ### <a name="191"></a> 



  **[⬆ Наверх](#top)**

192. ### <a name="192"></a> 



  **[⬆ Наверх](#top)**

193. ### <a name="193"></a> 



  **[⬆ Наверх](#top)**

194. ### <a name="194"></a> 



  **[⬆ Наверх](#top)**

195. ### <a name="195"></a> 



  **[⬆ Наверх](#top)**

196. ### <a name="196"></a> 



  **[⬆ Наверх](#top)**

197. ### <a name="197"></a> 



  **[⬆ Наверх](#top)**

198. ### <a name="198"></a> 



  **[⬆ Наверх](#top)**

199. ### <a name="199"></a> 



  **[⬆ Наверх](#top)**

200. ### <a name="200"></a> 



  **[⬆ Наверх](#top)**      
