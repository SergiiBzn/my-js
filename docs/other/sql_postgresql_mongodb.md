<a name="top"></a>

[–ù–∞ –≥–ª–∞–≤–Ω—É—é](../README.md)

[–ü–µ—Ä–µ–π—Ç–∏ –∫ –≤–æ–ø—Ä–æ—Å–∞–º](#questions)

| ‚Ññ. | –í–æ–ø—Ä–æ—Å |
| --- | --------- |
|   | SQL |
|1 | [Was ist SQL und wof√ºr wird es verwendet?](#1) |
|2 | [Unterschied zwischen SQL und NoSQL?](#2) |
|3 | [Was ist ein Prim√§rschl√ºssel?](#3) |
|4 | [Was ist ein Fremdschl√ºssel?](#4) |
|5 | [Unterschied zwischen PRIMARY KEY, UNIQUE und INDEX?](#5) |
|6 | [Was sind Normalformen und warum sind sie wichtig?](#6) |
|7 | [Unterschied zwischen 1NF, 2NF und 3NF?](#7) |
|8 | [Was sind Transaktionen in SQL?](#8) |
|9 | [Was bedeutet ACID in Datenbanken?](#9) |
|10 | [Unterschied zwischen ACID und BASE Prinzipien?](#10) |
|11 | [Unterschied zwischen SELECT * und gezielten Spaltenabfragen?](#11) |
|12 | [Unterschied zwischen INNER JOIN, LEFT JOIN, RIGHT JOIN, FULL JOIN?](#12) |
|13 | [Unterschied zwischen WHERE und HAVING?](#13) |
|14 | [Unterschied zwischen DISTINCT und GROUP BY?](#14) |
|15 | [Was sind Aggregatfunktionen (COUNT, SUM, AVG, MIN, MAX)?](#15) |
|16 | [Wie funktioniert ORDER BY und LIMIT?](#16) |
|17 | [Was ist ein Subquery (Unterabfrage)?](#17) |
|18 | [Unterschied zwischen korrelierter und nicht-korrelierter Unterabfrage?](#18) |
|19 | [Unterschied zwischen EXISTS und IN?](#19) |
|20 | [Unterschied zwischen UNION und UNION ALL?](#20) |
|   | PostgreSQL |
|21 | [Was ist PostgreSQL und welche Vorteile hat es gegen√ºber MySQL?](#21) |
|22 | [Was sind Datentypen in PostgreSQL (TEXT, VARCHAR, SERIAL, JSONB)?](#22) |
|23 | [Unterschied zwischen SERIAL und BIGSERIAL?](#23) |
|24 | [Wie arbeitet PostgreSQL mit Arrays?](#24) |
|25 | [Was ist der Unterschied zwischen JSON und JSONB in PostgreSQL?](#25) |
|26 | [Wie speichert und verarbeitet PostgreSQL Zeitstempel (TIMESTAMP, TIMESTAMPTZ)?](#26) |
|27 | [Was sind Sequences in PostgreSQL?](#27) |
|28 | [Wie implementiert man Auto-Increment in PostgreSQL?](#28) |
|29 | [Was sind Materialized Views?](#29) |
|30 | [Unterschied zwischen View und Materialized View?](#30) |
|31 | [Was ist ein Index in PostgreSQL?](#31) |
|32 | [Unterschied zwischen B-Tree, Hash und GIN Index?](#32) |
|33 | [Was ist ein Unique Index?](#33) |
|34 | [Nachteile von zu vielen Indexen?](#34) |
|35 | [Wie analysiert man eine Query mit EXPLAIN?](#35) |
|36 | [Unterschied zwischen EXPLAIN und EXPLAIN ANALYZE?](#36) |
|37 | [Wie vermeidet man Table Scans?](#37) |
|38 | [Was ist ein Partial Index?](#38) |
|39 | [Was ist ein Covering Index (INCLUDE)?](#39) |
|40 | [Wie funktioniert Vacuum in PostgreSQL?](#40) |
|41 | [Wie startet und beendet man eine Transaktion?](#41) |
|42 | [Unterschied zwischen COMMIT und ROLLBACK?](#42) |
|43 | [Was ist ein Savepoint in SQL?](#43) |
|44 | [Unterschied zwischen Deadlock und Race Condition?](#44) |
|45 | [Welche Isolation Levels gibt es in PostgreSQL (READ COMMITTED, SERIALIZABLE)?](#45) |
|46 | [Unterschied zwischen Optimistic Locking und Pessimistic Locking?](#46) |
|47 | [Wie erkennt PostgreSQL Deadlocks?](#47) |
|48 | [Welche Standard-Isolationsebene nutzt PostgreSQL?](#48) |
|49 | [Wie implementiert man Transaktionen in Node.js/Express mit PostgreSQL?](#49) |
|50 | [Unterschied zwischen BEGIN und START TRANSACTION?](#50) |
|51 | [Wie verwaltet man Benutzer und Rollen in PostgreSQL?](#51) |
|52 | [Unterschied zwischen Login-Rollen und Gruppen-Rollen?](#52) |
|53 | [Wie vergibt man Berechtigungen (GRANT, REVOKE)?](#53) |
|54 | [Was ist Row Level Security (RLS) in PostgreSQL?](#54) |
|55 | [Wie sch√ºtzt man sensible Daten (z. B. Passw√∂rter) in PostgreSQL?](#55) |
|56 | [Wie sichert man eine PostgreSQL-Datenbank (pg_dump)?](#56) |
|57 | [Wie stellt man ein Backup wieder her?](#57) |
|58 | [Unterschied zwischen pg_dump und pg_restore?](#58) |
|59 | [Wie konfiguriert man SSL f√ºr PostgreSQL-Verbindungen?](#59) |
|60 | [Was ist Connection Pooling und wie implementiert man es (z. B. mit pg-pool in Node.js)?](#60) |
|   | MongoDB |
|61 | [Was ist MongoDB und wof√ºr wird es verwendet?](#61) |
|62 | [Unterschied zwischen SQL und NoSQL?](#62) |
|63 | [Was ist der Unterschied zwischen Dokument, Collection und Datenbank?](#63) |
|64 | [Was ist BSON und wie unterscheidet es sich von JSON?](#64) |
|65 | [Was ist ein ObjectId und warum wird es genutzt?](#65) |
|66 | [Wie f√ºgt man Dokumente ein (insertOne, insertMany)?](#66) |
|67 | [Wie liest man Daten (find, findOne)?](#67) |
|68 | [Unterschied zwischen find(), findOne() und findById() in Mongoose?](#68) |
|69 | [Wie aktualisiert man Dokumente (updateOne, updateMany, findByIdAndUpdate)?](#69) |
|70 | [Wie l√∂scht man Dokumente (deleteOne, deleteMany, findByIdAndDelete)?](#70) |
|71 | [Was ist Mongoose und warum wird es h√§ufig in Node/Express-Projekten verwendet?](#71) |
|72 | [Unterschied zwischen Schema und Model in Mongoose?](#72) |
|73 | [Wie definiert man Validierungen in einem Schema?](#73) |
|74 | [Was sind Virtuals und Middleware (pre, post) in Mongoose?](#74) |
|75 | [Wie funktioniert populate in Mongoose (Beziehungen zwischen Dokumenten)?](#75) |
|76 | [Welche Vergleichsoperatoren gibt es ($gt, $lt, $in, $nin, $eq)?](#76) |
|77 | [Wie sucht man mit $and, $or, $nor?](#77) |
|78 | [Wie sucht man in Arrays ($elemMatch, $push, $pull)?](#78) |
|79 | [Unterschied zwischen sort, limit und skip?](#79) |
|80 | [Was ist der Unterschied zwischen countDocuments() und estimatedDocumentCount()?](#80) |
|81 | [Was ist eine Aggregation Pipeline und wof√ºr wird sie verwendet?](#81) |
|82 | [Welche Stages gibt es ($match, $group, $project, $sort, $limit)?](#82) |
|83 | [Was sind Indexe und warum sind sie wichtig?](#83) |
|84 | [Unterschied zwischen Single-Field Index und Compound Index?](#84) |
|85 | [Was ist ein Unique-Index?](#85) |
|86 | [Was ist Sharding und Replikation in MongoDB?](#86) |
|87 | [Was ist ein Replica Set und warum ist es wichtig?](#87) |
|88 | [Wie optimiert man Queries in MongoDB (Explain, Indexe)?](#88) |
|89 | [Wie sch√ºtzt man MongoDB vor unautorisiertem Zugriff?](#89) |
|90 | [Unterschied zwischen Rollen und Berechtigungen (z. B. read, readWrite)?](#90) |
|91 | [](#91) |
|92 | [](#92) |
|93 | [](#93) |
|94 | [](#94) |
|95 | [](#95) |
|96 | [](#96) |
|97 | [](#97) |
|98 | [](#98) |
|99 | [](#99) |
|100 | [](#100) |
|101 | [](#101) |
|102 | [](#102) |
|103 | [](#103) |
|104 | [](#104) |
|105 | [](#105) |
|106 | [](#106) |
|107 | [](#107) |
|108 | [](#108) |
|109 | [](#109) |
|110 | [](#110) |
|111 | [](#111) |
|112 | [](#112) |
|113 | [](#113) |
|114 | [](#114) |
|115 | [](#115) |
|116 | [](#116) |
|117 | [](#117) |
|118 | [](#118) |
|119 | [](#119) |
|120 | [](#120) |
|121 | [](#121) |
|122 | [](#122) |
|123 | [](#123) |
|124 | [](#124) |
|125 | [](#125) |
|126 | [](#126) |
|127 | [](#127) |
|128 | [](#128) |
|129 | [](#129) |
|130 | [](#130) |
|131 | [](#131) |
|132 | [](#132) |
|133 | [](#133) |
|134 | [](#134) |
|135 | [](#135) |
|136 | [](#136) |
|137 | [](#137) |
|138 | [](#138) |
|139 | [](#139) |
|140 | [](#140) |
|141 | [](#141) |
|142 | [](#142) |
|143 | [](#143) |
|144 | [](#144) |
|145 | [](#145) |
|146 | [](#146) |
|147 | [](#147) |
|148 | [](#148) |
|149 | [](#149) |
|150 | [](#150) |
|151 | [](#151) |
|152 | [](#152) |
|153 | [](#153) |
|154 | [](#154) |
|155 | [](#155) |
|156 | [](#156) |
|157 | [](#157) |
|158 | [](#158) |
|159 | [](#159) |
|160 | [](#160) |
|161 | [](#161) |
|162 | [](#162) |
|163 | [](#163) |
|164 | [](#164) |
|165 | [](#165) |
|166 | [](#166) |
|167 | [](#167) |
|168 | [](#168) |
|169 | [](#169) |
|170 | [](#170) |
|171 | [](#171) |
|172 | [](#172) |
|173 | [](#173) |
|174 | [](#174) |
|175 | [](#175) |
|176 | [](#176) |
|177 | [](#177) |
|178 | [](#178) |
|179 | [](#179) |
|180 | [](#180) |
|181 | [](#181) |
|182 | [](#182) |
|183 | [](#183) |
|184 | [](#184) |
|185 | [](#185) |
|186 | [](#186) |
|187 | [](#187) |
|188 | [](#188) |
|189 | [](#189) |
|190 | [](#190) |
|191 | [](#191) |
|192 | [](#192) |
|193 | [](#193) |
|194 | [](#194) |
|195 | [](#195) |
|196 | [](#196) |
|197 | [](#197) |
|198 | [](#198) |
|199 | [](#199) |
|200 | [](#200) |



<a name="questions"></a>


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**
  
1. ### <a name="1"></a> Was ist SQL und wof√ºr wird es verwendet?

**SQL (Structured Query Language)** ist eine standardisierte Sprache zur Arbeit mit relationalen Datenbanken.
Sie dient dazu:

* **Daten zu definieren** (Tabellen, Schemata) ‚Üí *Data Definition Language (DDL)*
* **Daten zu manipulieren** (Einf√ºgen, Aktualisieren, L√∂schen) ‚Üí *Data Manipulation Language (DML)*
* **Daten abzufragen** (Selektieren, Filtern, Aggregieren) ‚Üí *Data Query Language (DQL)*
* **Zugriffsrechte zu steuern** ‚Üí *Data Control Language (DCL)*

### Beispiel:

```sql
-- Tabelle erstellen (DDL)
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  name VARCHAR(100),
  email VARCHAR(100) UNIQUE
);

-- Daten einf√ºgen (DML)
INSERT INTO users (name, email)
VALUES ('Max Mustermann', 'max@example.com');

-- Daten abfragen (DQL)
SELECT id, name
FROM users
WHERE email LIKE '%example.com';
```

SQL wird in relationalen Datenbanksystemen wie **PostgreSQL**, **MySQL**, **SQLite**, **Oracle DB** und **MS SQL Server** verwendet.

---

**Zusammenfassung:**
SQL ist die Standardsprache zur Definition, Abfrage und Manipulation von Daten in relationalen Datenbanken.

üìñ Quellen:

* [PostgreSQL Dokumentation ‚Äì SQL](https://www.postgresql.org/docs/current/sql.html)
* [MDN ‚Äì SQL Einf√ºhrung (RU)](https://developer.mozilla.org/ru/docs/Glossary/SQL)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

2. ### <a name="2"></a> Unterschied zwischen SQL und NoSQL?

**SQL (relational) vs. NoSQL (nicht-relational):**

### 1. **Datenmodell**

* **SQL:** Tabellenbasiert, mit Zeilen und Spalten. Starke Beziehungen (Relations).
* **NoSQL:** Flexible Modelle ‚Äì Dokumente (MongoDB), Key-Value (Redis), Spalten (Cassandra), Graphen (Neo4j).

### 2. **Schema**

* **SQL:** Strenges, festes Schema (z. B. `VARCHAR(100)` f√ºr eine Spalte). √Ñnderungen erfordern Migration.
* **NoSQL:** Schemafrei oder sehr flexibel. Neue Felder k√∂nnen einfach hinzugef√ºgt werden.

### 3. **Skalierung**

* **SQL:** Vertikale Skalierung (st√§rkere Server). Horizontale Skalierung oft komplexer.
* **NoSQL:** F√ºr horizontale Skalierung entworfen (Sharding, Replikation).

### 4. **Transaktionen**

* **SQL:** ACID-konform (Atomicity, Consistency, Isolation, Durability). Hohe Datenintegrit√§t.
* **NoSQL:** Oft BASE-Prinzip (Basically Available, Soft state, Eventually consistent). Schneller, aber weniger strikt.

### 5. **Abfragesprache**

* **SQL:** Einheitliche Standardsprache (z. B. `SELECT`, `JOIN`).
* **NoSQL:** Unterschiedliche APIs oder abfrage√§hnliche Sprachen je nach DB (z. B. MongoDB mit `find()`).

---

### Beispiel SQL (PostgreSQL)

```sql
-- Benutzer mit Email abfragen
SELECT * FROM users WHERE email = 'max@example.com';
```

### Beispiel NoSQL (MongoDB)

```js
// Dokument aus der Collection users abfragen
db.users.find({ email: "max@example.com" });
```

---

**Zusammenfassung:**

* **SQL** ‚Üí relational, streng, ACID, f√ºr komplexe Beziehungen und Integrit√§t.
* **NoSQL** ‚Üí flexibel, schemafrei, skalierbar, oft schneller f√ºr gro√üe unstrukturierte Datenmengen.

üìñ Quellen:

* [PostgreSQL Docs ‚Äì SQL](https://www.postgresql.org/docs/current/sql.html)
* [MongoDB ‚Äì What is NoSQL?](https://www.mongodb.com/nosql-explained)
* [MDN ‚Äì SQL Glossar (RU)](https://developer.mozilla.org/ru/docs/Glossary/SQL)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

3. ### <a name="3"></a> Was ist ein Prim√§rschl√ºssel?

**Prim√§rschl√ºssel (Primary Key)** ist ein Attribut oder eine Kombination von Attributen in einer Tabelle, das jeden Datensatz eindeutig identifiziert.

### Eigenschaften:

* **Eindeutigkeit:** Kein doppelter Wert erlaubt.
* **Nicht-Null:** Jeder Datensatz muss einen Prim√§rschl√ºssel haben.
* **Stabilit√§t:** Sollte sich nicht h√§ufig √§ndern.
* **Nur ein Prim√§rschl√ºssel pro Tabelle**, aber er kann aus mehreren Spalten bestehen (*komposit*).

---

### Beispiel in SQL (PostgreSQL)

```sql
-- Einfacher Prim√§rschl√ºssel
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  name VARCHAR(100),
  email VARCHAR(100)
);

-- Komposit-Schl√ºssel (zwei Spalten bilden den Primary Key)
CREATE TABLE orders (
  order_id INT,
  product_id INT,
  PRIMARY KEY (order_id, product_id)
);
```

---

### Warum wichtig?

* Sichert **Eindeutigkeit** der Daten.
* Erm√∂glicht effiziente **Indizierung und Suche**.
* Grundlage f√ºr **Beziehungen (FOREIGN KEYS)** zwischen Tabellen.

---

**Zusammenfassung:**
Ein Prim√§rschl√ºssel ist ein eindeutiges Feld oder Feldkombination in einer Tabelle, das jeden Datensatz identifiziert und keine NULL-Werte zul√§sst.

üìñ Quellen:

* [PostgreSQL Docs ‚Äì Constraints](https://www.postgresql.org/docs/current/ddl-constraints.html)
* [MDN Glossar ‚Äì Primary Key (RU)](https://developer.mozilla.org/ru/docs/Glossary/Primary_key)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

4. ### <a name="4"></a> Was ist ein Fremdschl√ºssel?

**Fremdschl√ºssel (Foreign Key)** ist eine Spalte oder eine Kombination von Spalten, die auf den **Prim√§rschl√ºssel einer anderen Tabelle** verweist.
Er stellt eine **Beziehung zwischen zwei Tabellen** her und sorgt f√ºr **Datenintegrit√§t**.

---

### Eigenschaften:

* Muss auf einen g√ºltigen Wert im Prim√§rschl√ºssel der referenzierten Tabelle zeigen.
* Verhindert das Einf√ºgen von Werten, die nicht existieren.
* Kann mit **ON DELETE** oder **ON UPDATE** Regeln kombiniert werden (z. B. `CASCADE`, `SET NULL`).

---

### Beispiel in SQL (PostgreSQL)

```sql
-- Tabelle users
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  name VARCHAR(100)
);

-- Tabelle orders mit Fremdschl√ºssel auf users.id
CREATE TABLE orders (
  id SERIAL PRIMARY KEY,
  user_id INT,
  product VARCHAR(100),
  CONSTRAINT fk_user FOREIGN KEY (user_id)
    REFERENCES users (id)
    ON DELETE CASCADE
);
```

* Wenn ein **User gel√∂scht wird**, werden durch `ON DELETE CASCADE` automatisch auch alle seine Bestellungen gel√∂scht.

---

### Nutzen:

* Sichert **Referenzielle Integrit√§t**.
* Verbindet Daten logisch √ºber Tabellen hinweg.
* Erm√∂glicht **Joins** zwischen Tabellen.

---

**Zusammenfassung:**
Ein Fremdschl√ºssel ist ein Attribut in einer Tabelle, das auf den Prim√§rschl√ºssel einer anderen Tabelle verweist und so die Beziehung zwischen den Tabellen sicherstellt.

üìñ Quellen:

* [PostgreSQL Docs ‚Äì Foreign Keys](https://www.postgresql.org/docs/current/ddl-constraints.html#DDL-CONSTRAINTS-FK)
* [MDN Glossar ‚Äì Foreign Key (RU)](https://developer.mozilla.org/ru/docs/Glossary/Foreign_key)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

5. ### <a name="5"></a> Unterschied zwischen PRIMARY KEY, UNIQUE und INDEX?

### **1. PRIMARY KEY**

* Eindeutiger Bezeichner f√ºr jede Zeile.
* Impliziert automatisch **NOT NULL** und **UNIQUE**.
* Nur **ein PRIMARY KEY pro Tabelle**, kann aber aus mehreren Spalten bestehen (*komposit*).
* Wird intern automatisch indiziert.

**Beispiel:**

```sql
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  email VARCHAR(100)
);
```

---

### **2. UNIQUE**

* Erzwingt, dass Werte in der Spalte oder Spaltenkombination **eindeutig** sind.
* Mehrere `UNIQUE`-Constraints pro Tabelle m√∂glich.
* **NULL**-Werte sind erlaubt (abh√§ngig vom DBMS, in PostgreSQL mehrfach `NULL`).

**Beispiel:**

```sql
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  email VARCHAR(100) UNIQUE
);
```

---

### **3. INDEX**

* Datenbankstruktur zur **Beschleunigung von Such- und Sortieroperationen**.
* Keine Einschr√§nkung der Daten, nur Performance-Optimierung.
* Mehrere Indizes pro Tabelle m√∂glich.
* Kann auch **auf nicht eindeutigen Spalten** erstellt werden.

**Beispiel:**

```sql
-- Index auf Spalte name
CREATE INDEX idx_users_name ON users (name);
```

---

### **Vergleich:**

| Merkmal            | PRIMARY KEY    | UNIQUE          | INDEX                     |
| ------------------ | -------------- | --------------- | ------------------------- |
| Eindeutigkeit      | Ja             | Ja              | Nein (au√üer UNIQUE Index) |
| NULL erlaubt       | Nein           | Ja (PostgreSQL) | Ja                        |
| Anzahl pro Tabelle | 1              | Beliebig viele  | Beliebig viele            |
| Hauptzweck         | Identifikation | Datenintegrit√§t | Performance               |
| Automatisch Index? | Ja             | Ja              | Ja (aber nur manuell)     |

---

**Zusammenfassung:**

* **PRIMARY KEY** = eindeutiger Identifikator (einmal pro Tabelle).
* **UNIQUE** = verhindert Duplikate, aber erlaubt `NULL`.
* **INDEX** = dient nur der Performance, erzwingt keine Eindeutigkeit.

üìñ Quellen:

* [PostgreSQL Docs ‚Äì Constraints](https://www.postgresql.org/docs/current/ddl-constraints.html)
* [PostgreSQL Docs ‚Äì Indexes](https://www.postgresql.org/docs/current/indexes.html)
* [MDN Glossar ‚Äì Primary Key](https://developer.mozilla.org/ru/docs/Glossary/Primary_key)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

6. ### <a name="6"></a> Was sind Normalformen und warum sind sie wichtig?

### **Normalformen in relationalen Datenbanken**

**Definition:**
Normalformen sind Regeln zur **Strukturierung von Tabellen**, damit Redundanz, Inkonsistenzen und Anomalien beim Einf√ºgen, Aktualisieren oder L√∂schen von Daten vermieden werden.

---

### **1. Normalform (1NF)**

* Alle Attribute enthalten **atomare Werte** (keine Listen oder Arrays).
* Keine mehrfachen oder wiederholenden Spalten.

**Beispiel ‚Äì falsch (nicht 1NF):**

```sql
-- Spalte enth√§lt mehrere Werte
CREATE TABLE customers (
  id SERIAL PRIMARY KEY,
  name VARCHAR(100),
  phones TEXT -- "12345, 67890"
);
```

**Korrekt (1NF):**

```sql
CREATE TABLE phones (
  id SERIAL PRIMARY KEY,
  customer_id INT REFERENCES customers(id),
  phone VARCHAR(20)
);
```

---

### **2. Normalform (2NF)**

* Erf√ºllt 1NF.
* Jedes Nicht-Schl√ºssel-Attribut h√§ngt **vollst√§ndig vom Prim√§rschl√ºssel** ab, nicht nur von einem Teil davon.
* Gilt nur f√ºr Tabellen mit **kompositem Prim√§rschl√ºssel**.

---

### **3. Normalform (3NF)**

* Erf√ºllt 2NF.
* Keine **transitiven Abh√§ngigkeiten** (ein Attribut h√§ngt nicht von einem anderen Nicht-Schl√ºssel-Attribut ab).

**Beispiel ‚Äì schlecht (nicht 3NF):**

```sql
CREATE TABLE orders (
  order_id SERIAL PRIMARY KEY,
  customer_id INT,
  customer_city VARCHAR(100) -- h√§ngt vom Kunden, nicht von der Bestellung ab
);
```

**Besser (3NF):**

```sql
CREATE TABLE customers (
  id SERIAL PRIMARY KEY,
  city VARCHAR(100)
);

CREATE TABLE orders (
  id SERIAL PRIMARY KEY,
  customer_id INT REFERENCES customers(id)
);
```

---

### **Weitere Normalformen:**

* **BCNF (Boyce-Codd-Normalform):** Strengere Version von 3NF.
* **4NF/5NF:** Selten in der Praxis, behandeln mehrfache Abh√§ngigkeiten und Join-Abh√§ngigkeiten.

---

### **Warum wichtig?**

* **Vermeidung von Redundanz** ‚Üí spart Speicherplatz.
* **Vermeidung von Anomalien** beim INSERT/UPDATE/DELETE.
* **Bessere Datenintegrit√§t**.
* **Effiziente Abfragen** durch klare Beziehungen.

---

**Zusammenfassung:**
Normalformen sind Stufen der Datenbanknormalisierung, die sicherstellen, dass Tabellen logisch strukturiert sind, Redundanz vermeiden und Datenintegrit√§t sichern. In der Praxis werden meist **1NF bis 3NF** umgesetzt.

üìñ Quellen:

* [PostgreSQL Docs ‚Äì Database Design](https://www.postgresql.org/docs/current/ddl.html)
* [MDN Glossar ‚Äì Normalization (RU)](https://developer.mozilla.org/ru/docs/Glossary/Database_normalization)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

7. ### <a name="7"></a> Unterschied zwischen 1NF, 2NF und 3NF?

### **Unterschied zwischen 1NF, 2NF und 3NF**

---

### **1. Normalform (1NF)**

* Alle Attribute enthalten **atomare Werte** (keine Arrays oder mehrfachen Werte in einer Spalte).
* Keine wiederholenden Spalten.

**Beispiel (nicht 1NF):**

```sql
CREATE TABLE customers (
  id SERIAL PRIMARY KEY,
  name VARCHAR(100),
  phones TEXT -- "12345,67890"
);
```

**Korrekt (1NF):**

```sql
CREATE TABLE phones (
  id SERIAL PRIMARY KEY,
  customer_id INT REFERENCES customers(id),
  phone VARCHAR(20)
);
```

---

### **2. Normalform (2NF)**

* Erf√ºllt **1NF**.
* Alle Nicht-Schl√ºssel-Attribute h√§ngen **vollst√§ndig vom gesamten Prim√§rschl√ºssel** ab, nicht nur von einem Teil.
* Relevant bei **kompositem Prim√§rschl√ºssel**.

**Beispiel (nicht 2NF):**

```sql
CREATE TABLE order_items (
  order_id INT,
  product_id INT,
  product_name VARCHAR(100), -- h√§ngt nur von product_id ab
  PRIMARY KEY (order_id, product_id)
);
```

**Korrekt (2NF):**

```sql
CREATE TABLE products (
  id INT PRIMARY KEY,
  name VARCHAR(100)
);

CREATE TABLE order_items (
  order_id INT,
  product_id INT REFERENCES products(id),
  PRIMARY KEY (order_id, product_id)
);
```

---

### **3. Normalform (3NF)**

* Erf√ºllt **2NF**.
* Keine **transitiven Abh√§ngigkeiten**: Ein Nicht-Schl√ºssel-Attribut darf nicht von einem anderen Nicht-Schl√ºssel-Attribut abh√§ngen.

**Beispiel (nicht 3NF):**

```sql
CREATE TABLE orders (
  id SERIAL PRIMARY KEY,
  customer_id INT,
  customer_city VARCHAR(100) -- h√§ngt von customer_id ab, nicht von der Bestellung
);
```

**Korrekt (3NF):**

```sql
CREATE TABLE customers (
  id SERIAL PRIMARY KEY,
  city VARCHAR(100)
);

CREATE TABLE orders (
  id SERIAL PRIMARY KEY,
  customer_id INT REFERENCES customers(id)
);
```

---

### **Vergleich in Kurzform**

| Normalform | Regel                                                                  | Fokus                            |
| ---------- | ---------------------------------------------------------------------- | -------------------------------- |
| **1NF**    | Nur atomare Werte, keine Wiederholungen                                | Struktur der Spalten             |
| **2NF**    | 1NF + keine partielle Abh√§ngigkeit vom Teil eines zusammengesetzten PK | Abh√§ngigkeit vom Prim√§rschl√ºssel |
| **3NF**    | 2NF + keine transitive Abh√§ngigkeit                                    | Trennung unabh√§ngiger Infos      |

---

**Zusammenfassung:**

* **1NF** ‚Üí Atomare Werte, keine Wiederholungen.
* **2NF** ‚Üí Keine partielle Abh√§ngigkeit von Teil-Schl√ºssel.
* **3NF** ‚Üí Keine transitive Abh√§ngigkeit von Nicht-Schl√ºssel-Attributen.

üìñ Quellen:

* [PostgreSQL Docs ‚Äì Database Design](https://www.postgresql.org/docs/current/ddl.html)
* [MDN Glossar ‚Äì Normalization (RU)](https://developer.mozilla.org/ru/docs/Glossary/Database_normalization)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

8. ### <a name="8"></a> Was sind Transaktionen in SQL?

### **Transaktionen in SQL**

Eine **Transaktion** ist eine logische Einheit von Datenbankoperationen, die entweder **vollst√§ndig** oder **gar nicht** ausgef√ºhrt wird.
Sie sorgt f√ºr **Datenkonsistenz** und folgt den **ACID-Prinzipien**:

* **Atomicity** ‚Üí Alles oder nichts wird ausgef√ºhrt.
* **Consistency** ‚Üí Daten bleiben nach Transaktion in konsistentem Zustand.
* **Isolation** ‚Üí Gleichzeitige Transaktionen beeinflussen sich nicht.
* **Durability** ‚Üí √Ñnderungen bleiben auch nach Systemabsturz erhalten.

---

### **Beispiel in SQL (PostgreSQL)**

```sql
BEGIN; -- Start der Transaktion

-- 1. Geld vom Konto A abbuchen
UPDATE accounts
SET balance = balance - 100
WHERE id = 1;

-- 2. Geld auf Konto B √ºberweisen
UPDATE accounts
SET balance = balance + 100
WHERE id = 2;

COMMIT; -- √Ñnderungen dauerhaft speichern
```

Falls w√§hrend der Transaktion ein Fehler passiert:

```sql
ROLLBACK; -- Alle √Ñnderungen r√ºckg√§ngig machen
```

---

### **Isolation Levels (PostgreSQL unterst√ºtzt 4 Stufen):**

1. **READ UNCOMMITTED** ‚Äì unsichere Reads m√∂glich.
2. **READ COMMITTED** ‚Äì nur best√§tigte Daten sichtbar (Standard in PostgreSQL).
3. **REPEATABLE READ** ‚Äì gleiche Abfrage liefert immer identische Ergebnisse innerhalb der Transaktion.
4. **SERIALIZABLE** ‚Äì maximale Isolation, Transaktionen wirken wie nacheinander ausgef√ºhrt.

---

**Zusammenfassung:**
Transaktionen sind logische Bl√∂cke mehrerer SQL-Operationen, die mit **ACID-Sicherheit** ausgef√ºhrt werden. Sie stellen sicher, dass Daten konsistent bleiben, auch bei Fehlern oder parallelen Zugriffen.

üìñ Quellen:

* [PostgreSQL Docs ‚Äì Transactions](https://www.postgresql.org/docs/current/tutorial-transactions.html)
* [MDN Glossar ‚Äì ACID (RU)](https://developer.mozilla.org/ru/docs/Glossary/ACID)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

9. ### <a name="9"></a> Was bedeutet ACID in Datenbanken?

### **ACID-Prinzip in Datenbanken**

ACID beschreibt die vier Kern¬≠eigenschaften, die eine **Transaktion** in einem relationalen Datenbanksystem erf√ºllen muss:

---

### **1. Atomicity (Atomarit√§t)**

* Eine Transaktion wird **vollst√§ndig oder gar nicht** ausgef√ºhrt.
* Fehler ‚Üí alle √Ñnderungen werden mit `ROLLBACK` r√ºckg√§ngig gemacht.

**Beispiel:** Geld√ºberweisung ‚Üí entweder beide Konten werden angepasst, oder keins.

---

### **2. Consistency (Konsistenz)**

* Die Transaktion √ºberf√ºhrt die Datenbank von einem **konsistenten Zustand** in einen anderen.
* Regeln wie **Constraints, Datentypen, Trigger** werden eingehalten.

**Beispiel:** Ein negativer Kontostand ist nicht erlaubt ‚Üí die Transaktion schl√§gt fehl.

---

### **3. Isolation (Isolation)**

* Gleichzeitige Transaktionen beeinflussen sich nicht gegenseitig.
* Isolation Levels (PostgreSQL):

  * **READ COMMITTED** (Standard)
  * **REPEATABLE READ**
  * **SERIALIZABLE**

**Beispiel:** Zwei Nutzer lesen und schreiben gleichzeitig denselben Datensatz, ohne dass Inkonsistenzen entstehen.

---

### **4. Durability (Dauerhaftigkeit)**

* Nach einem `COMMIT` bleiben √Ñnderungen **dauerhaft gespeichert**, auch bei Absturz oder Stromausfall.
* Daten werden im **Write-Ahead-Log (WAL)** gesichert.

---

### **ACID in SQL-Beispiel**

```sql
BEGIN;

UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;

COMMIT; -- garantiert ACID-Sicherheit
```

---

**Zusammenfassung:**
ACID = **Atomicity, Consistency, Isolation, Durability**.
Diese Prinzipien garantieren sichere, konsistente und zuverl√§ssige Transaktionen in Datenbanken.

üìñ Quellen:

* [PostgreSQL Docs ‚Äì Transactions](https://www.postgresql.org/docs/current/tutorial-transactions.html)
* [MDN Glossar ‚Äì ACID (RU)](https://developer.mozilla.org/ru/docs/Glossary/ACID)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

10. ### <a name="10"></a> Unterschied zwischen ACID und BASE Prinzipien?

### **Unterschied zwischen ACID und BASE Prinzipien**

---

### **ACID (klassische SQL-Datenbanken)**

Fokus: **Korrektheit und Integrit√§t der Daten**

1. **Atomicity** ‚Üí Alles oder nichts wird ausgef√ºhrt
2. **Consistency** ‚Üí Regeln und Constraints bleiben erhalten
3. **Isolation** ‚Üí Parallele Transaktionen beeinflussen sich nicht
4. **Durability** ‚Üí √Ñnderungen sind dauerhaft gespeichert

‚û°Ô∏è Geeignet f√ºr **Banken, Finanzsysteme, Buchhaltung** ‚Äì wo absolute Datenintegrit√§t n√∂tig ist.

---

### **BASE (h√§ufig in NoSQL-Datenbanken)**

Fokus: **Verf√ºgbarkeit und Skalierbarkeit**

1. **Basically Available** ‚Üí Das System ist immer verf√ºgbar, auch bei Teilfehlern
2. **Soft State** ‚Üí Daten k√∂nnen sich √§ndern, auch ohne direkte Eingriffe (z. B. durch Replikation)
3. **Eventually Consistent** ‚Üí Daten werden √ºber Zeit konsistent, aber nicht sofort

‚û°Ô∏è Geeignet f√ºr **verteilte Systeme, Social Media, E-Commerce** ‚Äì wo schnelle Antwortzeit wichtiger ist als sofortige Konsistenz.

---

### **Vergleich in Kurzform**

| Prinzip         | ACID (SQL)                                  | BASE (NoSQL)                           |
| --------------- | ------------------------------------------- | -------------------------------------- |
| Ziel            | Datenintegrit√§t                             | Verf√ºgbarkeit + Skalierbarkeit         |
| Konsistenz      | Streng, sofort                              | Eventual Consistency (zeitverz√∂gert)   |
| Isolation       | Stark (Transaktionen sind getrennt)         | Locker, gleichzeitige Zugriffe erlaubt |
| Geschwindigkeit | Weniger performant bei vielen Transaktionen | Sehr performant bei gro√üen Datenmengen |
| Beispiele       | PostgreSQL, MySQL, Oracle                   | MongoDB, Cassandra, DynamoDB           |

---

**Zusammenfassung:**

* **ACID** ‚Üí strikte Konsistenz, sicher, aber weniger flexibel.
* **BASE** ‚Üí hohe Verf√ºgbarkeit und Skalierbarkeit, aber Daten k√∂nnen zeitweise inkonsistent sein.

üìñ Quellen:

* [PostgreSQL Docs ‚Äì Transactions (ACID)](https://www.postgresql.org/docs/current/tutorial-transactions.html)
* [MongoDB ‚Äì NoSQL Explained (BASE)](https://www.mongodb.com/nosql-explained)
* [MDN Glossar ‚Äì ACID (RU)](https://developer.mozilla.org/ru/docs/Glossary/ACID)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

11. ### <a name="11"></a> Unterschied zwischen SELECT * und gezielten Spaltenabfragen?

### **Unterschied zwischen `SELECT *` und gezielten Spaltenabfragen**

---

### **1. `SELECT *`**

* W√§hlt **alle Spalten** einer Tabelle aus.
* Praktisch f√ºr **schnelle Tests** oder kleine Tabellen.
* Nachteile:

  * **Performance**: Mehr Daten werden geladen, auch wenn nicht ben√∂tigt.
  * **Netzwerkbelastung**: Unn√∂tige Daten√ºbertragung.
  * **Instabilit√§t**: Wenn sich das Schema √§ndert (neue Spalten), k√∂nnen Abfragen unvorhergesehen mehr Daten liefern.
  * **Schlechter f√ºr Index-Nutzung** ‚Üí DB muss alle Spalten lesen.

**Beispiel:**

```sql
SELECT * FROM users;
```

---

### **2. Gezielte Spaltenabfragen**

* Nur die **ben√∂tigten Spalten** werden abgefragt.
* Vorteile:

  * **Effizienter** (schneller, weniger Speicherverbrauch).
  * **Klarheit**: Der Code zeigt, welche Daten wirklich gebraucht werden.
  * **Bessere Index-Nutzung** ‚Üí DB kann Abfrage optimieren.

**Beispiel:**

```sql
SELECT id, name, email 
FROM users;
```

---

### **Vergleich**

| Merkmal           | `SELECT *`                        | Gezielte Spalten              |
| ----------------- | --------------------------------- | ----------------------------- |
| Performance       | Schw√§cher, l√§dt alles             | Besser, nur relevante Spalten |
| Lesbarkeit        | Unklar, was gebraucht wird        | Deutlich, selbsterkl√§rend     |
| Schema-√Ñnderungen | Kann ungewollt mehr Daten liefern | Stabiler                      |
| Nutzung in Praxis | Debugging, schnelle Tests         | Produktionscode, APIs         |

---

**Zusammenfassung:**

* `SELECT *` ist bequem, aber ineffizient und unsauber f√ºr produktiven Code.
* Gezielte Spaltenabfragen sind performanter, sicherer und besser lesbar.

üìñ Quellen:

* [PostgreSQL Docs ‚Äì SELECT](https://www.postgresql.org/docs/current/sql-select.html)
* [MDN Glossar ‚Äì SQL SELECT (RU)](https://developer.mozilla.org/ru/docs/Web/SQL/SELECT)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

12. ### <a name="12"></a> Unterschied zwischen INNER JOIN, LEFT JOIN, RIGHT JOIN, FULL JOIN?

### **JOIN-Arten in SQL**

Mit **JOINs** verbindet man Tabellen √ºber gemeinsame Schl√ºssel (meist Fremdschl√ºssel). Unterschiedliche JOIN-Typen bestimmen, welche Datens√§tze zur√ºckgegeben werden.

---

### **1. INNER JOIN**

* Liefert **nur die Datens√§tze**, bei denen in beiden Tabellen eine √úbereinstimmung besteht.

```sql
SELECT u.id, u.name, o.product
FROM users u
INNER JOIN orders o ON u.id = o.user_id;
```

‚û°Ô∏è Nur Benutzer, die mindestens eine Bestellung haben.

---

### **2. LEFT JOIN (LEFT OUTER JOIN)**

* Alle Datens√§tze aus der **linken Tabelle** werden zur√ºckgegeben.
* Falls keine √úbereinstimmung in der rechten Tabelle ‚Üí `NULL` in deren Spalten.

```sql
SELECT u.id, u.name, o.product
FROM users u
LEFT JOIN orders o ON u.id = o.user_id;
```

‚û°Ô∏è Alle Benutzer, auch die ohne Bestellungen (dort `product = NULL`).

---

### **3. RIGHT JOIN (RIGHT OUTER JOIN)**

* Alle Datens√§tze aus der **rechten Tabelle** werden zur√ºckgegeben.
* Falls keine √úbereinstimmung in der linken Tabelle ‚Üí `NULL` in deren Spalten.

```sql
SELECT u.id, u.name, o.product
FROM users u
RIGHT JOIN orders o ON u.id = o.user_id;
```

‚û°Ô∏è Alle Bestellungen, auch ohne zugeh√∂rigen Benutzer (z. B. wenn ein User gel√∂scht wurde).

---

### **4. FULL JOIN (FULL OUTER JOIN)**

* Kombination aus LEFT JOIN + RIGHT JOIN.
* Alle Datens√§tze beider Tabellen, auch wenn keine √úbereinstimmung vorliegt.

```sql
SELECT u.id, u.name, o.product
FROM users u
FULL JOIN orders o ON u.id = o.user_id;
```

‚û°Ô∏è Alle Benutzer und alle Bestellungen, auch wenn keine Zuordnung besteht (`NULL` auf einer Seite).

---

### **Vergleichs√ºbersicht**

| JOIN-Typ   | Ergebnis                                                            |
| ---------- | ------------------------------------------------------------------- |
| INNER JOIN | Nur Datens√§tze mit Match in beiden Tabellen                         |
| LEFT JOIN  | Alle aus linker Tabelle + passende aus rechter Tabelle, Rest = NULL |
| RIGHT JOIN | Alle aus rechter Tabelle + passende aus linker Tabelle, Rest = NULL |
| FULL JOIN  | Alle Datens√§tze beider Tabellen, auch ohne Match                    |

---

**Zusammenfassung:**

* **INNER JOIN** ‚Üí Schnittmenge
* **LEFT JOIN** ‚Üí Alles aus links + √úbereinstimmungen rechts
* **RIGHT JOIN** ‚Üí Alles aus rechts + √úbereinstimmungen links
* **FULL JOIN** ‚Üí Vereinigung beider Tabellen

üìñ Quellen:

* [PostgreSQL Docs ‚Äì Joins](https://www.postgresql.org/docs/current/queries-table-expressions.html#QUERIES-JOIN)
* [MDN Glossar ‚Äì JOIN (RU)](https://developer.mozilla.org/ru/docs/Glossary/Join)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

13. ### <a name="13"></a> Unterschied zwischen WHERE und HAVING?

### **Unterschied zwischen `WHERE` und `HAVING`**

---

### **1. WHERE**

* Filtert **Zeilen**, bevor Gruppierungen (`GROUP BY`) oder Aggregationen (`SUM`, `COUNT`, ‚Ä¶) ausgef√ºhrt werden.
* Kann **nicht** direkt auf Aggregatfunktionen angewendet werden.

**Beispiel:**

```sql
-- Nur aktive Benutzer ausw√§hlen
SELECT id, name
FROM users
WHERE active = true;
```

---

### **2. HAVING**

* Filtert **Gruppen** nach einer Aggregation.
* Wird **nach GROUP BY** ausgef√ºhrt.
* Kann Bedingungen mit Aggregatfunktionen enthalten.

**Beispiel:**

```sql
-- Nur Benutzer anzeigen, die mehr als 2 Bestellungen haben
SELECT user_id, COUNT(*) AS total_orders
FROM orders
GROUP BY user_id
HAVING COUNT(*) > 2;
```

---

### **Vergleich in Kurzform**

| Merkmal       | WHERE                 | HAVING                             |
| ------------- | --------------------- | ---------------------------------- |
| Zeitpunkt     | Vor der Gruppierung   | Nach der Gruppierung               |
| Filtert       | Einzelne Zeilen       | Ganze Gruppen                      |
| Aggregatfunk. | Nicht erlaubt         | Erlaubt (z. B. `SUM()`, `COUNT()`) |
| Typischer Use | `WHERE active = true` | `HAVING COUNT(*) > 2`              |

---

**Zusammenfassung:**

* **WHERE** filtert Zeilen vor der Gruppierung.
* **HAVING** filtert Gruppen nach der Aggregation.

üìñ Quellen:

* [PostgreSQL Docs ‚Äì SELECT](https://www.postgresql.org/docs/current/sql-select.html)
* [MDN SQL HAVING (RU)](https://developer.mozilla.org/ru/docs/Web/SQL/HAVING)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

14. ### <a name="14"></a> Unterschied zwischen DISTINCT und GROUP BY?

### **Unterschied zwischen `DISTINCT` und `GROUP BY`**

---

### **1. DISTINCT**

* Entfernt **Duplikate** aus dem Ergebnis.
* Liefert eine **Liste einzigartiger Zeilen**.
* Keine Aggregatfunktionen erforderlich.

**Beispiel:**

```sql
-- Alle einzigartigen St√§dte aus der Kundentabelle
SELECT DISTINCT city
FROM customers;
```

‚û°Ô∏è Gibt jede Stadt nur **einmal** zur√ºck.

---

### **2. GROUP BY**

* Fasst Zeilen zu **Gruppen** zusammen, basierend auf einer oder mehreren Spalten.
* Wird fast immer mit **Aggregatfunktionen** (`COUNT`, `SUM`, `AVG`, ‚Ä¶) genutzt.
* Ohne Aggregatfunktion verh√§lt es sich √§hnlich wie DISTINCT, ist aber flexibler.

**Beispiel:**

```sql
-- Anzahl der Kunden pro Stadt
SELECT city, COUNT(*) AS customer_count
FROM customers
GROUP BY city;
```

‚û°Ô∏è Gibt pro Stadt **eine Zeile** zur√ºck, zus√§tzlich mit Aggregatwerten.

---

### **Vergleich**

| Merkmal            | DISTINCT                               | GROUP BY                                     |
| ------------------ | -------------------------------------- | -------------------------------------------- |
| Zweck              | Entfernt Duplikate                     | Gruppiert Zeilen                             |
| Aggregatfunktionen | Nicht n√∂tig                            | Typisch notwendig (`COUNT`, `SUM`, ‚Ä¶)        |
| Ergebnis           | Einzigartige Kombinationen von Spalten | Eine Zeile pro Gruppe, oft mit Aggregaten    |
| Beispiel           | `SELECT DISTINCT city`                 | `SELECT city, COUNT(*) FROM ‚Ä¶ GROUP BY city` |

---

### **Beispiel mit gleichem Ergebnis**

```sql
-- DISTINCT
SELECT DISTINCT city FROM customers;

-- GROUP BY (ohne Aggregat)
SELECT city FROM customers GROUP BY city;
```

‚û°Ô∏è Beide geben eine Liste einzigartiger St√§dte zur√ºck.
Aber: **GROUP BY** erlaubt zus√§tzlich Berechnungen pro Gruppe.

---

**Zusammenfassung:**

* **DISTINCT** entfernt nur Duplikate.
* **GROUP BY** gruppiert Daten und wird oft mit Aggregatfunktionen verwendet.

üìñ Quellen:

* [PostgreSQL Docs ‚Äì SELECT](https://www.postgresql.org/docs/current/sql-select.html)
* [MDN SQL DISTINCT (RU)](https://developer.mozilla.org/ru/docs/Web/SQL/Distinct)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

15. ### <a name="15"></a> Was sind Aggregatfunktionen (COUNT, SUM, AVG, MIN, MAX)?

### **Aggregatfunktionen in SQL**

Aggregatfunktionen fassen mehrere Zeilen zu einem einzigen Wert zusammen. Sie werden oft mit **`GROUP BY`** kombiniert.

---

### **1. COUNT()**

Z√§hlt die Anzahl der Zeilen (oder nicht-NULL-Werte einer Spalte).

```sql
-- Anzahl aller Kunden
SELECT COUNT(*) FROM customers;

-- Anzahl der Kunden mit Email
SELECT COUNT(email) FROM customers;
```

---

### **2. SUM()**

Berechnet die Summe numerischer Werte.

```sql
-- Gesamtsumme aller Bestellungen
SELECT SUM(amount) AS total_sales
FROM orders;
```

---

### **3. AVG()**

Berechnet den Durchschnittswert.

```sql
-- Durchschnittlicher Bestellwert
SELECT AVG(amount) AS avg_order
FROM orders;
```

---

### **4. MIN()**

Gibt den kleinsten Wert zur√ºck.

```sql
-- G√ºnstigste Bestellung
SELECT MIN(amount) AS min_order
FROM orders;
```

---

### **5. MAX()**

Gibt den gr√∂√üten Wert zur√ºck.

```sql
-- Teuerste Bestellung
SELECT MAX(amount) AS max_order
FROM orders;
```

---

### **Beispiel mit GROUP BY**

```sql
-- Anzahl und durchschnittlicher Umsatz pro Kunde
SELECT customer_id,
       COUNT(*) AS orders_count,
       SUM(amount) AS total_spent,
       AVG(amount) AS avg_spent,
       MIN(amount) AS min_order,
       MAX(amount) AS max_order
FROM orders
GROUP BY customer_id;
```

‚û°Ô∏è Ergebnis: eine Zeile pro Kunde mit Statistiken.

---

**Zusammenfassung:**

* **COUNT()** ‚Üí Anzahl
* **SUM()** ‚Üí Summe
* **AVG()** ‚Üí Durchschnitt
* **MIN()** ‚Üí Kleinster Wert
* **MAX()** ‚Üí Gr√∂√üter Wert

üìñ Quellen:

* [PostgreSQL Docs ‚Äì Aggregate Functions](https://www.postgresql.org/docs/current/functions-aggregate.html)
* [MDN SQL Aggregate Functions (RU)](https://developer.mozilla.org/ru/docs/Web/SQL/Aggregate_functions)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

16. ### <a name="16"></a> Wie funktioniert ORDER BY und LIMIT?

### **ORDER BY**

* Sortiert die Ergebniszeilen einer Abfrage.
* Standardm√§√üig **aufsteigend (`ASC`)**, absteigend mit **`DESC`**.
* Kann nach mehreren Spalten sortieren.

**Beispiele:**

```sql
-- Alle Kunden nach Name (aufsteigend)
SELECT id, name FROM customers
ORDER BY name ASC;

-- Bestellungen nach Betrag (absteigend)
SELECT id, amount FROM orders
ORDER BY amount DESC;

-- Mehrfachsortierung: erst nach Stadt, dann nach Name
SELECT id, name, city FROM customers
ORDER BY city ASC, name ASC;
```

---

### **LIMIT**

* Begrenzt die Anzahl der zur√ºckgegebenen Zeilen.
* Praktisch f√ºr **Pagination** oder Testabfragen.

**Beispiele:**

```sql
-- Nur die ersten 5 Kunden
SELECT * FROM customers
LIMIT 5;

-- Teuerste Bestellung (1 Ergebnis)
SELECT * FROM orders
ORDER BY amount DESC
LIMIT 1;
```

---

### **ORDER BY + LIMIT (Pagination)**

Mit `OFFSET` kann man Ergebnisse ‚Äû√ºberspringen‚Äú ‚Üí wichtig f√ºr **Seitenweise Anzeige**.

```sql
-- Seite 1: erste 10 Ergebnisse
SELECT * FROM products
ORDER BY name
LIMIT 10 OFFSET 0;

-- Seite 2: n√§chste 10 Ergebnisse
SELECT * FROM products
ORDER BY name
LIMIT 10 OFFSET 10;
```

---

### **Vergleich**

| Befehl   | Zweck                            |
| -------- | -------------------------------- |
| ORDER BY | Sortiert die Ergebnismenge       |
| LIMIT    | Beschr√§nkt die Anzahl der Zeilen |
| OFFSET   | √úberspringt bestimmte Zeilen     |

---

**Zusammenfassung:**

* **ORDER BY** ‚Üí sortiert Ergebnisse.
* **LIMIT** ‚Üí begrenzt Anzahl der Zeilen.
* Mit **OFFSET** ‚Üí einfache Pagination m√∂glich.

üìñ Quellen:

* [PostgreSQL Docs ‚Äì ORDER BY](https://www.postgresql.org/docs/current/queries-order.html)
* [PostgreSQL Docs ‚Äì LIMIT/OFFSET](https://www.postgresql.org/docs/current/queries-limit.html)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

17. ### <a name="17"></a> Was ist ein Subquery (Unterabfrage)?

### **Subquery (Unterabfrage) in SQL**

Ein **Subquery** ist eine **verschachtelte Abfrage** innerhalb einer anderen SQL-Anweisung.
Die Unterabfrage wird zuerst ausgef√ºhrt, und ihr Ergebnis wird in der √§u√üeren Abfrage verwendet.

---

### **Arten von Subqueries**

1. **Im `WHERE` oder `HAVING` (skalare oder Mengenabfrage)**

```sql
-- Kunden, die mindestens eine Bestellung gemacht haben
SELECT id, name
FROM customers
WHERE id IN (SELECT DISTINCT customer_id FROM orders);
```

2. **Im `FROM` (Subquery als virtuelle Tabelle)**

```sql
-- Durchschnittlicher Bestellwert pro Kunde
SELECT t.customer_id, AVG(t.amount) AS avg_amount
FROM (
  SELECT customer_id, amount
  FROM orders
) t
GROUP BY t.customer_id;
```

3. **Im `SELECT` (skalare Subquery)**

```sql
-- Kunden mit Anzahl ihrer Bestellungen
SELECT name,
       (SELECT COUNT(*) FROM orders o WHERE o.customer_id = c.id) AS total_orders
FROM customers c;
```

---

### **Eigenschaften**

* Kann **einen Wert** (skalare Subquery), **eine Liste** oder **eine Tabelle** zur√ºckgeben.
* Kann mit Operatoren wie `IN`, `EXISTS`, `=`, `> ALL` usw. kombiniert werden.
* K√∂nnen **korreliert** sein ‚Üí Zugriff auf Spalten der √§u√üeren Abfrage.

**Beispiel (korrelierte Subquery):**

```sql
-- Bestellungen, die √ºber dem Durchschnittswert des jeweiligen Kunden liegen
SELECT o.id, o.amount
FROM orders o
WHERE o.amount > (
  SELECT AVG(amount)
  FROM orders
  WHERE customer_id = o.customer_id
);
```

---

**Zusammenfassung:**
Ein **Subquery** ist eine Abfrage in einer anderen Abfrage.

* Im `WHERE`/`HAVING`: Filterung.
* Im `FROM`: virtuelle Tabelle.
* Im `SELECT`: einzelner Wert.
* Kann **korreliert** oder **nicht korreliert** sein.

üìñ Quellen:

* [PostgreSQL Docs ‚Äì Subqueries](https://www.postgresql.org/docs/current/functions-subquery.html)
* [MDN Glossar ‚Äì Subquery (RU)](https://developer.mozilla.org/ru/docs/Glossary/Subquery)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

18. ### <a name="18"></a> Unterschied zwischen korrelierter und nicht-korrelierter Unterabfrage?

### **Unterschied zwischen korrelierter und nicht-korrelierter Unterabfrage**

---

### **1. Nicht-korrelierte Unterabfrage**

* Wird **einmal** ausgef√ºhrt, unabh√§ngig von der √§u√üeren Abfrage.
* Ergebnis wird dann in der √§u√üeren Abfrage verwendet.

**Beispiel:**

```sql
-- Alle Bestellungen, die √ºber dem globalen Durchschnitt liegen
SELECT id, amount
FROM orders
WHERE amount > (SELECT AVG(amount) FROM orders);
```

‚û°Ô∏è Die Subquery `(SELECT AVG(amount) FROM orders)` wird **einmal berechnet**.

---

### **2. Korrelierte Unterabfrage**

* Wird **f√ºr jede Zeile der √§u√üeren Abfrage erneut ausgef√ºhrt**.
* Bezieht sich auf Spalten der √§u√üeren Abfrage.

**Beispiel:**

```sql
-- Bestellungen, die √ºber dem Durchschnitt des jeweiligen Kunden liegen
SELECT o.id, o.amount
FROM orders o
WHERE o.amount > (
  SELECT AVG(amount)
  FROM orders
  WHERE customer_id = o.customer_id
);
```

‚û°Ô∏è F√ºr jede Bestellung `o` wird die Subquery neu ausgef√ºhrt.

---

### **Vergleich**

| Merkmal      | Nicht-korreliert               | Korrelierte Unterabfrage                   |
| ------------ | ------------------------------ | ------------------------------------------ |
| Ausf√ºhrung   | Einmal                         | F√ºr jede Zeile der √§u√üeren Abfrage         |
| Abh√§ngigkeit | Unabh√§ngig von √§u√üerer Abfrage | Verweist auf Spalten der √§u√üeren Abfrage   |
| Performance  | Meist effizienter              | Potenziell langsamer (mehrfach ausgef√ºhrt) |
| Beispiel     | Globaler Durchschnitt          | Durchschnitt pro Kunde                     |

---

**Zusammenfassung:**

* **Nicht-korrelierte Subquery**: unabh√§ngig, einmal berechnet.
* **Korrelierte Subquery**: abh√§ngig, mehrfach berechnet.

üìñ Quellen:

* [PostgreSQL Docs ‚Äì Subqueries](https://www.postgresql.org/docs/current/functions-subquery.html)
* [MDN Glossar ‚Äì Subquery (RU)](https://developer.mozilla.org/ru/docs/Glossary/Subquery)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

19. ### <a name="19"></a> Unterschied zwischen EXISTS und IN?

### **Unterschied zwischen `EXISTS` und `IN`**

---

### **1. `IN`**

* Vergleicht einen Wert mit einer **Liste von Werten** oder dem Ergebnis einer Subquery.
* Subquery liefert eine **Liste von Werten** zur√ºck.
* Eher geeignet, wenn wenige Werte zur√ºckgegeben werden.

**Beispiel:**

```sql
-- Kunden, die Bestellungen gemacht haben
SELECT name
FROM customers
WHERE id IN (SELECT customer_id FROM orders);
```

---

### **2. `EXISTS`**

* Pr√ºft, ob eine **Subquery mindestens eine Zeile** zur√ºckgibt.
* Liefert `TRUE`, sobald ein Treffer gefunden wird (optimiert).
* Eher geeignet, wenn viele Werte zur√ºckgegeben werden.

**Beispiel:**

```sql
-- Kunden, die Bestellungen gemacht haben
SELECT name
FROM customers c
WHERE EXISTS (
  SELECT 1
  FROM orders o
  WHERE o.customer_id = c.id
);
```

---

### **Technische Unterschiede**

| Merkmal      | `IN`                                           | `EXISTS`                             |
| ------------ | ---------------------------------------------- | ------------------------------------ |
| R√ºckgabewert | Vergleicht mit Liste von Werten                | Liefert TRUE/FALSE                   |
| Subquery-Typ | Muss Spalte(n) zur√ºckgeben                     | Beliebige Abfrage (meist `SELECT 1`) |
| Performance  | Gut bei kleiner Ergebnismenge                  | Gut bei gro√üer Ergebnismenge         |
| NULL-Werte   | K√∂nnen zu Problemen f√ºhren (z. B. `IN (NULL)`) | Beeintr√§chtigen `EXISTS` nicht       |

---

### **Beispiel mit NULL-Problematik**

```sql
-- Problem mit IN, falls Subquery NULL enth√§lt
SELECT name
FROM customers
WHERE id IN (SELECT customer_id FROM orders); -- Falls NULL dabei ist ‚Üí Ergebnis kann leer sein

-- EXISTS vermeidet das Problem
SELECT name
FROM customers c
WHERE EXISTS (
  SELECT 1 FROM orders o WHERE o.customer_id = c.id
);
```

---

**Zusammenfassung:**

* **`IN`** ‚Üí vergleicht mit Werteliste, gut f√ºr kleine Mengen.
* **`EXISTS`** ‚Üí pr√ºft nur Existenz, besser bei gro√üen Datenmengen und sicherer bei NULL-Werten.

üìñ Quellen:

* [PostgreSQL Docs ‚Äì Subqueries with IN/EXISTS](https://www.postgresql.org/docs/current/functions-subquery.html)
* [MDN SQL Subquery (RU)](https://developer.mozilla.org/ru/docs/Glossary/Subquery)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

20. ### <a name="20"></a> Unterschied zwischen UNION und UNION ALL?

### **Unterschied zwischen `UNION` und `UNION ALL`**

---

### **1. UNION**

* Kombiniert Ergebnisse von zwei oder mehr `SELECT`-Abfragen.
* Entfernt **Duplikate** automatisch.
* F√ºhrt implizit ein **`DISTINCT`** auf allen zur√ºckgegebenen Zeilen aus.
* Etwas langsamer, da ein Sortierschritt n√∂tig ist.

**Beispiel:**

```sql
-- Gibt jede Stadt nur einmal zur√ºck
SELECT city FROM customers
UNION
SELECT city FROM suppliers;
```

---

### **2. UNION ALL**

* Kombiniert Ergebnisse von zwei oder mehr `SELECT`-Abfragen.
* Beh√§lt **alle Duplikate** bei.
* Schneller, da keine zus√§tzliche Pr√ºfung auf Duplikate erfolgt.

**Beispiel:**

```sql
-- Gibt auch doppelte St√§dte zur√ºck
SELECT city FROM customers
UNION ALL
SELECT city FROM suppliers;
```

---

### **Vergleich**

| Merkmal       | UNION                                             | UNION ALL                            |
| ------------- | ------------------------------------------------- | ------------------------------------ |
| Duplikate     | Entfernt automatisch                              | Beh√§lt alle                          |
| Performance   | Langsamer (wegen DISTINCT)                        | Schneller                            |
| Typischer Use | Wenn nur **eindeutige Ergebnisse** gew√ºnscht sind | Wenn **alle Daten** gebraucht werden |

---

**Zusammenfassung:**

* **`UNION`** = Kombination ohne Duplikate (langsamer).
* **`UNION ALL`** = Kombination mit allen Zeilen, inkl. Duplikaten (schneller).

üìñ Quellen:

* [PostgreSQL Docs ‚Äì UNION](https://www.postgresql.org/docs/current/queries-union.html)
* [MDN SQL UNION (RU)](https://developer.mozilla.org/ru/docs/Web/SQL/UNION)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

21. ### <a name="21"></a> Was ist PostgreSQL und welche Vorteile hat es gegen√ºber MySQL?

### **PostgreSQL**

PostgreSQL ist ein **objektrelationales Open-Source-Datenbankmanagementsystem (DBMS)**.
Es gilt als sehr stabil, ACID-konform und wird f√ºr kleine wie auch hochskalierte Anwendungen genutzt.

---

### **Vorteile von PostgreSQL gegen√ºber MySQL**

1. **Standardkonformit√§t & Features**

* Vollst√§ndige ACID-Unterst√ºtzung.
* M√§chtige SQL-Funktionen (z. B. CTEs, Window Functions, rekursive Abfragen).
* Unterst√ºtzung f√ºr komplexe Datentypen (JSONB, Arrays, HSTORE, Geodaten via PostGIS).

2. **Erweiterbarkeit**

* Eigene Funktionen, Operatoren und Datentypen definierbar.
* Erweiterungen wie **PostGIS**, **pg\_partman** (Partitionierung), **TimescaleDB** (Zeitreihen).

3. **Leistungsst√§rke bei komplexen Abfragen**

* Optimierter Query Planner.
* Bessere Performance bei **Joins, Aggregationen und OLAP**-√§hnlichen Workloads.

4. **Transaktionen & Sicherheit**

* `SERIALIZABLE` Isolation Level voll implementiert.
* Starke Rolle-/Rechteverwaltung.
* Unterst√ºtzung f√ºr Row-Level Security (RLS).

5. **JSON-Unterst√ºtzung**

* **JSONB** mit Indizes, ideal f√ºr hybride SQL/NoSQL-Anwendungen.
* MySQL unterst√ºtzt JSON, aber weniger effizient und ohne so flexible Indexierung.

6. **Open-Source-Community & Stabilit√§t**

* Sehr aktive Community, strenge Code-Qualit√§t.
* Mehr als 30 Jahre Entwicklungsgeschichte.

---

### **Wann ist MySQL vorteilhaft?**

* Einfachere Einrichtung, oft **besser f√ºr kleinere Webanwendungen**.
* Breite Unterst√ºtzung durch viele Hosting-Anbieter (z. B. WordPress, PHP-Umgebungen).
* Performance-Vorteile bei **simplen Lese-lastigen Workloads**.

---

### **Vergleichs√ºbersicht**

| Merkmal            | PostgreSQL                                | MySQL                               |
| ------------------ | ----------------------------------------- | ----------------------------------- |
| ACID               | Vollst√§ndig implementiert                 | Teilweise (InnoDB notwendig)        |
| JSON-Unterst√ºtzung | JSON + JSONB mit Indizes                  | JSON (eingeschr√§nkt)                |
| Erweiterbarkeit    | Sehr hoch (Extensions, eigene Datentypen) | Begrenzt                            |
| Komplexe Abfragen  | Sehr stark (Window, CTE, rekursiv)        | Weniger leistungsf√§hig              |
| Performance        | St√§rker bei komplexen Queries             | Oft schneller bei einfachen Queries |
| Community          | Stark, akademisch & professionell         | Sehr gro√ü im Web-Bereich            |

---

**Zusammenfassung:**

* **PostgreSQL** ist m√§chtiger, erweiterbarer und besser f√ºr komplexe Anwendungen.
* **MySQL** ist einfacher, weit verbreitet und besser f√ºr kleine bis mittlere Webprojekte.

üìñ Quellen:

* [PostgreSQL Docs](https://www.postgresql.org/docs/)
* [MySQL Docs](https://dev.mysql.com/doc/)
* [Vergleich PostgreSQL vs. MySQL (MDN RU)](https://developer.mozilla.org/ru/docs/Glossary/SQL)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

22. ### <a name="22"></a> Was sind Datentypen in PostgreSQL (TEXT, VARCHAR, SERIAL, JSONB)?

### **Datentypen in PostgreSQL (TEXT, VARCHAR, SERIAL, JSONB)**

PostgreSQL bietet eine gro√üe Vielfalt an Datentypen. Einige der wichtigsten sind:

---

### **1. TEXT**

* Speichert Zeichenketten beliebiger L√§nge (theoretisch bis 1 GB).
* Kein L√§ngenlimit erforderlich.
* Praktisch identisch zu `VARCHAR` ohne L√§ngenbeschr√§nkung.

**Beispiel:**

```sql
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  bio TEXT
);
```

---

### **2. VARCHAR(n)**

* Variable L√§nge, aber mit **maximaler Zeichenanzahl n**.
* Bei √úberschreiten ‚Üí Fehler.
* In PostgreSQL gibt es **keinen Performance-Unterschied** zu `TEXT`.

**Beispiel:**

```sql
CREATE TABLE products (
  id SERIAL PRIMARY KEY,
  name VARCHAR(100) -- max. 100 Zeichen
);
```

---

### **3. SERIAL**

* Pseudotyp f√ºr **Auto-Increment Integer**.
* Erstellt automatisch eine **Sequenz** und setzt sie als Default f√ºr die Spalte.
* Typisch f√ºr Prim√§rschl√ºssel.
* In modernen PostgreSQL-Versionen ersetzt durch `GENERATED AS IDENTITY`.

**Beispiel:**

```sql
CREATE TABLE orders (
  id SERIAL PRIMARY KEY,
  amount NUMERIC(10,2)
);
```

---

### **4. JSONB**

* Bin√§re Form von JSON, effizienter als `JSON`.
* Vorteile:

  * Kompakter Speicher.
  * Unterst√ºtzt **Indexierung** (`GIN`-Index).
  * Schnelle Abfragen innerhalb von JSON-Daten.

**Beispiel:**

```sql
CREATE TABLE events (
  id SERIAL PRIMARY KEY,
  data JSONB
);

-- Einf√ºgen
INSERT INTO events (data)
VALUES ('{"type": "login", "user": "max"}');

-- Abfragen
SELECT data->>'user'
FROM events
WHERE data->>'type' = 'login';
```

---

### **Vergleich**

| Datentyp    | Beschreibung                         | Typische Nutzung                |
| ----------- | ------------------------------------ | ------------------------------- |
| **TEXT**    | Zeichenketten beliebiger L√§nge       | Freitext, lange Texte           |
| **VARCHAR** | Zeichenkette mit L√§ngenlimit         | Namen, Codes, begrenzte Strings |
| **SERIAL**  | Auto-Increment Ganzzahl              | Prim√§rschl√ºssel                 |
| **JSONB**   | JSON in bin√§rer Form mit Indexierung | Semi-strukturierte Daten, Logs  |

---

**Zusammenfassung:**

* **TEXT** und **VARCHAR** sind f√ºr Strings ‚Üí praktisch gleichwertig in PostgreSQL.
* **SERIAL** = Auto-Increment f√ºr Prim√§rschl√ºssel (heute: `IDENTITY`).
* **JSONB** = flexibler, indexierbarer Datentyp f√ºr semi-strukturierte Daten.

üìñ Quellen:

* [PostgreSQL Docs ‚Äì Data Types](https://www.postgresql.org/docs/current/datatype.html)
* [PostgreSQL Docs ‚Äì JSON Types](https://www.postgresql.org/docs/current/datatype-json.html)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

23. ### <a name="23"></a> Unterschied zwischen SERIAL und BIGSERIAL?

### **Unterschied zwischen `SERIAL` und `BIGSERIAL` in PostgreSQL**

---

### **1. SERIAL**

* Alias f√ºr `INTEGER` + automatische Sequenz.
* Wertebereich: **-2.147.483.648 bis 2.147.483.647** (\~2,1 Mrd).
* F√ºr kleine bis mittlere Tabellen geeignet.

**Beispiel:**

```sql
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  name TEXT
);
```

---

### **2. BIGSERIAL**

* Alias f√ºr `BIGINT` + automatische Sequenz.
* Wertebereich: **-9.223.372.036.854.775.808 bis 9.223.372.036.854.775.807** (\~9 Quintillionen).
* F√ºr sehr gro√üe Tabellen mit extrem vielen Zeilen.

**Beispiel:**

```sql
CREATE TABLE logs (
  id BIGSERIAL PRIMARY KEY,
  message TEXT
);
```

---

### **Vergleich**

| Merkmal        | SERIAL (INTEGER)                     | BIGSERIAL (BIGINT)                           |
| -------------- | ------------------------------------ | -------------------------------------------- |
| Speichergr√∂√üe  | 4 Byte                               | 8 Byte                                       |
| Max. Wert      | \~ 2,1 Milliarden                    | \~ 9,2 Quintillionen                         |
| Performance    | Minimal schneller (kleiner Datentyp) | Minimal langsamer (gr√∂√üerer Datentyp)        |
| Anwendungsfall | Normale Tabellen                     | Sehr gro√üe Tabellen (Milliarden+ Datens√§tze) |

---

**Zusammenfassung:**

* **SERIAL** ‚Üí 32-Bit, reicht f√ºr die meisten Anwendungen.
* **BIGSERIAL** ‚Üí 64-Bit, f√ºr extrem gro√üe Tabellen.

üìñ Quellen:

* [PostgreSQL Docs ‚Äì SERIAL Types](https://www.postgresql.org/docs/current/datatype-numeric.html#DATATYPE-SERIAL)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

24. ### <a name="24"></a> Wie arbeitet PostgreSQL mit Arrays?

### **Arrays in PostgreSQL**

PostgreSQL unterst√ºtzt **Arrays als Datentyp**. Eine Spalte kann mehrere Werte desselben Typs speichern (z. B. `INTEGER[]`, `TEXT[]`).

---

### **1. Array-Datentyp definieren**

```sql
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  name TEXT,
  tags TEXT[] -- Array von Textwerten
);
```

---

### **2. Array-Werte einf√ºgen**

```sql
INSERT INTO users (name, tags)
VALUES ('Max', ARRAY['admin', 'editor']),
       ('Anna', '{"guest","beta"}'); -- alternative Syntax
```

---

### **3. Zugriff auf Array-Elemente**

* Einzelnes Element mit Index (1-basiert!).
* Slice mit Bereich.

```sql
-- Erstes Tag von Max
SELECT tags[1] FROM users WHERE name = 'Max';

-- Erstes bis zweites Element
SELECT tags[1:2] FROM users WHERE name = 'Max';
```

---

### **4. Array-Funktionen und Operatoren**

* **Mit Element vergleichen:** `= ANY(array)`
* **Array enth√§lt Wert:** `array @> array`
* **Array ist enthalten in:** `array <@ array`
* **√úberschneidung pr√ºfen:** `&&`

```sql
-- Alle User mit Tag 'admin'
SELECT name
FROM users
WHERE 'admin' = ANY(tags);

-- User, deren Tags 'admin' enthalten
SELECT name
FROM users
WHERE tags @> ARRAY['admin'];
```

---

### **5. N√ºtzliche Funktionen**

* `unnest()` ‚Üí Array in mehrere Zeilen aufl√∂sen
* `array_length()` ‚Üí L√§nge bestimmen
* `array_append()` / `array_remove()`

```sql
-- Array in Zeilen umwandeln
SELECT unnest(tags) FROM users WHERE name = 'Max';

-- L√§nge des Arrays
SELECT array_length(tags, 1) FROM users WHERE name = 'Max';
```

---

**Zusammenfassung:**
PostgreSQL bietet Arrays als nativen Datentyp mit flexiblem Zugriff, Vergleichsoperatoren und n√ºtzlichen Funktionen wie `unnest()`. Arrays sind praktisch f√ºr Tags, Labels oder kleine Listen, aber bei stark relationalen Daten sind **separate Tabellen + JOINs** oft die bessere Wahl.

üìñ Quellen:

* [PostgreSQL Docs ‚Äì Arrays](https://www.postgresql.org/docs/current/arrays.html)


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

25. ### <a name="25"></a> Was ist der Unterschied zwischen JSON und JSONB in PostgreSQL?

### **Unterschied zwischen `JSON` und `JSONB` in PostgreSQL**

---

### **1. JSON**

* Speichert Daten als **reinen Text** im JSON-Format.
* Speicherung erfolgt genau so, wie die Eingabe ist (inkl. Whitespaces, Keys-Reihenfolge).
* Vorteile:

  * Originalformat bleibt unver√§ndert.
  * Weniger Rechenaufwand beim Einf√ºgen.
* Nachteile:

  * Keine Indexierung m√∂glich.
  * Langsamer bei Abfragen und Filtern.

**Beispiel:**

```sql
CREATE TABLE events (
  id SERIAL PRIMARY KEY,
  data JSON
);

INSERT INTO events (data)
VALUES ('{ "user": "Max", "role": "admin" }');
```

---

### **2. JSONB**

* Speichert JSON-Daten im **bin√§ren Format**.
* Entfernt unn√∂tige Whitespaces, sortiert Keys.
* Vorteile:

  * Unterst√ºtzt **Indizes** (z. B. GIN-Index).
  * Schnellere Abfragen und Vergleiche.
  * Bessere Operatoren und Funktionen.
* Nachteile:

  * Etwas langsamer beim Einf√ºgen (wegen Konvertierung in Bin√§rformat).

**Beispiel:**

```sql
CREATE TABLE events_b (
  id SERIAL PRIMARY KEY,
  data JSONB
);

-- Abfrage mit Filter
SELECT data->>'user'
FROM events_b
WHERE data @> '{"role": "admin"}';
```

Mit Index:

```sql
CREATE INDEX idx_events_data ON events_b USING gin (data);
```

---

### **Vergleich**

| Merkmal            | JSON                         | JSONB                         |
| ------------------ | ---------------------------- | ----------------------------- |
| Speicherung        | Text (wie eingegeben)        | Bin√§r, normalisiert           |
| Whitespaces / Keys | Werden gespeichert           | Ignoriert, Keys sortiert      |
| Einf√ºgen           | Schneller                    | Etwas langsamer               |
| Abfragen           | Langsamer                    | Schneller, da bin√§r           |
| Indexierung        | Nicht m√∂glich                | M√∂glich (z. B. GIN-Index)     |
| Nutzung            | Archivierung, Originalformat | Aktive Queries, Filter, Suche |

---

**Zusammenfassung:**

* **JSON** ‚Üí schneller beim Schreiben, speichert Originalformat, keine Indizes.
* **JSONB** ‚Üí optimal f√ºr Abfragen und Suche, unterst√ºtzt Indizes, braucht aber mehr beim Einf√ºgen.

üìñ Quellen:

* [PostgreSQL Docs ‚Äì JSON Types](https://www.postgresql.org/docs/current/datatype-json.html)


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

26. ### <a name="26"></a> Wie speichert und verarbeitet PostgreSQL Zeitstempel (TIMESTAMP, TIMESTAMPTZ)?

### **Zeitstempel in PostgreSQL: `TIMESTAMP` vs. `TIMESTAMPTZ`**

---

### **1. TIMESTAMP (without time zone)**

* Speichert **Datum + Uhrzeit**, aber **ohne Zeitzonen-Information**.
* Werte werden so gespeichert, wie sie eingegeben werden.
* Keine automatische Anpassung an Zeitzonen.

**Beispiel:**

```sql
CREATE TABLE events (
  id SERIAL PRIMARY KEY,
  created_at TIMESTAMP
);

INSERT INTO events (created_at)
VALUES ('2025-09-06 15:00:00'); -- bleibt exakt so gespeichert
```

---

### **2. TIMESTAMPTZ (TIMESTAMP WITH TIME ZONE)**

* Speichert **Zeitpunkt in UTC**, zeigt ihn aber abh√§ngig von der Session-Zeitzone an.
* Bei Eingabe wird automatisch nach UTC konvertiert.
* Sicherer f√ºr globale Anwendungen.

**Beispiel:**

```sql
CREATE TABLE events_tz (
  id SERIAL PRIMARY KEY,
  created_at TIMESTAMPTZ
);

-- Eingabe mit Zeitzone
INSERT INTO events_tz (created_at)
VALUES ('2025-09-06 15:00:00+02'); -- wird in UTC gespeichert

-- Anzeige in aktueller Session-Zeitzone
SET TIMEZONE = 'Europe/Berlin';
SELECT created_at FROM events_tz;
```

‚û°Ô∏è Wenn Session-Zeitzone `UTC` ist ‚Üí `2025-09-06 13:00:00+00`
‚û°Ô∏è Wenn Session-Zeitzone `Europe/Berlin` ist ‚Üí `2025-09-06 15:00:00+02`

---

### **Vergleich**

| Merkmal    | TIMESTAMP             | TIMESTAMPTZ                        |
| ---------- | --------------------- | ---------------------------------- |
| Zeitzone   | Keine Speicherung     | Speicherung in UTC + Konvertierung |
| Konsistenz | Lokal g√ºltig          | Global eindeutig                   |
| Verwendung | F√ºr rein lokale Daten | F√ºr globale Systeme, APIs, Logs    |

---

### **Best Practices**

* F√ºr **globale Anwendungen** (Web, APIs, Logs) ‚Üí **TIMESTAMPTZ** verwenden.
* F√ºr **rein lokale Daten** (z. B. √ñffnungszeiten) ‚Üí **TIMESTAMP** reicht.

---

**Zusammenfassung:**

* **TIMESTAMP** = Datum + Uhrzeit ohne Zeitzone.
* **TIMESTAMPTZ** = Datum + Uhrzeit mit Zeitzonenunterst√ºtzung (intern UTC).
* Empfehlung: Standardm√§√üig **TIMESTAMPTZ** nutzen, da es konsistenter f√ºr globale Systeme ist.

üìñ Quellen:

* [PostgreSQL Docs ‚Äì Date/Time Types](https://www.postgresql.org/docs/current/datatype-datetime.html)


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

27. ### <a name="27"></a> Was sind Sequences in PostgreSQL?

### **Sequences in PostgreSQL**

Eine **Sequence** ist ein spezielles Datenbankobjekt, das fortlaufende **Zahlenwerte** generiert.
Sie wird oft f√ºr **Prim√§rschl√ºssel (Auto-Increment)** verwendet.

---

### **1. Sequence erstellen**

```sql
CREATE SEQUENCE user_id_seq
  START 1      -- Startwert
  INCREMENT 1  -- Schrittweite
  MINVALUE 1
  MAXVALUE 1000000
  CYCLE;       -- optional: nach MAXVALUE wieder von vorne beginnen
```

---

### **2. Werte abrufen**

```sql
-- N√§chster Wert
SELECT nextval('user_id_seq');

-- Aktueller Wert (ohne Erh√∂hung)
SELECT currval('user_id_seq');

-- Wert zur√ºcksetzen
ALTER SEQUENCE user_id_seq RESTART WITH 1;
```

---

### **3. Nutzung in Tabellen**

```sql
CREATE TABLE users (
  id INT DEFAULT nextval('user_id_seq') PRIMARY KEY,
  name TEXT
);
```

Oder direkt mit **SERIAL / BIGSERIAL / IDENTITY** (nutzt intern auch Sequences):

```sql
CREATE TABLE orders (
  id SERIAL PRIMARY KEY,
  amount NUMERIC
);
```

---

### **4. Vorteile**

* Garantierte eindeutige Werte.
* Unabh√§ngig von Tabellen nutzbar.
* Flexibel (kann mit beliebigen INCREMENT, START, CYCLE konfiguriert werden).

---

### **Unterschied zu `SERIAL` / `IDENTITY`**

* `SERIAL` / `IDENTITY` sind nur **Convenience-Shortcuts**, die intern automatisch eine Sequence anlegen.
* Mit einer **manuell definierten Sequence** hat man mehr Kontrolle (z. B. mehrere Tabellen nutzen dieselbe Sequence).

---

**Zusammenfassung:**
Sequences sind Objekte in PostgreSQL zur Erzeugung fortlaufender eindeutiger Zahlen.
Sie werden oft f√ºr Auto-Increment-Spalten verwendet und bilden die Basis f√ºr `SERIAL` und `IDENTITY`.

üìñ Quellen:

* [PostgreSQL Docs ‚Äì Sequences](https://www.postgresql.org/docs/current/sql-createsequence.html)


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

28. ### <a name="28"></a> Wie implementiert man Auto-Increment in PostgreSQL?

### **Auto-Increment in PostgreSQL**

PostgreSQL unterst√ºtzt mehrere M√∂glichkeiten, automatisch fortlaufende IDs zu erzeugen.

---

### **1. SERIAL (klassisch, √§lterer Ansatz)**

* K√ºrzel f√ºr: `INTEGER` + `DEFAULT nextval(sequence)`
* Legt im Hintergrund automatisch eine **Sequence** an.

```sql
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  name TEXT
);
```

‚û°Ô∏è `id` wird bei jedem `INSERT` automatisch erh√∂ht.

---

### **2. BIGSERIAL**

* Wie `SERIAL`, aber auf `BIGINT`-Basis (f√ºr sehr gro√üe Tabellen).

```sql
CREATE TABLE logs (
  id BIGSERIAL PRIMARY KEY,
  message TEXT
);
```

---

### **3. IDENTITY (moderner Standard, SQL:2003)**

* Ab PostgreSQL 10 verf√ºgbar.
* Empfohlen, da **Standard-konform** und flexibler.

```sql
CREATE TABLE products (
  id INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  name TEXT
);
```

Varianten:

* `GENERATED ALWAYS AS IDENTITY` ‚Üí DB verwaltet die Werte strikt (manuelles Insert nicht m√∂glich ohne Override).
* `GENERATED BY DEFAULT AS IDENTITY` ‚Üí erlaubt manuelles Setzen, wenn n√∂tig.

---

### **4. Manuelle Sequence** (volle Kontrolle)

```sql
CREATE SEQUENCE order_seq START 1;

CREATE TABLE orders (
  id INT DEFAULT nextval('order_seq') PRIMARY KEY,
  amount NUMERIC
);
```

---

### **Vergleich**

| Methode          | Datentyp       | Standard-konform | Empfehlung                                                      |
| ---------------- | -------------- | ---------------- | --------------------------------------------------------------- |
| SERIAL           | INTEGER        | Nein             | Legacy, noch h√§ufig genutzt                                     |
| BIGSERIAL        | BIGINT         | Nein             | F√ºr sehr gro√üe Tabellen                                         |
| IDENTITY         | INTEGER/BIGINT | Ja               | Moderne Best Practice                                           |
| Sequence manuell | Flexibel       | Ja               | Spezialf√§lle (z. B. mehrere Tabellen teilen sich eine Sequence) |

---

**Zusammenfassung:**

* **`SERIAL`/`BIGSERIAL`** ‚Üí √§lter, praktisch, aber nicht Standard.
* **`IDENTITY`** ‚Üí moderner, SQL-konform, empfohlen ab PostgreSQL 10.
* **Manuelle Sequence** ‚Üí maximale Flexibilit√§t.

üìñ Quellen:

* [PostgreSQL Docs ‚Äì SERIAL Types](https://www.postgresql.org/docs/current/datatype-numeric.html#DATATYPE-SERIAL)
* [PostgreSQL Docs ‚Äì Identity Columns](https://www.postgresql.org/docs/current/ddl-generated-columns.html#DDL-IDENTITY-COLUMNS)
* [PostgreSQL Docs ‚Äì Sequences](https://www.postgresql.org/docs/current/sql-createsequence.html)


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

29. ### <a name="29"></a> Was sind Materialized Views?

### **Materialized Views in PostgreSQL**

Eine **Materialized View** ist eine gespeicherte Abfrage, deren Ergebnis **physisch in der Datenbank gespeichert** wird.
Sie √§hnelt einer normalen View, wird aber nicht bei jeder Abfrage neu berechnet, sondern als **statische Tabelle** abgelegt.

---

### **1. Erstellung**

```sql
CREATE MATERIALIZED VIEW sales_summary AS
SELECT customer_id, SUM(amount) AS total_sales
FROM orders
GROUP BY customer_id;
```

‚û°Ô∏è Ergebnis wird gespeichert wie in einer Tabelle.

---

### **2. Nutzung**

```sql
-- Abfrage wie bei einer normalen Tabelle
SELECT * FROM sales_summary;
```

---

### **3. Aktualisierung**

* Daten sind **nicht automatisch aktuell**.
* M√ºssen manuell oder √ºber Cron/Trigger mit `REFRESH` aktualisiert werden.

```sql
REFRESH MATERIALIZED VIEW sales_summary;
```

Optional:

```sql
REFRESH MATERIALIZED VIEW CONCURRENTLY sales_summary;
```

‚û°Ô∏è Erm√∂glicht gleichzeitige Lesezugriffe w√§hrend des Refreshs (erfordert Unique Index).

---

### **4. Vorteile**

* Schnelle Abfragen f√ºr komplexe Berechnungen (z. B. Aggregationen, Joins).
* Reduziert Datenbanklast bei h√§ufig wiederholten komplexen Queries.

---

### **5. Nachteile**

* Daten sind nicht ‚Äûlive‚Äú, sondern nur so aktuell wie der letzte `REFRESH`.
* Ben√∂tigen zus√§tzlichen Speicherplatz.

---

### **Vergleich: View vs. Materialized View**

| Merkmal        | View                          | Materialized View                      |
| -------------- | ----------------------------- | -------------------------------------- |
| Speicherung    | Nur Abfrage gespeichert       | Ergebnis der Abfrage gespeichert       |
| Aktualit√§t     | Immer aktuell                 | Muss mit `REFRESH` aktualisiert werden |
| Performance    | Langsam bei komplexen Queries | Schnell, da vorgerechnet               |
| Speicherbedarf | Kein zus√§tzlicher Speicher    | Braucht Speicherplatz                  |

---

**Zusammenfassung:**
Eine **Materialized View** ist eine gespeicherte Abfrage mit persistenten Ergebnissen.
Sie beschleunigt komplexe Abfragen, muss aber regelm√§√üig mit `REFRESH` aktualisiert werden.

üìñ Quellen:

* [PostgreSQL Docs ‚Äì Materialized Views](https://www.postgresql.org/docs/current/rules-materializedviews.html)


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

30. ### <a name="30"></a> Unterschied zwischen View und Materialized View?

### **Unterschied zwischen View und Materialized View in PostgreSQL**

---

### **1. View**

* Eine **gespeicherte Abfrage** (virtuelle Tabelle).
* Ergebnis wird **nicht gespeichert**, sondern **bei jeder Abfrage neu berechnet**.
* Immer **aktuell**, aber langsamer bei komplexen Abfragen.

**Beispiel:**

```sql
CREATE VIEW active_users AS
SELECT id, name
FROM users
WHERE active = true;

SELECT * FROM active_users;
```

‚û°Ô∏è Berechnet sich jedes Mal neu.

---

### **2. Materialized View**

* Speichert das Ergebnis der Abfrage **physisch in der Datenbank**.
* Ergebnis bleibt erhalten und wird wie eine Tabelle abgefragt.
* Muss manuell mit `REFRESH MATERIALIZED VIEW` aktualisiert werden.

**Beispiel:**

```sql
CREATE MATERIALIZED VIEW sales_summary AS
SELECT customer_id, SUM(amount) AS total_sales
FROM orders
GROUP BY customer_id;

-- sp√§ter aktualisieren
REFRESH MATERIALIZED VIEW sales_summary;
```

‚û°Ô∏è Schneller bei Abfragen, aber nicht automatisch aktuell.

---

### **Vergleichstabelle**

| Merkmal             | View                            | Materialized View                |
| ------------------- | ------------------------------- | -------------------------------- |
| Speicherung         | Keine Daten gespeichert         | Ergebnis wird gespeichert        |
| Aktualit√§t          | Immer aktuell                   | Muss manuell aktualisiert werden |
| Performance         | Langsamer bei komplexen Queries | Schnell, da vorgerechnet         |
| Speicherplatzbedarf | Kein zus√§tzlicher Speicher      | Ben√∂tigt Speicherplatz           |

---

**Zusammenfassung:**

* **View** = immer aktuell, aber langsamer.
* **Materialized View** = schneller, aber erfordert manuelles Aktualisieren.

üìñ Quellen:

* [PostgreSQL Docs ‚Äì Views](https://www.postgresql.org/docs/current/sql-createview.html)
* [PostgreSQL Docs ‚Äì Materialized Views](https://www.postgresql.org/docs/current/rules-materializedviews.html)


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

31. ### <a name="31"></a> Was ist ein Index in PostgreSQL?

### **Index in PostgreSQL**

Ein **Index** ist eine zus√§tzliche Datenstruktur, die PostgreSQL anlegt, um **Datenbankabfragen zu beschleunigen**.
Er funktioniert √§hnlich wie ein Inhaltsverzeichnis in einem Buch: Statt jede Seite zu durchsuchen, springt die Datenbank direkt an die richtige Stelle.

---

### **1. Erstellung eines Index**

```sql
-- Einfacher Index auf Spalte email
CREATE INDEX idx_users_email
ON users (email);
```

‚û°Ô∏è Abfragen wie

```sql
SELECT * FROM users WHERE email = 'max@example.com';
```

werden dadurch wesentlich schneller.

---

### **2. Arten von Indizes**

* **B-Tree (Standard):** F√ºr Gleichheits- und Bereichsabfragen (`=`, `<`, `>`, `BETWEEN`).
* **Hash:** Nur f√ºr Gleichheitsvergleiche.
* **GIN (Generalized Inverted Index):** F√ºr Arrays, JSONB, Volltextsuche.
* **GiST (Generalized Search Tree):** F√ºr Geodaten, komplexe Datentypen.
* **BRIN (Block Range Index):** F√ºr sehr gro√üe Tabellen mit sequenziellen Daten (z. B. Zeitserien).
* **Unique Index:** Erzwingt Eindeutigkeit (z. B. Emails).

---

### **3. Wartung**

* Indizes brauchen **Speicherplatz** und m√ºssen beim `INSERT`, `UPDATE`, `DELETE` aktualisiert werden.
* Zu viele Indizes k√∂nnen Schreiboperationen verlangsamen.

---

### **4. Beispiel: Unique Index**

```sql
CREATE UNIQUE INDEX idx_users_email_unique
ON users (email);
```

‚û°Ô∏è Kein Nutzer kann doppelte Email eintragen.

---

### **5. Index bei JSONB**

```sql
CREATE INDEX idx_events_data
ON events USING gin (data);
```

‚û°Ô∏è Erm√∂glicht schnelle Suche in JSONB-Feldern:

```sql
SELECT * FROM events WHERE data @> '{"type": "login"}';
```

---

### **Vergleich: Index vs. kein Index**

| Merkmal            | Ohne Index                | Mit Index                            |
| ------------------ | ------------------------- | ------------------------------------ |
| SELECT-Abfragen    | Langsam (Full Table Scan) | Schnell (direkter Zugriff)           |
| Speicherbedarf     | Wenig                     | Mehr (Index-Struktur zus√§tzlich)     |
| Schreiboperationen | Schneller                 | Etwas langsamer (Index-Update n√∂tig) |

---

**Zusammenfassung:**
Ein **Index** in PostgreSQL beschleunigt Lesezugriffe auf Tabellen, indem er eine optimierte Datenstruktur anlegt. Er erh√∂ht aber den Speicherbedarf und verlangsamt Schreiboperationen leicht.

üìñ Quellen:

* [PostgreSQL Docs ‚Äì Indexes](https://www.postgresql.org/docs/current/indexes.html)


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

32. ### <a name="32"></a> Unterschied zwischen B-Tree, Hash und GIN Index?

### **Unterschied zwischen B-Tree, Hash und GIN Index in PostgreSQL**

---

### **1. B-Tree Index (Standard)**

* **Default-Index-Typ** in PostgreSQL.
* Optimiert f√ºr **Vergleiche und Sortierungen**:

  * `=`, `<`, `>`, `<=`, `>=`, `BETWEEN`, `ORDER BY`.
* Unterst√ºtzt auch **Prefix-Suche** bei Strings (`LIKE 'abc%'`).
* Sehr universell, f√ºr die meisten F√§lle geeignet.

**Beispiel:**

```sql
CREATE INDEX idx_users_email
ON users (email);
```

‚û°Ô∏è Schnell f√ºr:

```sql
SELECT * FROM users WHERE email = 'max@example.com';
```

---

### **2. Hash Index**

* Optimiert f√ºr **Gleichheitsabfragen (`=`)**.
* Fr√ºher weniger stabil, seit PostgreSQL 10 **WAL-gesichert** und produktionsreif.
* Kein Vorteil gegen√ºber B-Tree, au√üer in speziellen F√§llen.

**Beispiel:**

```sql
CREATE INDEX idx_users_hash
ON users USING hash (email);
```

‚û°Ô∏è Schnell f√ºr:

```sql
SELECT * FROM users WHERE email = 'anna@example.com';
```

Aber nicht f√ºr `<`, `>`, `ORDER BY` geeignet.

---

### **3. GIN (Generalized Inverted Index)**

* Speziell f√ºr **Sammlungen von Werten** innerhalb einer Spalte.
* Ideal f√ºr **Arrays, JSONB, Full-Text-Suche**.
* Unterst√ºtzt Operatoren wie `@>`, `<@`, `&&`.

**Beispiel f√ºr JSONB:**

```sql
CREATE INDEX idx_events_data
ON events USING gin (data);
```

```sql
SELECT * FROM events
WHERE data @> '{"role": "admin"}';
```

‚û°Ô∏è Ohne GIN-Index ‚Üí sehr langsam (Full Table Scan).
‚û°Ô∏è Mit GIN-Index ‚Üí extrem schnell.

---

### **Vergleichstabelle**

| Merkmal               | B-Tree                         | Hash                   | GIN                                           |
| --------------------- | ------------------------------ | ---------------------- | --------------------------------------------- |
| Standard              | Ja                             | Nein                   | Nein                                          |
| Unterst√ºtzte Abfragen | `=`, `<`, `>`, `BETWEEN`, Sort | Nur `=`                | JSONB, Arrays, Volltext                       |
| St√§rken               | Universell, sehr flexibel      | Gleichheitsvergleiche  | Suche in komplexen Datentypen                 |
| Schw√§chen             | Nicht optimal f√ºr Arrays/JSONB | Keine Bereichsabfragen | Hoher Speicherbedarf, langsamer Insert/Update |

---

**Zusammenfassung:**

* **B-Tree** ‚Üí Standard, universell f√ºr Vergleiche und Sortierungen.
* **Hash** ‚Üí Nur f√ºr Gleichheit (`=`), selten sinnvoller als B-Tree.
* **GIN** ‚Üí Speziell f√ºr JSONB, Arrays und Volltextsuche.

üìñ Quellen:

* [PostgreSQL Docs ‚Äì Index Types](https://www.postgresql.org/docs/current/indexes-types.html)


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

33. ### <a name="33"></a> Was ist ein Unique Index?

### **Unique Index in PostgreSQL**

Ein **Unique Index** stellt sicher, dass die Werte in einer oder mehreren Spalten **eindeutig** sind.
Dadurch wird verhindert, dass doppelte Werte eingef√ºgt werden.

---

### **1. Erstellung eines Unique Index**

```sql
CREATE UNIQUE INDEX idx_users_email_unique
ON users (email);
```

‚û°Ô∏è Kein Benutzer kann zweimal dieselbe Email eintragen.

---

### **2. Unique Constraint vs. Unique Index**

* `UNIQUE CONSTRAINT` (z. B. in `CREATE TABLE`) erzeugt intern automatisch einen **Unique Index**.
* Unterschied:

  * **Unique Constraint** = Teil der Datenintegrit√§t (Schema-Level).
  * **Unique Index** = Index-Objekt, kann auch unabh√§ngig erstellt werden.

**Beispiel mit Constraint:**

```sql
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  email TEXT UNIQUE
);
```

‚û°Ô∏è PostgreSQL erzeugt dabei automatisch einen Unique Index.

---

### **3. Mehrspaltige Unique Indizes**

Man kann auch Kombinationen von Spalten eindeutig machen.

```sql
CREATE UNIQUE INDEX idx_orders_user_product
ON orders (user_id, product_id);
```

‚û°Ô∏è Ein Benutzer kann jedes Produkt nur **einmal** bestellen.

---

### **4. Vorteile**

* Verhindert doppelte Werte ‚Üí **Datenintegrit√§t**.
* Schnelle Suche durch Indexierung.

### **5. Nachteile**

* **Einf√ºgen/Update langsamer**, weil PostgreSQL pr√ºfen muss, ob der Wert schon existiert.

---

**Zusammenfassung:**
Ein **Unique Index** garantiert Eindeutigkeit in einer oder mehreren Spalten. Er wird automatisch bei `UNIQUE`-Constraints angelegt oder kann manuell erstellt werden.

üìñ Quellen:

* [PostgreSQL Docs ‚Äì Indexes: Unique Indexes](https://www.postgresql.org/docs/current/indexes-unique.html)
* [PostgreSQL Docs ‚Äì Constraints](https://www.postgresql.org/docs/current/ddl-constraints.html)


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

34. ### <a name="34"></a> Nachteile von zu vielen Indexen?

### **Nachteile von zu vielen Indizes in PostgreSQL**

Indizes verbessern die **Lesegeschwindigkeit**, haben aber auch Nachteile, wenn man zu viele davon anlegt:

---

### **1. Speicherverbrauch**

* Jeder Index ben√∂tigt zus√§tzlichen **Platz auf der Festplatte**.
* Gro√üe Tabellen mit vielen Indizes k√∂nnen deutlich mehr Speicher belegen.

---

### **2. Langsamere Schreiboperationen**

* Bei **INSERT, UPDATE, DELETE** muss PostgreSQL alle relevanten Indizes **mitaktualisieren**.
* Je mehr Indizes ‚Üí desto langsamer werden Schreibvorg√§nge.

---

### **3. Komplexere Wartung**

* Indizes m√ºssen regelm√§√üig **neu aufgebaut oder analysiert** werden (`REINDEX`, `VACUUM ANALYZE`).
* Viele Indizes machen das aufw√§ndiger.

---

### **4. Suboptimale Query-Pl√§ne**

* Der Query Planner kann bei zu vielen Indizes schlechter entscheiden, welcher Index am besten ist.
* Risiko: PostgreSQL w√§hlt einen ineffizienten Index ‚Üí schlechtere Performance.

---

### **5. Redundanz und Overhead**

* Gleiche oder √§hnliche Indizes (z. B. auf `email` und zus√§tzlich auf `LOWER(email)`) k√∂nnen sich √ºberlappen.
* Das f√ºhrt zu unn√∂tigem Overhead ohne zus√§tzlichen Nutzen.

---

### **Beispiel**

```sql
-- √úbertrieben viele Indizes
CREATE INDEX idx_users_name ON users(name);
CREATE INDEX idx_users_name_lower ON users(LOWER(name));
CREATE INDEX idx_users_name_text_pattern ON users(name text_pattern_ops);
```

‚û°Ô∏è Diese Indizes k√∂nnten teilweise √ºberfl√ºssig sein und die Schreibperformance stark verschlechtern.

---

**Zusammenfassung:**
Zu viele Indizes f√ºhren zu **mehr Speicherverbrauch**, **langsamen Schreiboperationen**, **aufwendiger Wartung** und manchmal sogar zu **schlechterer Query-Performance**.
Empfehlung: Nur Indizes anlegen, die **konkret von Abfragen genutzt** werden.

üìñ Quellen:

* [PostgreSQL Docs ‚Äì Indexes](https://www.postgresql.org/docs/current/indexes.html)
* [PostgreSQL Performance Tuning Guide](https://www.postgresql.org/docs/current/performance-tips.html)


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

35. ### <a name="35"></a> Wie analysiert man eine Query mit EXPLAIN?

### **Query-Analyse mit `EXPLAIN` in PostgreSQL**

Mit **`EXPLAIN`** zeigt PostgreSQL, **wie** eine Abfrage vom Query Planner ausgef√ºhrt wird.
So kann man Performanceprobleme erkennen (z. B. fehlende Indizes, Full Table Scans).

---

### **1. Einfaches `EXPLAIN`**

```sql
EXPLAIN
SELECT * FROM users WHERE email = 'max@example.com';
```

‚û°Ô∏è Gibt den **geplanten Ausf√ºhrungsplan** zur√ºck (z. B. ‚ÄûSeq Scan‚Äú oder ‚ÄûIndex Scan‚Äú).

---

### **2. `EXPLAIN ANALYZE`**

```sql
EXPLAIN ANALYZE
SELECT * FROM users WHERE email = 'max@example.com';
```

‚û°Ô∏è F√ºhrt die Abfrage **wirklich aus** und zeigt:

* Tats√§chliche Laufzeit
* Anzahl der gescannten Zeilen
* Unterschied zwischen gesch√§tzten und realen Werten

---

### **3. Typische Scan-Arten**

* **Seq Scan (Sequential Scan)** ‚Üí Tabelle wird komplett gelesen (teuer bei gro√üen Tabellen).
* **Index Scan** ‚Üí Daten werden √ºber einen Index gesucht (viel schneller).
* **Bitmap Index Scan** ‚Üí Hybrid-Ansatz, n√ºtzlich bei vielen Treffern.
* **Nested Loop / Hash Join / Merge Join** ‚Üí verschiedene Join-Strategien.

---

### **4. Beispielvergleich**

Ohne Index:

```sql
EXPLAIN ANALYZE
SELECT * FROM users WHERE email = 'max@example.com';
```

Ausgabe (gek√ºrzt):

```
Seq Scan on users  (cost=0.00..35.50 rows=1 width=50)
  Filter: (email = 'max@example.com')
```

Mit Index:

```sql
CREATE INDEX idx_users_email ON users(email);

EXPLAIN ANALYZE
SELECT * FROM users WHERE email = 'max@example.com';
```

Ausgabe (gek√ºrzt):

```
Index Scan using idx_users_email on users  (cost=0.15..8.17 rows=1 width=50)
  Index Cond: (email = 'max@example.com')
```

‚û°Ô∏è Deutlich effizienter.

---

### **5. Erweiterungen**

* `EXPLAIN (BUFFERS, ANALYZE)` ‚Üí zeigt auch Lese-/Schreibzugriffe auf Datenbl√∂cken.
* `EXPLAIN (FORMAT JSON)` ‚Üí strukturierte Ausgabe f√ºr Tools.

---

**Zusammenfassung:**

* **`EXPLAIN`** ‚Üí zeigt geplanten Ausf√ºhrungsplan.
* **`EXPLAIN ANALYZE`** ‚Üí zeigt zus√§tzlich echte Laufzeiten.
* Wichtig zur Optimierung von Abfragen (z. B. Einsatz von Indizes, Join-Strategien).

üìñ Quellen:

* [PostgreSQL Docs ‚Äì EXPLAIN](https://www.postgresql.org/docs/current/using-explain.html)


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

36. ### <a name="36"></a> Unterschied zwischen EXPLAIN und EXPLAIN ANALYZE?

### **Unterschied zwischen `EXPLAIN` und `EXPLAIN ANALYZE` in PostgreSQL**

---

### **1. `EXPLAIN`**

* Zeigt den **geplanten Ausf√ºhrungsplan** des Query Planners.
* F√ºhrt die Abfrage **nicht aus**.
* Liefert **gesch√§tzte Kosten** (cost), Zeilenanzahl (rows) und Breite (width).
* Gut f√ºr eine schnelle **theoretische Analyse**.

**Beispiel:**

```sql
EXPLAIN
SELECT * FROM users WHERE email = 'max@example.com';
```

Ausgabe (gek√ºrzt):

```
Seq Scan on users  (cost=0.00..35.50 rows=1 width=50)
  Filter: (email = 'max@example.com')
```

---

### **2. `EXPLAIN ANALYZE`**

* F√ºhrt die Abfrage **wirklich aus**.
* Zeigt zus√§tzlich **tats√§chliche Laufzeiten** und die **wirklich gelesene Zeilenanzahl**.
* Hilfreich, um zu pr√ºfen, ob die **Sch√§tzungen des Planners korrekt** sind.
* Kann √Ñnderungen an Daten (z. B. `INSERT`, `UPDATE`, `DELETE`) wirklich ausf√ºhren ‚Üí Vorsicht in Produktion.

**Beispiel:**

```sql
EXPLAIN ANALYZE
SELECT * FROM users WHERE email = 'max@example.com';
```

Ausgabe (gek√ºrzt):

```
Index Scan using idx_users_email on users  (cost=0.15..8.17 rows=1 width=50)
  Index Cond: (email = 'max@example.com')
  Actual time=0.020..0.022 rows=1 loops=1
```

---

### **Vergleich**

| Merkmal              | `EXPLAIN`        | `EXPLAIN ANALYZE`                           |
| -------------------- | ---------------- | ------------------------------------------- |
| F√ºhrt Query aus?     | Nein             | Ja                                          |
| Kosten / Sch√§tzungen | Ja               | Ja                                          |
| Tats√§chliche Zeiten  | Nein             | Ja                                          |
| Zeilenanzahl (real)  | Nein             | Ja                                          |
| Risiko               | Keine √Ñnderungen | F√ºhrt Query wirklich aus (Vorsicht bei DML) |

---

**Zusammenfassung:**

* **`EXPLAIN`** ‚Üí nur Plan, keine Ausf√ºhrung.
* **`EXPLAIN ANALYZE`** ‚Üí Plan + echte Laufzeiten (f√ºhrt Query wirklich aus).

üìñ Quellen:

* [PostgreSQL Docs ‚Äì Using EXPLAIN](https://www.postgresql.org/docs/current/using-explain.html)


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

37. ### <a name="37"></a> Wie vermeidet man Table Scans?

### **Table Scans in PostgreSQL vermeiden**

Ein **Sequential Scan (Table Scan)** bedeutet, dass PostgreSQL die komplette Tabelle Zeile f√ºr Zeile durchsucht.
Das ist bei gro√üen Tabellen teuer. Ziel: M√∂glichst einen **Index Scan** nutzen.

---

### **1. Indexe anlegen**

* **B-Tree-Index** f√ºr Gleichheits- und Bereichsabfragen:

```sql
CREATE INDEX idx_users_email ON users(email);
```

‚û°Ô∏è Beschleunigt:

```sql
SELECT * FROM users WHERE email = 'max@example.com';
```

* **GIN-Index** f√ºr JSONB, Arrays, Volltextsuche:

```sql
CREATE INDEX idx_events_data ON events USING gin (data);
```

---

### **2. Geeignete Bedingungen schreiben**

* Abfragen so formulieren, dass der Index genutzt werden kann.
  ‚ùå Schlecht (kein Index-Use):

```sql
WHERE LOWER(email) = 'max@example.com'
```

‚úÖ Besser (funktionaler Index):

```sql
CREATE INDEX idx_users_lower_email ON users(LOWER(email));
WHERE LOWER(email) = 'max@example.com';
```

---

### **3. Nur ben√∂tigte Spalten abfragen**

* `SELECT *` zwingt die DB oft zu mehr Arbeit.
* Lieber gezielt:

```sql
SELECT id, email FROM users WHERE email = 'max@example.com';
```

---

### **4. Statistiken aktuell halten**

* Query Planner verl√§sst sich auf Statistiken.
* Regelm√§√üig:

```sql
ANALYZE users;
```

Oder Auto-VACUUM aktivieren.

---

### **5. Partitionierung nutzen**

* Gro√üe Tabellen in **Partitionen** aufteilen, z. B. nach Datum.
* PostgreSQL durchsucht dann nur die relevante Partition.

```sql
CREATE TABLE logs (
  id SERIAL,
  created_at DATE,
  message TEXT
) PARTITION BY RANGE (created_at);
```

---

### **6. EXPLAIN verwenden**

* Pr√ºfen, ob wirklich ein Index genutzt wird:

```sql
EXPLAIN ANALYZE
SELECT * FROM users WHERE email = 'max@example.com';
```

‚û°Ô∏è Statt `Seq Scan` sollte `Index Scan` erscheinen.

---

**Zusammenfassung:**
Table Scans vermeidet man durch **geeignete Indizes, optimierte Abfragen, aktuelle Statistiken und Partitionierung**. Mit `EXPLAIN` √ºberpr√ºft man den Query Plan.

üìñ Quellen:

* [PostgreSQL Docs ‚Äì Indexes](https://www.postgresql.org/docs/current/indexes.html)
* [PostgreSQL Docs ‚Äì Performance Tips](https://www.postgresql.org/docs/current/performance-tips.html)


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

38. ### <a name="38"></a> Was ist ein Partial Index?

### **Partial Index in PostgreSQL**

Ein **Partial Index** ist ein Index, der **nur f√ºr einen Teil der Zeilen einer Tabelle** erstellt wird ‚Äì basierend auf einer **WHERE-Bedingung**.
Dadurch spart man **Speicherplatz** und beschleunigt Abfragen, die genau diese Bedingung nutzen.

---

### **1. Erstellung**

```sql
-- Index nur f√ºr aktive Benutzer
CREATE INDEX idx_users_active
ON users (email)
WHERE active = true;
```

---

### **2. Nutzung**

Dieser Index wird nur bei Abfragen verwendet, die dieselbe Bedingung enthalten:

```sql
SELECT * FROM users WHERE active = true AND email = 'max@example.com';
```

‚û°Ô∏è Schneller, weil nur ein Teil der Tabelle indexiert ist.

---

### **3. Vorteile**

* **Weniger Speicherplatz** als ein vollst√§ndiger Index.
* **Schnelleres Schreiben** (INSERT/UPDATE), da weniger Zeilen indexiert werden.
* Ideal bei **Tabellen mit vielen NULLs oder selten genutzten Werten**.

---

### **4. Einschr√§nkungen**

* Nur effektiv, wenn Abfragen **die Bedingung des Index exakt enthalten**.
* Falsche Bedingung ‚Üí Index wird nicht genutzt.

---

### **5. Beispiel f√ºr h√§ufige Anwendung**

* Nur **nicht gel√∂schte Zeilen** indexieren (Soft Deletes):

```sql
CREATE INDEX idx_orders_not_deleted
ON orders (customer_id)
WHERE deleted_at IS NULL;
```

‚û°Ô∏è Abfragen nach aktiven Bestellungen sind schnell, gel√∂schte Daten werden ignoriert.

---

**Zusammenfassung:**
Ein **Partial Index** ist ein Index √ºber eine Teilmenge der Daten, definiert durch eine WHERE-Bedingung. Er spart Speicher und verbessert Performance bei spezifischen Abfragen.

üìñ Quellen:

* [PostgreSQL Docs ‚Äì Partial Indexes](https://www.postgresql.org/docs/current/indexes-partial.html)


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

39. ### <a name="39"></a> Was ist ein Covering Index (INCLUDE)?

### **Covering Index (INCLUDE) in PostgreSQL**

Ein **Covering Index** ist ein Index, der neben den indexierten Spalten auch **zus√§tzliche Spalten** speichert.
Diese zus√§tzlichen Spalten werden mit dem Schl√ºssel gespeichert, sind aber **nicht Teil der Index-Sortierung**.
In PostgreSQL wird das mit **`INCLUDE`** umgesetzt.

---

### **1. Zweck**

* Verhindert, dass PostgreSQL die Tabelle selbst (Heap) lesen muss.
* Die Abfrage kann vollst√§ndig aus dem Index beantwortet werden ‚Üí **Index-only Scan**.
* Spart **I/O und Zeit**.

---

### **2. Beispiel**

```sql
-- Index auf email, zus√§tzlich name speichern
CREATE INDEX idx_users_email_include
ON users (email)
INCLUDE (name);
```

**Abfrage:**

```sql
SELECT email, name
FROM users
WHERE email = 'max@example.com';
```

‚û°Ô∏è PostgreSQL kann die Abfrage **nur mit dem Index** beantworten, ohne die Tabelle zu lesen.

---

### **3. Vorteile**

* **Schneller** bei h√§ufigen SELECTs mit mehreren Spalten.
* Spart Speicher, da nicht alle Spalten im Index sortiert werden m√ºssen.
* Besonders n√ºtzlich bei **breiten Tabellen**.

---

### **4. Einschr√§nkungen**

* `INCLUDE`-Spalten k√∂nnen nicht f√ºr Sortierung oder Bedingungen (`WHERE`) genutzt werden.
* Sie dienen nur der **Abdeckung von SELECT-Ausgaben**.

---

### **5. Beispiel f√ºr typische Nutzung**

```sql
-- Eindeutigkeit nach user_id, aber zus√§tzlich Spalte created_at abdecken
CREATE UNIQUE INDEX idx_orders_user_product
ON orders (user_id, product_id)
INCLUDE (created_at);
```

‚û°Ô∏è Queries wie

```sql
SELECT user_id, product_id, created_at
FROM orders
WHERE user_id = 1 AND product_id = 5;
```

k√∂nnen komplett √ºber den Index laufen.

---

**Zusammenfassung:**
Ein **Covering Index (INCLUDE)** speichert zus√§tzliche Spalten im Index, die nicht Teil der Schl√ºsseldefinition sind. Dadurch k√∂nnen Abfragen vollst√§ndig aus dem Index beantwortet werden (**Index-only Scan**) und werden schneller.

üìñ Quellen:

* [PostgreSQL Docs ‚Äì Indexes with INCLUDE](https://www.postgresql.org/docs/current/sql-createindex.html#SQL-CREATEINDEX-INCLUDE)


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

40. ### <a name="40"></a> Wie funktioniert Vacuum in PostgreSQL?

### **VACUUM in PostgreSQL**

PostgreSQL nutzt ein **MVCC-Modell (Multi-Version Concurrency Control)**.
Dabei werden alte Versionen von Zeilen nicht sofort gel√∂scht, sondern als **tote Tupel** (dead tuples) markiert.
Das Kommando **`VACUUM`** bereinigt diese toten Tupel und h√§lt Tabellen und Indizes effizient.

---

### **1. Aufgaben von VACUUM**

* Entfernt **nicht mehr ben√∂tigte Zeilen** (dead tuples).
* Gibt Speicherplatz **innerhalb der Tabelle** wieder frei.
* H√§lt **Index-Eintr√§ge** aktuell.
* Verhindert das √úberschreiten des **Transaction ID Wraparound** (sonst Datenbankstop).

---

### **2. Arten von VACUUM**

#### üîπ **VACUUM (Standard)**

* Bereinigt tote Tupel.
* Gibt Speicher nur intern wieder frei (nicht sofort an das Betriebssystem).
* Schnell, nicht blockierend.

```sql
VACUUM users;
```

#### üîπ **VACUUM FULL**

* Kompaktet Tabellen komplett neu.
* Gibt Speicher **an das Betriebssystem** zur√ºck.
* **Blockiert** die Tabelle w√§hrend der Ausf√ºhrung.
* Sehr ressourcenintensiv.

```sql
VACUUM FULL users;
```

#### üîπ **AUTOVACUUM**

* L√§uft automatisch im Hintergrund.
* Startet, wenn eine bestimmte Menge an √Ñnderungen in einer Tabelle √ºberschritten wird.
* Konfigurierbar √ºber `postgresql.conf`.

---

### **3. Erg√§nzende Befehle**

* `ANALYZE` ‚Üí aktualisiert Statistiken f√ºr den Query Planner.

```sql
VACUUM ANALYZE users;
```

* `REINDEX` ‚Üí neuaufbau von Indizes, wenn diese zu gro√ü oder fragmentiert sind.

---

### **4. Beispiel**

```sql
-- Standard-Vacuum f√ºr alle Tabellen
VACUUM;

-- Tabelle bereinigen + Statistiken aktualisieren
VACUUM ANALYZE orders;

-- Komplette Neuorganisation (teuer!)
VACUUM FULL orders;
```

---

### **5. Nachteile, wenn man VACUUM nicht nutzt**

* Tabellen und Indizes wachsen unn√∂tig (‚Äûbloating‚Äú).
* Abfragen werden langsamer.
* Gefahr des **Transaction ID Wraparound**, was die Datenbank unbenutzbar machen kann.

---

**Zusammenfassung:**
`VACUUM` entfernt alte Zeilen (dead tuples), h√§lt Tabellen kompakt und sch√ºtzt PostgreSQL vor Transaction-ID-√úberlauf.

* **VACUUM** = leicht, regelm√§√üig.
* **VACUUM FULL** = schwer, blockierend, nur bei starkem Bloating n√∂tig.
* **AUTOVACUUM** = l√§uft automatisch und sollte fast immer aktiviert bleiben.

üìñ Quellen:

* [PostgreSQL Docs ‚Äì VACUUM](https://www.postgresql.org/docs/current/sql-vacuum.html)
* [PostgreSQL Docs ‚Äì Routine Vacuuming](https://www.postgresql.org/docs/current/routine-vacuuming.html)


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

41. ### <a name="41"></a> Wie startet und beendet man eine Transaktion?

### **Transaktionen in PostgreSQL starten und beenden**

Eine Transaktion ist ein Block von SQL-Anweisungen, die als **eine Einheit** ausgef√ºhrt werden.
In PostgreSQL gibt es daf√ºr spezielle Befehle.

---

### **1. Start einer Transaktion**

```sql
BEGIN;   -- oder START TRANSACTION;
```

---

### **2. SQL-Befehle innerhalb der Transaktion**

```sql
UPDATE accounts
SET balance = balance - 100
WHERE id = 1;

UPDATE accounts
SET balance = balance + 100
WHERE id = 2;
```

---

### **3. Transaktion beenden**

* **Erfolgreich abschlie√üen:**

```sql
COMMIT;
```

‚û°Ô∏è Alle √Ñnderungen werden dauerhaft gespeichert.

* **Abbrechen:**

```sql
ROLLBACK;
```

‚û°Ô∏è Alle √Ñnderungen seit `BEGIN` werden verworfen.

---

### **4. Komplettes Beispiel**

```sql
BEGIN;

UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;

COMMIT; -- oder ROLLBACK bei Fehler
```

---

### **5. Automatisches Verhalten**

* Standardm√§√üig l√§uft PostgreSQL im **Autocommit-Modus** ‚Üí jede einzelne Query ist automatisch eine Transaktion.
* Mit `BEGIN` deaktiviert man Autocommit, bis `COMMIT` oder `ROLLBACK` ausgef√ºhrt wird.

---

**Zusammenfassung:**

* **BEGIN / START TRANSACTION** ‚Üí Start
* **COMMIT** ‚Üí √Ñnderungen speichern
* **ROLLBACK** ‚Üí √Ñnderungen verwerfen
* Standard = Autocommit, explizite Transaktionen f√ºr mehrere zusammengeh√∂rige Befehle.

üìñ Quellen:

* [PostgreSQL Docs ‚Äì Transactions](https://www.postgresql.org/docs/current/tutorial-transactions.html)


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

42. ### <a name="42"></a> Unterschied zwischen COMMIT und ROLLBACK?

### **Unterschied zwischen `COMMIT` und `ROLLBACK` in PostgreSQL**

---

### **1. COMMIT**

* Beendet eine Transaktion **erfolgreich**.
* Alle √Ñnderungen (INSERT, UPDATE, DELETE) werden **dauerhaft gespeichert**.
* Andere Sessions sehen die √Ñnderungen erst nach `COMMIT`.

**Beispiel:**

```sql
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT; -- √Ñnderungen gespeichert
```

---

### **2. ROLLBACK**

* Bricht eine Transaktion **ab**.
* Alle √Ñnderungen seit `BEGIN` werden **zur√ºckgesetzt**.
* Datenbankzustand = wie vor Beginn der Transaktion.

**Beispiel:**

```sql
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
-- Fehler passiert hier
ROLLBACK; -- √Ñnderungen r√ºckg√§ngig gemacht
```

---

### **Vergleich**

| Merkmal            | COMMIT                        | ROLLBACK             |
| ------------------ | ----------------------------- | -------------------- |
| Wirkung            | √Ñnderungen speichern          | √Ñnderungen verwerfen |
| Zeitpunkt sichtbar | Nach COMMIT f√ºr alle Sessions | Nie                  |
| Typischer Einsatz  | Erfolgreiche Transaktion      | Fehler oder Abbruch  |

---

**Zusammenfassung:**

* **COMMIT** ‚Üí speichert √Ñnderungen dauerhaft.
* **ROLLBACK** ‚Üí macht √Ñnderungen r√ºckg√§ngig.

üìñ Quellen:

* [PostgreSQL Docs ‚Äì Transactions](https://www.postgresql.org/docs/current/tutorial-transactions.html)


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

43. ### <a name="43"></a> Was ist ein Savepoint in SQL?

### **Savepoint in SQL (PostgreSQL)**

Ein **Savepoint** ist ein **Zwischenpunkt innerhalb einer Transaktion**, auf den man mit `ROLLBACK TO` zur√ºckspringen kann, ohne die ganze Transaktion abzubrechen.
Er erlaubt eine **feinere Kontrolle** √ºber Fehlerbehandlung in langen oder komplexen Transaktionen.

---

### **1. Savepoint setzen**

```sql
BEGIN;

UPDATE accounts SET balance = balance - 100 WHERE id = 1;

SAVEPOINT sp1; -- Zwischenpunkt
```

---

### **2. Weiterarbeiten und ggf. zur√ºckspringen**

```sql
UPDATE accounts SET balance = balance + 100 WHERE id = 2;

-- Fehler passiert, zur√ºck zum Savepoint
ROLLBACK TO sp1;
```

‚û°Ô∏è Die √Ñnderung an `account 2` wird verworfen, aber die vorherige √Ñnderung (`account 1`) bleibt bestehen.

---

### **3. Transaktion fortsetzen**

```sql
UPDATE accounts SET balance = balance + 50 WHERE id = 3;

COMMIT; -- speichert die √Ñnderungen endg√ºltig
```

---

### **4. Savepoint l√∂schen (optional)**

```sql
RELEASE SAVEPOINT sp1;
```

‚û°Ô∏è Entfernt den Savepoint, ohne die Transaktion zu beenden.

---

### **Vorteile**

* Erm√∂glicht **Teil-Rollbacks** innerhalb einer Transaktion.
* N√ºtzlich bei komplexen Operationen mit mehreren Schritten.
* Verhindert unn√∂tige Komplettabbr√ºche der Transaktion.

---

**Zusammenfassung:**
Ein **Savepoint** ist ein Marker in einer Transaktion, zu dem man mit `ROLLBACK TO` zur√ºckspringen kann, ohne die ganze Transaktion zu verlieren.

üìñ Quellen:

* [PostgreSQL Docs ‚Äì Savepoints](https://www.postgresql.org/docs/current/sql-savepoint.html)


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

44. ### <a name="44"></a> Unterschied zwischen Deadlock und Race Condition?

### **Unterschied zwischen Deadlock und Race Condition**

---

### **1. Deadlock**

* Situation, in der sich **zwei oder mehr Transaktionen gegenseitig blockieren**.
* Keine der Transaktionen kann fortfahren, weil jede auf eine Ressource wartet, die von der anderen gehalten wird.
* F√ºhrt zu einem Stillstand, den PostgreSQL automatisch erkennt ‚Üí eine Transaktion wird abgebrochen.

**Beispiel:**

```sql
-- Transaktion A
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;

-- Transaktion B
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 2;

-- A will id=2 updaten, B will id=1 updaten ‚Üí Deadlock
```

‚û°Ô∏è Ergebnis: PostgreSQL bricht eine Transaktion mit `ERROR: deadlock detected` ab.

---

### **2. Race Condition**

* Tritt auf, wenn mehrere Transaktionen **gleichzeitig auf dieselben Daten zugreifen** und das Ergebnis von der **Reihenfolge der Ausf√ºhrung** abh√§ngt.
* Kann zu **inkonsistenten Daten** f√ºhren, wenn keine Synchronisation erfolgt.

**Beispiel:**

```sql
-- Kontostand = 100

-- Transaktion A liest balance = 100
-- Transaktion B liest balance = 100

-- A zieht 30 ab ‚Üí schreibt 70
-- B zieht 50 ab ‚Üí schreibt 50

-- Endergebnis = 50 (statt 20!)
```

‚û°Ô∏è Das passiert durch **fehlende Isolation** (Lost Update).

---

### **Vergleich**

| Merkmal   | Deadlock                                  | Race Condition                                   |
| --------- | ----------------------------------------- | ------------------------------------------------ |
| Ursache   | Gegenseitige Sperren auf Ressourcen       | Gleichzeitiger Zugriff ohne Kontrolle            |
| Wirkung   | Vollst√§ndiger Stillstand (Blockade)       | Falsche oder unerwartete Ergebnisse              |
| Erkennung | DB erkennt und bricht eine Transaktion ab | Schwerer zu erkennen, erfordert Isolation Levels |
| L√∂sung    | Sperr-Reihenfolge konsistent halten       | Geeignete Isolation (`SERIALIZABLE`, Locks)      |

---

**Zusammenfassung:**

* **Deadlock** = gegenseitige Blockade ‚Üí Stillstand, DB l√∂st es durch Abbruch.
* **Race Condition** = parallele Zugriffe f√ºhren zu falschen Ergebnissen ‚Üí verhindert durch Isolation oder Locks.

üìñ Quellen:

* [PostgreSQL Docs ‚Äì Concurrency Control](https://www.postgresql.org/docs/current/mvcc.html)
* [MDN Glossar ‚Äì Race Condition (RU)](https://developer.mozilla.org/ru/docs/Glossary/Race_condition)


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

45. ### <a name="45"></a> Welche Isolation Levels gibt es in PostgreSQL (READ COMMITTED, SERIALIZABLE)?

### **Isolation Levels in PostgreSQL**

Isolation Levels bestimmen, wie stark Transaktionen voneinander abgeschirmt werden. PostgreSQL unterst√ºtzt gem√§√ü **SQL-Standard** drei Stufen:

---

### **1. READ COMMITTED (Standard in PostgreSQL)**

* Jede Abfrage innerhalb einer Transaktion sieht nur **bereits best√§tigte √Ñnderungen (COMMIT)**.
* Wenn eine andere Transaktion w√§hrenddessen Daten √§ndert, sieht die n√§chste Abfrage innerhalb derselben Transaktion **den neuen Stand**.
* Verhindert **Dirty Reads**, erlaubt aber **Non-Repeatable Reads** und **Phantom Reads**.

**Beispiel:**

```sql
BEGIN; -- Transaktion A
SELECT balance FROM accounts WHERE id = 1; -- Ergebnis: 100

-- Transaktion B f√ºhrt UPDATE + COMMIT aus (balance = 200)

SELECT balance FROM accounts WHERE id = 1; -- Ergebnis: 200
COMMIT;
```

‚û°Ô∏è Wert hat sich w√§hrend der Transaktion ge√§ndert ‚Üí **Non-Repeatable Read** m√∂glich.

---

### **2. REPEATABLE READ**

* Alle Abfragen innerhalb einer Transaktion sehen einen **konsistenten Schnappschuss** vom Start der Transaktion.
* Andere Commits sind w√§hrenddessen **nicht sichtbar**.
* Verhindert **Dirty Reads** und **Non-Repeatable Reads**.
* Aber **Phantom Reads** sind noch m√∂glich.

---

### **3. SERIALIZABLE**

* St√§rkste Isolation.
* Transaktionen werden so ausgef√ºhrt, als ob sie **nacheinander (seriell)** gelaufen w√§ren.
* Verhindert **Dirty Reads, Non-Repeatable Reads und Phantom Reads**.
* Kann bei Konflikten zu Fehlern f√ºhren:

  ```text
  ERROR: could not serialize access due to concurrent update
  ```
* L√∂sung: Transaktion wiederholen.

---

### **Vergleich**

| Isolation Level | Dirty Read | Non-Repeatable Read | Phantom Read |
| --------------- | ---------- | ------------------- | ------------ |
| READ COMMITTED  | Nein       | Ja                  | Ja           |
| REPEATABLE READ | Nein       | Nein                | Ja           |
| SERIALIZABLE    | Nein       | Nein                | Nein         |

---

### **Setzen des Isolation Levels**

```sql
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

BEGIN;
-- Transaktionslogik
COMMIT;
```

---

**Zusammenfassung:**

* **READ COMMITTED** = Standard, schnell, aber schw√§chere Isolation.
* **REPEATABLE READ** = konsistenter Snapshot, verhindert Non-Repeatable Reads.
* **SERIALIZABLE** = h√∂chste Isolation, garantiert korrekte Ergebnisse, kann aber zu Rollbacks f√ºhren.

üìñ Quellen:

* [PostgreSQL Docs ‚Äì Transaction Isolation](https://www.postgresql.org/docs/current/transaction-iso.html)


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

46. ### <a name="46"></a> Unterschied zwischen Optimistic Locking und Pessimistic Locking?

### **Unterschied zwischen Optimistic Locking und Pessimistic Locking**

---

### **1. Optimistic Locking**

* Annahme: **Konflikte treten selten auf**.
* Mehrere Transaktionen d√ºrfen **gleichzeitig lesen und bearbeiten**.
* Beim Speichern wird gepr√ºft, ob sich die Daten zwischenzeitlich ge√§ndert haben ‚Üí wenn ja ‚Üí Fehler / Wiederholung n√∂tig.
* Technisch oft mit einer **Versionsspalte (`version`, `updated_at`)** umgesetzt.

**Beispiel:**

```sql
-- Tabelle mit Versionsspalte
CREATE TABLE accounts (
  id SERIAL PRIMARY KEY,
  balance NUMERIC,
  version INT DEFAULT 0
);

-- Update mit Optimistic Locking
UPDATE accounts
SET balance = balance - 100,
    version = version + 1
WHERE id = 1 AND version = 0;
```

‚û°Ô∏è Nur erfolgreich, wenn kein anderer die Zeile ver√§ndert hat.

**Vorteile:** Hohe Parallelit√§t, kein Locking n√∂tig.
**Nachteile:** Fehler beim Commit m√∂glich ‚Üí Transaktion muss wiederholt werden.

---

### **2. Pessimistic Locking**

* Annahme: **Konflikte treten h√§ufig auf**.
* Eine Transaktion sperrt die Daten sofort ‚Üí andere Transaktionen m√ºssen warten.
* Verhindert Konflikte, aber reduziert Parallelit√§t.

**Beispiel in PostgreSQL:**

```sql
BEGIN;

-- Sperrt die Zeile f√ºr andere Transaktionen (exclusive lock)
SELECT * FROM accounts
WHERE id = 1
FOR UPDATE;

-- √Ñnderungen vornehmen
UPDATE accounts SET balance = balance - 100 WHERE id = 1;

COMMIT;
```

‚û°Ô∏è Andere Transaktionen k√∂nnen erst nach Freigabe weitermachen.

**Vorteile:** Keine Konflikte beim Commit.
**Nachteile:** Weniger parallel, Gefahr von Deadlocks.

---

### **Vergleich**

| Merkmal          | Optimistic Locking                             | Pessimistic Locking                              |
| ---------------- | ---------------------------------------------- | ------------------------------------------------ |
| Annahme          | Konflikte sind selten                          | Konflikte sind wahrscheinlich                    |
| Sperren          | Keine direkten Locks                           | Zeilen/Tabelle werden gesperrt                   |
| Performance      | Hohe Parallelit√§t, effizient                   | Weniger parallel, langsamer bei vielen Zugriffen |
| Risiko           | Konflikte beim Commit, Wiederholung n√∂tig      | Deadlocks, lange Wartezeiten m√∂glich             |
| Typische Nutzung | Web-Apps, verteilte Systeme, seltene Konflikte | Banking, kritische Konsistenz, viele Konflikte   |

---

**Zusammenfassung:**

* **Optimistic Locking** ‚Üí keine Sperren, Konflikte erst beim Commit erkannt.
* **Pessimistic Locking** ‚Üí sofortige Sperre, Konflikte werden verhindert, aber weniger parallel.

üìñ Quellen:

* [PostgreSQL Docs ‚Äì Concurrency Control](https://www.postgresql.org/docs/current/mvcc.html)
* [MDN Glossar ‚Äì Race Condition (RU)](https://developer.mozilla.org/ru/docs/Glossary/Race_condition)


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

47. ### <a name="47"></a> Wie erkennt PostgreSQL Deadlocks?

### **Deadlock-Erkennung in PostgreSQL**

PostgreSQL arbeitet mit **Locks** (Sperren) auf Tabellen- oder Zeilenebene, um Konsistenz sicherzustellen.
Ein **Deadlock** entsteht, wenn zwei oder mehr Transaktionen sich gegenseitig blockieren:

* Transaktion A h√§lt Sperre X und will Sperre Y.
* Transaktion B h√§lt Sperre Y und will Sperre X.

Keiner kann fortfahren ‚Üí Deadlock.

---

### **1. Deadlock Detection Mechanismus**

* PostgreSQL verwaltet intern ein **Lock-Wait-Graph**:

  * Knoten = Transaktionen
  * Kanten = Abh√§ngigkeiten (‚Äûwartet auf Sperre‚Äú)
* Bei jedem **Lock-Wait** pr√ºft PostgreSQL, ob ein **Zyklus** im Graphen entsteht.
* Wenn Zyklus erkannt ‚Üí **Deadlock**.

---

### **2. Verhalten bei Deadlock**

* PostgreSQL bricht **sofort eine der beteiligten Transaktionen** ab (die ‚Äûbilligste‚Äú laut Heuristik ‚Üí meist die mit weniger Ressourcenverbrauch).
* Die andere Transaktion darf weiterlaufen.

**Fehlermeldung:**

```text
ERROR: deadlock detected
DETAIL: Process 12345 waits for ShareLock on transaction 67890; blocked by process 67890.
```

---

### **3. Beispiel f√ºr Deadlock**

```sql
-- Transaktion A
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;

-- Transaktion B
BEGIN;
UPDATE accounts SET balance = balance - 200 WHERE id = 2;

-- A versucht nun id=2 zu sperren
UPDATE accounts SET balance = balance - 50 WHERE id = 2;

-- B versucht id=1 zu sperren ‚Üí Deadlock
UPDATE accounts SET balance = balance - 30 WHERE id = 1;
```

‚û°Ô∏è PostgreSQL erkennt den Zyklus und bricht eine Transaktion ab.

---

### **4. Vermeidung von Deadlocks**

* **Konsistente Sperr-Reihenfolge** einhalten (immer gleiche Reihenfolge von Ressourcen sperren).
* M√∂glichst kleine Transaktionen.
* Sperren explizit mit `SELECT ... FOR UPDATE` setzen.

---

**Zusammenfassung:**
PostgreSQL erkennt Deadlocks durch Analyse des Lock-Wait-Graphen.
Bei einem Zyklus wird eine Transaktion automatisch abgebrochen, um das System zu entlasten.

üìñ Quellen:

* [PostgreSQL Docs ‚Äì Deadlocks](https://www.postgresql.org/docs/current/explicit-locking.html#LOCKING-DEADLOCKS)


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

48. ### <a name="48"></a> Welche Standard-Isolationsebene nutzt PostgreSQL?

### **Standard-Isolationsebene in PostgreSQL**

PostgreSQL verwendet standardm√§√üig die Isolationsebene:

üëâ **READ COMMITTED**

---

### **Eigenschaften von READ COMMITTED**

* Jede Anweisung innerhalb einer Transaktion sieht nur **bereits best√§tigte Daten** (kein Dirty Read).
* Jede Anweisung liest einen **neuen Snapshot** der Daten ‚Üí √Ñnderungen anderer Transaktionen nach deren COMMIT sind sofort sichtbar.
* Zul√§ssig sind aber:

  * **Non-Repeatable Reads** (derselbe SELECT kann verschiedene Ergebnisse liefern).
  * **Phantom Reads** (neue Zeilen k√∂nnen ‚Äûauftauchen‚Äú).

---

### **Beispiel**

```sql
BEGIN; -- Transaktion A
SELECT balance FROM accounts WHERE id = 1; -- Ergebnis: 100

-- Parallel: Transaktion B
UPDATE accounts SET balance = 200 WHERE id = 1;
COMMIT;

-- Transaktion A fragt erneut ab
SELECT balance FROM accounts WHERE id = 1; -- Ergebnis: 200
COMMIT;
```

‚û°Ô∏è In derselben Transaktion sieht man beim zweiten SELECT den **ge√§nderten Wert** ‚Üí typisch f√ºr READ COMMITTED.

---

**Zusammenfassung:**
Die Standard-Isolationsebene in PostgreSQL ist **READ COMMITTED**.
Sie verhindert Dirty Reads, erlaubt aber Non-Repeatable Reads und Phantom Reads.

üìñ Quellen:

* [PostgreSQL Docs ‚Äì Transaction Isolation](https://www.postgresql.org/docs/current/transaction-iso.html)


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

49. ### <a name="49"></a> Wie implementiert man Transaktionen in Node.js/Express mit PostgreSQL?

### **Transaktionen in Node.js/Express mit PostgreSQL**

---

#### **A) Mit `node-postgres` (`pg`) ‚Äì manuell `BEGIN/COMMIT/ROLLBACK`**

```js
// ESM-Imports
import express from "express";
import pg from "pg";

const { Pool } = pg;
const app = express();
app.use(express.json());

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  // ssl: { rejectUnauthorized: false } // falls n√∂tig (Cloud)
});

// Transaktions-Wrapper (Hilfsfunktion)
async function withTransaction(fn, { isolation = "READ COMMITTED" } = {}) {
  const client = await pool.connect();
  try {
    await client.query("BEGIN");
    await client.query(`SET TRANSACTION ISOLATION LEVEL ${isolation}`);
    const result = await fn(client);            // alle Queries √ºber denselben Client!
    await client.query("COMMIT");
    return result;
  } catch (err) {
    await client.query("ROLLBACK");
    throw err;
  } finally {
    client.release();
  }
}

// Beispiel-Route: Geld √ºberweisen (ACID-sicher)
app.post("/transfer", async (req, res) => {
  const { fromId, toId, amount } = req.body;

  try {
    const result = await withTransaction(async (client) => {
      // 1) Abbuchen (mit Plausibilit√§tscheck)
      const { rows: [from] } = await client.query(
        `UPDATE accounts
           SET balance = balance - $1
         WHERE id = $2
         RETURNING id, balance`,
        [amount, fromId]
      );
      if (!from || from.balance < 0) {
        throw new Error("Unzureichendes Guthaben oder Konto nicht gefunden");
      }

      // 2) Gutschrift
      const { rows: [to] } = await client.query(
        `UPDATE accounts
           SET balance = balance + $1
         WHERE id = $2
         RETURNING id, balance`,
        [amount, toId]
      );
      if (!to) throw new Error("Zielkonto nicht gefunden");

      return { from, to };
    }, { isolation: "SERIALIZABLE" }); // optional: st√§rkeres Isolation Level

    res.json({ ok: true, result });
  } catch (e) {
    res.status(400).json({ ok: false, error: e.message });
  }
});

app.listen(3000);
```

**Hinweise:**

* **Immer denselben `client`** innerhalb der Transaktion verwenden.
* Bei Fehlern: `ROLLBACK` im `catch`.
* Optional: **Savepoints** f√ºr Teil-Rollbacks:

  ```js
  await client.query("SAVEPOINT sp1");
  // ‚Ä¶ riskante Operation ‚Ä¶
  await client.query("ROLLBACK TO sp1"); // nur Teil zur√ºcknehmen
  ```

---

#### **B) Mit Sequelize (ORM) ‚Äì Transaktionen als API**

```js
// ESM-Imports
import { Sequelize, Transaction, DataTypes } from "sequelize";

export const sequelize = new Sequelize(process.env.DATABASE_URL, {
  dialect: "postgres"
});

const Account = sequelize.define("Account", {
  balance: { type: DataTypes.DECIMAL(12,2), allowNull: false }
}, { tableName: "accounts", timestamps: false });

// Muster: Manuelle Transaktion
async function transferSequelize(fromId, toId, amount) {
  const t = await sequelize.transaction({
    isolationLevel: Transaction.ISOLATION_LEVELS.SERIALIZABLE
  });

  try {
    const from = await Account.findByPk(fromId, { transaction: t, lock: t.LOCK.UPDATE });
    const to   = await Account.findByPk(toId,   { transaction: t, lock: t.LOCK.UPDATE });

    if (!from || !to) throw new Error("Konto nicht gefunden");
    if (Number(from.balance) < amount) throw new Error("Unzureichendes Guthaben");

    await from.update({ balance: Number(from.balance) - amount }, { transaction: t });
    await to.update({ balance: Number(to.balance) + amount }, { transaction: t });

    await t.commit();
    return { from, to };
  } catch (err) {
    await t.rollback();
    throw err;
  }
}
```

**Hinweise:**

* `transaction`-Objekt **√ºberall weitergeben** (`find/update/create`).
* Optional: **`lock: t.LOCK.UPDATE`** f√ºr pessimistisches Locking (verhindert Race Conditions).
* Isolation Level je nach Bedarf w√§hlen (z. B. `READ COMMITTED` vs. `SERIALIZABLE`).

---

#### **Best Practices**

* **Kleine, fokussierte Transaktionen** (kurze Sperrzeiten).
* **Konsistente Reihenfolge** beim Zugriff auf Ressourcen ‚Üí Deadlocks vermeiden.
* **Explizite Fehlerbehandlung** und **Retry** bei `SERIALIZABLE`-Konflikten.
* **Parameterisierte Queries** (`$1, $2, ‚Ä¶`) gegen SQL-Injection.
* **`EXPLAIN (ANALYZE, BUFFERS)`** nutzen, wenn Performance leidet.

---

**Zusammenfassung:**
Transaktionen in Node.js/Express mit PostgreSQL implementiert man entweder **niedrigschwellig mit `pg`** √ºber `BEGIN/COMMIT/ROLLBACK` (ein Client pro Transaktion, Fehler ‚Üí Rollback) oder **h√∂herstufig mit Sequelize** via `sequelize.transaction(...)`. Isolation Level und optionales Locking/Savepoints sichern Korrektheit unter Parallelit√§t.

üìñ **Quellen:**

* [PostgreSQL ‚Äì Transactions](https://www.postgresql.org/docs/current/tutorial-transactions.html)
* [PostgreSQL ‚Äì Transaction Isolation](https://www.postgresql.org/docs/current/transaction-iso.html)
* [Express.js Offizielle Doku](https://expressjs.com/de/)
* [Node.js Dokumentation](https://nodejs.org/docs)
* [Sequelize ‚Äì Transactions](https://sequelize.org/docs/v6/other-topics/transactions/)


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

50. ### <a name="50"></a> Unterschied zwischen BEGIN und START TRANSACTION?

### **Unterschied zwischen `BEGIN` und `START TRANSACTION` in PostgreSQL**

---

### **1. BEGIN**

* K√ºrzere Schreibweise f√ºr den Transaktionsstart.
* Von PostgreSQL als Alias f√ºr `START TRANSACTION` implementiert.
* In PostgreSQL g√§ngig, wird oft im Alltag verwendet.

**Beispiel:**

```sql
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
COMMIT;
```

---

### **2. START TRANSACTION**

* Standardkonforme SQL-Syntax (SQL-92).
* Bietet **mehr Optionen direkt beim Start**, z. B. Isolation Level oder Read/Write-Modus.

**Beispiel:**

```sql
START TRANSACTION ISOLATION LEVEL SERIALIZABLE READ WRITE;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;
```

---

### **3. Technischer Unterschied in PostgreSQL**

* Funktional **kein Unterschied** ‚Üí beide starten eine Transaktion.
* Nur bei **zus√§tzlichen Optionen** ist `START TRANSACTION` n√∂tig.
* PostgreSQL-Doku empfiehlt `START TRANSACTION`, wenn man **Isolation Levels oder Modus** setzen m√∂chte.

---

### **Vergleich**

| Merkmal              | `BEGIN`                      | `START TRANSACTION`           |
| -------------------- | ---------------------------- | ----------------------------- |
| SQL-Standard         | Nein (PostgreSQL-spezifisch) | Ja (SQL-konform)              |
| Optionen (Isolation) | Nicht m√∂glich                | Direkt beim Start m√∂glich     |
| Nutzung              | K√ºrzer, h√§ufiger             | Formeller, f√ºr komplexe F√§lle |

---

**Zusammenfassung:**

* **`BEGIN`** = PostgreSQL-Kurzform.
* **`START TRANSACTION`** = Standard-SQL, mit Optionen wie Isolation Level und Read/Write-Modus.
* In PostgreSQL sind beide im Alltag gleichwertig, au√üer man will spezielle Einstellungen setzen.

üìñ Quellen:

* [PostgreSQL Docs ‚Äì Transaction Control](https://www.postgresql.org/docs/current/sql-begin.html)
* [PostgreSQL Docs ‚Äì START TRANSACTION](https://www.postgresql.org/docs/current/sql-start-transaction.html)


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

51. ### <a name="51"></a> Wie verwaltet man Benutzer und Rollen in PostgreSQL?

### **Benutzer- und Rollenverwaltung in PostgreSQL**

In PostgreSQL sind **Benutzer und Rollen dasselbe Konzept**:

* **Benutzer** = Rolle mit **Login-Recht**.
* **Rolle** = Kann Berechtigungen haben und Mitglied anderer Rollen sein.

---

### **1. Benutzer/Rollen erstellen**

```sql
-- Benutzer mit Login-Recht
CREATE ROLE max LOGIN PASSWORD 'geheim';

-- Nur Rolle ohne Login
CREATE ROLE read_only;
```

---

### **2. Rechte vergeben**

```sql
-- Rechte f√ºr eine Tabelle
GRANT SELECT, INSERT ON users TO max;

-- Rolle als Gruppe nutzen
GRANT read_only TO max; -- Benutzer max ist jetzt Mitglied von read_only
```

---

### **3. Attribute von Rollen**

* `LOGIN` ‚Üí erlaubt Anmeldung.
* `SUPERUSER` ‚Üí uneingeschr√§nkte Rechte.
* `CREATEDB` ‚Üí darf neue Datenbanken anlegen.
* `CREATEROLE` ‚Üí darf neue Rollen erstellen.
* `REPLICATION` ‚Üí f√ºr Streaming-Replikation.
* `INHERIT` ‚Üí erbt Rechte von Rollen, in denen sie Mitglied ist.

**Beispiel:**

```sql
CREATE ROLE admin LOGIN PASSWORD 'admin123'
  CREATEDB CREATEROLE;
```

---

### **4. Rollen √§ndern**

```sql
ALTER ROLE max WITH PASSWORD 'neuPasswort';
ALTER ROLE max WITH LOGIN;
```

---

### **5. Rollen l√∂schen**

```sql
DROP ROLE max;
```

---

### **6. Aktuelle Rollen anzeigen**

```sql
\du   -- im psql-Client
```

Beispielausgabe:

```
 Role name | Attributes                 | Member of
-----------+----------------------------+-----------
 postgres  | Superuser, Create DB       | {}
 max       |                            | {read_only}
```

---

### **7. Best Practices**

* F√ºr **jeden Entwickler/Service eigenen Benutzer** anlegen.
* Rechte so restriktiv wie m√∂glich vergeben (**Principle of Least Privilege**).
* Rollen als Gruppen nutzen (z. B. `read_only`, `read_write`).

---

**Zusammenfassung:**
PostgreSQL verwaltet Benutzer und Rollen √ºber das gleiche Konzept: Rollen k√∂nnen **Login-Rechte** haben und Berechtigungen √ºbernehmen. Man vergibt Rechte √ºber `GRANT`, organisiert Nutzer in Rollen-Gruppen und nutzt Attribute wie `CREATEDB` oder `CREATEROLE` f√ºr erweiterte Privilegien.

üìñ Quellen:

* [PostgreSQL Docs ‚Äì Database Roles](https://www.postgresql.org/docs/current/user-manag.html)
* [PostgreSQL Docs ‚Äì GRANT](https://www.postgresql.org/docs/current/sql-grant.html)


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

52. ### <a name="52"></a> Unterschied zwischen Login-Rollen und Gruppen-Rollen?

### **Unterschied zwischen Login-Rollen und Gruppen-Rollen in PostgreSQL**

PostgreSQL kennt nur **Rollen** ‚Äì diese k√∂nnen unterschiedliche Attribute haben.
Der Unterschied zwischen **Login-Rollen** und **Gruppen-Rollen** ergibt sich aus deren Rechten.

---

### **1. Login-Rollen**

* Rollen mit dem Attribut **`LOGIN`**.
* K√∂nnen sich **anmelden** (z. B. per `psql`, Anwendung, Benutzerkonto).
* Werden als **Benutzer** verstanden.

**Beispiel:**

```sql
CREATE ROLE max LOGIN PASSWORD 'geheim';
```

‚û°Ô∏è `max` kann sich direkt an der Datenbank anmelden.

---

### **2. Gruppen-Rollen**

* Rollen **ohne `LOGIN`**.
* Dienen als **Sammelrollen**, um Berechtigungen zu b√ºndeln.
* K√∂nnen an Login-Rollen vergeben werden.

**Beispiel:**

```sql
CREATE ROLE read_only; -- ohne LOGIN
GRANT SELECT ON ALL TABLES IN SCHEMA public TO read_only;

-- Benutzer max erh√§lt die Gruppenrolle
GRANT read_only TO max;
```

‚û°Ô∏è `max` kann sich einloggen und hat zus√§tzlich **READ-ONLY-Rechte**.

---

### **3. Vergleich**

| Merkmal       | Login-Rolle                  | Gruppen-Rolle                 |
| ------------- | ---------------------------- | ----------------------------- |
| LOGIN m√∂glich | ‚úÖ Ja                         | ‚ùå Nein                        |
| Zweck         | Benutzerkonto                | Rechteb√ºndel (Gruppe)         |
| Beispiel      | `CREATE ROLE anna LOGIN ...` | `CREATE ROLE reporting;`      |
| Nutzung       | Verbindung zur DB            | Verwaltung von Berechtigungen |

---

**Zusammenfassung:**

* **Login-Rolle** = tats√§chlicher Benutzer (kann sich anmelden).
* **Gruppen-Rolle** = Sammlung von Berechtigungen (wird Benutzern zugewiesen).
  Best Practice: **Benutzer = Login-Rollen**, **Gruppen = Rollen ohne Login** f√ºr Rechteverwaltung.

üìñ Quellen:

* [PostgreSQL Docs ‚Äì Database Roles](https://www.postgresql.org/docs/current/user-manag.html)


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

53. ### <a name="53"></a> Wie vergibt man Berechtigungen (GRANT, REVOKE)?

### **Berechtigungen in PostgreSQL mit `GRANT` und `REVOKE`**

PostgreSQL steuert den Zugriff auf Objekte (Tabellen, Schemata, Funktionen usw.) √ºber **Privileges**.
Man vergibt (`GRANT`) oder entzieht (`REVOKE`) diese an Rollen oder Benutzer.

---

### **1. GRANT ‚Äì Rechte vergeben**

```sql
-- SELECT-Recht auf Tabelle users an Rolle read_only
GRANT SELECT ON users TO read_only;

-- Alle Rechte auf Tabelle users an Benutzer max
GRANT ALL PRIVILEGES ON users TO max;

-- Nutzung eines Schemas erlauben
GRANT USAGE ON SCHEMA public TO read_only;
```

‚û°Ô∏è `GRANT` erm√∂glicht Rollen/Benutzern den Zugriff.

---

### **2. REVOKE ‚Äì Rechte entziehen**

```sql
-- SELECT-Recht entziehen
REVOKE SELECT ON users FROM read_only;

-- Alle Rechte entziehen
REVOKE ALL PRIVILEGES ON users FROM max;
```

‚û°Ô∏è `REVOKE` entfernt bestimmte oder alle Rechte.

---

### **3. Verf√ºgbare Privilegien (h√§ufig genutzt)**

* **SELECT** ‚Üí Lesen von Tabellen/Views.
* **INSERT** ‚Üí Neue Zeilen einf√ºgen.
* **UPDATE** ‚Üí Daten √§ndern.
* **DELETE** ‚Üí Daten l√∂schen.
* **TRUNCATE** ‚Üí Tabelle leeren.
* **REFERENCES** ‚Üí Fremdschl√ºssel auf Tabelle setzen.
* **USAGE** ‚Üí Nutzung von Schema oder Sequenz.
* **EXECUTE** ‚Üí Funktionen/Prozeduren ausf√ºhren.
* **ALL PRIVILEGES** ‚Üí alle verf√ºgbaren Rechte.

---

### **4. Beispiel: Kombinierte Nutzung**

```sql
-- Neue Gruppe mit Lese-Rechten
CREATE ROLE read_only;

-- Lesezugriff auf alle Tabellen im Schema public
GRANT CONNECT ON DATABASE mydb TO read_only;
GRANT USAGE ON SCHEMA public TO read_only;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO read_only;

-- Benutzer max bekommt die Rolle
GRANT read_only TO max;
```

---

### **5. Rechte entziehen**

```sql
-- Benutzer max darf nicht mehr lesen
REVOKE read_only FROM max;
```

---

### **6. Aktuelle Berechtigungen anzeigen**

```sql
\z users   -- im psql-Client: zeigt Privilegien f√ºr Tabelle users
```

---

**Zusammenfassung:**

* **`GRANT`** ‚Üí Rechte vergeben.
* **`REVOKE`** ‚Üí Rechte entziehen.
* Typische Rechte: `SELECT`, `INSERT`, `UPDATE`, `DELETE`, `USAGE`, `EXECUTE`.
* Best Practice: **Gruppenrollen f√ºr Berechtigungen**, **Login-Rollen f√ºr Benutzer**.

üìñ Quellen:

* [PostgreSQL Docs ‚Äì GRANT](https://www.postgresql.org/docs/current/sql-grant.html)
* [PostgreSQL Docs ‚Äì REVOKE](https://www.postgresql.org/docs/current/sql-revoke.html)


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

54. ### <a name="54"></a> Was ist Row Level Security (RLS) in PostgreSQL?

### **Row Level Security (RLS) in PostgreSQL**

**Row Level Security (RLS)** ist ein Sicherheitsmechanismus, mit dem man **Zugriffsrechte auf Zeilenebene** steuern kann.
Damit wird festgelegt, **welche Zeilen einer Tabelle ein Benutzer sehen oder √§ndern darf**.

---

### **1. Aktivierung von RLS**

```sql
ALTER TABLE accounts ENABLE ROW LEVEL SECURITY;
```

---

### **2. Policies definieren**

Eine **Policy** beschreibt die Bedingungen, unter denen ein Benutzer Zeilen lesen, einf√ºgen oder √§ndern darf.

**Beispiel: Benutzer darf nur seine eigenen Konten sehen**

```sql
CREATE POLICY user_can_select_own_rows
ON accounts
FOR SELECT
USING (owner_id = current_user::int);
```

‚û°Ô∏è `USING` definiert, welche Zeilen bei `SELECT` sichtbar sind.

---

### **3. Policies f√ºr andere Operationen**

* **SELECT** ‚Üí Zugriff auf Zeilen beim Lesen
* **INSERT** ‚Üí Bedingungen f√ºr neue Zeilen
* **UPDATE** ‚Üí Welche Zeilen aktualisiert werden d√ºrfen
* **DELETE** ‚Üí Welche Zeilen gel√∂scht werden d√ºrfen

**Beispiel: Benutzer darf nur eigene Zeilen √§ndern**

```sql
CREATE POLICY user_can_update_own_rows
ON accounts
FOR UPDATE
USING (owner_id = current_user::int);
```

---

### **4. Zugriff f√ºr alle Benutzer (optional)**

Falls auch Superuser-Rollen oder bestimmte Gruppen Zugriff haben sollen:

```sql
ALTER TABLE accounts FORCE ROW LEVEL SECURITY; -- erzwingt RLS
```

---

### **5. Kombination mit GRANT**

* RLS ersetzt nicht `GRANT`/`REVOKE`.
* Erst **Basisrechte** (z. B. `SELECT`, `UPDATE`) vergeben, dann √ºber Policies fein steuern.

---

### **6. Beispiel komplett**

```sql
-- Tabelle mit Konten
CREATE TABLE accounts (
  id SERIAL PRIMARY KEY,
  owner_id INT NOT NULL,
  balance NUMERIC NOT NULL
);

-- RLS aktivieren
ALTER TABLE accounts ENABLE ROW LEVEL SECURITY;

-- Policy: jeder Benutzer sieht nur seine eigenen Zeilen
CREATE POLICY own_rows_only
ON accounts
FOR SELECT
USING (owner_id = current_user::int);

-- Rechte vergeben
GRANT SELECT ON accounts TO public;
```

---

### **Vorteile von RLS**

* Sehr fein granulierte Sicherheit.
* Besonders n√ºtzlich f√ºr **Multi-Tenant-Apps** (z. B. SaaS-Systeme).
* Regeln liegen **direkt in der Datenbank** ‚Üí weniger Logik im Code.

---

**Zusammenfassung:**
Row Level Security (RLS) erm√∂glicht Zugriffskontrolle **auf Zeilenebene** in PostgreSQL. Mit Policies legt man fest, welche Zeilen ein Benutzer lesen, einf√ºgen, √§ndern oder l√∂schen darf.

üìñ Quellen:

* [PostgreSQL Docs ‚Äì Row Security Policies](https://www.postgresql.org/docs/current/ddl-rowsecurity.html)


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

55. ### <a name="55"></a> Wie sch√ºtzt man sensible Daten (z. B. Passw√∂rter) in PostgreSQL?

### **Schutz sensibler Daten (z. B. Passw√∂rter) in PostgreSQL**

---

#### **1) Passw√∂rter: niemals im Klartext**

* **Hash + Salt** verwenden (empfohlen: **Argon2id**, alternativ **bcrypt**).
* Hashing **in der Applikation** durchf√ºhren; DB speichert nur den Hash.
* In PostgreSQL-Only-Setups kann `pgcrypto` genutzt werden.

**Node.js (ESM) mit Argon2id**

```js
import argon2 from "argon2";

// Hashen
const hash = await argon2.hash(plaintextPassword, {
  type: argon2.argon2id,
  memoryCost: 2 ** 16,  // z. B. 64 MiB
  timeCost: 3,
  parallelism: 1
});

// Pr√ºfen
const ok = await argon2.verify(hash, loginPassword);
```

**PostgreSQL (pgcrypto, falls Hashing in der DB)**

```sql
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- bcrypt-Hash erstellen/pr√ºfen
UPDATE users SET password_hash = crypt($1, gen_salt('bf'));
SELECT crypt($1, password_hash) = password_hash AS valid FROM users WHERE email=$2;
```

---

#### **2) Transport & Zugriff**

* **TLS aktivieren** (Client‚ÜîServer): `ssl = on`, Zertifikate nutzen.
* **Least Privilege**: separate **Login-Rollen** pro Service, nur ben√∂tigte Rechte (`GRANT/REVOKE`).
* **RLS** (Row Level Security) f√ºr mandantenf√§hige/zeilengranulare Zugriffe.
* **Sensible Spalten abschirmen**: nur √ºber **Views** freigeben; direkte Spaltenrechte entziehen.

---

#### **3) Daten ‚Äûat rest‚Äú**

* **Festplatten-/Volume-Verschl√ºsselung** (OS/Cloud) f√ºr das Cluster.
* **Spaltenweise Verschl√ºsselung** f√ºr besonders sensible Felder mit `pgcrypto`.

```sql
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- symmetrisch verschl√ºsseln (z. B. Steuer-ID)
INSERT INTO persons(ssn_enc)
VALUES (pgp_sym_encrypt('123-45-6789', current_setting('app.encryption_key')));

-- entschl√ºsseln
SELECT pgp_sym_decrypt(ssn_enc, current_setting('app.encryption_key')) AS ssn
FROM persons;
```

> Schl√ºssel **nie** hartkodieren; via **Server-Var/Secret-Manager** injizieren (z. B. `ALTER DATABASE SET app.encryption_key TO '...';` nur zur Laufzeit setzen).

---

#### **4) Server-Authentifizierung**

* **SCRAM-SHA-256** f√ºr DB-Rollen aktivieren:

```sql
ALTER SYSTEM SET password_encryption = 'scram-sha-256';
SELECT pg_reload_conf();
```

* Alte `md5`-Passw√∂rter migrieren.

---

#### **5) Auditing & Betrieb**

* **Logging** sensibler Spalten verhindern (kein PII in Logs).
* **Backups** verschl√ºsseln (z. B. `pg_dump` ‚Üí verschl√ºsselte Speicherung).
* **EXPLAIN/Parameterization**: Nur **parametrisierte Queries** verwenden, kein SQL-Injection.
* **Regelm√§√üige Updates** (PostgreSQL/OS), **Rechte-Review**, **Rotation** von Secrets/Keys.

---

#### **6) Wann DB-seitiges Hashing sinnvoll ist**

* Zentralisierte Passwortlogik ohne Applikationszugriff auf Klartext.
* Beachte: Funktionsumfang (Argon2) ist in DB begrenzt; moderne KDFs besser **in der App**.

---

**Zusammenfassung:**

* Passw√∂rter stets mit **Argon2id/bcrypt** hashen (idealerweise in der App); nur Hash speichern.
* **TLS**, **Least Privilege**, **RLS** und **Views** f√ºr Zugriffskontrolle.
* **At-rest-Schutz** via Volume-Verschl√ºsselung und gezielte **Spaltenverschl√ºsselung** mit `pgcrypto`.
* **SCRAM-SHA-256** f√ºr Rollenpassw√∂rter aktivieren; Backups/Logs sicher handhaben.

üìñ **Quellen:**

* [PostgreSQL Docs ‚Äì Data Types / `pgcrypto`](https://www.postgresql.org/docs/current/pgcrypto.html)
* [PostgreSQL Docs ‚Äì Row Security](https://www.postgresql.org/docs/current/ddl-rowsecurity.html)
* [PostgreSQL Docs ‚Äì GRANT/REVOKE](https://www.postgresql.org/docs/current/sql-grant.html)
* [PostgreSQL Docs ‚Äì Authentication / `password_encryption`](https://www.postgresql.org/docs/current/auth-password.html)
* [MDN (RU) ‚Äì –ü–∞—Ä–æ–ª–∏ –∏ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è (–æ–±—â–∏–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏)](https://developer.mozilla.org/ru/)


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

56. ### <a name="56"></a> Wie sichert man eine PostgreSQL-Datenbank (pg_dump)?

### **Backup einer PostgreSQL-Datenbank mit `pg_dump`**

Das Standardwerkzeug f√ºr Backups in PostgreSQL ist **`pg_dump`**. Es erstellt **logische Backups**, d. h. SQL-Skripte oder portierbare Dumps, die unabh√§ngig von der PostgreSQL-Version sind.

---

### **1. Einfache Sicherung (SQL-Skript)**

```bash
pg_dump -U username -d mydb > backup.sql
```

* Enth√§lt alle `CREATE TABLE`, `INSERT` usw.
* Kann mit `psql` wiederhergestellt werden:

```bash
psql -U username -d mydb < backup.sql
```

---

### **2. Backup mit Schema + Daten**

* **Nur Schema (ohne Daten):**

```bash
pg_dump -U username -s mydb > schema.sql
```

* **Nur Daten (ohne Schema):**

```bash
pg_dump -U username -a mydb > data.sql
```

---

### **3. Komprimierte / Custom Backups**

`pg_dump` kann auch im **Custom-Format** sichern (`-Fc`):

```bash
pg_dump -U username -d mydb -Fc > backup.dump
```

Wiederherstellung mit `pg_restore`:

```bash
pg_restore -U username -d mydb backup.dump
```

---

### **4. Parallele Backups (schneller bei gro√üen DBs)**

Nur im **Custom/Directory-Format** m√∂glich:

```bash
pg_dump -U username -d mydb -Fd -j 4 -f /backups/mydb_dir
```

* `-Fd` = Directory-Format
* `-j 4` = 4 parallele Jobs

Wiederherstellung:

```bash
pg_restore -U username -d mydb -j 4 /backups/mydb_dir
```

---

### **5. Ganze Cluster sichern (alle DBs)**

Daf√ºr nutzt man **`pg_dumpall`**:

```bash
pg_dumpall -U username > cluster_backup.sql
```

‚û°Ô∏è Enth√§lt auch Rollen und globale Objekte.

---

### **6. Best Practices**

* **Automatisieren** (z. B. via Cronjob):

```bash
0 2 * * * pg_dump -U username -Fc mydb > /backups/mydb_$(date +\%F).dump
```

* **Backups verschl√ºsseln** (z. B. mit `gpg`).
* **Regelm√§√üig testen** (`restore` auf Testsystem pr√ºfen).
* F√ºr sehr gro√üe DBs: zus√§tzlich **physische Backups** mit **`pg_basebackup`** oder Replikation.

---

**Zusammenfassung:**

* `pg_dump` ‚Üí Backup einer einzelnen DB (Schema + Daten).
* Formate: **SQL (Standard)**, **Custom/Directory (schnell, parallel, flexibel)**.
* Wiederherstellung: `psql` (SQL) oder `pg_restore` (Custom/Dir).
* **pg\_dumpall** ‚Üí Backup des gesamten Clusters inkl. Rollen.

üìñ Quellen:

* [PostgreSQL Docs ‚Äì pg\_dump](https://www.postgresql.org/docs/current/app-pgdump.html)
* [PostgreSQL Docs ‚Äì pg\_restore](https://www.postgresql.org/docs/current/app-pgrestore.html)
* [PostgreSQL Docs ‚Äì pg\_dumpall](https://www.postgresql.org/docs/current/app-pgdumpall.html)


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

57. ### <a name="57"></a> Wie stellt man ein Backup wieder her?

### **Wiederherstellung eines PostgreSQL-Backups**

Die Wiederherstellung h√§ngt vom Format des Backups ab, das mit `pg_dump` oder `pg_dumpall` erstellt wurde.

---

### **1. SQL-Backup (Plain Text)**

* Enth√§lt `CREATE TABLE`, `INSERT`, ‚Ä¶ ‚Üí direkt mit `psql` einspielen.

```bash
psql -U username -d mydb < backup.sql
```

‚û°Ô∏è Vorher sicherstellen, dass die Datenbank **existiert**:

```bash
createdb -U username mydb
```

---

### **2. Custom- oder Directory-Format (`-Fc`, `-Fd`)**

* Muss mit **pg\_restore** wiederhergestellt werden.

**Einfaches Restore in bestehende DB:**

```bash
pg_restore -U username -d mydb backup.dump
```

**Vorherige Datenbank ersetzen (DROP + CREATE):**

```bash
pg_restore -U username -C -d postgres backup.dump
```

‚û°Ô∏è `-C` erstellt die Datenbank automatisch.

**Paralleles Restore (schneller):**

```bash
pg_restore -U username -d mydb -j 4 /backups/mydb_dir
```

---

### **3. Komplettes Cluster-Backup (`pg_dumpall`)**

```bash
psql -U username -f cluster_backup.sql postgres
```

‚û°Ô∏è Spielt **alle Datenbanken + Rollen** wieder ein.

---

### **4. Best Practices**

* Immer **auf Testsystem pr√ºfen**, bevor man ein Backup in Produktion einspielt.
* Gegebenenfalls vorher DB l√∂schen/leeren:

```bash
dropdb -U username mydb
createdb -U username mydb
```

* Bei gro√üen DBs: besser **pg\_restore im Directory-Format mit -j (parallel)** nutzen.
* F√ºr Rollen/Rechte: `pg_dumpall --globals-only` sichern und mit `psql` zur√ºckspielen.

---

**Zusammenfassung:**

* **SQL-Backups** ‚Üí mit `psql` einspielen.
* **Custom/Directory-Backups** ‚Üí mit `pg_restore`.
* **pg\_dumpall-Backups** ‚Üí mit `psql` auf `postgres` zur√ºckspielen.

üìñ Quellen:

* [PostgreSQL Docs ‚Äì Restoring the Dump](https://www.postgresql.org/docs/current/backup-dump.html#BACKUP-DUMP-RESTORE)
* [PostgreSQL Docs ‚Äì pg\_restore](https://www.postgresql.org/docs/current/app-pgrestore.html)


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

58. ### <a name="58"></a> Unterschied zwischen pg_dump und pg_restore?

### **Unterschied zwischen `pg_dump` und `pg_restore` in PostgreSQL**

---

### **1. `pg_dump`**

* Werkzeug zum **Erstellen von Backups**.
* Erzeugt ein **logisches Backup** (Daten + Schema).
* Unterst√ºtzte Formate:

  * **Plain SQL** (`.sql`) ‚Üí direkt mit `psql` einspielbar.
  * **Custom** (`-Fc`) ‚Üí komprimiert, f√ºr `pg_restore`.
  * **Directory** (`-Fd`) ‚Üí Ordnerstruktur, parallele Dumps m√∂glich.
  * **Tar** (`-Ft`).

**Beispiel:**

```bash
pg_dump -U username -d mydb > backup.sql      # Plain SQL
pg_dump -U username -Fc mydb > backup.dump    # Custom Format
```

---

### **2. `pg_restore`**

* Werkzeug zum **Wiederherstellen von Backups**, die mit `pg_dump` im **Custom/Directory/Tar-Format** erstellt wurden.
* Vorteile gegen√ºber `psql` (bei Plain SQL):

  * Selektives Restore (z. B. nur bestimmte Tabellen/Funktionen).
  * Paralleles Restore (`-j`).
  * Kontrolle √ºber Reihenfolge und Objekte.

**Beispiel:**

```bash
pg_restore -U username -d mydb backup.dump        # Restore Custom-Backup
pg_restore -U username -d mydb -j 4 mydb_dir      # Restore Directory-Backup parallel
pg_restore -l backup.dump                         # Liste der enthaltenen Objekte
pg_restore -t users -d mydb backup.dump           # Nur Tabelle "users" wiederherstellen
```

---

### **3. Vergleich**

| Merkmal            | `pg_dump`                       | `pg_restore`                            |
| ------------------ | ------------------------------- | --------------------------------------- |
| Zweck              | Backup erstellen                | Backup wiederherstellen                 |
| Input              | Datenbank                       | Dump-Datei (Custom/Dir/Tar)             |
| Output             | Dump-Datei (SQL/Custom/Dir/Tar) | Datenbank (oder SQL)                    |
| Plain-SQL nutzbar? | Ja                              | Nein (daf√ºr `psql`)                     |
| Selektives Restore | Nein                            | Ja (z. B. einzelne Tabellen/Funktionen) |
| Parallelisierung   | Beim Dump mit `-Fd`             | Beim Restore mit `-j`                   |

---

**Zusammenfassung:**

* **`pg_dump`** ‚Üí erstellt ein Backup (SQL oder spezielles Format).
* **`pg_restore`** ‚Üí spielt Backups im **Custom/Directory/Tar-Format** wieder ein und erlaubt selektives, paralleles Restore.
* F√ºr **Plain SQL Dumps** nutzt man direkt `psql` zum Wiederherstellen.

üìñ Quellen:

* [PostgreSQL Docs ‚Äì pg\_dump](https://www.postgresql.org/docs/current/app-pgdump.html)
* [PostgreSQL Docs ‚Äì pg\_restore](https://www.postgresql.org/docs/current/app-pgrestore.html)


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

59. ### <a name="59"></a> Wie konfiguriert man SSL f√ºr PostgreSQL-Verbindungen?

### **SSL/TLS f√ºr PostgreSQL-Verbindungen konfigurieren**

---

#### **1) Server-Zertifikate erstellen/ablegen**

```bash
# Self-signed (Test)
openssl req -new -x509 -days 365 -nodes \
  -out server.crt -keyout server.key -subj "/CN=db.example.com"

# Rechte setzen (wichtig!)
chmod 600 server.key
chown postgres:postgres server.crt server.key

# In PG-Datenverzeichnis verschieben (z. B. /var/lib/postgresql/data)
mv server.crt server.key $PGDATA/
```

> Produktion: **CA-signiertes** Zertifikat (z. B. via Let‚Äôs Encrypt). Chain korrekt ablegen (server.crt inkl. Intermediate).

---

#### **2) `postgresql.conf`**

```conf
ssl = on
ssl_cert_file = 'server.crt'
ssl_key_file  = 'server.key'
# optional: ssl_ciphers, ssl_min_protocol_version = 'TLSv1.2'
```

---

#### **3) `pg_hba.conf` (nur SSL erlauben)**

```conf
# Nur SSL-Verbindungen akzeptieren:
hostssl all all 0.0.0.0/0 scram-sha-256
hostssl all all ::0/0       scram-sha-256

# (Optional) Non-SSL explizit ablehnen:
hostnossl all all 0.0.0.0/0 reject
hostnossl all all ::0/0     reject
```

> Optional: **Client-Zertifikate** erzwingen (`clientcert=verify-full`) bei hostssl-Zeilen.

---

#### **4) Server neu laden**

```bash
pg_ctl reload   # oder: SELECT pg_reload_conf();
```

---

#### **5) Clientseite ‚Äì `psql` testen**

```bash
# Mindestens SSL verwenden
psql "host=db.example.com dbname=mydb user=myuser sslmode=require"

# Server gegen CA pr√ºfen (empfohlen)
# Root-CA lokal speichern: ~/.postgresql/root.crt
psql "host=db.example.com dbname=mydb user=myuser sslmode=verify-full"
```

**sslmode-√úbersicht:**

* `require` ‚Üí verschl√ºsselt, pr√ºft Zertifikat **nicht**
* `verify-ca` ‚Üí CA gepr√ºft, **Hostnamen nicht**
* `verify-full` ‚Üí CA **und** Hostname gepr√ºft (**empfohlen**)

---

#### **6) Node.js/Express (`pg`)**

```js
import pg from "pg";
import fs from "node:fs";

const pool = new pg.Pool({
  host: "db.example.com",
  user: "myuser",
  database: "mydb",
  password: process.env.DB_PASSWORD,
  port: 5432,
  ssl: {
    rejectUnauthorized: true,                   // wie verify-full
    ca:   fs.readFileSync("/etc/ssl/rootCA.pem").toString(),
    // optional bei mTLS (Client-Zertifikate):
    // key:  fs.readFileSync("/etc/ssl/client.key").toString(),
    // cert: fs.readFileSync("/etc/ssl/client.crt").toString(),
  },
});
```

---

#### **7) Verifikation & Betrieb**

* **√úberpr√ºfen:** `SHOW ssl;` (sollte `on` sein), `\conninfo` in `psql` (zeigt TLS).
* **Schl√ºssel sch√ºtzen:** `server.key` ausschlie√ülich f√ºr `postgres` lesbar.
* **Nur starke Protokolle/Cipher:** `ssl_min_protocol_version = 'TLSv1.2'` oder h√∂her.
* **Hostname passend zum Zertifikat** (CN/SAN = `db.example.com`).
* **Backups/HA:** Zertifikate/Keys sicher versionieren/rotieren (kein Git!).

---

**Zusammenfassung:**
SSL aktivieren (`ssl=on`), Zertifikat/Key mit restriktiven Rechten ins Datenverzeichnis legen, in `pg_hba.conf` **hostssl** nutzen (optional non-SSL blockieren), Server neu laden. Clients mit `sslmode=verify-full` und korrekter CA verbinden; in Node.js `ssl.rejectUnauthorized=true` plus `ca` verwenden. Produktion: CA-signierte Zertifikate und starke TLS-Einstellungen.

üìñ **Quellen:**

* [PostgreSQL Docs ‚Äì SSL Support](https://www.postgresql.org/docs/current/ssl-tcp.html)
* [PostgreSQL Docs ‚Äì Client Authentication (`pg_hba.conf`)](https://www.postgresql.org/docs/current/auth-pg-hba-conf.html)
* [PostgreSQL Docs ‚Äì libpq SSL Modes](https://www.postgresql.org/docs/current/libpq-ssl.html)


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

60. ### <a name="60"></a> Was ist Connection Pooling und wie implementiert man es (z. B. mit pg-pool in Node.js)?

### **Connection Pooling in PostgreSQL & Implementierung mit `pg` (pg-pool) in Node.js**

**Definition:**
Connection Pooling h√§lt **wiederverwendbare DB-Verbindungen** offen, statt pro Request eine neue TCP/SSL-/Auth-Verbindung aufzubauen. Ziel: **Latenz reduzieren**, **Ressourcen begrenzen**, **Durchsatz erh√∂hen**.

---

### **Warum Pooling?**

* Neue Verbindungen sind teuer (Handshake, Auth, TLS).
* PostgreSQL hat **Begrenzungen pro Server**; zu viele parallele Sessions schaden der Performance.
* Gleichm√§√üige Lastverteilung und Backpressure (max. Verbindungen).

---

### **Implementierung mit `pg` (ESM)**

```js
// pool.js
import pg from "pg";
const { Pool } = pg;

export const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  max: 10,                 // maximale gleichzeitige Verbindungen im Pool
  idleTimeoutMillis: 30_000, // Idle-Verbindung schlie√üen nach 30s
  connectionTimeoutMillis: 5_000, // Wartezeit bis Verbindungsaufbau fehlschl√§gt
  // ssl: { rejectUnauthorized: true, ca: '...'} // falls n√∂tig
});

// optional: sauberes Herunterfahren (z. B. bei SIGTERM/K8s)
process.on("SIGTERM", async () => {
  await pool.end();
  process.exit(0);
});
```

```js
// app.js
import express from "express";
import { pool } from "./pool.js";

const app = express();
app.use(express.json());

// Einfache Query (Pool verwaltet Verbindungen)
app.get("/users", async (_req, res) => {
  try {
    const { rows } = await pool.query("SELECT id, email FROM users ORDER BY id LIMIT 100");
    res.json(rows);
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

// Transaktion: immer denselben Client verwenden!
app.post("/transfer", async (req, res) => {
  const { fromId, toId, amount } = req.body;
  const client = await pool.connect();
  try {
    await client.query("BEGIN");
    const { rows: [from] } = await client.query(
      "UPDATE accounts SET balance = balance - $1 WHERE id = $2 RETURNING id,balance",
      [amount, fromId]
    );
    if (!from || Number(from.balance) < 0) throw new Error("Unzureichendes Guthaben");
    await client.query(
      "UPDATE accounts SET balance = balance + $1 WHERE id = $2",
      [amount, toId]
    );
    await client.query("COMMIT");
    res.json({ ok: true });
  } catch (err) {
    await client.query("ROLLBACK");
    res.status(400).json({ ok: false, error: err.message });
  } finally {
    client.release(); // sehr wichtig: sonst Verbindungs-Leak!
  }
});

app.listen(3000);
```

---

### **Best Practices**

* **Ein Pool pro Prozess**, nicht pro Request/Route erstellen.
* **`max`** sinnvoll setzen (z. B. Anzahl CPU-Worker √ó 5‚Äì10) und **Serverlimit** beachten (`max_connections` bzw. PgBouncer-Limit).
* **Transaktionen:** denselben **`client`** durchreichen; nach Nutzung **`release()`**.
* **Timeouts**/**Backpressure** konfigurieren (z. B. `connectionTimeoutMillis`).
* **SSL/TLS** korrekt konfigurieren in produktiven Umgebungen.
* **Pooling auf Infrastruktur-Ebene:** F√ºr viele Services/Server **PgBouncer** nutzen (Modus *transaction pooling* f√ºr hohe Parallelit√§t, *session pooling* wenn Session-Features n√∂tig, z. B. Temp-Tables, CTE-cursors).

---

### **Typische Fehler**

* Pool in jeder Funktion neu erzeugen ‚Üí **Verbindungsflut**.
* `client.release()` vergessen ‚Üí **Pool ersch√∂pft** (H√§nger).
* Zu hohes `max` ‚Üí Server thrashen (zu viele gleichzeitige Queries).
* PgBouncer im *transaction pooling* mit **Session-State** (z. B. `SET LOCAL`, Temp-Tables) kombinieren ‚Üí unerwartetes Verhalten.

---

**Zusammenfassung:**
Connection Pooling h√§lt eine begrenzte Anzahl wiederverwendbarer Verbindungen und reduziert Verbindungs-Overhead. In Node.js nutzt man einen **zentralen `Pool` aus `pg`**, gibt bei Transaktionen denselben Client weiter und released ihn zuverl√§ssig. F√ºr viele App-Instanzen empfiehlt sich zus√§tzlich **PgBouncer**.

üìñ **Quellen:**

* [Node-Postgres (`pg`) ‚Äì Pool](https://node-postgres.com/features/pooling)
* [PostgreSQL Docs ‚Äì libpq / Verbindungen](https://www.postgresql.org/docs/current/libpq-connect.html)
* [Express.js Offizielle Doku](https://expressjs.com/de/)
* [PostgreSQL Performance-Tipps](https://www.postgresql.org/docs/current/performance-tips.html)


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

61. ### <a name="61"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

62. ### <a name="62"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

63. ### <a name="63"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

64. ### <a name="64"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

65. ### <a name="65"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

66. ### <a name="66"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

67. ### <a name="67"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

68. ### <a name="68"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

69. ### <a name="69"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

70. ### <a name="70"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

71. ### <a name="71"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

72. ### <a name="72"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

73. ### <a name="73"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

74. ### <a name="74"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

75. ### <a name="75"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

76. ### <a name="76"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

77. ### <a name="77"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

78. ### <a name="78"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

79. ### <a name="79"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

80. ### <a name="80"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

81. ### <a name="81"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

82. ### <a name="82"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

83. ### <a name="83"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

84. ### <a name="84"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

85. ### <a name="85"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

86. ### <a name="86"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

87. ### <a name="87"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

88. ### <a name="88"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

89. ### <a name="89"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

90. ### <a name="90"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

91. ### <a name="91"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

92. ### <a name="92"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

93. ### <a name="93"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

94. ### <a name="94"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

95. ### <a name="95"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

96. ### <a name="96"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

97. ### <a name="97"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

98. ### <a name="98"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

99. ### <a name="99"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

100. ### <a name="100"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**    

101. ### <a name="101"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

102. ### <a name="102"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

103. ### <a name="103"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

104. ### <a name="104"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

105. ### <a name="105"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

106. ### <a name="106"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

107. ### <a name="107"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

108. ### <a name="108"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

109. ### <a name="109"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

110. ### <a name="110"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

111. ### <a name="111"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

112. ### <a name="112"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

113. ### <a name="113"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

114. ### <a name="114"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

115. ### <a name="115"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

116. ### <a name="116"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

117. ### <a name="117"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

118. ### <a name="118"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

119. ### <a name="119"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

120. ### <a name="120"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

121. ### <a name="121"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

122. ### <a name="122"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

123. ### <a name="123"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

124. ### <a name="124"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

125. ### <a name="125"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

126. ### <a name="126"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

127. ### <a name="127"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

128. ### <a name="128"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

129. ### <a name="129"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

130. ### <a name="130"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

131. ### <a name="131"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

132. ### <a name="132"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

133. ### <a name="133"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

134. ### <a name="134"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

135. ### <a name="135"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

136. ### <a name="136"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

137. ### <a name="137"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

138. ### <a name="138"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

139. ### <a name="139"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

140. ### <a name="140"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

141. ### <a name="141"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

142. ### <a name="142"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

143. ### <a name="143"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

144. ### <a name="144"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

145. ### <a name="145"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

146. ### <a name="146"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

147. ### <a name="147"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

148. ### <a name="148"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

149. ### <a name="149"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

150. ### <a name="150"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

151. ### <a name="151"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

152. ### <a name="152"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

153. ### <a name="153"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

154. ### <a name="154"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

155. ### <a name="155"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

156. ### <a name="156"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

157. ### <a name="157"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

158. ### <a name="158"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

159. ### <a name="159"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

160. ### <a name="160"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

161. ### <a name="161"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

162. ### <a name="162"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

163. ### <a name="163"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

164. ### <a name="164"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

165. ### <a name="165"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

166. ### <a name="166"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

167. ### <a name="167"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

168. ### <a name="168"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

169. ### <a name="169"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

170. ### <a name="170"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

171. ### <a name="171"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

172. ### <a name="172"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

173. ### <a name="173"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

174. ### <a name="174"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

175. ### <a name="175"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

176. ### <a name="176"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

177. ### <a name="177"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

178. ### <a name="178"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

179. ### <a name="179"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

180. ### <a name="180"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

181. ### <a name="181"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

182. ### <a name="182"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

183. ### <a name="183"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

184. ### <a name="184"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

185. ### <a name="185"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

186. ### <a name="186"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

187. ### <a name="187"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

188. ### <a name="188"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

189. ### <a name="189"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

190. ### <a name="190"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

191. ### <a name="191"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

192. ### <a name="192"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

193. ### <a name="193"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

194. ### <a name="194"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

195. ### <a name="195"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

196. ### <a name="196"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

197. ### <a name="197"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

198. ### <a name="198"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

199. ### <a name="199"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

200. ### <a name="200"></a> 



  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**      
