<a name="top"></a>

[На главную](../README.md)

[Перейти к вопросам](#questions)

| №. | Вопрос |
| --- | --------- |
|   | Основы JavaScript  |
|100 | [Различие между null и undefined](#100) |
|101 | [Переменные let, const, var. Cтрогий режим](#101) |
|102 | [Классификация типов данных, приведение типов](#102) |
|103 | [Общение с пользователем: alert(), prompt(), confirm()](#103) |
|104 | [Интерполяция (ES6)](#104) |
|105 | [Операторы в JS](#105) |
|106 | [Условия](#106) |
|107 | [Циклы, Цикл в цикле, метки](#107) |
|108 | [Функции, стрелочные ф-ции, IIFE](#108) |
|109 | [Функции привязки контекста (call, apply, bind)](#109) |
|110 | [Замыкание](#110) |
|111 | [Методы и свойства строк и чисел](#111) |
|112 | [Callback- функции](#112) |
|113 | [Объекты, деструктуризация объектов (ES6)](#113) |
|134 | [Методы Object, Object.prototype](#134) |
|114 | [Способы создания объекта](#114) |
|115 | [Копирование объекты?](#115) |
|116 | [Массивы и псевдомассивы, деструктуризация массивов](#116) |
|135 | [Методы Array, Array.prototype](#135) |
|117 | [Копирование массивов](#117) |
|118 | [Private and protected свойства Оььекта](#118) |
|119 | [Spread оператор (ES6-ES9)](#119) |
|120 | [Rest оператор и параметры по умолчанию (ES6)](#120) |
|121 | [Контекст выполнения. Лексическое окружение](#121) |
|122 | [Контекст выполнения. Лексическое окружение](#122) |
|123 | [События и их обработчики](#123) |
|124 | [Async, defer, динамические скрипты](#124) |
|125 | [typeof - как определить тип значения?](#125) |
|126 | [Почему у переменных примитивного типа данных есть методы? Что такое Autoboxing?](#126) |
|127 | [Сборщик мусора в JS?](#127) |
|128 | [Временная мертвая зона](#128) |
|129 | [Всплытие событий, event bubbling](#129) |
|130 | [Делегирование событий](#130) |
|131 | [Hoisting - Поднятие](#131) |
|132 | [Глобальный объект window](#132) |
|133 | [import/export syntax(ES6 Modules) & CommonJS](#133) |
|136 | [Зная разницу между классом и объектом. Различие между прототипическим и классическим наследованием](#136) |
|137 | [Что такое функциональное программирование? Основы функционального программирования (функция первого класса, функция высшего порядка, лямбда-функции, неизменяемость данных, ленивое вычисление, рекурсия, чистые функции)](#137) |
|138 | [Живые коллекции](#138) |
|139 | [Symbol](#139) |
|140 | [Дескрипторы свойств обьектов](#140) |
|141 | [Итерируемые конструкции](#141) |
|142 | [BigInt](#142) |
|143 | [](#143) |
|144 | [](#144) |
|145 | [](#145) |
|146 | [](#146) |
|147 | [](#147) |
|   | JavaScript в работе  |
|201 | [Получение элементов со страницы](#201) |
|202 | [Действия с элементами на странице](#202) |
|203 | [Навигация по DOM - элементам](#203) |
|204 | [Способы получения DOM-элементов в JS](#204) |
|205 | [DOM-дерево (устройство, селекторы)](#205) |
|206 | [ClassList, ClassName и делегирование событий](#206) |
|207 | [](#207) |
|208 | [Работа с датами](#208) |
|209 | [](#209) |
|210 | [Параметры документа, окна и работа с ними](#210) |
|211 | [](#211) |
|212 | [Разница между событиеми load и DOMContentLoaded](#212) |
|213 | [Создаем табы в новом проекте](#213) |
|214 | [Создаем таймер обратного отсчета на сайте](#214) |
|215 | [Создаем модальное окно](#215) |
|216 | [Создаем слайдер на сайте](#216) |
|217 | [Создаем калькулятор на сайте](#217) |
|218 | [](#218) |
|219 | [](#219) |
|220 | [](#220) |
|   | Продвинутый JavaScript |
|300 | [Функции-конструкторы](#300) |
|301 | [Контекст вызова. This](#301) |
|302 | [Классы (ES6)](#302)  |
|303 | [Наследование классов. Private, protected свойства](#303) |
|304 | [setTimeout и setInterval скрипты и время их выполнения](#304) |
|305 | [JSON](#305) |
|306 | [AJAX и XMLHttpRequest (общение с сервером)](#306) |
|307 | [Promise (ES6)](#307) |
|308 | [Promise](#308) |
|309 | [Fetch API](#309) |
|310 | [Async/Await (ES8)](#310) |
|311 | [try catch, выдача throw](#311) |
|312 | [Библиотека Axios](#312) |
|313 | [Получение данных с сервера. Async/Await. Создание карточек меню. Forms](#313) |
|314 | [Регулярные выражения RegExp](#314) |
|315 | [Web Animations API](#315) |
|316 | [Геттеры и сеттеры (свойства объектов)](#316) |
|317 | [Инкапсуляция](#317) |
|318 | [Функции-генераторы](#318) |
|319 | [JS анимации, requestAnimationFrame](#319) |
|320 | [Event loop, подробная работа асинхронных и синхронных операций](#320) |
|321 | [Что такое Set, Map, WeakSet и WeakMap?](#321) |
|700 | [Map, Set](#700) |
|322 | [Прототипы, цепочка прототипов](#322) |
|323 | [Прототипы, Object.create()](#323) |
|324 | [Длительный опрос как работает](#324) |
|325 | [Web Socket](#325) |
|326 | [Способы отправки запроса на сервер](#326) |
|327 | [Минификация](#327) |
|328 | [Что такое web workers и зачем они нам нужны?](#328) |
|329 | [Typescript или flow](#329) |
|330 | [Рекурсия](#330) |
|331 | [](#331) |
|332 | [](#332) |


<a name="questions"></a>

  **[⬆ Наверх](#top)**	
  
100. ## <a name="100"></a> Различие между null и undefined

В JavaScript, null и undefined представляют отсутствие значения, но они имеют некоторые различия:

- undefined означает, что переменная была объявлена, но ей не было присвоено значение. Это значение по умолчанию для объявленных переменных, если им явно не присвоено другое значение. Пример:

  ```javascript
  let x;
  console.log(x); // Выводит undefined
  ```

- null используется для явного указания отсутствия значения. Он может быть присвоен переменной, чтобы показать, что она не имеет никакого значения или отсутствует. Пример:

  ```javascript
  let y = null;
  console.log(y); // Выводит null
  ```

- undefined также может быть возвращено, когда функция не возвращает явное значение. Также, если вы обратитесь к несуществующему свойству объекта или индексу массива, будет возвращено undefined. Примеры:

  ```javascript
  function doSomething() {
    // Здесь нет явного возврата значения
  }

  console.log(doSomething()); // Выводит undefined

  let obj = {};
  console.log(obj.nonExistentProperty); // Выводит undefined
  ```

Обычно, если вы хотите указать, что значение переменной отсутствует или неизвестно, лучше использовать null. Undefined обычно возникает сам по себе при отсутствии явного значения.

  **[⬆ Наверх](#top)**		
	
	
101. ## <a name="101"></a> Переменные let, const, var. Cтрогий режим

В JavaScript есть три основных способа объявления переменных: `let`, `const` и `var`. Вот их основные отличия:

1. `let`: Переменная, объявленная с помощью `let`, имеет блочную область видимости. Это означает, что она доступна только внутри блока, в котором она была объявлена (например, внутри фигурных скобок `{}`). Повторное объявление переменной с помощью `let` внутри одного и того же блока вызовет ошибку. Пример:

   ```javascript
   let x = 5;
   if (true) {
     let x = 10;
     console.log(x); // Выводит 10
   }
   console.log(x); // Выводит 5
   ```

2. `const`: Переменная, объявленная с помощью `const`, также имеет блочную область видимости. Однако, её значение не может быть изменено после присвоения. Попытка перезаписи переменной, объявленной с помощью `const`, вызовет ошибку. `const` также требует, чтобы переменная была инициализирована при объявлении. Пример:

   ```javascript
   const y = 7;
   // y = 10; // Ошибка: Нельзя перезаписать переменную, объявленную с помощью const
   ```

3. `var`: Переменная, объявленная с помощью `var`, имеет функциональную область видимости или область видимости всего скрипта (если объявлена вне функции). Переменная `var` также поднимается (hoisting), что означает, что она может быть использована до своего фактического объявления в коде. Это может привести к неожиданным результатам. `var` можно переобъявлять и перезаписывать. Пример:

   ```javascript
   var z = 3;
   if (true) {
     var z = 6;
     console.log(z); // Выводит 6
   }
   console.log(z); // Выводит 6
   ```

Обычно рекомендуется использовать `let` и `const` для объявления переменных, так как они обеспечивают более предсказуемое и безопасное поведение. Использование `var` стоит избегать из-за его неочевидного поведения поднятия и области видимости.


### Строгий режим

`Строгий режим` (strict mode) в JavaScript - это специальный режим работы, который предназначен для усиления семантики языка и включения дополнительных проверок при выполнении кода. Включение строгого режима помогает избежать некоторых ошибок и улучшить общую надежность кода.

Для включения строгого режима необходимо добавить директиву `"use strict";` в начало скрипта или функции. Когда строгий режим включен, выполняются следующие изменения в поведении JavaScript:

1. Запрещены неявные глобальные переменные: Если переменная не объявлена с помощью ключевых слов `var`, `let` или `const`, будет выброшена ошибка.

2. Запрещено переопределение переменных: Повторное объявление переменных с одним и тем же именем приведет к ошибке.

3. Запрещено удаление переменных, функций или объявлений функций: Попытка удалить объявление приведет к ошибке.

4. Запрещено удаление переменных и параметров функции: Удаление переменных или параметров функции вызовет ошибку.

5. `this` имеет значение `undefined` в глобальной области видимости и в функциях, вызванных без контекста.

6. Запрещено использование слов, зарезервированных для будущих версий ECMAScript: Некоторые идентификаторы, которые зарезервированы для будущих версий стандарта ECMAScript, запрещены в строгом режиме.

Использование строгого режима рекомендуется, так как он помогает избежать некоторых распространенных ошибок и приводит к более чистому и предсказуемому поведению JavaScript-кода.

  **[⬆ Наверх](#top)**	
	
102. ## <a name="102"></a> Классификация типов данных, приведение типов

В JavaScript существует несколько основных типов данных. Они могут быть классифицированы следующим образом:

1. Примитивные типы данных:
   - Число (number): целые числа и числа с плавающей точкой.
   - Строка (string): последовательность символов, заключенная в кавычки (одинарные или двойные).
   - Булев тип (boolean): может быть только два значения - `true` (истина) или `false` (ложь).
   - undefined: значение, присвоенное переменной, которой не было назначено другое значение.
   - null: отсутствие значения или явное указание на отсутствие объекта.
   - Symbol: уникальный и неизменяемый тип данных, введенный в ECMAScript 6.

2. Объекты (Objects): Составные типы данных, которые могут содержать свойства и методы.
   - Объекты (Object): набор свойств, каждое из которых имеет имя и значение.
   - Массивы (Array): упорядоченные списки значений, обычно доступные по индексу.
   - Функции (Function): блок кода, который может быть вызван по имени.
   - Даты (Date): представление даты и времени.
   - Регулярные выражения (RegExp): шаблоны для поиска и сопоставления строк.
   - и другие, такие как Map, Set, Promise и т.д.

3. Специальные типы данных:
   - NaN (Not a Number): специальное значение, которое указывает на нечисловое значение.
   - Infinity: специальное значение, представляющее бесконечность.

JavaScript является языком со слабой динамической типизацией, что означает, что переменные могут содержать значения разных типов данных и типы могут быть преобразованы автоматически во время выполнения.

### Приведение типов:

В JavaScript типы данных могут быть преобразованы из одного в другой. Приведение типов может происходить явно или неявно в зависимости от контекста. Вот несколько примеров приведения типов в JavaScript:

1. Явное приведение типов:
   - Преобразование в строку: можно использовать функцию `String()` или метод `toString()`.
   ```javascript
   let number = 42;
   let str = String(number); // явное преобразование в строку
   console.log(str); // выводит "42"
   ```

   - Преобразование в число: можно использовать функцию `Number()` или оператор `+`.
   ```javascript
   let str = "42";
   let number = Number(str); // явное преобразование в число
   console.log(number); // выводит 42
   ```

   - Преобразование в логическое значение: можно использовать функцию `Boolean()`.
   ```javascript
   let value = "Hello";
   let bool = Boolean(value); // явное преобразование в логическое значение
   console.log(bool); // выводит true
   ```

2. Неявное приведение типов:
   - Автоматическое преобразование в строку:
   ```javascript
   let number = 42;
   let str = "The answer is " + number; // неявное преобразование числа в строку
   console.log(str); // выводит "The answer is 42"
   ```

   - Автоматическое преобразование в число:
   ```javascript
   let a = "42";
   let b = "5";
   let sum = a + b; // неявное преобразование строк в числа и сложение
   console.log(sum); // выводит "425"
   ```

   - Автоматическое преобразование в логическое значение:
   ```javascript
   let value = "Hello";
   if (value) {
     console.log("Value is truthy"); // неявное преобразование в логическое значение
   }
   ```

Неявное приведение типов может иногда приводить к неожиданным результатам, поэтому важно быть внимательным при работе с разными типами данных и учитывать их автоматическое преобразование.

  **[⬆ Наверх](#top)**
	
103. ## <a name="103"></a> Общение с пользователем: alert(), prompt(), confirm()

В JavaScript `alert()`, `prompt()` и `confirm()` являются встроенными функциями, предоставляемыми браузером, для взаимодействия с пользователем через модальные окна. Вот их основное назначение:

1. `alert()`: Используется для отображения сообщения в модальном окне с кнопкой "OK". Окно `alert()` блокирует выполнение скрипта до тех пор, пока пользователь не нажмет кнопку "OK" или не закроет окно.

   ```javascript
   alert("Привет, мир!"); // Отображает модальное окно с сообщением "Привет, мир!"
   ```

2. `prompt()`: Используется для отображения модального окна с сообщением, полем ввода и кнопками "OK" и "Отмена". Пользователь может ввести данные в поле ввода и нажать "OK" для передачи значения или "Отмена" для отмены операции. Функция `prompt()` возвращает введенное значение или `null`, если пользователь нажал "Отмена".

   ```javascript
   let name = prompt("Введите ваше имя:"); // Отображает модальное окно с полем ввода
   console.log("Привет, " + name); // Выводит приветствие с введенным именем
   ```

3. `confirm()`: Используется для отображения модального окна с сообщением и кнопками "OK" и "Отмена". Пользователь может выбрать "OK" или "Отмена". Функция `confirm()` возвращает `true`, если пользователь нажал "OK", или `false`, если пользователь нажал "Отмена".

   ```javascript
   let result = confirm("Вы уверены?"); // Отображает модальное окно с сообщением
   if (result) {
     console.log("Пользователь нажал OK");
   } else {
     console.log("Пользователь нажал Отмена");
   }
   ```

Эти функции полезны для взаимодействия с пользователем и получения данных во время выполнения скрипта в браузере. Однако, у них есть некоторые ограничения, и для более сложных взаимодействий может потребоваться использование других методов и средств.

  **[⬆ Наверх](#top)**
	
104. ## <a name="104"></a> Интерполяция (ES6)

Интерполяция в JavaScript - это способ вставки значений переменных или выражений внутри строкового литерала, чтобы формировать новую строку. Интерполяция облегчает создание строк, в которых значения переменных могут быть динамически вставлены. В JavaScript интерполяция выполняется с использованием синтаксиса шаблонных строк.

Синтаксис шаблонных строк выглядит следующим образом:

```javascript
let variable = "значение";
let expression = 2 + 2;

let interpolatedString = `Текст ${variable} и выражение ${expression}`;
```

В примере выше, переменная `variable` и выражение `expression` вставляются внутри строки с помощью `${}`. Значения переменных или выражений будут автоматически преобразованы в строку и вставлены в соответствующие места внутри шаблонной строки.

Пример использования интерполяции в JavaScript:

```javascript
let name = "Alice";
let age = 25;

let message = `Привет, меня зовут ${name} и мне ${age} лет.`;
console.log(message); // Выводит "Привет, меня зовут Alice и мне 25 лет."
```

В этом примере значения переменных `name` и `age` вставляются внутри строки с помощью интерполяции. Результатом будет новая строка, в которой значения переменных будут подставлены в соответствующие места.

Использование интерполяции с шаблонными строками упрощает создание сложных строковых значений, таких как сообщения, запросы или HTML-код, где значения переменных или выражений могут быть легко вставлены на нужных местах.

  **[⬆ Наверх](#top)**
	
105. ## <a name="105"></a> Операторы в JS

JavaScript предоставляет разнообразные операторы для выполнения различных операций с данными. Операторы могут быть классифицированы в несколько категорий:

1. Арифметические операторы:
   - `+` (сложение): складывает два значения.
   - `-` (вычитание): вычитает одно значение из другого.
   - `*` (умножение): умножает два значения.
   - `/` (деление): делит одно значение на другое.
   - `%` (остаток от деления): возвращает остаток от деления двух значений.
   - `++` (инкремент): увеличивает значение на 1.
   - `--` (декремент): уменьшает значение на 1.

```javascript
let a = 5;
let b = 2;

let sum = a + b; // 7
let difference = a - b; // 3
let product = a * b; // 10
let quotient = a / b; // 2.5
let remainder = a % b; // 1

let increment = ++a; // 6
let decrement = --b; // 1
```

2. Операторы присваивания:
   - `=` (присваивание): присваивает значение правого операнда левому операнду.
   - `+=`, `-=`, `*=`, `/=`, `%=` и т.д. (составные операторы присваивания): выполняют операцию и присваивают результат левому операнду.

```javascript
let x = 10;

x += 5; // x = x + 5; // 15
x -= 3; // x = x - 3; // 12
x *= 2; // x = x * 2; // 24
x /= 4; // x = x / 4; // 6

```

3. Операторы сравнения:
   - `==` (равно): проверяет равенство двух значений.
   - `!=` (не равно): проверяет неравенство двух значений.
   - `===` (строго равно): проверяет равенство значений и типов данных.
   - `!==` (строго не равно): проверяет неравенство значений или типов данных.
   - `>` (больше), `<` (меньше), `>=` (больше или равно), `<=` (меньше или равно): сравнивают числовые значения.

```javascript
let a = 5;
let b = 3;

console.log(a == b); // false
console.log(a != b); // true
console.log(a === "5"); // false (сравнение значения и типа данных)
console.log(a !== "5"); // true (сравнение значения или типа данных)
console.log(a > b); // true
console.log(a < b); // false
console.log(a >= 5); // true
console.log(b <= 3); // true

```

4. Логические операторы:
   - `&&` (логическое И): возвращает `true`, если оба операнда истинны.
   - `||` (логическое ИЛИ): возвращает `true`, если хотя бы один из операндов истинен.
   - `!` (логическое НЕ): инвертирует значение операнда.

```javascript
let x = 5;
let y = 10;

console.log(x > 0 && y > 0); // true
console.log(x > 0 || y < 0); // true
console.log(!(x > 0)); // false

```

5. Побитовые операторы:
   - `&` (побитовое И): выполняет побитовую операцию И над двумя операндами.
   - `|` (побитовое ИЛИ): выполняет побитовую операцию ИЛИ над двумя операндами.
   - `^` (побитовое исключающее ИЛИ): выполняет побитовую операцию исключающего ИЛИ над двумя операндами.
   - `~` (побитовое НЕ): инвертирует каждый бит операнда.
   - `<<` (побитовый сдвиг влево), `>>` (п

```javascript
let a = 5;
let b = 3;

console.log(a & b); // 1 (побитовое И)
console.log(a | b); // 7 (побитовое ИЛИ)
console.log(a ^ b); // 6 (побитовое исключающее ИЛИ)
console.log(~a); // -6 (побитовое НЕ)
console.log(a << 1); // 10 (побитовый сдвиг влево на 1 бит)
console.log(b >> 1); // 1 (побитовый сдвиг вправо на 1 бит)
```
	

### Оператор объединения с null '??'

В JavaScript существует оператор объединения с null, который называется "Nullish Coalescing Operator" (??). Он используется для выбора значения из двух операндов, основываясь на их определенности (не равно null или undefined).

Синтаксис оператора объединения с null выглядит следующим образом:

```javascript
let result = a ?? b;
```

Значение переменной `result` будет равно `a`, если `a` не равно null или undefined. В противном случае, если `a` равно null или undefined, то значение переменной `result` будет равно `b`.

Примеры использования оператора объединения с null:

```javascript
let username = null;
let defaultUsername = "Гость";

let finalUsername = username ?? defaultUsername;
console.log(finalUsername); // Выводит "Гость"

let count = 0;
let defaultCount = 10;

let finalCount = count ?? defaultCount;
console.log(finalCount); // Выводит 0 (так как count не равно null или undefined)
```

В первом примере, значение переменной `username` равно null, поэтому оператор ?? выбирает значение `defaultUsername` и присваивает его переменной `finalUsername`.

Во втором примере, значение переменной `count` равно 0, которое не является null или undefined, поэтому оператор ?? присваивает значение переменной `count` переменной `finalCount`.

Оператор объединения с null особенно полезен, когда требуется выбрать значение по умолчанию, если первичное значение равно null или undefined.

### Опциональная цепочка '?.'
	
Опциональная цепочка, также известная как оператор "опционального доступа" или "оператор безопасной навигации", в JavaScript обозначается символом "?." и используется для безопасного доступа к свойствам и методам объектов, когда предыдущие свойства могут быть null или undefined.

Синтаксис оператора опциональной цепочки выглядит следующим образом:

```javascript
obj?.prop        // Доступ к свойству obj.prop, если obj не равно null или undefined
obj?.[expr]      // Доступ к свойству obj[expr], если obj не равно null или undefined
obj?.method()    // Вызов метода obj.method(), если obj не равно null или undefined
arr?.[index]     // Доступ к элементу arr[index], если arr не равно null или undefined
```

Оператор "?." проверяет, является ли объект, к которому применяется, null или undefined. Если объект не равен null или undefined, то доступ к свойству или методу осуществляется как обычно. Если же объект равен null или undefined, то оператор "?." возвращает значение undefined, и дальнейший доступ к свойству или вызов метода не происходит.

Пример использования оператора опциональной цепочки:

```javascript
let user = {
  name: "John",
  address: {
    city: "New York"
  }
};

console.log(user?.name); // Выводит "John"
console.log(user?.address?.city); // Выводит "New York"
console.log(user?.age); // Выводит undefined, так как свойства "age" нет у объекта "user"

let arr = [1, 2, 3];
console.log(arr?.[1]); // Выводит 2
console.log(arr?.[5]); // Выводит undefined, так как индекс 5 выходит за границы массива
```

В первом примере, оператор "?." безопасно обращается к свойствам объекта `user` и извлекает значение свойства `name` и `address.city`.

Во втором примере, оператор "?." используется для безопасного доступа к элементам массива `arr`. При доступе к несуществующему индексу, возвращается значение undefined.

Оператор опциональной цепочки облегчает работу с объектами, особенно при манипуляции со сложными структурами данных, где могут возникать ситуации с отсутствующими значениями.
	
### В JavaScript существуют бинарный плюс (+) и унарный плюс (+), которые имеют различные назначения и поведение.

1. Бинарный плюс (+):
   Бинарный плюс выполняет сложение двух операндов. Если оба операнда являются числами, то происходит их сложение. Если хотя бы один операнд не является числом, то происходит конкатенация строк. Если один из операндов является строкой, а другой - числом, то число приводится к строке, и выполняется конкатенация.

   Примеры:
   ```javascript
   let a = 5;
   let b = 10;
   let c = "Hello";
   let d = " world";

   let sum = a + b; // 15
   let concat = c + d; // "Hello world"
   let mix = a + c; // "5Hello"
   ```

2. Унарный плюс (+):
   Унарный плюс преобразует операнд в число, если это возможно. Если операнд уже является числом, то результат остается неизменным. Если операнд не является числом или не может быть преобразован в число, то результатом будет значение NaN (Not a Number).

   Примеры:
   ```javascript
   let num1 = 5;
   let num2 = "10";
   let num3 = "abc";

   let result1 = +num1; // 5
   let result2 = +num2; // 10
   let result3 = +num3; // NaN
   ```

Унарный и бинарный плюс имеют различное поведение и применяются в разных ситуациях. Бинарный плюс используется для сложения чисел или конкатенации строк, в то время как унарный плюс используется для преобразования операнда в число.

  **[⬆ Наверх](#top)**
	
106. ## <a name="106"></a> Условия
	
Число 0, пустая строка "", null, undefined и NaN становятся false. Из-за этого их называют «ложными» («falsy») значениями.

Остальные значения становятся true, поэтому их называют «правдивыми» («truthy»).	

В JavaScript условия используются для выполнения различных блоков кода в зависимости от условия, которое может быть истинным (true) или ложным (false). Условия в JavaScript реализуются с помощью оператора `if`, операторов сравнения (`==`, `===`, `!=`, `!==`, `>`, `<`, `>=`, `<=`) и логических операторов (`&&`, `||`, `!`).

Пример использования условий в JavaScript:

```javascript
let x = 5;

if (x > 0) {
  console.log("Число положительное");
} else if (x < 0) {
  console.log("Число отрицательное");
} else {
  console.log("Число равно нулю");
}
```

В этом примере условие `x > 0` проверяется с помощью оператора `if`. Если оно истинно, то выполняется блок кода внутри фигурных скобок после `if`. Если условие ложно, то проверяется следующее условие `x < 0` с помощью оператора `else if`. Если оно истинно, то выполняется соответствующий блок кода. Если оба условия ложны, то выполняется блок кода внутри `else`.

Кроме того, можно использовать логические операторы для комбинирования условий:

```javascript
let age = 25;
let hasDriverLicense = true;

if (age >= 18 && hasDriverLicense) {
  console.log("Вы можете водить автомобиль");
} else {
  console.log("Вы не можете водить автомобиль");
}
```

В этом примере условие `age >= 18 && hasDriverLicense` проверяет, что возраст `age` больше или равен 18 и у пользователя есть водительские права. Если оба условия истинны, то выводится сообщение о возможности вождения автомобиля. В противном случае выводится сообщение о невозможности вождения.

Также в JavaScript можно использовать тернарный оператор для написания более краткого кода условий:

```javascript
let isEven = x % 2 === 0 ? true : false;
```

В этом примере тернарный оператор `x % 2 === 0 ? true : false` проверяет, является ли число `x` четным. Если условие истинно, то переменной `isEven` присваивается значение `true`, в противном случае - `false`.

Условия в JavaScript позволяют создавать гибкие и мощные конструкции для контроля выполнения кода в зависимости от определенных условий.

### Switch

switch работает только со строгим сравнением и switch так же работает со строками

Оператор `switch` в JavaScript используется для выполнения различных действий в зависимости от значения выражения. Он позволяет сравнивать выражение со списком возможных значений и выполнять соответствующий блок кода для соответствующего совпадения.

Синтаксис оператора `switch` выглядит следующим образом:

```javascript
switch (выражение) {
  case значение1:
    // блок кода, выполняемый при совпадении с значение1
    break;
  case значение2:
    // блок кода, выполняемый при совпадении с значение2
    break;
  // другие case
  default:
    // блок кода, выполняемый, если ни одно значение не совпало
}
```

Оператор `switch` выполняет следующие действия:
1. Оценивает выражение.
2. Сравнивает значение выражения с каждым `case` (значением).
3. Если значение совпадает с `case`, выполняется соответствующий блок кода.
4. Если совпадение найдено, выполнение продолжается после `switch` (если не указан оператор `break`).
5. Если ни одно значение не совпадает, выполняется блок кода `default` (если он указан).

Пример использования оператора `switch`:

```javascript
let day = 2;
let dayName;

switch (day) {
  case 1:
    dayName = "Понедельник";
    break;
  case 2:
    dayName = "Вторник";
    break;
  case 3:
    dayName = "Среда";
    break;
  case 4:
    dayName = "Четверг";
    break;
  case 5:
    dayName = "Пятница";
    break;
  default:
    dayName = "Выходной";
}

console.log(dayName); // Выводит "Вторник"
```

В этом примере переменная `day` равна 2. Оператор `switch` сравнивает значение `day` со значениями каждого `case`. Поскольку значение `day` равно 2, выполняется блок кода соответствующий `case 2`, и переменной `dayName` присваивается значение "Вторник". Затем выводится значение переменной `dayName`.

Оператор `switch` удобен, когда требуется проверить одно значение на равенство с несколькими возможными значениями и выполнить соответствующий код.

  **[⬆ Наверх](#top)**
	
107. ### <a name="107"></a> Циклы, Цикл в цикле, метки

В JavaScript существуют различные конструкции для реализации циклов, включая `for`, `while` и `do...while` циклы. Циклы позволяют выполнять определенный блок кода несколько раз до выполнения определенного условия.

1. Цикл `for`:
   Цикл `for` используется для выполнения циклического кода с определенным количеством итераций.

   Пример:
   ```javascript
   for (let i = 0; i < 5; i++) {
     console.log(i);
   }
   ```

2. Цикл `while`:
   Цикл `while` выполняет блок кода до тех пор, пока указанное условие истинно.

   Пример:
   ```javascript
   let i = 0;
   while (i < 5) {
     console.log(i);
     i++;
   }
   ```

3. Цикл `do...while`:
   Цикл `do...while` похож на цикл `while`, но он сначала выполняет блок кода, а затем проверяет условие.

   Пример:
   ```javascript
   let i = 0;
   do {
     console.log(i);
     i++;
   } while (i < 5);
   ```

Циклы могут быть вложенными, то есть один цикл может находиться внутри другого. Такой подход называется "цикл в цикле" или "вложенный цикл". Вложенные циклы полезны для обработки сложных структур данных или выполнения многократных операций.

Пример вложенного цикла:
```javascript
for (let i = 0; i < 3; i++) {
  for (let j = 0; j < 3; j++) {
    console.log(`i: ${i}, j: ${j}`);
  }
}
```

В JavaScript также можно использовать метки (лейблы) для управления циклами и выполнением операций с определенными условиями. Метка - это идентификатор, предшествующий оператору цикла или условию. Они используются в сочетании с операторами `break` и `continue`.

Пример использования метки:
```javascript
outerLoop: for (let i = 0; i < 3; i++) {
  for (let j = 0; j < 3; j++) {
    if (i === 1 && j === 1) {
      break outerLoop; // Прерывает выполнение внешнего цикла по метке
    }
    console.log(`i: ${i}, j: ${j}`);
  }
}
```

В этом примере оператор `break` с меткой `outerLoop` прерывает выполнение внешнего цикла, когда `i` и `j` равны 1.

Метки не являются обязательными и в большинстве случаев можно обойтись без них. Однако, в некоторых ситуациях они могут быть полезны для более точного управления потоком выполнения программы.			 
		       
  **[⬆ Наверх](#top)**
		       
108. ### <a name="108"></a> Функции, стрелочные ф-ции, IIFE

В JavaScript функции играют важную роль, они являются основными строительными блоками программы. Функции в JavaScript могут быть объявлены с помощью ключевого слова `function` или в виде стрелочных функций (arrow functions).

В JavaScript существуют два основных способа объявления функций: "Function Declaration" (объявление функции) и "Function Expression" (функциональное выражение).

1. Function Declaration (объявление функции):
   Функции, объявленные с использованием синтаксиса "Function Declaration", могут быть вызваны перед их объявлением в коде.

   Пример:
   ```javascript
   function greet(name) {
     console.log(`Привет, ${name}!`);
   }
   greet("Алиса"); // Выводит "Привет, Алиса!"
   ```

   В этом примере функция `greet` объявлена с использованием ключевого слова `function`, а затем вызывается с передачей аргумента "Алиса".

2. Function Expression (функциональное выражение):
   Функциональные выражения создают функцию как часть выражения и могут быть присвоены переменной или переданы в качестве аргумента другой функции.

   Примеры:
   ```javascript
   // Анонимное функциональное выражение
   const greet = function(name) {
     console.log(`Привет, ${name}!`);
   };
   greet("Алиса"); // Выводит "Привет, Алиса!"

   // Именованное функциональное выражение
   const square = function multiply(num) {
     return num * num;
   };
   console.log(square(5)); // Выводит 25
   ```

   В этом примере функция `greet` является анонимной функцией, объявленной как часть выражения и присвоенной переменной `greet`. Функция `square` также является функциональным выражением и имеет имя `multiply`, которое может быть использовано внутри функции для рекурсивного вызова.

Оба способа объявления функций имеют свои особенности и используются в разных ситуациях. Function Declarations особенно удобны, когда необходимо иметь возможность вызывать функцию до ее объявления в коде, в то время как Function Expressions полезны при присваивании функций переменным или передаче их в качестве аргументов других функций.

3. Стрелочные функции (arrow functions):
   Стрелочные функции представляют сокращенный синтаксис для объявления функций. Они используют стрелку (`=>`) для указания тела функции.

   Примеры:
   ```javascript
   // Без параметров
   const sayHello = () => {
     console.log("Привет!");
   };
   sayHello(); // Выводит "Привет!"

   // С одним параметром
   const double = (num) => {
     return num * 2;
   };
   console.log(double(5)); // Выводит 10

   // С несколькими параметрами
   const add = (a, b) => a + b;
   console.log(add(3, 4)); // Выводит 7
   ```

   В стрелочных функциях тело функции может быть указано в одной строке без явного использования оператора `return`, если оно состоит из одного выражения.

4. IIFE (Immediately Invoked Function Expression):
   IIFE представляет собой функцию, которая вызывается немедленно после своего объявления. Она позволяет создавать локальные области видимости и изолировать переменные от глобальной области видимости.

   Пример:
   ```javascript
   (function() {
     let name = "Алиса";
     console.log(`Привет, ${name}!`);
   })();
   ```

   В этом примере функция объявлена внутри скобок и сразу вызывается. Таким образом, код внутри функции выполнится немедленно.

Функции в JavaScript являются мощным инструментом и могут быть использованы для организации и повторного использования кода, а стрелочные функции и IIFE предоставляют более компактный и удобный синтаксис для определения функций и выполнения кода.

  **[⬆ Наверх](#top)**
	
	
109. ### <a name="109"></a> Функции привязки контекста (call, apply, bind)

В JavaScript существуют методы `call`, `apply` и `bind`, которые позволяют управлять контекстом выполнения функций.

1. Метод `call`:
   Метод `call` вызывает функцию с указанным контекстом и передает аргументы в виде отдельных аргументов функции.

   Пример использования `call`:
   ```javascript
   function greet() {
     console.log(`Привет, ${this.name}!`);
   }

   const person = { name: "Алиса" };
   greet.call(person); // Выводит "Привет, Алиса!"
   ```

   В этом примере функция `greet` вызывается с контекстом `person` с помощью метода `call`. Внутри функции `this` будет ссылаться на объект `person`.

2. Метод `apply`:
   Метод `apply` работает аналогично методу `call`, но аргументы передаются в виде массива.

   Пример использования `apply`:
   ```javascript
   function greet(message) {
     console.log(`${message}, ${this.name}!`);
   }

   const person = { name: "Алиса" };
   greet.apply(person, ["Привет"]); // Выводит "Привет, Алиса!"
   ```

   В этом примере метод `apply` используется для вызова функции `greet` с контекстом `person` и аргументом "Привет".

3. Метод `bind`:
   Метод `bind` создает новую функцию, связанную с указанным контекстом. Он не вызывает функцию, а возвращает новую функцию с привязанным контекстом.

   Пример использования `bind`:
   ```javascript
   function greet() {
     console.log(`Привет, ${this.name}!`);
   }

   const person = { name: "Алиса" };
   const greetPerson = greet.bind(person);
   greetPerson(); // Выводит "Привет, Алиса!"
   ```

   В этом примере `bind` используется для создания новой функции `greetPerson`, которая имеет привязку к контексту `person`. При вызове `greetPerson` будет выводиться приветствие с именем "Алиса".

Методы `call`, `apply` и `bind` предоставляют гибкость в управлении контекстом выполнения функций. `call` и `apply` позволяют немедленно вызывать функцию с указанным контекстом, а `bind` создает новую функцию с постоянной привязкой к контексту. Эти методы особенно полезны при работе с объектами и использовании функций в различных контекстах.

  **[⬆ Наверх](#top)**
	
	
110. ### <a name="110"></a> Замыкание

Замыкание (closure) в JavaScript - это комбинация функции и лексического окружения, в котором эта функция была объявлена. Замыкание позволяет функции сохранять доступ к переменным из своего внешнего окружения, даже после того, как это окружение было завершено.

Пример замыкания:
```javascript
function outer() {
  let message = "Привет";

  function inner() {
    console.log(message);
  }

  return inner;
}

const closureFunc = outer();
closureFunc(); // Выводит "Привет"
```

В этом примере функция `outer` определяет переменную `message` и возвращает вложенную функцию `inner`. Когда `outer` вызывается и присваивается переменной `closureFunc`, она сохраняет доступ к переменной `message` из своего внешнего окружения. Поэтому при вызове `closureFunc` выводится значение "Привет".

Замыкания особенно полезны в следующих случаях:
- Создание приватных переменных и функций, которые не могут быть доступны извне.
- Сохранение состояния между вызовами функции.
- Работа с функциями обратного вызова (callback) и асинхронными операциями.

Замыкания помогают в создании гибких и мощных конструкций в JavaScript, позволяя функциям сохранять и использовать данные из своих внешних контекстов.

  **[⬆ Наверх](#top)**
	
	
111. ### <a name="111"></a> Методы и свойства строк и чисел

В JavaScript строки (String) и числа (Number) являются встроенными типами данных и имеют свои методы и свойства, которые можно использовать для работы с ними.

Методы строк (String):

1. `length`: Возвращает длину строки.

   ```javascript
   const str = "Привет";
   console.log(str.length); // Выводит 6
   ```

2. `toUpperCase()`: Преобразует все символы строки в верхний регистр.

   ```javascript
   const str = "привет";
   console.log(str.toUpperCase()); // Выводит "ПРИВЕТ"
   ```

3. `toLowerCase()`: Преобразует все символы строки в нижний регистр.

   ```javascript
   const str = "ПРИВЕТ";
   console.log(str.toLowerCase()); // Выводит "привет"
   ```

4. `charAt(index)`: Возвращает символ в указанной позиции (индексе) строки.

   ```javascript
   const str = "Hello";
   console.log(str.charAt(1)); // Выводит "e"
   ```
Конечно! Вот еще несколько распространенных методов для работы со строками в JavaScript:

5. `concat(str1, str2, ..., strN)`: Объединяет две или более строк и возвращает новую строку.

   ```javascript
   const str1 = "Hello";
   const str2 = "World";
   console.log(str1.concat(" ", str2)); // Выводит "Hello World"
   ```

6. `slice(startIndex, endIndex)`: Извлекает часть строки от `startIndex` до `endIndex` (не включая) и возвращает новую строку.

   ```javascript
   const str = "JavaScript";
   console.log(str.slice(0, 4)); // Выводит "Java"
   console.log(str.slice(4)); // Выводит "Script"
   ```

7. `substring(startIndex, endIndex)`: Извлекает часть строки от `startIndex` до `endIndex` (не включая) и возвращает новую строку. Поддерживает отрицательные индексы.

   ```javascript
   const str = "JavaScript";
   console.log(str.substring(0, 4)); // Выводит "Java"
   console.log(str.substring(4)); // Выводит "Script"
   ```

8. `indexOf(searchValue, startIndex)`: Возвращает индекс первого вхождения `searchValue` в строку, начиная с индекса `startIndex`. Если не найдено, возвращает -1.

   ```javascript
   const str = "Hello, World";
   console.log(str.indexOf("o")); // Выводит 4
   console.log(str.indexOf("o", 5)); // Выводит 8
   ```

9. `startsWith(searchValue)`: Проверяет, начинается ли строка с `searchValue`. Возвращает `true` или `false`.

   ```javascript
   const str = "Hello, World";
   console.log(str.startsWith("Hello")); // Выводит true
   console.log(str.startsWith("World")); // Выводит false
   ```

10. `endsWith(searchValue)`: Проверяет, заканчивается ли строка на `searchValue`. Возвращает `true` или `false`.

   ```javascript
   const str = "Hello, World";
   console.log(str.endsWith("World")); // Выводит true
   console.log(str.endsWith("Hello")); // Выводит false
   ```

11. `replace(searchValue, replaceValue)`: Заменяет все вхождения `searchValue` на `replaceValue` и возвращает новую строку.

   ```javascript
   const str = "Hello, World";
   console.log(str.replace("Hello", "Hi")); // Выводит "Hi, World"
   ```

12. `trim()`: Удаляет пробельные символы в начале и конце строки и возвращает новую строку.

   ```javascript
   const str = "   Hello, World   ";
   console.log(str.trim()); // Выводит "Hello, World"
   ```

13. `split(separator)`: Разбивает строку на массив подстрок, используя `separator` в качестве разделителя.

   ```javascript
   const str = "Hello, World";
   console.log

    (str.split(", ")); // Выводит ["Hello", "World"]
   ```

Это лишь несколько примеров методов для работы со строками в JavaScript. С помощью этих методов и других, вы можете выполнять различные операции со строками, такие как поиск, замена, разбиение на подстроки и многое другое.

### Методы чисел (Number):

1. `toFixed(digits)`: Округляет число до указанного количества десятичных знаков и возвращает строку.

   ```javascript
   const num = 3.14159;
   console.log(num.toFixed(2)); // Выводит "3.14"
   ```

2. `toString()`: Преобразует число в строку.

   ```javascript
   const num = 42;
   console.log(num.toString()); // Выводит "42"
   ```

3. `toPrecision(precision)`: Форматирует число с указанной точностью и возвращает строку.

   ```javascript
   const num = 123.456;
   console.log(num.toPrecision(4)); // Выводит "123.5"
   ```

4. `toString(base)`: Преобразует число в строку с указанной системой счисления (`base`). По умолчанию используется десятичная система.

   ```javascript
   const num = 42;
   console.log(num.toString()); // Выводит "42"
   console.log(num.toString(2)); // Выводит "101010" (двоичное представление)
   console.log(num.toString(16)); // Выводит "2a" (шестнадцатеричное представление)
   ```

5. `parseInt(string, radix)`: Преобразует строку в целое число. Второй аргумент `radix` указывает систему счисления (от 2 до 36). Если `radix` не указан, то предполагается десятичная система.

   ```javascript
   const str = "10";
   console.log(parseInt(str)); // Выводит 10
   console.log(parseInt("1010", 2)); // Выводит 10 (двоичное число)
   ```

6. `parseFloat(string)`: Преобразует строку в число с плавающей запятой.

   ```javascript
   const str = "3.14";
   console.log(parseFloat(str)); // Выводит 3.14
   ```

7. `isNaN(value)`: Проверяет, является ли значение не числом (NaN). Возвращает `true` или `false`.

   ```javascript
   console.log(isNaN(42)); // Выводит false
   console.log(isNaN("Hello")); // Выводит true
   ```

8. `isFinite(value)`: Проверяет, является ли значение конечным числом. Возвращает `true` или `false`.

   ```javascript
   console.log(isFinite(42)); // Выводит

    true
    console.log(isFinite(Infinity)); // Выводит false
   ```

Обратите внимание, что строки являются неизменяемыми (immutable), поэтому большинство методов возвращают новую строку, а не изменяют исходную. Числа, в свою очередь, являются примитивами и не имеют методов, но JavaScript автоматически оборачивает их в объекты-обертки для использования методов.
	
  **[⬆ Наверх](#top)**
	
	
112. ### <a name="112"></a> Callback - функции

Callback-функции в JavaScript - это функции, которые передаются в качестве аргументов в другие функции и вызываются внутри этих функций. Они используются для реализации асинхронного и событийного программирования, где функция должна быть вызвана по завершении определенной операции или события.

Пример использования callback-функций:

```javascript
function doSomething(callback) {
  // Выполняется некоторая операция
  // ...

  // По завершении операции вызываем callback-функцию
  callback();
}

function callbackFunction() {
  console.log("Callback выполнен!");
}

// Передаем callback-функцию в doSomething
doSomething(callbackFunction);
```

В этом примере функция `doSomething` принимает `callback` в качестве аргумента и вызывает его по завершении операции. Внутри `doSomething` может быть любая асинхронная операция, например, чтение файла или выполнение запроса к серверу.

Callback-функции могут также принимать аргументы и передавать им значения. Например:

```javascript
function calculate(num1, num2, callback) {
  const result = num1 + num2;
  callback(result);
}

function displayResult(result) {
  console.log("Результат: " + result);
}

calculate(5, 10, displayResult); // Выводит "Результат: 15"
```

В этом примере функция `calculate` принимает два числа `num1` и `num2`, выполняет вычисление и передает результат в `callback`. Функция `displayResult` принимает результат и выводит его.

Использование callback-функций позволяет создавать гибкие и многопоточные программы в JavaScript, обрабатывать асинхронные задачи и реагировать на события.
	
  **[⬆ Наверх](#top)**

	
113. ### <a name="113"></a> Объекты, деструктуризация объектов (ES6)

В JavaScript объекты - это коллекции свойств, которые содержат пары ключ-значение. Они позволяют организовывать и структурировать данные.

Создание объекта:

```javascript
const person = {
  name: "John",
  age: 30,
  profession: "Developer"
};
```

Доступ к свойствам объекта можно получить с помощью оператора точки (`.`) или оператора квадратных скобок (`[]`):

```javascript
console.log(person.name); // Выводит "John"
console.log(person["age"]); // Выводит 30
```

Деструктуризация объектов позволяет извлечь значения свойств объекта и присвоить их переменным:

```javascript
const { name, age, profession } = person;

console.log(name); // Выводит "John"
console.log(age); // Выводит 30
console.log(profession); // Выводит "Developer"
```

Деструктуризация объектов позволяет удобно извлекать только нужные свойства из объекта, что облегчает чтение и использование данных.

Также можно использовать деструктуризацию при объявлении параметров функции:

```javascript
function displayPersonInfo({ name, age }) {
  console.log(`Имя: ${name}`);
  console.log(`Возраст: ${age}`);
}

displayPersonInfo(person); // Выводит информацию о персоне
```

В этом примере мы передаем объект `person` в функцию `displayPersonInfo`, и используем деструктуризацию параметра функции, чтобы получить доступ к свойствам объекта.

Деструктуризацию объектов также можно комбинировать с значениями по умолчанию:

```javascript
const { name, age, profession = "Unknown" } = person;

console.log(profession); // Выводит "Developer" (значение из объекта)
```

В этом примере, если свойство `profession` отсутствует в объекте `person`, то будет использовано значение по умолчанию "Unknown".

Деструктуризация объектов - мощный инструмент, который делает работу с объектами более удобной и понятной, позволяя получить доступ к нужным данным и использовать их в коде.
	
  **[⬆ Наверх](#top)**
	
134. ### <a name="134"></a> Методы Object, Object.prototype

В JavaScript, `Object` является встроенным объектом, который предоставляет ряд методов и свойств для работы с объектами.

Некоторые методы `Object`:

0. Метод `Object.create()` в JavaScript используется для создания нового объекта с указанным прототипом.

Синтаксис метода `Object.create()` выглядит следующим образом:

```javascript
Object.create(proto[, propertiesObject])
```

- `proto`: Объект, который будет использоваться в качестве прототипа нового объекта.
- `propertiesObject` (необязательный): Объект, определяющий дескрипторы свойств нового объекта.

Пример использования метода `Object.create()`:

```javascript
const person = {
  greet: function() {
    console.log(`Hello, my name is ${this.name}`);
  }
};

const john = Object.create(person);
john.name = "John";
john.greet(); // Выводит "Hello, my name is John"
```

В приведенном примере мы создаем объект `person`, который содержит метод `greet()`. Затем с помощью метода `Object.create()` мы создаем новый объект `john`, используя `person` в качестве прототипа. Затем мы добавляем свойство `name` к объекту `john` и вызываем метод `greet()`, который наследуется от прототипа `person`.

Метод `Object.create()` позволяет создавать объекты, которые наследуют свойства и методы от других объектов, служащих в качестве прототипа. Это предоставляет гибкость и возможность организации наследования в JavaScript.


1. `Object.keys(obj)`: Возвращает массив из строковых ключей всех перечисляемых свойств объекта `obj`.

   ```javascript
   const person = {
     name: "John",
     age: 30,
     profession: "Developer"
   };

   console.log(Object.keys(person)); // Выводит ["name", "age", "profession"]
   ```

2. `Object.values(obj)`: Возвращает массив из значений всех перечисляемых свойств объекта `obj`.

   ```javascript
   console.log(Object.values(person)); // Выводит ["John", 30, "Developer"]
   ```

3. `Object.entries(obj)`: Возвращает массив, содержащий массивы из пар ключ-значение всех перечисляемых свойств объекта `obj`.

   ```javascript
   console.log(Object.entries(person));
   // Выводит [["name", "John"], ["age", 30], ["profession", "Developer"]]
   ```

4. `Object.assign(target, ...sources)`: Копирует значения всех перечисляемых свойств из одного или нескольких исходных объектов (`sources`) в целевой объект (`target`) и возвращает измененный целевой объект.

   ```javascript
   const obj1 = { a: 1, b: 2 };
   const obj2 = { c: 3, d: 4 };

   const mergedObj = Object.assign(obj1, obj2);
   console.log(mergedObj); // Выводит { a: 1, b: 2, c: 3, d: 4 }
   ```

5. `Object.freeze(obj)`: Замораживает объект `obj`, делая его свойства неподдающимися изменению. Новые свойства не могут быть добавлены, существующие свойства не могут быть изменены или удалены.

   ```javascript
   const obj = { a: 1, b: 2 };
   Object.freeze(obj);

   obj.c = 3; // Игнорируется
   delete obj.a; // Игнорируется

   console.log(obj); // Выводит { a: 1, b: 2 }
   ```

6. `Object.getOwnPropertyNames(obj)`: Возвращает массив, содержащий имена всех свойств объекта `obj`, включая не перечисляемые свойства.

   ```javascript
   const person = {
     name: "John",
     age: 30
   };

   Object.defineProperty(person, "profession", {
     value: "Developer",
     enumerable: false // Делаем свойство не перечисляемым
   });

   const propertyNames = Object.getOwnPropertyNames(person);
   console.log(propertyNames); // Выводит ["name", "age", "profession"]
   ```

7. `Object.getPrototypeOf(obj)`: Возвращает прототип (сверхкласс) объекта `obj`.

   ```javascript
   const person = { name: "John" };
   const prototype = Object.getPrototypeOf(person);
   console.log(prototype); // Выводит {}
   ```

8. `Object.hasOwnProperty(prop)`: Проверяет, содержит ли объект собственное свойство с именем `prop`.

   ```javascript
   const person = { name: "John" };

   console.log(person.hasOwnProperty("name")); // Выводит true
   console.log(person.hasOwnProperty("age")); // Выводит false
   ```


`Object.prototype` - это прототипный объект, который является прототипом для всех объектов JavaScript. Он содержит методы и свойства, доступные для всех объектов JavaScript.

Некоторые методы `Object.prototype`:

1. `Object.prototype.hasOwnProperty(prop)`: Проверяет, содержит ли объект собственное свойство с именем `prop`.

   ```javascript
   console.log(person.hasOwnProperty("name")); // Выводит true
   console.log(person.hasOwnProperty("country")); // Выводит false
   ```

2. `Object.prototype.toString()`: Возвращает строковое представление объекта.

   ```javascript
   console.log(person.toString()); // Выводит "[object Object]"
   ```

3. `Object.prototype.hasOwnProperty()`: Позволяет добавить новое свойство или изменить существующее свойство объекта.

   ```javascript
   person.country = "USA";
   console.log(person); // Выводит {name: "John", age: 30, profession: "Developer", country: "USA"}
   ```

4. `Object.prototype.constructor`: Ссылка на функцию-конструктор, которая создала объект.

   ```javascript
   console.log(person.constructor); // Выводит Object()
   ```

Методы `Object` и свойства `Object.prototype` предоставляют удобные возможности для работы с объектами в JavaScript, включая получение ключей, значений и запись новых свойств.

  **[⬆ Наверх](#top)**	
	
114. ### <a name="114"></a> Способы создания объекта

В JavaScript существует несколько способов создания объектов. Вот некоторые из них:

1. Литерал объекта: Создание объекта с помощью фигурных скобок `{}` и указания свойств и их значений.

   ```javascript
   const person = {
     name: "John",
     age: 30,
     profession: "Developer"
   };
   ```

2. Конструктор объекта: Использование конструктора `Object` для создания пустого объекта, а затем добавление свойств и их значений.

   ```javascript
   const person = new Object();
   person.name = "John";
   person.age = 30;
   person.profession = "Developer";
   ```

3. Создание объекта с помощью конструктора функции: Определение функции-конструктора и использование оператора `new` для создания нового экземпляра объекта.

   ```javascript
   function Person(name, age, profession) {
     this.name = name;
     this.age = age;
     this.profession = profession;
   }

   const person = new Person("John", 30, "Developer");
   ```

4. `Object.create()`: Использование метода `Object.create()` для создания нового объекта с указанным прототипом.

   ```javascript
   const person = {
     greet: function() {
       console.log(`Hello, my name is ${this.name}`);
     }
   };

   const john = Object.create(person);
   john.name = "John";
   john.greet(); // Выводит "Hello, my name is John"
   ```

Это только некоторые из способов создания объектов в JavaScript. Выбор метода создания объекта зависит от конкретных требований и стиля кодирования.

  **[⬆ Наверх](#top)**
	
115. ### <a name="115"></a> Копирование объектов

В JavaScript копирование объектов может быть немного сложным из-за особенностей работы с ссылочными типами данных. Вот несколько способов копирования объектов:

1. Поверхностное копирование (shallow copy) с использованием оператора распространения (`...`):

   ```javascript
   const obj = { name: "John", age: 30 };
   const copy = { ...obj };
   ```

   В этом случае `copy` будет новым объектом, который содержит те же свойства и значения, что и `obj`. Однако, если у `obj` есть вложенные объекты, то они будут ссылаться на одни и те же объекты в обоих копии.

2. Клонирование с использованием метода `Object.assign()`:

   ```javascript
   const obj = { name: "John", age: 30 };
   const copy = Object.assign({}, obj);
   ```

   Этот метод также создает поверхностную копию объекта `obj`. Он копирует свойства из `obj` в новый пустой объект `{}`. Подобно оператору распространения, этот метод не делает глубокое копирование для вложенных объектов.

3. Глубокое копирование (deep copy) с использованием метода `JSON.parse()` и `JSON.stringify()`:

   ```javascript
   const obj = { name: "John", age: 30 };
   const copy = JSON.parse(JSON.stringify(obj));
   ```

   Этот метод создает полную копию объекта `obj`, включая все вложенные объекты. Он сериализует объект в строку с помощью `JSON.stringify()`, а затем разбирает его обратно в новый объект с помощью `JSON.parse()`. Однако, следует учитывать, что этот метод не будет работать с функциями и некоторыми специальными типами данных, которые не могут быть сериализованы в JSON.

   Обратите внимание, что эти методы копирования создают независимую копию объекта на первом уровне (поверхностное копирование), но не для вложенных объектов. Если вам нужно глубокое копирование со всеми вложенными объектами, то может потребоваться использование дополнительных методов или библиотек, таких как `lodash.cloneDeep()`.

   Важно также отметить, что при копировании объектов с методами, ссылки на функции не будут скопированы, и копия объекта будет ссылаться на те же функции, что и оригинальный объект.

https://medium.com/@stasonmars/%D0%BA%D0%BE%D0%BF%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2-%D0%B2-javascript-d25c261a7aff

  **[⬆ Наверх](#top)**
	
116. ## <a name="116"></a> Массивы и псевдомассивы, деструктуризация массивов

В JavaScript массивы являются объектами, которые содержат упорядоченную коллекцию элементов. Вот некоторая информация о массивах и деструктуризации массивов в JavaScript:

1. Создание массива:

   ```javascript
   const fruits = ["apple", "banana", "orange"];
   ```

   В этом примере мы создаем массив `fruits`, содержащий три элемента.

2. Доступ к элементам массива:

   ```javascript
   console.log(fruits[0]); // Выводит "apple"
   console.log(fruits[1]); // Выводит "banana"
   console.log(fruits[2]); // Выводит "orange"
   ```

   Индексы массива начинаются с 0, поэтому `fruits[0]` обращается к первому элементу массива.

3. Длина массива:

   ```javascript
   console.log(fruits.length); // Выводит 3
   ```

   Свойство `length` возвращает количество элементов в массиве.

4. Деструктуризация массивов:

   ```javascript
   const fruits = ["apple", "banana", "orange"];
   const [first, second, third] = fruits;

   console.log(first); // Выводит "apple"
   console.log(second); // Выводит "banana"
   console.log(third); // Выводит "orange"
   ```

   В этом примере мы используем деструктуризацию массива, чтобы присвоить каждому элементу массива `fruits` соответствующую переменную.

5. Оставшиеся элементы (Rest):

   ```javascript
   const fruits = ["apple", "banana", "orange", "mango"];
   const [first, ...rest] = fruits;

   console.log(first); // Выводит "apple"
   console.log(rest); // Выводит ["banana", "orange", "mango"]
   ```

   С помощью оператора `...` (rest) мы можем присвоить оставшиеся элементы массива переменной `rest`.

6. Пропуск элементов:

   ```javascript
   const fruits = ["apple", "banana", "orange", "mango"];
   const [, second, , fourth] = fruits;

   console.log(second); // Выводит "banana"
   console.log(fourth); // Выводит "mango"
   ```

   Путем использования запятых без переменных, мы можем пропустить определенные элементы массива.

Деструктуризация массивов позволяет нам извлекать элементы массива и присваивать их переменным с помощью синтаксиса сопоставления с образцом. Это удобный способ получения доступа к элементам массива и выполнения операций на них.


### Псевдомассивы

`Псевдомассив` - обьект структура которого совпадает со структурой массива, он будет выглядеть точно так же как массив
одно условие, у таких псевдомассивов не будет вообще никаких методов(не forEach, не filter, не push и pop и join...)
это просто струтура которая хранить данные по порядку.

В JavaScript термин "псевдомассив" используется для описания объектов, которые выглядят и ведут себя как массивы, но фактически не являются экземплярами класса `Array`. Обычно псевдомассивы похожи на массивы в том смысле, что у них есть числовые индексы и свойство `length`, но они не обладают встроенными методами массивов, такими как `push()`, `pop()`, `forEach()` и другими.

Примером псевдомассивов являются объекты, которые имеют числовые индексы и свойство `length`, но не являются массивами. Например, результаты, возвращаемые некоторыми методами DOM, такими как `querySelectorAll()`, `getElementsByTagName()` и другими, представляют собой псевдомассивы.

Вот пример использования псевдомассива:

```javascript
const nodeList = document.querySelectorAll("li"); // возвращает псевдомассив NodeList

console.log(nodeList.length); // Выводит количество элементов в NodeList

console.log(nodeList[0]); // Выводит первый элемент из NodeList

nodeList.forEach(function(item) {
  console.log(item.textContent); // Выводит текстовое содержимое каждого элемента
});
```

Хотя псевдомассивы не обладают методами массивов, можно преобразовать их в настоящие массивы, используя методы массивов, такие как `Array.from()` или оператор расширения массива `[...pseudоArray]`. Это позволяет применять стандартные методы массивов к этим объектам. Например:

```javascript
const realArray = Array.from(pseudoArray);
// или
const realArray = [...pseudoArray];
```

Теперь `realArray` является настоящим экземпляром класса `Array` с доступными методами массивов.


Чтобы пройтись по элементам массива:

- for (let i=0; i<arr.length; i++) – работает быстрее всего, совместим со старыми браузерами.
- for (let item of arr) – современный синтаксис только для значений элементов (к индексам нет доступа).
- for (let i in arr) – никогда не используйте для массивов!	

Оператор `for` в JavaScript используется для создания циклов и выполнения повторяющихся операций определенное количество раз.

Синтаксис оператора `for` выглядит следующим образом:

```javascript
for (инициализация; условие; выражение_после_итерации) {
  // Блок кода, выполняемый на каждой итерации
}
```

Оператор `for` состоит из трех частей:

1. `инициализация`: Выполняется перед началом цикла и обычно используется для объявления и инициализации переменной счетчика цикла.

2. `условие`: Определяет условие, при котором цикл будет продолжаться. Если условие вычисляется в `true`, цикл выполняется. Если условие вычисляется в `false`, цикл прекращается.

3. `выражение_после_итерации`: Выполняется после каждой итерации цикла и обычно используется для изменения значения переменной счетчика или других переменных.

Примеры использования оператора `for`:

1. Перебор элементов массива:

   ```javascript
   const array = [1, 2, 3, 4, 5];

   for (let i = 0; i < array.length; i++) {
     console.log(array[i]);
   }
   // Вывод:
   // 1
   // 2
   // 3
   // 4
   // 5
   ```

2. Генерация чисел в заданном диапазоне:

   ```javascript
   for (let i = 1; i <= 10; i++) {
     console.log(i);
   }
   // Вывод:
   // 1
   // 2
   // 3
   // 4
   // 5
   // 6
   // 7
   // 8
   // 9
   // 10
   ```

3. Пропуск итераций с помощью условия:

   ```javascript
   for (let i = 1; i <= 10; i++) {
     if (i % 2 === 0) {
       continue; // Пропускаем четные числа
     }
     console.log(i);
   }
   // Вывод:
   // 1
   // 3
   // 5
   // 7
   // 9
   ```

4. Прерывание цикла с помощью условия:

   ```javascript
   for (let i = 1; i <= 10; i++) {
     if (i === 5) {
       break; // Прерываем цикл при i равном 5
     }
     console.log(i);
   }
   // Вывод:
   // 1
   // 2
   // 3
   // 4
   ```

Оператор `for` предоставляет гибкую возможность для создания циклов и повторения операций в JavaScript

. Можно использовать его для перебора элементов массивов, генерации числовых последовательностей, выполнения определенных действий и многого другого.

Оператор `for...of` в JavaScript используется для перебора элементов итерируемых объектов, таких как массивы, строки, наборы и другие.

Синтаксис оператора `for...of` выглядит следующим образом:

```javascript
for (variable of iterable) {
  // Блок кода, выполняемый для каждого элемента
}
```

В каждой итерации цикла переменная `variable` принимает значение текущего элемента из `iterable`. Затем выполняется блок кода внутри цикла для каждого элемента в итерируемом объекте.

Примеры использования оператора `for...of`:

1. Перебор элементов массива:

   ```javascript
   const array = [1, 2, 3, 4, 5];

   for (let element of array) {
     console.log(element);
   }
   // Вывод:
   // 1
   // 2
   // 3
   // 4
   // 5
   ```

2. Перебор символов строки:

   ```javascript
   const str = "Hello";

   for (let char of str) {
     console.log(char);
   }
   // Вывод:
   // H
   // e
   // l
   // l
   // o
   ```

3. Перебор элементов Map:

   ```javascript
   const map = new Map();
   map.set("name", "John");
   map.set("age", 30);

   for (let [key, value] of map) {
     console.log(`${key}: ${value}`);
   }
   // Вывод:
   // name: John
   // age: 30
   ```

   В этом примере используется деструктуризация массива `[key, value]` для получения ключа и значения из каждой записи Map.

Оператор `for...of` обеспечивает более простой и наглядный способ перебора элементов в итерируемых объектах, по сравнению с использованием индексов или методов перебора, таких как `forEach` или `map`.

  **[⬆ Наверх](#top)**

			       
135. ## <a name="135"></a> Методы Array

JavaScript предоставляет множество методов для работы с массивами. Вот несколько часто используемых методов:

1. `push()`: Добавляет один или несколько элементов в конец массива и возвращает новую длину массива.

   ```javascript
   const fruits = ["apple", "banana"];
   fruits.push("orange", "mango");
   ```

2. `pop()`: Удаляет последний элемент из массива и возвращает его значение.

   ```javascript
   const fruits = ["apple", "banana", "orange"];
   const lastFruit = fruits.pop();
   ```

3. `shift()`: Удаляет первый элемент из массива и возвращает его значение. Остальные элементы смещаются влево.

   ```javascript
   const fruits = ["apple", "banana", "orange"];
   const firstFruit = fruits.shift();
   ```

4. `unshift()`: Добавляет один или несколько элементов в начало массива и возвращает новую длину массива.

   ```javascript
   const fruits = ["banana", "orange"];
   fruits.unshift("apple", "mango");
   ```

5. `concat()`: Объединяет два или более массивов и возвращает новый массив.

   ```javascript
   const fruits = ["apple", "banana"];
   const moreFruits = ["orange", "mango"];
   const allFruits = fruits.concat(moreFruits);
   ```

6. `slice()`: Возвращает новый массив, содержащий выбранные элементы из исходного массива.

   ```javascript
   const fruits = ["apple", "banana", "orange", "mango"];
   const citrus = fruits.slice(1, 3); // Возвращает новый массив ["banana", "orange"]
   ```

7. `forEach()`: Выполняет указанную функцию один раз для каждого элемента массива.

   ```javascript
   const fruits = ["apple", "banana", "orange"];
   fruits.forEach(function(fruit) {
     console.log(fruit);
   });
   ```

8. `map()`: Создает новый массив, содержащий результат вызова указанной функции для каждого элемента исходного массива.

   ```javascript
   const numbers = [1, 2, 3];
   const doubledNumbers = numbers.map(function(number) {
     return number * 2;
   });
   ```

9. `filter()`: Создает новый массив, содержащий все элементы исходного массива, для которых указанная функция возвращает `true`.

   ```javascript
   const numbers = [1, 2, 3, 4, 5];
   const evenNumbers = numbers.filter(function(number) {
     return number % 2 === 0;
   });
   ```

10. `reduce()`: Применяет функцию к аккумулятору и каждому элементу массива (слева направо), возвращая одно значение.

    ```javascript
    const numbers = [1, 2, 3, 4, 5];
    const sum = numbers.reduce(function(acc, number) {
      return acc + number;
    }, 0);
    ```

11. `some()`: Проверяет, удовлетворяет ли хотя бы один элемент массива условию, заданному в функции. Возвращает `true`, если хотя бы один элемент удовлетворяет условию, и `false` в противном случае.

   ```javascript
   const numbers = [1, 2, 3, 4, 5];
   const hasEvenNumber = numbers.some(function(number) {
     return number % 2 === 0;
   });
   ```

12. `every()`: Проверяет, удовлетворяют ли все элементы массива условию, заданному в функции. Возвращает `true`, если все элементы удовлетворяют условию, и `false` в противном случае.

   ```javascript
   const numbers = [1, 2, 3, 4, 5];
   const allNumbersGreaterThanZero = numbers.every(function(number) {
     return number > 0;
   });
   ```

	
https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array

https://learn.javascript.ru/array-methods

  **[⬆ Наверх](#top)**			       
	
	
117. ## <a name="117"></a> Копирование массивов

В JavaScript есть несколько способов копирования массивов. Однако при копировании массивов нужно учитывать, что сам массив является объектом, и некоторые методы копирования могут поведение ссылки на объект, а не создание нового независимого массива. Вот некоторые способы копирования массивов:

1. Создание поверхностной копии с помощью `slice()`:

   ```javascript
   const originalArray = [1, 2, 3];
   const copiedArray = originalArray.slice();
   ```

2. Создание копии с помощью оператора расширения массива:

   ```javascript
   const originalArray = [1, 2, 3];
   const copiedArray = [...originalArray];
   ```

3. Создание копии с помощью `Array.from()`:

   ```javascript
   const originalArray = [1, 2, 3];
   const copiedArray = Array.from(originalArray);
   ```

4. Создание глубокой копии с помощью `JSON.parse()` и `JSON.stringify()`:

   ```javascript
   const originalArray = [1, 2, 3];
   const copiedArray = JSON.parse(JSON.stringify(originalArray));
   ```

   Обратите внимание, что этот способ работает только для простых массивов, содержащих примитивные значения или объекты, которые могут быть сериализованы в JSON. Он не сохраняет некоторые специальные типы данных, такие как функции или регулярные выражения.

   Например:

   ```javascript
   const originalArray = [1, 2, { name: "John" }];
   const copiedArray = JSON.parse(JSON.stringify(originalArray));
   ```

5. Использование методов копирования, таких как `concat()` или `Array.from()` в сочетании с модификацией массива:

   ```javascript
   const originalArray = [1, 2, 3];
   const copiedArray = [].concat(originalArray);
   // или
   const copiedArray = Array.from(originalArray);
   ```

Важно отметить, что эти методы выполняют поверхностное копирование массива, то есть они копируют ссылки на объекты внутри массива. Если массив содержит вложенные объекты, то изменения в этих объектах будут отражаться как в оригинальном, так и в скопированном массиве. Для создания глубокой копии массива с вложенными объектами необходимо использовать специализированные методы или библиотеки.

  **[⬆ Наверх](#top)**
	
	
118. ## <a name="118"></a> Private and protected свойства Обьекта

В JavaScript нет встроенной поддержки для явного объявления private и protected свойств объекта, как в некоторых других языках программирования. Однако есть несколько подходов, которые можно использовать для имитации такого поведения.

1. Использование соглашения именования: Один из распространенных подходов - использование соглашения именования для указания, что свойство должно считаться приватным или защищенным. Например, префикс "_" может использоваться для обозначения приватных свойств, а префикс "__" - для защищенных свойств. Это не является фактическим ограничением доступа к свойству, но указывает на то, что оно должно считаться внутренним и не предназначено для прямого доступа извне.

```javascript
function MyClass() {
  // Приватное свойство
  var _privateProperty = "Private";

  // Защищенное свойство
  this.__protectedProperty = "Protected";

  // Публичный метод для доступа к приватному свойству
  this.getPrivateProperty = function() {
    return _privateProperty;
  };
}

var obj = new MyClass();
console.log(obj._privateProperty); // undefined (но не настоящая защита)
console.log(obj.__protectedProperty); // "Protected"
console.log(obj.getPrivateProperty()); // "Private"
```

2. Использование замыканий: Замыкания могут быть использованы для создания локальных областей видимости, в которых определены приватные переменные и функции. Приватные свойства и методы могут быть доступны только изнутри замыкания, а не напрямую извне.

```javascript
var obj = (function() {
  // Приватное свойство
  var privateProperty = "Private";

  // Защищенное свойство
  var protectedProperty = "Protected";

  // Приватный метод
  function privateMethod() {
    console.log("Private method");
  }

  // Возвращаемые методы
  return {
    // Публичный метод для доступа к защищенному свойству
    getProtectedProperty: function() {
      return protectedProperty;
    },

    // Публичный метод для вызова приватного метода
    callPrivateMethod: function() {
      privateMethod();
    }
  };
})();

console.log(obj.privateProperty); // undefined (настоящая приватность)
console.log(obj.getProtectedProperty()); // "Protected"
obj.callPrivateMethod(); // "Private method"
```

Оба эти подхода позволяют имитировать приватные и защищенные свойства объекта в JavaScript. Однако они не обеспечивают полной гарантии конфиденциальности и ограничений доступа, так как JavaScript не имеет встроенной поддержки для такого типа модификаторов доступа.
	
  **[⬆ Наверх](#top)**
	
	
119. ## <a name="119"></a> Spread оператор (ES6-ES9)
	
Spread оператор (`...`) в JavaScript используется для разбора (spread) и объединения (spread) элементов в массивах или объектах.

1. Разбор (spread) элементов массива:

   ```javascript
   const array = [1, 2, 3];
   console.log(...array); // 1 2 3
   ```

   Spread оператор разбирает элементы массива и передает их как отдельные аргументы функции или в другой массив.

2. Объединение (spread) массивов:

   ```javascript
   const array1 = [1, 2, 3];
   const array2 = [4, 5, 6];
   const combinedArray = [...array1, ...array2];
   console.log(combinedArray); // [1, 2, 3, 4, 5, 6]
   ```

   Spread оператор может быть использован для объединения элементов из разных массивов в новый массив.

3. Клонирование массива:

   ```javascript
   const array = [1, 2, 3];
   const clonedArray = [...array];
   console.log(clonedArray); // [1, 2, 3]
   ```

   Spread оператор также может быть использован для создания копии (клонирования) массива.

4. Разбор (spread) свойств объекта:

   ```javascript
   const obj = { a: 1, b: 2, c: 3 };
   const { a, ...rest } = obj;
   console.log(a); // 1
   console.log(rest); // { b: 2, c: 3 }
   ```

   Spread оператор может быть использован для разбора свойств объекта и создания нового объекта без определенных свойств.

5. Объединение (spread) свойств объектов:

   ```javascript
   const obj1 = { a: 1, b: 2 };
   const obj2 = { c: 3, d: 4 };
   const combinedObj = { ...obj1, ...obj2 };
   console.log(combinedObj); // { a: 1, b: 2, c: 3, d: 4 }
   ```

   Spread оператор также может быть использован для объединения свойств из разных объектов в новый объект.

Spread оператор позволяет более удобно работать с массивами и объектами, упрощая разбор и объединение элементов. Он широко используется в современном JavaScript для создания краткого и элегантного кода.

  **[⬆ Наверх](#top)**
	
	
120. ## <a name="120"></a> Rest оператор и параметры по умолчанию (ES6)

Rest оператор (`...`) в JavaScript используется для объединения оставшихся аргументов функции в массив или для объединения оставшихся свойств объекта в новый объект.

1. Объединение оставшихся аргументов функции в массив:

   ```javascript
   function sum(...numbers) {
     let total = 0;
     for (let number of numbers) {
       total += number;
     }
     return total;
   }

   console.log(sum(1, 2, 3)); // 6
   console.log(sum(4, 5, 6, 7)); // 22
   ```

   Rest оператор позволяет передавать произвольное количество аргументов в функцию и объединять их в массив `numbers`.

2. Объединение оставшихся свойств объекта в новый объект:

   ```javascript
   const { a, b, ...rest } = { a: 1, b: 2, c: 3, d: 4 };
   console.log(a); // 1
   console.log(b); // 2
   console.log(rest); // { c: 3, d: 4 }
   ```

   Rest оператор используется в деструктуризации объекта для объединения оставшихся свойств (не указанных явно) в новый объект `rest`.

Rest оператор позволяет более гибко работать с аргументами функций и свойствами объектов, обрабатывая их как массивы или новые объекты. Он полезен, когда нам неизвестно точное количество аргументов или свойств, с которыми мы будем работать, и позволяет писать более гибкий и компактный код.

### Параметры по умолчанию
	
Параметры по умолчанию в JavaScript позволяют задать значения по умолчанию для функциональных параметров, которые будут использованы, если аргументы не переданы или имеют значение `undefined`.

1. Задание значения по умолчанию для функционального параметра:

   ```javascript
   function greet(name = "Guest") {
     console.log(`Hello, ${name}!`);
   }

   greet(); // Hello, Guest!
   greet("John"); // Hello, John!
   ```

   В примере выше, если аргумент `name` не передан или имеет значение `undefined`, будет использовано значение по умолчанию "Guest".

2. Использование выражений для значения по умолчанию:

   ```javascript
   function multiply(a, b = a * 2) {
     console.log(a * b);
   }

   multiply(5); // 5 * 10 = 50
   multiply(5, 3); // 5 * 3 = 15
   ```

   В этом примере, если аргумент `b` не передан или имеет значение `undefined`, будет использовано выражение `a * 2` для вычисления значения по умолчанию.

3. Параметры по умолчанию и rest-параметры:

   ```javascript
   function calculateTotal(...prices) {
     let total = 0;
     for (let price of prices) {
       total += price;
     }
     console.log(`Total: ${total}`);
   }

   calculateTotal(10, 20, 30); // Total: 60
   calculateTotal(5, 10); // Total: 15
   calculateTotal(); // Total: 0
   ```

   В данном примере функция `calculateTotal` принимает переменное количество аргументов (`prices`) и суммирует их. Если аргументы не переданы или их количество равно 0, будет использован пустой массив, и общая сумма будет равна 0.

Параметры по умолчанию упрощают работу с функциями, обеспечивая значения по умолчанию для аргументов, которые могут быть необязательными или иметь типичные значения. Они помогают создавать более гибкий и читаемый код.	
	
  **[⬆ Наверх](#top)**
	
121. ### <a name="121"></a> Контекст выполнения. Лексическое окружение

# Контекст выполнения

Контекст выполнения (execution context) - это окружение, в котором выполняется код.

Есть три типа контекстов функции

* Глобальный контекст выполнения. Это базовый, используемый по умолчанию контекст выполнения. Если некий код находится не внутри какой-нибудь функции, значит этот код принадлежит глобальному контексту. Глобальный контекст характеризуется наличием глобального объекта, которым, в случае с браузером, является объект `window`, и тем, что ключевое слово `this` указывает на этот глобальный объект. В программе может быть лишь один глобальный контекст.
* Контекст выполнения функции. Каждый раз, когда вызывается функция, для неё создаётся новый контекст, даже если функция вызывает саму себя (рекурсия). В программе может одновременно присутствовать множество контекстов выполнения функций. При создании нового контекста выполнения функции он проходит через определённую последовательность шагов, о которой мы поговорим ниже.
* Контекст выполнения функции `eval`. Код, выполняемый внутри функции `eval`, также имеет собственный контекст выполнения. Однако функцией `eval` пользуются очень редко, поэтому здесь мы об этом контексте выполнения говорить не будем.

**Стек вызовов** (call stack) или **стек выполнения** (execution stack) - стек для хранения контекстов вызованных функций.

**Стек** - это структура данных, в которой элементы упорядочены так, что последний элемент, который попадает в стек, выходит из него первым (LIFO: last in, first out). Стек похож на стопку книг: та книга, которую мы кладём последней, находится сверху.

Когда JS-движок начинает обрабатывать скрипт, движок создаёт глобальный контекст выполнения и помещает его в текущий стек. При обнаружении команды вызова функции движок создаёт новый контекст выполнения для этой функции и помещает его в верхнюю часть стека.

Движок выполняет функцию, контекст выполнения которой находится в верхней части стека. Когда работа функции завершается, её контекст извлекается из стека и управление передаётся тому контексту, который находится в предыдущем элементе стека.

Перед выполнением JavaScript-кода создаётся контекст выполнения. В процессе его создания выполняются три действия:

1. Определяется значение `this` и осуществляется привязка `this` (this binding).
2. Создаётся компонент `LexicalEnvironment` (лексическое окружение).
3. Создаётся компонент `VariableEnvironment` (окружение переменных).

Концептуально контекст выполнения можно представить так:

```js
ExecutionContext = {
  ThisBinding = <this value>,
  LexicalEnvironment = { ... },
  VariableEnvironment = { ... },
}
```

Жизненный цикл контекста имеет два этапа - этап создания и этап выполнения.

## Привязка this

В глобальном контексте выполнения `this` содержит ссылку на глобальный объект (как уже было сказано, в браузере это объект `window`).

В контексте выполнения функции значение `this` зависит от того, как именно была вызвана функция. Если она вызвана в виде метода объекта, тогда значение `this` привязано к этому объекту. В других случаях `this` привязывается к глобальному объекту или устанавливается в `undefined` (в строгом режиме).

## Лексическое окружение

**Лексическое окружение** - это структура, которая хранит сведения о соответствии идентификаторов и переменных. Под «идентификатором» здесь понимается имя переменной или функции, а под «переменной» - ссылка на конкретный объект (в том числе — на функцию) или примитивное значение.

В лексическом окружении имеется **два компонента**:

1. _Environment Record_ – объект, в котором как свойства хранятся все локальные переменные (а также некоторая другая информация, такая как значение `this`).
2. Ссылка на внешнее окружение. Наличие такой ссылки говорит о том, что у лексического окружения есть доступ к родительскому лексическому окружению (области видимости).

"Переменная" – это просто свойство специального внутреннего объекта: Environment Record. «Получить или изменить переменную», означает, «получить или изменить свойство этого объекта».

Именно из-за формирования записи окружения и выделения памяти под переменные до выполнения кода к ним можно обращаться до их объявления в программе. Такое поведения называется \*\*“всплытие”\*\*или **hoisting**

Однако, важно обратить внимание на то, что для переменных `let` и `const` есть некоторые отличия от `var` переменных в механизме всплытия. Например, если обратиться к переменным `let` и `const` до их объявления, то возникнет ошибка `ReferenceError`, в отличие от переменной `var`, значение которой в таком случае отобразится как `undefined`.

Такая ошибка `ReferenceError` из-за попытки получить или установить значение `let`  или `const` переменной до её объявления называется ошибкой **“Временной мертвой зоны” (Temporal Dead Zone (TDZ) error).**

Временная мертвая зона заканчивается именно тогда, когда **само выполнение кода** доберется до объявления переменной.

```js
console.log(typeof foo); // Uncaught ReferenceError: foo is not defined
console.log(typeof aVariableThatDoesNotExist); // undefined
let foo;
```

В случае с необъявленной переменной `aVariableThatDoesNotExist`, которой не существует, оператор покажет `undefined`. А в случае с объявленной `foo` возникнет ошибка, так как эта переменная объявлена, но запрошена во время действия временной мертвой зоны.

Существует **два типа лексических окружений**:

1. Глобальное окружение (или глобальный контекст выполнения) — это лексическое окружение, у которого нет внешнего окружения. Ссылка глобального окружения на внешнее окружение представлена значением `null`. В глобальном окружении (в записи окружения) доступны встроенные сущности языка (такие, как `Object`, `Array`, и так далее), которые связаны с глобальным объектом, там же находятся и глобальные переменные, определённые пользователем. Значение `this` в этом окружении указывает на глобальный объект.
2. Окружение функции, в котором, в записи окружения, хранятся переменные, объявленные пользователем. Ссылка на внешнее окружение может указывать как на глобальный объект, так и на внешнюю по отношении к рассматриваемой функции функцию.

### Блоки кода

Мы также можем использовать «простые» блоки кода `{...}`, чтобы изолировать переменные в «локальной области видимости».

```js
{
    let foo = 'foo'

    // foo
    console.log(foo)
}

// здесь также будет ошибка
console.log(foo)

{
    let foo = 'foo'
}
```

### **IIFE**

В прошлом в JavaScript не было лексического окружения на уровне блоков кода.

Так что программистам пришлось что-то придумать. И то, что они сделали, называется «immediately-invoked function expressions» (аббревиатура IIFE), что означает функцию, запускаемую сразу после объявления.

Это не то, что мы должны использовать сегодня, но, так как вы можете встретить это в старых скриптах, полезно понимать принцип работы.

```js
(function() {

  let message = "Hello";

  alert(message); // Hello

})();
```

Подробнее: [https://learn.javascript.ru/closure#iife](https://learn.javascript.ru/closure#iife).

## **Окружение переменных**

Окружение переменных (Variable Environment) — это тоже лексическое окружение, запись окружения которого хранит привязки, созданные посредством команд объявления переменных (`VariableStatement`) в текущем контексте выполнения.

Так как окружение переменных также является лексическим окружением, оно обладает всеми вышеописанными свойствами лексического окружения.

В ES6 существует одно различие между компонентами `LexicalEnvironment` и `VariableEnvironment`. Оно заключается в том, что первое используется для хранения объявлений функций и переменных, объявленных с помощью ключевых слов `let` и `const`, а второе — только для хранения привязок переменных, объявленных с использованием ключевого слова `var`.

## Объект arguments

`arguments` - это локальная переменная в любой функции, кроме стрелочных, содержащая параметры функции. Представляет собой итерируемый объект, похожий на массив.

Можно обращаться в параметрам по их индексу, начиная с нуля. Также у объекта есть свойство `length`, которое позволяет определить количество аргументов.

```js
function () {
    console.log(arguments)
}
```

Начиная с ES6 более предпочтительным споособом по сравнению с `arguments` является синтаксис **rest parameters**:

```js
function (...args) {
    console.log(args)
}
```

## Замыкание

**Замыкание** — это комбинация функции и лексического окружения, в котором эта функция была определена. Другими словами, замыкание даёт вам доступ кобласти видимости  внешней функции из внутренней функции. В JavaScript замыкания создаются каждый раз при создании функции, во время её создания.

```js
let name = "John";

function sayHi() {
  alert("Hi, " + name);
}

name = "Pete";

// выведет "Hi, Pete"
sayHi();
```

## Источники

* [https://habr.com/ru/company/ruvds/blog/422089/](https://habr.com/ru/company/ruvds/blog/422089/)
* [https://blog.bitsrc.io/understanding-execution-context-and-execution-stack-in-javascript-1c9ea8642dd0](https://blog.bitsrc.io/understanding-execution-context-and-execution-stack-in-javascript-1c9ea8642dd0)
* [http://jsflow.org/docs/exec-context-fundamentals/](http://jsflow.org/docs/exec-context-fundamentals/)
* [https://developer.mozilla.org/ru/docs/Web/JavaScript/Closures](https://developer.mozilla.org/ru/docs/Web/JavaScript/Closures)


  **[⬆ Наверх](#top)**
	
122. ## <a name="122"></a> Контекст выполнения. Лексическое окружение
	
Контекст выполнения и лексическое окружение в JavaScript тесно связаны и используются для организации и управления выполнением кода.

Контекст выполнения представляет собой среду, в которой выполняется код JavaScript. Он содержит информацию о переменных, функциях, объектах и других ресурсах, доступных во время выполнения кода.

Лексическое окружение - это часть контекста выполнения, которая связывает переменные и функции с их лексическими областями видимости, то есть с местами, где они были определены в исходном коде. Лексическое окружение определяет, какие переменные и функции доступны в текущем контексте выполнения.

Каждый раз, когда функция вызывается, создается новый контекст выполнения, который включает в себя свое собственное лексическое окружение. Контексты выполнения могут быть вложенными, когда одна функция вызывает другую функцию, создавая стек контекстов выполнения.

Лексическое окружение состоит из двух основных компонентов:

1. **Environment Record** (запись окружения): Это место, где переменные и функции сохраняются и доступны в текущем контексте выполнения. Внутри Environment Record хранятся имена переменных и их значения.

2. **Outer Environment Reference** (ссылка на внешнее окружение): Это ссылка на лексическое окружение, связанное с внешней областью видимости текущего контекста выполнения. Она используется для доступа к переменным во внешнем окружении.

Лексическое окружение и контекст выполнения помогают JavaScript определить, какие переменные и функции видимы и доступны в каждом месте кода.

Пример использования лексического окружения и контекста выполнения:

```javascript
function outer() {
  const x = 10;

  function inner() {
    const y = 20;
    console.log(x + y);
  }

  inner();
}

outer();
```

В приведенном примере у нас есть функция `outer()`, которая содержит переменную `x`. Внутри `outer()` определена функция `inner()`, которая имеет свою собственную переменную `y`. При вызове `inner()` будет создан новый контекст выполнения с лексическим окружением, содержащим переменные `x` и `y`. Внутри `inner()` мы можем обратиться и использовать переменные из внешнего окружения `outer()` благодаря связи лексического окружения с внешним окружением.

Таким образом, лексическое окружение и контекст выполнения играют важную роль в определении области видимости переменных и функций в JavaScript, а также обеспечивают правильное управление выполнением кода.
	
  **[⬆ Наверх](#top)**
	
123. ## <a name="123"></a> События и их обработчики

События и их обработчики в JavaScript используются для отслеживания и реагирования на действия пользователя или изменения состояния элементов на веб-странице. 

В JavaScript события представляются объектами, которые содержат информацию о событии, такую как тип события, цель (элемент, на котором произошло событие), данные события и другое. Для обработки событий в JavaScript используются обработчики событий.

Обработчики событий - это функции, которые вызываются при возникновении определенного события. Они связываются с элементом и выполняются в ответ на произошедшее событие.

В JavaScript существует несколько способов привязать обработчики событий к элементам:

1. Использование свойства `on<event>` элемента:
   ```javascript
   const button = document.querySelector('button');
   
   button.onclick = function() {
     console.log('Клик!');
   };
   ```

2. Использование метода `addEventListener()`:
   ```javascript
   const button = document.querySelector('button');
   
   button.addEventListener('click', function() {
     console.log('Клик!');
   });
   ```

   Метод `addEventListener()` позволяет добавить несколько обработчиков событий к одному элементу.

3. Использование атрибута HTML:
   ```html
   <button onclick="handleClick()">Нажми меня</button>
   
   <script>
     function handleClick() {
       console.log('Клик!');
     }
   </script>
   ```

Обработчики событий могут быть функциями, которые определены непосредственно в коде JavaScript, или ссылками на функции, определенные в другом месте.

Примеры типов событий:

- `click`: событие происходит при клике на элементе.
- `mouseover`: событие происходит, когда указатель мыши наводится на элемент.
- `keydown`: событие происходит при нажатии клавиши на клавиатуре.

Обработчики событий позволяют реагировать на взаимодействие пользователя с веб-страницей и выполнять соответствующие действия в JavaScript коде.
	
Для удаления обработчика событий в JavaScript можно использовать метод `removeEventListener()`. Этот метод позволяет удалить ранее привязанный обработчик события из элемента.

Синтаксис метода `removeEventListener()` выглядит следующим образом:

```javascript
element.removeEventListener(eventName, eventHandler);
```

Где:
- `element` - элемент, у которого был добавлен обработчик события.
- `eventName` - тип события, для которого был добавлен обработчик.
- `eventHandler` - ссылка на функцию обработчика события, которую необходимо удалить.

Пример удаления обработчика события:

```javascript
const button = document.querySelector('button');

function handleClick() {
  console.log('Клик!');
}

// Добавление обработчика события
button.addEventListener('click', handleClick);

// Удаление обработчика события
button.removeEventListener('click', handleClick);
```

После вызова метода `removeEventListener()`, обработчик события больше не будет вызываться при возникновении события.

Важно убедиться, что перед вызовом `removeEventListener()` используется та же самая функция обработчика, которая была использована при добавлении обработчика события. Это гарантирует правильное удаление обработчика.

`Объект события` в JavaScript представляет собой объект, содержащий информацию о конкретном событии, произошедшем на элементе. Этот объект передается в обработчик события как параметр и содержит различные свойства и методы, которые можно использовать для работы с событием.

Свойства объекта события могут включать:

- `type`: Тип события.
- `target`: Целевой элемент, на котором произошло событие.
- `currentTarget`: Элемент, на котором в данный момент выполняется обработчик события (может быть предком целевого элемента).
- `eventPhase`: Фаза события (захват, цель, всплытие).
- `timeStamp`: Временная метка события (в миллисекундах).
- `keyCode`: Код клавиши, связанной с событием (для событий клавиатуры).

Методы объекта события могут включать:

- `preventDefault()`: Предотвращает выполнение действия по умолчанию, связанного с событием (например, переход по ссылке при клике).
- `stopPropagation()`: Останавливает дальнейшее всплытие или захват события.
- `stopImmediatePropagation()`: Останавливает дальнейшее всплытие или захват события и предотвращает вызов других обработчиков этого события.

Пример использования объекта события:

```javascript
const button = document.querySelector('button');

button.addEventListener('click', function(event) {
  console.log(event.type); // 'click'
  console.log(event.target); // Целевой элемент, на котором произошло событие
  console.log(event.currentTarget); // Элемент, на котором выполняется обработчик события
  console.log(event.timeStamp); // Временная метка события
  
  event.preventDefault(); // Предотвращение выполнения действия по умолчанию
});
```

Объект события предоставляет контекстную информацию о событии, позволяя разработчикам получать доступ к свойствам и методам, связанным с конкретным событием. Это позволяет более гибко управлять поведением и взаимодействием на веб-странице.

  **[⬆ Наверх](#top)**
	
124. ## <a name="124"></a> Async, defer, динамические скрипты

`async` и `defer` - это атрибуты тега `<script>`, которые позволяют управлять асинхронной загрузкой и выполнением скриптов на веб-странице. Они используются для оптимизации производительности и поведения скриптов.

1. `async`: Атрибут `async` указывает браузеру, что скрипт можно загружать асинхронно, не блокируя загрузку страницы. Когда браузер встречает тег `<script async>`, он начинает загружать скрипт параллельно с загрузкой страницы. При этом скрипт может быть выполнен до того, как страница полностью загрузится. Порядок выполнения скриптов с атрибутом `async` может быть непредсказуемым, поэтому, если порядок выполнения важен, лучше использовать другие методы или атрибут `defer`.

2. `defer`: Атрибут `defer` указывает браузеру, что скрипт должен быть загружен асинхронно, но выполнение скрипта должно быть отложено до тех пор, пока вся страница не будет полностью загружена. Когда браузер встречает тег `<script defer>`, он начинает загружать скрипт параллельно с загрузкой страницы, но откладывает его выполнение до того момента, когда страница будет полностью загружена. Скрипты с атрибутом `defer` выполняются в порядке, в котором они встречаются на странице.

3. Динамические скрипты: В JavaScript также есть возможность динамически создавать и добавлять скрипты на страницу. Для этого можно использовать методы `createElement()` для создания элемента `<script>`, `setAttribute()` для установки атрибутов скрипта, и `appendChild()` для добавления скрипта в DOM. Динамические скрипты позволяют загружать и выполнять скрипты по мере необходимости, например, после определенного события или условия.

Пример использования атрибутов `async` и `defer`:

```html
<script src="script.js" async></script>
<script src="script.js" defer></script>
```

Пример использования динамических скриптов:

```javascript
const script = document.createElement('script');
script.src = 'script.js';
document.body.appendChild(script);
```

Важно заметить, что использование атрибутов `async` и `defer` или динамических скриптов может повлиять на порядок выполнения скриптов и зависимости между ними. Поэтому важно правильно организовывать и управлять загрузкой и выполнением скриптов в зависимости от требований вашего приложения.

https://learn.javascript.ru/script-async-defer

  **[⬆ Наверх](#top)**
	
125. ## <a name="125"></a> typeof

Оператор `typeof` в JavaScript используется для определения типа значения, хранящегося в переменной или выражении. Он возвращает строку, указывающую тип данных значения.

Вот несколько основных типов данных и соответствующие значения, возвращаемые оператором `typeof`:

- `"undefined"`: Если значение переменной не определено или переменная не объявлена.
- `"boolean"`: Если значение является логическим типом данных `true` или `false`.
- `"number"`: Если значение является числом.
- `"string"`: Если значение является строкой.
- `"symbol"`: Если значение является символом (введено с помощью функции `Symbol()`).
- `"object"`: Если значение является объектом или `null`.
- `"function"`: Если значение является функцией.

Некоторые примеры использования оператора `typeof`:

```javascript
const x = 10;
console.log(typeof x); // "number"

const str = "Hello";
console.log(typeof str); // "string"

const obj = { name: "John", age: 25 };
console.log(typeof obj); // "object"

function greet() {
  console.log("Hello!");
}
console.log(typeof greet); // "function"
```

Оператор `typeof` является удобным инструментом для проверки типов данных и выполнения соответствующих операций в JavaScript. Однако стоит быть осторожным при работе с некоторыми типами данных, так как результаты оператора `typeof` могут иметь некоторые особенности. Например, `typeof null` возвращает `"object"`, хотя `null` не является объектом.

  **[⬆ Наверх](#top)**
	
126. ## <a name="126"></a> Почему у переменных примитивного типа данных есть методы? Что такое Autoboxing?

В JavaScript переменные примитивных типов данных, таких как числа, строки и булевы значения, временно оборачиваются в соответствующие объекты-оболочки (называемые "объекты-обёртки") для доступа к методам и свойствам, которые доступны только для объектов.

Например, у примитивного типа данных `string` есть методы, такие как `toUpperCase()`, `charAt()`, `length` и другие. Когда мы вызываем метод на примитивной переменной типа `string`, JavaScript временно оборачивает эту переменную в объект-оболочку типа `String`, чтобы мы могли вызвать соответствующий метод. После выполнения метода объект-оболочка уничтожается, и переменная снова становится примитивом.

Аналогично, для чисел (`number`) и булевых значений (`boolean`) существуют объекты-оболочки `Number` и `Boolean`, соответственно, которые предоставляют методы и свойства для работы с этими примитивными типами.

Например, при вызове метода `toFixed()` на числовой переменной, JavaScript временно оборачивает это число в объект-оболочку типа `Number` для доступа к методу `toFixed()`. После выполнения метода объект-оболочка уничтожается, и переменная снова становится примитивом.

Этот механизм временной обёртки примитивов в объекты-оболочки называется "автоматическим упаковыванием" или "autoboxing". Он обеспечивает возможность использования методов и свойств на примитивных типах данных, хотя они фактически являются примитивами.

Пример использования метода на примитиве:

```javascript
const str = "hello";
console.log(str.toUpperCase()); // "HELLO"
```

Здесь переменная `str` является примитивом типа `string`, но благодаря автоматическому упаковыванию мы можем вызвать метод `toUpperCase()` на этой переменной.

Несмотря на автоматическое упаковывание, важно помнить, что примитивные значения всё равно остаются примитивами и не могут быть изменены напрямую. Методы, вызываемые на примитивных значениях, создают новые значения или возвращают результаты обработки без изменения исходного значения.

  **[⬆ Наверх](#top)**
	
127. ## <a name="127"></a> Сборщик мусора в JS?

В JavaScript существует механизм автоматического сбора мусора (Garbage Collection), который отвечает за освобождение памяти, занятой объектами, которые больше не используются в программе. Сборщик мусора автоматически определяет, какие объекты могут быть удалены и освобождает память, которую они занимали, чтобы она могла быть использована для других целей.

Основная концепция, на которой основан сборщик мусора в JavaScript, - это обнаружение недостижимых объектов. Если объект становится недостижимым, то есть к нему больше нет ссылок из активных частей программы, то он считается ненужным и может быть удален.

Существует несколько алгоритмов сборки мусора, используемых в различных реализациях JavaScript. Некоторые из наиболее распространенных алгоритмов включают подсчет ссылок, алгоритмы маркировки и свипа, алгоритмы поколений и другие.

Сборка мусора происходит автоматически и является фоновым процессом в браузере или среде выполнения JavaScript. Он следит за использованием памяти и освобождает память, когда это необходимо. Однако, точное время и частота сборки мусора зависят от реализации JavaScript и условий выполнения программы.

Важно отметить, что хотя сборка мусора облегчает жизнь разработчиков, избегать утечек памяти и эффективно управлять ресурсами все равно является важной задачей. Разработчики должны быть внимательными при работе с объектами, особенно с большими или долгоживущими объектами, чтобы предотвратить накопление мусора и утечки памяти.
	
https://learn.javascript.ru/garbage-collection	
	
  **[⬆ Наверх](#top)**
	
128. ## <a name="128"></a> Временная мертвая зона

Временная мертвая зона (Temporal Dead Zone или TDZ) - это фаза во время выполнения кода в JavaScript, когда переменная уже объявлена, но еще не доступна для использования. В этой фазе переменная существует, но ее нельзя обратиться к ней или прочитать ее значение.

TDZ возникает в следующих случаях:

1. При использовании переменных, объявленных с помощью `let` и `const`: Когда код доходит до объявления переменной, она существует в TDZ до момента фактического объявления.

```javascript
console.log(x); // ReferenceError: x is not defined
let x = 10; // TDZ для переменной x
```

2. При использовании переменных в блоках `if`, `for`, `while` и других блоках области видимости: Переменные, объявленные внутри блока, существуют в TDZ до момента объявления внутри блока.

```javascript
if (condition) {
  console.log(x); // ReferenceError: x is not defined
  let x = 10; // TDZ для переменной x
}
```

3. При использовании параметров функции: Параметры функции существуют в TDZ до момента выполнения самой функции.

```javascript
function myFunction(x = y, y) {
  console.log(x); // ReferenceError: y is not defined
  console.log(y); // undefined
}
myFunction(); // TDZ для параметра x
```

TDZ является механизмом JavaScript, который помогает предотвратить ошибки во время выполнения, связанные с использованием переменных до их объявления. Поэтому рекомендуется объявлять переменные перед их использованием, чтобы избежать возникновения TDZ и связанных с этим ошибок.

  **[⬆ Наверх](#top)**
	
129. ## <a name="129"></a> Всплытие событий, event bubbling
	
Всплытие событий (event bubbling) - это механизм в JavaScript, при котором события, произошедшие на вложенных элементах DOM, сначала обрабатываются на самом вложенном элементе, а затем последовательно всплывают (переходят) к его родительским элементам вверх по иерархии DOM.

Когда происходит событие на элементе, например, клик на кнопке, событие начинает всплывать от самого вложенного элемента до его родителей. Это означает, что обработчики событий, привязанные к родительским элементам, также могут сработать.

Процесс всплытия событий происходит автоматически, если для события не указано явное отменяющее всплытие (stopPropagation). По умолчанию большинство событий всплывают.

Пример:

```html
<div id="parent">
  <div id="child">
    <button id="button">Click me</button>
  </div>
</div>
```

```javascript
document.getElementById('button').addEventListener('click', function() {
  console.log('Button clicked');
});

document.getElementById('child').addEventListener('click', function() {
  console.log('Child clicked');
});

document.getElementById('parent').addEventListener('click', function() {
  console.log('Parent clicked');
});
```

При клике на кнопке с сообщением "Click me", обработчики событий будут вызваны в следующем порядке:

1. "Button clicked" (обработчик кнопки)
2. "Child clicked" (обработчик дочернего элемента)
3. "Parent clicked" (обработчик родительского элемента)

Это происходит потому, что событие клика всплывает от кнопки к дочернему элементу и затем к родительскому элементу.

Всплытие событий позволяет легко обрабатывать события на родительских элементах, не привязывая обработчики к каждому дочернему элементу отдельно. Однако, в некоторых случаях может потребоваться остановить всплытие события с помощью метода `event.stopPropagation()`, чтобы предотвратить дальнейшее всплытие события к родительским элементам.	
	
  **[⬆ Наверх](#top)**
	
130. ## <a name="130"></a> Делегирование событий

Делегирование событий (event delegation) - это прием в JavaScript, при котором обработка событий осуществляется не на конкретных элементах, а на их родительском элементе. Это позволяет эффективно обрабатывать события для множества дочерних элементов, вместо того чтобы привязывать обработчики событий к каждому элементу отдельно.

Преимущества делегирования событий:

1. Экономия ресурсов: При использовании делегирования событий обработчики привязываются только к родительскому элементу, что экономит память и упрощает код.

2. Динамически добавляемые элементы: Если в дальнейшем появляются новые дочерние элементы, им не требуется привязывать обработчики событий отдельно - они автоматически наследуются от родительского элемента.

3. Упрощение работы с элементами списка: Для списков или таблиц, в которых имеется множество элементов, делегирование событий позволяет обрабатывать события на всем списке или таблице, а не на каждом элементе по отдельности.

Пример использования делегирования событий:

```html
<ul id="myList">
  <li>Item 1</li>
  <li>Item 2</li>
  <li>Item 3</li>
</ul>
```

```javascript
document.getElementById('myList').addEventListener('click', function(event) {
  if (event.target.tagName === 'LI') {
    console.log('Clicked on item:', event.target.textContent);
  }
});
```

В этом примере мы привязываем обработчик события клика к родительскому элементу `<ul>`. При клике на любой из дочерних элементов `<li>`, обработчик будет вызываться, и мы можем получить информацию о том, на какой именно элемент кликнули.

Таким образом, делегирование событий позволяет нам эффективно обрабатывать события для множества элементов и сделать код более гибким и масштабируемым.

  **[⬆ Наверх](#top)**
	
131. ## <a name="131"></a> Hoisting - Поднятие

Hoisting (поднятие) - это механизм в JavaScript, который перемещает объявления переменных и функций в начало своей области видимости перед выполнением кода. Фактически, объявления перемещаются вверх в коде, но их инициализация остается на моменте, где они были в исходном коде.

Hoisting применяется к объявлениям переменных (`var`, `let`, `const`) и функций (`function declaration`), но работает по-разному для каждого типа.

1. Переменные (`var`, `let`, `const`):
   - Переменные, объявленные с использованием `var`, поднимаются (hoisting) в начало своей области видимости, но остаются неинициализированными. Если переменная инициализирована после использования, она будет содержать значение `undefined`.
   - Переменные, объявленные с использованием `let` и `const`, также поднимаются (hoisting) в начало своей области видимости, но остаются в "временной мертвой зоне" (TDZ) до момента фактического объявления. При доступе к переменной в TDZ будет выброшена ошибка `ReferenceError`.

2. Функции (`function declaration`):
   - Функции, объявленные с использованием `function declaration`, полностью поднимаются (hoisting) в начало своей области видимости. Они могут быть вызваны до фактического объявления функции в коде.

Примеры:

```javascript
console.log(x); // undefined
var x = 10;

console.log(y); // ReferenceError: y is not defined
let y = 20;

console.log(z); // ReferenceError: z is not defined
const z = 30;

myFunction(); // "Hello, world!"

function myFunction() {
  console.log("Hello, world!");
}
```

В приведенном примере переменная `x` поднимается в начало области видимости, поэтому мы можем получить к ней доступ до фактического объявления. Переменные `y` и `z`, объявленные с использованием `let` и `const`, находятся в TDZ, поэтому попытка доступа к ним вызывает ошибку `ReferenceError`.

Функция `myFunction` поднимается в начало своей области видимости, поэтому мы можем вызвать ее до фактического объявления.

Хотя hoisting позволяет использовать переменные и функции до их объявления, рекомендуется объявлять их перед использованием для повышения читаемости и понимания кода.	
	
  **[⬆ Наверх](#top)**	
	
	
132. ## <a name="132"></a> Глобальный объект window

Глобальный объект `window` является основным объектом в браузерной среде JavaScript. Он представляет собой глобальную область видимости, которая содержит переменные, функции и другие объекты, доступные на глобальном уровне.

Некоторые важные свойства и методы глобального объекта `window`:

1. `window.document`: Свойство, которое предоставляет доступ к объекту `Document`, представляющему текущий HTML-документ.

2. `window.alert()`: Метод, который отображает модальное диалоговое окно с указанным сообщением и кнопкой "ОК".

3. `window.prompt()`: Метод, который отображает модальное диалоговое окно с указанным сообщением и полем для ввода данных.

4. `window.confirm()`: Метод, который отображает модальное диалоговое окно с указанным сообщением и кнопками "OK" и "Отмена" для подтверждения.

5. `window.setTimeout()`: Метод, который позволяет запустить выполнение функции или переданного кода через указанное количество миллисекунд.

6. `window.setInterval()`: Метод, который позволяет запустить выполнение функции или переданного кода повторно через указанный интервал времени.

7. `window.clearTimeout()`: Метод, который позволяет отменить запланированное выполнение функции или кода, установленное с помощью `setTimeout()`.

8. `window.clearInterval()`: Метод, который позволяет отменить повторное выполнение функции или кода, установленное с помощью `setInterval()`.

9. `window.location`: Свойство, предоставляющее информацию о текущем URL-адресе и методы для изменения URL-адреса.

10. `window.console`: Объект, предоставляющий доступ к консоли разработчика браузера для вывода сообщений и отладочных данных.

Это лишь некоторые из свойств и методов, доступных через глобальный объект `window`. Он играет важную роль взаимодействия JavaScript с браузерной средой и предоставляет доступ к множеству функциональных возможностей, таких как манипуляция DOM, управление таймерами, работа с событиями и другими.
 
 https://learn.javascript.ru/global-object

  **[⬆ Наверх](#top)**
	
133. ## <a name="133"></a> import/export syntax & CommonJS

Синтаксис `import/export` в JavaScript используется для модульного организации кода и обмена данными между модулями. Он является частью стандарта ECMAScript (ES) модулей, который предоставляет более мощные возможности импорта и экспорта, чем старый синтаксис `require/module.exports`, используемый в CommonJS.

Синтаксис `import` используется для импорта функций, объектов или значений из других модулей:

```javascript
import { имяЭкспорта1, имяЭкспорта2 } from 'модуль';
import значение from 'модуль';
import * as префикс from 'модуль';
```

- `имяЭкспорта1`, `имяЭкспорта2`: Имена экспортируемых значений из модуля, которые мы хотим импортировать.
- `значение`: Имя для импортируемого значения из модуля.
- `префикс`: Префикс, который будет использоваться для доступа ко всем экспортируемым значениям из модуля.

Синтаксис `export` используется для экспорта функций, объектов или значений из текущего модуля:

```javascript
export { имяЭкспорта1, имяЭкспорта2 };
export default значение;
```

- `имяЭкспорта1`, `имяЭкспорта2`: Имена значений, которые мы хотим экспортировать из модуля.
- `значение`: Значение, которое будет экспортировано по умолчанию из модуля.

Примеры использования:

```javascript
// Модуль "utils.js"
export function add(a, b) {
  return a + b;
}

export const PI = 3.14159;

// Модуль "main.js"
import { add, PI } from './utils';

console.log(add(2, 3)); // Вывод: 5
console.log(PI); // Вывод: 3.14159
```

В приведенном примере мы экспортируем функцию `add` и константу `PI` из модуля "utils.js". Затем мы импортируем их в модуле "main.js" с помощью синтаксиса `import`. Теперь мы можем использовать импортированные значения в нашем коде.

Кроме того, с помощью ключевого слова `default` можно экспортировать значение по умолчанию из модуля. Это значение может быть одним для каждого модуля:

```javascript
// Модуль "math.js"
const multiply = (a, b) => a * b;
export default multiply;

// Модуль "main.js"
import multiply from './math';

console.log(multiply(2, 3)); // Вывод: 6
```

В этом примере мы экспортируем функцию `multiply`из модуля "math.js" по умолчанию. Затем мы импортируем ее в модуле "main.js" с помощью синтаксиса `import`.

`Довод против экспортов по умолчанию`

Один из доводов против использования экспортов по умолчанию в JavaScript заключается в ухудшении читаемости и понимания кода. Вот несколько причин, почему некоторые разработчики предпочитают избегать экспортов по умолчанию:

1. Неявное и неоднозначное именование: При использовании экспорта по умолчанию имя экспортируемого значения не указывается явно. Вместо этого оно задается ключевым словом `default`. Это может сделать код менее понятным и усложнить понимание, какие значения экспортируются по умолчанию из модуля.

2. Несогласованность и путаница: В JavaScript можно экспортировать только одно значение по умолчанию из модуля. Это ограничение может привести к путанице и несогласованности при разработке более сложных модульных систем. Вместо этого, использование именованных экспортов позволяет явно указать, какие значения экспортируются из модуля, и дает большую гибкость при работе с несколькими значениями.

3. Усложнение тестирования: При использовании экспорта по умолчанию в модуле может быть сложно тестировать и мокать только определенные значения, поскольку они экспортируются неявно. Именованные экспорты делают тестирование более прозрачным и удобным.

4. Потеря контроля над именами: С использованием экспорта по умолчанию может возникнуть риск конфликта имен при импорте в другие модули. Если несколько модулей экспортируют значения по умолчанию с одинаковыми именами, это может привести к неожиданному поведению и сложностям при отладке.

В целом, предпочтительно использовать именованные экспорты вместо экспортов по умолчанию, так как они явно указывают, какие значения экспортируются из модуля, делают код более понятным и удобным для сопровождения.

Експорт:

1. Перед объявлением класса/функции/…:
	- export [default] class/function/variable ...
2. Отдельный экспорт:
	- export {x [as y], ...}.
3. Реэкспорт:
	- export {x [as y], ...} from "module"
	- export * from "module" (не реэкспортирует export default).
	- export {default [as y]} from "module" (реэкспортирует только export default).

Импорт:

1. Именованные экспорты из модуля:
	- import {x [as y], ...} from "module"
2. Импорт по умолчанию:
	- import x from "module"
	- import {default as x} from "module"
3. Всё сразу:
	- import * as obj from "module"
4. Только подключить модуль (его код запустится), но не присваивать его переменной:
	- import "module"


`CommonJS` — это спецификация модульной системы для JavaScript, которая была разработана с целью обеспечить модульность и повторное использование кода в среде серверной разработки. Она была широко использована в Node.js.

Особенности и синтаксис CommonJS:

1. `require`: Для импорта модулей используется функция `require`. Она принимает путь к модулю и возвращает экспортированные значения.

```javascript
const module = require('модуль');
```

2. `module.exports`: Для экспорта значений из модуля используется объект `module.exports`. Значения, присвоенные свойству `module.exports`, будут доступны для импорта из других модулей.

```javascript
module.exports = значение;
```

3. `exports`: Кроме `module.exports` можно использовать также объект `exports` для экспорта значений. Однако `exports` является просто ссылкой на `module.exports`, и поэтому он может быть использован только для добавления свойств к экспортированному объекту.

```javascript
exports.имя = значение;
```

Пример использования CommonJS:

```javascript
// Модуль "math.js"
const add = (a, b) => a + b;
const multiply = (a, b) => a * b;

module.exports = {
  add,
  multiply,
};

// Модуль "main.js"
const math = require('./math');

console.log(math.add(2, 3)); // Вывод: 5
console.log(math.multiply(2, 3)); // Вывод: 6
```

В приведенном примере мы экспортируем функции `add` и `multiply` из модуля "math.js" с помощью `module.exports`. Затем мы импортируем их в модуле "main.js" с помощью `require` и используем в нашем коде.

CommonJS широко использовался в среде Node.js для модульной разработки на сервере. Однако в браузерной среде стандартом стали модули ES (ECMAScript Modules), которые используют синтаксис `import/export` для импорта и экспорта модулей.
	
https://nodejsdev.ru/api/modules/	
	
  **[⬆ Наверх](#top)** 

136. ### <a name="136"></a> Разница между классом и объектом. Различие между прототипическим и классическим наследованием

В JavaScript классы и объекты являются ключевыми элементами объектно-ориентированного программирования, но они имеют разные роли и характеристики.

1. Класс (Class):
   - Класс является шаблоном или моделью, по которой создаются объекты.
   - Класс определяет структуру и поведение объектов, определяя их свойства (переменные) и методы (функции).
   - В JavaScript классы объявляются с использованием ключевого слова `class` и могут иметь конструктор для инициализации объектов и другие методы.
   - Класс может быть использован для создания множества объектов с одинаковой структурой и поведением.

Пример объявления класса:

```javascript
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  sayHello() {
    console.log(`Hello, my name is ${this.name} and I'm ${this.age} years old.`);
  }
}
```

2. Объект (Object):
   - Объект представляет конкретный экземпляр класса. Он является "живым" сущностью, имеющей свое состояние и поведение.
   - Объекты создаются на основе класса с помощью ключевого слова `new`.
   - Объекты содержат свойства и методы, определенные в классе, и могут иметь свои собственные значения свойств.

Пример создания объекта на основе класса:

```javascript
const person1 = new Person('John', 25);
person1.sayHello(); // Вывод: Hello, my name is John and I'm 25 years old.
```

Таким образом, класс является абстрактным описанием структуры и поведения объектов, в то время как объект является конкретным экземпляром класса со своими уникальными значениями свойств и состоянием. Классы предоставляют основу для создания и управления объектами в JavaScript.

В JavaScript существуют два основных подхода к наследованию: прототипическое наследование и классическое (псевдоклассическое) наследование. Вот их основные различия:

Прототипическое наследование:
- В прототипическом наследовании каждый объект имеет ссылку на прототип (прототипное свойство `[[Prototype]]`), из которого он наследует свойства и методы.
- Прототип является обычным объектом, и свойства и методы, определенные в прототипе, могут быть унаследованы и использованы объектами, которые ссылается на этот прототип.
- Когда свойство или метод вызывается на объекте, JavaScript сначала проверяет, есть ли это свойство или метод непосредственно в объекте. Если нет, то оно ищется в прототипе. Если свойство или метод не найдены в прототипе, поиск продолжается в цепочке прототипов.
- Прототипное наследование позволяет создавать новые объекты на основе существующих, используя механизм наследования через прототипы.

Классическое (псевдоклассическое) наследование:
- В классическом наследовании используется понятие классов и экземпляров, как в других объектно-ориентированных языках.
- Класс определяет структуру и поведение объектов, и на его основе создаются экземпляры (объекты).
- В классическом наследовании объекты наследуют свойства и методы от класса с помощью механизма наследования.
- Классическое наследование в JavaScript обычно реализуется путем использования конструкторов и прототипов.

Важно отметить, что в JavaScript прототипное наследование является фундаментальной особенностью языка, в то время как классическое наследование было введено с появлением синтаксиса классов в ECMAScript 2015 (ES6). Несмотря на это, классы в JavaScript всё ещё основаны на прототипах, и за кулисами используются прототипные механизмы.

В современном JavaScript классы предоставляют более удобный синтаксис для определения структуры и поведения объектов, но прототипное наследование по-прежнему широко используется и остается мощным инструментом для работы с объектами и наследования их свойств и методов.

`Прототипы` - это механизм, с помощью которого объекты JavaScript наследуют свойства друг от друга.

JavaScript часто описывают как язык прототипного наследования — каждый объект, имеет объект-прототип, который выступает как шаблон, от которого объект наследует методы и свойства. 

Объект-прототип так же может иметь свой прототип и наследовать его свойства и методы и так далее. Это часто называется цепочкой прототипов и объясняет почему одним объектам доступны свойства и методы которые определены в других объектах.		
Javascript использует наследование прототипов, поэтому классов как таковых не существует. Все является объектом; просто некоторые объекты имеют общий родительский объект, методы/переменные которого будут найдены, когда разрешение имен будет искать цепочку прототипов.

Как прототипное наследование, так и классическое наследование являются парадигмами объектно-ориентированного программирования (т. е. они имеют дело с объектами). Объекты — это просто абстракции, которые состоят из свойств сущности из реального мира (т. е. они представляют в программе сущности из реального мира в виде слов ). И это называется абстракция.

### Парадигма классического наследования

В классическом наследовании объекты являются абстракциями «вещей» реального мира, но мы можем ссылаться на объекты только через классы. Классы — в данном случае это обобщение объекта. Другими словами, получается что классы — это абстракция объекта реального мира. При обобщении мы наследуем один класс от другого. И при классическом наследовании процесс наследования должен создавать уровень абстракции. При каждом наследовании, каждый дочерний класс должен повышать уровень абстракции, тем самым повышая уровень обобщения. Вот пример классического наследования:
```js
class Shoe {
    // ...
}
class Boot extends Shoe {
    // ...
}
```
Man hikingBoot = new Boot();
Как вы можете видеть в классических объектно-ориентированных языках программирования классы являются обобщениями и при каждом наследовании у них должен снижаться уровень абстракции.

Объекты в классических объектно-ориентированных языках программирования могут быть созданы только путем создания экземпляров классов.

Следовательно, по мере увеличения уровня абстракции сущности становятся более общими, а по мере снижения уровня абстракции сущности становятся более конкретными. В этом смысле уровень абстракции аналогичен шкале, варьирующейся от более специфических сущностей до более общих сущностей.


### Парадигма прототипного наследования

В отличие от классического наследования, прототипное наследование не имеет дело с увеличивающимися уровнями абстракции. Объект — это либо абстракция реальной вещи, как и раньше, либо прямая копия другого Объекта (другими словами, Прототипа (Prototype)). Объекты могут быть созданы из ничего, или они могут быть созданы из других объектов.
 
Если взять наш прежний пример то вряд ли нам удастся избежать иерархии абстракций. Поэтому он будет выглядеть примерно так:
```js
var shoe = {};
var boot = Object.create(shoe);
var hikingBoot = Object.create(boot);
```
Но в нем есть главное отличие. shoe, boot и hikingBoot это все независимые объекты. Просто одни объекты созданы от других. Это важно! А при классическом наследование обобщения являются абстракциями абстракций… от абстракций … вплоть до самого последнего потомка.

Было бы правильнее в данном случае привести пример из независимых объектов, но для объяснения разницы думаю этого будет достаточно.

Уровень абстракции здесь не обязан быть глубже одного уровня (хотя при желание может и быть).

При использование парадигмы прототипного наследования программист имеет дело только с объектами и при этом у него есть возможность создавать сущности в одном уровне абстракции.

Вы можете комбинировать обе формы наследования для достижения очень гибкой системы повторного использования кода. Что собственно почти всегда и происходит в реальном коде JavaScript. То есть в реальных проектах обычно подсознательно реализуется классическое наследование, через иерархию объектов, хотя это делать не обязательно. Так как реализовать классическое наследование с помощью прототипов очень легко. И да, обратное утверждение будет неверным.

Прототипное наследование позволяет реализовать большинство важных функций, которые вы найдете в классических языках ООП. В JavaScript замыкания и фабричные функции позволяют реализовать приватное состояние, а функциональное наследование можно легко комбинировать с прототипами, что также позволяет использовать миксины.


### Некоторые преимущества прототипного наследования:

`Слабая связь`. Экземпляр никогда не нуждается в прямой ссылке на родительский класс или прототип. Можно сохранить ссылку на прототип объекта, но это не рекомендуется, потому что это будет способствовать тесной связи в иерархии объектов — одна из самых больших ошибок классического наследования.

`Плоские иерархии`. С прототипным наследованием легко поддерживать плоские иерархии наследования — используя конкатенацию (выборочное использование свойств одного объекта для создания другого ) и делегирование (клонирование одного объекта в другой), вы можете иметь один уровень делегирования объекта и один экземпляр без ссылок на родительские классы.

`Тривиальное множественное наследование`. Наследование от нескольких предков так же просто, как объединение свойств из нескольких прототипов с использованием конкатенации для формирования нового объекта или нового делегата для нового объекта.

`Гибкая архитектура`. Поскольку вы можете выборочно наследоваться, вам не нужно беспокоиться о проблеме «неправильного дизайна». Новый класс может наследовать любую комбинацию свойств от любой комбинации исходных объектов. Из-за простоты выравнивания иерархии, изменение в одном месте не обязательно вызывает рябь в длинной цепочке объектов-потомков.

`Заключение`

В заключении отвечая на вопрос чем отличается классическое наследование от прототипного, можно сказать, что при следовании парадигме классического наследования нам необходимо создавать иерархию классов от общему к частному создавая тем самым при каждом наследовании дополнительный уровень абстракции. При следовании парадигме прототипного наследования мы не обязаны создавать иерархию от общего к частному, мы можем это делать а можем и не делать. Это оставляет нам свободу выбора (независимо от того понимаем мы это или нет), что и является на мой взгляд главным отличием этих двух парадигм.	

  **[⬆ Наверх](#top)**	

137. ### <a name="137"></a> Что такое функциональное программирование? Основы функционального программирования (функция первого класса, функция высшего порядка, лямбда-функции, неизменяемость данных, ленивое вычисление, рекурсия, чистые функции)

`Функциональное программирование` — это парадигма программирования, в которой процесс вычисления трактуется как вычисление значений функций в математическом понимании последних. Функциональное программирование предполагает обходиться вычислением результатов функций от исходных данных и результатов других функций, и не предполагает явного хранения состояния программы. Соответственно, не предполагает оно и изменяемости этого состояния.

`Функции первого класса`

Если язык программирования имеет функции первого класса, то значит они трактуются как объекты, то есть могут быть переданы другим функциям и их можно вернуть из функций. Так же их можно присваивать переменным.

Пример
```js
/* функция не имеет имени и находится в правой части команды присваивания переменной.*/

var dog = function(num) {
    for (var i = 0; i < num; i++) {
        alert("Woof");
    }
};
dog(3); //Эту функцию можно вызвать через переменную dog.
```
Такое использование ключевого слова function — внутри команды, как в команде присваивания, — называется функциональным выражением. В отличие от объявления, эта функция не имеет имени. Кроме того, результатом этого выражения является значение, которое затем присваивается переменной dog. Что это за значение? Мы присваиваем его переменной dog, а затем вызываем через эту переменную, значит, это есть ссылка на функцию.


`Функции высшего порядка`

Такие функции оперируют другими функциями, принимая их в качестве аргументов или возвращая их. Проще говоря, `Функции высшего порядка` ― это такие функции, которые принимают функцию в качестве аргумента или возвращают функцию в качестве вывода.

Например, эти функции высшего порядка встроены в язык: Array.prototype.map, Array.prototype.filter и Array.prototype.reduce .

`Array.prototype.map`

Метод map() создаёт новый массив, вызывая callback-функцию, указанную в качестве аргумента, для каждого элемента входного массива. Метод map() берёт каждое возвращённое значение от callback-функции и создаёт новый массив, используя эти значения.

Callback-функция, отправленная в метод map(), принимает 3 аргумента: element, index, и array.

Допустим, у нас есть массив из чисел. Мы хотим создать новый массив, который будет содержать удвоенные значения первого. Давайте посмотрим, как мы можем решить эту задачу с помощью функции высшего порядка и без неё.

`Без функции высшего порядка`
```js
const arr1 = [1, 2, 3];
const arr2 = [];
for(let i = 0; i < arr1.length; i++) {
  arr2.push(arr1[i] * 2);
}
// prints [ 2, 4, 6 ]
console.log(arr2);
```

С функцией высшего порядка map
```js
const arr1 = [1, 2, 3];
const arr2 = arr1.map(function(item) {
  return item * 2;
});
console.log(arr2);
```

### Понятие неизменяемости данных

Концепция неизменяемости довольно проста. По сути, неизменное значение — это то, что нельзя изменить. В частности, когда мы разрабатываем наши приложения, мы можем оказаться в некоторых ситуациях, когда мы захотим создать новый объект в нашем коде, содержащий новое свойство или значение, при этом сохраняя исходное значение. Концепция неизменяемости может помочь нам создавать новые объекты, следя за тем, чтобы мы не меняли исходное значение.

В JavaScript у нас есть примитивные типы и ссылочные типы. Примитивные типы включают числа, строки, boolean, null, undefined. И ссылочные типы включают объекты, массивы и функции.

Разница между этими типами заключается в том, что примитивные типы неизменяемы (immutable), а ссылочные типы изменяемы (mutable). Например, тип string неизменяем


### Рекурсия

Рекурсия – это приём программирования, полезный в ситуациях, когда задача может быть естественно разделена на несколько аналогичных, но более простых задач. Или когда задача может быть упрощена до несложных действий плюс простой вариант той же задачи. Или, как мы скоро увидим, для работы с определёнными структурами данных.

Рекурсивный способ: упрощение задачи и вызов функцией самой себя:
```js
function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}

alert( pow(2, 3) ); // 8
```

### Чистые функции

«Чистые» функции - это любые функции, исходные данные которых получены исключительно из их входных данных и не вызывают побочных эффектов в приложении. Математические функции являются примерами «чистых» функций. «Нечистые» функции бывают разных форм и размеров. Вот некоторые примеры:

- функции, вывод которых зависит от внешнего / глобального состояния;
- функции, которые возвращают разные исходные данные при одинаковых входных;
- функции, которые изменяют состояние приложения;
- функции, которые изменяют «внешний мир».
- 
Функциональное программирование основано на использовании «чистых» функций и строгом контроле побочных эффектов. Способность распознавать любой тип функции является ключевым для функционального программирования.

«Чистая» функция - это функция, которая выводит свои данные основываясь исключительно на свои входные данные и не вызывает побочных эффектов в приложении.

Например у нас есть функция, которая получает одно значение x и возвращает в данном случае x + 1:
```js
// function f(x) { return x + 1 }

const f = x => x + 1;
```
Довольно легко понять, что это «чистая» функция. Мы получаем тот же результат при вызове этой функции, с тем же входным значением; плюс у нас нет внешних зависимостей, которые бы вызывали побочные эффекты. Чтобы понять это далее, давай сравним это с несколькими «нечистыми» функциями.

  **[⬆ Наверх](#top)**	

138. ## <a name="138"></a> Живые коллекции

Все методы "getElementsBy*" возвращают живую коллекцию. Такие коллекции всегда отражают текущее состояние документа и автоматически обновляются при его изменении.

В приведённом ниже примере есть два скрипта.

Первый создаёт ссылку на коллекцию <div>. На этот момент её длина равна 1.
Второй скрипт запускается после того, как браузер встречает ещё один <div>, теперь её длина – 2.
```js	
<div>First div</div>

<script>
  let divs = document.getElementsByTagName('div');
  alert(divs.length); // 1
</script>

<div>Second div</div>

<script>
  alert(divs.length); // 2
</script>
```
	
Напротив, querySelectorAll возвращает статическую коллекцию. Это похоже на фиксированный массив элементов.

Если мы будем использовать его в примере выше, то оба скрипта вернут длину коллекции, равную 1:
```js
<div>First div</div>

<script>
  let divs = document.querySelectorAll('div');
  alert(divs.length); // 1
</script>

<div>Second div</div>

<script>
  alert(divs.length); // 1
</script>
```	
Теперь мы легко видим разницу. Длина статической коллекции не изменилась после появления нового div в документе.	
```js
// Живые коллекции

const boxesQuery = document.querySelectorAll('.box');
const boxesGet = document.getElementsByClassName('box');

boxesQuery[0].remove();
boxesGet[0].remove();

console.log(boxesQuery); //неживые коллекции
console.log(boxesGet); // живые коллекции

console.log(Array.from(boxesGet)) // первод в обычный массив	
```
	
### matches
	
Предыдущие методы искали по DOM.

Метод elem.matches(css) ничего не ищет, а проверяет, удовлетворяет ли elem CSS-селектору, и возвращает true или false.

Этот метод удобен, когда мы перебираем элементы (например, в массиве или в чём-то подобном) и пытаемся выбрать те из них, которые нас интересуют.

Например:
```js
<a href="http://example.com/file.zip">...</a>
<a href="http://ya.ru">...</a>

<script>
  // может быть любая коллекция вместо document.body.children
  for (let elem of document.body.children) {
    if (elem.matches('a[href$="zip"]')) {
      alert("Ссылка на архив: " + elem.href );
    }
  }
</script>
```
```js
boxesQuery.forEach(box => {
  if (box.matches('.class')) console.log(box);
})	
```
	
### closest
	
Предки элемента – родитель, родитель родителя, его родитель и так далее. Вместе они образуют цепочку иерархии от элемента до вершины.

Метод elem.closest(css) ищет ближайшего предка, который соответствует CSS-селектору. Сам элемент также включается в поиск.

Другими словами, метод closest поднимается вверх от элемента и проверяет каждого из родителей. Если он соответствует селектору, поиск прекращается. Метод возвращает либо предка, либо null, если такой элемент не найден.

Например:
```js
<h1>Содержание</h1>

<div class="contents">
  <ul class="book">
    <li class="chapter">Глава 1</li>
    <li class="chapter">Глава 2</li>
  </ul>
</div>

<script>
  let chapter = document.querySelector('.chapter'); // LI

  alert(chapter.closest('.book')); // UL
  alert(chapter.closest('.contents')); // DIV

  alert(chapter.closest('h1')); // null (потому что h1 - не предок)
</script>
```	
```js
console.log(boxesQuery[0].closest('.wrapper'));	
```
	
  **[⬆ Наверх](#top)**
	
139. ## <a name="139"></a> Symbol

Symbol в JavaScript представляет собой уникальный и неизменяемый тип данных, который может быть использован в качестве идентификатора для свойств объектов. Он был добавлен в стандарт ECMAScript 2015 (ES6) и предназначен для создания уникальных идентификаторов, которые не пересекаются с другими значениями.

Основные особенности Symbol в JavaScript:

1. Уникальность: Каждый символ Symbol уникален. Даже если два символа имеют одинаковое описание, они не будут равны друг другу.

2. Неизменяемость: Значение символа Symbol не может быть изменено после его создания. Однако символы могут быть использованы в качестве ключей для свойств объектов и доступа к свойствам.

3. Использование в качестве ключей: Символы могут быть использованы в качестве ключей для свойств объектов. Использование символов в качестве ключей позволяет создавать недоступные для случайных пересечений имена свойств.

Примеры использования символов Symbol:

```javascript
const sym1 = Symbol(); // Создание нового символа

const obj = {
  [sym1]: 'value' // Использование символа в качестве ключа
};

console.log(obj[sym1]); // Вывод: value

const sym2 = Symbol('description'); // Создание символа с описанием

console.log(sym2.toString()); // Вывод: Symbol(description)
```

Символы Symbol являются полезным инструментом в JavaScript, который позволяет создавать уникальные идентификаторы и использовать их в качестве ключей для свойств объектов без опасения случайных пересечений имен. Они особенно полезны при определении специальных методов или свойств, которые не должны быть доступными или перезаписываемыми извне объекта.

  **[⬆ Наверх](#top)**
	
140. ### <a name="140"></a> Дескрипторы свойств обьектов

Дескрипторы свойств в JavaScript - это объекты, которые определяют поведение и атрибуты свойства объекта. Они предоставляют контроль над доступом, записью и удалением свойств объекта.

В JavaScript дескриптор свойства может содержать следующие свойства:

1. value: Значение свойства.

2. writable: Булевое значение, указывающее, можно ли изменять значение свойства. Если установлено в false, попытки изменения значения свойства будут игнорироваться.

3. enumerable: Булевое значение, указывающее, должно ли свойство быть перечисляемым в цикле for...in или методе Object.keys(). Если установлено в false, свойство будет пропущено при переборе свойств объекта.

4. configurable: Булевое значение, указывающее, можно ли изменять дескриптор свойства и удалить свойство из объекта. Если установлено в false, любые попытки изменения или удаления свойства будут игнорироваться.

Пример использования дескрипторов свойств:

```javascript
const obj = {};

Object.defineProperty(obj, 'name', {
  value: 'John',
  writable: false,
  enumerable: true,
  configurable: true
});

console.log(obj.name); // Вывод: John

obj.name = 'Jane'; // Попытка изменения значения игнорируется

console.log(obj.name); // Вывод: John

for (let key in obj) {
  console.log(key); // Вывод: name
}

delete obj.name; // Удаление свойства игнорируется

console.log(obj.name); // Вывод: John
```

Дескрипторы свойств позволяют определять различные атрибуты и поведение свойств объектов в JavaScript. Они предоставляют гибкость и контроль над свойствами, позволяя управлять доступом и изменением свойств объектов.
	
  **[⬆ Наверх](#top)**		
	
141. ### <a name="141"></a> Итерируемые конструкции
	
В JavaScript итерируемые конструкции - это объекты, которые поддерживают итерацию (перебор) элементов с помощью циклов или других методов перебора. Эти объекты предоставляют специальный интерфейс, который позволяет получать доступ к элементам один за другим.

Вот некоторые примеры итерируемых конструкций в JavaScript:

1. Массивы: Массивы являются итерируемыми конструкциями по умолчанию. Вы можете использовать циклы `for..of` или методы, такие как `forEach()`, `map()`, `filter()`, чтобы перебрать элементы массива.

```javascript
const arr = [1, 2, 3];

for (const item of arr) {
  console.log(item);
}

arr.forEach(item => {
  console.log(item);
});

const doubled = arr.map(item => item * 2);
console.log(doubled);
```

2. Строки: Строки также являются итерируемыми конструкциями. Вы можете использовать цикл `for..of` для перебора символов строки.

```javascript
const str = 'Hello';

for (const char of str) {
  console.log(char);
}
```

3. Map и Set: Map и Set - это коллекции, которые также являются итерируемыми. Вы можете использовать цикл `for..of` для перебора элементов Map и Set.

```javascript
const map = new Map();
map.set('a', 1);
map.set('b', 2);

for (const [key, value] of map) {
  console.log(key, value);
}

const set = new Set([1, 2, 3]);

for (const item of set) {
  console.log(item);
}
```

4. NodeList: NodeList - это коллекция элементов, которая обычно возвращается методами, такими как `querySelectorAll()`. NodeList также является итерируемым, и вы можете использовать цикл `for..of` для перебора элементов NodeList.

```javascript
const nodeList = document.querySelectorAll('p');

for (const element of nodeList) {
  console.log(element.textContent);
}
```

Это лишь некоторые примеры итерируемых конструкций в JavaScript. Итерируемость является важным аспектом JavaScript, поскольку позволяет эффективно работать с коллекциями и перебирать их элементы с помощью циклов или методов перебора.	
	
  **[⬆ Наверх](#top)**
	
142. ### <a name="142"></a> BigInt

BigInt – это специальный числовой тип, который предоставляет возможность работать с целыми числами произвольной длины.	
	
BigInt в JavaScript является встроенным типом данных, предназначенным для работы с целыми числами произвольной точности. Он позволяет работать с числами, которые выходят за пределы максимально возможного значения для типа данных Number.

Чтобы создать значение типа BigInt, добавьте суффикс "n" к целочисленному литералу или используйте функцию BigInt():

```javascript
const bigInt1 = 123456789012345678901234567890n;
const bigInt2 = BigInt("987654321098765432109876543210");
```

Вы также можете выполнять математические операции с BigInt, включая сложение, вычитание, умножение, деление и остаток:

```javascript
const bigInt1 = 10n;
const bigInt2 = 3n;

const sum = bigInt1 + bigInt2; // 13n
const difference = bigInt1 - bigInt2; // 7n
const product = bigInt1 * bigInt2; // 30n
const quotient = bigInt1 / bigInt2; // 3n (округление вниз)
const remainder = bigInt1 % bigInt2; // 1n
```

BigInt также поддерживает операторы сравнения (>, <, >=, <=, ===, !==) и другие операции, такие как инкремент (++), декремент (--), префиксный и постфиксный, и побитовые операции.

Однако, поскольку BigInt представляет числа произвольной точности, он имеет некоторые особенности. Он не может быть смешан с числами типа Number, поэтому для выполнения операций между BigInt и Number необходимо преобразование типов. Кроме того, некоторые операции, которые в JavaScript легко выполняются с числами типа Number, могут быть менее эффективными с BigInt из-за его высокой точности.

В целом, BigInt предоставляет возможность работать с целыми числами произвольной точности в JavaScript, позволяя решать задачи, требующие работы с большими числами, которые не умещаются в тип Number.	
	
  **[⬆ Наверх](#top)**
	
143. ### <a name="143"></a> 
	
	
  **[⬆ Наверх](#top)**
	
144. ### <a name="144"></a> 
	
	
  **[⬆ Наверх](#top)**
	
145. ### <a name="145"></a> 
	
	
  **[⬆ Наверх](#top)**
	
146. ### <a name="146"></a> 
	
	
  **[⬆ Наверх](#top)**
	
147. ### <a name="147"></a> 
	
	
  **[⬆ Наверх](#top)**
	
148. ### <a name="148"></a> 
	
	
  **[⬆ Наверх](#top)**	
	
201. ### <a name="201"></a> Получение элементов со страницы

В JavaScript существует несколько способов получения элементов со страницы. Вот некоторые из них:

1. Метод getElementById(): Этот метод позволяет получить элемент по его уникальному идентификатору (id):

```javascript
const element = document.getElementById('myElement');
```

2. Метод querySelector(): Этот метод позволяет получить первый элемент, соответствующий заданному селектору CSS:

```javascript
const element = document.querySelector('.myClass');
```

3. Метод querySelectorAll(): Этот метод позволяет получить все элементы, соответствующие заданному селектору CSS, в виде NodeList:

```javascript
const elements = document.querySelectorAll('.myClass');
```

4. Метод getElementsByClassName(): Этот метод позволяет получить все элементы, имеющие указанный класс:

```javascript
const elements = document.getElementsByClassName('myClass');
```

5. Метод getElementsByTagName(): Этот метод позволяет получить все элементы с указанным тегом:

```javascript
const elements = document.getElementsByTagName('div');
```

6. Методы getElementsByName() и getElementsByNameNS(): Эти методы позволяют получить все элементы с указанным атрибутом name:

```javascript
const elements = document.getElementsByName('myName');
```

7. Методы parentElement, nextElementSibling, previousElementSibling: Эти методы позволяют получить родительский элемент, следующий элемент и предыдущий элемент соответственно относительно заданного элемента:

```javascript
const parentElement = element.parentElement;
const nextElement = element.nextElementSibling;
const previousElement = element.previousElementSibling;
```

8. Методы children и childNodes: Эти методы позволяют получить всех дочерних элементов или узлы (включая текстовые узлы) указанного элемента:

```javascript
const children = element.children;
const childNodes = element.childNodes;
```

Это только некоторые из методов, которые могут быть использованы для получения элементов со страницы в JavaScript. Выбор подходящего метода зависит от конкретной задачи и структуры страницы.	
	
```js
const box = document.getElementById('box');

console.log(box);

const btns = document.getElementsByTagName('button')/*[1]*/; // вот тут вот

console.log(btns[1]); // или тут 
console.log(btns);

console.log(btns[1]); // только так мы можем поменять цвет кнопки или размер или тд.


const circles = document.getElementsByClassName('box');

console.log(box);


// querySelectorAll - это исключение, псевдомассив, но у него появляется один метод forEach()

const hearts = document.querySelectorAll('.heart');

hearts.forEach(item => {
  console.log(item);
});

	
// const oneHeart = document.querySelector('.heart'); // позволяет получить первый элемент на странице	

const oneHeart = document.querySelector('div'); // позволяет получить первый элемент 

console.log(oneHeart);	
```	

  **[⬆ Наверх](#top)**
	
202. ### <a name="202"></a> Действия с элементами на странице

```js
const box = document.getElementById('box'),
      btns = document.getElementsByTagName('button'),
      circles = document.getElementsByClassName('circle'),
      hearts = document.querySelectorAll('.heart'),
      oneHeart = document.querySelector('.heart'),
      wrapper = document.querySelector('.wrapper');


// box.style.backgroundColor = 'blue';
// box.style.width = '500px';

// тоже самое
// box.style.cssText = 'background-color: blue; width: 500px';

// box.style.cssText = `background-color: blue; width: ${num}px`;


// btns[1].style.borderRadius = '100%';

// circles[0].style.backgroundColor = 'red';


// for (let i = 0; i < hearts.length; i++) {
//   hearts[i].style.backgroundColor = 'blue';
// }

// но лучше использовать forEach =>

// метод forEach() существует только если мы используем метод document.querySelectorAll

// hearts.forEach(item => {
//   item.style.backgroundColor = 'blue';
// });


// Основные методы для работы с элементами страницы


const div = document.createElement('div');

// const text = document.createTextNode('Hello');

div.classList.add('black');

// document.body.append(div);


// перемещение, удаление, замена

// document.querySelector('.wrapper').append(div);

//рефакторинг кода, если мы используем эту переменную много раз, то мы перемещаем wrapper вверх < = , и дальше мы можем писать вот так =>

wrapper.append(div);

//старый вариант
// wrapper.appendChild(div);


// wrapper.prepend(div);

// hearts[0].before(div);
// hearts[0].after(div);

//старый вариант
// wrapper.insertBefore(div, hearts[0]);



// circles[0].remove();

//старый вариант
// wrapper.removeChild(hearts[1]);



// hearts[0].replaceWith(circles[0]);

// старый вариант
// wrapper.replaceChild(circles[0], hearts[0]);


// редактирование текста, добавить текст в элемент

// div.innerHTML = '<h1>Hello World</h1>';

// div.textContent = 'Hello';

// div.insertAdjacentHTML('beforebegin', '<h2>Hello</h2>');	
```	

  **[⬆ Наверх](#top)**
	
203. ### <a name="203"></a> Навигация по DOM - элементам

Навигация по DOM элементам в JavaScript предоставляет различные методы и свойства для перемещения между элементами и их отношениями. Вот некоторые из них:

1. Соседние элементы:
   - `nextSibling`: Возвращает следующий соседний узел, включая текстовые узлы.
   - `previousSibling`: Возвращает предыдущий соседний узел, включая текстовые узлы.
   - `nextElementSibling`: Возвращает следующий элемент-сосед.
   - `previousElementSibling`: Возвращает предыдущий элемент-сосед.

2. Родительский элемент:
   - `parentNode`: Возвращает родительский узел.
   - `parentElement`: Возвращает родительский элемент.

3. Дочерние элементы:
   - `childNodes`: Возвращает коллекцию дочерних узлов, включая текстовые узлы.
   - `children`: Возвращает коллекцию дочерних элементов.

4. Первый и последний дочерние элементы:
   - `firstChild`: Возвращает первый дочерний узел, включая текстовые узлы.
   - `lastChild`: Возвращает последний дочерний узел, включая текстовые узлы.
   - `firstElementChild`: Возвращает первый дочерний элемент.
   - `lastElementChild`: Возвращает последний дочерний элемент.

5. Потомки элемента:
   - `querySelector()`: Позволяет выбрать первый потомок, соответствующий заданному селектору.
   - `querySelectorAll()`: Позволяет выбрать все потомки, соответствующие заданному селектору.

6. Обход дерева элементов:
   - Рекурсивные функции или циклы можно использовать для обхода дерева элементов, начиная с определенного узла и переходя к его потомкам.

Примеры использования этих методов и свойств:

```javascript
const parentElement = document.getElementById('parent');
const firstChild = parentElement.firstChild;
const nextSibling = firstChild.nextSibling;
const previousElementSibling = nextSibling.previousElementSibling;
const children = parentElement.children;
const firstElementChild = parentElement.firstElementChild;
const lastElementChild = parentElement.lastElementChild;
const descendant = parentElement.querySelector('.descendant');
const descendants = parentElement.querySelectorAll('.descendant');

// Пример обхода дерева элементов
function traverse(node) {
  // Обработка текущего узла
  // ...

  // Рекурсивный вызов для потомков
  const children = node.childNodes;
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (child.nodeType === Node.ELEMENT_NODE) {
      traverse(child);
    }
  }
}

traverse(parentElement);
```

Это лишь некоторые из методов и свойств, которые предоставляет JavaScript для навигации по DOM элементам

. Выбор конкретных методов и свойств зависит от требований вашего проекта и структуры вашей страницы.	
	
```js
console.log(document.body);
console.log(document.head);
console.log(document.documentElement); // html

console.log(document.body.childNodes);

Разницв между DOM Elements и DOM Nodes: каждая сущность которая находится на странице она по факту будет узлом, но не каждый узел будет элементом 

console.log(document.body.firstChild);

console.log(document.body.firstElementChild);

console.log(document.body.lastChild);
console.log(document.body.lastElementChild);

console.log(document.querySelector('#current').parentNode.parentNode);

console.log(document.querySelector('#current').parentElement);


console.log(document.querySelector('[data-current = "3"]').nextSibling);

console.log(document.querySelector('[data-current = "3"]').previousSibling);

console.log(document.querySelector('[data-current = "3"]').nextElementSibling);

console.log(document.querySelector('[data-current = "3"]').previousElementSibling);



// тут псевдомассив, но использовать forEach мы не можем, но мы можем использовать for of

for (let node of document.body.childNodes) {
  if (node.nodeName == '#text') {
    continue;
  }

  console.log(node);
}

коментарий не является тектовой нодой	
```	

  **[⬆ Наверх](#top)**
	
204. ### <a name="204"></a> Способы получения DOM-элементов в JS

В JavaScript есть несколько способов получить DOM-элементы на странице. Вот некоторые из них:

1. По идентификатору:
   - Используйте метод `getElementById()` для получения элемента по его уникальному идентификатору.

     ```javascript
     const element = document.getElementById('myElementId');
     ```

2. По селектору:
   - Используйте метод `querySelector()` для получения первого элемента, соответствующего заданному CSS-селектору.

     ```javascript
     const element = document.querySelector('.myElementClass');
     ```

   - Используйте метод `querySelectorAll()` для получения всех элементов, соответствующих заданному CSS-селектору.

     ```javascript
     const elements = document.querySelectorAll('.myElementClass');
     ```

3. По тегу:
   - Используйте метод `getElementsByTagName()` для получения всех элементов с заданным тегом.

     ```javascript
     const elements = document.getElementsByTagName('div');
     ```

4. По имени класса:
   - Используйте метод `getElementsByClassName()` для получения всех элементов с заданным классом.

     ```javascript
     const elements = document.getElementsByClassName('myElementClass');
     ```

5. По атрибуту:
   - Используйте метод `querySelectorAll()` и указывайте селектор с атрибутом, чтобы получить элементы с определенным атрибутом или значением атрибута.

     ```javascript
     const elements = document.querySelectorAll('[data-custom-attribute]');
     ```

6. По отношению к другим элементам:
   - Используйте методы навигации по DOM, такие как `parentNode`, `nextSibling`, `previousSibling`, `firstChild`, `lastChild`, `childNodes`, `children` и другие, чтобы получить элементы на основе их отношений с другими элементами.

     ```javascript
     const parentElement = document.getElementById('parentElement');
     const childElements = parentElement.children;
     const firstChildElement = parentElement.firstChild;
     const nextSiblingElement = parentElement.nextSibling;
     ```

Это только несколько примеров способов получения DOM-элементов в JavaScript. Выбор конкретного способа зависит от требований вашего проекта и структуры вашей страницы.	
	
```javascript
// Создать div
const div = document.createElement('div');

// Добавить к нему класс wrapper
div.classList.add('wrapper');
// Поместить его внутрь тэга body
const body = document.querySelector('body');

// const body2 = document.body;

console.log(body);
// console.log(body2);

body.appendChild(div);

console.log(div);
// Создать заголовок H1 "DOM (Document Object Model)"
const header = document.createElement('h1');
header.textContent = 'DOM (Document Object Model)';
console.log(header);
// Добавить H1 перед DIV с классом wrapper
div.insertAdjacentElement('beforebegin', header);
// Создать список <ul></ul>
// Добавить в него 3 элемента с текстом "один, два, три"

const ul = `
	<ul>
		<li>один</li>
		<li>два</li>
		<li>три</li>
	</ul>
`;

// Поместить список внутрь элемента с классом wrapper
	div.innerHTML = ul;
// =================================================
// Создать изображение
const img = document.createElement('img');
// Добавить следующие свойства к изображению
// 1. Добавить атрибут source
img.src = 'https://picsum.photos/240';
// 2. Добавить атрибут width со значением 240
img.width = 240;
// 3. Добавить класс super
img.classList.add('super');
// 4. Добавить свойство alt со значением "Super Man"
img.alt = 'superMan';
// Поместить изображение внутрь элемента с классом wrapper
div.appendChild(img);
```

  **[⬆ Наверх](#top)**
	
205. ### <a name="205"></a> DOM-дерево (устройство, селекторы)

DOM (Document Object Model) представляет собой структуру в виде дерева, которая представляет HTML-документ. В DOM-дереве каждый элемент HTML-документа представлен узлом, и эти узлы связаны между собой отношениями родитель-потомок.

DOM-дерево включает в себя различные типы узлов, такие как элементы, текстовые узлы, комментарии и другие. Каждый узел имеет свои свойства и методы, которые позволяют взаимодействовать с элементами и их содержимым.

Устройство DOM-дерева:

- Корневой узел (`document`): Верхний узел DOM-дерева, представляющий весь HTML-документ.
- Элементы (`Element`): Узлы, представляющие HTML-элементы (например, `<div>`, `<p>`, `<span>` и т.д.).
- Текстовые узлы (`Text`): Узлы, содержащие текстовое содержимое элемента.
- Атрибуты (`Attribute`): Атрибуты, присоединенные к элементам.
- Родитель-потомок отношение: Каждый узел имеет ссылку на своего родителя (`parentNode`) и на своих прямых потомков (`childNodes`, `children`).
- Соседние узлы: Узлы, имеющие общего родителя, считаются соседними и имеют ссылки на предыдущий (`previousSibling`) и следующий (`nextSibling`) узлы.

Селекторы в JavaScript используются для выбора элементов на основе различных критериев, таких как идентификаторы, классы, атрибуты, теги и другие свойства элементов. Вот некоторые из популярных селекторов в JavaScript:

- Идентификатор (`#id`): Выбирает элемент по его уникальному идентификатору.

  ```javascript
  const element = document.querySelector('#myElementId');
  ```

- Класс (`.class`): Выбирает элементы по их классу.

  ```javascript
  const elements = document.querySelectorAll('.myElementClass');
  ```

- Тег (`tag`): Выбирает элементы по их тегу.

  ```javascript
  const elements = document.getElementsByTagName('div');
  ```

- Атрибут (`[attribute]`): Выбирает элементы, у которых есть указанный атрибут.

  ```javascript
  const elements = document.querySelectorAll('[data-custom-attribute]');
  ```

- Комбинированные селекторы: Можно комбинировать различные селекторы для более точного выбора элементов

. Например, `element.class` выберет элементы с указанным классом, а `element[attr=value]` выберет элементы с указанным атрибутом и его значением.

  ```javascript
  const elements = document.querySelectorAll('div.myElementClass');
  ```

  ```javascript
  const elements = document.querySelectorAll('input[type="text"]');
  ```

Это лишь некоторые примеры селекторов, которые можно использовать в JavaScript. Селекторы позволяют легко выбирать и взаимодействовать с элементами DOM-дерева в вашем коде.
 
### Cелекторы:
 
 Основных видов селекторов всего несколько:
`*` – любые элементы.
 
`div` – элементы с таким тегом.
 
`#id` – элемент с данным id.
 
`.class` – элементы с таким классом.
 
`[name="value"]` – селекторы на атрибут (см. далее).
 
`:visited` – «псевдоклассы», остальные разные условия на элемент.
 
 Селекторы можно комбинировать, записывая последовательно, без пробела:
	
`.c1.c2` – элементы одновременно с двумя классами c1 и c2
 
`a#id.c1.c2:visited` – элемент a с данным id, классами c1 и c2, и псевдоклассом visited
 
 Самые известные вы наверняка знаете:
 
`div p` – элементы p, являющиеся потомками div.
 
`div > p` – только непосредственные потомки
 
Есть и два более редких:

`div ~ p` – правые соседи: все p на том же уровне вложенности, которые идут после div.
 
`div + p` – первый правый сосед: p на том же уровне вложенности, который идёт сразу после div.
 
 При выборе элемента можно указать его место среди соседей.
Список псевдоклассов для этого:

`:first-child` – первый потомок своего родителя.

`:last-child` – последний потомок своего родителя.

`:only-child` – единственный потомок своего родителя, соседних элементов нет.

:nth-child(a)` – потомок номер a своего родителя, например :nth-child(2) – второй потомок. Нумерация начинается с 1.

`:nth-child(an+b)` – расширение предыдущего селектора через указание номера потомка формулой, где a,b – константы, а под n подразумевается любое целое число.

Этот псевдокласс будет фильтровать все элементы, которые попадают под формулу при каком-либо n. Например: -:nth-child(2n) даст элементы номер 2, 4, 6…, то есть чётные.

`:nth-child(2n+1)` даст элементы номер 1, 3…, то есть нечётные.
 
`:nth-child(3n+2)` даст элементы номер 2, 5, 8 и так далее.
 
 Другие псевдоклассы
	
`:not(селектор)` – все, кроме подходящих под селектор.

`:focus` – в фокусе.

`:hover` – под мышью.

`:empty` – без детей (даже без текстовых).

`:checked`, `:disabled`, `:enabled` – состояния INPUT.

`:target` – этот фильтр сработает для элемента, ID которого совпадает с анкором #... текущего URL.

Например, если на странице есть элемент с id="intro", то правило :target { color: red } подсветит его в том случае, если текущий URL имеет вид http://...#intro.
 
При помощи псевдоэлементов ::before и ::after можно добавлять содержимое в начало и конец элемента

https://learn.javascript.ru/dom-nodes

https://learn.javascript.ru/css-selectors

  **[⬆ Наверх](#top)**
		
206. ### <a name="206"></a> ClassList, ClassName и делегирование событий

Мы используем classList и className в JavaScript DOM для управления классами из элемента. Эти два свойства DOM имеют разные варианты использования. Посмотрим, в чем основное различие между ними.
	
Для управления классами существуют два DOM-свойства:

- className – строковое значение, удобно для управления всем набором классов.
- classList – объект с методами add/remove/toggle/contains, удобно для управления отдельными классами.

classList
	
Используя classList, вы можете добавить или удалить класс, не затрагивая любые другие классы, которые может иметь элемент.

Так что это полезно для добавления дополнительных классов к элементу, который содержит другие классы.
```js
classListесть несколько удобных методов, таких как toggleи replace.
if (clicked) {
    button.classList.add('clicked');
} else {
    button.classList.remove('clicked');
}
```
Здесь, если была нажата кнопка, он добавит выбранный класс вместе с другими классами, которые может иметь элемент, и удалит только выбранный класс из элемента.

className
	
Если вы используете className, он уничтожит все существующие классы при добавлении нового (или если вы назначите пустую строку, он уничтожит все из них).

Использование classNameможет быть удобным, если вы знаете, что этот элемент не будет использовать какие-либо другие классы.
```js	
if (clicked) {
    button.className = 'clicked';
} else {
    button.className = '';
}
```
В этом случае classNameстираются все классы, которые может иметь элемент, и добавляется к нему класс, по которому щелкнули . Пустая строка ('') сотрет все классы.

Заключение
Я бы рекомендовал использовать, classNameкогда это возможно.

Используйте, classListкогда вам нужны методы classList, такие как переключение, замена 
	
	
ClassList и ClassName в JavaScript используются для работы с классами элементов DOM, а делегирование событий позволяет обрабатывать события на родительском элементе вместо прямого назначения обработчиков на каждом дочернем элементе. Давайте рассмотрим каждую из этих тем более подробно.

1. ClassList:
   - ClassList представляет собой свойство объекта элемента DOM, которое предоставляет методы для добавления, удаления, переключения и проверки классов элемента.
   - Методы ClassList включают `add(className)`, `remove(className)`, `toggle(className)`, `contains(className)` и `replace(oldClass, newClass)`, позволяющие манипулировать классами элемента.
   - Например, чтобы добавить класс к элементу, можно использовать `element.classList.add('className')`, а чтобы проверить наличие класса, можно использовать `element.classList.contains('className')`.

2. ClassName:
   - ClassName представляет собой свойство объекта элемента DOM, которое позволяет получить или установить строку с классами элемента.
   - С помощью свойства ClassName можно получить список всех классов элемента в виде строки, а также установить новую строку классов.
   - Например, чтобы получить список классов элемента, можно использовать `element.className`, а чтобы установить новые классы, можно использовать `element.className = 'newClass'`.

3. Делегирование событий:
   - Делегирование событий позволяет обрабатывать события на родительском элементе вместо прямого назначения обработчиков на каждом дочернем элементе.
   - Вместо того, чтобы назначать обработчики событий на каждый элемент, вы можете назначить обработчик на родительский элемент и использовать информацию о целевом элементе события для определения, какой элемент вызвал событие.
   - Делегирование событий особенно полезно, когда у вас есть динамически создаваемые элементы или когда вам нужно обрабатывать события на большом количестве элементов.
   - Пример использования делегирования событий:

     ```javascript
     const parentElement = document.getElementById('parentElement');

     parentElement.addEventListener('click', function(event) {
       if (event.target.classList.contains('className')) {
         // Обработка события для элементов с определенным классом
       }
     });
     ```

   В результате делегирования событий можно снизить количество назначаемых обработчиков событий и более эффективно обрабатывать события на динамически изменяемых элементах.

В целом, ClassList и ClassName позволяют работать с классами элементов DOM, а делегирование событий помогает

 эффективно обрабатывать события на родительском элементе, избегая назначения обработчиков на каждом дочернем элементе.


// Делигирование событий

wrapper.addEventListener('click', (event) => {
  // console.dir(event.target);
  if (event.target && event.target.tagName == 'BUTTON') {
    console.log('Hello');
  }
});


wrapper.addEventListener('click', (event) => {
  if (event.target && event.target.classList.contains('blue')) {
    console.log('HEllo');
  }
});


wrapper.addEventListener('click', (event) => {
  if (event.target && event.target.tagName == 'BUTTON') {
    console.log('HEllo');
  }
});


wrapper.addEventListener('click', (event) => {
  if (event.target && event.target.matches('button.red')) {
    console.log('HEllo');
  }
});


//ошибка, которую можно допустить =>

btns.forEach(btn => {
  btn.addEventListener('click', () => {
    console.log('Hi-Hi');
  });
});


//Делегирование - вне зависимости когда элемент появился, у него будут такие же свойства как и у остальных

const btn = document.createElement('button');
btn.classList.add('red');
wrapper.append(btn);	
```	
	
  **[⬆ Наверх](#top)**
	
	
207. ### <a name="207"></a> 
	

  **[⬆ Наверх](#top)**
	
	
208. ### <a name="208"></a> Работа с датами

```js
Способы создания даты

const now = new Date();

console.log(now);


const now = new Date('2021-01-15');

console.log(now);


const now = new Date(2021, 1, 15, 20);

console.log(now);


колличество милисекунд отчитывается с начала 1970 года

const now = new Date(0);

console.log(now);



const now = new Date(-9999999999999);

console.log(now);


Получение компонентов даты

const now = new Date();

console.log(now.getFullYear());
console.log(now.getMonth());
console.log(now.getDate());
console.log(now.getHours());
console.log(now.getMinutes());
console.log(now.getSeconds());
console.log(now.getMilliseconds());

нумерация начинается с Воскресенья
console.log(now.getDay());

console.log(now.getUTCHours());

console.log(now.getTime());
console.log(now.getTimezoneOffset());

Что бы обратно превратить число миллисекунд в дату:
const noww = new Date(1610723430634);
console.log(noww);


Установка компонентов
set - такие же команды как и в get

const now = new Date('2021-01-15');
получается тоже самое, только используем метод()
new Date.parse('2021-01-15');

console.log(now.setHours(18));
console.log(now.setHours(18, 40)); // не всегда хорошо, так как тут часы
console.log(now);

console.log(now.setHours(40)); //Автоматически исправляет

	

let start = new Date();

for (let i = 0; i < 100000; i++) {
  let some = i ** 3;
}

let end = new Date();

alert(`Цыкл отработал за ${end - start} миллисекунд`);	
```	

  **[⬆ Наверх](#top)**
	
209. ### <a name="209"></a> 
	
	
  **[⬆ Наверх](#top)**
	
210. ### <a name="210"></a> Параметры документа, окна и работа с ними

document - это обьект который содержит всю нашу html структуру, только в более сложном варианте

window - окно в котором показывается документ 

screen - весь ваш видимый монитор, именно монитор

```js
const box = document.querySelector('.box'),
      btn = document.querySelector('button');

// const width = box.clientWidth;
// const height = box.clientHeight;

// const width = box.offsetWidth;
// const height = box.offsetHeight;

const width = box.scrollWidth;
const height = box.scrollHeight;

console.log(width, height);

btn.addEventListener('click', () => {
  // box.style.height = box.scrollHeight + 'px';

  console.log(box.scrollTop);
});


console.log(box.getBoundingClientRect());


console.log(box.getBoundingClientRect().top);


const style = window.getComputedStyle(box);

console.log(style);
console.log(style.display);


//window.getComputedStyle(box) - эти стили идут с CSS, они изначально появятся у нас на странице

//box.style.height = box.scrollHeight + 'px' - это инлайн стили, которые появляются внутри верстки и прописываются прямо в тэг. По правилам верстки они более приоритетней



// console.log(document.documentElement.clientWidth);

// console.log(document.documentElement.scrollTop);



// пишется в консоли =>

// от текущей позиции
window.scrollBy(0, 400);


// относительно всей страницы а не текущей страницы
window.scrollTo(0, 400);
```	

  **[⬆ Наверх](#top)**
	
211. ### <a name="211"></a> 
	

  **[⬆ Наверх](#top)**
	
212. ### <a name="212"></a> Разница между событиеми load и DOMContentLoaded

Разница между событиями `load` и `DOMContentLoaded` заключается в том, когда они срабатывают в жизненном цикле загружаемой страницы.

1. Событие `load`:
   Событие `load` срабатывает, когда вся страница, включая все ее ресурсы (такие как изображения, стили, скрипты), была полностью загружена и отображена в браузере. Оно указывает на то, что весь контент страницы доступен для манипуляций и взаимодействия.

   ```javascript
   window.addEventListener('load', function() {
     // Весь контент страницы полностью загружен
     // Можно выполнять операции с элементами страницы
   });
   ```

   Это событие часто используется для выполнения действий, которые требуют полной загрузки страницы, таких как манипуляции с DOM-элементами, инициализация плагинов, отправка аналитических данных и другие задачи, которые зависят от доступности всего контента страницы.

2. Событие `DOMContentLoaded`:
   Событие `DOMContentLoaded` срабатывает, когда вся структура DOM-дерева страницы была построена и доступна для манипуляций, не дожидаясь полной загрузки внешних ресурсов, таких как изображения или стили. Оно указывает на то, что структура HTML-разметки страницы полностью доступна.

   ```javascript
   document.addEventListener('DOMContentLoaded', function() {
     // Структура HTML-разметки страницы полностью доступна
     // Можно выполнять операции с DOM-элементами
   });
   ```

   Событие `DOMContentLoaded` обычно используется для выполнения операций, которые зависят только от доступности DOM-структуры, например, привязка обработчиков событий, инициализация интерфейсных компонентов или другие действия, которые не требуют полной загрузки ресурсов страницы.

Важно отметить, что событие `load` происходит после события `DOMContentLoaded`. То есть событие `DOMContentLoaded` срабатывает быстрее, так как оно ожидает только построения структуры DOM-дерева, в то время как событие `load` ожидает полной загрузки всех ресурсов страницы.

Выбор между использованием события `load` или `DOMContentLoaded` зависит от того, когда вам нужно начать выполнять операции на странице. Если вам необходим доступ к полному контенту страницы, включая внешние ресурсы, используйте событие `load`. Если вам нужно только

 получить доступ к структуре DOM-дерева и выполнить операции, которые не зависят от внешних ресурсов, используйте событие `DOMContentLoaded`.

  **[⬆ Наверх](#top)**
	
213. ### <a name="213"></a> Создаем табы в новом проекте

```js
window.addEventListener('DOMContentLoaded', () => {

  const tabs = document.querySelectorAll('.tabheader__item'),
        tabsContent = document.querySelectorAll('.tabcontent'),
        tabsParent = document.querySelector('.tabheader__items');

  function hideTabContent() {
    tabsContent.forEach(item => {
      item.classList.add('hide');
      item.classList.remove('show', 'fade');
    });

    tabs.forEach(item => {
      item.classList.remove('tabheader__item_active');
    });

  } 

  function showTabContent(i = 0) {
    tabsContent[i].classList.add('show', 'fade');
    tabsContent[i].classList.remove('hide');
    tabs[i].classList.add('tabheader__item_active');
  }

  hideTabContent();
  showTabContent();

  tabsParent.addEventListener('click', (event) => {
    const target = event.target;

    if (target && target.classList.contains('tabheader__item')) {
      tabs.forEach((item, i) => {
        if (target == item) {
          hideTabContent();
          showTabContent(i);
        }
      });
    }
  });

});	
```
	
  **[⬆ Наверх](#top)**	

214. ### <a name="214"></a> Создаем таймер обратного отсчета на сайте

```js
window.addEventListener('DOMContentLoaded', () => {

  // Timer

  const deadline = '2021-04-27';

  function getTimeRemaining(endtime) {
    const t = Date.parse(endtime) - Date.parse(new Date()),
      days = Math.floor(t / (1000 * 60 * 60 * 24)),
      hours = Math.floor((t / (1000 * 60 * 60)) % 24),
      minutes = Math.floor((t / 1000 / 60) % 60),
      seconds = Math.floor((t / 1000) % 60);

    return {
      total: t,
      days: days,
      hours: hours,
      minutes: minutes,
      seconds: seconds,
    };
  }

  function getZero(num) {
    if (num >= 0 && num < 10) {
      return `0${num}`;
    } else {
      return num;
    }
  }

  function setClock(selector, endtime) {
    const timer = document.querySelector(selector),
      days = timer.querySelector('#days'),
      hours = timer.querySelector('#hours'),
      minutes = timer.querySelector('#minutes'),
      seconds = timer.querySelector('#seconds'),
      timeInterval = setInterval(updateClock, 1000);

    updateClock();

    function updateClock() {
      const t = getTimeRemaining(endtime);

      days.innerHTML = getZero(t.days);
      hours.innerHTML = getZero(t.hours);
      minutes.innerHTML = getZero(t.minutes);
      seconds.innerHTML = getZero(t.seconds);

      if (t.total <= 0) {
        clearInterval(timeInterval);
      }
    }
  }

  setClock('.timer', deadline);
});	
```	

### Если таймер <= time то нужно вывести нули 0
```js
const deadline = '2021-04-27';

  function getTimeRemaining(endtime) {
    let days, hours, minutes, seconds;
    const t = Date.parse(endtime) - Date.parse(new Date());

    if (t <= 0) {
      days = 0;
      hours = 0;
      minutes = 0;
      seconds = 0;
    } else {
      days = Math.floor(t / (1000 * 60 * 60 * 24)),
      hours = Math.floor((t / (1000 * 60 * 60)) % 24),
      minutes = Math.floor((t / 1000 / 60) % 60),
      seconds = Math.floor((t / 1000) % 60);
    }
    
    return {
      total: t,
      days: days,
      hours: hours,
      minutes: minutes,
      seconds: seconds,
    };
  }

  function getZero(num) {
    if (num >= 0 && num < 10) {
      return `0${num}`;
    } else {
      return num;
    }
  }

  function setClock(selector, endtime) {
    const timer = document.querySelector(selector),
      days = timer.querySelector('#days'),
      hours = timer.querySelector('#hours'),
      minutes = timer.querySelector('#minutes'),
      seconds = timer.querySelector('#seconds'),
      timeInterval = setInterval(updateClock, 1000);

    updateClock();

    function updateClock() {
      const t = getTimeRemaining(endtime);

      days.innerHTML = getZero(t.days);
      hours.innerHTML = getZero(t.hours);
      minutes.innerHTML = getZero(t.minutes);
      seconds.innerHTML = getZero(t.seconds);

      if (t.total <= 0) {
        clearInterval(timeInterval);
      }
    }
  }

  setClock('.timer', deadline);		  
```
	
  **[⬆ Наверх](#top)**	

215. ### <a name="215"></a> Создаем модальное окно

### New Modal
```js
    // Modal

    const modalTrigger = document.querySelectorAll('[data-modal]'),
        modal = document.querySelector('.modal');

    modalTrigger.forEach(btn => {
        btn.addEventListener('click', openModal);
    });

    function closeModal() {
        modal.classList.add('hide');
        modal.classList.remove('show');
        document.body.style.overflow = '';
    }

    function openModal() {
        modal.classList.add('show');
        modal.classList.remove('hide');
        document.body.style.overflow = 'hidden';
        clearInterval(modalTimerId);
    }

    modal.addEventListener('click', (e) => {
        if (e.target === modal || e.target.getAttribute('data-close') == "") {
            closeModal();
        }
    });

    document.addEventListener('keydown', (e) => {
        if (e.code === "Escape" && modal.classList.contains('show')) { 
            closeModal();
        }
    });

    const modalTimerId = setTimeout(openModal, 300000);
    // Изменил значение, чтобы не отвлекало

    function showModalByScroll() {
        if (window.pageYOffset + document.documentElement.clientHeight >= document.documentElement.scrollHeight) {
            openModal();
            window.removeEventListener('scroll', showModalByScroll);
        }
    }
    window.addEventListener('scroll', showModalByScroll);	
```	
	
### Old Modal	
```js
window.addEventListener('DOMContentLoaded', () => {

  // Modal, Создание модального окна

  // тригеры - это те элементы которые вызывают последующие действия (кнопка: Связатся с нами)

  const modalTrigger = document.querySelectorAll('[data-modal]'),
        modal = document.querySelector('.modal'),
        modalCloseBtn = document.querySelector('[data-close]');

  modalTrigger.forEach(btn => {
    btn.addEventListener('click', () => {
      modal.classList.add('show');
      modal.classList.remove('hide');
  
      // еще можно toggle проверить
      // modal.classList.toggle('show');
  
      document.body.style.overflow = 'hidden';
    });
  });
  

  function closeModal() {
    modal.classList.add('hide');
    modal.classList.remove('show');
    document.body.style.overflow = '';
  }
  

  modalCloseBtn.addEventListener('click', closeModal);

  // еще можно toggle 
  // modal.classList.toggle('show');


  modal.addEventListener('click', (e) => {
    if (e.target === modal) {
      closeModal();
    }
  });


  document.addEventListener('keydown', (e) => {
    if (e.code === "Escape" && modal.classList.contains('show')) {
      closeModal();
    }
  });
  
});	
```	
Модификация модального окна	
```js
window.addEventListener('DOMContentLoaded', () => {

  // Modal, Создание модального окна


  // тригеры - это те элементы которые вызывают последующие действия

  const modalTrigger = document.querySelectorAll('[data-modal]'),
        modal = document.querySelector('.modal'),
        modalCloseBtn = document.querySelector('[data-close]');


  function openModal() {
    modal.classList.add('show');
    modal.classList.remove('hide');
    document.body.style.overflow = 'hidden';
    clearInterval(modalTimerId);
  }

  modalTrigger.forEach(btn => {
    btn.addEventListener('click', openModal);
  });
  

  function closeModal() {
    modal.classList.add('hide');
    modal.classList.remove('show');
    document.body.style.overflow = '';
  }
  

  modalCloseBtn.addEventListener('click', closeModal);


  // еще можно toggle проверить
  // modal.classList.toggle('show');

  // еще можно toggle 
  // modal.classList.toggle('show');


  modal.addEventListener('click', (e) => {
    if (e.target === modal) {
      closeModal();
    }
  });


  document.addEventListener('keydown', (e) => {
    if (e.code === "Escape" && modal.classList.contains('show')) {
      closeModal();
    }
  });


  const modalTimerId = setTimeout(openModal, 5000);


  function showModalByScroll() {
    if (window.pageYOffset + document.documentElement.clientHeight >= document.documentElement.scrollHeight) {
      openModal();
      window.removeEventListener('scroll', showModalByScroll);
    }
  }


  window.addEventListener('scroll', showModalByScroll);
  
});	
```
	
  **[⬆ Наверх](#top)**
	
216. ### <a name="216"></a> Создаем слайдер на сайте

```js
window.addEventListener('DOMContentLoaded', () => {

// Slider

  const slides = document.querySelectorAll('.offer__slide'),
        prev = document.querySelector('.offer__slider-prev'),
        next = document.querySelector('.offer__slider-next'),
        total = document.querySelector('#total'),
        current = document.querySelector('#current'),
        slidesWrapper = document.querySelector('.offer__slider-wrapper'),
        slidesField = document.querySelector('.offer__slider-inner'),
        width = window.getComputedStyle(slidesWrapper).width;
  
  let slideIndex = 1;
  let offset = 0;

  if (slides.length < 10) {
    total.textContent = `0${slides.length}`;
    current.textContent = `0${slideIndex}`;
  } else {
    total.textContent = slides.length;
    current.textContent = slideIndex;

  }

  slidesField.style.width = 100 * slides.length + '%';

  slidesField.style.display = 'flex';
  slidesField.style.transition = '0.5s all';

  slidesWrapper.style.overflow = 'hidden';


  slides.forEach(slide => {
    slide.style.width = width;
  });

  next.addEventListener('click', () => {  
    if (offset == +width.slice(0, width.length - 2) * (slides.length -1)) {
      offset = 0;
    } else {
      offset += +width.slice(0, width.length - 2);
    }

    slidesField.style.transform = `translateX(-${offset}px)`;

    if (slideIndex == slides.length) {
      slideIndex = 1;
    } else {
      slideIndex++;
    }

    if (slides.length < 10) {
      current.textContent = `0${slideIndex}`;
    } else {
      current.textContent = slideIndex;
    }
  });


  prev.addEventListener('click', () => {  
    if (offset == 0) {
      offset = +width.slice(0, width.length - 2) * (slides.length -1);
    } else {
      offset -= +width.slice(0, width.length - 2);
    }

    slidesField.style.transform = `translateX(-${offset}px)`;

    if (slideIndex == 1) {
      slideIndex = slides.length;
    } else {
      slideIndex--;
    }

    if (slides.length < 10) {
      current.textContent = `0${slideIndex}`;
    } else {
      current.textContent = slideIndex;
    }
  });
```

// Добавляем точки который работают синхронно со слайдером
 
```js
const slides = document.querySelectorAll('.offer__slide'),
        slider = document.querySelector('.offer__slider'),
        prev = document.querySelector('.offer__slider-prev'),
        next = document.querySelector('.offer__slider-next'),
        total = document.querySelector('#total'),
        current = document.querySelector('#current'),
        slidesWrapper = document.querySelector('.offer__slider-wrapper'),
        slidesField = document.querySelector('.offer__slider-inner'),
        width = window.getComputedStyle(slidesWrapper).width;
  
  let slideIndex = 1;
  let offset = 0;

  if (slides.length < 10) {
    total.textContent = `0${slides.length}`;
    current.textContent = `0${slideIndex}`;
  } else {
    total.textContent = slides.length;
    current.textContent = slideIndex;

  }

  slidesField.style.width = 100 * slides.length + '%';

  slidesField.style.display = 'flex';
  slidesField.style.transition = '0.5s all';

  slidesWrapper.style.overflow = 'hidden';


  slides.forEach(slide => {
    slide.style.width = width;
  });

  slider.style.position = 'relative';

  const indicators = document.createElement('ol'),
        dots = [];

  indicators.classList.add('carousel-indicators');
  indicators.style.cssText = `
    position: absolute;
    right: 0;
    bottom: 0;
    left: 0;
    z-index: 15;
    display: flex;
    justify-content: center;
    margin-right: 15%;
    margin-left: 15%;
    list-style: none;
  `;

  slider.append(indicators);

  for (let i = 0; i < slides.length; i++) {
    const dot = document.createElement('li');

    dot.setAttribute('data-slide-to', i + 1);
    dot.style.cssText = `
      box-sizing: content-box;
      flex: 0 1 auto;
      width: 30px;
      height: 6px;
      margin-right: 3px;
      margin-left: 3px;
      cursor: pointer;
      background-color: #fff;
      background-clip: padding-box;
      border-top: 10px solid transparent;
      border-bottom: 10px solid transparent;
      opacity: .5;
      transition: opacity .6s ease;
    `;

    if ( i == 0) {
      dot.style.opacity = 1;
    }

    indicators.append(dot);
    dots.push(dot);
  }

  function deleteNotDigits(str) {
    return +str.replace(/\D/g, '');
  }

  next.addEventListener('click', () => {  
    if (offset == deleteNotDigits(width) * (slides.length -1)) {
      offset = 0;
    } else {
      offset += deleteNotDigits(width);
    }

    slidesField.style.transform = `translateX(-${offset}px)`;

    if (slideIndex == slides.length) {
      slideIndex = 1;
    } else {
      slideIndex++;
    }

    if (slides.length < 10) {
      current.textContent = `0${slideIndex}`;
    } else {
      current.textContent = slideIndex;
    }

    dots.forEach(dot => dot.style.opacity = '.5');
    dots[slideIndex -1].style.opacity = 1;
  });


  prev.addEventListener('click', () => {  
    if (offset == 0) {
      offset = deleteNotDigits(width) * (slides.length -1);
    } else {
      offset -= deleteNotDigits(width);
    }

    slidesField.style.transform = `translateX(-${offset}px)`;

    if (slideIndex == 1) {
      slideIndex = slides.length;
    } else {
      slideIndex--;
    }

    if (slides.length < 10) {
      current.textContent = `0${slideIndex}`;
    } else {
      current.textContent = slideIndex;
    }

    dots.forEach(dot => dot.style.opacity = '.5');
    dots[slideIndex -1].style.opacity = 1;
  });

  dots.forEach(dot => {
    dot.addEventListener('click', (e) => {
      const slideTo = e.target.getAttribute('data-slide-to');

      slideIndex = slideTo;
      offset = deleteNotDigits(width) * (slideTo -1);

      slidesField.style.transform = `translateX(-${offset}px)`;

      if (slides.length < 10) {
        current.textContent = `0${slideIndex}`;
      } else {
        current.textContent = slideIndex;
      }

      dots.forEach(dot => dot.style.opacity = '.5');
      dots[slideIndex -1].style.opacity = 1;
    });
  });
```


// Slider - простой вариант
```js
  showSlides(slideIndex);

  if (slides.length < 10) {
    total.textContent = `0${slides.length}`;
  } else {
    total.textContent = slides.length;
  }

  function showSlides(n) {
    if (n > slides.length) {
      slideIndex = 1;
    }

    if (n < 1) {
      slideIndex = slides.length;
    }

    slides.forEach(item => item.style.display = 'none');

    slides[slideIndex - 1].style.display = 'block';

    if (slides.length < 10) {
      current.textContent = `0${slideIndex}`;
    } else {
      current.textContent = slideIndex;
    }
  }

  function plusSlides(n) {
    showSlides(slideIndex += n);
  }

  prev.addEventListener('click', () => {
    plusSlides(-1);
  });

  next.addEventListener('click', () => {
    plusSlides(1);
  });	
```
	
  **[⬆ Наверх](#top)**
	
217. ### <a name="217"></a> Создаем калькулятор на сайте

```js
window.addEventListener('DOMContentLoaded', function() {

// Calculator

const result = document.querySelector('.calculating__result span');
let sex = 'female',
    height, weight, age,
    ratio = 1.375;

function calcTotal() {
    if (!sex || !height || !weight || !age || !ratio) {
        result.textContent = '____'; // Можете придумать что угодно
        return;
    }
    if (sex === 'female') {
        result.textContent = Math.round((447.6 + (9.2 * weight) + (3.1 * height) - (4.3 * age)) * ratio);
    } else {
        result.textContent = Math.round((88.36 + (13.4 * weight) + (4.8 * height) - (5.7 * age)) * ratio);
    }
}

calcTotal();

function getStaticInformation(parentSelector, activeClass) {
    const elements = document.querySelectorAll(`${parentSelector} div`);

    elements.forEach(elem => {
        elem.addEventListener('click', (e) => {
            if (e.target.getAttribute('data-ratio')) {
                ratio = +e.target.getAttribute('data-ratio');
            } else {
                sex = e.target.getAttribute('id');
            }

            elements.forEach(elem => {
                elem.classList.remove(activeClass);
            });

            e.target.classList.add(activeClass);

            calcTotal();
        });
    });
}

getStaticInformation('#gender', 'calculating__choose-item_active');
getStaticInformation('.calculating__choose_big', 'calculating__choose-item_active');

function getDynamicInformation(selector) {
    const input = document.querySelector(selector);

    input.addEventListener('input', () => {
        switch(input.getAttribute('id')) {
            case "height":
                height = +input.value;
                break;
            case "weight":
                weight = +input.value;
                break;
            case "age":
                age = +input.value;
                break;
        }

        calcTotal();
    });
}

getDynamicInformation('#height');
getDynamicInformation('#weight');
getDynamicInformation('#age');
  
});	
```	

### Улучшаем калькулятор, делаем практичным

```js
const result = document.querySelector('.calculating__result span');
    
    let sex, height, weight, age, ratio;

    if (localStorage.getItem('sex')) {
        sex = localStorage.getItem('sex');
    } else {
        sex = 'female';
        localStorage.setItem('sex', 'female');
    }

    if (localStorage.getItem('ratio')) {
        ratio = localStorage.getItem('ratio');
    } else {
        ratio = 1.375;
        localStorage.setItem('ratio', 1.375);
    }

    function calcTotal() {
        if (!sex || !height || !weight || !age || !ratio) {
            result.textContent = '____';
            return;
        }
        if (sex === 'female') {
            result.textContent = Math.round((447.6 + (9.2 * weight) + (3.1 * height) - (4.3 * age)) * ratio);
        } else {
            result.textContent = Math.round((88.36 + (13.4 * weight) + (4.8 * height) - (5.7 * age)) * ratio);
        }
    }

    calcTotal();

    function initLocalSettings(selector, activeClass) {
        const elements = document.querySelectorAll(selector);

        elements.forEach(elem => {
            elem.classList.remove(activeClass);
            if (elem.getAttribute('id') === localStorage.getItem('sex')) {
                elem.classList.add(activeClass);
            }
            if (elem.getAttribute('data-ratio') === localStorage.getItem('ratio')) {
                elem.classList.add(activeClass);
            }
        });
    }

    initLocalSettings('#gender div', 'calculating__choose-item_active');
    initLocalSettings('.calculating__choose_big div', 'calculating__choose-item_active');

    function getStaticInformation(selector, activeClass) {
        const elements = document.querySelectorAll(selector);

        elements.forEach(elem => {
            elem.addEventListener('click', (e) => {
                if (e.target.getAttribute('data-ratio')) {
                    ratio = +e.target.getAttribute('data-ratio');
                    localStorage.setItem('ratio', +e.target.getAttribute('data-ratio'));
                } else {
                    sex = e.target.getAttribute('id');
                    localStorage.setItem('sex', e.target.getAttribute('id'));
                }
    
                elements.forEach(elem => {
                    elem.classList.remove(activeClass);
                });
    
                e.target.classList.add(activeClass);
    
                calcTotal();
            });
        });
    }

    getStaticInformation('#gender div', 'calculating__choose-item_active');
    getStaticInformation('.calculating__choose_big div', 'calculating__choose-item_active');

    function getDynamicInformation(selector) {
        const input = document.querySelector(selector);

        input.addEventListener('input', () => {
            if (input.value.match(/\D/g)) {
                input.style.border = "1px solid red";
            } else {
                input.style.border = 'none';
            }
            switch(input.getAttribute('id')) {
                case "height":
                    height = +input.value;
                    break;
                case "weight":
                    weight = +input.value;
                    break;
                case "age":
                    age = +input.value;
                    break;
            }

            calcTotal();
        });
    }

    getDynamicInformation('#height');
    getDynamicInformation('#weight');
    getDynamicInformation('#age');
```
	
  **[⬆ Наверх](#top)**
	
218. ### <a name="218"></a> 


	
  **[⬆ Наверх](#top)**
	
219. ### <a name="219"></a> 


	
  **[⬆ Наверх](#top)**
	
220. ### <a name="220"></a> 


	
  **[⬆ Наверх](#top)**
	
221. ### <a name="221"></a> 


	
  **[⬆ Наверх](#top)**
	
222. ### <a name="222"></a> 


	
  **[⬆ Наверх](#top)**	
	
300. ### <a name="300"></a> Функции-конструкторы

Функции-конструкторы в JavaScript - это специальный тип функций, который используется для создания новых объектов с заданными свойствами и методами.

Для создания функции-конструктора используется ключевое слово `function`, за которым следует имя функции. Обычно имя функции-конструктора начинается с заглавной буквы, чтобы указать на то, что она должна вызываться с использованием оператора `new`. Внутри функции-конструктора можно определить свойства и методы объекта, используя ключевое слово `this`.

Пример функции-конструктора:

```javascript
function Person(name, age) {
  this.name = name;
  this.age = age;
  
  this.greet = function() {
    console.log('Hello, my name is ' + this.name);
  };
}

// Создание нового объекта с использованием функции-конструктора
var person1 = new Person('John', 30);
var person2 = new Person('Jane', 25);

// Доступ к свойствам и вызов методов объектов
console.log(person1.name); // 'John'
console.log(person2.age); // 25
person1.greet(); // 'Hello, my name is John'
person2.greet(); // 'Hello, my name is Jane'
```

При вызове функции-конструктора с использованием оператора `new`, создается новый объект, для которого `this` указывает на этот объект. Затем свойства и методы задаются с использованием `this`. Каждый созданный объект будет иметь собственные независимые копии свойств и методов.

Функции-конструкторы обычно используются в JavaScript для создания объектов с общими свойствами и методами. Они предоставляют возможность создавать множество объектов с одним и тем же набором функциональности.		

https://learn.javascript.ru/constructor-new	
	
  **[⬆ Наверх](#top)**
	
301. ### <a name="301"></a> Контекст вызова this

1) Обычная функция: this = window, но если use strict - undefined 
2) Контекст у методов обьекта - сам обьект
3) this в конструкторах и классах - это новый экземпляр обьекта
4) Ручная привязка this: call, apply, bind	
	
	
### 1) Обычная функция: this = window, но если use strict - undefined	
```js
function showThis() {
  console.log(this);
}

showThis(); // Window или undefined
```


Даже если у нас используется функция внутри функции то контекст у нее не меняется, он все равно будет Window или undefined
```js
function showThis(a, b) {
  console.log(this); // undefined
  function sum() {
    console.log(this); // undefined

    // return this.a + this.b;

    // или вот вариант c замыканием которая обращается к родительской функции showThis(a, b) которая равняется showThis(4, 5);

    return a + b;
  }

  console.log(sum()); // 9
}

showThis(4, 5);
```

### 2) Контекст у методов обьекта - сам обьект, и если мы используем стрелочную функцию в методе обьекта она будет равнятся самому обьекту	
```js
const obj2 = {
  a: 20,
  b: 15,
  sum: function() {
      console.log(this) // {a: 20, b: 15, sum: ƒ}

    function shout2() {
      console.log(this); // undefined
    }

    const shout = () => {
      console.log(this) // {a: 20, b: 15, sum: ƒ}
    }

    shout2();	
    shout();
  }
};

obj2.sum();
```	
	
### Прмер стрелочной функции в методе обьекта		
```js
const obj = {
  num: 5,
  sayNumber: function() {
    const say = () => {
      console.log(this); // {num: 5, sayNumber: ƒ}
      console.log(this.num) // 5
    };

    say();
  }
};

obj.sayNumber();	
```	

Example
```js
const obj = {
  a: 20,
  b: 15,
  shout() {
    console.log(this); // {a: 20, b: 15, shout: ƒ}
  },
};

obj.shout();	
```
	
Example
```js
const obj = {
  a: 20,
  b: 15,
  shout() {
    console.log(this); // {a: 20, b: 15, shout: ƒ}

    const arrowFunc = () => {
      console.log(this); // {a: 20, b: 15, shout: ƒ}
    }
    arrowFunc();
  },
};

obj.shout();	
```		

### 3) this в конструкторах и классах - это новый экземпляр обьекта
```js	
function User(name, id) {
  this.name = name;
  this.id = id;
  this.human = true;
  this.hello = function() {
    console.log('Hello! ' + this.name);
  }
}
let ivan = new User('Ivan', 23, true);

console.log(ivan.hello())  // Hello! Ivan
console.log(ivan.id) // 23
```

Class example
```js
class User {
  constructor(name, id) {
    this.name = name;
    this.id = id;
    this.human = true;
  }
  hello() {
    console.log(`Hello! ${this.name}`)
  }
  exit() {
     console.log(`Пользователь ${this.name} ушел`)
  }
}

const ivan = new User('Ivan', 28);
const alex = new User('Alex', 20);

console.log(ivan);
console.log(alex);

ivan.hello();
alex.hello();    

ivan.exit();	
```	
	
### 4) Ручная привязка this: call, apply, bind
```js	
function sayName(surname) {
  console.log(this); // {name: 'John'}
  console.log(this.name + surname); // John Smith
}

const user = {
  name: 'John'
};

sayName.call(user, ' Smith');
sayName.apply(user, [' Smith']);
```

```js
function count(num) {
  return this * num;
}

const double = count.bind(2);

console.log(double(3)); // 6
console.log(double(13)); // 26
```


### Пример	
```js
const btn = document.querySelector('button');

btn.addEventListener('click', function() {
  // console.log(this); // <button>click</button>
  this.style.backgroundColor = 'red';
});


// Если же мы используем стрелочную ф-цию - то контекст вызова теряеться, мы уже его использовать не можем. this = undefined(если есть 'use strict') или Window
	
btn.addEventListener('click', () => {
  console.log(this)
  this.style.backgroundColor = 'red';
});


// тоже самое только с обработчиком события вместо this

btn.addEventListener('click', (e) => {
  e.target.style.backgroundColor = 'red';
});
```

Когда у нас обработчик событий который идет как callback функция, написан в классическом режиме (function() {}) в таком случае наш контекст вызова будет сам элемент на котором произошло событие

В обработчиках событий когда мы используем обычный синтаксис через function - мы имеем доступ к this.

	
### Метозы привязки контекста

```jsx harmony
 function hello() {
  console.log('Hello', this)
}

console.log(hello()) //window

const person = {
  name: 'Spacy',
  age: 30,
  sayHello: hello,
  sayHelloWindow: hello.bind(window), // window
  // sayHelloWindow: hello.bind(document) // documtnt
  logInfo: function(job, phone) {
    console.group(`${this.name} info:`);
    console.log(`Name is ${this.name}`);
    console.log(`Age is ${this.age}`);
    console.log(`Job is ${job}`);
    console.log(`Phone is ${phone}`);
    console.groupEnd();
  }
}

const lena = {
  name: 'Elena',
  age: 25,
}

console.log(person) // {name: "Spacy", age: 30, sayHello: ƒ}

console.log(person.sayHello()) // Hello {name: "Spacy", age: 30, sayHello: ƒ}

console.log(person.sayHelloWindow()); // Hello Window {window: Window, self: Window, document: document, name: "", location: Location, …}

console.log(this === window) //true

console.log(person.logInfo())

console.log(person.logInfo('FRFR', '432523'))

console.log(person.logInfo.bind(lena)())


// метод bind()- возвращает нам новую функцию, и ее мы можем вызвать в любое время
person.logInfo.bind(lena, 'Frontend', '073-23-12-421')();

// метод call() - задает определенный контекст функции и какие-то параметры через запятую перечисленные, и вызывает функцию сразу
person.logInfo.call(lena, 'Frontend', '073-23-12-421');

// // метод apply() сразу вызовет эту функцию
person.logInfo.apply(lena, ['Frontend', '073-23-12-421'])
```

### Задача: Прототипы и this
```js
const array = [1, 2, 3, 4, 5]

Array.prototype.multBy = function(n) {
  return this.map(function(i) {
    return i * n
  })
}

console.log(array.multBy(2)) // [2, 4, 6, 8, 10]


const arr2 = [1, 2, 5].multBy(3)
console.log(arr2) // [3, 6, 15]	
```	
 
### Методы привязки контекста 2: bind, call, apply <a name="Metody_privyazki_konteksta_2"></a>

Метод bind() создаёт новую функцию, которая при вызове устанавливает в качестве контекста выполнения this предоставленное значение. В метод также передаётся набор аргументов, которые будут установлены перед переданными в привязанную функцию аргументами при её вызове.

Метод call() вызывает функцию с указанным значением this и индивидуально предоставленными аргументами. Функция call() принимает список аргументов	
	
Метод apply() вызывает функцию с указанным значением this и аргументами, предоставленными в виде массива (либо массивоподобного объекта ). Функция apply() принимает единичный массив аргументов
	
	
```jsx harmony 
 const auto = {
	brand: 'BMW',
	drive() {
		console.log(this) // {brand: "BMW", drive: ƒ}
		return `Заведем наш ${this.brand}`
	}
}

const motorBike = {
	brand: 'Suzuki'
}

console.log(auto.drive()); // Заведем наш BMW

// const autoDrive = auto.drive;

// console.log(autoDrive()) // Заведем наш undefined
```
 
// bind
```jsx harmony
const autoDrive = auto.drive.bind(auto);

console.log(autoDrive()) // Заведем наш BMW


const motorDrive = auto.drive.bind(motorBike)

const motorDrive1 = auto.drive.bind({brand: 'Корабль'});

console.log(motorDrive()); // Заведем наш Suzuki

console.log(motorDrive1()); // Заведем наш Корабль
```
 
// !
```jsx harmony
const $ = document.querySelector.bind(document);

console.log($ === document.querySelector);

const header = $('h2')
console.log(header);
```

// !
```jsx harmony
const bill = {
	tip: 0.1,
	calculate(total) {
		console.log(this);
		return total + total * this.tip;
	}
}

// const pay = bill.calculate(1000);
// console.log(pay); // 1100

const payCount = bill.calculate.bind(bill);

console.log(payCount(1000)); // 1100


const payCount2 = bill.calculate.bind({tip: 0.2}, 1000);

console.log(payCount2()); // 1200
```

// call apply
```jsx harmony
const bill2 = {
	tip: 0.1,
	calculate(total) {
		console.log(this);
		return total + total * this.tip;
	}
}


const payBind = bill2.calculate.bind(bill);

console.log(payBind(1000)); // 1100


const payCountCall = bill2.calculate.call(bill2, 1000);

console.log(payCountCall); // 1100


const payCountApply = bill2.calculate.apply(bill2, [1000]);

console.log(payCountApply); // 1100
```

// контекст привязывается один раз, и мы не можем повторно его привязать


// 
```jsx harmony
const bill3 = {
	tip: 0.1,
	calculate(total) {
		console.log(this);
		return total + total * this.tip;
	},
	detail(dish1, dish2, sum) {
		return `Ваш обед ${dish1}, ${dish2} стоит ${this.calculate((sum))}`
	}
}

const a = bill3.detail('pizza', 'salad', 1000);

const b = bill3.detail.call(bill3, 'pizza', 'salad', 1000);

const c = bill3.detail.apply(bill, ['pizza', 'salad', 1000]);


console.log(a); //Ваш обед pizza, salad стоит 1100
console.log(b); //Ваш обед pizza, salad стоит 1100
console.log(c); //Ваш обед pizza, salad стоит 1100
```

  **[⬆ Наверх](#top)**
	
302. ### <a name="302"></a> Классы (ES6)

Классы в JavaScript - это специальный синтаксический сахар, введенный в ECMAScript 2015 (ES6), который позволяет создавать объекты на основе шаблонов с заданными свойствами и методами. Классы представляют собой более удобный и понятный способ работы с прототипами и наследованием в JavaScript.

Для создания класса используется ключевое слово `class`, за которым следует имя класса, обычно с заглавной буквы. Внутри класса можно определить конструктор и другие методы, используя синтаксис обычных функций.

Пример создания класса:

```javascript
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
  
  greet() {
    console.log(`Hello, my name is ${this.name}`);
  }
}

// Создание объекта на основе класса
const person = new Person('John', 30);

// Доступ к свойствам и вызов методов объекта
console.log(person.name); // 'John'
console.log(person.age); // 30
person.greet(); // 'Hello, my name is John'
```

Классы позволяют определять конструктор с помощью метода `constructor()`, который вызывается при создании нового объекта на основе класса. Внутри конструктора можно инициализировать свойства объекта. Остальные методы класса определяются непосредственно внутри класса без необходимости использовать ключевое слово `function`. Также классы поддерживают статические методы и наследование.

Классы в JavaScript основаны на прототипах и внутри JavaScript движка преобразуются в прототипное наследование. Они предоставляют более понятный и декларативный способ создания и работы с объектами.	
	
У функций-стрелок нет своего this и super, поэтому они «прозрачно» встраиваются во внешний контекст.

  **[⬆ Наверх](#top)**
	
303. ### <a name="303"></a> Наследование классов. Private, protected свойства

В JavaScript наследование классов реализуется с помощью ключевого слова `extends`. При объявлении класса, который наследует другой класс, используется синтаксис `class ChildClass extends ParentClass`.

Пример наследования классов:

```javascript
class Animal {
  constructor(name) {
    this.name = name;
  }
  
  eat() {
    console.log(`${this.name} is eating.`);
  }
}

class Cat extends Animal {
  constructor(name, breed) {
    super(name);
    this.breed = breed;
  }
  
  meow() {
    console.log(`${this.name} says meow.`);
  }
}

const cat = new Cat('Fluffy', 'Persian');
cat.eat(); // Output: Fluffy is eating.
cat.meow(); // Output: Fluffy says meow.
console.log(cat.name); // Output: Fluffy
console.log(cat.breed); // Output: Persian
```

Ключевое слово `super` используется в конструкторе производного класса для вызова конструктора родительского класса и передачи аргументов.

Относительно приватных и защищенных свойств, JavaScript не имеет явного синтаксиса для объявления таких свойств, как это есть, например, в языке Java. Вместо этого, существуют соглашения об именовании и паттерны, которые помогают указать на приватность или защищенность свойств.

Приватные свойства обычно именуются с использованием префикса `_`, чтобы указать, что они не предназначены для прямого доступа извне класса. Однако это не предотвращает фактический доступ к ним.

Пример приватного свойства:

```javascript
class MyClass {
  constructor() {
    this._privateProperty = 42;
  }
  
  get privateProperty() {
    return this._privateProperty;
  }
  
  set privateProperty(value) {
    this._privateProperty = value;
  }
}

const instance = new MyClass();
console.log(instance.privateProperty); // Output: 42
instance.privateProperty = 24;
console.log(instance.privateProperty); // Output: 24
```

Защищенные свойства обычно именуются с использованием префикса `_`, за которым следует один или несколько символов `_` (например, `__protectedProperty`), чтобы указать, что они предназначены для внутреннего использования внутри класса и его наследников. Однако это всего лишь соглашение об именовании, и доступ к защищенным свойствам также возможен извне класса.

Пример защищенного свойства:

```javascript
class MyBaseClass {
  constructor() {
    this._protectedProperty = 'protected';
  }
}

class MyDerivedClass extends MyBaseClass {
  logProtectedProperty() {
    console.log(this._protectedProperty);
  }
}

const instance = new MyDerivedClass();
instance

.logProtectedProperty(); // Output: protected
```

Важно отметить, что эти соглашения об именовании и паттерны не обеспечивают полную приватность или защищенность свойств в JavaScript. Они служат скорее для информационных целей и обозначения намерений, а не для строгого контроля доступа.	
		
  **[⬆ Наверх](#top)**
	
304. ### <a name="304"></a> setTimeout и setInterval скрипты и время их выполнения

Мы можем вызвать функцию не в данный момент, а позже, через заданный интервал времени. Это называется «планирование вызова».

Для этого существуют два метода:

- setTimeout позволяет вызвать функцию один раз через определённый интервал времени.
- setInterval позволяет вызывать функцию регулярно, повторяя вызов через определённый интервал времени.

### setTimeout
```js
function sayHi() {
  alert('Привет');
}

setTimeout(sayHi, 1000);
```
С аргументами:
```js
function sayHi(phrase, who) {
  alert( phrase + ', ' + who );
}

setTimeout(sayHi, 1000, "Привет", "Джон"); // Привет, Джон
```
Это также будет работать:
```js
setTimeout("alert('Привет')", 1000);
```
Но использование строк не рекомендуется. Вместо этого используйте функции. Например, так:
```js
setTimeout(() => alert('Привет'), 1000);
```

### Отмена setTimeout
```js
let timerId = setTimeout(...);
clearTimeout(timerId);
```
В коде ниже планируем вызов функции и затем отменяем его (просто передумали). В результате ничего не происходит:
```js
let timerId = setTimeout(() => alert("ничего не происходит"), 1000);
alert(timerId); // идентификатор таймера

clearTimeout(timerId);
alert(timerId); // тот же идентификатор (не принимает значение null после отмены)
```

### setInterval
```js
// повторить с интервалом 2 секунды
let timerId = setInterval(() => alert('tick'), 2000);

// остановить вывод через 5 секунд
setTimeout(() => { clearInterval(timerId); alert('stop'); }, 5000);
```
```js
clearInterval(timerId);
```
// Пример
```js
const timerId = setTimeout(function() {
  console.log('Hello');
}, 2000);


const timerId = setTimeout(function(text) {
  console.log(text);
}, 2000, 'Hello');



const timerId = setTimeout(logger, 2000);

function logger() {
  console.log('text');
}


const timerId = setTimeout(logger, 2000);

clearInterval(timerId);

function logger() {
  console.log('text');
}


const btn = document.querySelector('.btn');
let timerId,
    i = 0;

btn.addEventListener('click', () => {
  // const timerId = setTimeout(logger, 2000);

  timerId = setInterval(logger, 500);
});

function logger() {
  if (i === 3) {
    clearInterval(timerId);
  }
  console.log('text');
  i++;
}


// Рекурсивный вызов setTimeout, она будет вызыватся точно через 500мс и после 500мс = 1сек

let id = setTimeout(function log() {
  console.log('Hello');
  id = setTimeout(log, 500);
}, 500);


//банальная анимация

const btn = document.querySelector('.btn');
let timerId,
    i = 0;

function myAnimation() {
  const elem = document.querySelector('.box');
  let pos = 0;

  const id = setInterval(frame, 10);
  function frame() {
    if (pos == 300) {
      clearInterval(id);
    } else {
      pos++;
      elem.style.top = pos + 'px';
      elem.style.left = pos + 'px';
    }
  }
}

btn.addEventListener('click', myAnimation);	
```		
	
  **[⬆ Наверх](#top)**	
	
305. ### <a name="305"></a> JSON

__JSON, JavaScript Object Notation__ — текстовый формат обмена данными, основанный на JavaScript.

JSON представляет собой (в закодированном виде) одну из двух структур:

+ _Набор пар «ключ:значение»_;
+ _Упорядоченный набор значений_.

Ключом может быть только строка (регистрозависимая: имена с буквами в разных регистрах считаются разными).

В качестве значений могут быть использованы:

+ _Объект_ — неупорядоченное множество пар «ключ:значение», заключённое в фигурные скобки `{ }`. Ключ описывается строкой, между ним и значением стоит символ `:`. Пары ключ-значение отделяются друг от друга запятыми;
+ _Массив (одномерный)_ — упорядоченное множество значений. Массив заключается в квадратные скобки `[ ]`. Значения разделяются запятыми.
+ _Число_;
+ _Литералы_ `true`, `false` и `null`;
+ _Строка_ — упорядоченное множество из нуля или более символов Unicode, заключенное в кавычки `" "`. Символы могут быть указаны с использованием escape-последовательностей, начинающихся с обратной косой черты `\`, или записаны шестнадцатеричным кодом в кодировке UTF-8 в виде `\uFFFF`.	
	
JSON (JavaScript Object Notation) – это общий формат для представления значений и объектов.	
	
`JSON.stringify()` для преобразования объектов в JSON.
	
`JSON.parse()` для преобразования JSON обратно в объект.	
	
```js	
const persone = {
  name: 'Alex',
  tel: '+38023343535'
};

console.log(JSON.stringify(persone)); // {"name":"Alex","tel":"+38023343535"}
	
console.log(JSON.parse(JSON.stringify(persone))); // { name: 'Alex', tel: '+38023343535' }
```	
	
  **[⬆ Наверх](#top)**
	
306. ### <a name="306"></a> AJAX и XMLHttpRequest (общение с сервером)

Ajax (асинхронный JavaScript и XML) - это набор методов веб-разработки, использующих множество веб-технологий на стороне клиента для создания асинхронных веб-приложений. С помощью Ajax веб-приложения могут отправлять данные на сервер и получать их с сервера асинхронно (в фоновом режиме), не влияя на отображение и поведение открытой страницы. Отделяя уровень обмена данными от уровня представления, Ajax позволяет веб-страницам и, в частности, веб-приложениям динамически изменять содержимое без необходимости перезагрузки всей страницы. На практике для получения/передачи данных используется формат данных JSON вместо XML из-за того, что JSON основан на JavaScript.

Раньше для асинхронного взаимодействия использовали XMLHttpRequest API, а сейчас принято использовать fetch API.	

__AJAX, Asynchronous Javascript and XML (Асинхронный Javascript и XML)__ — подход к построению интерактивных пользовательских интерфейсов web-приложений, заключающийся в «фоновом» обмене данными браузера и web-сервера. В результате, при обновлении данных web-страница не перезагружается полностью и web-приложения становятся быстрее и удобнее.

При использовании AJAX:

1. Пользователь заходит на web-страницу и взаимодействует с каким-нибудь её элементом.
2. Скрипт на языке JavaScript определяет, какая информация необходима для обновления страницы.
3. Браузер отправляет соответствующий запрос на web-сервер.
4. Web-сервер возвращает только ту часть документа, на которую пришёл запрос.
5. Скрипт вносит изменения с учётом полученной информации (без полной перезагрузки страницы).

AJAX базируется на двух основных принципах:

1. использование технологии динамического обращения к серверу «на лету» (без перезагрузки страницы полностью) через динамическое создание:
    + _дочерних фреймов_;
    + _тега `<script>`_;
    + _тега `<img>`_.
2. использование _DHTML_ для динамического изменения содержания страницы;

AJAX не является самостоятельной технологией, это концепция использования нескольких смежных технологий:

+ _(X)HTML_, _CSS_ для подачи и стилизации информации;
+ _DOM-модель_, операции над которой производятся Javascript на стороне клиента, для обеспечения динамического отображения и взаимодействия с информацией;
+ _XMLHttpRequest_ или другой транспорт (_IFrame_, _SCRIPT-тег_, _..._) для асинхронного обмена данными с web-сервером;
+ _JSON_ или любой другой подходящий формат (_форматированный HTML_, _текст_, _XML_, _..._) для обмена данными.	

Под AJAX подразумевают любое общение с сервером без перезагрузки страницы, организованное при помощи JavaScript.

### Как это работает?
	
Помните, что технология AJAX не является ни единой технологией, ни языком программирования. Как уже говорилось ранее, AJAX — это набор методов веб-разработки. Система обычно состоит из:

HTML/XHTML для основного языка и CSS для презентации.
Объектная модель документа (DOM) для динамического отображения данных и их взаимодействия.
XML для обмена данными и XSLT для их управления. Многие разработчики начали заменять JSON, потому что он ближе по форме к JavaScript.
Объект XMLHttpRequest для асинхронного взаимодействия.
Наконец, язык программирования JavaScript, чтобы объединить все эти технологии.
Вам могут понадобиться некоторые технические знания, чтобы понять это полностью. Однако общая процедура работы AJAX довольно проста. Посмотрите на диаграмму и таблицу ниже для дальнейшего сравнения.	

![2](https://user-images.githubusercontent.com/80325645/137638460-ee4a4f3f-3e08-4987-80d1-24b47e02c490.jpg

Сравнительная таблица:
	
Обычная модель	AJAX модель
	
- HTTP-запрос отправляется с веб-браузера на сервер.
- Сервер получает и впоследствии извлекает данные.
- Сервер отправляет запрошенные данные в веб-браузер.
- Веб-браузер получает данные и перезагружает страницу для отображения данных.
	
Во время этого процесса у пользователей нет выбора, кроме как ждать, пока весь процесс не будет завершён. Это не только отнимает много времени, но и создаёт ненужную нагрузку на сервер.	

	
AJAX это набор методов веб-разработки, которые позволяют веб-приложениям работать асинхронно — обрабатывать любые запросы к серверу в фоновом режиме.		
	
### XMLHttpRequest GET запрос, json 	
```js
window.addEventListener('DOMContentLoaded', () => {

  function req() {

    const request = new XMLHttpRequest();
    request.open('GET', 'http://localhost:3000/people');
    request.setRequestHeader('Content-type', 'application/json; charset=utf-8');
    request.send();
    request.addEventListener('readystatechange', function() {
      if (request.readyState === 4 && request.status == 200) {
        let data = JSON.parse(request.response);
        console.log(data);

        data.forEach(item => {
          let card = document.createElement('div');
    
          card.classList.add('card');
    
          let icon;
    
          if (item.sex === 'male') {
            icon = "icons/mars.png"
          } else {
            icon = "icons/female.png"
          }
    
          card.innerHTML = `
            <img src="${item.photo}" alt="photo">
            <div class="name">${item.name} ${item.surname}</div>
            <div class="sex">
              <img src=${icon} alt="male">
            </div>
            <div class="age">${item.age}</div>
          `;
          document.querySelector('.app').appendChild(card);
        });
        
      } else {
        console.error('Что-то пошло не так...')
      }
    })

    this.remove();
  }

  document.querySelector('button').addEventListener('click', req, {once: true});

});	
```	
	
### Пример XMLHttpRequest GET запрос, json
```js
const inputUah = document.querySelector('#uah'),
      inputUsd = document.querySelector('#usd');

inputUah.addEventListener('input', () => {
  const request = new XMLHttpRequest();

  request.open('GET', 'js/current.json');
  request.setRequestHeader('Content-type', 'application/json; charset = utf-8');
  request.send();

  
  // request.addEventListener('readystatechange', () => {
  //   if (request.readyState === 4 && request.status === 200) {
  //     console.log(request.response);
  //     const data = JSON.parse(request.response);
  //     inputUsd.value = (+inputUah.value / data.current.usd).toFixed(2);
  //   } else {
  //     inputUsd.value = 'Что-то пошло не так';
  //   }

  // });


  request.addEventListener('load', () => {
    if (request.status === 200) {
      const data = JSON.parse(request.response);
      inputUsd.value = (+inputUah.value / data.current.usd).toFixed(2);
    } else {
      inputUsd.value = 'Что-то пошло не так';
    }

  });


  // status - 404, 200
  // statusText - ok, not found
  // response - ответ от сервера
  // readyState - текущее состояние запроса

});	
```		

### Пример XMLHttpRequest POST запрос, json и formData, реализация скрипта отправки данных на сервер	
```js
const forms = document.querySelectorAll('form');
  const message = {
    loading: 'Загрузка...',
    success: 'Спасибо! Скоро мы с вами свяжемся',
    failure: 'Что-то пошло не так...'
  };

  forms.forEach(item => {
    postData(item);
  });

  function postData(form) {
    form.addEventListener('submit', (e) => {
      e.preventDefault();

      let statusMessage = document.createElement('div');
      statusMessage.classList.add('status');
      statusMessage.textContent = message.loading;
      form.appendChild(statusMessage);
  
      const request = new XMLHttpRequest();
      request.open('POST', 'server.php');
      
      // для json =>
	
      request.setRequestHeader('Content-type', 'application/json');

      // когда мы используем связку XMLHttpRequest обьекта + form-data, нам заголовок устанавливать не нужно, он устанавливается автоматически
      
      const formData = new FormData(form);

	// для json =>	
	
      const object = {};
      formData.forEach(function(value, key){
          object[key] = value;
      });
      const json = JSON.stringify(object);

      request.send(json);
	
	// для formData =>
	
      // request.send(formData);		

      request.addEventListener('load', () => {
          if (request.status === 200) {
              console.log(request.response);
              statusMessage.textContent = message.success;
              form.reset();
              setTimeout(() => {
                  statusMessage.remove();
              }, 2000);
          } else {
              statusMessage.textContent = message.failure;
          }
      });
    });
  }	
```	
```js
<?php
$_POST = json_decode( file_get_contents("php://input"), true );
echo var_dump($_POST);

// как на php коде получить json данные и с ними поработать <=	
```	

### XMLHttpRequest с json, POST запрос =>

```js
window.addEventListener('DOMContentLoaded', () => {

  const form = document.querySelector('form');

  function req(e) {

    e.preventDefault();

    let formData = new FormData(form);
    formData.append('id', Math.random());

    let obj = {};
    formData.forEach((value, key) => {
      obj[key] = value;
    });

    let json = JSON.stringify(obj);

    const request = new XMLHttpRequest();
    request.open('POST', 'http://localhost:3000/people');
    request.setRequestHeader('Content-type', 'application/json; charset=utf-8');
    request.send(json);
    request.addEventListener('readystatechange', function() {
      if (request.readyState === 4 && request.status == 200) {
        let data = JSON.parse(request.response);
        console.log(data);
        
      } else {
        console.error('Что-то пошло не так...')
      }
    })
  }

  form.addEventListener('submit', (e) => req(e), {'once': true});
});
```

###  XMLHttpRequest c formData, POST запрос, уже без json
```js
window.addEventListener('DOMContentLoaded', () => {

  const form = document.querySelector('form');

  function req(e) {

    e.preventDefault();

    let formData = new FormData(form);

    // ! XMLHttpRequest formData

    const request = new XMLHttpRequest();
    request.open('POST', './api.php');
    // request.setRequestHeader('Content-Type', 'multipart/form-data'); 
    // когда XMLHttpRequest + formData - setRequestHeader тут не нужен
    request.send(formData);
    request.addEventListener('readystatechange', function() {
      if (request.readyState === 4 && request.status == 200) {
        console.log(request.response);
        
      } else {
        console.error('Что-то пошло не так...')
      }
    })
  }

  form.addEventListener('submit', (e) => req(e), {'once': true});
});
```

https://www.hostinger.com.ua/rukovodstva/chto-takoje-ajax/
https://developer.mozilla.org/ru/docs/Web/Guide/AJAX/Getting_Started	
https://itchief.ru/javascript/ajax-introduction

  **[⬆ Наверх](#top)**
	
307. ### <a name="307"></a> Promise (ES6)

Объект Promise используется для отложенных и асинхронных вычислений.	
	
1) Есть «создающий» код, который делает что-то, что занимает время. Например, загружает данные по сети.
2) Есть «потребляющий» код, который хочет получить результат «создающего» кода, когда он будет готов. Он может быть необходим более чем одной функции. 
3) Promise – это специальный объект в JavaScript, который связывает «создающий» и «потребляющий» коды вместе. «Создающий» код может выполняться сколько потребуется, чтобы получить результат, а промис делает результат доступным для кода, который подписан на него, когда результат готов.
	
```jsx harmony
let promise = new Promise(function(resolve, reject) {
  // эта функция выполнится автоматически, при вызове new Promise

  // через 1 секунду сигнализировать, что задача выполнена с результатом "done"
  setTimeout(() => resolve("done"), 1000);
});
```	

Функция, переданная в конструкцию new Promise, называется исполнитель (executor). Когда Promise создаётся, она запускается автоматически. Она должна содержать «создающий» код, который когда-нибудь создаст результат. В терминах нашей аналогии: исполнитель – это «певец».

Её аргументы resolve и reject – это колбэки, которые предоставляет сам JavaScript. Наш код – только внутри исполнителя.

Когда он получает результат, сейчас или позже – не важно, он должен вызвать один из этих колбэков:

- resolve(value) — если работа завершилась успешно, с результатом value.
- reject(error) — если произошла ошибка, error – объект ошибки.
	
Итак, исполнитель запускается автоматически, он должен выполнить работу, а затем вызвать resolve или reject.

У объекта promise, возвращаемого конструктором new Promise, есть внутренние свойства:

- state («состояние») — вначале "pending" («ожидание»), потом меняется на "fulfilled" («выполнено успешно») при вызове resolve или на "rejected" («выполнено с ошибкой») при вызове reject.
	
- result («результат») — вначале undefined, далее изменяется на value при вызове resolve(value) или на error при вызове reject(error).
	
Так что исполнитель по итогу переводит promise в одно из двух состояний: Resolve, Reject

Объект Promise служит связующим звеном между исполнителем («создающим» кодом) и функциями-потребителями («фанатами»), которые получат либо результат, либо ошибку. Функции-потребители могут быть зарегистрированы с помощью методов .then, .catch и .finally.

### У Promise есть методы: then, catch, finally	
	
.then - Наиболее важный и фундаментальный метод
Первый аргумент метода .then – функция, которая выполняется, когда промис переходит в состояние «выполнен успешно», и получает результат.
	
Второй аргумент .then – функция, которая выполняется, когда промис переходит в состояние «выполнен с ошибкой», и получает ошибку.

.catch(errorHandlingFunction) - обработать ошибку

.finally(f) похож на .then(f, f), в том смысле, что f выполнится в любом случае, когда промис завершится: успешно или с ошибкой.
finally хорошо подходит для очистки, например остановки индикатора загрузки, его ведь нужно остановить вне зависимости от результата.

	

### then
	
Наиболее важный и фундаментальный метод – .then.

Синтаксис:
```jsx harmony
promise.then(
  function(result) { /* обработает успешное выполнение */ },
  function(error) { /* обработает ошибку */ }
);
```	
Первый аргумент метода .then – функция, которая выполняется, когда промис переходит в состояние «выполнен успешно», и получает результат.

Второй аргумент .then – функция, которая выполняется, когда промис переходит в состояние «выполнен с ошибкой», и получает ошибку.

Например, вот реакция на успешно выполненный промис:
```jsx harmony
let promise = new Promise(function(resolve, reject) {
  setTimeout(() => resolve("done!"), 1000);
});

// resolve запустит первую функцию, переданную в .then
promise.then(
  result => alert(result), // выведет "done!" через одну секунду
  error => alert(error) // не будет запущена
);
```	
Выполнилась первая функция.

А в случае ошибки в промисе – выполнится вторая:
```jsx harmony
let promise = new Promise(function(resolve, reject) {
  setTimeout(() => reject(new Error("Whoops!")), 1000);
});

// reject запустит вторую функцию, переданную в .then
promise.then(
  result => alert(result), // не будет запущена
  error => alert(error) // выведет "Error: Whoops!" спустя одну секунду
);
```	
Если мы заинтересованы только в результате успешного выполнения задачи, то в then можно передать только одну функцию:
```jsx harmony
let promise = new Promise(resolve => {
  setTimeout(() => resolve("done!"), 1000);
});

promise.then(alert); // выведет "done!" спустя одну секунду
```
	
### catch
	
Если мы хотели бы только обработать ошибку, то можно использовать null в качестве первого аргумента: .then(null, errorHandlingFunction). Или можно воспользоваться методом .catch(errorHandlingFunction), который сделает тоже самое:
```jsx harmony
let promise = new Promise((resolve, reject) => {
  setTimeout(() => reject(new Error("Ошибка!")), 1000);
});

// .catch(f) это тоже самое, что promise.then(null, f)
promise.catch(alert); // выведет "Error: Ошибка!" спустя одну секунду
```	
Вызов .catch(f) – это сокращённый, «укороченный» вариант .then(null, f).

	
### finally
	
По аналогии с блоком finally из обычного try {...} catch {...}, у промисов также есть метод finally.

Вызов .finally(f) похож на .then(f, f), в том смысле, что f выполнится в любом случае, когда промис завершится: успешно или с ошибкой.

finally хорошо подходит для очистки, например остановки индикатора загрузки, его ведь нужно остановить вне зависимости от результата.

Например:
```jsx harmony
new Promise((resolve, reject) => {
  /* сделать что-то, что займёт время, и после вызвать resolve/reject */
})
  // выполнится, когда промис завершится, независимо от того, успешно или нет
  .finally(() => остановить индикатор загрузки)
  .then(result => показать результат, err => показать ошибку)
```	
Но это не совсем псевдоним then(f,f), как можно было подумать. Существует несколько важных отличий:

Обработчик, вызываемый из finally, не имеет аргументов. В finally мы не знаем, как был завершён промис. И это нормально, потому что обычно наша задача – выполнить «общие» завершающие процедуры.

Обработчик finally «пропускает» результат или ошибку дальше, к последующим обработчикам.

Например, здесь результат проходит через finally к then:
```jsx harmony
new Promise((resolve, reject) => {
  setTimeout(() => resolve("result"), 2000)
})
  .finally(() => alert("Промис завершён"))
  .then(result => alert(result)); // <-- .then обработает результат
```					 
А здесь ошибка из промиса проходит через finally к catch:
```jsx harmony
new Promise((resolve, reject) => {
  throw new Error("error");
})
  .finally(() => alert("Промис завершён"))
  .catch(err => alert(err));  // <-- .catch обработает объект ошибки
```				     
Это очень удобно, потому что finally не предназначен для обработки результата промиса. Так что он просто пропускает его через себя дальше.

				     
Последнее, но не менее значимое: вызов .finally(f) удобнее, чем .then(f, f) – не надо дублировать функции f.
				     
```jsx harmony
new Promise(function(resolve, reject) {

  setTimeout(() => resolve(1), 1000); // (*)

}).then(function(result) { // (**)

  alert(result); // 1
  return result * 2;

}).then(function(result) { // (***)

  alert(result); // 2
  return result * 2;

}).then(function(result) {

  alert(result); // 4
  return result * 2;

});
```	
Идея состоит в том, что результат первого промиса передаётся по цепочке обработчиков .then.

Поток выполнения такой:

Начальный промис успешно выполняется через 1 секунду (*),
Затем вызывается обработчик в .then (**).
Возвращаемое им значение передаётся дальше в следующий обработчик .then (***)
…и так далее.
В итоге результат передаётся по цепочке обработчиков, и мы видим несколько alert подряд, которые выводят: 1 → 2 → 4.			
### Пример полностью
```js
console.log('Request data...')

const p = new Promise(function(resolve, reject) {
  setTimeout(() => {
    console.log('Preparing data...')
    backEndData = {
      server: 'aws',
      port: 2000,
      status: 'working'
    }
    resolve(backEndData)
  }, 2000)
})


p.then(data => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      data.modified = true
      resolve(data)
    }, 2000)
  })

})
  .then(clientData => {
  console.log('Data received', clientData)

  clientData.fromPromise = true
  return clientData
})
.then(data => {
  console.log('Modifed', data)
})
.catch(err => console.error('Error: ', err))
.finally(() => console.log('Finally'))


// фишки

const sleep = ms => {
  return new Promise(resolve => { setTimeout(() => resolve(), ms)
  })
}

sleep(2000).then(() => console.log('After 2 sec'))
sleep(3000).then(() => console.log('After 3 sec'))

// All ->

Promise.all([sleep(2000), sleep(5000)])
  .then(() => {
    console.log('All promises')
})

// Race ->

Promise.race([sleep(2000), sleep(5000)])
  .then(() => {
    console.log('Race promises')
})
```

### Пример
```js
Promise.reject('a')
  .catch(p => p + 'b')
  .catch(p => p + 'c')
  .then(p => p + 'd')
  .finally(p => p + 'e')
  .then(p => console.log(p));
```	
Результат: abd

then(p => p + 'd') - выполняется по очереди

catch - промис реджектится со строкой 'а', дальш попадает все в catch второй catch не будет выполнен, все выполнется в первом

then(p => console.log(p)) -просто выводит 'p' в консоль, но не записывает его в промис поэтому попадает параметр p

finall - мы может отписыватся от собитый и он нечего не возвращает!	

### Пример
```js
Promise.resolve(7)
  .then((n) => Promise.reject(n))
  .catch((n) => Promise.reject(n))
  .catch(() => 5)
  .then(n => console.log(n)) 	
```	
Результат: 7	

### Пример
```js
let a = Promise.resolve(7)
  .then((n) => Promise.reject(n))
  .catch((n) => Promise.reject(n))
  .catch(() => 5)
  .then(n => console.log(n))	
```	
Результат: 5	
	
### Пример
```js
const req = new Promise((resolve, reject) => {
  setTimeout(() => {
    console.log('Подготовка данных...');
  
    const product = {
      name: 'TV',
      price: 2000
    };
    
    resolve(product);

  }, 2000);
});

req.then((product) => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      product.status = 'order';
      resolve(product);
    }, 2000);
  });
}).then(data => {
  data.modify = true;
  return data;
}).then(data => {
  console.log(data);
}).catch(() => {
  console.error('Произошла ошибка');
}).finally(() => {
  console.log('Finally');
});
	
/*
Результат: 
Подготовка данных...
{ name: 'TV', price: 2000, status: 'order', modify: true }
Finally
*/
```		
	
### Promise.all(iterable)
	
Вызов Promise.all(iterable) получает массив (или другой итерируемый объект) промисов и возвращает промис, который ждёт, пока все переданные промисы завершатся, и переходит в состояние «выполнено» с массивом их результатов.
	
```js
Promise.all([
  httpGet('/article/promise/user.json'),
  httpGet('/article/promise/guest.json')
]).then(results => {
  alert(results);
});	
```
	
### Promise.race(iterable)
	
Вызов Promise.race, как и Promise.all, получает итерируемый объект с промисами, которые нужно выполнить, и возвращает новый промис.

Но, в отличие от Promise.all, результатом будет только первый успешно выполнившийся промис из списка. Остальные игнорируются.
	
```js
Promise.race([
  httpGet('/article/promise/user.json'),
  httpGet('/article/promise/guest.json')
]).then(firstResult => {
  firstResult = JSON.parse(firstResult);
  alert( firstResult.name ); // iliakan или guest, смотря что загрузится раньше
});
```
 
### Пример All/Race
```js
const test = time => {
  return new Promise(resolve => {
    setTimeout(() => resolve(), time);
  });
};

// test(1000).then(() => console.log('1000 ms'));
// test(2000).then(() => console.log('2000 ms'));


Promise.all([test(1000), test(2000)]).then(() => {
  console.log('All');
});


Promise.race([test(1000), test(2000)]).then(() => {
  console.log('All');
});
```

### Example -> Что выведет в консоль данный код?
```js
const promise = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve('foo');
    }, 300);
});
  
promise.then((value) => {
    console.log(value);
}); 

// 'foo'
```

### Example -> Какое сообщение будет выведено в консоль при таком коде?
```js
const p1 = new Promise((resolve, reject) => {
  setTimeout(resolve, 1000, "one");
});
const p2 = new Promise((resolve, reject) => {
  setTimeout(resolve, 2000, "two");
});
const p3 = new Promise((resolve, reject) => {
  setTimeout(resolve, 3000, "three");
});
const p4 = new Promise((resolve, reject) => {
  setTimeout(resolve, 4000, "four");
});
const p5 = new Promise((resolve, reject) => {
  reject("reject");
});
 
Promise.all([p1, p2, p3, p4, p5]).then(value => {
  console.log(value);
}, reason => {
  console.log(reason)
});

// "reject"
```

### Example -> Через сколько секунд данный код выведет в консоль сообщение? И что именно будет в консоли?
```js
const promisify = (item, delay) =>
    new Promise(resolve => setTimeout(() => resolve(item), delay));
 
const a = () => promisify('a', 100);
const b = () => promisify('b', 5000);
const c = () => promisify('c', 3000);
 
async function two() {
    const promises = [a(), b(), c()];
    const outpu1 = await Promise.race(promises);
    return `two is done: ${outpu1}`;
}
 
two().then(console.log);

// Через 100мс, two is done: a
```

https://learn.javascript.ru/promise-basics

  **[⬆ Наверх](#top)**
	
	
308. ### <a name="308"></a> Promise

### Введение в Promises

Промисы часто используются, когда мы запрашиваем JSON API и выполняем AJAX запросы.

Промисы - это то, что произойдет между настоящим моментом и концом времени; или другими словами это то, что произойдет в будущем, но, вероятно, не сразу. Чтобы понять это, нам нужно помнить, что JavaScript почти полностью асинхронный.

Промисы - это один из способов работы с асинхронным кодом в JavaScript без написания слишком большого количества обратных вызовов.

Хоть они и существовали годами, со временем были стандартизированы и представлены в ES2015, а теперь заменены в ES2017 асинхронными функциями.

Асинхронные функции используют API промисов в качестве своего строительного блока, поэтому их понимание является основополагающим, так как скорее всего, мы больше будем использовать асинхронные функции вместо промисов.

### Вкратце о том, как работают промисы

Как только промис был вызван, он запускается в состоянии ожидания (pending state). Это означает, что функция, которая вызвала промис, продолжает выполнение, ожидая, пока промис выполнит свою собственную обработку и предоставит функции вызова некоторую обратную связь.

На этом этапе функция вызова ожидает, пока промис не вернется в resolved state (выполнено успешно) или в rejected state (выполнено с ошибкой), и в то же время она продолжает свое выполнение, пока выполняется промис.

### Создание промиса

Promise API предоставляет конструктор Promise, который мы инициализируем с помощью new Promise() и он принимает одну функцию которая передает нам resolve и reject. Идея заключается в том, что промис либо будет resolve (выполнен успешно) - завершен и передаст нам данные. Или он может сам себя reject (отклонить), потому что, возможно, произошла ошибка, или данные были искажены, или по какой-либо другой причине, которая приведет к ошибке. Мы вызываем resolve или reject (когда готовы завершить промис) и передаем в них данные для этого промиса.

Например:
```js
let done = true;

const p = new Promise((resolve, reject) => {
  if (done) {
    resolve("выполнено успешно");
  } else {
    reject("выполнено с ошибкой");
  }
});
```
В этом примере промис проверяет глобальную константу done, и если она равна true - мы возвращаем resolve («выполнено успешно»). В противном случае возвращаем rejected («выполнено с ошибкой»).

С помощью resolve и reject мы можем передать значение. В приведенном выше примере мы просто возвращаем строку, но это может быть и объект.

### Выполнение промиса

```js
const p = new Promise((resolve, reject) => {
  resolve("Alex is cool");
});

p.then(data => {
  console.log(data); // Alex is cool
});
```
При запуске p мы выполняем промис и ожидаем успешного выполнения, используя обратный вызов then(). Так как мы создали промис, а затем сразу же выполнили resolve - передав Alex is cool, мы сразу увидем результат в консоле.

### Если нужно сделать resolve через некоторое время

Если мы хотим выполнить некоторую обработку в фоновом режиме или сделать AJAX-запрос, а затем, когда данные вернутся, сделать resolve. По сути, всё сводится к тому, что «я не хочу останавливать выполнение JavaScript, я просто хочу начать запрос, а затем, когда он вернется, разберусь с этим результатом».

Давай посмотрим, что произойдет, когда мы установим здесь тайм-аут в 1 секунду.

```js
const p = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("Alex is cool");
  }, 1000);
});

p.then(data => {
  console.log(data); // Alex is cool - через 1 секунду
});
```

Через секунду в консоле появится Alex is cool. Точно так же мы можем вызвать reject:
```js
const p = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject("Err Alex is not cool");
  }, 1000);
});

p.then(data => {
  console.log(data);
});
```
В консоле увидим Uncaught (in promise) Err Alex is not cool. Err Alex is not cool - это настоящая ошибка. Почему Uncaught (in promise) (не перехвачено промисом)? Потому что мы не словили и не обработали ошибку в промисе. Для этого нам нужно добавить в нашу цепочку catch(), передать ошибку и вывести ее через console.error.

```js
const p = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject("Err Alex is not cool");
  }, 1000);
});

p.then(data => {
  console.log(data);
}).catch(err => {
  console.error(err);
});
```
Теперь в консоле браузера через 1 секунду будет только реальная ошибка, которую мы передали. В идеале, для более детальной информации, где произошла ошибка, мы должны передать объект Error, а не просто строку. Поэтому мы обернем строку в объект Error, а затем, когда ошибка выведется в консоль, мы увидим, что у нас есть информация о том, где она произошла.
```js
reject(Error("Err Alex is not cool"));
```

### Цепочка промисов

Промис можно вернуть другому промису и таким образом создать цепочку промисов.

Отличным примером цепочки промисов является Fetch API - слой поверх XMLHttpRequest API. Его мы можем использовать для получения данных, создав цепочку промисов. Они будут выполнятся, когда мы получим данные.

Fetch API - это механизм, основанный на промисах, а вызов fetch() - он эквивалентен определению нашего собственного промиса с использованием new Promise().

В этом примере мы вызываем fetch(), чтобы получить данные о моем профиле на github, и создаем цепочку промисов.

```js
const status = response => {
  if (response.status >= 200 && response.status < 300) {
    return Promise.resolve(response);
  }
  return Promise.reject(Error(response.statusText));
};

const json = response => response.json();

fetch("https://api.github.com/users/oleksiimyzgin")
  .then(status)
  .then(json)
  .then(data => {
    console.log("Request succeeded with JSON response", data);
  })
  .catch(error => {
    console.error("Request failed", error);
  });
```

Запуск fetch() возвращает response, который имеет много свойств, из которых мы используем:

- status - числовое значение, предоставляющее код состояния HTTP;
- statusText - сообщение о состоянии, которое OK, если запрос был выполнен успешно.

У response также есть метод json(), который возвращает промис. Выполнив его он содержит нужный нам контент тела, обработанный и преобразованный в JSON.

Таким образом, учитывая эти промисы, вот что происходит: первый промис в цепочке - это определенная нами функция, называемая status(), которая проверяет статус ответа и, если ответ успешный (между 200 и 299), то выполнится resolve, в противном случае reject.

Если выполняется reject, то цепочка промисов пропустит все перечисленные then() и перейдет непосредственно к первому catch() внизу, в котором будет записан текст Request failed (Ошибка запроса) вместе с сообщением об ошибке.

Если операция прошла успешно то выполняется resolve, затем вызывается функция json(), которую мы определили. Поскольку предыдущий промис, в случае успеха, вернул объект response, мы получаем его в качестве входных данных для второго промиса.

В этом случае мы возвращаем данные, обработанные JSON, поэтому третий промис получает JSON напрямую:

```js
.then((data) => {
  console.log('Request succeeded with JSON response', data)
})
```
это мы и выводим в консоль.

### Обработка ошибок

В приведенном примере, в предыдущем разделе, у нас есть catch(), который был добавлен к цепочке промисов. Когда что-либо в цепочке промисов дает сбой и вызывает ошибку или отклоняет промис, управление переходит к ближайшему catch() по цепочке.
```js
new Promise((resolve, reject) => {
  throw new Error("New Error");
})
  .then(res => console.log(res))
  .catch(err => {
    console.error(err); // Error: New Error
  });

// или

new Promise((resolve, reject) => {
  reject(Error("New Error"));
})
  .then(res => console.log(res))
  .catch(err => {
    console.error(err); // Error: New Error
  });
```

### Каскадные ошибки

Если внутри catch() мы вызываем ошибку, то можно добавить второй catch() для её обработки и так далее.
```js
new Promise((resolve, reject) => {
  throw new Error("Error 1");
})
  .catch(err => {
    throw new Error("Error 2");
  })
  .catch(err => {
    console.error(err); // Error: Error 2
  });
```

### Оркестровые промисы

### Promise.all()

Если нам нужно синхронизировать различные промисы, то Promise.all() поможет определить список промисов и выполнить что-то только тогда, когда все они будут выполнены успешно.
```js
const weather = new Promise(resolve => {
  setTimeout(() => {
    resolve({ temp: 25, condition: "Солнечно" });
  }, 2000);
});

const person = new Promise(resolve => {
  setTimeout(() => {
    resolve({ name: "Alex", dev: "Frontend" });
  }, 500);
});

Promise.all([weather, person])
  .then(res => {
    console.log("Array of results", res);
  })
  .catch(err => {
    console.error(err);
  });
```
Синтаксис ES2015 деструктуризации позволяет сделать так:
```js
Promise.all([weather, person]).then(([weatherInfo, personInfo]) => {
  console.log("Results", weatherInfo, personInfo);
});
```
В данном примере мы получим ответ только после 2 секунд, потому что мы ждем, пока каждый промис будет выполнен успешно, прежде чем запустим then. Иными словами, самый медленный response будет решать, через сколько вернутся все промисы.

Это был пример с setTimeouts. Сейчас давай разберем с реальными данными. Нам нужно 2 API, с которых мы получим данные. Берём 2 учетные записи с github.

Так как мы получаем в качестве ответа поток данных, мы должны его преобразовать в читаемый json. Ранее мы делали это с одним ответом через response.json(). Как это сделать если у нас два response? Мы перебираем response с помощью map, который вернет новый массив и на каждом res вызываем второй промис json().

```js
const data1 = fetch("https://api.github.com/users/oleksiimyzgin");
const data2 = fetch("https://api.github.com/users/leoyats");

Promise.all([data1, data2])
  .then(response => {
    return Promise.all(response.map(res => res.json()));
  })
  .then(response => {
    console.log(response);
  });
```
Почему мы должны вызывать res.json?

Причина в том, что существует много разных типов данных, которые могут вернуться. В MDN документации написано что body может вернуться в виде arrayBuffer, blob, json, text или formData. Но не стоит предполагать, что твой API или AJAX запросы всегда будут json, так как это могут быть данные любого типа, которые там есть.

### Promise.race()

Promise.race() возвращает resolve или reject промис, в зависимости от того, с каким результатом завершится первый из переданных ему промисов: со значением или с ошибкой. В данном примере выполнится только самый быстрый промис.
```js
const promiseOne = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("Return after 2 seconds");
  }, 2000);
});
const promiseTwo = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("Return after 1 second");
  }, 1000);
});

Promise.race([promiseOne, promiseTwo]).then(result => {
  console.log(result); // Return after 1 second
});
```

  **[⬆ Наверх](#top)**

309. ### <a name="309"></a> Fetch API

```js
let promise = fetch(url, [options])
````	
- url – URL для отправки запроса.
- options – дополнительные параметры: метод, заголовки и так далее.
	
Без options это простой GET-запрос, скачивающий содержимое по адресу url.

Браузер сразу же начинает запрос и возвращает промис, который внешний код использует для получения результата.

Процесс получения ответа обычно происходит в два этапа.

### Во-первых, promise выполняется с объектом встроенного класса Response в качестве результата, как только сервер пришлёт заголовки ответа.

На этом этапе мы можем проверить статус HTTP-запроса и определить, выполнился ли он успешно, а также посмотреть заголовки, но пока без тела ответа.

Промис завершается с ошибкой, если fetch не смог выполнить HTTP-запрос, например при ошибке сети или если нет такого сайта. HTTP-статусы 404 и 500 не являются ошибкой.

Мы можем увидеть HTTP-статус в свойствах ответа:

- status – код статуса HTTP-запроса, например 200.
- ok – логическое значение: будет true, если код HTTP-статуса в диапазоне 200-299.

Например:
```js
let response = await fetch(url);

if (response.ok) { // если HTTP-статус в диапазоне 200-299
  // получаем тело ответа (см. про этот метод ниже)
  let json = await response.json();
} else {
  alert("Ошибка HTTP: " + response.status);
}
```	
### Во-вторых, для получения тела ответа нам нужно использовать дополнительный вызов метода.

Response предоставляет несколько методов, основанных на промисах, для доступа к телу ответа в различных форматах:

- response.text() – читает ответ и возвращает как обычный текст,
- response.json() – декодирует ответ в формате JSON,
- response.formData() – возвращает ответ как объект FormData (разберём его в следующей главе),
- response.blob() – возвращает объект как Blob (бинарные данные с типом),
- response.arrayBuffer() – возвращает ответ как ArrayBuffer (низкоуровневое представление бинарных данных),
помимо этого, response.body – это объект ReadableStream, с помощью которого можно считывать тело запроса по частям. Мы рассмотрим и такой пример несколько позже.
	
Например, получим JSON-объект с последними коммитами из репозитория на GitHub:
```js
let url = 'https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits';
let response = await fetch(url);

let commits = await response.json(); // читаем ответ в формате JSON

alert(commits[0].author.login);
```	
То же самое без await, с использованием промисов:
```js
fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits')
  .then(response => response.json())
  .then(commits => alert(commits[0].author.login));
```	
Для получения ответа в виде текста используем await response.text() вместо .json():
```js
let response = await fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits');

let text = await response.text(); // прочитать тело ответа как текст

alert(text.slice(0, 80) + '...');
```	
В качестве примера работы с бинарными данными, давайте запросим и выведем на экран логотип спецификации «fetch» (см. главу Blob, чтобы узнать про операции с Blob):
```js
let response = await fetch('/article/fetch/logo-fetch.svg');

let blob = await response.blob(); // скачиваем как Blob-объект

// создаём <img>
let img = document.createElement('img');
img.style = 'position:fixed;top:10px;left:10px;width:100px';
document.body.append(img);

// выводим на экран
img.src = URL.createObjectURL(blob);

setTimeout(() => { // прячем через три секунды
  img.remove();
  URL.revokeObjectURL(img.src);
}, 3000);	
```	
	
Fetch API предоставляет интерфейс JavaScript для работы с запросами и ответами HTTP. Он также предоставляет глобальный метод fetch() (en-US), который позволяет легко и логично получать ресурсы по сети асинхронно. Подобная функциональность ранее достигалась с помощью XMLHttpRequest .
```jsx harmony
let response = await fetch(url);

if (response.ok) { // если HTTP-статус в диапазоне 200-299
  // получаем тело ответа (см. про этот метод ниже)
  let json = await response.json();
} else {
  alert("Ошибка HTTP: " + response.status);
}
```
```jsx harmony
Типичный запрос с помощью fetch состоит из двух операторов await:

let response = await fetch(url, options); // завершается с заголовками ответа
let result = await response.json(); // читать тело ответа в формате JSON

Или, без await:

fetch(url, options)
  .then(response => response.json())
  .then(result => /* обрабатываем результат */)
```

Параметры ответа:
- response.status – HTTP-код ответа,
- response.ok – true, если статус ответа в диапазоне 200-299.
- response.headers – похожий на Map объект с HTTP-заголовками.

Методы для получения тела ответа:
- response.text() – возвращает ответ как обычный текст,
- response.json() – преобразовывает ответ в JSON-объект,
- response.formData() – возвращает ответ как объект FormData (кодировка form/multipart, см. следующую главу),
- response.blob() – возвращает объект как Blob (бинарные данные с типом),
- response.arrayBuffer() – возвращает ответ как ArrayBuffer (низкоуровневые бинарные данные),

Опции fetch, которые мы изучили на данный момент:
- method – HTTP-метод,
- headers – объект с запрашиваемыми заголовками (не все заголовки разрешены),
- body – данные для отправки (тело запроса) в виде текста, FormData, BufferSource, Blob или UrlSearchParams.

https://learn.javascript.ru/fetch

### Пример => GET запрос, json
```js
 fetch('http://localhost:3000/people')
  .then((data) => data.json())
  .then((data) => createCards(data))
  .catch((err) => console.error(err));

// более подробный код =>

window.addEventListener('DOMContentLoaded', () => {
  
  function req() {

    // ! fetch =>

    /* fetch('http://localhost:3000/people')
      .then((data) => data.json())
      .then((data) => createCards(data))
      .catch((err) => console.error(err)); */

    // ! fetch с функцией getResource =>

    getResource('http://localhost:3000/people')
      .then((data) => createCards(data))
      .catch((err) => console.error(err));

    this.remove();
  }

  document
    .querySelector('button')
    .addEventListener('click', req, { once: true });

  // ! fetch функция getResource

  async function getResource(url) {
    const res = await fetch(`${url}`);

    if (!res.ok) {
      throw new Error(`Could not fetch ${url}, status: ${res.status}`);
    }

    return await res.json();
  }

  function createCards(response) {
    response.forEach((item) => {
      let card = document.createElement('div');

      card.classList.add('card');

      let icon;

      if (item.sex === 'male') {
        icon = 'icons/mars.png';
      } else {
        icon = 'icons/female.png';
      }

      card.innerHTML = `
              <img src="${item.photo}" alt="photo">
              <div class="name">${item.name} ${item.surname}</div>
              <div class="sex">
                <img src=${icon} alt="male">
              </div>
              <div class="age">${item.age}</div>
            `;
      document.querySelector('.app').appendChild(card);
    });
  }
});
```

### Пример => POST запрос с json
```js
window.addEventListener('DOMContentLoaded', () => {

  const form = document.querySelector('form');

  function req(e) {

    e.preventDefault();

    let formData = new FormData(form);
    formData.append('id', Math.random());

    let obj = {};
    formData.forEach((value, key) => {
      obj[key] = value;
    });

      // ! fetch с функцией getResource POST =>

      getResource('http://localhost:3000/people', obj)
      .then(data => console.log(data))
      .catch(err => console.error(err));
  }

  form.addEventListener('submit', (e) => req(e), {'once': true});

  // ! fetch функция getResource с POST

  async function getResource(url, data) {
    const res = await fetch(`${url}`, {
      method: "POST",
      headers: {
        'Content-type': 'application/json'
      },
      body: JSON.stringify(data)
    });

    if (!res.ok) {
      throw new Error(`Could not fetch ${url}, status: ${res.status}`);
    }

    return await res.json();
  }
});
```

### Пример => POST запрос с formData
```js
window.addEventListener('DOMContentLoaded', () => {

  const form = document.querySelector('form');

  function req(e) {

    e.preventDefault();

    let formData = new FormData(form); 

      // ! fetch с функцией getResource POST =>

      getResource('./api.php', formData)
      .then(data => console.log(data))
      .catch(err => console.error(err));
  }

  form.addEventListener('submit', (e) => req(e), {once: true});

  async function getResource(url, data) {
    const res = await fetch(`${url}`, {
      method: "POST",
      /* headers: {
        'Content-type': 'multipart/form-data'
      }, */ 
      // звголовок не нужен в этом случае, когда XMLHttpRequest + formData - setRequestHeader тут не нужен
      body: data
    });

    if (!res.ok) {
      throw new Error(`Could not fetch ${url}, status: ${res.status}`);
    }

    return await res.text();
  }
});
```

### Пример
```js
window.addEventListener('DOMContentLoaded', () => { 
  // Forms

  const forms = document.querySelectorAll('form');
  const message = {
    loading: 'img/form/spinner.svg',
    success: 'Спасибо! Скоро мы с вами свяжемся',
    failure: 'Что-то пошло не так...'
  };

  forms.forEach(item => {
    postData(item);
  });

  function postData(form) {
    form.addEventListener('submit', (e) => {
      e.preventDefault();

      let statusMessage = document.createElement('img');
      statusMessage.src = message.loading;
      statusMessage.style.cssText = `
      display: block;
      margin: 0 auto;
      `;
      form.appendChild(statusMessage);
      form.insertAdjacentElement('afterend', statusMessage);
  

      
      // request.setRequestHeader('Content-type', 'application/json; charset=utf-8');

      // когда мы используем связку XMLHttpRequest обьекта + form-data, нам заголовок устанавливать не нужно, он устанавливается автоматически
      
      const formData = new FormData(form);

      const object = {};
      formData.forEach(function(value, key){
          object[key] = value;
      });


      fetch('server.php', {
        method: 'POST',
        headers: {
          'Content-type': 'application/json'
        }, // если formData - закомментировать headers
        body: JSON.stringify(object) // или formData, если работать нужно не с json
      })
      .then(data => data.text())
      .then(data => {
        console.log(data);
        showThanksModal(message.success);
        statusMessage.remove();
      }).catch(() => {
        showThanksModal(message.failure);
      }).finally(() => {
        form.reset();
      });

    });
  }

  function showThanksModal(message) {
    const prevModalDialog = document.querySelector('.modal__dialog');

    prevModalDialog.classList.add('hide');
    openModal();

    const thanksModal = document.createElement('div');
    thanksModal.classList.add('modal__dialog');

  thanksModal.innerHTML = `
    <div class="modal__content">
      <div class="modal__close" data-close>×</div>
      <div class="modal__title">${message}</div>
    </div>
  `;

    document.querySelector('.modal').append(thanksModal);
    setTimeout(() => {
      thanksModal.remove();
      prevModalDialog.classList.add('show');
      prevModalDialog.classList.remove('hide');
      closeModal();

    }, 4000);
  }

  // Fetch

  fetch('https://jsonplaceholder.typicode.com/posts', {
    method: 'POST',
    body: JSON.stringify({name: 'Alex'}),
    headers: {
      'Content-type': 'application/json'
    }
  })
    .then(response => response.json())
    .then(json => console.log(json));

});	
```	

  **[⬆ Наверх](#top)**
 

310. ### <a name="310"></a> Async/Await (ES8)


### Итого

Ключевое слово async перед объявлением функции:

- Обязывает её всегда возвращать промис.
- Позволяет использовать await в теле этой функции.

Ключевое слово await перед промисом заставит JavaScript дождаться его выполнения, после чего:

- Если промис завершается с ошибкой, будет сгенерировано исключение, как если бы на этом месте находилось throw.
- Иначе вернётся результат промиса.

Вместе они предоставляют отличный каркас для написания асинхронного кода. Такой код легко и писать, и читать.

Хотя при работе с async/await можно обходиться без promise.then/catch, иногда всё-таки приходится использовать эти методы (на верхнем уровне вложенности, например). Также await отлично работает в сочетании с Promise.all, если необходимо выполнить несколько задач параллельно.

## async/await

`async/await` - это синтаксический сахар для промисов, позволяющий писать их в привычном синхронном стиле.

Ключевое слово `async` позволяет сделать из обычной функции асинхронную.

Такая функция делает две вещи:

* Оборачивает возвращаемое значение в Promise
* Позволяет использовать ключевое слово `await`

По сути она делает следующее:

```jsx
// обычная функция
function hello() {
    return 'Hello'
}

// асинхронная функция
async function hello() {
    return 'Hello'
}

// эквивалентно
function hello() {
    return new Promise((resolve, reject) => {
        try {
            // здесь может быть более сложный код, который может вернуть значение
            // или выбросить ошибку
            resolve('Hello')
        } catch (error) {
            reject(error)
        }
    })
}
```

Асинхронные функции становятся мощным инструментом при использовании ключевого слова `await`. `await` **работает только в асинхронных функциях.**

Мы можем использовать await перед promise-based функцией, чтобы остановить поток выполнения и дождаться результата её выполнения (результат Promise).

`await` можно использовать с любыми функциями, которые возвращают промис.

Пример:

```jsx
async function hello() {
  return greeting = await Promise.resolve('Hello')
}
```

Для обработки ошибок в `async/await` используется обычный `try/catch`.

## Подводные камни

Если написать несколько `async/await` подряд в случак, когда они независимы, то один промис будет дожидаться выполнения другого. Пример:

```jsx
await queryClient.prefetchQuery(QUERY_KEYS.BANNERS(restaurant?.id), () => getBanners(restaurant?.id))
await queryClient.prefetchQuery(QUERY_KEYS.CATEGORIES(restaurant?.id), () => getCategories(restaurant?.id))
await queryClient.prefetchQuery(QUERY_KEYS.POPULAR_PRODUCTS(restaurant?.id), () => getPopularProducts(restaurant?.id))
await queryClient.prefetchQuery(QUERY_KEYS.PRODUCTS(restaurant?.id), () => getProducts(restaurant?.id))
```

Можно вынести их в переменные или использовать `Promise.all`:

```jsx
const banners = queryClient.prefetchQuery(QUERY_KEYS.BANNERS(restaurant?.id), () => getBanners(restaurant?.id))
const categories queryClient.prefetchQuery(QUERY_KEYS.CATEGORIES(restaurant?.id), () => getCategories(restaurant?.id))
const popularProducts = await queryClient.prefetchQuery(QUERY_KEYS.POPULAR_PRODUCTS(restaurant?.id), () => getPopularProducts(restaurant?.id))
const products = await queryClient.prefetchQuery(QUERY_KEYS.PRODUCTS(restaurant?.id), () => getProducts(restaurant?.id))

await banners
await categories
await popularProducts
await products

// можно и так:

Promise.all([banners, categories, popularProducts, products])
```

Т. к. промисы в таком случае создаются одновременно, а значит и запускается асинхронный код, то один запрос не будет блокировать другой.

Подробнее: [Недостатки async/await (MDN)](https://developer.mozilla.org/ru/docs/Learn/JavaScript/Asynchronous/Promises#%D0%BD%D0%B5%D0%B4%D0%BE%D1%81%D1%82%D0%B0%D1%82%D0%BA%D0%B8\_asyncawait).

https://learn.javascript.ru/async-await

### Пример
```js
const delay = ms => {
  return new Promise(r => setTimeout(() => r(), ms))
}

delay(2000).then(() => console.log('2 sec'))


const url = 'https://jsonplaceholder.typicode.com/todos'


// пример промисы ->

function fetchTodos() {
  console.log('Fetch todo started...')
  return delay(2000)
  .then(() => {
    return fetch(url)
  })
  .then(response => response.json())
}

fetchTodos().then(data => {
  console.log('Data', data)
})
.catch(e => console.error(e))


// пример async await ->

async function fetchAsyncTodos() {
  console.log('Fetch todo started...')
  try {
    await delay(2000)
    const response = await fetch(url)
    const data = await response.json()
    console.log('Data', data)
  } catch(e) {
    console.error(e)
  } finally {
    console.log('Smth...')
  }  
}

fetchAsyncTodos()
```

### Пример
```js
window.addEventListener('DOMContentLoaded', () => {

  // Class, Используем Классы для карточек

  class MenuCard {
    constructor(src, alt, title, descr, price, parentSelector, ...classess ) {
      this.src = src;
      this.alt = alt;
      this.title = title;
      this.descr = descr;
      this.price = price;
      this.classess = classess;
      this.parent = document.querySelector(parentSelector);
      this.transfer = 27;
      this.changeToUAH();
    }

    changeToUAH() {
      this.price = this.price * this.transfer;
    }

    render() {
      const element = document.createElement('div');
      if (this.classess.length === 0) {
        this.element = 'menu__item';
        element.classList.add(this.element);
      } else {
        this.classess.forEach(className => element.classList.add(className));
      }

      element.innerHTML = `
          <img src=${this.src} alt=${this.alt}>
          <h3 class="menu__item-subtitle">${this.title}</h3>
          <div class="menu__item-descr">${this.descr}</div>
          <div class="menu__item-divider"></div>
          <div class="menu__item-price">
              <div class="menu__item-cost">Цена:</div>
              <div class="menu__item-total"><span>${this.price}</span> грн/день</div>
          </div>
      `;
      this.parent.append(element);
    }
  }


  const getResource = async (url) => {
    const res = await fetch(url);
    
    if (!res.ok) {
      throw new Error(`Could not fetch ${url}, status: ${res.status}`);
    }

    return await res.json();
};

  getResource('http://localhost:3000/menu')
  .then(data => {
    data.forEach(({img, altimg, title, descr, price}) => {
      new MenuCard(img, altimg, title, descr, price, '.menu .container').render();
    });
  });


  // Еще один вариант =>

  /* getResource('http://localhost:3000/menu')
  .then(data => createCard(data));

  function createCard(data) {
    data.forEach(({img, altimg, title, descr, price}) => {
      const element = document.createElement('div');

      element.classList.add('menu__item');

      element.innerHTML = `
        <img src=${img} alt=${altimg}>
        <h3 class="menu__item-subtitle">${title}</h3>
        <div class="menu__item-descr">${descr}</div>
        <div class="menu__item-divider"></div>
        <div class="menu__item-price">
            <div class="menu__item-cost">Цена:</div>
            <div class="menu__item-total"><span>${price}</span> грн/день</div>
        </div>
      `;

      document.querySelector('.menu .container').append(element);
    });


  } */

  
  // Forms

  const forms = document.querySelectorAll('form');
  const message = {
    loading: 'img/form/spinner.svg',
    success: 'Спасибо! Скоро мы с вами свяжемся',
    failure: 'Что-то пошло не так...'
  };

  forms.forEach(item => {
    bindPostData(item);
  });


  const postData = async (url, data) => {
    const res = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-type': 'application/json'
      },
      body: data
  });

    return await res.json();
 };


  function bindPostData(form) {
    form.addEventListener('submit', (e) => {
      e.preventDefault();

      let statusMessage = document.createElement('img');
      statusMessage.src = message.loading;
      statusMessage.style.cssText = `
      display: block;
      margin: 0 auto;
      `;
      form.appendChild(statusMessage);
      form.insertAdjacentElement('afterend', statusMessage);
  
      
      const formData = new FormData(form);

      const json = JSON.stringify(Object.fromEntries(formData.entries()));


      postData('http://localhost:3000/requests', json)
      .then(data => {
        console.log(data);
        showThanksModal(message.success);
        statusMessage.remove();
      }).catch(() => {
        showThanksModal(message.failure);
      }).finally(() => {
        form.reset();
      });

    });
  }

  function showThanksModal(message) {
    const prevModalDialog = document.querySelector('.modal__dialog');

    prevModalDialog.classList.add('hide');
    openModal();

    const thanksModal = document.createElement('div');
    thanksModal.classList.add('modal__dialog');

  thanksModal.innerHTML = `
    <div class="modal__content">
      <div class="modal__close" data-close>×</div>
      <div class="modal__title">${message}</div>
    </div>
  `;

    document.querySelector('.modal').append(thanksModal);
    setTimeout(() => {
      thanksModal.remove();
      prevModalDialog.classList.add('show');
      prevModalDialog.classList.remove('hide');
      closeModal();

    }, 4000);
  }

  fetch('http://localhost:3000/menu')
      .then(data => data.json())
      .then(res => console.log(res));

});
```

  **[⬆ Наверх](#top)**
	
311. ### <a name="311"></a> try catch, выдача throw

Конструкция try..catch состоит из двух основных блоков: try, и затем catch:
```js
try {

  // код...

} catch (err) {

  // обработка ошибки

}
```
Работает она так:

1. Сначала выполняется код внутри блока try {...}.
2. Если в нём нет ошибок, то блок catch(err) игнорируется: выполнение доходит до конца try и потом далее, полностью пропуская catch.
3. Если же в нём возникает ошибка, то выполнение try прерывается, и поток управления переходит в начало catch(err). Переменная err (можно использовать любое имя) содержит объект ошибки с подробной информацией о произошедшем.

```js
try {
  lalala; // ошибка, переменная не определена!
} catch(err) {
  alert(err.name); // ReferenceError
  alert(err.message); // lalala is not defined
  alert(err.stack); // ReferenceError: lalala is not defined at (...стек вызовов)

  // Можем также просто вывести ошибку целиком
  // Ошибка приводится к строке вида "name: message"
  alert(err); // ReferenceError: lalala is not defined
}
```
```js
let json = "{ некорректный JSON }";

try {

  let user = JSON.parse(json); // <-- тут возникает ошибка...
  alert( user.name ); // не сработает

} catch (e) {
  // ...выполнение прыгает сюда
  alert( "Извините, в данных ошибка, мы попробуем получить их ещё раз." );
  alert( e.name );
  alert( e.message );
}
```

### выдача throwing

Оператор throw генерирует ошибку.
```js
throw <объект ошибки>
```
Технически в качестве объекта ошибки можно передать что угодно. Это может быть даже примитив, число или строка, но всё же лучше, чтобы это был объект, желательно со свойствами name и message (для совместимости со встроенными ошибками).

```js
let json = '{ "age": 30 }'; // данные неполны

try {

  let user = JSON.parse(json); // <-- выполнится без ошибок

  if (!user.name) {
    throw new SyntaxError("Данные неполны: нет имени"); // (*)
  }

  alert( user.name );

} catch(e) {
  alert( "JSON Error: " + e.message ); // JSON Error: Данные неполны: нет имени
}
```
В строке (*) оператор throw генерирует ошибку SyntaxError с сообщением message. Точно такого же вида, как генерирует сам JavaScript. Выполнение блока try немедленно останавливается, и поток управления прыгает в catch.

```js
try {
  alert( 'try' );
  if (confirm('Сгенерировать ошибку?')) BAD_CODE();
} catch (e) {
  alert( 'catch' );
} finally {
  alert( 'finally' );
}
```
У кода есть два пути выполнения:

Если вы ответите на вопрос «Сгенерировать ошибку?» утвердительно, то try -> catch -> finally.
Если ответите отрицательно, то try -> finally.

### Example
```js
const data = [
  { id: 'box', tag: 'div' },
  { id: '', tag: 'nav' },
  { id: 'circle', tag: 'span' },
];

try {
  data.forEach((block0bj, i) => {
    const block = document.createElement(block0bj.tag);

    if (!block0bj.id) throw new SyntaxError(`B данных под номером ${i + 1} нет id`);

    block.setAttribute('id', block0bj.id);
    document.body.append(block);
  });
} catch(e) {
  console.error(e.name);
  console.log(e.message);
  console.log(e.stack);
}
```


  **[⬆ Наверх](#top)**
	
312. ### <a name="312"></a> Библиотека Axios

Axios — JavaScript-библиотека, основанная на обещаниях, для выполнения HTTP-запросов.

	
GET запросы JSON данных
Типичная задача во frontend'е — получение JSON данных с сервера. Axios для этого требуется 1 действие, fetch - 2 действия: запрос + вызов метода .json() над результатом запроса.
	
Axios
```js
axios.get('https://jsonplaceholder.typicode.com/posts/1')
  .then(response => console.log(response));
```	

Обработка ошибок
	
Axios обрабатывает ошибки логично. Если сервер вернул ответ с HTTP статусом ошибки (например 404 или 500), то обещание будет отвергнуто.
```js
axios.get(url)
  .then(result => console.log('success:', result))
  .catch(error => console.log('error:', error));
```
	
Некоторые люди скажут: «В чем проблема? Вы запросили данные с сервера, и их получили. И если сервер ответил статусом 404, то это ответ сервера и точка.» На мой взгляд, для разработчика приложений, ответ сервера с кодом ошибки считается таким же исключением как сетевой сбой и должно обрабатываться соответствующим образом.

POST запросы
С axios всё просто, а с fetch уже не так: JSON обязан быть преобразован в строку, а заголовок Content-Type должен указывать, что отправляются JSON данные, иначе сервер будет рассматривать их как строку.

Axios
```js
axios.post('/user', {
  firstName: 'Fred',
  lastName: 'Flintstone'
});
```
	
Базовые значения для запросов
Как вы могли заметить, fetch это явный API, вы ничего не получаете, если об этом не просите. Если используется аутентификация, основанная на сохранении сессии пользователя, то надо явно указывать куку. Если сервер расположен на поддомене, то надо явно прописывать CORS. Эти опции надо прописывать для всех вызовов сервера и у fetch нет механизма для установки значений по-умолчанию, а у axios есть.

```js	
axios.defaults.baseURL = 'https://api.example.com';
axios.defaults.headers.common['Accept'] = 'application/json';
axios.defaults.headers.post['Content-Type'] = 'application/json';
```
	
Заключение
Эквивалентный код
	
Axios
```js
function addUser(details) {
  return axios.post('https://api.example.com/user', details);
}
```
### Пример axios GET запрос

```js
window.addEventListener('DOMContentLoaded', () => {

  function req() {
      
    // ! axios =>

    getResource('http://localhost:3000/people')
    .then(data => createCards(data.data))
    .catch(err => console.error(err));

    this.remove();
  }

  document.querySelector('button').addEventListener('click', req, {once: true});

  // ! axios функция getResource =>

  async function getResource(url) {
    const res = await axios(`${url}`);

    if (res.status !== 200) {
      throw new Error(`Could not fetch ${url}, status: ${res.status}`);
    }

    return res;
  }


  function createCards(response) {
    response.forEach(item => {
      let card = document.createElement('div');

      card.classList.add('card');

      let icon;

      if (item.sex === 'male') {
        icon = "icons/mars.png"
      } else {
        icon = "icons/female.png"
      }

      card.innerHTML = `
        <img src="${item.photo}" alt="photo">
        <div class="name">${item.name} ${item.surname}</div>
        <div class="sex">
          <img src=${icon} alt="male">
        </div>
        <div class="age">${item.age}</div>
      `;
      document.querySelector('.app').appendChild(card);
    });
  }
});
``` 

### Пример axios POST запрос с json

```js
window.addEventListener('DOMContentLoaded', () => {

  const form = document.querySelector('form');

  function req(e) {

    e.preventDefault();

    let formData = new FormData(form);
    formData.append('id', Math.random());

    let obj = {};
    formData.forEach((value, key) => {
      obj[key] = value;
    });

      axios.post('http://localhost:3000/people', obj);
  }

  form.addEventListener('submit', (e) => req(e), {'once': true});
});
```

### Пример axios POST запрос с formData
```js
window.addEventListener('DOMContentLoaded', () => {

  const form = document.querySelector('form');

  function req(e) {

    e.preventDefault();

    let formData = new FormData(form);

      axios({
        method: 'post',
        url: './api.php',
        data: formData,
        headers: {'content-type': 'multipart/form-data'} // можно использовать headers, но это по желанию, можно и без него
      })
      .then(data => console.log(data.data))
  }

  form.addEventListener('submit', (e) => req(e), {'once': true});
});
```

### Пример
```js
 window.addEventListener('DOMContentLoaded', () => {

  // Class, Используем Классы для карточек

  class MenuCard {
    constructor(src, alt, title, descr, price, parentSelector, ...classess ) {
      this.src = src;
      this.alt = alt;
      this.title = title;
      this.descr = descr;
      this.price = price;
      this.classess = classess;
      this.parent = document.querySelector(parentSelector);
      this.transfer = 27;
      this.changeToUAH();
    }

    changeToUAH() {
      this.price = this.price * this.transfer;
    }

    render() {
      const element = document.createElement('div');
      if (this.classess.length === 0) {
        this.element = 'menu__item';
        element.classList.add(this.element);
      } else {
        this.classess.forEach(className => element.classList.add(className));
      }

      element.innerHTML = `
          <img src=${this.src} alt=${this.alt}>
          <h3 class="menu__item-subtitle">${this.title}</h3>
          <div class="menu__item-descr">${this.descr}</div>
          <div class="menu__item-divider"></div>
          <div class="menu__item-price">
              <div class="menu__item-cost">Цена:</div>
              <div class="menu__item-total"><span>${this.price}</span> грн/день</div>
          </div>
      `;
      this.parent.append(element);
    }
  }


  const getResource = async (url) => {
    const res = await fetch(url);
    
    if (!res.ok) {
      throw new Error(`Could not fetch ${url}, status: ${res.status}`);
    }

    return await res.json();
};

  // getResource('http://localhost:3000/menu')
  // .then(data => {
  //   data.forEach(({img, altimg, title, descr, price}) => {
  //     new MenuCard(img, altimg, title, descr, price, '.menu .container').render();
  //   });
  // });


  
  // axios.get('http://localhost:3000/menu')
  // .then(data => console.log(data));


  axios.get('http://localhost:3000/menu')
  .then(data => {
    data.data.forEach(({img, altimg, title, descr, price}) => {
      new MenuCard(img, altimg, title, descr, price, '.menu .container').render();
    });
  });



  // Forms

  const forms = document.querySelectorAll('form');
  const message = {
    loading: 'img/form/spinner.svg',
    success: 'Спасибо! Скоро мы с вами свяжемся',
    failure: 'Что-то пошло не так...'
  };

  forms.forEach(item => {
    bindPostData(item);
  });


  const postData = async (url, data) => {
    const res = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-type': 'application/json'
      },
      body: data
  });

    return await res.json();
 };


  function bindPostData(form) {
    form.addEventListener('submit', (e) => {
      e.preventDefault();

      let statusMessage = document.createElement('img');
      statusMessage.src = message.loading;
      statusMessage.style.cssText = `
      display: block;
      margin: 0 auto;
      `;
      form.appendChild(statusMessage);
      form.insertAdjacentElement('afterend', statusMessage);
  

      const formData = new FormData(form);

      const json = JSON.stringify(Object.fromEntries(formData.entries()));


      postData('http://localhost:3000/requests', json)
      .then(data => {
        console.log(data);
        showThanksModal(message.success);
        statusMessage.remove();
      }).catch(() => {
        showThanksModal(message.failure);
      }).finally(() => {
        form.reset();
      });

    });
  }

  function showThanksModal(message) {
    const prevModalDialog = document.querySelector('.modal__dialog');

    prevModalDialog.classList.add('hide');
    openModal();

    const thanksModal = document.createElement('div');
    thanksModal.classList.add('modal__dialog');

  thanksModal.innerHTML = `
    <div class="modal__content">
      <div class="modal__close" data-close>×</div>
      <div class="modal__title">${message}</div>
    </div>
  `;

    document.querySelector('.modal').append(thanksModal);
    setTimeout(() => {
      thanksModal.remove();
      prevModalDialog.classList.add('show');
      prevModalDialog.classList.remove('hide');
      closeModal();

    }, 4000);
  }

});
```

### Axios & Fetch
	
`Объём шаблонного кода`

`Fetch`
```js
fetch('https://jsonplaceholder.typicode.com/todos/1')
  .then(response => response.json())
  .then(json => console.log(json))
// {
//   "userId": 1,
//   "id": 1,
//   "title": "delectus aut autem",
//   "completed": false
// }
```	

`Axios`
```js
axios.get("https://jsonplaceholder.typicode.com/todos/1")
  .then(response => console.log("response", response.data))
// {
//   "userId": 1,
//   "id": 1,
//   "title": "delectus aut autem",
//   "completed": false
// }	
```
	
`Fetch`
```js
fetch("https://jsonplaceholder.typicode.com/posts", {
  method: "POST",
  body: JSON.stringify({
    title: "Title of post",
    body: "Post Body"
  })
})
  .then(res => {
    if (!response.ok) throw Error(response.statusText);
    return response.json();
  })
  .then(data => console.log(data))
  .catch(error => console.log(error));
```
	
`Axios`
```js
axios
  .post("https://jsonplaceholder.typicode.com/posts", {
    title: "Title of post",
    body: "Body of post"
  })
  .then(response => console.log(response.data))
  .catch(error => console.log(error));	
```
	
`Обработка ошибок`

`Fetch`
```js
fetch("https://jsonplaceholder.typicode.com/todos/100000")
  .then(response => {
    if (!response.ok) throw Error(response.statusText);
    return response.json();
  })
  .then(data => console.log("data", data))
  .catch(error => {
    console.log("error", error);
  });
// error Error: Not Found
```
	
`Axios`
```js
axios
  .get("https://jsonplaceholder.typicode.com/todos/100000")
  .then(response => {
    console.log("response", response);
  })
  .catch(error => {
    console.log("error", error);
  });
// error Error: Not Found
```
	
Библиотека Axios выдаёт сведения о сетевых ошибках, а API Fetch — нет. Работая с Fetch всегда нужно проверять свойство response.ok. Для того чтобы упростить решение данной задачи, проверку этой ошибки можно оформить в виде отдельной функции:
```js
const checkForError = response => {
  if (!response.ok) throw Error(response.statusText);
  return response.json();
};
fetch("https://jsonplaceholder.typicode.com/todos/100000")
  .then(checkForError)
  .then(data => console.log("data", data))
  .catch(error => {
    console.log("error", error);
  });	
```	
		
	
### Axios
	
Axios основан на промисах, что дает вам возможность использовать возможности JavaScript async и await для получения более удобочитаемого асинхронного кода.

Axios это один из самых популярных HTTP клиентов для браузеров и node.js, основанный на промисах.

В Axios есть поддержка запросов, получение ответов от сервера, их трансформация и автоматическая конвертация в JSON.
	
### Создание запроса GET
 
Добавьте в компонент следующий код:
```jsx harmony
import React from 'react';

import axios from 'axios';

export default class PersonList extends React.Component {
  state = {
    persons: []
  }

  componentDidMount() {
    axios.get(`https://jsonplaceholder.typicode.com/users`)
      .then(res => {
        const persons = res.data;
        this.setState({ persons });
      })
  }

  render() {
    return (
      <ul>
        { this.state.persons.map(person => <li>{person.name}</li>)}
      </ul>
    )
  }
}	
```
	
### Составление запроса POST
```jsx harmony	
import React from 'react';
import axios from 'axios';

export default class PersonList extends React.Component {
  state = {
    name: '',
  }

  handleChange = event => {
    this.setState({ name: event.target.value });
  }

  handleSubmit = event => {
    event.preventDefault();

    const user = {
      name: this.state.name
    };

    axios.post(`https://jsonplaceholder.typicode.com/users`, { user })
      .then(res => {
        console.log(res);
        console.log(res.data);
      })
  }

  render() {
    return (
      <div>
        <form onSubmit={this.handleSubmit}>
          <label>
            Person Name:
            <input type="text" name="name" onChange={this.handleChange} />
          </label>
          <button type="submit">Add</button>
        </form>
      </div>
    )
  }
}	
```
	
### Создание запроса DELETE
```jsx harmony
import React from 'react';
import axios from 'axios';

export default class PersonList extends React.Component {
  state = {
    id: '',
  }

  handleChange = event => {
    this.setState({ id: event.target.value });
  }

  handleSubmit = event => {
    event.preventDefault();

    axios.delete(`https://jsonplaceholder.typicode.com/users/${this.state.id}`)
      .then(res => {
        console.log(res);
        console.log(res.data);
      })
  }

  render() {
    return (
      <div>
        <form onSubmit={this.handleSubmit}>
          <label>
            Person ID:
            <input type="text" name="id" onChange={this.handleChange} />
          </label>
          <button type="submit">Delete</button>
        </form>
      </div>
    )
  }
}	
```				
https://developer.mozilla.org/ru/docs/Learn/JavaScript/Client-side_web_APIs/Fetching_data	

  **[⬆ Наверх](#top)**
	
313. ### <a name="313"></a> Получение данных с сервера. Async/Await. Создание карточек меню. Forms

https://github.com/yankovalenko94/JS_task_answers/blob/master/JS_step_16/Food/js/script.js

Local server + json server ->

```js
// Используем классы для создание карточек меню

    class MenuCard {
        constructor(src, alt, title, descr, price, parentSelector, ...classes) {
            this.src = src;
            this.alt = alt;
            this.title = title;
            this.descr = descr;
            this.price = price;
            this.classes = classes;
            this.parent = document.querySelector(parentSelector);
            this.transfer = 27;
            this.changeToUAH(); 
        }

        changeToUAH() {
            this.price = this.price * this.transfer; 
        }

        render() {
            const element = document.createElement('div');

            if (this.classes.length === 0) {
                this.classes = "menu__item";
                element.classList.add(this.classes);
            } else {
                this.classes.forEach(className => element.classList.add(className));
            }

            element.innerHTML = `
                <img src=${this.src} alt=${this.alt}>
                <h3 class="menu__item-subtitle">${this.title}</h3>
                <div class="menu__item-descr">${this.descr}</div>
                <div class="menu__item-divider"></div>
                <div class="menu__item-price">
                    <div class="menu__item-cost">Цена:</div>
                    <div class="menu__item-total"><span>${this.price}</span> грн/день</div>
                </div>
            `;
            this.parent.append(element);
        }
    }

    getResource('http://localhost:3000/menu')
        .then(data => {
            data.forEach(({img, altimg, title, descr, price}) => {
                new MenuCard(img, altimg, title, descr, price, ".menu .container").render();
            });
        });

// Создание карточек без шаблона ->

    // getResource('http://localhost:3000/menu')
    //     .then(data => createCard(data));

    // function createCard(data) {
    //     data.forEach(({img, altimg, title, descr, price}) => {
    //         const element = document.createElement('div');

    //         element.classList.add("menu__item");

    //         element.innerHTML = `
    //             <img src=${img} alt=${altimg}>
    //             <h3 class="menu__item-subtitle">${title}</h3>
    //             <div class="menu__item-descr">${descr}</div>
    //             <div class="menu__item-divider"></div>
    //             <div class="menu__item-price">
    //                 <div class="menu__item-cost">Цена:</div>
    //                 <div class="menu__item-total"><span>${price}</span> грн/день</div>
    //             </div>
    //         `;
    //         document.querySelector(".menu .container").append(element);
    //     });
    // }

    // Forms

    const forms = document.querySelectorAll('form');
    const message = {
        loading: 'img/form/spinner.svg',
        success: 'Спасибо! Скоро мы с вами свяжемся',
        failure: 'Что-то пошло не так...'
    };

    forms.forEach(item => {
        bindPostData(item);
    });

    const postData = async (url, data) => {
        let res = await fetch(url, {
            method: "POST",
            headers: {
                'Content-Type': 'application/json'
            },
            body: data
        });
    
        return await res.json();
    };

    async function getResource(url) {
        let res = await fetch(url);
    
        if (!res.ok) {
            throw new Error(`Could not fetch ${url}, status: ${res.status}`);
        }
    
        return await res.json();
    }

    function bindPostData(form) {
        form.addEventListener('submit', (e) => {
            e.preventDefault();

            let statusMessage = document.createElement('img');
            statusMessage.src = message.loading;
            statusMessage.style.cssText = `
                display: block;
                margin: 0 auto;
            `;
            form.insertAdjacentElement('afterend', statusMessage);
        
            const formData = new FormData(form);

            const json = JSON.stringify(Object.fromEntries(formData.entries()));

            postData('http://localhost:3000/requests', json)
            .then(data => {
                console.log(data);
                showThanksModal(message.success);
                statusMessage.remove();
            }).catch(() => {
                showThanksModal(message.failure);
            }).finally(() => {
                form.reset();
            });
        });
    }

    function showThanksModal(message) {
        const prevModalDialog = document.querySelector('.modal__dialog');

        prevModalDialog.classList.add('hide');
        openModal();

        const thanksModal = document.createElement('div');
        thanksModal.classList.add('modal__dialog');
        thanksModal.innerHTML = `
            <div class="modal__content">
                <div class="modal__close" data-close>×</div>
                <div class="modal__title">${message}</div>
            </div>
        `;
        document.querySelector('.modal').append(thanksModal);
        setTimeout(() => {
            thanksModal.remove();
            prevModalDialog.classList.add('show');
            prevModalDialog.classList.remove('hide');
            closeModal();
        }, 4000);
    }
});
```

  **[⬆ Наверх](#top)**

	
314. ### <a name="314"></a> Регулярные выражения RegExp

Регулярные выражения (их еще называют regexp, или regex) — это механизм для поиска и замены текста. В строке, файле, нескольких файлах... Их используют разработчики в коде приложения, тестировщики в автотестах, да просто при работе в командной строке!

«Длинный» синтаксис:

regexp = new RegExp("шаблон", "флаги");

И короткий синтаксис, использующий слеши "/":

- regexp = /шаблон/; // без флагов
- regexp = /шаблон/gmi; // с флагами gmi

Регулярное выражение состоит из шаблона и необязательных флагов: 
- g - С этим флагом поиск ищет все совпадения, без него – только первое, 
- i - С этим флагом поиск не зависит от регистра: нет разницы между A и a, 
- m - Многострочный режим, 
- u - Включает полную поддержку юникода. Флаг разрешает корректную обработку суррогатных пар, 
- s - Включает режим «dotall», при котором точка . может соответствовать символу перевода строки \n, y - Режим поиска на конкретной позиции в тексте.
	
- Без флагов и специальных символов, которые мы изучим позже, поиск по регулярному выражению аналогичен поиску подстроки.
- Метод str.match(regexp) ищет совпадения: все, если есть флаг g, иначе только первое.
- Метод str.replace(regexp, replacement) заменяет совпадения с regexp на replacement: все, если у регулярного выражения есть флаг g, иначе только первое.
- Метод regexp.test(str) возвращает true, если есть хоть одно совпадение, иначе false.

\D - не числа

\W - не буквы


i - если мы хотим что-то найти вне зависимости регистра

g - глобал, это когда мы пытаемся найти сразу несколько вхождений

m - включает многострочный режим


\d - ищем цыфры

\w - ищем все слова, все буквы

\s - ищем все пробелы 

\b - граница слова

\B — не граница слова

^ - начало строки

$ - конец строки

[] - Соответствует символам в скобках

[^ ] - Соответствует символам НЕ в скобках

| - Либо Или

( )     - Группа


Квантификаторы:

* - 0 или больше

+ - 1 или больше

? - 0 или один

{3} - Точный номер

{3,4} - Диапазон номеров (минимум, максимум)


(/\./g) - экранирование - Чтобы использовать специальный символ как обычный, добавьте к нему обратную косую черту: \.. - это называется «экранирование символа

```js
/* 
new RegExp('pattern', 'flags');

/pattern/f


i - если мы хотим что-то найти вне зависимости регистра
g - глобал, это когда мы пытаемся найти сразу несколько вхождений
m - включает многострочный режим

\d - ищем цыфры
\w - ищем все слова, все буквы
\s - ищем все пробелы */


const ans = prompt('Введите ваше имя');

const reg = /n/ig;

console.log(ans.search(reg));
console.log(ans.match(reg));



const pass = prompt('Password');

console.log(pass.replace(/./g, "*"));
"." - означает все символы


(/\./g) - экранирование

console.log(pass.replace(/\./g, "*"));



console.log('12-34-56'.replace(/-/g, ':'));


const ans = prompt('Введите ваше число');

const reg = /\d/g;

console.log(reg.test(ans));

console.log(ans.match(reg));


const str = 'My name is R2D2';

console.log(str.match(/\w\d\w\d/i));



const str = 'My name is R2D2';

console.log(str.match(/\w\d\w\d/i));

console.log(str.match(/\D/ig));



/* 
\D - не числа
\W - не буквы


i - если мы хотим что-то найти вне зависимости регистра
g - глобал, это когда мы пытаемся найти сразу несколько вхождений
m - включает многострочный режим

\d - ищем цыфры
\w - ищем все слова, все буквы
\s - ищем все пробелы  */
```

https://learn.javascript.ru/regexp-introduction

  **[⬆ Наверх](#top)**
	
315. ### <a name="315"></a> Web Animations API

```js
'use strict';

const btnPhone = document.querySelector('#iphone'),
  btnMacbook = document.querySelector('#macbook'),
  images = document.querySelectorAll('img');

let phoneAnimation;

btnPhone.addEventListener('click', () => {
  if (!phoneAnimation) {
    phoneAnimation = images[0].animate(
      [
        { transform: 'translateY(0) rotate(0deg)', filter: 'opacity(100%)' },
        {
          transform: 'translateY(100px) rotate(180deg)',
          filter: 'opacity(50%)',
        },
        {
          transform: 'translateY(-100px) rotate(270deg)',
          filter: 'opacity(75%)',
        },
        { transform: 'translateY(0) rotate(360deg)', filter: 'opacity(100%)' },
      ],
      {
        duration: 3000,
        iterations: Infinity,
      }
    );
  } else if (phoneAnimation.playState === 'paused') {
    phoneAnimation.play();
  } else {
    phoneAnimation.pause();
  }
});
```

https://developer.mozilla.org/ru/docs/Web/API/Animation

  **[⬆ Наверх](#top)**
	
316. ### <a name="316"></a> Геттеры и сеттеры (свойства объектов)

Геттеры - Иногда желательно разрешить доступ к свойству, которое возвращает динамически вычисляемое значение, или вы можете захотеть отражать состояние внутренней переменной без необходимости использования явных вызовов методов. В JavaScript, это можно реализовать при помощи использования геттера.

Невозможно сделать так, чтобы геттер был привязан к свойству и одновременно чтобы это свойство действительно содержало значение, хотя можно использовать геттер и сеттер в сочетании, чтобы создать тип псевдо-свойство.


Сеттер - В JavaScript, сеттер можно использовать для выполнения функции, когда будет попытка изменения указанного свойства. Сеттеры используются чаще всего в сочетании с геттерами для создания одного из видов псевдо-свойства. Невозможно одновременно иметь сеттер для свойства, которое содержит фактическое значение.

```jsx harmony
class User {

  constructor(name) {
    // вызывает сеттер
    this.name = name;
  }

  get name() {
    return this._name;
  }

  set name(value) {
    if (value.length < 4) {
      alert("Имя слишком короткое.");
      return;
    }
    this._name = value;
  }

}

let user = new User("Иван");
alert(user.name); // Иван

user = new User(""); // Имя слишком короткое.
```

свойства Аксцессоры делятся на две группы: getter и setter. 
			 
- getter - позволяют нам получать какое-то значения свойства
- setter - позваоляют устанавливать какое-то значение свойства
			 
```js
const person = {
  name: 'Alex',
  age: 30,

  get userAge() {
    return this.age;
  },

  set userAge(num) {
    this.age = num;
  }
};

console.log(person.userAge);

console.log(person.userAge = 32);
console.log(person.userAge);
```			 

### Object.create(), get & set
```js
const person = Object.create(
  {
    calculateAge() {
      console.log('Age:', new Date().getFullYear() - this.birthYear)
    }
  }, 
  {
  name: {
    value: 'Spacy',
    enumerable: true,
    writable: true,
    configurable: true
  },
  birthYear: {
    value: 1990,
    enumerable: false,
    writable: false,
    configurable: false
  },
  age: {
    get() {
      return new Date().getFullYear() - this.birthYear
    },
    set(value) {
      // document.body.style.background = 'red'
      console.log('Set age', value)
    }
  }
})

console.log(person.age) // 32

person.age = 100
person.age = 'dfasf'

console.log(person.age) // Age: 32

person.name = 'Max'

console.log(person.calculateAge()) // undefined

console.log(person) // { name: 'Max' }

delete person.name
console.log(person.name) // undefined

delete person.birthYear
console.log(person.birthYear) // 1990


for (let key in person) {
  if (person.hasOwnProperty(key)) {
    
    console.log('Key', key, person[key])

  }
}
```    

  **[⬆ Наверх](#top)**

317. ### <a name="317"></a> Инкапсуляция

`Инкапсуляция` - это упаковка данных и функций в один компонент (например, класс) и последующий контроль доступа к этому компоненту, создавая тем самым "чёрный ящик" из объекта. По этой причине, пользователю необходимо знать только интерфейс этого класса (то есть данные и функции, предоставляемые для взаимодействия с классом извне), а не то, как он реализован внутри.

Инкапсуляция означает в ООП -  обьект хранит свое состояние в приватном порядке, и только методы обьекта имеют доступ для его изменений

```js
// Constructor

function User(name, age) {
  this.name = name;
  let userAge = age;


  this.say = function() {
    console.log(`Имя пользлватель: ${this.name}, возраст ${userAge}`);
  };

  this.getAge = function() {
    return userAge;
  };

  this.setAge = function(age) {
    if (typeof age === 'number' && age > 0 && age < 110) {
      userAge = age;
    } else {
      console.log('Недопустимое значение!');
    }
  };
}

const ivan = new User('Ivan', 27);

console.log(ivan.name);
console.log(ivan.getAge());

ivan.setAge(30);
ivan.setAge(300);
console.log(ivan.getAge());

ivan.say();
```

```js
// Class

class User {
  constructor(name, age) {
    this.name = name;
    this._age = age;
  }


  
  say() {
    console.log(`Имя пользлватель: ${this.name}, возраст ${this._age}`);
  }

  get age() {
    return this._age;
  }

  set age(age) {
    if (typeof age === 'number' && age > 0 && age < 110) {
      this._age = age;
    } else {
      console.log('Недопустимое значение!');
    }
  }
}

const ivan = new User('Ivan', 27);

console.log(ivan.age);
ivan.age = 99;
console.log(ivan.age);

ivan.say();
```

```js
// Class #, приватное свойство, еще не внесено в основу

class User {
  constructor(name, age) {
    this.name = name;
    this._age = age;
  }

  #surname = ' Pastuxov';

  
  say = () => {
    console.log(`Имя пользлватель: ${this.name}${this.#surname}, возраст ${this._age}`);
  }

  get age() {
    return this._age;
  }

  set age(age) {
    if (typeof age === 'number' && age > 0 && age < 110) {
      this._age = age;
    } else {
      console.log('Недопустимое значение!');
    }
  }
}

const ivan = new User('Ivan', 27);

console.log(ivan.surname);

ivan.say();
```

  **[⬆ Наверх](#top)**
	
318. ### <a name="318"></a> Функции-генераторы

```js
function* generator() {
  yield 'S';
  yield 'c';
  yield 'r';
  yield 'i';
  yield 'p';
  yield 't';
}

const str = generator();

console.log(str.next());
console.log(str.next());
console.log(str.next());
console.log(str.next());
console.log(str.next());
console.log(str.next());
console.log(str.next());

console.log(str.next().value); // S
```

```js
function* count(n) {
  for (let i = 0; i < n; i++) {
    yield i;
  }
}

const counter = count(7);

console.log(counter.next().value); //0
console.log(counter.next().value); //1
console.log(counter.next().value); //2

for (let k of count(7)) {
  console.log(k);
} // 0, 1, 2, 3, 4, 5, 6
```

https://learn.javascript.ru/generators

  **[⬆ Наверх](#top)**
	
319. ### <a name="319"></a> JS анимации, requestAnimationFrame

```js
const btn = document.querySelector('.btn'),
      elem = document.querySelector('.box');  
let pos = 0;

// function myAnimation() {
//     let pos = 0;

//     const id = setInterval(frame, 10);
//     function frame() {
//         if (pos == 300) {
//             clearInterval(id);
//         } else {
//             pos++;
//             elem.style.top = pos + "px";
//             elem.style.left = pos + 'px';
//         }
//     }
// }


function myAnimation() {
    pos++;
    elem.style.top = pos + "px";
    elem.style.left = pos + 'px';

    if (pos < 300) {
        requestAnimationFrame(myAnimation);
    }
}

btn.addEventListener('click', () => requestAnimationFrame(myAnimation));


let id = requestAnimationFrame(myAnimation);
cancelAnimationFrame(id);	
```	

  **[⬆ Наверх](#top)**
	
320. ### <a name="320"></a> Event loop, подробная работа асинхронных и синхронных операций

Цикл событий - это однопоточный цикл, который контролирует стек вызовов и проверяет, есть ли какая-либо работа, которую необходимо выполнить в очереди задач. Если стек вызовов пуст и в очереди задач есть callback-функции, то функция удаляется из очереди и помещается в стек вызовов для выполнения.

Событийный цикл
	
Есть бесконечный цикл, в котором движок JavaScript ожидает задачи, исполняет их и снова ожидает появления новых.

Общий алгоритм движка:

1. Пока есть задачи:
- выполнить их, начиная с самой старой
2. Бездействовать до появления новой задачи, а затем перейти к пункту 1

Очередность:
 
1 Выбрать и исполнить старейшую задачу из очереди макрозадач (например, «script»).

2 Исполнить все микрозадачи: Пока очередь микрозадач не пуста: - Выбрать из очереди и исполнить старейшую микрозадачу

3 Отрисовать изменения страницы, если они есть.

4 Если очередь макрозадач пуста – подождать, пока появится макрозадача.

5 Перейти к шагу 1.

### Чтобы добавить в очередь новую макрозадачу:

- Используйте setTimeout(f) с нулевой задержкой.
 
Этот способ можно использовать для разбиения больших вычислительных задач на части, чтобы браузер мог реагировать на пользовательские события и показывать прогресс выполнения этих частей.

Также это используется в обработчиках событий для отложенного выполнения действия после того, как событие полностью обработано (всплытие завершено).
 
### Для добавления в очередь новой микрозадачи:

- Используйте queueMicrotask(f).
- Также обработчики промисов выполняются в рамках очереди микрозадач.
- Микрозадачи приходят только из кода. Обычно они создаются промисами: выполнение обработчика .then/catch/finally становится микрозадачей. 
- Микрозадачи также используются «под капотом» await, т.к. это форма обработки промиса.
 
События пользовательского интерфейса и сетевые события в промежутках между микрозадачами не обрабатываются: микрозадачи исполняются непрерывно одна за другой.

Поэтому queueMicrotask можно использовать для асинхронного выполнения функции в том же состоянии окружения.
 

Сразу после каждой макрозадачи движок исполняет все задачи из очереди микрозадач перед тем, как выполнить следующую макрозадачу или отобразить изменения на странице, или сделать что-то ещё.

Все микрозадачи завершаются до обработки каких-либо событий или рендеринга, или перехода к другой макрозадаче.

https://learn.javascript.ru/event-loop

https://medium.com/devschacht/javascript-eventloop-explained-f2dcf84e36ee

https://habr.com/ru/company/ruvds/blog/337662/
 
### Макрозадачи и Микрозадачи:
 
При одном обходе цикла событий будет обработана ровно одна задача из очереди макрозадач (эта очередь просто называется очередью задач в спецификации WHATWG ). После завершения этой макрозадачи все доступные микрозадачи будут обработаны, а именно в рамках одного и того же цикла обхода. Пока эти микрозадачи обрабатываются, они могут ставить в очередь еще больше микрозадач, которые будут выполняться одна за другой, пока очередь микрозадач не будет исчерпана.

Каковы практические последствия этого?
Если микрозадача рекурсивно ставит в очередь другие микрозадачи, может потребоваться много времени, пока не будет обработана следующая макрозадача. Это означает, что вы можете получить заблокированный UI или какой-то завершенный ввод-вывод в вашем приложении.

Однако, по крайней мере, в отношении функции Node.js's process.nextTick (которая ставит в очередь микрозадачи ), существует встроенная защита от такой блокировки с помощью process.maxTickDepth. Это значение по умолчанию равно 1000, что сокращает дальнейшую обработку микрозадач после достижения этого предела, что позволяет обрабатывать следующую макрозадачу )

Так когда же использовать что?
В принципе, используйте микрозадачи , когда вам нужно делать что-то асинхронно синхронно (т. Е. Когда вы сказали бы, что выполните эту (микро -) задачу в самом ближайшем будущем ). В противном случае придерживайтесь макрозадач .

Примеры
- макрозадачи: setTimeout , setInterval , setImmediate , requestAnimationFrame , ввод-вывод , UI
- микрозадачи: process.nextTick , queueMicrotask , MutationObserver	
	

Порядок выполнения событийного цикла:
1. Выполнение Макрозадач
2. После каждой Макрозадачи, выполняется стек Микрозадач.
3. Выполняются все Web Api

	
### WebApi 
Интерфейс прикладного программирования (Application Programming Interfaces, APIs) - это готовые конструкции языка программирования, позволяющие разработчику строить сложную функциональность с меньшими усилиями. Они "скрывают" более сложный код от программиста, обеспечивая простоту использования.	
	
	
Итак, когда использовать что?

В основном, используйте микрозадачи, когда вам нужно делать что-то асинхронно синхронно (то есть когда вы говорите, что выполняете эту (микро) задачу в ближайшем будущем ). В противном случае, придерживайтесь макрозадач .

Примеры
макрозадачи: setTimeout , setInterval , setImmediate , requestAnimationFrame , I / O ,

микрозадачи рендеринга UI: process.nextTick , Promises , queueMicrotask , MutationObserver


Порядок выполнения событийного цыклв
```js
const promise = new Promise((resolve) => {
  resolve('hello');
  console.log('hello');
});
setTimeout(() => console.log('123'), 100);
promise.then((res) => {
  console.log('res', res);
});
console.log('My name is Maxim');
```
=> порядок выполнения =>

1. hello => console.log('hello')
2. My name is Maxim
3. res hello
4. 123


описание

1. console.log('gdsg') попадает в колл стэк и выполняется
2. setTimeout попадает в колл стэк => попадает в Web Api и делается 5 сек(коллбэк)
3. следующий console.log выполняется
4. дальше setTimeout попадает в Callback Queue и дальше попадает в Call Stack и выполняет console.log


Отметим две детали:

Микрозадачи приходят только из кода. Обычно они создаются промисами: выполнение обработчика .then/catch/finally становится микрозадачей. Микрозадачи также используются «под капотом» await, т.к. это форма обработки промиса.

Также есть специальная функция queueMicrotask(func), которая помещает func в очередь микрозадач.

Сразу после каждой макрозадачи движок исполняет все задачи из очереди микрозадач перед тем, как выполнить следующую макрозадачу или отобразить изменения на странице, или сделать что-то ещё.

```js
setTimeout(() => alert("timeout"));

Promise.resolve()
  .then(() => alert("promise"));

alert("code");
```

Какой здесь будет порядок?

1. code появляется первым, т.к. это обычный синхронный вызов.
2. promise появляется вторым, потому что .then проходит через очередь микрозадач и выполняется после текущего синхронного кода.
3. timeout появляется последним, потому что это макрозадача.

### Пример
```jsx harmony
console.log('1');
const p = new Promise((res) => {
    console.log('2');
    if (true) res('name')
})

setTimeout(() => console.log('3'))

p.then(name => {
    console.log(name);
})

console.log('5');

// 1, 2, 5, name, 3
```

### Exsmple
```js
setTimeout(() => console.log('timeout'));

Promise.resolve()
  .then(() => console.log('promise'));

queueMicrotask(() => console.log('queueMicrotask'));

Promise.resolve()
  .then(() => console.log('promise2'));

console.log('code');  

// code, promise, queueMicrotask, promise2, timeout


// makrotask
// microtasks: then/catch/finally/await
// render
// makrotask
// microtasks: then/catch/finally/await
// render
// makrotask
```

Example ->
```js
setTimeout(function timeout() {
  console.log(' 1');
}, 0);

let createPromise = new Promise(function (resolve, reject) {
  console.log('2');
  resolve();
});

createPromise.then(function () {
  console.log(3);
});

console.log(4);

// 2 4 3 1
```

![52](https://user-images.githubusercontent.com/80325645/154839062-6f12e62c-0a01-4fb8-bc3b-76fb60953b15.jpg)

  **[⬆ Наверх](#top)**
	
321. ### <a name="321"></a> Что такое Set, Map, WeakSet и WeakMap?

В ES-2015 появились новые типы коллекций в JavaScript: Set, Map, WeakSet и WeakMap.

`Map` – коллекция для хранения записей вида ключ:значение. В отличие от объектов, в которых ключами могут быть только строки, в Map ключом может быть произвольное значение, например:
```js
'use strict';

let map = new Map();

map.set('1', 'str1');   // ключ-строка
map.set(1, 'num1');     // число
map.set(true, 'bool1'); // булевое значение

// в обычном объекте это было бы одно и то же,
// map сохраняет тип ключа
alert( map.get(1)   ); // 'num1'
alert( map.get('1') ); // 'str1'

alert( map.size ); // 3
```

`Set` – коллекция для хранения множества значений, причём каждое значение может встречаться лишь один раз. Например, к нам приходят посетители, и мы хотели бы сохранять всех, кто пришёл. При этом повторные визиты не должны приводить к дубликатам, то есть каждого посетителя нужно «посчитать» ровно один раз. Set для этого отлично подходит:
```js
'use strict';

let set = new Set();

let vasya = {name: "Вася"};
let petya = {name: "Петя"};
let dasha = {name: "Даша"};

// посещения, некоторые пользователи заходят много раз
set.add(vasya);
set.add(petya);
set.add(dasha);
set.add(vasya);
set.add(petya);

// set сохраняет только уникальные значения
alert( set.size ); // 3

set.forEach( user => alert(user.name ) ); // Вася, Петя, Даша
```

`WeakMap` – это Map-подобная коллекция, позволяющая использовать в качестве ключей только объекты, и автоматически удаляющая их вместе с соответствующими значениями, как только они становятся недостижимыми иными путями.

`WeakSet` – это Set-подобная коллекция, которая хранит только объекты и удаляет их, как только они становятся недостижимыми иными путями.

### WeakMap - Первое его отличие от Map в том, что ключи в WeakMap должны быть объектами, а не примитивными значениями:

`WeakMap` – это Map-подобная коллекция, позволяющая использовать в качестве ключей только объекты, и автоматически удаляющая их вместе с соответствующими значениями, как только они становятся недостижимыми иными путями.

```js
let weakMap = new WeakMap();

let obj = {};

weakMap.set(obj, "ok"); // работает (объект в качестве ключа)

// нельзя использовать строку в качестве ключа
weakMap.set("test", "Whoops"); // Ошибка, потому что "test" не объект
```

Теперь, если мы используем объект в качестве ключа и если больше нет ссылок на этот объект, то он будет удалён из памяти (и из объекта WeakMap) автоматически.

```js
let john = { name: "John" };

let weakMap = new WeakMap();
weakMap.set(john, "...");

john = null; // перезаписываем ссылку на объект

// объект john удалён из памяти!
```

WeakMap не поддерживает перебор и методы keys(), values(), entries(), так что нет способа взять все ключи или значения из неё.

В WeakMap присутствуют только следующие методы:
- weakMap.get(key)
- weakMap.set(key, value)
- weakMap.delete(key)
- weakMap.has(key)

К чему такие ограничения? Из-за особенностей технической реализации. Если объект станет недостижим (как объект john в примере выше), то он будет автоматически удалён сборщиком мусора. Но нет информации, в какой момент произойдёт эта очистка.

Решение о том, когда делать сборку мусора, принимает движок JavaScript. Он может посчитать необходимым как удалить объект прямо сейчас, так и отложить эту операцию, чтобы удалить большее количество объектов за раз позже. Так что технически количество элементов в коллекции WeakMap неизвестно. Движок может произвести очистку сразу или потом, или сделать это частично. По этой причине методы для доступа ко всем сразу ключам/значениям недоступны.

Example
```js
let cache = new WeakMap();

function cahcheUser(user) {
  if (!cache.has(user)) {
    cache.set(user, Date.now());
  }

  return cache.get(user);
}

let lena = { name: 'Elena' };
let alex = { name: 'Alex' };

cahcheUser(lena);
cahcheUser(alex);

lena = null;

console.log(cache.has(lena));
console.log(cache.has(alex));
```

### WeakSet

`WeakSet` – это Set-подобная коллекция, которая хранит только объекты и удаляет их, как только они становятся недостижимыми иными путями.

Коллекция WeakSet ведёт себя похоже:

- Она аналогична Set, но мы можем добавлять в WeakSet только объекты (не примитивные значения).
- Объект присутствует в множестве только до тех пор, пока доступен где-то ещё.
- Как и Set, она поддерживает add, has и delete, но не size, keys() и не является перебираемой.

Будучи «слабой» версией оригинальной структуры данных, она тоже служит в качестве дополнительного хранилища. Но не для произвольных данных, а скорее для значений типа «да/нет». Присутствие во множестве WeakSet может что-то сказать нам об объекте.

Например, мы можем добавлять пользователей в WeakSet для учёта тех, кто посещал наш сайт:

```js
let visitedSet = new WeakSet();

let john = { name: "John" };
let pete = { name: "Pete" };
let mary = { name: "Mary" };

visitedSet.add(john); // John заходил к нам
visitedSet.add(pete); // потом Pete
visitedSet.add(john); // John снова

// visitedSet сейчас содержит двух пользователей

// проверим, заходил ли John?
alert(visitedSet.has(john)); // true

// проверим, заходила ли Mary?
alert(visitedSet.has(mary)); // false

john = null;

// структура данных visitedSet будет очищена автоматически
Наиболее значительным ограничением WeakMap и WeakSet является то, что их нельзя перебрать или взять всё содержимое. Это может доставлять неудобства, но не мешает WeakMap/WeakSet выполнять их главную задачу – быть дополнительным хранилищем данных для объектов, управляемых из каких-то других мест в коде.
```

// Example WeakSet

// add, has, delete
```js
let messages = [
{text: 'Hello', from: 'John'},
{text: 'World', from: 'Alex'},
{text: '....', from: 'M'},
];

let readMessages = new WeakSet();

readMessages.add(messages[0]);
// readMessages.add(messages[1]);

readMessages.add(messages[0]);
messages.shift();

console.log(readMessages.has(messages[0]));
```

  **[⬆ Наверх](#top)**

700. ### <a name="700"></a> Map, Set

### Map

```js
const shops = [
  {rice: 500},
  {oil: 200},
  {bread: 50}
]

const budget = [5000, 15000, 25000];

const map = new Map([
  [{paper: 400}, 8000]
]);

// map.set(shops[0], 5000);
// map.set(shops[1], 15000);
// map.set(shops[2], 25000);

shops.forEach((shop, i) => {
  map.set(shop, budget[i]);
})

console.log(map);
/* Map(3) {
  { rice: 500 } => 5000,
  { oil: 200 } => 15000,
  { bread: 50 } => 25000
} */

console.log(map.get(shops[0]))
console.log(map.has(shops[0]))

map.delete();
map.clear();
map.size();


// map.keys() возвращает итерируемый обьект по ключам

console.log(map.keys())

for (let shop of map.keys()) {
  console.log(shop)
}

const goods = [];

for (let shop of map.keys()) {
  goods.push(Object.keys(shop)[0])
}

console.log(goods)

// map.values() - возвращаем свойства

for (let price of map.values()) {
  console.log(price)
}

// map.entries()

for (let price of map.entries()) {
  console.log(price)
}

for (let [shop, price] of map.entries()) {
  console.log(shop, price)
}


// forEach

map.forEach((value, key, map) => {
  console.log(key, value)
});



const userFour = {
  name: 'Alex',
  surname: 'Smith',
  birhday: '20/04/1990',
  showMyPublicData: function() {
    console.log(`${this.name} ${this.surname}`);
  }
}

const userMap = new Map(Object.entries(userFour))

console.log(userMap);

const newUserFour = Object.fromEntries(userMap)

console.log(userMap);
```

### Set

```js
const array = [1, 1, 2, 2, 4, 5, 6, 5];

const set = new Set(array);

console.log(set) // { 1, 2, 4, 5, 6 }


const array3 = ['Alex', 'Ann', 'Alex', 'Oleg'];

const set2 = new Set(array3);

set2.add('Ivan');
set2.add('Oleg');
set2.add('Vasya');

set2.add('Ivan')
    .add('Kostya')

console.log(set2);


set.delete(value)
set.has(value)
set.clear()
set.size()


for (let value of set2) console.log(value)


set2.forEach((value, valueAgain, set) => {
  console.log(value, valueAgain)
})


console.log(set.values())

console.log(set.keys())

console.log(set.entries())


function unique(array) {
  return Array.from(new Set(array))
}

console.log(unique(array))
```

  **[⬆ Наверх](#top)** 


322. ### <a name="322"></a> Прототипы, цепочка прототипов

`Прототипы` - это механизм, с помощью которого объекты JavaScript наследуют свойства друг от друга.

JavaScript часто описывают как язык прототипного наследования — каждый объект, имеет объект-прототип, который выступает как шаблон, от которого объект наследует методы и свойства. 

Объект-прототип так же может иметь свой прототип и наследовать его свойства и методы и так далее. Это часто называется цепочкой прототипов и объясняет почему одним объектам доступны свойства и методы которые определены в других объектах.

- `__proto__` - это геттер и сеттер для обьекта, установить или получить прототип готового обьекта.
- `[[Prototype]]` - это скрытое свойство, напряму в js оно не доступно, оно доступно через геттер, сеттер, __proto__, setObjectPrototype, getObjectPrototype методы
- `obj.prototype` - это только у функций конструкторов бывает, будет использоваться как: Прототип обьекта который будет создан с помощью нашей функции конструктора

### "__proto__"" and ""prototype"" properties

`__proto__` фактический объект, который используется в цепочке поиска для разрешения методов и т. д. 
`prototype` - это объект, который используется для построения __proto__ при создании объекта с помощью new:
```js
( new Foo ).__proto__ === Foo.prototype;
( new Foo ).prototype === undefined;
```

В JavaScript объекты имеют специальное скрытое свойство [[Prototype]] (так оно названо в спецификации), которое либо равно null, либо ссылается на другой объект. Этот объект называется «прототип»:

Свойство [[Prototype]] является внутренним и скрытым, но есть много способов задать его.

Одним из них является использование __proto__, например так:
```js
let animal = {
  eats: true
};
let rabbit = {
  jumps: true
};

rabbit.__proto__ = animal;
```

Если мы ищем свойство в rabbit, а оно отсутствует, JavaScript автоматически берёт его из animal.
```js
let animal = {
  eats: true
};
let rabbit = {
  jumps: true
};

rabbit.__proto__ = animal; // (*)

// теперь мы можем найти оба свойства в rabbit:
alert( rabbit.eats ); // true (**)
alert( rabbit.jumps ); // true
```
Здесь строка (*) устанавливает animal как прототип для rabbit.

Затем, когда alert пытается прочитать свойство rabbit.eats (**), его нет в rabbit, поэтому JavaScript следует по ссылке [[Prototype]] и находит его в animal

Здесь мы можем сказать, что "animal является прототипом rabbit" или "rabbit прототипно наследует от animal".

Так что если у animal много полезных свойств и методов, то они автоматически становятся доступными у rabbit. Такие свойства называются «унаследованными».

Если у нас есть метод в animal, он может быть вызван на rabbit:
```js
let animal = {
  eats: true,
  walk() {
    alert("Animal walk");
  }
};

let rabbit = {
  jumps: true,
  __proto__: animal
};

// walk взят из прототипа
rabbit.walk(); // Animal walk
```
### Цепочка прототипов может быть длиннее:
```js
let animal = {
  eats: true,
  walk() {
    alert("Animal walk");
  }
};

let rabbit = {
  jumps: true,
  __proto__: animal
};

let longEar = {
  earLength: 10,
  __proto__: rabbit
};

// walk взят из цепочки прототипов
longEar.walk(); // Animal walk
alert(longEar.jumps); // true (из rabbit)
```


### Cоздать объект с прототипом

```js
const person = new Object({
    name: 'Spacy',
    age: 30,
    greet: function() {
      console.log('Greet!')
  }
})

console.log(person)
// console.log(person.name)
// console.log(person.greet())


// console.log(person.sayHello())

// console.log(person.toString())

Object.prototype.sayHallo = function() {
  console.log('Hello!');
}

console.log(person.sayHallo())


const lena = Object.create(person)

console.log(lena)
console.log(lena.greet())
console.log(lena.sayHallo())

console.log(lena.name)

lena.name = 'Elena';
console.log(lena.name)


const str = new String('I am string');

console.log(str)
console.log(str.sayHallo())
```
	
prototype - это определенный обьект который присутствует у обьектов и он вызывается по цепочке сверху-вниз, если мы находим какие-то поля на верхнем уровне или функции - мы обращаемся к ним, если не находим - мы идем вниз по прототипу и ищем либо поля либо функции.

```jsx harmony
const person = {
  name: 'Spacy',
  age: 30,
  greet: function() {
    console.log('Greet')
  }
}

console.log(person)
console.log(person.name)
console.log(person.greet())

console.log(person.sayHello())
console.log(person.toString())

console.log(person)


const person = new Object({
  name: 'Spacy',
  age: 30,
  greet: function() {
    console.log('Greet')
  }
})

// console.log(person)

Object.prototype.sayHello = function() {
  console.log('Hello')
}

console.log(person.sayHello())



const lena = Object.create(person);

console.log(lena)

console.log(lena.greet())
console.log(lena.toString())

console.log(lena.name)

lena.name = 'elena';

console.log(lena)
console.log(lena.name)

console.log(lena.sayHello())


const str = new String('I am string');

console.log(str)                         
```
 
### Пример прототипов
```js
function Cat(name, color) {
  this.name = name
  this.color = color
}

Cat.prototype.voice = function() {
  console.log(`Cat ${this.name} says myay`)
}

const cat = new Cat('Kot', 'white')

console.log(Cat.prototype) // { voice: [Function (anonymous)] }
console.log(cat) // Cat { name: 'Kot', color: 'white' }
console.log(cat.__proto__ === Cat.prototype) // true
console.log(cat.constructor) // [Function: Cat]
cat.voice() // Cat Kot says myay


// ============
function Person() {}
Person.prototype.legs = 2
Person.prototype.skin = 'white'

const person = new Person()
person.name = 'Vladilen'

console.log('skin' in person) // true
console.log(person.legs) // 2
console.log(person.name) // Vladilen

console.log(person.hasOwnProperty('name')) // true
console.log(person.hasOwnProperty('skin')) // false


// Object.create()
var proto = {year: 2019}
const myYear = Object.create(proto)

console.log(myYear.year) // 2019

proto.year = 2200

console.log(myYear.year) // 2200

console.log(myYear.hasOwnProperty('year')) // false
console.log(myYear.__proto__ === proto) // true
```

### Задача: Прототипы и this
```js
const array = [1, 2, 3, 4, 5]

Array.prototype.multBy = function(n) {
  return this.map(function(i) {
    return i * n
  })
}

console.log(array.multBy(2)) // [2, 4, 6, 8, 10]


const arr2 = [1, 2, 5].multBy(3)
console.log(arr2) // [3, 6, 15]	
```

  **[⬆ Наверх](#top)**
	
323. ### <a name="323"></a> Прототипы, Object.create()

Все объекты в JavaScript имеют свойство proto, которое является ссылкой на другой объект. Когда происходит обращение к свойству объекта, и если свойство не найдено в этом объекте, то механизм JavaScript просматривает прототип объекта, затем прототип прототипа и т.д. До тех пор, пока не найдет определенное свойство на одном из прототипов или до тех пор, пока он не достигнет конца цепочки прототипов. Такое поведение имитирует классическое наследование, но на самом деле это скорее делегирование, чем наследование.

В плане наследования JavaScript работает лишь с одной сущностью: **объектами**. Каждый объект имеет внутреннюю ссылку на другой объект, называемый его **прототипом**. У объекта-прототипа также есть свой собственный прототип и так далее до тех пор, пока цепочка не завершится объектом, у которого свойство prototype равно **null**. По определению, null не имеет прототипа и является завершающим звеном в цепочке прототипов.

- `__proto__` - это геттер и сеттер для обьекта, установить или получить прототип готового обьекта.
- `[[Prototype]]` - это скрытое свойство, напряму в js оно не доступно, оно доступно через геттер, сеттер, __proto__, setObjectPrototype, getObjectPrototype методы
- `obj.prototype` - это только у функций конструкторов бывает, будет использоваться как: Прототип обьекта который будет создан с помощью нашей функции конструктора

В JavaScript "конструктор" — это "просто" функция, вызываемая с оператором new.

В ECMAScript 5 представлен новый метод создания объектов: Object.create. Прототип создаваемого объекта указывается в первом аргументе этого метода.

Если необходимо проверить, определено ли свойство у *самого объекта*, а не где-то в его цепочке прототипов, вы можете использовать метод `[hasOwnProperty]`, который все объекты наследуют от `Object.prototype`.

- `[hasOwnProperty]` — единственная существующая в JavaScript возможность работать со свойствами, не затрагивая цепочку прототипов.

Важно:
- Типы определяются в `.prototype`
- Для наследования используется `Object.create()`

- Свойство "`prototype`" функции-конструктора. 

- Свойство `__proto__` — исторически обусловленный геттер/сеттер для `[[Prototype]]`
Обратите внимание, что `__proto__` — не то же самое, что `[[Prototype]]`. Это геттер/сеттер для него.
Он существует по историческим причинам, в современном языке его заменяют функции `Object.getPrototypeOf`/`Object.setPrototypeOf`, которые также получают/устанавливают прототип.

- `Object.create(proto, [descriptors])` – создаёт пустой объект со свойством `[[Prototype]]`, указанным как `proto`, и необязательными дескрипторами свойств `descriptors`.
- `Object.getPrototypeOf(obj)` – возвращает свойство `[[Prototype]]` объекта `obj`.
- `Object.setPrototypeOf(obj, proto)` – устанавливает свойство `[[Prototype]]` объекта `obj` как `proto`.

https://learn.javascript.ru/prototype-inheritance

### Object.create()
```js
const person = Object.create(
  {
    calculateAge() {
      console.log('Age:', new Date().getFullYear() - this.birthYear)
    }
  }, 
  {
  name: {
    value: 'Spacy',
    enumerable: true,
    writable: true,
    configurable: true
  },
  birthYear: {
    value: 1990,
    enumerable: false,
    writable: false,
    configurable: false
  },
  age: {
    get() {
      return new Date().getFullYear() - this.birthYear
    },
    set(value) {
      // document.body.style.background = 'red'
      console.log('Set age', value)
    }
  }
})

console.log(person.age) // 32

person.age = 100
person.age = 'dfasf'

console.log(person.age) // Age: 32

person.name = 'Max'

console.log(person.calculateAge()) // undefined

console.log(person) // { name: 'Max' }

delete person.name
console.log(person.name) // undefined

delete person.birthYear
console.log(person.birthYear) // 1990


for (let key in person) {
  if (person.hasOwnProperty(key)) {
    
    console.log('Key', key, person[key])

  }
}
```

  **[⬆ Наверх](#top)**
	
324. ### <a name="324"></a> Длительный опрос как работает

Длинные опросы – это самый простой способ поддерживать постоянное соединение с сервером, не используя при этом никаких специфических протоколов (типа WebSocket или Server Sent Events).

«Длинные опросы» – гораздо лучший способ взаимодействия с сервером.

Они также очень просты в реализации, и сообщения доставляются без задержек.

Как это происходит:

1. Запрос отправляется на сервер.
2. Сервер не закрывает соединение, пока у него не возникнет сообщение для отсылки.
3. Когда появляется сообщение – сервер отвечает на запрос, посылая его.
4. Браузер немедленно делает новый запрос.

Если соединение будет потеряно, скажем, из-за сетевой ошибки, браузер немедленно посылает новый запрос.

Примерный код клиентской функции subscribe, которая реализует длинные опросы:
```js
async function subscribe() {
  let response = await fetch("/subscribe");

  if (response.status == 502) {
    // Статус 502 - это таймаут соединения;
    // возможен, когда соединение ожидало слишком долго
    // и сервер (или промежуточный прокси) закрыл его
    // давайте восстановим связь
    await subscribe();
  } else if (response.status != 200) {
    // Какая-то ошибка, покажем её
    showMessage(response.statusText);
    // Подключимся снова через секунду.
    await new Promise(resolve => setTimeout(resolve, 1000));
    await subscribe();
  } else {
    // Получим и покажем сообщение
    let message = await response.text();
    showMessage(message);
    // И снова вызовем subscribe() для получения следующего сообщения
    await subscribe();
  }
}

subscribe();
```
Функция subscribe() делает запрос, затем ожидает ответ, обрабатывает его и снова вызывает сама себя.

  **[⬆ Наверх](#top)**
	
325. ### <a name="325"></a> Web Socket

Протокол WebSocket обеспечивает возможность обмена данными между браузером и сервером через постоянное соединение. Данные передаются по нему в обоих направлениях в виде «пакетов», без разрыва соединения и дополнительных HTTP-запросов.

WebSocket особенно хорош для сервисов, которые нуждаются в постоянном обмене данными, например онлайн игры, торговые площадки, работающие в реальном времени, и т.д.

Чтобы открыть веб-сокет-соединение, нам нужно создать объект new WebSocket, указав в url-адресе специальный протокол ws:
```js
let socket = new WebSocket("ws://javascript.info");
```
Также существует протокол wss://, использующий шифрование. Это как HTTPS для веб-сокетов.

Как только объект WebSocket создан, мы должны слушать его события. Их всего 4:
- open – соединение установлено,
- message – получены данные,
- error – ошибка,
- close – соединение закрыто.

```js
let socket = new WebSocket("wss://javascript.info/article/websocket/demo/hello");

socket.onopen = function(e) {
  alert("[open] Соединение установлено");
  alert("Отправляем данные на сервер");
  socket.send("Меня зовут Джон");
};

socket.onmessage = function(event) {
  alert(`[message] Данные получены с сервера: ${event.data}`);
};

socket.onclose = function(event) {
  if (event.wasClean) {
    alert(`[close] Соединение закрыто чисто, код=${event.code} причина=${event.reason}`);
  } else {
    // например, сервер убил процесс или сеть недоступна
    // обычно в этом случае event.code 1006
    alert('[close] Соединение прервано');
  }
};

socket.onerror = function(error) {
  alert(`[error] ${error.message}`);
};
```
### Итого

WebSocket – это современный способ иметь постоянное соединение между браузером и сервером.

- Нет ограничений, связанных с кросс-доменными запросами.
- Имеют хорошую поддержку браузерами.
- Могут отправлять/получать как строки, так и бинарные данные.

API прост.

Методы:
- socket.send(data),
- socket.close([code], [reason]).

События:
- open,
- message,
- error,
- close.

WebSocket сам по себе не содержит такие функции, как переподключение при обрыве соединения, аутентификацию пользователей и другие механизмы высокого уровня. Для этого есть клиентские и серверные библиотеки, а также можно реализовать это вручную.

Иногда, чтобы добавить WebSocket к уже существующему проекту, WebSocket-сервер запускают параллельно с основным сервером. Они совместно использует одну базу данных. Запросы к WebSocket отправляются на wss://ws.site.com – поддомен, который ведёт к WebSocket-серверу, в то время как https://site.com ведёт на основной HTTP-сервер.

  **[⬆ Наверх](#top)**
	
326. ### <a name="326"></a> Способы отправки запроса на сервер

### iFrame
	
`IFrame` — это кадр внутри кадра. Это компонент HTML-элемента, который позволяет встраивать документы, видео и интерактивные медиафайлы на страницу. Сделав это, вы сможете отобразить дополнительную страницу на главной веб-странице.

Элемент iFrame позволяет включать часть содержимого из других источников. Он может интегрировать контент в любом месте на вашей странице, без необходимости включать их в структуру веб-макета, как традиционный элемент.

Однако следует быть осторожными. Чрезмерное использование iFrame может замедлить работу страницы и создать угрозу безопасности, особенно если вы используете контент с подозрительного веб-сайта.	

### src
	
Импортирует файл со скриптами из внешнего файла. Как только внешние инструкции полностью загружаются, браузер обрабатывает их, словно они были внедрены в текущий документ. Файлы со скриптами JavaScript обычно имеют расширение js и могут размещаться в любом доступном месте.

Преимуществ использования внешних файлов несколько. Внешний файл после первого обращения сохраняется в кэше браузера и при последующих вызовах загружается быстрее. Кроме того, вызываемые функции удобно править в одном месте и код проще контролировать. Это особенно актуально, когда множество веб-страниц используют одни и те же скрипты.
	
### jsonp 
	
JSONP — это метод передачи данных JSON, не заботясь о кросс-доменных ограничениях.

В JSONP не используется объект XMLHttpRequest.

Вместо этого JSONP использует тег <script>.

JSONP означает "JSON with padding" (JSON с набивкой) и является дополнением к формату JSON.

Запрос данных с сервера, находящегося в другом домене, может вызвать определенные проблемы из-за политики ограничения домена.

Запрос же внешних скриптов с сервера, находящегося в другом домене, не вызывает таких проблем.

JSONP пользуется этим преимущество, запрашивая файлы при помощи тега <script> вместо объекта XMLHttpRequest.
```js
<script src="//msiter.ru/demo_jsonp.php">
```	

### form
	
Тег <form> устанавливает форму на веб-странице. Форма предназначена для обмена данными между пользователем и сервером. Область применения форм не ограничена отправкой данных на сервер, с помощью клиентских скриптов можно получить доступ к любому элементу формы, изменять его и применять по своему усмотрению.

Документ может содержать любое количество форм, но одновременно на сервер может быть отправлена только одна форма. По этой причине данные форм должны быть независимы друг от друга.

Для отправки формы на сервер используется кнопка Submit, того же можно добиться, если нажать клавишу Enter в пределах формы. Если кнопка Submit отсутствует в форме, клавиша Enter имитирует ее использование.

Когда форма отправляется на сервер, управление данными передается программе, заданной атрибутом action тега <form>. Предварительно браузер подготавливает информацию в виде пары «имя=значение», где имя определяется атрибутом name тега <input>, а значение введено пользователем или установлено в поле формы по умолчанию. Если для отправки данных используется метод GET, то адресная строка может принимать следующий вид.
```js
http://www.htmlbook.ru/cgi-bin/handler.cgi?nick=%C2%E0%ED%FF+%D8%E0%EF%EE%F7%EA%E8%ED&page=5
```
Параметры перечисляются после вопросительного знака, указанного после адреса CGI-программы и разделяются между собой символом амперсанда (&). Нелатинские символы преобразуются в шестнадцатеричное представление (в форме %HH, где HH — шестнадцатеричный код для значения ASCII-символа), пробел заменяется на плюс (+).

Допускается внутрь контейнера <form> помещать другие теги, при этом сама форма никак не отображается на веб-странице, видны только ее элементы и результаты вложенных тегов.
```js
<form action="URL">
  ...
</form>	
```
	
### websocket 
	
Протокол WebSocket обеспечивает возможность обмена данными между браузером и сервером через постоянное соединение. Данные передаются по нему в обоих направлениях в виде «пакетов», без разрыва соединения и дополнительных HTTP-запросов.

WebSocket особенно хорош для сервисов, которые нуждаются в постоянном обмене данными, например онлайн игры, торговые площадки, работающие в реальном времени, и т.д.	
	
Чтобы открыть веб-сокет-соединение, нам нужно создать объект new WebSocket, указав в url-адресе специальный протокол ws:
```js
let socket = new WebSocket("ws://javascript.info");
```	
Также существует протокол wss://, использующий шифрование. Это как HTTPS для веб-сокетов.	

WebSocket – это современный способ иметь постоянное соединение между браузером и сервером.
- Нет ограничений, связанных с кросс-доменными запросами.
- Имеют хорошую поддержку браузерами.
- Могут отправлять/получать как строки, так и бинарные данные.

API прост.
	
Методы:
- socket.send(data),
- socket.close([code], [reason]).

Как только объект WebSocket создан, мы должны слушать его события. Их всего 4:
- open – соединение установлено,
- message – получены данные,
- error – ошибка,
- close – соединение закрыто.	
	
### Пример
```js
let socket = new WebSocket("wss://javascript.info/article/websocket/demo/hello");

socket.onopen = function(e) {
  alert("[open] Соединение установлено");
  alert("Отправляем данные на сервер");
  socket.send("Меня зовут Джон");
};

socket.onmessage = function(event) {
  alert(`[message] Данные получены с сервера: ${event.data}`);
};

socket.onclose = function(event) {
  if (event.wasClean) {
    alert(`[close] Соединение закрыто чисто, код=${event.code} причина=${event.reason}`);
  } else {
    // например, сервер убил процесс или сеть недоступна
    // обычно в этом случае event.code 1006
    alert('[close] Соединение прервано');
  }
};

socket.onerror = function(error) {
  alert(`[error] ${error.message}`);
};	
```	

### Fetch
	
### Пример 1	
```jsx harmony
fetch('http://example.com/movies.json')
  .then((response) => {
    return response.json();
  })
  .then((data) => {
    console.log(data);
  });
```	
Здесь мы забираем JSON файл по сети и выводим его содержимое в консоль. Самый простой способ использования fetch() заключается в вызове этой функии с одним аргументом — строкой, содержащей путь к ресурсу, который вы хотите получить — которая возвращает promise, содержащее ответ (объект Response).	

	
### Пример
```js
fetch('https://jsonplaceholder.typicode.com/posts', {
    method: 'POST',
    body: JSON.stringify({name: 'Alex'}),
    headers: {
      'Content-type': 'application/json'
    }
  })
    .then(response => response.json())
    .then(json => console.log(json));	
```		
		
### Теория
	
Метод fetch() — современный и очень мощный, поэтому начнём с него. Он не поддерживается старыми (можно использовать полифил), но поддерживается всеми современными браузерами.

Базовый синтаксис:
```js
let promise = fetch(url, [options])
```	
- url – URL для отправки запроса.
- options – дополнительные параметры: метод, заголовки и так далее.
	
Без options это простой GET-запрос, скачивающий содержимое по адресу url.

Браузер сразу же начинает запрос и возвращает промис, который внешний код использует для получения результата.

Процесс получения ответа обычно происходит в два этапа.

### Во-первых, promise выполняется с объектом встроенного класса Response в качестве результата, как только сервер пришлёт заголовки ответа.

На этом этапе мы можем проверить статус HTTP-запроса и определить, выполнился ли он успешно, а также посмотреть заголовки, но пока без тела ответа.

Промис завершается с ошибкой, если fetch не смог выполнить HTTP-запрос, например при ошибке сети или если нет такого сайта. HTTP-статусы 404 и 500 не являются ошибкой.

Мы можем увидеть HTTP-статус в свойствах ответа:

- status – код статуса HTTP-запроса, например 200.
- ok – логическое значение: будет true, если код HTTP-статуса в диапазоне 200-299.
	
```js
let response = await fetch(url);

if (response.ok) { // если HTTP-статус в диапазоне 200-299
  // получаем тело ответа (см. про этот метод ниже)
  let json = await response.json();
} else {
  alert("Ошибка HTTP: " + response.status);
}
```
	
### Во-вторых, для получения тела ответа нам нужно использовать дополнительный вызов метода.

Response предоставляет несколько методов, основанных на промисах, для доступа к телу ответа в различных форматах:

- response.text() – читает ответ и возвращает как обычный текст,
- response.json() – декодирует ответ в формате JSON,
- response.formData() – возвращает ответ как объект FormData (разберём его в следующей главе),
- response.blob() – возвращает объект как Blob (бинарные данные с типом),
- response.arrayBuffer() – возвращает ответ как ArrayBuffer (низкоуровневое представление бинарных данных),
помимо этого, response.body – это объект ReadableStream, с помощью которого можно считывать тело запроса по частям. Мы рассмотрим и такой пример несколько позже.
	
Например, получим JSON-объект с последними коммитами из репозитория на GitHub:
```js
let url = 'https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits';
let response = await fetch(url);

let commits = await response.json(); // читаем ответ в формате JSON

alert(commits[0].author.login);
```	
То же самое без await, с использованием промисов:
```js
fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits')
  .then(response => response.json())
  .then(commits => alert(commits[0].author.login));
```	
Для получения ответа в виде текста используем await response.text() вместо .json():
```js
let response = await fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits');

let text = await response.text(); // прочитать тело ответа как текст

alert(text.slice(0, 80) + '...');	
```	
	
Типичный запрос с помощью fetch состоит из двух операторов await:
```js
let response = await fetch(url, options); // завершается с заголовками ответа
let result = await response.json(); // читать тело ответа в формате JSON
```	
Или, без await:
```js
fetch(url, options)
  .then(response => response.json())
  .then(result => /* обрабатываем результат */)
```
	
Параметры ответа:
- response.status – HTTP-код ответа,
- response.ok – true, если статус ответа в диапазоне 200-299.
- response.headers – похожий на Map объект с HTTP-заголовками.
	
Методы для получения тела ответа:
- response.text() – возвращает ответ как обычный текст,
- response.json() – преобразовывает ответ в JSON-объект,
- response.formData() – возвращает ответ как объект FormData (кодировка form/multipart, см. следующую главу),
- response.blob() – возвращает объект как Blob (бинарные данные с типом),
- response.arrayBuffer() – возвращает ответ как ArrayBuffer (низкоуровневые бинарные данные),
	
Опции fetch, которые мы изучили на данный момент:
- method – HTTP-метод,
- headers – объект с запрашиваемыми заголовками (не все заголовки разрешены),
- body – данные для отправки (тело запроса) в виде текста, FormData, BufferSource, Blob или UrlSearchParams.

  **[⬆ Наверх](#top)**
	
327. ### <a name="327"></a> Минификация

Перед выкладыванием JavaScript на «боевую» машину – пропускаем его через минификатор (также говорят «сжиматель»), который удаляет пробелы и по-всякому оптимизирует код, уменьшая его размер.
	
*Что делает минификатор?*
	
Все современные минификаторы работают следующим образом:

1. Разбирают JavaScript-код в синтаксическое дерево.
Также поступает любой интерпретатор JavaScript перед тем, как его выполнять. Но затем, вместо исполнения кода…
2. Бегают по этому дереву, анализируют и оптимизируют его.
3. Записывают из синтаксического дерева получившийся код.

  **[⬆ Наверх](#top)**
	
328. ### <a name="328"></a> Что такое web workers и зачем они нам нужны?

Web Worker-ы предоставляют простое средство для запуска скриптов в фоновом потоке. Поток Worker'а может выполнять задачи без вмешательства в пользовательский интерфейс. К тому же, они могут осуществлять ввод/вывод, используя XMLHttpRequest (хотя атрибуты responseXML и channel всегда будут равны null). Существующий Worker может отсылать сообщения JavaScript коду-создателю через обработчик событий, указанный этим кодом (и наоборот).

	
### Web Workers API
	
Worker - это объект, создаваемый конструктором (например, Worker()) и запускающий именной JavaScript файл — этот файл содержит код, который будет выполнен в потоке Worker'а; объекты же Workers запускаются в другом глобальном контексте, отличающемся от текущего, - window. Поэтому использование переменной window для получения текущего глобального контекста (вместо self) внутри Worker вернёт ошибку.	

*Другие типы worker-ов*
	
В дополнение к выделенным и совместно используемым web worker-ам доступны другие типы worker-ов:

- ServiceWorkers, по сути, действуют как прокси-серверы, которые размещаются между веб-приложениями, браузером и сетью (при наличии). Они предназначены (помимо прочего) для создания эффективного автономного взаимодействия, перехвата сетевых запросов и принятия соответствующих действий в зависимости от того, доступна ли сеть, и обновлены ли ресурсы на сервере. Они также разрешают доступ push-уведомлениям и API фоновой синхронизации.
- Chrome Workers это worker типа Firefox-only, который вы можете использовать, если вы разрабатываете дополнения и хотите использовать worker-ы в расширениях и иметь доступ к js-ctypes в вашем worker-е. Смотрите ChromeWorker для более подробной информации.
- Audio Workers предоставляют возможность прямой обработки звука по сценарию в контексте web worker-а.

  **[⬆ Наверх](#top)**
	
329. ### <a name="329"></a> Typescript или flow

TypeScript — это язык программирования, разработанный в Microsoft. TypeScript является надмножеством JavaScript, имеет статическую систему типов и собственный компилятор. Статическая типизация позволяет отлавливать ошибки и баги во время компиляции, ещё до запуска приложения. Подробнее узнать о совместном использовании TypeScript и React можно здесь.

Чтобы использовать TypeScript, нужно:

- добавить TypeScript в проект как зависимость.
- настроить компилятор.
- использовать правильные расширения файлов.
- установить файлы объявлений для используемых библиотек;


Flow — это библиотека для статической типизации JavaScript, разработанная в Facebook и часто применяемая в связке с React. Flow расширяет возможности JavaScript, добавляя аннотации типов для переменных, функций и React-компонентов. Ознакомиться с основами Flow можно на странице официальной документации.

Чтобы начать пользоваться возможностями Flow необходимо:

- добавить Flow в ваш проект как зависимость.
- убедиться, что аннотации Flow удаляются из кода при его компиляции.
- добавить несколько аннотаций типов и запустить Flow для их проверки;

https://ru.reactjs.org/docs/static-type-checking.html

  **[⬆ Наверх](#top)**
	
330. ### <a name="330"></a> Рекурсия

`Рекурсия` – это термин в программировании, означающий вызов функцией самой себя. Рекурсивные функции могут быть использованы для элегантного решения определённых задач.

Когда функция вызывает саму себя, это называется шагом рекурсии. База рекурсии – это такие аргументы функции, которые делают задачу настолько простой, что решение не требует дальнейших вложенных вызовов.

`База рекурсии` – это случай который приводит сразу к завершению функции. Это такие аргументы функции, которые делают задачу настолько простой, что решение не требует дальнейших вложенных вызовов.
```js
if ( n === 1) {
    return x;
}
```

Когда функция вызывает саму себя, это называется `шагом рекурсии`
```js
pow(x, n - 1)
```

`Глубина рекурсии` равна максимальному числу контекстов, одновременно хранимых в стеке.
```js
n
```

```js
function pow(x, n) {
  if ( n === 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}

pow(2, 1) //2
pow(2, 2) //4
pow(2, 3) //8
```

```js
function factorial(n) {
  if (typeof(n) !== 'number' || !Number.isInteger(n)) {
    return "Ошибка, проверьте данные";
  }

  if (n >= 1) {
    return n * factorial(n - 1);
  } else {
    return 1;
  }

  return n ? n * factorial(n - 1) : 1;
}

console.log(factorial(5));
```

```js
let students = {
  js: [{
    name: 'John',
    progress: 100
  }, {
    name: 'Ivan',
    progress: 60
  }],

  html: {
    basic: [{
      name: 'Peter',
      progress: 20
    }, {
      name: 'Ann',
      progress: 18
    }],

    pro: [{
      name: 'Sam',
      progress: 10
    }],

    // recursion +
    semi: {
      students: [{
        name: 'Test',
        progress: 100
      }]
    }
  }
};

function getTotalProgressByIteration(data) {
  let total = 0;
  let students = 0;

  for (let course of Object.values(data)) {
    if (Array.isArray(course)) {
      students += course.length;

      for (let i = 0; i < course.length; i++) {
        total += course[i].progress;
      }
    } else {
      for (let subCourse of Object.values(course)) {
        students += subCourse.length;

        for (let i = 0; i < subCourse.length; i++) {
          total += subCourse[i].progress;
        }
      }

    }
  }

  return total / students;
}

console.log(getTotalProgressByIteration(students));

// Recursion =>

function getTotalProgressByRecursion(data) {
  if (Array.isArray(data)) {
    let total = 0;

    for (let i = 0; i < data.length; i++) {
      total += data[i].progress;
    }

    return [total, data.length]
  } else {
    let total = [0, 0];

    for (let subData of Object.values(data)) {
      const subDataArr = getTotalProgressByRecursion(subData);
      total[0] += subDataArr[0];
      total[1] += subDataArr[1];

    }

    return total;
  }
}

const result = getTotalProgressByRecursion(students);

console.log(result[0]/result[1]);
```

https://learn.javascript.ru/recursion


  **[⬆ Наверх](#top)**
	
331. ### <a name="331"></a> 



  **[⬆ Наверх](#top)**
	
332. ### <a name="332"></a> 



  **[⬆ Наверх](#top)**
	
333. ### <a name="333"></a> 



  **[⬆ Наверх](#top)**	  
