<a name="top"></a>

[–ù–∞ –≥–ª–∞–≤–Ω—É—é](../../README.md)

[–ü–µ—Ä–µ–π—Ç–∏ –∫ –≤–æ–ø—Ä–æ—Å–∞–º](#questions)

| ‚Ññ. | –í–æ–ø—Ä–æ—Å |
| --- | --------- |
|   | JavaScript Grundlagen |
|1 | [Klassifizierung von Datentypen, Typumwandlung](#1) |
|2 | [Unterschied zwischen null und undefined](#2) |
|3 | [Variablen let, const, var. Strikter Modus](#3) |
|4 | [Interaktion mit dem Benutzer: alert(), prompt(), confirm()](#4) |
|5 | [Interpolation (ES6)](#5) |
|6 | [Operatoren in JavaScript](#6) |
|7 | [Bedingungen](#7) |
|8 | [Schleifen, verschachtelte Schleifen, Labels](#8) |
|9 | [Hoisting (Hochheben von Variablen und Funktionen)](#9) |
|10 | [Ausf√ºhrungskontext, Lexikalische Umgebung](#10) |
|11 | [Tempor√§re Totzone (Temporal Dead Zone)](#11) |
|12 | [typeof ‚Äì wie erkennt man den Typ eines Werts?](#12) |
|13 | [Warum haben primitive Datentypen Methoden? Was ist Autoboxing?](#13) |
|14 | [Garbage Collector in JavaScript](#14) |
|15 | [Unterschied zwischen == und ===](#15) |
|16 | [Primitive vs. Referenztypen](#16) |
|17 | [Symbol.iterator und Iterierbare Objekte](#17) |
|18 | [WeakRef und FinalizationRegistry](#18) |
|19 | [](#19) |
|20 | [](#20) |
|   | Funktionen und ihre Besonderheiten |
|21 | [Funktionen, Pfeilfunktionen, IIFE](#21) |
|22 | [Methoden zur Kontextbindung (call, apply, bind)](#22) |
|23 | [Closures (Abschl√ºsse)](#23) |
|24 | [Callback-Funktionen](#24) |
|25 | [Konstruktor-Funktionen](#25) |
|26 | [Aufrufkontext (this)](#26) |
|27 | [Getter und Setter (Objekteigenschaften)](#27) |
|28 | [Generatorfunktionen](#28) |
|29 | [Rekursion](#29) |
|30 | [Memoization](#30) |
|   | Arbeiten mit Objekten |
|31 | [Objekte, Destrukturierung von Objekten (ES6)](#31) |
|32 | [Methoden Object, Object.prototype](#32) |
|33 | [M√∂glichkeiten zur Objekterstellung](#33) |
|34 | [Kopieren von Objekten](#34) |
|35 | [Property Descriptors (Eigenschaftsbeschreibungen)](#35) |
|36 | [Private und gesch√ºtzte Eigenschaften von Objekten](#36) |
|37 | [Prototypen, Prototypen-Kette](#37) |
|38 | [Object.create()](#38) |
|39 | [Unterschied zwischen klassischer und prototypischer Vererbung](#39) |
|40 | [](#40) |
|   | Arrays und Sammlungen |
|41 | [Arrays und Pseudo-Arrays, Array-Destrukturierung](#41) |
|42 | [Methoden Array, Array.prototype](#42) |
|43 | [Kopieren von Arrays](#43) |
|44 | [Map, Set, WeakSet, WeakMap](#44) |
|45 | [Live Collections (lebendige Sammlungen)](#45) |
|46 | [](#46) |
|47 | [](#47) |
|48 | [](#48) |
|49 | [](#49) |
|50 | [](#50) |
|   | Moderne JavaScript-Funktionen |
|51 | [Spread-Operator (ES6-ES9)](#51) |
|52 | [Rest-Operator und Standardparameter (ES6)](#52) |
|53 | [Symbol](#53) |
|54 | [BigInt](#54) |
|55 | [Module import/export (ES6) & CommonJS](#55) |
|56 | [Proxy und Reflect](#56) |
|57 | [](#57) |
|58 | [](#58) |
|59 | [](#59) |
|60 | [](#60) |
|   | Ereignisse und DOM-Manipulation |
|61 | [Ereignisse und ihre Handler](#61) |
|62 | [Ereignis-Bubbling (event bubbling)](#62) |
|63 | [Ereignis-Delegation](#63) |
|64 | [Unterschied zwischen load und DOMContentLoaded](#64) |
|65 | [Elemente von der Seite abrufen](#65) |
|66 | [Methoden zum Abrufen von DOM-Elementen in JavaScript](#66) |
|67 | [Navigation durch DOM-Elemente](#67) |
|68 | [classList, className und Ereignisdelegation](#68) |
|69 | [Manipulation von Seitenelementen](#69) |
|70 | [Dokument- und Fensterparameter sowie deren Nutzung](#70) |
|71 | [Web Animations API](#71) |
|72 | [requestAnimationFrame](#72) |
|73 | [Debouncing und Throttling](#73) |
|74 | [IntersectionObserver API](#74) |
|75 | [Unterschied zwischen innerHTML, textContent und innerText](#75) |
|   | Asynchronit√§t und Serverkommunikation |
|76 | [setTimeout und setInterval, Besonderheiten](#76) |
|77 | [AJAX und XMLHttpRequest](#77) |
|78 | [Promise (ES6)](#78) |
|79 | [Fetch API](#79) |
|80 | [Async/Await (ES8)](#80) |
|81 | [try...catch, throw-Anweisung](#81) |
|82 | [Axios-Bibliothek](#82) |
|83 | [Event Loop, synchrone und asynchrone Operationen](#83) |
|84 | [M√∂glichkeiten zum Senden von Serveranfragen](#84) |
|85 | [Long Polling (Langes Abfragen)](#85) |
|86 | [Web Socket](#86) |
|87 | [Was sind Web Workers und wof√ºr braucht man sie?](#87) |
|88 | [Microtasks vs. Macrotasks](#88) |
|89 | [](#89) |
|90 | [](#90) |
|   | Fortgeschrittene Themen |
|91 | [Klassen (ES6)](#91) |
|92 | [Klassenvererbung, private und gesch√ºtzte Eigenschaften](#92) |
|93 | [Kapselung (Encapsulation)](#93) |
|94 | [Was ist funktionale Programmierung? Grundlagen (First-Class-Funktionen, Higher-Order-Funktionen, Pure Functions, Immutability, Lazy Evaluation usw.)](#94) |
|95 | [Regul√§re Ausdr√ºcke (RegExp)](#95) |
|96 | [JSON](#96) |
|97 | [Design-Patterns in JavaScript (Singleton, Factory, Observer, etc.)](#97) |
|98 | [](#98) |
|99 | [](#99) |
|100 | [](#100) |
|   | Praktische Aufgaben |
|101 | [Erstellen von Tabs in einem Projekt](#101) |
|102 | [Countdown-Timer](#102) |
|103 | [Modales Fenster](#103) |
|104 | [Slider](#104) |
|105 | [Rechner](#105) |
|106 | [](#106) |
|107 | [](#107) |
|108 | [](#108) |
|109 | [](#109) |
|110 | [Zusammenfassung JavaScript](#110) |



<a name="questions"></a>

## JavaScript Grundlagen

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**
  
1. ### <a name="1"></a> Klassifizierung von Datentypen, Typumwandlung

**Klassifizierung von Datentypen und Typumwandlung in JavaScript**

---

### 1. Datentypen in JavaScript

**Primitive Typen (werden direkt gespeichert, unver√§nderlich):**

* **string** ‚Üí `"Hallo"`
* **number** ‚Üí `42`, `3.14`, `NaN`
* **bigint** ‚Üí `123n`
* **boolean** ‚Üí `true`, `false`
* **undefined** ‚Üí nicht zugewiesener Wert
* **symbol** ‚Üí eindeutiger Bezeichner (`Symbol('id')`)
* **null** ‚Üí explizit "kein Wert"

**Referenztypen (nicht direkt gespeichert, verweisen auf Objekte):**

* **Object**
* **Array**
* **Function**
* **Date**, **RegExp**, usw.

---

### 2. Dynamische Typisierung

JavaScript ist **dynamisch typisiert**, d. h. der Typ einer Variablen kann sich √§ndern:

```js
let x = 42;       // number
x = "Hallo";      // string
```

---

### 3. Typumwandlung (Type Conversion)

#### Implizite Umwandlung (Type Coercion)

JavaScript wandelt automatisch um, wenn n√∂tig:

```js
console.log("5" * 2);    // 10  ("5" ‚Üí number)
console.log("5" + 2);    // "52" (2 ‚Üí string)
console.log(true + 1);   // 2    (true ‚Üí 1)
```

#### Explizite Umwandlung

Mit Konstruktorfunktionen oder Operatoren:

```js
// Zu String
console.log(String(123));   // "123"
console.log((123).toString()); // "123"

// Zu Number
console.log(Number("42"));  // 42
console.log(+"42");         // 42
console.log(parseInt("42px", 10)); // 42
console.log(parseFloat("3.14"));  // 3.14

// Zu Boolean
console.log(Boolean(0));    // false
console.log(Boolean(""));   // false
console.log(Boolean("Hi")); // true
```

---

### 4. Truthy und Falsy Werte

* **Falsy**: `false`, `0`, `""`, `null`, `undefined`, `NaN`
* Alles andere ist **truthy**.

```js
if ("Hallo") {
  console.log("wird ausgef√ºhrt"); // truthy
}
```

---

### 5. Besonderheiten

* `null` ist ein **eigenst√§ndiger Typ**, aber `typeof null === "object"` (historischer Bug).
* `NaN` ist vom Typ **number**, aber `NaN !== NaN`.
  Pr√ºfen mit `Number.isNaN()`.

---

**Zusammenfassung:**
JavaScript kennt **7 primitive Typen** und **Referenztypen** (Objekte). Typumwandlungen erfolgen entweder **implizit** (Coercion) oder **explizit** (z. B. `Number()`, `String()`, `Boolean()`). Wichtige Konzepte sind **dynamische Typisierung**, **truthy/falsy Werte** und Sonderf√§lle wie `NaN` oder `null`.

üìñ Quelle: [MDN Web Docs ‚Äî Data types](https://developer.mozilla.org/ru/docs/Web/JavaScript/Data_structures)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

2. ### <a name="2"></a> Unterschied zwischen null und undefined

**Unterschied zwischen `null` und `undefined` in JavaScript**

---

### `undefined`

* Automatischer Standardwert, wenn eine Variable **deklariert, aber nicht initialisiert** wurde.
* Bedeutet: ‚ÄûWert nicht zugewiesen‚Äú.

```js
let a;
console.log(a); // undefined
```

* R√ºckgabewert von Funktionen ohne `return`:

```js
function foo() {}
console.log(foo()); // undefined
```

* Zugriff auf nicht existierende Objekteigenschaft:

```js
const obj = {};
console.log(obj.prop); // undefined
```

---

### `null`

* Muss **explizit** vom Entwickler gesetzt werden.
* Bedeutet: ‚Äûbewusst kein Wert‚Äú oder ‚Äûleer‚Äú.

```js
let user = null; // Platzhalter f√ºr sp√§teres Objekt
```

---

### Vergleich

```js
console.log(null == undefined);  // true (lose Gleichheit)
console.log(null === undefined); // false (strikte Gleichheit)

console.log(typeof undefined); // "undefined"
console.log(typeof null);      // "object" (bekannter Bug in JS)
```

---

### Typische Verwendung

* **`undefined`** ‚Üí vom System automatisch, ‚ÄûWert fehlt‚Äú
* **`null`** ‚Üí vom Entwickler gesetzt, ‚Äûbewusste Leere‚Äú

---

**Zusammenfassung:**
`undefined` zeigt an, dass **kein Wert zugewiesen** wurde (Standard in JS).
`null` bedeutet, dass ein Entwickler **absichtlich keinen Wert** gesetzt hat.
Mit `==` sind beide gleich, aber mit `===` strikt verschieden.

üìñ Quelle: [MDN Web Docs ‚Äî null](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/null), [MDN Web Docs ‚Äî undefined](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/undefined)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

3. ### <a name="3"></a> Variablen let, const, var. Strikter Modus

**Variablen (`let`, `const`, `var`) und strikter Modus (`"use strict"`) in JavaScript**

---

### 1. `var`

* G√ºltig seit ES5 und fr√ºher.
* **Funktions-Scope**, nicht blockbasiert.
* **Hoisting**: Deklaration wird nach oben verschoben, aber nicht die Initialisierung.
* Mehrfachdeklaration m√∂glich.

```js
function test() {
  console.log(a); // undefined (Hoisting)
  var a = 5;
  console.log(a); // 5
}
test();
```

---

### 2. `let`

* Eingef√ºhrt mit ES6.
* **Block-Scope** (nur innerhalb `{}` sichtbar).
* Kein erneutes Deklarieren in demselben Scope m√∂glich.
* **Temporal Dead Zone (TDZ)**: Zugriff vor Deklaration f√ºhrt zu Fehler.

```js
{
  // console.log(b); // ReferenceError
  let b = 10;
  console.log(b); // 10
}
```

---

### 3. `const`

* Wie `let`, aber Wert **muss bei Deklaration gesetzt** werden.
* Der **Bezeichner** ist konstant, nicht der Inhalt.
* Bei Objekten/Arrays k√∂nnen Inhalte ge√§ndert werden.

```js
const PI = 3.14;
// PI = 3.15; // TypeError

const arr = [1, 2];
arr.push(3); // erlaubt
console.log(arr); // [1, 2, 3]
```

---

### 4. Strikter Modus (`"use strict"`)

* Aktiviert durch `"use strict";` am Anfang einer Datei oder Funktion.
* Verhindert ‚Äûunsauberes‚Äú Verhalten:

  * Keine impliziten globalen Variablen.
  * Kein L√∂schen von Variablen/Funktionen.
  * Reservierte Schl√ºsselw√∂rter gesch√ºtzt.
  * Mehr Sicherheit f√ºr `this`.

```js
"use strict";

x = 10; // ReferenceError: x is not defined
```

---

### Vergleich `var`, `let`, `const`

| Merkmal             | var                     | let                                      | const                                    |
| ------------------- | ----------------------- | ---------------------------------------- | ---------------------------------------- |
| Scope               | Funktions-Scope         | Block-Scope                              | Block-Scope                              |
| Hoisting            | Ja (Wert = `undefined`) | Ja (TDZ, ReferenceError vor Deklaration) | Ja (TDZ, ReferenceError vor Deklaration) |
| Mehrfachdeklaration | erlaubt                 | nicht erlaubt                            | nicht erlaubt                            |
| Neuzuweisung        | erlaubt                 | erlaubt                                  | nicht erlaubt                            |

---

**Zusammenfassung:**

* `var`: Funktions-Scope, veraltet, hoisting mit `undefined`.
* `let`: Block-Scope, moderne Standard-Variante.
* `const`: Block-Scope, unver√§nderlicher Bezeichner, Inhalte von Objekten/Arrays ver√§nderbar.
* `"use strict"`: erzwingt sauberen, sicheren Code, verhindert implizite Globals und unsauberes Verhalten.

üìñ Quelle: [MDN Web Docs ‚Äî let](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/let), [MDN Web Docs ‚Äî const](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/const), [MDN Web Docs ‚Äî var](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/var), [MDN Web Docs ‚Äî Strict mode](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Strict_mode)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

4. ### <a name="4"></a> Interaktion mit dem Benutzer: alert(), prompt(), confirm()

**Interaktion mit dem Benutzer: `alert()`, `prompt()`, `confirm()` in JavaScript**

---

### 1. `alert()`

* Zeigt eine einfache Meldung an.
* Gibt **immer `undefined`** zur√ºck.
* Blockiert den Code, bis der Nutzer ‚ÄûOK‚Äú klickt.

```js
alert("Willkommen auf meiner Seite!");
```

---

### 2. `prompt()`

* Fragt den Benutzer nach Eingabe.
* Syntax: `prompt(message, defaultValue)`
* R√ºckgabewert:

  * String mit Eingabe
  * `null`, wenn Abbrechen gedr√ºckt wird

```js
const name = prompt("Wie hei√üt du?", "Max");
console.log(name); 
```

---

### 3. `confirm()`

* Stellt eine Ja/Nein-Frage.
* Gibt **boolean** zur√ºck:

  * `true`, wenn ‚ÄûOK‚Äú geklickt wurde
  * `false`, wenn ‚ÄûAbbrechen‚Äú

```js
const isSure = confirm("Bist du sicher?");
if (isSure) {
  console.log("Aktion best√§tigt");
} else {
  console.log("Aktion abgebrochen");
}
```

---

### 4. Eigenschaften

* Alle drei Methoden sind **modal**: sie blockieren die Interaktion mit der Seite, bis der Dialog geschlossen wird.
* Werden meist f√ºr **Tests oder kleine Demos** genutzt, nicht in professionellen UIs.
* In modernen Projekten ersetzt man sie durch **eigene Dialog-Komponenten** (z. B. in React, mit CSS/JS).

---

**Zusammenfassung:**

* `alert()` ‚Üí Meldung anzeigen.
* `prompt()` ‚Üí Eingabe vom Nutzer erhalten (String oder `null`).
* `confirm()` ‚Üí Best√§tigung abfragen (`true`/`false`).
  Alle sind blockierend und werden in realen Projekten durch benutzerdefinierte Dialoge ersetzt.

üìñ Quelle: [MDN Web Docs ‚Äî Dialoge mit alert(), prompt() und confirm()](https://developer.mozilla.org/ru/docs/Web/API/Window/alert)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

5. ### <a name="5"></a> Interpolation (ES6)

**Interpolation (Template Literals in ES6)**

---

### 1. Einf√ºhrung

* Seit **ES6** gibt es Template-Literale (Backticks `` ` ``).
* Erm√∂glichen **Interpolation** von Variablen und Ausdr√ºcken mit `${...}`.
* Unterst√ºtzen **mehrzeilige Strings**, ohne `\n`.

---

### 2. Variablen-Interpolation

```js
const name = "Sergii";
const age = 33;

const message = `Mein Name ist ${name} und ich bin ${age} Jahre alt.`;
console.log(message);
// "Mein Name ist Sergii und ich bin 33 Jahre alt."
```

---

### 3. Ausdrucks-Interpolation

```js
const a = 10;
const b = 5;

console.log(`Die Summe von ${a} + ${b} ist ${a + b}`);
// "Die Summe von 10 + 5 ist 15"
```

---

### 4. Mehrzeilige Strings

```js
const text = `Dies ist
ein mehrzeiliger
String.`;

console.log(text);
```

---

### 5. Verschachtelte Ausdr√ºcke und Funktionen

```js
function upper(str) {
  return str.toUpperCase();
}

const user = "sergii";
console.log(`Hallo, ${upper(user)}!`);
// "Hallo, SERGII!"
```

---

### 6. Tagged Templates (fortgeschritten)

```js
function highlight(strings, ...values) {
  return strings.reduce((acc, str, i) =>
    `${acc}${str}<b>${values[i] ?? ""}</b>`, "");
}

const city = "Leipzig";
const country = "Deutschland";

console.log(highlight`Ich lebe in ${city}, ${country}.`);
// "Ich lebe in <b>Leipzig</b>, <b>Deutschland</b>."
```

---

**Zusammenfassung:**
ES6-Template-Literale (`` `...` ``) erm√∂glichen **Interpolation** mit `${...}`, **mehrzeilige Strings** und erweiterte Funktionen wie **Tagged Templates**. Sie ersetzen die un√ºbersichtliche String-Konkatenation mit `+`.

üìñ Quelle: [MDN Web Docs ‚Äî Template literals](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Template_literals)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

6. ### <a name="6"></a> Operatoren in JavaScript

**Operatoren in JavaScript**

---

### 1. Arithmetische Operatoren

* `+` ‚Üí Addition / String-Konkatenation
* `-` ‚Üí Subtraktion
* `*` ‚Üí Multiplikation
* `/` ‚Üí Division
* `%` ‚Üí Modulo (Rest)
* `**` ‚Üí Potenzierung (ES6)

```js
console.log(5 + 2);   // 7
console.log("Hi" + 5); // "Hi5"
console.log(10 % 3);  // 1
console.log(2 ** 3);  // 8
```

---

### 2. Zuweisungsoperatoren

* `=` ‚Üí Zuweisung
* `+=`, `-=`, `*=`, `/=`, `%=` ‚Üí kombinierte Zuweisung

```js
let x = 5;
x += 3; // x = 8
```

---

### 3. Vergleichsoperatoren

* `==` ‚Üí lose Gleichheit (Typumwandlung m√∂glich)
* `===` ‚Üí strikte Gleichheit (kein Typ-Casting)
* `!=` / `!==` ‚Üí ungleich
* `<`, `>`, `<=`, `>=`

```js
console.log(5 == "5");   // true
console.log(5 === "5");  // false
```

---

### 4. Logische Operatoren

* `&&` ‚Üí UND
* `||` ‚Üí ODER
* `!` ‚Üí NICHT
* **Kurzschluss-Evaluation**: `a && b`, `a || b`

```js
console.log(true && false); // false
console.log(false || "Hi"); // "Hi"
console.log(!true);         // false
```

---

### 5. Inkrement/Dekrement

* `++` ‚Üí +1
* `--` ‚Üí -1
* **Prefix/Postfix-Unterschied**

```js
let a = 1;
console.log(++a); // 2 (erst erh√∂hen, dann zur√ºckgeben)
console.log(a++); // 2 (erst zur√ºckgeben, dann erh√∂hen)
```

---

### 6. Bedingungsoperator (Ternary)

```js
const age = 20;
const access = age >= 18 ? "Erlaubt" : "Verboten";
console.log(access); // "Erlaubt"
```

---

### 7. Nullish Coalescing und Optional Chaining (ES2020)

* `??` ‚Üí gibt den rechten Wert zur√ºck, wenn links `null` oder `undefined`.
* `?.` ‚Üí sicherer Zugriff auf verschachtelte Eigenschaften.

```js
const user = null;
console.log(user ?? "Gast"); // "Gast"

const obj = { name: "Sergii" };
console.log(obj?.age ?? "Keine Angabe"); // "Keine Angabe"
```

---

### 8. Bitweise Operatoren

* `&` (AND), `|` (OR), `^` (XOR), `~` (NOT), `<<`, `>>`, `>>>`

```js
console.log(5 & 1); // 1
```

---

**Zusammenfassung:**
JavaScript unterst√ºtzt viele Operatoren: **arithmetische**, **Zuweisungs-**, **Vergleichs-**, **logische**, **Inkrement/Dekrement**, **tern√§re**, moderne (`??`, `?.`) sowie **bitweise** Operatoren. Wichtiger Unterschied: `==` erlaubt Typumwandlung, `===` pr√ºft strikt.

üìñ Quelle: [MDN Web Docs ‚Äî Expressions and operators](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

7. ### <a name="7"></a> Bedingungen

**Bedingungen (Control Flow) in JavaScript**

---

### 1. `if / else if / else`

```js
const age = 20;

if (age >= 18) {
  console.log("Zugang erlaubt");
} else if (age >= 16) {
  console.log("Eingeschr√§nkt erlaubt");
} else {
  console.log("Kein Zugang");
}
```

---

### 2. Ternary Operator (`?:`)

Kurzschreibweise f√ºr einfache Bedingungen.

```js
const isMember = true;
const price = isMember ? 5 : 10;
console.log(price); // 5
```

---

### 3. `switch`

Gut geeignet f√ºr mehrere feste Vergleichswerte.

```js
const color = "green";

switch (color) {
  case "red":
    console.log("Stopp");
    break;
  case "green":
    console.log("Go");
    break;
  default:
    console.log("Unbekannt");
}
```

---

### 4. Logische Operatoren in Bedingungen

* `&&` (UND), `||` (ODER), `!` (NICHT)
* Kurzschluss-Evaluation ‚Üí kann Bedingungen verk√ºrzen.

```js
const user = { isAdmin: true, loggedIn: true };

if (user && user.loggedIn) {
  console.log("Benutzer eingeloggt");
}
```

---

### 5. Nullish Coalescing (`??`) & Optional Chaining (`?.`)

Moderne Erg√§nzungen f√ºr sichere Bedingungen.

```js
const name = null;
console.log(name ?? "Gast"); // "Gast"

const obj = {};
console.log(obj?.user?.name ?? "Kein Name"); // "Kein Name"
```

---

### 6. Besonderheiten

* Nur **falsy Werte** (`false`, `0`, `""`, `null`, `undefined`, `NaN`) werden in Bedingungen als *false* interpretiert.
* Alle anderen Werte gelten als *true*.

```js
if ("Hallo") {
  console.log("Wird ausgef√ºhrt"); // truthy
}
```

---

**Zusammenfassung:**
Bedingungen in JavaScript k√∂nnen mit **`if/else`**, dem **Ternary-Operator**, **`switch`**, sowie logischen Operatoren umgesetzt werden. Seit ES2020 stehen auch **`??`** und **`?.`** f√ºr sichere Abfragen zur Verf√ºgung. Wichtig ist das Verst√§ndnis von **truthy/falsy Werten**.

üìñ Quelle: [MDN Web Docs ‚Äî Control flow and error handling](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Control_flow_and_error_handling)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

8. ### <a name="8"></a> Schleifen, verschachtelte Schleifen, Labels

**Schleifen in JavaScript**

---

### 1. `for`-Schleife

* Klassische Z√§hlschleife.
* Syntax: `for (Initialisierung; Bedingung; Inkrement)`

```js
for (let i = 0; i < 5; i++) {
  console.log(i); // 0,1,2,3,4
}
```

---

### 2. `while`-Schleife

* F√ºhrt Block aus, solange Bedingung **true** ist.
* Bedingung wird **vor** jedem Durchlauf gepr√ºft.

```js
let i = 0;
while (i < 3) {
  console.log(i);
  i++;
}
```

---

### 3. `do...while`-Schleife

* F√ºhrt Block **mindestens einmal** aus.
* Bedingung wird **am Ende** gepr√ºft.

```js
let x = 0;
do {
  console.log(x); // l√§uft mindestens 1x
  x++;
} while (x < 3);
```

---

### 4. Verschachtelte Schleifen

* Schleifen k√∂nnen ineinander verschachtelt sein.
* Typisch f√ºr Matrizen oder Tabellen.

```js
for (let i = 1; i <= 3; i++) {
  for (let j = 1; j <= 2; j++) {
    console.log(`i=${i}, j=${j}`);
  }
}
```

---

### 5. Labels

* Erlauben gezielten `break` oder `continue` f√ºr √§u√üere Schleifen.
* **Selten genutzt**, aber n√ºtzlich bei komplexen Schleifen.

```js
outer: for (let i = 0; i < 3; i++) {
  for (let j = 0; j < 3; j++) {
    if (i === 1 && j === 1) {
      break outer; // bricht auch die √§u√üere Schleife ab
    }
    console.log(`i=${i}, j=${j}`);
  }
}
```

---

### 6. `for...of` (ES6)

* Iteriert √ºber **iterierbare Objekte** (Array, String, Map, Set).

```js
const arr = ["a", "b", "c"];
for (const item of arr) {
  console.log(item);
}
```

---

### 7. `for...in`

* Iteriert √ºber **Eigenschaftsnamen** eines Objekts.
* Nicht f√ºr Arrays empfohlen (Reihenfolge unsicher).

```js
const obj = { name: "Sergii", age: 33 };
for (const key in obj) {
  console.log(`${key}: ${obj[key]}`);
}
```

---

### 8. `break` und `continue`

* `break`: beendet Schleife komplett.
* `continue`: √ºberspringt aktuellen Durchlauf.

```js
for (let i = 0; i < 5; i++) {
  if (i === 2) continue; // √ºberspringt 2
  if (i === 4) break;    // beendet Schleife
  console.log(i);
}
```

---

**Zusammenfassung:**
JavaScript bietet mehrere Schleifenarten: `for`, `while`, `do...while`, `for...of`, `for...in`. Wichtige Steuerungen sind `break`, `continue` und optional **Labels**. Verschachtelte Schleifen eignen sich f√ºr mehrdimensionale Strukturen. Moderne Praxis: **`for...of`** f√ºr Arrays, **`for...in`** f√ºr Objekte.

üìñ Quelle: [MDN Web Docs ‚Äî Loops and iteration](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Loops_and_iteration)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

9. ### <a name="9"></a> Hoisting (Hochheben von Variablen und Funktionen)

**Hoisting (Hochheben) in JavaScript**

---

### 1. Definition

* **Hoisting** = Verhalten von JavaScript, bei dem **Deklarationen** (von Variablen und Funktionen) an den Anfang ihres G√ºltigkeitsbereichs verschoben werden.
* Nur die **Deklarationen**, nicht die **Initialisierungen**, werden ‚Äûhochgehoben‚Äú.

---

### 2. `var`

* Deklaration wird nach oben verschoben.
* Wert ist bis zur Zuweisung `undefined`.

```js
console.log(a); // undefined (Hoisting)
var a = 5;
console.log(a); // 5
```

---

### 3. `let` und `const`

* Werden ebenfalls ‚Äûgehoisted‚Äú, befinden sich aber in der **Temporal Dead Zone (TDZ)**, bis die Deklaration erreicht wird.
* Zugriff vor der Deklaration ‚Üí **ReferenceError**.

```js
// console.log(b); // ReferenceError
let b = 10;

const c = 20;
// console.log(c); // ReferenceError
```

---

### 4. Funktionen

* **Function Declarations** werden komplett (Name + Body) hochgehoben ‚Üí k√∂nnen schon vor der Definition aufgerufen werden.
* **Function Expressions** und **Arrow Functions** werden wie Variablen behandelt (Hoisting der Deklaration, aber nicht der Zuweisung).

```js
// Function Declaration
greet(); // "Hallo"
function greet() {
  console.log("Hallo");
}

// Function Expression
// sayHi(); // TypeError: sayHi is not a function
var sayHi = function () {
  console.log("Hi");
};
```

---

### 5. Besonderheiten

* Hoisting wirkt **innerhalb des Scopes** (Funktions- oder Blockscope).
* In **strict mode** gibt es keine impliziten globalen Variablen durch Hoisting.

---

**Zusammenfassung:**
Beim Hoisting werden **Deklarationen von Variablen und Funktionen** an den Anfang ihres Scopes verschoben. `var` ‚Üí hoisted mit `undefined`, `let`/`const` ‚Üí hoisted, aber in **TDZ** bis zur Deklaration. **Function Declarations** sind voll verf√ºgbar, **Function Expressions** erst nach der Zuweisung.

üìñ Quelle: [MDN Web Docs ‚Äî Hoisting](https://developer.mozilla.org/ru/docs/Glossary/Hoisting)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

10. ### <a name="10"></a> Ausf√ºhrungskontext, Lexikalische Umgebung

**Ausf√ºhrungskontext (Execution Context) & Lexikalische Umgebung (Lexical Environment) in JavaScript**

---

### 1. Ausf√ºhrungskontext (Execution Context)

Ein **Ausf√ºhrungskontext** beschreibt den Rahmen, in dem JavaScript-Code ausgef√ºhrt wird.

Es gibt drei Hauptarten:

1. **Global Execution Context (GEC)**

   * Entsteht beim Laden eines Skripts.
   * Erstellt das globale Objekt (`window` im Browser, `global` in Node.js) und `this`.
   * Nur einmal pro Programm.

2. **Function Execution Context (FEC)**

   * F√ºr jede Funktionsausf√ºhrung erstellt.
   * Enth√§lt eigene Variablen, Argumente und `this`.
   * Kann verschachtelt sein.

3. **Eval Execution Context** (selten)

   * F√ºr Code innerhalb von `eval()`.

**Lebenszyklus:**

* **Creation Phase**: Hoisting von Variablen/Funktionen, Einrichtung von `this`.
* **Execution Phase**: Code wird ausgef√ºhrt, Werte zugewiesen.

---

### 2. Lexikalische Umgebung (Lexical Environment)

* Eine **Lexical Environment** ist eine Datenstruktur, die den **Scope** (sichtbare Variablen) beschreibt.
* Enth√§lt zwei Teile:

  1. **Environment Record** (Variablen und Funktionen im aktuellen Scope).
  2. **Verweis auf √§u√üere Lexical Environment** (Chain ‚Üí Scope Chain).

Beispiel:

```js
function outer() {
  let a = 10;
  function inner() {
    let b = 20;
    console.log(a + b); // Zugriff auf √§u√üere Variable "a"
  }
  inner();
}
outer();
```

* `inner` hat Zugriff auf `b` (lokal) und `a` (√§u√üere Umgebung).
* Das nennt man **Scope Chain**.

---

### 3. Zusammenhang

* Jeder **Ausf√ºhrungskontext** hat eine **lexikalische Umgebung**.
* Lexikalisch bedeutet: Struktur wird beim **Schreiben des Codes** festgelegt, nicht zur Laufzeit.

---

### 4. Besonderheit: Closures

Ein Closure entsteht, wenn eine Funktion auf Variablen aus ihrer √§u√üeren lexikalischen Umgebung zugreift, selbst wenn die √§u√üere Funktion bereits beendet ist.

```js
function counter() {
  let count = 0;
  return function () {
    count++;
    return count;
  };
}

const inc = counter();
console.log(inc()); // 1
console.log(inc()); // 2
```

---

**Zusammenfassung:**

* **Execution Context** = Laufzeitumgebung (global, Funktion, eval).
* Besteht aus **Creation Phase** (Hoisting, this) und **Execution Phase** (Codeausf√ºhrung).
* **Lexical Environment** = beschreibt, welche Variablen/Funktionen in einem Scope verf√ºgbar sind, inkl. Verweis auf √§u√üere Umgebungen (Scope Chain).
* Basis f√ºr **Closures** und Scope-Verhalten in JavaScript.

üìñ Quelle: [MDN Web Docs ‚Äî Execution context](https://developer.mozilla.org/ru/docs/Glossary/Execution_context), [MDN Web Docs ‚Äî Lexical scoping](https://developer.mozilla.org/ru/docs/Glossary/Scope)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

11. ### <a name="11"></a> Tempor√§re Totzone (Temporal Dead Zone)

**Tempor√§re Totzone (Temporal Dead Zone, TDZ) in JavaScript**

---

### 1. Definition

* Die **TDZ** ist der Bereich zwischen dem **Beginn eines Block-Scopes** und der tats√§chlichen **Deklaration mit `let` oder `const`**.
* In diesem Bereich existiert die Variable zwar schon (wegen Hoisting), ist aber **nicht zugreifbar**.
* Zugriff vor der Deklaration f√ºhrt zu einem **ReferenceError**.

---

### 2. Beispiel

```js
{
  // TDZ beginnt hier
  // console.log(a); // ReferenceError
  let a = 10;       // TDZ endet hier
  console.log(a);   // 10
}
```

---

### 3. Unterschied zu `var`

* `var` wird ebenfalls gehoisted, aber direkt mit `undefined` initialisiert.
* Deshalb kein Fehler, sondern nur `undefined`.

```js
{
  console.log(b); // undefined (wegen var-Hoisting)
  var b = 20;
}
```

---

### 4. Auch bei `const`

* `const` verh√§lt sich wie `let`, aber muss sofort initialisiert werden.
* Zugriff in der TDZ ‚Üí ReferenceError.

```js
{
  // console.log(c); // ReferenceError
  const c = 30;
}
```

---

### 5. In Funktionen

Auch Funktionsparameter k√∂nnen eine TDZ haben, wenn Default-Werte auf noch nicht deklarierte Variablen zugreifen.

```js
function test(x = y, y = 2) {
  return x + y;
}
// test(); // ReferenceError: Cannot access 'y' before initialization
```

---

**Zusammenfassung:**
Die **Temporal Dead Zone** ist der Zeitraum zwischen Scope-Beginn und der Variablen-Deklaration (`let`/`const`). Variablen sind dort **gehoisted, aber uninitialisiert** ‚Üí Zugriff f√ºhrt zu **ReferenceError**. Im Gegensatz dazu ist `var` sofort mit `undefined` verf√ºgbar.

üìñ Quelle: [MDN Web Docs ‚Äî let](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/let#temporal_dead_zone_tdz)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

12. ### <a name="12"></a> typeof ‚Äì wie erkennt man den Typ eines Werts?

**`typeof` ‚Äì Erkennen des Typs eines Werts in JavaScript**

---

### 1. Syntax

```js
typeof wert
```

* Gibt einen **String** zur√ºck, der den Typ beschreibt.

---

### 2. Ergebnisse f√ºr primitive Typen

```js
console.log(typeof "Hallo");   // "string"
console.log(typeof 42);        // "number"
console.log(typeof 10n);       // "bigint"
console.log(typeof true);      // "boolean"
console.log(typeof undefined); // "undefined"
console.log(typeof Symbol());  // "symbol"
```

---

### 3. Sonderf√§lle

```js
console.log(typeof null);      // "object"  (bekannter Bug seit JS-Anfang)
console.log(typeof NaN);       // "number"
```

---

### 4. F√ºr Objekte und Funktionen

```js
console.log(typeof {});        // "object"
console.log(typeof []);        // "object"  (Array wird nicht extra erkannt)
console.log(typeof function(){}); // "function"
```

---

### 5. Einschr√§nkungen von `typeof`

* Unterscheidet **Array** nicht von **Objekten**.
* F√ºr genauere Typpr√ºfung ‚Üí `Array.isArray()` oder `instanceof`.

```js
console.log(Array.isArray([1, 2, 3])); // true
console.log([1, 2, 3] instanceof Array); // true
```

---

### 6. Typ-Check-Strategie

* **Primitiv-Typen**: `typeof` reicht aus (au√üer `null`).
* **Array**: `Array.isArray()`
* **null**: explizit mit `value === null`
* **Objekte allgemein**: `typeof x === "object" && x !== null`

---

**Zusammenfassung:**
Mit `typeof` erkennt man den **Grundtyp** eines Werts, Ergebnis ist immer ein String. Problemf√§lle: `null` gibt `"object"` zur√ºck, Arrays ebenfalls `"object"`. F√ºr pr√§zise Checks kombiniert man `typeof`, `Array.isArray()` und `=== null`.

üìñ Quelle: [MDN Web Docs ‚Äî typeof](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/typeof)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

13. ### <a name="13"></a> Warum haben primitive Datentypen Methoden? Was ist Autoboxing?

**Warum haben primitive Datentypen Methoden? Was ist Autoboxing?**

---

### 1. Primitive Datentypen

Primitive Werte (`string`, `number`, `boolean`, `bigint`, `symbol`) sind **keine Objekte**. Trotzdem kann man Methoden darauf anwenden:

```js
console.log("Hallo".toUpperCase()); // "HALLO"
console.log((42).toFixed(2));       // "42.00"
```

---

### 2. Autoboxing (Wrapper-Objekte)

* Wenn man auf einer primitiven Variable eine Methode aufruft, erstellt JavaScript **automatisch** ein **tempor√§res Wrapper-Objekt** (`String`, `Number`, `Boolean`).
* Dieses Objekt stellt Methoden bereit.
* Danach wird es sofort wieder verworfen.
* Dieser Vorgang hei√üt **Autoboxing**.

```js
const str = "test";

// Intern passiert:
const temp = new String(str);
const result = temp.toUpperCase();
temp = null;

console.log(result); // "TEST"
```

---

### 3. Wrapper-Objekte

* `String`, `Number`, `Boolean` sind eingebaute Konstruktorfunktionen.
* Meist **nicht direkt** mit `new` verwenden ‚Üí erzeugt ein echtes Objekt statt primitiven Wert.

```js
const prim = "hi"; 
const obj = new String("hi");

console.log(typeof prim); // "string"
console.log(typeof obj);  // "object"
```

---

### 4. Besonderheiten

* Autoboxing gilt **nicht** f√ºr `null` und `undefined`.
  ‚Üí Methodenaufruf darauf f√ºhrt zu Fehler.

```js
// console.log(null.toString()); // TypeError
```

---

**Zusammenfassung:**
Primitive Datentypen haben scheinbar Methoden, weil JavaScript beim Zugriff **tempor√§re Wrapper-Objekte** (z. B. `String`, `Number`, `Boolean`) erstellt und danach wieder entfernt. Dieser automatische Prozess hei√üt **Autoboxing**. Dadurch k√∂nnen auch Primitive wie Objekte genutzt werden ‚Äì mit Ausnahme von `null` und `undefined`.

üìñ Quelle: [MDN Web Docs ‚Äî Primitive](https://developer.mozilla.org/ru/docs/Glossary/Primitive), [MDN Web Docs ‚Äî Autoboxing](https://developer.mozilla.org/ru/docs/Glossary/Autoboxing)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

14. ### <a name="14"></a> Garbage Collector in JavaScript

**Garbage Collector in JavaScript**

---

### 1. Definition

Der **Garbage Collector (GC)** in JavaScript ist ein automatisches Speicherverwaltungs-System.

* Aufgabe: **unbenutzte Objekte erkennen und freigeben**, damit Speicher effizient genutzt wird.
* Entwickler haben **keinen direkten Zugriff** darauf (im Gegensatz zu Sprachen wie C/C++).

---

### 2. Grundprinzip ‚Äì *Reachability*

Ein Wert bleibt im Speicher, solange er **erreichbar** ist, d. h. wenn es eine Referenz von ‚ÄûWurzeln‚Äú gibt:

* **Roots**: globales Objekt (`window`), aktuelle Funktions-Variablen, Aufrufstack.
* Ein Objekt wird gel√∂scht, wenn **keine Referenzkette** mehr zu einer Root besteht.

```js
let user = { name: "Sergii" };
user = null; // Objekt ist nicht mehr erreichbar ‚Üí GC entfernt es irgendwann
```

---

### 3. Algorithmen

JavaScript-Engines (z. B. V8 in Chrome/Node.js) nutzen verschiedene Techniken:

* **Mark-and-Sweep** (am h√§ufigsten):

  1. Start bei den Roots.
  2. Markiere alle erreichbaren Objekte.
  3. L√∂sche alle nicht markierten.

* **Reference Counting** (fr√ºher): z√§hlt Referenzen, Problem: *Zirkul√§re Referenzen*.

```js
function cycle() {
  let a = {};
  let b = {};
  a.ref = b;
  b.ref = a;
}
cycle(); 
// Beide Objekte nicht mehr erreichbar ‚Üí GC kann sie trotzdem entsorgen
```

---

### 4. Besondere F√§lle

* **Zirkul√§re Referenzen** sind heute **kein Problem mehr** (Mark-and-Sweep).
* Variablen in **Closures** bleiben erhalten, solange die Funktion existiert.

```js
function outer() {
  let secret = "123";
  return function inner() {
    return secret; // "secret" bleibt erhalten
  };
}
const fn = outer(); 
```

---

### 5. Best Practices f√ºr Entwickler

* **Referenzen l√∂schen**, wenn sie nicht mehr gebraucht werden (`obj = null`).
* **Keine unn√∂tigen globalen Variablen** ‚Üí bleiben w√§hrend der ganzen Laufzeit erhalten.
* Gro√üe Strukturen (z. B. Arrays) bewusst freigeben.

---

**Zusammenfassung:**
Der Garbage Collector entfernt automatisch **nicht mehr erreichbare Objekte**. Grundlage ist das **Reachability-Konzept** (Mark-and-Sweep). Entwickler m√ºssen Speicher nicht manuell freigeben, sollten aber auf **Referenzen, Closures und globale Variablen** achten, um Speicherlecks zu vermeiden.

üìñ Quelle: [MDN Web Docs ‚Äî Garbage collection](https://developer.mozilla.org/ru/docs/Glossary/Garbage_collection)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

15. ### <a name="15"></a> Unterschied zwischen == und ===

**Unterschied zwischen `==` und `===` in JavaScript**

---

### 1. `==` (lose Gleichheit)

* Vergleicht Werte **nach Typumwandlung (Type Coercion)**.
* Kann unterschiedliche Typen gleichsetzen.

```js
console.log(5 == "5");    // true (String ‚Üí Number)
console.log(true == 1);   // true
console.log(null == undefined); // true
```

---

### 2. `===` (strikte Gleichheit)

* Vergleicht Werte **ohne Typumwandlung**.
* Typ und Wert m√ºssen identisch sein.

```js
console.log(5 === "5");   // false (unterschiedliche Typen)
console.log(true === 1);  // false
console.log(null === undefined); // false
```

---

### 3. Besonderheiten

* `NaN` ist nie gleich:

```js
console.log(NaN === NaN); // false
```

* Pr√ºfen mit `Number.isNaN(NaN); // true`

* Objektvergleiche: Nur gleich, wenn es sich um **dasselbe Objekt im Speicher** handelt.

```js
const a = {};
const b = {};
console.log(a === b); // false
```

---

### 4. Best Practice

* In moderner Praxis immer **`===`** verwenden.
* `==` nur, wenn man **bewusst Typumwandlung** nutzen will (selten sinnvoll).

---

**Zusammenfassung:**

* `==` vergleicht Werte **mit Typumwandlung** (lose Gleichheit).
* `===` vergleicht Werte **ohne Typumwandlung** (strikte Gleichheit).
* Empfehlung: **immer `===`**, um unerwartete Ergebnisse zu vermeiden.

üìñ Quelle: [MDN Web Docs ‚Äî Equality comparisons](https://developer.mozilla.org/ru/docs/Web/JavaScript/Equality_comparisons_and_sameness)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

16. ### <a name="16"></a> Primitive vs. Referenztypen

**Primitive vs. Referenztypen in JavaScript**

---

### 1. Primitive Typen

* **Arten:** `string`, `number`, `bigint`, `boolean`, `symbol`, `undefined`, `null`
* **Eigenschaften:**

  * Unver√§nderlich (immutable)
  * Werden **direkt im Stack** gespeichert
  * Vergleiche erfolgen nach **Wert**

```js
let a = 10;
let b = a;   // Kopie des Werts
b = 20;
console.log(a); // 10 (unver√§ndert)
```

---

### 2. Referenztypen

* **Arten:** `Object`, `Array`, `Function`, `Date`, `RegExp` usw.
* **Eigenschaften:**

  * Ver√§nderlich (mutable)
  * Variable speichert **Referenz (Adresse)**, nicht das Objekt selbst
  * Vergleiche erfolgen nach **Referenz**, nicht nach Inhalt

```js
let obj1 = { name: "Sergii" };
let obj2 = obj1;   // Kopie der Referenz
obj2.name = "Alex";
console.log(obj1.name); // "Alex" (beide verweisen auf dasselbe Objekt)
```

---

### 3. Vergleich Primitive vs. Referenz

| Merkmal         | Primitive Typen      | Referenztypen              |
| --------------- | -------------------- | -------------------------- |
| Speicherung     | Wert direkt im Stack | Referenz (Adresse im Heap) |
| Ver√§nderbarkeit | unver√§nderlich       | ver√§nderlich               |
| Vergleich       | nach Wert            | nach Referenz              |
| Zuweisung       | Kopie des Werts      | Kopie der Referenz         |

---

### 4. Besonderheiten beim Vergleich

```js
console.log({} === {});      // false (verschiedene Objekte im Speicher)
console.log([1,2] === [1,2]); // false (verschiedene Arrays)
console.log("Hi" === "Hi");   // true (Primitive vergleichen Werte)
```

---

**Zusammenfassung:**

* **Primitive Typen** sind unver√§nderliche Werte, die direkt gespeichert und nach **Wert** verglichen werden.
* **Referenztypen** speichern nur eine Adresse im Speicher (Heap) ‚Üí Zuweisungen und Vergleiche erfolgen nach **Referenz**.
* Deshalb ver√§ndern Objekte/Arrays beim Weitergeben mehrere Variablen gleichzeitig.

üìñ Quelle: [MDN Web Docs ‚Äî Data types](https://developer.mozilla.org/ru/docs/Web/JavaScript/Data_structures)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

17. ### <a name="17"></a> Symbol.iterator und Iterierbare Objekte

**`Symbol.iterator` und iterierbare Objekte in JavaScript**

---

### 1. Iterierbare Objekte

* Ein Objekt ist **iterierbar**, wenn es die Methode **`[Symbol.iterator]()`** implementiert.
* Diese Methode muss einen **Iterator** zur√ºckgeben.
* Iterator = Objekt mit Methode **`next()`**, die `{ value, done }` liefert.

```js
const iterable = {
  items: [1, 2, 3],
  [Symbol.iterator]() {
    let i = 0;
    return {
      next: () => {
        if (i < this.items.length) {
          return { value: this.items[i++], done: false };
        }
        return { done: true };
      }
    };
  }
};

for (const num of iterable) {
  console.log(num); // 1, 2, 3
}
```

---

### 2. Eingebaute iterierbare Objekte

* **Array**
* **String**
* **Map**
* **Set**
* **arguments-Objekt**
* Einige DOM-Kollektionen (z. B. `NodeList`)

```js
for (const char of "Sergii") {
  console.log(char);
}
```

---

### 3. Verwendung in Syntax

* `for...of` greift auf `[Symbol.iterator]` zu.
* **Spread-Operator `...`** funktioniert nur mit iterierbaren Objekten.
* Funktionen wie `Array.from()` erwarten Iterables.

```js
console.log([..."ABC"]); // ["A","B","C"]

const set = new Set([1,2,3]);
console.log([...set]); // [1,2,3]
```

---

### 4. Unterschied Iterator vs. Iterable

* **Iterable**: hat eine Methode `[Symbol.iterator]()`, die einen Iterator liefert.
* **Iterator**: hat `next()`, das `{ value, done }` zur√ºckgibt.

---

### 5. Generatoren (vereinfachte Iterator-Erstellung)

* Mit `function*` lassen sich Iterables leicht bauen.

```js
function* gen() {
  yield 1;
  yield 2;
  yield 3;
}
for (const val of gen()) {
  console.log(val); // 1, 2, 3
}
```

---

**Zusammenfassung:**

* Iterierbare Objekte implementieren **`[Symbol.iterator]()`**.
* Damit funktionieren `for...of`, Spread-Operator und viele eingebaute Funktionen (`Array.from`, `Promise.all`).
* Eingebaute Iterables: Arrays, Strings, Maps, Sets.
* Iterator liefert Werte schrittweise √ºber `next()`. Generatoren vereinfachen deren Erstellung.

üìñ Quelle: [MDN Web Docs ‚Äî Iteration protocols](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Iteration_protocols)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

18. ### <a name="18"></a> WeakRef und FinalizationRegistry

**`WeakRef` und `FinalizationRegistry` in JavaScript**

---

### 1. Hintergrund

* Standardm√§√üig verhindern **starke Referenzen**, dass ein Objekt vom **Garbage Collector (GC)** entfernt wird.
* Manchmal m√∂chte man jedoch, dass ein Objekt **entfernt werden kann**, auch wenn noch Verweise existieren.
* Daf√ºr gibt es **schwache Referenzen** und die M√∂glichkeit, Aufr√§umaktionen nach der GC zu registrieren.

---

### 2. `WeakRef`

* Ein **WeakRef** h√§lt eine **schwache Referenz** auf ein Objekt.
* Der GC darf das Objekt jederzeit l√∂schen, wenn es sonst nicht mehr erreichbar ist.
* Zugriff erfolgt √ºber `.deref()` ‚Üí gibt das Objekt zur√ºck oder `undefined`, falls es schon gel√∂scht wurde.

```js
let obj = { name: "Sergii" };
const weakRef = new WeakRef(obj);

// Zugriff
console.log(weakRef.deref().name); // "Sergii"

// Objekt freigeben
obj = null;
// Irgendwann l√∂scht der GC es ‚Üí weakRef.deref() liefert dann undefined
```

**Einsatzgebiet:**

* Caches
* Strukturen, bei denen Objekte automatisch verschwinden d√ºrfen

---

### 3. `FinalizationRegistry`

* Erlaubt es, eine **Aufr√§umfunktion** zu registrieren, die aufgerufen wird, wenn ein Objekt vom GC entfernt wird.
* Syntax:

```js
const registry = new FinalizationRegistry((heldValue) => {
  console.log(`Aufr√§umen: ${heldValue}`);
});

let user = { name: "Sergii" };
registry.register(user, "User-Daten");

// sp√§ter
user = null;
// Wenn GC Objekt l√∂scht ‚Üí Callback in Registry wird irgendwann aufgerufen
```

**Hinweis:**

* Zeitpunkt des Callbacks ist **nicht deterministisch**.
* GC entscheidet selbst, wann Speicher freigegeben wird.

---

### 4. Unterschiede & Einschr√§nkungen

| Feature      | WeakRef                           | FinalizationRegistry                            |
| ------------ | --------------------------------- | ----------------------------------------------- |
| Zweck        | Zugriff auf Objekt, falls noch da | Aufr√§umaktionen nach GC                         |
| Zugriff      | `deref()`                         | Callback mit ‚ÄûheldValue‚Äú                        |
| GC-Steuerung | keine Kontrolle                   | keine Kontrolle, nur Reaktion m√∂glich           |
| Einsatz      | Caches, optionale Objekte         | Logging, Cleanup von Ressourcen (z. B. Handles) |

---

**Zusammenfassung:**

* **`WeakRef`** erm√∂glicht den Zugriff auf Objekte, ohne deren Lebensdauer zu verl√§ngern.
* **`FinalizationRegistry`** erlaubt das Registrieren von Aufr√§um-Callbacks, wenn Objekte vom GC entfernt werden.
* Beide dienen dem Umgang mit Speicherverwaltung, sollten aber **sparsam** genutzt werden, da der GC-Zeitpunkt unvorhersehbar ist.

üìñ Quelle: [MDN Web Docs ‚Äî WeakRef](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/WeakRef), [MDN Web Docs ‚Äî FinalizationRegistry](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

19. ### <a name="19"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

20. ### <a name="20"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

21. ### <a name="21"></a> Funktionen, Pfeilfunktionen, IIFE, Unterschied zwischen Funktionsdeklaration und Funktionsausdruck

**Funktionen in JavaScript: Deklaration, Ausdruck, Pfeilfunktionen, IIFE**

---

### 1. Funktionsdeklaration (Function Declaration)

* Syntax mit `function` + Name.
* Wird **gehoisted** ‚Üí kann vor der Definition aufgerufen werden.

```js
greet(); // funktioniert
function greet() {
  console.log("Hallo!");
}
```

---

### 2. Funktionsausdruck (Function Expression)

* Funktion wird einer Variablen zugewiesen.
* **Nicht gehoisted** ‚Üí erst nach der Zuweisung verf√ºgbar.

```js
// greet(); // ReferenceError
const greet = function () {
  console.log("Hallo!");
};
```

---

### 3. Pfeilfunktionen (Arrow Functions, ES6)

* K√ºrzere Syntax: `() => {}`
* **Kein eigenes `this`**, sondern √ºbernimmt `this` aus der √§u√üeren Umgebung (lexikalisches `this`).
* K√∂nnen nicht als Konstruktoren verwendet werden.
* Kein `arguments`-Objekt, aber Zugriff √ºber Rest-Parameter m√∂glich.

```js
const sum = (a, b) => a + b;
console.log(sum(2, 3)); // 5

const obj = {
  name: "Sergii",
  normal() { console.log(this.name); }, // "Sergii"
  arrow: () => console.log(this.name)   // undefined (this vom √§u√üeren Scope)
};
obj.normal();
obj.arrow();
```

---

### 4. IIFE (Immediately Invoked Function Expression)

* Funktion, die **sofort nach der Definition** ausgef√ºhrt wird.
* Umgeben von `()` und mit `()` aufgerufen.
* H√§ufig verwendet, um einen **eigenen Scope** zu schaffen.

```js
(function () {
  console.log("IIFE l√§uft sofort!");
})(); 

(() => {
  console.log("Arrow IIFE l√§uft auch!");
})();
```

---

### 5. Vergleich ‚Äì Deklaration vs. Ausdruck

| Merkmal               | Funktionsdeklaration | Funktionsausdruck            |
| --------------------- | -------------------- | ---------------------------- |
| Name                  | ben√∂tigt             | optional                     |
| Hoisting              | ja                   | nein                         |
| Aufruf vor Definition | m√∂glich              | nicht m√∂glich                |
| Typische Nutzung      | Standardfunktionen   | Inline-Funktionen, Callbacks |

---

**Zusammenfassung:**

* **Deklaration**: `function name() {}`, wird gehoisted.
* **Ausdruck**: `const fn = function() {};`, nicht gehoisted.
* **Pfeilfunktionen**: kompakte Syntax, lexikalisches `this`, kein `arguments`.
* **IIFE**: sofortige Ausf√ºhrung zur Kapselung eines Scopes.

üìñ Quelle: [MDN Web Docs ‚Äî Functions](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions), [MDN Web Docs ‚Äî Arrow functions](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Arrow_functions)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

22. ### <a name="22"></a> Methoden zur Kontextbindung (call, apply, bind)

**Methoden zur Kontextbindung (`call`, `apply`, `bind`) in JavaScript**

---

### 1. Hintergrund

* Jede Funktion hat Zugriff auf **`this`**, das den aktuellen Kontext beschreibt.
* Mit `call`, `apply` und `bind` kann man diesen Kontext explizit setzen.

---

### 2. `call()`

* Ruft die Funktion **sofort** mit angegebenem Kontext und Argumenten auf.

```js
function greet(greeting) {
  console.log(`${greeting}, mein Name ist ${this.name}`);
}

const user = { name: "Sergii" };

greet.call(user, "Hallo"); 
// "Hallo, mein Name ist Sergii"
```

---

### 3. `apply()`

* Wie `call()`, aber Argumente werden als **Array** √ºbergeben.

```js
greet.apply(user, ["Hi"]); 
// "Hi, mein Name ist Sergii"
```

Typisches Beispiel: Nutzung von `Math.max` auf einem Array:

```js
console.log(Math.max.apply(null, [1, 5, 3])); // 5
```

---

### 4. `bind()`

* Gibt eine **neue Funktion** zur√ºck, die fest an den angegebenen Kontext gebunden ist.
* Wird **nicht sofort ausgef√ºhrt**.

```js
const boundGreet = greet.bind(user, "Servus");
boundGreet(); 
// "Servus, mein Name ist Sergii"
```

---

### 5. Vergleich

| Methode | Ausf√ºhrung        | Argumente      | R√ºckgabe                        |
| ------- | ----------------- | -------------- | ------------------------------- |
| `call`  | sofort            | Einzelne Werte | Ergebnis der Funktion           |
| `apply` | sofort            | Array          | Ergebnis der Funktion           |
| `bind`  | sp√§ter (explizit) | Einzelne Werte | neue Funktion mit festem `this` |

---

### 6. Besonderheiten

* `bind` wird oft f√ºr **Event-Handler** oder **Callbacks** genutzt.
* `apply` war n√ºtzlich f√ºr ‚ÄûSpread‚Äú-Effekte, aber seit ES6 meist durch den Spread-Operator ersetzt:

```js
console.log(Math.max(...[1, 5, 3])); // 5
```

---

**Zusammenfassung:**

* **`call`**: f√ºhrt Funktion sofort mit Kontext + Argumenten aus.
* **`apply`**: wie `call`, aber Argumente als Array.
* **`bind`**: erstellt neue Funktion mit festem Kontext, wird sp√§ter ausgef√ºhrt.

üìñ Quelle: [MDN Web Docs ‚Äî Function.prototype.call](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/call), [MDN Web Docs ‚Äî apply](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/apply), [MDN Web Docs ‚Äî bind](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/bind)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

23. ### <a name="23"></a> Closures (Abschl√ºsse)

**Closures (Abschl√ºsse) in JavaScript**

---

### 1. Definition

Ein **Closure** entsteht, wenn eine Funktion Zugriff auf Variablen aus ihrer **√§u√üeren lexikalischen Umgebung** beh√§lt ‚Äì auch dann, wenn diese √§u√üere Funktion bereits beendet ist.

---

### 2. Einfaches Beispiel

```js
function outer() {
  let counter = 0;
  return function inner() {
    counter++;
    return counter;
  };
}

const inc = outer();

console.log(inc()); // 1
console.log(inc()); // 2
console.log(inc()); // 3
```

* `inner` bildet ein **Closure** und speichert Zugriff auf `counter`, obwohl `outer()` schon zur√ºckgegeben wurde.

---

### 3. Eigenschaften

* Funktionen ‚Äûmerken sich‚Äú ihre **lexikalische Umgebung**.
* Variablen werden nicht neu erstellt, sondern weiterverwendet.
* Grundlage f√ºr **Datenkapselung** und **Module** in JS.

---

### 4. Praktische Anwendungsf√§lle

1. **Datenkapselung**

   ```js
   function createUser(name) {
     return {
       getName: () => name,
       setName: (newName) => { name = newName; }
     };
   }
   const user = createUser("Sergii");
   console.log(user.getName()); // "Sergii"
   user.setName("Alex");
   console.log(user.getName()); // "Alex"
   ```

2. **Funktionen als Generatoren**

   ```js
   function multiplier(factor) {
     return x => x * factor;
   }
   const double = multiplier(2);
   console.log(double(5)); // 10
   ```

3. **Callbacks und Event-Handler**

   ```js
   function setup() {
     let msg = "Hallo";
     document.addEventListener("click", () => console.log(msg));
   }
   setup();
   // Klick zeigt immer "Hallo", Closure h√§lt msg fest
   ```

---

### 5. Besonderheiten

* Closures k√∂nnen zu **Memory Leaks** f√ºhren, wenn gro√üe Strukturen ‚Äûversehentlich‚Äú festgehalten werden.
* GC l√∂scht Variablen nicht, solange sie von einem Closure referenziert werden.

---

**Zusammenfassung:**
Ein **Closure** ist eine Funktion, die ihre √§u√üere **lexikalische Umgebung** ‚Äûmitnimmt‚Äú. Dadurch k√∂nnen innere Funktionen auf Variablen der √§u√üeren Funktion zugreifen ‚Äì auch nach deren Ausf√ºhrung. Closures erm√∂glichen **Kapselung, Datenpersistenz und flexible Funktionserstellung**.

üìñ Quelle: [MDN Web Docs ‚Äî Closures](https://developer.mozilla.org/ru/docs/Web/JavaScript/Closures)

---
  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

24. ### <a name="24"></a> Callback-Funktionen in JavaScript

**Callback-Funktionen in JavaScript**

---

### 1. Definition

Eine **Callback-Funktion** ist eine Funktion, die **als Argument** an eine andere Funktion √ºbergeben und dort **zu einem sp√§teren Zeitpunkt** aufgerufen wird.

---

### 2. Einfaches Beispiel

```js
function greet(name, callback) {
  console.log(`Hallo, ${name}`);
  callback();
}

function bye() {
  console.log("Auf Wiedersehen!");
}

greet("Sergii", bye);
// Hallo, Sergii
// Auf Wiedersehen!
```

---

### 3. Anonyme Callback-Funktion

```js
setTimeout(() => {
  console.log("Nach 1 Sekunde ausgef√ºhrt");
}, 1000);
```

---

### 4. Verwendung

* **Asynchroner Code**: z. B. Timer, Event-Handler, Netzwerkrequests.
* **Funktionen h√∂herer Ordnung** wie `map`, `filter`, `forEach`.

```js
const nums = [1, 2, 3];
const doubled = nums.map(n => n * 2);
console.log(doubled); // [2, 4, 6]
```

---

### 5. Problem: Callback Hell

* Verschachtelte Callbacks machen Code un√ºbersichtlich:

```js
doSomething((result) => {
  doSomethingElse(result, (newResult) => {
    doThirdThing(newResult, (final) => {
      console.log(final);
    });
  });
});
```

* L√∂sung: **Promises** oder **async/await**.

---

### 6. Zusammenhang mit `this`

* Bei Callbacks kann der Kontext (`this`) verloren gehen.
* L√∂sung: `bind`, Arrow Functions oder Variablen speichern.

```js
const obj = {
  value: 10,
  logLater() {
    setTimeout(() => console.log(this.value), 1000);
  }
};
obj.logLater(); // 10
```

---

**Zusammenfassung:**
Callback-Funktionen sind Funktionen, die an andere Funktionen √ºbergeben und dort sp√§ter ausgef√ºhrt werden. Sie sind zentral f√ºr **Asynchronit√§t** und **h√∂here Ordnungsfunktionen**. Nachteile wie **Callback Hell** werden heute durch **Promises** und **async/await** vermieden.

üìñ Quelle: [MDN Web Docs ‚Äî Callback function](https://developer.mozilla.org/ru/docs/Glossary/Callback_function)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

25. ### <a name="25"></a> Konstruktor-Funktionen

**Konstruktor-Funktionen in JavaScript**

---

### 1. Definition

* Konstruktor-Funktion = normale Funktion, die mit **`new`** aufgerufen wird.
* Dient zur Erstellung mehrerer √§hnlicher Objekte (wie eine Schablone).
* Konvention: Name beginnt mit **Gro√übuchstaben**.

---

### 2. Syntax

```js
function User(name, age) {
  this.name = name;
  this.age = age;
  this.sayHi = function() {
    console.log(`Hallo, ich bin ${this.name}`);
  };
}

const user1 = new User("Sergii", 33);
const user2 = new User("Alex", 25);

user1.sayHi(); // "Hallo, ich bin Sergii"
```

---

### 3. Ablauf beim Aufruf mit `new`

1. Neues leeres Objekt wird erstellt: `{}`
2. `this` zeigt auf dieses neue Objekt
3. Code in der Funktion wird ausgef√ºhrt, Eigenschaften/Methoden hinzugef√ºgt
4. Das Objekt wird automatisch zur√ºckgegeben

---

### 4. Methoden im Prototyp

Besser: Methoden im **Prototype** definieren ‚Üí Speicher effizienter.

```js
function User(name) {
  this.name = name;
}

User.prototype.sayHi = function() {
  console.log(`Hallo, ich bin ${this.name}`);
};

const u = new User("Sergii");
u.sayHi();
```

---

### 5. Vergleich zu Klassen (ES6)

* Klassen sind syntaktischer Zucker f√ºr Konstruktor-Funktionen.

```js
class User {
  constructor(name) {
    this.name = name;
  }
  sayHi() {
    console.log(`Hallo, ich bin ${this.name}`);
  }
}
```

---

### 6. Besonderheiten

* Ohne `new` ‚Üí `this` zeigt auf `undefined` (strict mode) oder `window` (non-strict).
* Deshalb Konstruktoren immer mit `new` verwenden.

```js
const user = User("Sergii"); 
console.log(user); // undefined
```

---

**Zusammenfassung:**
Konstruktor-Funktionen sind spezielle Funktionen, die mit `new` Objekte erzeugen. Sie initialisieren Eigenschaften im Objekt √ºber `this`. Methoden sollten im `prototype` gespeichert werden. Seit ES6 werden **Klassen** als moderne Alternative verwendet.

üìñ Quelle: [MDN Web Docs ‚Äî Constructor](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes/constructor)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

26. ### <a name="26"></a> Aufrufkontext (this)

**Aufrufkontext (`this`) in JavaScript**

---

### 1. Definition

* `this` = spezielles Schl√ºsselwort, das den **aktuellen Ausf√ºhrungskontext** (Kontext des Funktionsaufrufs) beschreibt.
* Wert von `this` h√§ngt **nicht vom Ort der Definition**, sondern vom **Aufruf** ab.

---

### 2. Im globalen Kontext

```js
console.log(this); 
// Browser: Window
// Node.js (strict mode): undefined
```

---

### 3. In Funktionen

* **Non-strict mode**: `this` zeigt auf das globale Objekt (`window`).
* **Strict mode**: `this` bleibt `undefined`.

```js
function test() {
  console.log(this);
}
test(); // undefined (strict) oder window (non-strict)
```

---

### 4. In Objekten (Methodenaufruf)

```js
const obj = {
  name: "Sergii",
  sayHi() {
    console.log(this.name);
  }
};

obj.sayHi(); // "Sergii"
```

---

### 5. In Konstruktoren und Klassen

* Bei Aufruf mit `new`: `this` verweist auf das neu erstellte Objekt.

```js
function User(name) {
  this.name = name;
}
const u = new User("Sergii");
console.log(u.name); // "Sergii"
```

---

### 6. Verlust von `this`

Wenn eine Methode als Callback √ºbergeben wird, kann der Kontext verloren gehen:

```js
const user = {
  name: "Sergii",
  sayHi() {
    console.log(this.name);
  }
};

setTimeout(user.sayHi, 1000); // undefined (Kontextverlust)
```

L√∂sung: **bind** oder Arrow Function:

```js
setTimeout(() => user.sayHi(), 1000); // "Sergii"
```

---

### 7. `call`, `apply`, `bind`

Explizite Bindung von `this`.

```js
function greet() {
  console.log(this.name);
}
const user = { name: "Alex" };
greet.call(user);  // "Alex"
```

---

### 8. Arrow Functions (`=>`)

* **Kein eigenes `this`**.
* Erben `this` aus der **lexikalischen Umgebung**.

```js
const obj = {
  name: "Sergii",
  arrow: () => console.log(this.name),
  normal() { console.log(this.name); }
};

obj.normal(); // "Sergii"
obj.arrow();  // undefined (this vom √§u√üeren Scope = global)
```

---

**Zusammenfassung:**

* `this` h√§ngt vom **Aufrufkontext** ab, nicht von der Definition.
* Global: `window` (non-strict) oder `undefined` (strict).
* Methode in Objekt: zeigt auf Objekt.
* Konstruktor/Klasse: neues Objekt.
* Arrow Functions: erben `this` lexikalisch.
* Kontext kann mit `call`, `apply`, `bind` gesteuert werden.

üìñ Quelle: [MDN Web Docs ‚Äî this](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/this)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

27. ### <a name="27"></a> Getter und Setter (Objekteigenschaften)

**Getter und Setter in JavaScript (Objekteigenschaften)**

---

### 1. Definition

* **Getter** = spezielle Methode zum **Auslesen** einer Eigenschaft.
* **Setter** = spezielle Methode zum **Setzen/√Ñndern** einer Eigenschaft.
* Werden mit Schl√ºsselw√∂rtern `get` und `set` definiert.

---

### 2. Beispiel ‚Äì Objektliteral

```js
const user = {
  firstName: "Sergii",
  lastName: "Bachmann",
  
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  },
  
  set fullName(value) {
    const [first, last] = value.split(" ");
    this.firstName = first;
    this.lastName = last;
  }
};

console.log(user.fullName); // "Sergii Bachmann"
user.fullName = "Alex M√ºller";
console.log(user.firstName); // "Alex"
```

---

### 3. Mit `Object.defineProperty()`

```js
const person = { age: 30 };

Object.defineProperty(person, "doubleAge", {
  get() {
    return this.age * 2;
  },
  set(value) {
    this.age = value / 2;
  }
});

console.log(person.doubleAge); // 60
person.doubleAge = 100;
console.log(person.age); // 50
```

---

### 4. In Klassen (ES6)

```js
class User {
  constructor(name) {
    this._name = name;
  }
  
  get name() {
    return this._name.toUpperCase();
  }
  
  set name(value) {
    if (value.length < 3) {
      console.log("Name zu kurz!");
      return;
    }
    this._name = value;
  }
}

const u = new User("Sergii");
console.log(u.name); // "SERGII"
u.name = "Al";      // "Name zu kurz!"
```

---

### 5. Vorteile

* Erm√∂glichen **Kontrolle** √ºber den Zugriff auf Eigenschaften.
* K√∂nnen Berechnungen oder Validierungen beim Lesen/Schreiben durchf√ºhren.
* Erzeugen f√ºr Au√üenstehenden die Illusion ‚Äûnormaler Eigenschaften‚Äú.

---

**Zusammenfassung:**
Getter und Setter sind spezielle Methoden zum **Lesen und Schreiben von Eigenschaften**. Sie erm√∂glichen Kapselung, Validierung und dynamische Berechnungen. Definiert werden sie mit `get`/`set`, `Object.defineProperty()` oder in **Klassen**.

üìñ Quelle: [MDN Web Docs ‚Äî getter](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/get), [MDN Web Docs ‚Äî setter](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/set)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

28. ### <a name="28"></a> Generatorfunktionen in JavaScript

**Generatorfunktionen in JavaScript**

---

### 1. Definition

* Generator = spezielle Funktion, die **schrittweise** Werte liefert.
* Deklariert mit `function*`.
* R√ºckgabe ist ein **Iterator-Objekt** mit Methode `next()`.
* `yield` unterbricht die Ausf√ºhrung und gibt einen Wert zur√ºck.

---

### 2. Einfaches Beispiel

```js
function* genNumbers() {
  yield 1;
  yield 2;
  yield 3;
}

const it = genNumbers();

console.log(it.next()); // { value: 1, done: false }
console.log(it.next()); // { value: 2, done: false }
console.log(it.next()); // { value: 3, done: false }
console.log(it.next()); // { value: undefined, done: true }
```

---

### 3. Verwendung mit `for...of`

* Generatoren sind **iterierbar**.

```js
for (const n of genNumbers()) {
  console.log(n); // 1, 2, 3
}
```

---

### 4. Werte an Generator zur√ºckgeben

* Mit `next(value)` kann man Daten **in den Generator hineingeben**.

```js
function* dialog() {
  const name = yield "Wie hei√üt du?";
  yield `Hallo, ${name}!`;
}

const it = dialog();
console.log(it.next().value);     // "Wie hei√üt du?"
console.log(it.next("Sergii").value); // "Hallo, Sergii!"
```

---

### 5. Unendliche Sequenzen

Generatoren k√∂nnen **lazy evaluated** Sequenzen erzeugen.

```js
function* infinite() {
  let i = 0;
  while (true) {
    yield i++;
  }
}

const nums = infinite();
console.log(nums.next().value); // 0
console.log(nums.next().value); // 1
```

---

### 6. Vorteile

* Arbeiten mit **Iterationen** und **Streams**.
* Sparsamer Speicherverbrauch (Werte nur bei Bedarf erzeugt).
* Grundlage f√ºr **asynchrone Generatoren** (`async function*`) ‚Üí z. B. Datenstr√∂me.

---

**Zusammenfassung:**
Generatorfunktionen (`function*`) liefern Schritt-f√ºr-Schritt-Werte mit `yield`. Sie geben ein Iterator-Objekt zur√ºck, das mit `next()` oder `for...of` genutzt werden kann. Vorteil: **Lazy Evaluation**, **bessere Speicherverwaltung** und flexible Datenstr√∂me.

üìñ Quelle: [MDN Web Docs ‚Äî function\*](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/function*)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

29. ### <a name="29"></a> Rekursion in JavaScript

**Rekursion in JavaScript**

---

### 1. Definition

Rekursion = wenn eine Funktion **sich selbst aufruft**, um ein Problem durch Zerlegung in kleinere Teilprobleme zu l√∂sen.

---

### 2. Beispiel ‚Äì Fakult√§t

```js
function factorial(n) {
  if (n === 0) return 1;      // Abbruchbedingung
  return n * factorial(n - 1);
}

console.log(factorial(5)); // 120
```

---

### 3. Beispiel ‚Äì Traversieren einer Struktur

```js
const tree = {
  name: "root",
  children: [
    { name: "child1" },
    { name: "child2", children: [{ name: "grandchild" }] }
  ]
};

function printTree(node) {
  console.log(node.name);
  if (node.children) {
    node.children.forEach(printTree);
  }
}

printTree(tree);
// root, child1, child2, grandchild
```

---

### 4. Tail Call Optimization (TCO)

* In der Theorie k√∂nnte JS Endrekursionen optimieren, aber **V8 (Chrome, Node)** unterst√ºtzt das nicht.
* Tiefe Rekursion kann daher zu **‚ÄûMaximum call stack size exceeded‚Äú** f√ºhren.

---

### 5. Vergleich: Rekursion vs. Iteration

* **Iteration**: Schleifen (`for`, `while`), meist effizienter.
* **Rekursion**: oft einfacher & eleganter f√ºr Baum-/Strukturprobleme.

Beispiel Summe mit Rekursion:

```js
function sum(arr, i = 0) {
  if (i >= arr.length) return 0;
  return arr[i] + sum(arr, i + 1);
}

console.log(sum([1, 2, 3])); // 6
```

---

### 6. Best Practices

* Immer **Abbruchbedingung** setzen ‚Üí sonst Endlosschleife im Call Stack.
* F√ºr tiefe Berechnungen Iteration bevorzugen.
* Rekursion eignet sich besonders f√ºr:

  * B√§ume und verschachtelte Strukturen
  * Mathematische Definitionen (Fakult√§t, Fibonacci)

---

**Zusammenfassung:**
Rekursion = Funktion ruft sich selbst auf, bis eine **Abbruchbedingung** erreicht ist. Sie wird genutzt f√ºr **hierarchische Strukturen** und mathematische Probleme. Risiken: **Stack Overflow** bei tiefer Rekursion, weshalb Iteration oft effizienter ist.

üìñ Quelle: [MDN Web Docs ‚Äî Functions ‚Üí Recursion](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Functions#rekursiya)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

30. ### <a name="30"></a> Memoization

**Memoization in JavaScript**

---

### 1. Definition

* **Memoization** = Technik zur **Optimierung** von Funktionen, indem Ergebnisse von Funktionsaufrufen im Cache gespeichert werden.
* Wenn die Funktion sp√§ter mit denselben Argumenten aufgerufen wird, wird das Ergebnis **aus dem Cache** zur√ºckgegeben, statt neu berechnet zu werden.

---

### 2. Einfaches Beispiel

```js
function slowSquare(n) {
  console.log("Rechne...");
  return n * n;
}

function memoize(fn) {
  const cache = {};
  return function(x) {
    if (x in cache) {
      return cache[x]; // aus Cache
    }
    const result = fn(x);
    cache[x] = result;
    return result;
  };
}

const fastSquare = memoize(slowSquare);

console.log(fastSquare(4)); // Rechne... ‚Üí 16
console.log(fastSquare(4)); // direkt aus Cache ‚Üí 16
```

---

### 3. Mit mehreren Argumenten (Map statt Objekt)

```js
function memoizeMulti(fn) {
  const cache = new Map();
  return function(...args) {
    const key = JSON.stringify(args);
    if (cache.has(key)) return cache.get(key);
    const result = fn(...args);
    cache.set(key, result);
    return result;
  };
}

const add = (a, b) => a + b;
const memoAdd = memoizeMulti(add);

console.log(memoAdd(2, 3)); // 5 (berechnet)
console.log(memoAdd(2, 3)); // 5 (aus Cache)
```

---

### 4. Praxisbeispiel ‚Äì Fibonacci (Rekursiv)

Ohne Memoization ‚Üí extrem langsam bei gro√üen Zahlen.

```js
function fib(n, memo = {}) {
  if (n in memo) return memo[n];
  if (n <= 1) return n;
  memo[n] = fib(n - 1, memo) + fib(n - 2, memo);
  return memo[n];
}

console.log(fib(40)); // schnell dank Memoization
```

---

### 5. Einsatzgebiete

* Berechnungen mit hohem Aufwand (z. B. Fibonacci, Primzahlen).
* API-Calls oder Datenbankabfragen (Cache von Ergebnissen).
* UI-Berechnungen (z. B. teure Filter oder Sortierungen).

---

**Zusammenfassung:**
Memoization = Caching von Funktionsresultaten zur **Optimierung**.

* Nutzt z. B. Objekte oder Maps als Cache.
* Spart Rechenzeit bei wiederholten Eingaben.
* Typische Anwendungen: **Fibonacci, teure Berechnungen, API-Caching**.

üìñ Quelle: [MDN Web Docs ‚Äî Memoization](https://developer.mozilla.org/ru/docs/Glossary/Memoization)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

31. ### <a name="31"></a> Objekte, Destrukturierung von Objekten (ES6)

**Objekte & Destrukturierung von Objekten (ES6) in JavaScript**

---

### 1. Objekte in JavaScript

* Objekte = Sammlung von **Schl√ºssel-Wert-Paaren**.
* Schl√ºssel sind Strings oder Symbole, Werte k√∂nnen beliebig sein.

```js
const user = {
  name: "Sergii",
  age: 33,
  city: "Leipzig"
};
console.log(user.name); // "Sergii"
```

---

### 2. Destrukturierung ‚Äì Grundlagen (ES6)

Mit Destrukturierung k√∂nnen Eigenschaften direkt in Variablen entpackt werden.

```js
const { name, age } = user;
console.log(name); // "Sergii"
console.log(age);  // 33
```

---

### 3. Alias f√ºr Variablen

```js
const { city: wohnort } = user;
console.log(wohnort); // "Leipzig"
```

---

### 4. Standardwerte

Falls Eigenschaft nicht existiert, kann ein **Default-Wert** gesetzt werden.

```js
const { country = "Deutschland" } = user;
console.log(country); // "Deutschland"
```

---

### 5. Verschachtelte Objekte

```js
const person = {
  name: "Sergii",
  address: {
    street: "Hauptstr.",
    city: "Leipzig"
  }
};

const { address: { city } } = person;
console.log(city); // "Leipzig"
```

---

### 6. Destrukturierung in Funktionen

* Praktisch f√ºr Parameter-Objekte.

```js
function greet({ name, age }) {
  console.log(`Hallo, ${name}, du bist ${age} Jahre alt.`);
}

greet(user); // "Hallo, Sergii, du bist 33 Jahre alt."
```

---

### 7. Rest-Operator bei Objekten

```js
const { name: vorname, ...rest } = user;
console.log(vorname); // "Sergii"
console.log(rest);    // { age: 33, city: "Leipzig" }
```

---

### 8. Kombination mit Spread-Operator

```js
const updatedUser = { ...user, age: 34 };
console.log(updatedUser); // { name: "Sergii", age: 34, city: "Leipzig" }
```

---

**Zusammenfassung:**

* Objekte speichern Daten als Schl√ºssel-Wert-Paare.
* **Destrukturierung (ES6)** erleichtert das direkte Entpacken von Werten in Variablen.
* Unterst√ºtzt **Aliasnamen, Defaultwerte, verschachtelte Strukturen, Rest- und Spread-Operator**.
* Besonders n√ºtzlich bei **Funktionsparametern**.

üìñ Quelle: [MDN Web Docs ‚Äî Destructuring assignment](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

32. ### <a name="32"></a> Methoden Object, Object.prototype

**`Object` und `Object.prototype` in JavaScript**

---

### 1. `Object` (Konstruktorfunktion)

* Eingebaute Funktion zum Erstellen von Objekten.
* Kann als **Funktion** oder mit `new` aufgerufen werden.

```js
const obj1 = new Object();
const obj2 = {}; // Literal-Notation, bevorzugt
```

---

### 2. Wichtige statische Methoden von `Object`

| Methode                             | Beschreibung                                                    | Beispiel                         |
| ----------------------------------- | --------------------------------------------------------------- | -------------------------------- |
| `Object.keys(obj)`                  | Gibt Array der **Eigenschaftsnamen** zur√ºck                     | `["name", "age"]`                |
| `Object.values(obj)`                | Gibt Array der **Eigenschaftswerte** zur√ºck                     | `["Sergii", 33]`                 |
| `Object.entries(obj)`               | Gibt Array von `[key, value]` zur√ºck                            | `[["name","Sergii"],["age",33]]` |
| `Object.fromEntries(arr)`           | Wandelt `[key,value]`-Paare in Objekt um                        | `{ name: "Sergii", age: 33 }`    |
| `Object.assign(target, ...sources)` | Kopiert Eigenschaften                                           | `Object.assign({}, obj)`         |
| `Object.create(proto)`              | Erstellt neues Objekt mit bestimmtem Prototyp                   | `Object.create(null)`            |
| `Object.freeze(obj)`                | Objekt **einfrieren** (keine √Ñnderungen m√∂glich)                |                                  |
| `Object.seal(obj)`                  | √Ñnderungen m√∂glich, aber keine neuen/gel√∂schten Properties      |                                  |
| `Object.is(a, b)`                   | Strikter Vergleich (wie `===`, aber genauer bei `NaN` und `-0`) | `Object.is(NaN, NaN) // true`    |
| `Object.hasOwn(obj, key)` (ES2022)  | Pr√ºft, ob eigene Property vorhanden ist (ohne Prototyp)         | `Object.hasOwn(user, "name")`    |

---

### 3. `Object.prototype`

* Basis-Objekt, von dem **alle Objekte** erben (au√üer mit `Object.create(null)`).
* Enth√§lt Standardmethoden, die alle Objekte besitzen.

| Methode                     | Beschreibung                                                 |
| --------------------------- | ------------------------------------------------------------ |
| `toString()`                | Gibt String-Repr√§sentation zur√ºck, oft √ºberschrieben         |
| `valueOf()`                 | Gibt primitive Repr√§sentation zur√ºck                         |
| `hasOwnProperty(key)`       | Pr√ºft, ob Eigenschaft **eigen** ist (nicht vererbt)          |
| `isPrototypeOf(obj)`        | Pr√ºft, ob aktuelles Objekt im Prototyp-Chain von `obj` liegt |
| `propertyIsEnumerable(key)` | Pr√ºft, ob Property iterierbar ist                            |

Beispiel:

```js
const user = { name: "Sergii" };

console.log(user.hasOwnProperty("name")); // true
console.log(user.toString());             // "[object Object]"
```

---

### 4. Besonderheiten

* **Prototyp-Kette**: Jedes Objekt erbt von `Object.prototype`, au√üer wenn mit `Object.create(null)` erstellt.
* `Object.prototype`-Methoden sollten nicht √ºberschrieben werden (kann Probleme verursachen).
* Viele moderne Methoden (`Object.keys`, `Object.values`, `Object.entries`) sind **statisch** und geh√∂ren zu `Object`, nicht zu `Object.prototype`.

---

**Zusammenfassung:**

* `Object` = globaler Konstruktor mit vielen **statischen Methoden** f√ºr Objekthandling.
* `Object.prototype` = Basis f√ºr alle Objekte, enth√§lt Standardmethoden (`toString`, `hasOwnProperty`).
* Moderne Praxis: eher `Object.keys/values/entries/assign/create/freeze` statt direkter Nutzung von `Object.prototype`.

üìñ Quelle: [MDN Web Docs ‚Äî Object](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object), [MDN Web Docs ‚Äî Object.prototype](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

33. ### <a name="33"></a> M√∂glichkeiten zur Objekterstellung

**M√∂glichkeiten zur Objekterstellung in JavaScript**

---

### 1. Objekt-Literal (am h√§ufigsten)

* K√ºrzeste und einfachste Form.

```js
const user = {
  name: "Sergii",
  age: 33
};
```

---

### 2. Mit `new Object()`

* Weniger gebr√§uchlich, gleichwertig zu `{}`.

```js
const user = new Object();
user.name = "Sergii";
```

---

### 3. Mit `Object.create(proto)`

* Erstellt neues Objekt mit bestimmtem **Prototypen**.

```js
const proto = { greet() { console.log("Hallo"); } };
const user = Object.create(proto);
user.name = "Sergii";

user.greet(); // "Hallo"
```

---

### 4. Mit Konstruktor-Funktion

* Klassischer Ansatz vor ES6.

```js
function User(name, age) {
  this.name = name;
  this.age = age;
}
const u = new User("Sergii", 33);
```

---

### 5. Mit Klassen (ES6)

* Syntaktischer Zucker √ºber Konstruktor-Funktion + Prototype.

```js
class User {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
}
const u = new User("Sergii", 33);
```

---

### 6. Factory Function (Fabrikfunktion)

* Normale Funktion, die ein neues Objekt **zur√ºckgibt**.

```js
function createUser(name, age) {
  return {
    name,
    age,
    greet() {
      console.log(`Hallo, ich bin ${name}`);
    }
  };
}
const user = createUser("Sergii", 33);
user.greet();
```

---

### 7. Mit `Object.assign()`

* Kombinieren/Kopieren von Objekten.

```js
const user = Object.assign({}, { name: "Sergii" }, { age: 33 });
```

---

### 8. Mit Spread-Operator (ES6)

* Moderne Kurzform f√ºr Objektkopien/-kombination.

```js
const base = { name: "Sergii" };
const user = { ...base, age: 33 };
```

---

**Zusammenfassung:**
Objekte lassen sich auf verschiedene Arten erstellen:

* **Direkt**: `{}` oder `new Object()`
* **Mit Prototyp**: `Object.create(proto)`
* **√úber Funktionen**: Konstruktor-Funktion, Factory Function
* **ES6-Klassen**: `class` + `new`
* **Hilfsmethoden**: `Object.assign`, Spread-Operator

üìñ Quelle: [MDN Web Docs ‚Äî Object](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

34. ### <a name="34"></a> Kopieren von Objekten

**Kopieren von Objekten in JavaScript**

---

### 1. Shallow Copy (flache Kopie)

Nur die oberste Ebene wird kopiert. Verschachtelte Objekte bleiben **per Referenz** verbunden.

#### a) `Object.assign()`

```js
const user = { name: "Sergii", address: { city: "Leipzig" } };
const copy = Object.assign({}, user);

copy.name = "Alex";
copy.address.city = "Berlin";

console.log(user.address.city); // "Berlin" (Referenz geteilt!)
```

#### b) Spread-Operator (`...`)

```js
const copy = { ...user };
```

---

### 2. Deep Copy (tiefe Kopie)

Verschachtelte Objekte werden **rekursiv kopiert**.

#### a) JSON-Methode (nur f√ºr einfache Objekte)

* Nachteile: verliert Methoden, `undefined`, `Symbol`, Funktionen.

```js
const deepCopy = JSON.parse(JSON.stringify(user));
```

#### b) Rekursive Funktion (manuell)

```js
function deepClone(obj) {
  if (obj === null || typeof obj !== "object") return obj;
  if (Array.isArray(obj)) return obj.map(deepClone);

  const clone = {};
  for (const key in obj) {
    clone[key] = deepClone(obj[key]);
  }
  return clone;
}
```

#### c) `structuredClone` (moderne Methode, Node.js 17+/Browser)

```js
const deepCopy = structuredClone(user);
```

---

### 3. Besonderheiten

* **Shallow Copy**: schnell, aber verschachtelte Referenzen bleiben verkn√ºpft.
* **Deep Copy**: komplett unabh√§ngig, aber langsamer.
* Funktionen, Prototypen, `Map`, `Set`, Klasseninstanzen ‚Üí nur mit spezialisierten L√∂sungen (z. B. `lodash.cloneDeep`).

---

**Zusammenfassung:**

* **Shallow Copy**: `Object.assign({}, obj)` oder `{...obj}` ‚Üí nur oberste Ebene.
* **Deep Copy**: `structuredClone(obj)` (modern), `JSON.parse(JSON.stringify(obj))` (limitiert), oder manuell/lodash.
* Richtige Methode h√§ngt davon ab, ob verschachtelte Objekte unabh√§ngig sein sollen.

üìñ Quelle: [MDN Web Docs ‚Äî Object.assign](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/assign), [MDN Web Docs ‚Äî structuredClone](https://developer.mozilla.org/ru/docs/Web/API/structuredClone)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

35. ### <a name="35"></a> Property Descriptors (Eigenschaftsbeschreibungen)

**Property Descriptors (Eigenschaftsbeschreibungen) in JavaScript**

---

### 1. Definition

Ein **Property Descriptor** beschreibt, wie eine Objekteigenschaft funktioniert: ob sie ver√§nderbar, auflistbar oder √ºberschreibbar ist.
Jede Eigenschaft in JavaScript hat **versteckte Flags**, die mit **`Object.getOwnPropertyDescriptor()`** sichtbar gemacht werden k√∂nnen.

---

### 2. Standard-Descriptor einer Eigenschaft

```js
const user = { name: "Sergii" };

console.log(Object.getOwnPropertyDescriptor(user, "name"));
/*
{
  value: "Sergii",
  writable: true,     // Wert ver√§nderbar?
  enumerable: true,   // in Schleifen/keys sichtbar?
  configurable: true  // l√∂schbar/√§nderbar?
}
*/
```

---

### 3. `Object.defineProperty()`

Mit dieser Methode lassen sich Eigenschaften mit spezifischen Flags erstellen.

```js
const user = {};

Object.defineProperty(user, "name", {
  value: "Sergii",
  writable: false,    // nicht √ºberschreibbar
  enumerable: true,   // in for...in sichtbar
  configurable: false // nicht l√∂schbar/√§nderbar
});

console.log(user.name); // "Sergii"
user.name = "Alex";
console.log(user.name); // "Sergii" (unver√§ndert)
```

---

### 4. Accessor Descriptors (Getter/Setter)

Statt `value`/`writable` k√∂nnen auch **Getter/Setter** definiert werden.

```js
const person = {
  first: "Sergii",
  last: "Bachmann"
};

Object.defineProperty(person, "fullName", {
  get() {
    return `${this.first} ${this.last}`;
  },
  set(value) {
    [this.first, this.last] = value.split(" ");
  },
  enumerable: true,
  configurable: true
});

console.log(person.fullName); // "Sergii Bachmann"
person.fullName = "Alex M√ºller";
console.log(person.first); // "Alex"
```

---

### 5. Mehrere Eigenschaften gleichzeitig

```js
Object.defineProperties(user, {
  age: { value: 33, writable: true },
  city: { value: "Leipzig", enumerable: false }
});
```

---

### 6. N√ºtzliche Hilfsmethoden

* **`Object.getOwnPropertyDescriptors(obj)`** ‚Üí alle Property-Deskriptoren
* **`Object.preventExtensions(obj)`** ‚Üí keine neuen Eigenschaften
* **`Object.seal(obj)`** ‚Üí keine neuen/l√∂schbaren Eigenschaften, Werte modifizierbar
* **`Object.freeze(obj)`** ‚Üí Eigenschaften fix, unver√§nderlich

---

**Zusammenfassung:**
Property Descriptors definieren, wie Eigenschaften funktionieren:

* **Data Descriptor**: `value`, `writable`, `enumerable`, `configurable`
* **Accessor Descriptor**: `get`, `set`
* Kontrollieren Sichtbarkeit, Ver√§nderbarkeit und Verhalten von Properties.

üìñ Quelle: [MDN Web Docs ‚Äî Object.defineProperty()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

36. ### <a name="36"></a> Private und gesch√ºtzte Eigenschaften von Objekten

**Private und gesch√ºtzte Eigenschaften in JavaScript**

---

### 1. Hintergrund

JavaScript kennt traditionell **keine echte Zugriffskontrolle** wie in Java/C++.
Aber es gibt verschiedene M√∂glichkeiten, Eigenschaften **vor direktem Zugriff zu sch√ºtzen**:

---

### 2. Gesch√ºtzte Eigenschaften (Konvention: Unterstrich `_`)

* Kein echter Schutz, nur **Konvention**.
* Signalisiert ‚ÄûBitte nicht direkt benutzen‚Äú.

```js
class User {
  constructor(name) {
    this._name = name; // gesch√ºtzte Eigenschaft
  }
}

const u = new User("Sergii");
console.log(u._name); // m√∂glich, aber nicht empfohlen
```

---

### 3. Private Eigenschaften mit `#` (ES2022)

* Echte private Felder, nur innerhalb der Klasse zugreifbar.
* Au√üerhalb ‚Üí **SyntaxError**.

```js
class User {
  #password; // private Eigenschaft

  constructor(name, password) {
    this.name = name;
    this.#password = password;
  }

  checkPassword(pwd) {
    return this.#password === pwd;
  }
}

const u = new User("Sergii", "1234");
console.log(u.name);        // "Sergii"
// console.log(u.#password); // ‚ùå SyntaxError
console.log(u.checkPassword("1234")); // true
```

---

### 4. Gesch√ºtzte Eigenschaften mit Closures (√§ltere Technik)

Man kann Variablen √ºber Closures kapseln, sodass sie nur √ºber Methoden erreichbar sind.

```js
function createUser(name, password) {
  let _password = password; // gesch√ºtzt durch Closure
  return {
    name,
    checkPassword(pwd) {
      return _password === pwd;
    }
  };
}

const user = createUser("Sergii", "1234");
console.log(user.name); // "Sergii"
console.log(user.checkPassword("1234")); // true
// console.log(user._password); // undefined
```

---

### 5. Gesch√ºtzte Eigenschaften mit `WeakMap`

Objekte k√∂nnen als Schl√ºssel in einer WeakMap verwendet werden, um Daten ‚Äûversteckt‚Äú zu speichern.

```js
const passwords = new WeakMap();

class User {
  constructor(name, password) {
    this.name = name;
    passwords.set(this, password);
  }

  checkPassword(pwd) {
    return passwords.get(this) === pwd;
  }
}

const u = new User("Sergii", "1234");
console.log(u.checkPassword("1234")); // true
```

---

### 6. Vergleich

| Methode              | Schutzstufe        | Nachteile                                 |
| -------------------- | ------------------ | ----------------------------------------- |
| `_name` (Konvention) | schwach            | nur Stilfrage, kein echter Schutz         |
| Closure              | stark              | nicht OOP-freundlich, schwer zu erweitern |
| `WeakMap`            | stark              | mehr Boilerplate, komplexer               |
| `#private`           | **stark (modern)** | nur in Klassen, relativ neu               |

---

**Zusammenfassung:**

* **Gesch√ºtzt** (Konvention `_`) = keine echte Sicherheit.
* **Private** Eigenschaften:

  * Fr√ºher mit **Closures** oder **WeakMap**.
  * Heute Standard: **`#`-private Felder (ES2022)**.
* Beste Praxis: **`#`-private Felder** f√ºr moderne Klassen.

üìñ Quelle: [MDN Web Docs ‚Äî Private class features](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes/Private_class_fields)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

37. ### <a name="37"></a> Prototypen, Prototypen-Kette

**Prototypen und Prototypen-Kette in JavaScript**

---

### 1. Prototypen

* Jedes Objekt in JavaScript besitzt eine **interne Referenz** auf ein anderes Objekt ‚Üí **Prototyp**.
* Der Prototyp dient als **Fallback**, wenn eine Eigenschaft oder Methode nicht im Objekt selbst vorhanden ist.

```js
const user = { name: "Sergii" };
console.log(user.toString()); // von Object.prototype geerbt
```

---

### 2. Zugriff auf den Prototypen

* **Modern:** `Object.getPrototypeOf(obj)` / `Object.setPrototypeOf(obj, proto)`
* **Veraltet:** `obj.__proto__`

```js
const user = {};
console.log(Object.getPrototypeOf(user) === Object.prototype); // true
```

---

### 3. Prototypen-Kette

* Wenn eine Eigenschaft nicht im Objekt gefunden wird, sucht JavaScript im Prototypen, dann im Prototypen des Prototypen usw.
* Diese Kette endet bei `Object.prototype`, das wiederum `null` als Prototyp hat.

```js
const arr = [1, 2, 3];
console.log(arr.hasOwnProperty("length")); // true (aus Object.prototype)
```

---

### 4. Eigene Prototypen (√ºber Konstruktoren)

```js
function User(name) {
  this.name = name;
}
User.prototype.sayHi = function() {
  console.log(`Hallo, ich bin ${this.name}`);
};

const u = new User("Sergii");
u.sayHi(); // "Hallo, ich bin Sergii"
```

* Hier hat jedes mit `new User()` erzeugte Objekt Zugriff auf `sayHi` √ºber den **Prototyp**.

---

### 5. Klassen (syntaktischer Zucker f√ºr Prototypen)

```js
class User {
  constructor(name) {
    this.name = name;
  }
  sayHi() {
    console.log(`Hallo, ich bin ${this.name}`);
  }
}

const u = new User("Alex");
u.sayHi();
```

* Methoden in Klassen landen **automatisch im Prototyp**.

---

### 6. Prototype Inheritance (Vererbung)

```js
const animal = {
  eat() { console.log("Essen"); }
};

const dog = Object.create(animal);
dog.bark = () => console.log("Wuff!");

dog.eat();  // aus animal
dog.bark(); // aus dog
```

---

### 7. Visualisierung der Prototypen-Kette

`dog ‚Üí animal ‚Üí Object.prototype ‚Üí null`

---

**Zusammenfassung:**

* **Prototyp** = Objekt, von dem ein anderes Objekt erbt.
* **Prototypen-Kette** = Kette von Verweisen, die bei einer Eigenschaftensuche durchlaufen wird.
* Methoden und Vererbung in JS basieren auf diesem Mechanismus.
* **Klassen (ES6)** sind nur syntaktischer Zucker √ºber Prototypen.

üìñ Quelle: [MDN Web Docs ‚Äî Prototypes](https://developer.mozilla.org/ru/docs/Learn/JavaScript/Objects/Object_prototypes)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

38. ### <a name="38"></a> Object.create()

**`Object.create()` in JavaScript**

---

### 1. Definition

* `Object.create(proto, [propertiesObject])` erstellt ein **neues Objekt** mit einem bestimmten **Prototyp**.
* Erlaubt **feinere Kontrolle** √ºber Vererbung als Objekt-Literale.

---

### 2. Einfaches Beispiel

```js
const animal = {
  eat() {
    console.log("Essen...");
  }
};

const dog = Object.create(animal); // Prototyp = animal
dog.bark = function() {
  console.log("Wuff!");
};

dog.eat();  // geerbt von animal
dog.bark(); // eigene Methode
```

---

### 3. Mit `null` als Prototyp

* Erstellt Objekt **ohne Prototyp** ‚Üí kein Zugriff auf `toString`, `hasOwnProperty` usw.

```js
const dict = Object.create(null);
dict.word = "Test";

console.log(dict.toString); // undefined
```

---

### 4. Mit Property Descriptors

Man kann Eigenschaften gleich beim Erstellen definieren.

```js
const user = Object.create(Object.prototype, {
  name: {
    value: "Sergii",
    writable: true,
    enumerable: true,
    configurable: true
  },
  age: {
    value: 33,
    writable: false
  }
});

console.log(user.name); // "Sergii"
user.age = 40;
console.log(user.age); // 33 (nicht √ºberschreibbar)
```

---

### 5. Typischer Anwendungsfall

* Erstellung von Objekten mit **explizitem Prototypen**.
* Basis f√ºr **klassische Vererbung vor ES6**.

```js
function Animal(name) {
  this.name = name;
}
Animal.prototype.speak = function() {
  console.log(`${this.name} macht Ger√§usch`);
};

function Dog(name) {
  Animal.call(this, name);
}
Dog.prototype = Object.create(Animal.prototype); // Vererbung
Dog.prototype.constructor = Dog;

const rex = new Dog("Rex");
rex.speak(); // "Rex macht Ger√§usch"
```

---

**Zusammenfassung:**

* `Object.create(proto)` erzeugt ein Objekt mit bestimmtem Prototyp.
* Mit `null` ‚Üí prototypfreies Objekt.
* Zweites Argument erlaubt **Property Descriptors**.
* Wichtig f√ºr **Vererbung** und **feink√∂rnige Kontrolle** der Objekterstellung.

üìñ Quelle: [MDN Web Docs ‚Äî Object.create()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/create)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

39. ### <a name="39"></a> Unterschied zwischen klassischer und prototypischer Vererbung

**Unterschied zwischen klassischer und prototypischer Vererbung in JavaScript**

---

### 1. Klassische Vererbung (z. B. in Java, C#, C++)

* Basierend auf **Klassen**.
* Klasse = **Schablone** f√ºr Objekte.
* Objekte sind **Instanzen einer Klasse**.
* Hierarchie wird **zur Compile-Zeit** festgelegt.

```java
class Animal {
  void speak() { System.out.println("Ger√§usch"); }
}

class Dog extends Animal {
  void speak() { System.out.println("Wuff!"); }
}
```

---

### 2. Prototypische Vererbung (JavaScript)

* Kein Unterschied zwischen ‚ÄûKlasse‚Äú und ‚ÄûInstanz‚Äú.
* Objekte erben direkt von anderen Objekten (**Prototyp-Kette**).
* Jede Eigenschaft, die nicht gefunden wird, wird im Prototyp gesucht.

```js
const animal = {
  speak() {
    console.log("Ger√§usch");
  }
};

const dog = Object.create(animal);
dog.speak = function() {
  console.log("Wuff!");
};

dog.speak(); // "Wuff!"
```

---

### 3. ES6-Klassen in JavaScript

* **Syntaktischer Zucker** √ºber Prototypen.
* Unter der Haube basiert alles auf **Prototypen-Vererbung**.

```js
class Animal {
  speak() {
    console.log("Ger√§usch");
  }
}

class Dog extends Animal {
  speak() {
    console.log("Wuff!");
  }
}
```

---

### 4. Vergleich

| Merkmal             | Klassische Vererbung | Prototypische Vererbung          |
| ------------------- | -------------------- | -------------------------------- |
| Grundlage           | Klassen              | Objekte                          |
| Beziehung           | Instanz ‚Üî Klasse     | Objekt ‚Üî Prototyp                |
| Zeitpunkt           | Compile-Time         | Laufzeit (dynamisch ver√§nderbar) |
| Erweiterung         | durch neue Klassen   | durch √Ñnderung von Prototypen    |
| JavaScript-Realit√§t | ‚Äî                    | alles basiert auf Prototypen     |

---

**Zusammenfassung:**

* **Klassische Vererbung**: Objekte entstehen aus **Klassen** (Blueprint).
* **Prototypische Vererbung**: Objekte erben direkt von anderen Objekten.
* JavaScript nutzt **prototypische Vererbung**, auch wenn ES6-Klassen wie klassische Syntax aussehen.

üìñ Quelle: [MDN Web Docs ‚Äî Inheritance and the prototype chain](https://developer.mozilla.org/ru/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

40. ### <a name="40"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

41. ### <a name="41"></a> Arrays und Pseudo-Arrays, Array-Destrukturierung

**Arrays, Pseudo-Arrays und Array-Destrukturierung in JavaScript**

---

### 1. Arrays

* Geordnete Sammlung von Werten (Index-basiert).
* Intern Objekte mit speziellen Eigenschaften (`length`, numerische Schl√ºssel).

```js
const arr = [10, 20, 30];
console.log(arr[1]); // 20
console.log(arr.length); // 3
```

---

### 2. Pseudo-Arrays (Array-like Objects)

* Objekte, die wie Arrays aussehen, aber **keine echten Arrays** sind.
* Haben meist:

  * numerische Indizes
  * `length`-Eigenschaft
* Erben **nicht** von `Array.prototype`.

Beispiele:

* `arguments` in Funktionen
* `NodeList` (z. B. `document.querySelectorAll`)

```js
function showArgs() {
  console.log(arguments[0]); // Zugriff per Index
  console.log(arguments.length); 
}
showArgs("a", "b", "c"); // "a", 3
```

Umwandlung in echtes Array:

```js
const arr = Array.from(arguments);
```

---

### 3. Array-Destrukturierung (ES6)

* Erm√∂glicht einfaches **Entpacken von Werten** in Variablen.

```js
const numbers = [1, 2, 3];
const [a, b, c] = numbers;
console.log(a, b, c); // 1 2 3
```

---

### 4. √úberspringen von Elementen

```js
const [first, , third] = [10, 20, 30];
console.log(first, third); // 10 30
```

---

### 5. Rest-Operator (`...`)

```js
const [head, ...tail] = [1, 2, 3, 4];
console.log(head); // 1
console.log(tail); // [2, 3, 4]
```

---

### 6. Standardwerte

```js
const [x = 5, y = 10] = [7];
console.log(x, y); // 7 10
```

---

### 7. Vertauschen von Werten (Swap-Trick)

```js
let a = 1, b = 2;
[a, b] = [b, a];
console.log(a, b); // 2 1
```

---

### 8. Verschachtelte Arrays

```js
const nested = [1, [2, 3]];
const [one, [two, three]] = nested;
console.log(two, three); // 2 3
```

---

**Zusammenfassung:**

* **Arrays**: echte Listen mit Array-Methoden.
* **Pseudo-Arrays**: indexierte Objekte mit `length`, aber ohne Array-Methoden (z. B. `arguments`, `NodeList`).
* **Array-Destrukturierung (ES6)**: komfortables Entpacken mit Optionen wie **Standardwerte**, **Rest-Operator**, **Nested Destructuring**.

üìñ Quelle: [MDN Web Docs ‚Äî Array](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array), [MDN Web Docs ‚Äî Destructuring assignment](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

42. ### <a name="42"></a> Methoden Array, Array.prototype

**Methoden von `Array` und `Array.prototype` in JavaScript**

---

### 1. Unterschied

* **`Array`** = Konstruktorfunktion mit **statischen Methoden** (direkt auf `Array`).
* **`Array.prototype`** = Sammlung von Methoden, die **auf Instanzen** von Arrays verf√ºgbar sind.

---

### 2. Statische Methoden (`Array`)

| Methode                | Beschreibung                                       | Beispiel                             |
| ---------------------- | -------------------------------------------------- | ------------------------------------ |
| `Array.isArray(x)`     | Pr√ºft, ob Wert ein Array ist                       | `Array.isArray([1,2]) // true`       |
| `Array.from(iterable)` | Wandelt Iterables/Pseudo-Arrays in echtes Array um | `Array.from("abc") // ["a","b","c"]` |
| `Array.of(...args)`    | Erstellt Array aus Argumenten                      | `Array.of(1,2,3) // [1,2,3]`         |

---

### 3. Instanzmethoden (`Array.prototype`)

#### a) Zugriff & Iteration

* `at(index)` ‚Üí Element an Position (unterst√ºtzt negative Indizes)
* `forEach(callback)` ‚Üí iteriert √ºber alle Elemente (ohne R√ºckgabe)

```js
[10, 20, 30].at(-1); // 30
[1, 2, 3].forEach(n => console.log(n));
```

#### b) Transformation

* `map(callback)` ‚Üí neues Array mit transformierten Werten
* `filter(callback)` ‚Üí neues Array mit gefilterten Werten
* `reduce(callback, init)` ‚Üí reduziert zu einem Wert
* `flat(depth)` / `flatMap(callback)` ‚Üí Array gl√§tten

```js
[1, 2, 3].map(n => n * 2); // [2, 4, 6]
[1, 2, 3].reduce((a, b) => a + b, 0); // 6
[1, [2, [3]]].flat(2); // [1, 2, 3]
```

#### c) Suche

* `find(callback)` ‚Üí erstes passendes Element
* `findIndex(callback)` ‚Üí Index des ersten Treffers
* `includes(value)` ‚Üí pr√ºft auf Vorhandensein
* `indexOf(value)` / `lastIndexOf(value)`

```js
[1, 2, 3].find(n => n > 1); // 2
[1, 2, 3].includes(2); // true
```

#### d) Mutierende Methoden

* `push(...items)` / `pop()` ‚Üí am Ende hinzuf√ºgen/entfernen
* `shift()` / `unshift(...items)` ‚Üí am Anfang
* `splice(start, deleteCount, ...items)` ‚Üí Elemente hinzuf√ºgen/l√∂schen
* `sort(compareFn)` ‚Üí sortiert Array (mutierend)
* `reverse()` ‚Üí kehrt Reihenfolge um

```js
const arr = [1, 2, 3];
arr.push(4); // [1,2,3,4]
arr.splice(1, 1, 99); // [1,99,3,4]
```

#### e) Nicht-mutierende Methoden

* `slice(start, end)` ‚Üí Teil-Array kopieren
* `concat(...arrays)` ‚Üí Arrays verbinden
* `join(separator)` ‚Üí String erzeugen
* `toString()` ‚Üí Array als String

```js
[1, 2, 3].slice(1); // [2, 3]
[1, 2].concat([3, 4]); // [1, 2, 3, 4]
["a","b"].join("-"); // "a-b"
```

#### f) Iteration-Methoden (ES6+)

* `keys()` ‚Üí Iterator √ºber Indizes
* `values()` ‚Üí Iterator √ºber Werte
* `entries()` ‚Üí Iterator √ºber `[index, value]`

```js
for (const [i, v] of ["a","b"].entries()) {
  console.log(i, v);
}
// 0 "a", 1 "b"
```

---

### 4. Besonderheiten

* **Mutierende Methoden** (z. B. `push`, `splice`) ver√§ndern Original-Array.
* **Nicht-mutierende Methoden** (z. B. `slice`, `map`, `filter`) geben neues Array zur√ºck.
* Moderne Praxis: **immutables Arbeiten** bevorzugt (`map`, `filter`, `reduce` statt `splice`).

---

**Zusammenfassung:**

* **`Array`** enth√§lt statische Methoden (`isArray`, `from`, `of`).
* **`Array.prototype`** enth√§lt Instanzmethoden (Iteration, Transformation, Suche, Mutation).
* Wichtiger Unterschied: **mutierende** vs. **nicht-mutierende** Methoden.

üìñ Quelle: [MDN Web Docs ‚Äî Array](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

43. ### <a name="43"></a> Kopieren von Arrays

**Kopieren von Arrays in JavaScript**

---

### 1. Shallow Copy (flache Kopie)

Kopiert nur die **erste Ebene** ‚Äì verschachtelte Objekte/Arrays bleiben per Referenz verbunden.

#### a) Spread-Operator (ES6)

```js
const arr = [1, 2, 3];
const copy = [...arr];
```

#### b) `Array.slice()`

```js
const arr = [1, 2, 3];
const copy = arr.slice();
```

#### c) `Array.from()`

```js
const arr = [1, 2, 3];
const copy = Array.from(arr);
```

#### d) `concat()`

```js
const arr = [1, 2, 3];
const copy = [].concat(arr);
```

---

### 2. Deep Copy (tiefe Kopie)

Kopiert **rekursiv**, sodass verschachtelte Strukturen unabh√§ngig sind.

#### a) JSON-Methode (einfach, aber limitiert)

* Funktioniert nur mit JSON-kompatiblen Daten.

```js
const arr = [[1, 2], [3, 4]];
const deepCopy = JSON.parse(JSON.stringify(arr));
```

#### b) `structuredClone()` (modern, Browser + Node 17+)

```js
const arr = [[1, 2], [3, 4]];
const deepCopy = structuredClone(arr);
```

#### c) Bibliotheken (z. B. Lodash `_.cloneDeep`)

```js
const _ = require("lodash");
const deepCopy = _.cloneDeep(arr);
```

---

### 3. Besonderheiten

* **Shallow Copy** reicht f√ºr Arrays mit primitiven Werten.
* **Deep Copy** n√∂tig bei verschachtelten Arrays oder Objekten.
* Vorsicht bei **Referenzen**:

```js
const arr = [[1, 2]];
const shallow = [...arr];
shallow[0][0] = 99;
console.log(arr[0][0]); // 99 (immer noch verkn√ºpft!)
```

---

**Zusammenfassung:**

* **Flache Kopie**: `slice`, `concat`, `[...arr]`, `Array.from`.
* **Tiefe Kopie**: `structuredClone`, `JSON.parse(JSON.stringify(...))`, oder Libs wie `lodash`.
* Richtige Methode w√§hlen h√§ngt davon ab, ob **Referenzen** unabh√§ngig sein m√ºssen.

üìñ Quelle: [MDN Web Docs ‚Äî Array](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

44. ### <a name="44"></a> Map, Set, WeakSet, WeakMap

**`Map`, `Set`, `WeakSet`, `WeakMap` in JavaScript**

---

### 1. `Map`

* Sammlung von **Schl√ºssel-Wert-Paaren**.
* Schl√ºssel k√∂nnen **beliebige Typen** sein (auch Objekte).
* **Einf√ºgereihenfolge** wird gespeichert.

```js
const map = new Map();
map.set("name", "Sergii");
map.set({ id: 1 }, "Objekt-Schl√ºssel");

console.log(map.get("name")); // "Sergii"
console.log(map.size);        // 2

for (const [key, value] of map) {
  console.log(key, value);
}
```

---

### 2. `Set`

* Sammlung von **einzigartigen Werten** (keine Duplikate).
* Reihenfolge entspricht der Einf√ºgereihenfolge.

```js
const set = new Set([1, 2, 2, 3]);
console.log(set); // Set(3) {1, 2, 3}

set.add(4);
console.log(set.has(2)); // true
set.delete(1);

for (const value of set) {
  console.log(value);
}
```

---

### 3. `WeakMap`

* √Ñhnlich wie `Map`, aber:

  * **nur Objekte** als Schl√ºssel erlaubt.
  * Referenzen sind **schwach** ‚Üí wenn kein anderes Objekt mehr verweist, kann GC aufr√§umen.
  * Nicht iterierbar (`for...of`, `.keys()` etc. nicht m√∂glich).

```js
const weakMap = new WeakMap();
let obj = { id: 1 };
weakMap.set(obj, "private data");

console.log(weakMap.get(obj)); // "private data"
obj = null; // Objekt freigegeben ‚Üí Eintrag wird vom GC gel√∂scht
```

---

### 4. `WeakSet`

* Sammlung von Objekten (keine primitiven Werte).
* Auch schwache Referenzen ‚Üí GC entfernt automatisch, wenn Objekt unerreichbar.
* Nicht iterierbar.

```js
const weakSet = new WeakSet();
let user = { name: "Sergii" };
weakSet.add(user);

console.log(weakSet.has(user)); // true
user = null; // Referenz gel√∂scht ‚Üí GC r√§umt auf
```

---

### 5. Vergleich

| Struktur    | Schl√ºssel/Werte          | Duplikate?      | Iterierbar? | GC-Eigenschaften       |
| ----------- | ------------------------ | --------------- | ----------- | ---------------------- |
| **Map**     | Key ‚Üí Value (alle Typen) | Key eindeutig   | Ja          | stark (keine GC-Hilfe) |
| **Set**     | nur Werte (alle Typen)   | Werte eindeutig | Ja          | stark                  |
| **WeakMap** | Key = nur Objekte        | Key eindeutig   | Nein        | schwach (GC l√∂scht)    |
| **WeakSet** | nur Objekte              | Werte eindeutig | Nein        | schwach (GC l√∂scht)    |

---

**Zusammenfassung:**

* **Map**: Schl√ºssel-Wert-Paare, beliebige Typen, iterierbar.
* **Set**: Sammlung einzigartiger Werte, iterierbar.
* **WeakMap**: Schl√ºssel = nur Objekte, nicht iterierbar, GC-freundlich.
* **WeakSet**: Objekte als Werte, nicht iterierbar, GC-freundlich.

üìñ Quelle:

* [MDN Web Docs ‚Äî Map](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Map)
* [MDN Web Docs ‚Äî Set](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Set)
* [MDN Web Docs ‚Äî WeakMap](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/WeakMap)
* [MDN Web Docs ‚Äî WeakSet](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/WeakSet)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

45. ### <a name="45"></a> Live Collections (lebendige Sammlungen)

**Live Collections (lebendige Sammlungen) in JavaScript**

---

### 1. Definition

* **Live Collections** = DOM-Sammlungen, die sich **automatisch aktualisieren**, wenn sich das zugrunde liegende Dokument √§ndert.
* Gegensatz: **Static Collections** (statisch), die unver√§ndert bleiben.

---

### 2. Beispiele f√ºr Live Collections

* `document.getElementsByTagName()`
* `document.getElementsByClassName()`
* `document.getElementsByName()`
* `document.forms`, `document.images`, `document.links`

```js
const divs = document.getElementsByTagName("div");
console.log(divs.length); // z. B. 2

const newDiv = document.createElement("div");
document.body.appendChild(newDiv);

console.log(divs.length); // automatisch 3 (Live Collection!)
```

---

### 3. Statische Sammlungen (zum Vergleich)

* `document.querySelectorAll()` ‚Üí gibt **NodeList** zur√ºck, die **statisch** ist.

```js
const nodes = document.querySelectorAll("div");
console.log(nodes.length); // 2

const newDiv = document.createElement("div");
document.body.appendChild(newDiv);

console.log(nodes.length); // bleibt 2 (statisch)
```

---

### 4. Besonderheiten

* Live Collections k√∂nnen zu **Performance-Problemen** f√ºhren, wenn man oft DOM-Operationen durchf√ºhrt (da sie sich st√§ndig neu aktualisieren).
* Deshalb werden in moderner Praxis oft **statische Sammlungen** (`querySelectorAll`) bevorzugt.

---

### 5. Vergleich

| Sammlung                 | Typ            | Dynamisch? | R√ºckgabe                    |
| ------------------------ | -------------- | ---------- | --------------------------- |
| `getElementsByTagName`   | HTMLCollection | Live       | Elemente, auto-aktualisiert |
| `getElementsByClassName` | HTMLCollection | Live       | Elemente, auto-aktualisiert |
| `querySelectorAll`       | NodeList       | Statisch   | bleibt unver√§ndert          |
| `childNodes`             | NodeList       | Live       | inkl. Textknoten            |

---

**Zusammenfassung:**

* **Live Collections** = DOM-Sammlungen, die sich automatisch √§ndern, wenn sich das Dokument √§ndert (`getElementsBy*`).
* **Static Collections** (`querySelectorAll`) bleiben gleich.
* Live Collections sind praktisch, k√∂nnen aber **langsamer** sein, daher in moderner Entwicklung oft **statische Alternativen** bevorzugen.

üìñ Quelle: [MDN Web Docs ‚Äî HTMLCollection](https://developer.mozilla.org/ru/docs/Web/API/HTMLCollection), [MDN Web Docs ‚Äî NodeList](https://developer.mozilla.org/ru/docs/Web/API/NodeList)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

46. ### <a name="46"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

47. ### <a name="47"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

48. ### <a name="48"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

49. ### <a name="49"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

50. ### <a name="50"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

51. ### <a name="51"></a> Spread-Operator (ES6-ES9)

**Spread-Operator (`...`) in JavaScript**

---

### 1. Definition

Der **Spread-Operator** (`...`) breitet ein **iterierbares Objekt** (z. B. Array, String, Set) in einzelne Elemente auf.
Seit **ES6** verf√ºgbar.

---

### 2. Arrays kopieren und zusammenf√ºhren

```js
const arr1 = [1, 2];
const arr2 = [3, 4];

const copy = [...arr1];
console.log(copy); // [1, 2]

const merged = [...arr1, ...arr2];
console.log(merged); // [1, 2, 3, 4]
```

---

### 3. Strings in Zeichen zerlegen

```js
const word = "Hi";
const chars = [...word];
console.log(chars); // ["H", "i"]
```

---

### 4. Objekte kopieren und kombinieren (ES2018+)

```js
const user = { name: "Sergii" };
const details = { age: 33 };

const copy = { ...user };
const merged = { ...user, ...details };

console.log(copy);   // { name: "Sergii" }
console.log(merged); // { name: "Sergii", age: 33 }
```

---

### 5. In Funktionsaufrufen (Alternative zu `apply`)

```js
function sum(a, b, c) {
  return a + b + c;
}

const nums = [1, 2, 3];
console.log(sum(...nums)); // 6
```

---

### 6. Rest-Parameter vs. Spread

* **Spread (`...`)**: entpackt ein Array/Iterable in einzelne Elemente.
* **Rest (`...`)**: sammelt mehrere Werte in ein Array (Parameterdefinition).

```js
function logAll(...args) { // Rest
  console.log(args);
}

logAll(1, 2, 3); // [1, 2, 3]

const arr = [4, 5, 6];
logAll(...arr);  // Spread ‚Üí √úbergabe als Einzelwerte
```

---

**Zusammenfassung:**

* **Spread (`...`)** entpackt Iterables in einzelne Elemente (Arrays, Strings, Sets, Objekte).
* Einsatz: Arrays/Objekte kopieren und mergen, Funktionsaufrufe, Strings zerlegen.
* Unterschied zu **Rest**: Rest sammelt, Spread entpackt.

üìñ Quelle: [MDN Web Docs ‚Äî Spread syntax](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Spread_syntax)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

52. ### <a name="52"></a> Rest-Operator und Standardparameter (ES6)

**Rest-Operator (`...`) und Standardparameter in JavaScript**

---

### 1. Rest-Operator (`...`)

* Sammelt **beliebig viele Argumente** in ein Array.
* Wird in der **Funktionsdefinition** verwendet.

```js
function sum(...nums) {
  return nums.reduce((acc, n) => acc + n, 0);
}

console.log(sum(1, 2, 3, 4)); // 10
```

‚û° Unterschied zum Spread:

* **Spread**: entpackt Arrays in Einzelwerte (beim Aufruf).
* **Rest**: packt Einzelwerte in ein Array (bei Definition).

```js
function logAll(...args) {
  console.log(args);
}

logAll(1, 2, 3); // [1, 2, 3]
```

---

### 2. Standardparameter

* Falls kein Wert oder `undefined` √ºbergeben wird, gilt der **Default-Wert**.

```js
function greet(name = "Gast") {
  console.log(`Hallo, ${name}!`);
}

greet("Sergii"); // "Hallo, Sergii!"
greet();         // "Hallo, Gast!"
greet(undefined); // "Hallo, Gast!"
greet(null);      // "Hallo, null!" (Default nur bei undefined!)
```

---

### 3. Kombination von Rest + Default

```js
function multiply(factor = 1, ...nums) {
  return nums.map(n => n * factor);
}

console.log(multiply(2, 1, 2, 3)); // [2, 4, 6]
console.log(multiply(undefined, 5, 6)); // [5, 6] (factor = 1)
```

---

### 4. Vorteile

* **Rest**: macht Funktionen flexibel (unbegrenzte Argumente).
* **Standardparameter**: vermeidet manuelle Pr√ºfungen mit `||` oder `if`.

---

**Zusammenfassung:**

* **Rest (`...`)** sammelt mehrere Argumente in ein Array (bei Definition).
* **Standardparameter** setzen Default-Werte, falls Argument `undefined` ist.
* Beide k√∂nnen kombiniert werden f√ºr flexible Funktionssignaturen.

üìñ Quelle:

* [MDN Web Docs ‚Äî Rest parameters](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/rest_parameters)
* [MDN Web Docs ‚Äî Default parameters](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Default_parameters)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

53. ### <a name="53"></a> Symbol

**`Symbol` in JavaScript**

---

### 1. Definition

* `Symbol` = primitiver Datentyp (ES6).
* Jeder erstellte Symbolwert ist **einzigartig und unver√§nderlich**.
* Wird oft als **Schl√ºssel f√ºr Objekteigenschaften** genutzt, um Namenskollisionen zu vermeiden.

```js
const id1 = Symbol("id");
const id2 = Symbol("id");

console.log(id1 === id2); // false (immer einzigartig)
```

---

### 2. Verwendung als Objektschl√ºssel

* Symbol-Schl√ºssel werden **nicht** durch normale Iterationen (`for...in`, `Object.keys`) gefunden.

```js
const user = {
  name: "Sergii",
  [Symbol("id")]: 123
};

console.log(Object.keys(user)); // ["name"]
console.log(user);              // { name: "Sergii", [Symbol(id)]: 123 }
```

---

### 3. Zugriff auf Symbole

* Zugriff nur √ºber **direkte Referenz** oder `Object.getOwnPropertySymbols()`.

```js
const id = Symbol("id");
const user = { [id]: 123 };

console.log(user[id]); // 123
console.log(Object.getOwnPropertySymbols(user)); // [Symbol(id)]
```

---

### 4. Globale Symbol-Registry

* `Symbol.for(key)` erstellt oder holt ein Symbol aus der **globalen Registry**.
* Gleiches `key` ‚Üí dasselbe Symbol.

```js
const s1 = Symbol.for("shared");
const s2 = Symbol.for("shared");
console.log(s1 === s2); // true
```

---

### 5. Well-known Symbols (eingebaute Symbole)

JavaScript definiert spezielle Symbole, die Standard-Objekte ‚Äûkonfigurierbar‚Äú machen:

* `Symbol.iterator` ‚Üí Iterierbarkeit (`for...of`, Spread).
* `Symbol.toPrimitive` ‚Üí Steuerung der Typumwandlung.
* `Symbol.toStringTag` ‚Üí Anpassung von `Object.prototype.toString()`.

```js
const obj = {
  [Symbol.toPrimitive](hint) {
    return hint === "number" ? 42 : "Hallo";
  }
};

console.log(+obj);     // 42
console.log(`${obj}`); // "Hallo"
```

---

### 6. Eigenschaften

* Symbole sind **nicht automatisch konvertierbar zu Strings**.

```js
const s = Symbol("test");
// console.log("ID: " + s); // ‚ùå TypeError
console.log("ID: " + String(s)); // ‚úÖ "ID: Symbol(test)"
```

---

**Zusammenfassung:**

* `Symbol` = einzigartiger, unver√§nderlicher primitiver Typ.
* Verwendung: **eindeutige Objektschl√ºssel**, um Konflikte zu vermeiden.
* Globale Registry mit `Symbol.for`.
* **Well-known Symbols** steuern Verhalten von Objekten (z. B. Iterierbarkeit).

üìñ Quelle: [MDN Web Docs ‚Äî Symbol](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Symbol)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

54. ### <a name="54"></a> BigInt

**`BigInt` in JavaScript**

---

### 1. Definition

* `BigInt` = primitiver Datentyp (ES2020).
* Dient zur Darstellung von **ganzen Zahlen beliebiger Gr√∂√üe**, √ºber den Bereich von `Number` hinaus (`¬±2^53 - 1`).

```js
const big = 1234567890123456789012345678901234567890n;
console.log(typeof big); // "bigint"
```

---

### 2. Erstellung

* Mit Suffix **`n`**:

```js
const a = 10n;
```

* Mit **`BigInt()`**-Funktion:

```js
const b = BigInt("9007199254740993");
```

---

### 3. Operationen

* Unterst√ºtzt Standard-Arithmetik (`+`, `-`, `*`, `**`, `%`).
* Division rundet immer auf **ganze Zahl**.

```js
console.log(5n / 2n); // 2n
console.log(7n % 3n); // 1n
```

---

### 4. Einschr√§nkungen

* `BigInt` kann **nicht mit `Number` direkt gemischt** werden.

```js
const n = 10n;
// console.log(n + 5); // ‚ùå TypeError
console.log(n + 5n);  // ‚úÖ 15n
```

‚û° L√∂sung: explizite Umwandlung

```js
Number(10n) + 5; // 15
```

---

### 5. Vergleiche

* `==` erlaubt Vergleich mit `Number` (implizite Umwandlung).
* `===` verlangt gleichen Typ.

```js
console.log(10n == 10);  // true
console.log(10n === 10); // false
```

---

### 6. Einsatzgebiete

* Arbeit mit sehr gro√üen Zahlen (z. B. Kryptographie, Hashing, Finanzmathematik).
* Bessere Genauigkeit als `Number`, das bei gro√üen Werten Rundungsfehler bekommt.

```js
console.log(9999999999999999);   // 10000000000000000 (Ungenauigkeit!)
console.log(9999999999999999n);  // 9999999999999999n (korrekt)
```

---

**Zusammenfassung:**

* `BigInt` = primitiver Typ f√ºr **ganze Zahlen beliebiger Gr√∂√üe**.
* Erzeugung mit `n` oder `BigInt()`.
* Nur mit anderen `BigInt` sicher nutzbar (sonst explizite Konvertierung).
* Wichtig bei **gro√üen Ganzzahlen** ‚Üí keine Rundungsfehler wie bei `Number`.

üìñ Quelle: [MDN Web Docs ‚Äî BigInt](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/BigInt)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

55. ### <a name="55"></a> Module import/export (ES6) & CommonJS

**Module-Systeme in JavaScript: ES6 (ECMAScript Modules) vs. CommonJS**

---

### 1. ES6-Module (ECMAScript Modules, ESM)

* Standard seit **ES6 (2015)**.
* Verwenden `import` / `export`.
* Werden **statisch ausgewertet** ‚Üí Baum-Optimierung (Tree Shaking) m√∂glich.
* L√§uft nativ in modernen Browsern und Node.js (mit `"type": "module"` in `package.json`).

**Export**

```js
// math.js
export const add = (a, b) => a + b;
export default function multiply(a, b) {
  return a * b;
}
```

**Import**

```js
// app.js
import multiply, { add } from "./math.js";

console.log(add(2, 3));      // 5
console.log(multiply(2, 3)); // 6
```

---

### 2. CommonJS (CJS)

* √Ñlteres System, urspr√ºnglich f√ºr **Node.js**.
* Verwenden `require` / `module.exports`.
* Wird **dynamisch geladen** (zur Laufzeit).

**Export**

```js
// math.js
const add = (a, b) => a + b;
function multiply(a, b) {
  return a * b;
}

module.exports = { add, multiply };
```

**Import**

```js
// app.js
const { add, multiply } = require("./math");

console.log(add(2, 3));      // 5
console.log(multiply(2, 3)); // 6
```

---

### 3. Vergleich ESM vs. CJS

| Merkmal         | ES6-Module (ESM)               | CommonJS (CJS)                   |
| --------------- | ------------------------------ | -------------------------------- |
| Syntax          | `import` / `export`            | `require` / `module.exports`     |
| Auswertung      | statisch (compile-time)        | dynamisch (runtime)              |
| Tree Shaking    | m√∂glich                        | nicht m√∂glich                    |
| Unterst√ºtzung   | Browser + Node.js (modern)     | Node.js (√§lter, weit verbreitet) |
| Dateiendung     | `.mjs` oder `"type": "module"` | `.cjs` oder Standard `.js`       |
| `this` im Modul | `undefined`                    | `exports`                        |

---

### 4. Besondere Hinweise

* In **Node.js**:

  * Standard = CommonJS.
  * Mit `"type": "module"` in `package.json` ‚Üí ESM aktiv.
* Mischen ist m√∂glich, aber erfordert **Interop-Mechanismen** (`import()` oder `createRequire`).

---

**Zusammenfassung:**

* **ES6-Module (ESM)**: moderner Standard, statisch, mit `import`/`export`, unterst√ºtzt Tree Shaking.
* **CommonJS (CJS)**: √§lteres Node.js-System, dynamisch, mit `require`/`module.exports`.
* Heute: **Browser & moderne Node-Projekte ‚Üí ESM**, √§ltere Node-Umgebungen ‚Üí CommonJS.

üìñ Quelle:

* [MDN Web Docs ‚Äî import](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/import)
* [MDN Web Docs ‚Äî export](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/export)
* [Node.js Docs ‚Äî Modules: CommonJS](https://nodejs.org/docs/latest/api/modules.html)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

56. ### <a name="56"></a> Proxy und Reflect

**`Proxy` und `Reflect` in JavaScript**

---

### 1. `Proxy`

* `Proxy` = Objekt, das ein anderes Objekt **‚Äûumh√ºllt‚Äú** und dessen Zugriffe **abf√§ngt** (Traps).
* Erlaubt benutzerdefiniertes Verhalten f√ºr **Lesen, Schreiben, L√∂schen, Funktionsaufrufe** usw.

**Syntax**

```js
const proxy = new Proxy(target, handler);
```

* `target` ‚Üí das eigentliche Objekt
* `handler` ‚Üí Objekt mit ‚ÄûTraps‚Äú (Methoden, die Zugriffe abfangen)

**Beispiel: Lese-/Schreib-√úberwachung**

```js
const user = { name: "Sergii", age: 33 };

const proxy = new Proxy(user, {
  get(target, prop) {
    console.log(`Lese ${prop}`);
    return target[prop];
  },
  set(target, prop, value) {
    console.log(`Setze ${prop} = ${value}`);
    target[prop] = value;
    return true;
  }
});

proxy.name;      // Lese name
proxy.age = 34;  // Setze age = 34
```

---

### 2. `Reflect`

* Sammlung von Methoden zur Arbeit mit Objekten (√§hnlich wie `Object.*`).
* Wird oft innerhalb von Proxies genutzt, um Standardverhalten aufzurufen.

**Beispiel**

```js
const user = { name: "Sergii" };

console.log(Reflect.get(user, "name")); // "Sergii"
Reflect.set(user, "age", 33);
console.log(user.age); // 33
```

---

### 3. Proxy + Reflect zusammen

Typischerweise in Proxies: zuerst eigenes Verhalten, dann Weiterleitung an das Standardverhalten mit `Reflect`.

```js
const user = { name: "Sergii", age: 33 };

const proxy = new Proxy(user, {
  get(target, prop, receiver) {
    console.log(`GET ${prop}`);
    return Reflect.get(target, prop, receiver);
  },
  set(target, prop, value, receiver) {
    console.log(`SET ${prop} = ${value}`);
    return Reflect.set(target, prop, value, receiver);
  }
});

proxy.age;      // GET age
proxy.age = 40; // SET age = 40
```

---

### 4. Typische Anwendungsf√§lle

* **Validierung**: Eingaben √ºberpr√ºfen, bevor Werte gesetzt werden.
* **Property-Schutz**: Zugriff verbieten oder √§ndern.
* **Logging / Debugging**: Zugriffe auf Objekte √ºberwachen.
* **Virtualisierung**: Objekte dynamisch generieren.
* **Default-Werte**: Automatisch Werte zur√ºckgeben, wenn Property fehlt.

```js
const defaults = new Proxy({}, {
  get: (target, prop) => prop in target ? target[prop] : "N/A"
});

console.log(defaults.name); // "N/A"
```

---

### 5. Wichtige Reflect-Methoden

* `Reflect.get(obj, prop, receiver)`
* `Reflect.set(obj, prop, value, receiver)`
* `Reflect.has(obj, prop)` (wie `in`)
* `Reflect.deleteProperty(obj, prop)`
* `Reflect.ownKeys(obj)` (wie `Object.getOwnPropertyNames` + `Object.getOwnPropertySymbols`)
* `Reflect.construct(target, args)` (wie `new target(...args)`)
* `Reflect.apply(fn, thisArg, args)` (wie `fn.call(thisArg, ...args)`)

---

**Zusammenfassung:**

* **`Proxy`**: erlaubt das Abfangen und Anpassen von Objekt-Operationen.
* **`Reflect`**: Sammlung von Methoden, die Standard-Objektoperationen kapseln.
* Gemeinsam: `Proxy` √ºberschreibt Verhalten, `Reflect` f√ºhrt Standardaktionen aus.

üìñ Quelle:

* [MDN Web Docs ‚Äî Proxy](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Proxy)
* [MDN Web Docs ‚Äî Reflect](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Reflect)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

57. ### <a name="57"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

58. ### <a name="58"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

59. ### <a name="59"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

60. ### <a name="60"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

61. ### <a name="61"></a> Ereignisse und ihre Handler

**Ereignisse und ihre Handler in JavaScript**

---

### 1. Ereignisse

* Ereignisse = Signale, die im Browser bei bestimmten Aktionen ausgel√∂st werden:

  * Benutzeraktionen (**Klick, Eingabe, Tastendruck**)
  * Browser-Ereignisse (**Seite geladen, Fehler**)
* Jedes Ereignis hat ein **Event-Objekt** mit Infos (z. B. `event.type`, `event.target`).

---

### 2. Zuweisung von Event-Handlern

#### a) HTML-Attribut (veraltet, nicht empfohlen)

```html
<button onclick="alert('Hallo!')">Klick</button>
```

#### b) DOM-Property

```js
const btn = document.querySelector("button");
btn.onclick = function () {
  alert("Hallo!");
};
```

#### c) `addEventListener` (moderne Variante)

* Mehrere Handler m√∂glich
* Optionale Parameter (`capture`, `once`, `passive`)

```js
btn.addEventListener("click", () => {
  alert("Geklickt!");
});
```

---

### 3. Entfernen von Event-Handlern

```js
function handler() {
  console.log("Hi");
}
btn.addEventListener("click", handler);
btn.removeEventListener("click", handler);
```

---

### 4. Ereignisobjekt

Jeder Handler bekommt ein **Event-Objekt**:

```js
btn.addEventListener("click", (event) => {
  console.log(event.type);   // "click"
  console.log(event.target); // <button>
});
```

---

### 5. Ereignisfluss (Event Flow)

1. **Capturing**: Ereignis wandert von `window` ‚Üí Ziel-Element.
2. **Target**: Ereignis erreicht das Ziel.
3. **Bubbling**: Ereignis steigt wieder nach oben.

```js
document.body.addEventListener("click", () => {
  console.log("Body Bubbling");
});

document.body.addEventListener("click", () => {
  console.log("Body Capturing");
}, true); // Capturing
```

---

### 6. `event.stopPropagation()` und `event.preventDefault()`

* **stopPropagation()** ‚Üí verhindert Weitergabe (Bubbling/Capturing).
* **preventDefault()** ‚Üí verhindert Standardaktion (z. B. Link folgen).

```js
document.querySelector("a").addEventListener("click", (e) => {
  e.preventDefault(); // Link √∂ffnet sich nicht
  console.log("Link geklickt");
});
```

---

### 7. Event-Delegation (Best Practice)

Statt auf jedem Element Handler zu setzen ‚Üí auf Eltern-Element setzen und Bubbling nutzen.

```js
document.querySelector("ul").addEventListener("click", (e) => {
  if (e.target.tagName === "LI") {
    console.log("LI:", e.target.textContent);
  }
});
```

---

**Zusammenfassung:**

* Ereignisse = Reaktionen auf Aktionen (User/Browser).
* Handler k√∂nnen via **DOM-Property** oder besser **`addEventListener`** registriert werden.
* Event Flow: **Capturing ‚Üí Target ‚Üí Bubbling**.
* Steuerung via **`stopPropagation`** und **`preventDefault`**.
* **Event-Delegation** ist effizient f√ºr viele Elemente.

üìñ Quelle: [MDN Web Docs ‚Äî Einf√ºhrung in Ereignisse](https://developer.mozilla.org/ru/docs/Learn/JavaScript/Building_blocks/Events)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

62. ### <a name="62"></a> Ereignis-Bubbling (event bubbling)

**Ereignis-Bubbling (Event Bubbling) in JavaScript**

---

### 1. Definition

* Beim **Event-Bubbling** wandert ein Ereignis vom **Zielelement** (Target) nach oben durch die DOM-Hierarchie bis zum `document`.
* Standardverhalten in den meisten Browser-Events.

---

### 2. Beispiel

```html
<div id="parent">
  <button id="child">Klick mich</button>
</div>

<script>
document.getElementById("parent").addEventListener("click", () => {
  console.log("Parent DIV");
});

document.getElementById("child").addEventListener("click", () => {
  console.log("Button");
});
</script>
```

**Ausgabe bei Klick auf Button:**

```
Button
Parent DIV
```

---

### 3. Reihenfolge des Ereignisflusses

1. **Capturing Phase** (optional, wenn Handler mit `{ capture: true }`)
2. **Target Phase** (Ereignis erreicht Ziel-Element)
3. **Bubbling Phase** (Ereignis steigt nach oben)

---

### 4. Kontrolle des Bubblings

* **`event.stopPropagation()`** ‚Üí stoppt die Weitergabe.
* **`event.stopImmediatePropagation()`** ‚Üí stoppt zus√§tzlich alle weiteren Handler am gleichen Element.

```js
document.getElementById("child").addEventListener("click", (e) => {
  e.stopPropagation();
  console.log("Nur Button, kein Bubbling");
});
```

---

### 5. Praktischer Nutzen ‚Äì Event Delegation

Statt jedem Kind-Element einen eigenen Listener zu geben, setzt man den Listener auf das Elternelement und nutzt Bubbling:

```js
document.getElementById("parent").addEventListener("click", (e) => {
  if (e.target.tagName === "BUTTON") {
    console.log("Button wurde geklickt:", e.target.textContent);
  }
});
```

---

**Zusammenfassung:**

* **Event-Bubbling** = Ereignis wandert vom Ziel-Element nach oben durch die DOM-Hierarchie.
* Standard in JavaScript-Ereignissen.
* Steuerung √ºber **`stopPropagation()`** und **`stopImmediatePropagation()`**.
* Vorteil: **Event Delegation** f√ºr effizientere Event-Listener.

üìñ Quelle: [MDN Web Docs ‚Äî Event bubbling](https://developer.mozilla.org/ru/docs/Learn/JavaScript/Building_blocks/Events#bubbling_and_capture)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

63. ### <a name="63"></a> Ereignis-Delegation

**Ereignis-Delegation in JavaScript**

---

### 1. Definition

* **Event-Delegation** = Technik, bei der ein **einziger Event-Listener** auf einem **Elternelement** sitzt und Ereignisse von **Kind-Elementen** √ºber **Event-Bubbling** behandelt.
* Spart Ressourcen und macht Code wartbarer.

---

### 2. Beispiel ohne Delegation (ineffizient)

```js
const items = document.querySelectorAll("li");

items.forEach(item => {
  item.addEventListener("click", () => {
    console.log("Geklickt:", item.textContent);
  });
});
```

‚û° Viele Listener, h√∂herer Speicherverbrauch.

---

### 3. Beispiel mit Delegation (Best Practice)

```html
<ul id="list">
  <li>Apfel</li>
  <li>Banane</li>
  <li>Orange</li>
</ul>

<script>
document.getElementById("list").addEventListener("click", (event) => {
  if (event.target.tagName === "LI") {
    console.log("Geklickt:", event.target.textContent);
  }
});
</script>
```

* Listener sitzt auf `<ul>`.
* Klicks auf `<li>` werden √ºber **`event.target`** erkannt.

---

### 4. Vorteile

* Weniger Speicherverbrauch (nur **1 Listener**).
* Funktioniert auch f√ºr **dynamisch hinzugef√ºgte Elemente**.
* Saubererer Code.

---

### 5. Besonderheiten

* Pr√ºfen mit `event.target`, ob das richtige Kindelement getroffen wurde.
* Falls n√∂tig: `event.currentTarget` (zeigt auf das Element, wo der Listener gesetzt wurde).
* In verschachtelten Strukturen ggf. `stopPropagation()`, um Konflikte zu vermeiden.

---

**Zusammenfassung:**

* **Ereignis-Delegation** nutzt Bubbling: Ein Eltern-Listener f√§ngt Events von Kind-Elementen ab.
* Vorteile: **effizient**, **skalierbar**, **auch f√ºr dynamische Inhalte** geeignet.
* Schl√ºssel: **`event.target` pr√ºfen**.

üìñ Quelle: [MDN Web Docs ‚Äî Einf√ºhrung in Ereignisse](https://developer.mozilla.org/ru/docs/Learn/JavaScript/Building_blocks/Events#event_delegation)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

64. ### <a name="64"></a> Unterschied zwischen load und DOMContentLoaded

**Unterschied zwischen `load` und `DOMContentLoaded` in JavaScript**

---

### 1. `DOMContentLoaded`

* Wird ausgel√∂st, wenn das **HTML-Dokument vollst√§ndig geladen und geparst** ist.
* **Externe Ressourcen** (Bilder, Stylesheets, iframes) m√ºssen noch **nicht** fertig geladen sein.
* Typisch f√ºr Initialisierung von Skripten, die nur die DOM-Struktur brauchen.

```js
document.addEventListener("DOMContentLoaded", () => {
  console.log("DOM ist bereit!");
});
```

---

### 2. `load`

* Wird ausgel√∂st, wenn die gesamte Seite inkl. **aller Ressourcen** (Bilder, CSS, Skripte, Fonts, iframes) vollst√§ndig geladen ist.
* Tritt sp√§ter als `DOMContentLoaded` auf.

```js
window.addEventListener("load", () => {
  console.log("Alles geladen (inkl. Bilder, CSS)");
});
```

---

### 3. Vergleich

| Ereignis           | Ausgel√∂st, wenn ‚Ä¶                | Zeitpunkt |
| ------------------ | -------------------------------- | --------- |
| `DOMContentLoaded` | DOM fertig geparst               | fr√ºh      |
| `load`             | alle Ressourcen komplett geladen | sp√§t      |

---

### 4. Praxisbeispiel

```js
document.addEventListener("DOMContentLoaded", () => {
  // DOM-Elemente existieren ‚Üí Manipulation m√∂glich
  const btn = document.querySelector("button");
  btn.textContent = "Bereit!";
});

window.addEventListener("load", () => {
  // Alles ist geladen ‚Üí z. B. Bildgr√∂√üen sicher verf√ºgbar
  console.log("Seite komplett geladen");
});
```

---

**Zusammenfassung:**

* **`DOMContentLoaded`**: ausgel√∂st, wenn **DOM bereit** ist (ohne externe Ressourcen).
* **`load`**: ausgel√∂st, wenn **alle Ressourcen** (inkl. Bilder, CSS, Fonts) fertig sind.
* Empfehlung: F√ºr **DOM-Manipulation** ‚Üí `DOMContentLoaded`; f√ºr **Ressourcenabh√§ngigkeiten** (z. B. Bildgr√∂√üen) ‚Üí `load`.

üìñ Quelle: [MDN Web Docs ‚Äî Document: DOMContentLoaded event](https://developer.mozilla.org/ru/docs/Web/API/Document/DOMContentLoaded_event), [MDN Web Docs ‚Äî Window: load event](https://developer.mozilla.org/ru/docs/Web/API/Window/load_event)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

65. ### <a name="65"></a> Elemente von der Seite abrufen

**Elemente von der Seite abrufen (DOM-Selektion in JavaScript)**

---

### 1. Klassische Methoden

#### a) `getElementById`

* Selektiert **ein einzelnes Element** mit bestimmter `id`.

```js
const title = document.getElementById("main-title");
```

#### b) `getElementsByClassName`

* Gibt eine **Live HTMLCollection** zur√ºck.

```js
const items = document.getElementsByClassName("item");
```

#### c) `getElementsByTagName`

* Selektiert nach Tag-Namen, ebenfalls **Live HTMLCollection**.

```js
const divs = document.getElementsByTagName("div");
```

---

### 2. Moderne Methoden (empfohlen)

#### a) `querySelector`

* Selektiert **erstes Element**, das mit dem CSS-Selektor √ºbereinstimmt.

```js
const firstItem = document.querySelector(".item");
```

#### b) `querySelectorAll`

* Selektiert **alle passenden Elemente** als **statische NodeList**.

```js
const allItems = document.querySelectorAll(".item");
allItems.forEach(el => console.log(el.textContent));
```

---

### 3. Unterschied **Live vs. Statisch**

```js
const live = document.getElementsByClassName("item"); // Live
const staticList = document.querySelectorAll(".item"); // Statisch

const newItem = document.createElement("li");
newItem.className = "item";
document.body.appendChild(newItem);

console.log(live.length);      // automatisch +1
console.log(staticList.length); // unver√§ndert
```

---

### 4. Zugriff auf spezielle Sammlungen

* `document.forms` ‚Üí alle Formulare
* `document.images` ‚Üí alle `<img>`
* `document.links` ‚Üí alle `<a href>`

---

### 5. Beispiel

```html
<ul>
  <li class="item">Apfel</li>
  <li class="item">Banane</li>
</ul>

<script>
const ul = document.querySelector("ul");      // erstes <ul>
const items = document.querySelectorAll(".item"); // alle <li class="item">
items.forEach(li => console.log(li.textContent));
</script>
```

---

**Zusammenfassung:**

* **Klassische Methoden**: `getElementById`, `getElementsByClassName`, `getElementsByTagName` (Live Collections).
* **Moderne Methoden**: `querySelector`, `querySelectorAll` (CSS-Selektoren, statisch).
* Praxis: **`querySelector`/`querySelectorAll` bevorzugen** f√ºr Flexibilit√§t und √úbersicht.

üìñ Quelle: [MDN Web Docs ‚Äî Element selectors](https://developer.mozilla.org/ru/docs/Web/API/Document/querySelector)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

66. ### <a name="66"></a> Methoden zum Abrufen von DOM-Elementen in JavaScript

**Methoden zum Abrufen von DOM-Elementen in JavaScript**

---

### 1. Klassische Methoden

| Methode                                  | R√ºckgabe          | Typ              | Dynamik  | Beispiel                                  |
| ---------------------------------------- | ----------------- | ---------------- | -------- | ----------------------------------------- |
| `document.getElementById(id)`            | einzelnes Element | `Element`        | statisch | `document.getElementById("header")`       |
| `document.getElementsByClassName(class)` | mehrere           | `HTMLCollection` | **Live** | `document.getElementsByClassName("item")` |
| `document.getElementsByTagName(tag)`     | mehrere           | `HTMLCollection` | **Live** | `document.getElementsByTagName("div")`    |
| `document.getElementsByName(name)`       | mehrere           | `NodeList`       | **Live** | `document.getElementsByName("username")`  |

---

### 2. Moderne Methoden (empfohlen)

| Methode                          | R√ºckgabe                 | Typ                   | Dynamik      | Beispiel                               |
| -------------------------------- | ------------------------ | --------------------- | ------------ | -------------------------------------- |
| `document.querySelector(css)`    | erstes passendes Element | `Element` oder `null` | statisch     | `document.querySelector(".item")`      |
| `document.querySelectorAll(css)` | alle passenden           | `NodeList`            | **statisch** | `document.querySelectorAll("ul > li")` |

‚û° Vorteil: volle Unterst√ºtzung von **CSS-Selektoren**.

---

### 3. Zugriff auf spezielle Sammlungen

| Zugriff            | Beschreibung    | Typ              |
| ------------------ | --------------- | ---------------- |
| `document.forms`   | alle Formulare  | `HTMLCollection` |
| `document.images`  | alle `<img>`    | `HTMLCollection` |
| `document.links`   | alle `<a href>` | `HTMLCollection` |
| `document.scripts` | alle `<script>` | `HTMLCollection` |

---

### 4. Live vs. Statische Sammlungen

* **Live** (`getElementsBy*`): aktualisieren sich automatisch bei DOM-√Ñnderungen.
* **Statisch** (`querySelectorAll`): bleiben unver√§ndert.

```js
const live = document.getElementsByClassName("item");   // Live
const staticList = document.querySelectorAll(".item");  // Statisch

const newEl = document.createElement("li");
newEl.className = "item";
document.body.appendChild(newEl);

console.log(live.length);      // aktualisiert
console.log(staticList.length); // bleibt gleich
```

---

**Zusammenfassung:**

* **Klassisch**: `getElementById`, `getElementsByClassName`, `getElementsByTagName`, `getElementsByName`.
* **Modern**: `querySelector`, `querySelectorAll` (flexibler, statisch).
* **Spezial-Sammlungen**: `document.forms`, `document.images` etc.
* Empfehlung: F√ºr neue Projekte **`querySelector`/`querySelectorAll`** verwenden.

üìñ Quelle: [MDN Web Docs ‚Äî Document API](https://developer.mozilla.org/ru/docs/Web/API/Document)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

67. ### <a name="67"></a> Navigation durch DOM-Elemente

**Navigation durch DOM-Elemente in JavaScript**

---

### 1. Grundprinzip

Das DOM bildet eine **Baumstruktur**.
Man kann von einem Element zu **Eltern-, Kinder- und Geschwisterknoten** navigieren.

---

### 2. Eltern-Element

* `element.parentNode` ‚Üí n√§chster Elternknoten (kann auch `#text` sein).
* `element.parentElement` ‚Üí garantiert ein **Element**, sonst `null`.

```js
const el = document.querySelector(".item");
console.log(el.parentElement); // <ul> ‚Ä¶
```

---

### 3. Kinder-Elemente

* `element.childNodes` ‚Üí **alle Kindknoten** (inkl. Text, Kommentare).
* `element.children` ‚Üí nur **Element-Kinder**.
* `element.firstChild` / `element.lastChild` ‚Üí erstes/letztes Kind (inkl. Text).
* `element.firstElementChild` / `element.lastElementChild` ‚Üí nur Elemente.

```js
const list = document.querySelector("ul");
console.log(list.children);           // HTMLCollection (nur <li>)
console.log(list.firstElementChild);  // erstes <li>
```

---

### 4. Geschwister-Elemente

* `element.previousSibling` / `element.nextSibling` ‚Üí inkl. Textknoten.
* `element.previousElementSibling` / `element.nextElementSibling` ‚Üí nur Elemente.

```js
const item = document.querySelector("li.item");
console.log(item.nextElementSibling); // n√§chstes <li>
```

---

### 5. Wichtige Eigenschaften

* `element.closest(selector)` ‚Üí findet das n√§chste Eltern-Element, das Selektor erf√ºllt.

```js
const li = document.querySelector("li");
console.log(li.closest("ul")); // <ul>‚Ä¶
```

* `element.matches(selector)` ‚Üí pr√ºft, ob Element Selektor erf√ºllt.

```js
if (li.matches(".item")) {
  console.log("LI ist .item");
}
```

---

### 6. Visualisierung

```
parentElement
   ‚îî‚îÄ‚îÄ children
         ‚îú‚îÄ‚îÄ firstElementChild
         ‚îú‚îÄ‚îÄ nextElementSibling
         ‚îî‚îÄ‚îÄ lastElementChild
```

---

**Zusammenfassung:**

* Navigation: **Eltern (`parentElement`)**, **Kinder (`children`)**, **Geschwister (`nextElementSibling`)**.
* **childNodes**/`firstChild` ‚Üí inkl. Textknoten,
  **children**/`firstElementChild` ‚Üí nur Elemente.
* Praktisch: **`closest()`** (Suche nach oben), **`matches()`** (pr√ºfen).

üìñ Quelle: [MDN Web Docs ‚Äî Traversing the DOM](https://developer.mozilla.org/ru/docs/Web/API/Document_Object_Model/Traversing_an_HTML_table_with_JavaScript_and_DOM_Interfaces)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

68. ### <a name="68"></a> classList, className und Ereignisdelegation

**`classList`, `className` und Ereignis-Delegation in JavaScript**

---

## 1. `className`

* Zugriff/√Ñnderung auf den gesamten Klassen-String eines Elements.
* √úberschreibt alle Klassen, wenn direkt zugewiesen.

```js
const el = document.querySelector("#box");

console.log(el.className); // "red big"
el.className = "blue";     // ersetzt alle Klassen
```

‚û° **Nachteil:** unflexibel, weil alles √ºberschrieben wird.

---

## 2. `classList` (moderne Variante)

* Bequeme API f√ºr das Arbeiten mit **einzelnen Klassen**.

Methoden:

* `el.classList.add("name")`
* `el.classList.remove("name")`
* `el.classList.toggle("name")`
* `el.classList.contains("name")`

```js
const el = document.querySelector("#box");

el.classList.add("active");     
el.classList.remove("red");     
el.classList.toggle("hidden");  
console.log(el.classList.contains("active")); // true
```

‚û° Vorteil: granular, √ºberschreibt nicht den kompletten Klassen-String.

---

## 3. Ereignis-Delegation + classList-Beispiel

Mit **Event Delegation** l√§sst sich dynamisch auf Klassen√§nderungen reagieren:

```html
<ul id="list">
  <li class="item">Apfel</li>
  <li class="item">Banane</li>
  <li class="item">Orange</li>
</ul>

<script>
document.getElementById("list").addEventListener("click", (event) => {
  if (event.target.classList.contains("item")) {
    event.target.classList.toggle("selected");
  }
});
</script>
```

* Nur **ein Listener** auf `<ul>`.
* Klick auf `<li>` ‚Üí per **`classList.toggle()`** Klasse √§ndern.
* Funktioniert auch f√ºr dynamisch hinzugef√ºgte `<li>`.

---

## 4. Vergleich

| Merkmal       | `className`                  | `classList`                |
| ------------- | ---------------------------- | -------------------------- |
| Typ           | String                       | DOMTokenList (Methoden)    |
| Zugriff       | Alle Klassen auf einmal      | Einzelne Klassen steuerbar |
| Risiko        | √úberschreibt komplette Liste | Nur gezielte √Ñnderung      |
| Best Practice | ‚ùå alt                        | ‚úÖ modern                   |

---

**Zusammenfassung:**

* **`className`** ‚Üí Zugriff auf gesamten Klassennamen (String, unflexibel).
* **`classList`** ‚Üí moderne API f√ºr einzelne Klassen (`add`, `remove`, `toggle`, `contains`).
* In Kombination mit **Event Delegation** ‚Üí effiziente Steuerung von CSS-Klassen bei vielen Elementen.

üìñ Quelle:

* [MDN Web Docs ‚Äî Element.classList](https://developer.mozilla.org/ru/docs/Web/API/Element/classList)
* [MDN Web Docs ‚Äî Element.className](https://developer.mozilla.org/ru/docs/Web/API/Element/className)
* [MDN Web Docs ‚Äî Event delegation](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#event_delegation)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

69. ### <a name="69"></a> Manipulation von Seitenelementen

**Manipulation von Seitenelementen (DOM-Manipulation) in JavaScript**

---

### 1. Inhalt √§ndern

* **`innerHTML`** ‚Üí HTML-Inhalt als String setzen oder lesen.

```js
document.querySelector("#box").innerHTML = "<b>Hallo</b>";
```

* **`textContent`** ‚Üí nur Text (sicher gegen XSS).

```js
document.querySelector("#box").textContent = "Nur Text";
```

---

### 2. Attribute √§ndern

* **`getAttribute(name)` / `setAttribute(name, value)`**

```js
const img = document.querySelector("img");
img.setAttribute("alt", "Bildbeschreibung");
console.log(img.getAttribute("src"));
```

* Direkter Zugriff m√∂glich:

```js
img.src = "bild.png";
```

---

### 3. CSS-Klassen √§ndern

* Mit `className` (gesamter String) oder besser mit `classList`:

```js
const el = document.querySelector("#box");
el.classList.add("highlight");
el.classList.remove("hidden");
el.classList.toggle("active");
```

---

### 4. Inline-Stile √§ndern

```js
el.style.color = "red";
el.style.backgroundColor = "yellow";
```

Oder via CSS-Klasse: **Best Practice** ‚Üí weniger Inline-Styles.

---

### 5. Elemente erstellen & einf√ºgen

* **`document.createElement(tag)`**
* **`append`, `prepend`, `before`, `after`, `replaceWith`, `remove`**

```js
const newDiv = document.createElement("div");
newDiv.textContent = "Neues Element";
document.body.append(newDiv);
```

```js
const ul = document.querySelector("ul");
const li = document.createElement("li");
li.textContent = "Neuer Punkt";
ul.appendChild(li);
```

---

### 6. Entfernen

```js
li.remove(); // modernes API
// oder: ul.removeChild(li);
```

---

### 7. Zusammenfassung der g√§ngigsten Methoden

| Aktion             | Methode/Property                       |
| ------------------ | -------------------------------------- |
| Inhalt √§ndern      | `innerHTML`, `textContent`             |
| Attribute √§ndern   | `getAttribute`, `setAttribute`         |
| Klassen √§ndern     | `classList.add/remove/toggle`          |
| Stile √§ndern       | `element.style`                        |
| Elemente erstellen | `document.createElement`               |
| Elemente einf√ºgen  | `append`, `prepend`, `before`, `after` |
| Elemente entfernen | `remove()`, `removeChild()`            |

---

**Zusammenfassung:**

* DOM-Manipulation umfasst **Inhalt, Attribute, Klassen, Styles, Struktur**.
* Moderne Methoden wie **`append`, `remove`, `classList`** sind vorzuziehen.
* **Best Practice**: so wenig wie m√∂glich direkte Inline-Styles ‚Üí besser CSS-Klassen verwenden.

üìñ Quelle: [MDN Web Docs ‚Äî DOM manipulation](https://developer.mozilla.org/ru/docs/Web/API/Document_Object_Model/Introduction#dom_manipulation)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

70. ### <a name="70"></a> Dokument- und Fensterparameter sowie deren Nutzung

**Dokument- und Fensterparameter sowie deren Nutzung in JavaScript**

---

## 1. `document` (repr√§sentiert die aktuelle HTML-Seite)

### Wichtige Eigenschaften

* **`document.documentElement`** ‚Üí `<html>`-Element
* **`document.head`** ‚Üí `<head>`-Element
* **`document.body`** ‚Üí `<body>`-Element
* **`document.title`** ‚Üí Seitentitel √§ndern/lesen
* **`document.URL`** ‚Üí aktuelle URL
* **`document.cookie`** ‚Üí Zugriff auf Cookies
* **`document.referrer`** ‚Üí URL der vorherigen Seite

```js
console.log(document.title);   // liest Titel
document.title = "Neue Seite"; // setzt Titel
```

### Wichtige Methoden

* **`document.getElementById(id)`** ‚Üí einzelnes Element
* **`document.querySelector(sel)`** / `querySelectorAll(sel)` ‚Üí Selektoren
* **`document.createElement(tag)`** ‚Üí neues DOM-Element

---

## 2. `window` (repr√§sentiert das Browser-Fenster/Umgebung)

### Wichtige Eigenschaften

* **`window.innerWidth` / `window.innerHeight`** ‚Üí sichtbarer Bereich (Viewport)
* **`window.outerWidth` / `window.outerHeight`** ‚Üí gesamte Fenstergr√∂√üe inkl. Toolbar
* **`window.scrollX` / `window.scrollY`** ‚Üí Scroll-Position
* **`window.location`** ‚Üí Objekt mit URL-Infos (z. B. `href`, `hostname`, `pathname`)
* **`window.navigator`** ‚Üí Infos √ºber Browser/OS
* **`window.history`** ‚Üí Browser-History steuern

```js
console.log(window.innerWidth, window.innerHeight); 
console.log(window.location.href); // aktuelle URL
```

### Wichtige Methoden

* **`window.alert(msg)`**, `prompt()`, `confirm()` ‚Üí Benutzerinteraktion
* **`window.open(url)`** ‚Üí neues Tab/Fenster
* **`window.scrollTo(x, y)`** ‚Üí zu Position scrollen
* **`window.setTimeout(fn, ms)`** / `setInterval(fn, ms)` ‚Üí Timer

```js
setTimeout(() => alert("Hallo!"), 2000);
```

---

## 3. Unterschiede in der Nutzung

| Objekt     | Bedeutung                                        | Beispiel                                  |
| ---------- | ------------------------------------------------ | ----------------------------------------- |
| `document` | Repr√§sentiert die **Seite**                      | `document.body.style.background = "red";` |
| `window`   | Repr√§sentiert das **Browser-Fenster** & Umgebung | `window.innerWidth`                       |

* `document` = **Inhalt** (DOM-Struktur)
* `window` = **Rahmen** (Browser, Viewport, APIs)

---

**Zusammenfassung:**

* `document`: Zugriff auf DOM, Struktur, Inhalte (`body`, `title`, Selektoren, Erstellung von Elementen).
* `window`: Zugriff auf Browser-Parameter, Gr√∂√üe, Scroll-Position, History, Timer, Location.
* **Best Practice**: `document` = Inhalt manipulieren, `window` = Umgebung kontrollieren.

üìñ Quelle:

* [MDN Web Docs ‚Äî Document](https://developer.mozilla.org/ru/docs/Web/API/Document)
* [MDN Web Docs ‚Äî Window](https://developer.mozilla.org/ru/docs/Web/API/Window)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

71. ### <a name="71"></a> Web Animations API

**Web Animations API (WAAPI) in JavaScript**

---

## 1. Definition

* **Web Animations API** = moderne API zur Steuerung von **CSS-√§hnlichen Animationen** direkt mit JavaScript.
* Vorteil: pr√§zise Kontrolle (Start, Stop, Geschwindigkeit, Pausen, Keyframes).
* Alternative zu **CSS-Animationen** oder **setInterval**.

---

## 2. Syntax: `element.animate()`

```js
const box = document.querySelector(".box");

const animation = box.animate(
  [
    { transform: "translateX(0px)", opacity: 1 },   // Start-Keyframe
    { transform: "translateX(200px)", opacity: 0 }  // End-Keyframe
  ],
  {
    duration: 1000,   // Dauer in ms
    iterations: 2,    // Anzahl Wiederholungen
    direction: "alternate", // hin und zur√ºck
    easing: "ease-in-out"   // Timing-Funktion
  }
);
```

---

## 3. Steuerung mit Animation-Objekt

`animate()` gibt ein **`Animation`-Objekt** zur√ºck.

```js
animation.pause();       // pausieren
animation.play();        // fortsetzen
animation.reverse();     // umkehren
animation.finish();      // sofort beenden
animation.cancel();      // abbrechen
```

Eigenschaften:

* `animation.playbackRate` ‚Üí Geschwindigkeit √§ndern (`2` = doppelt so schnell).
* `animation.currentTime` ‚Üí aktuelle Zeit setzen/lesen.
* `animation.finished` ‚Üí Promise, das nach Ende aufgel√∂st wird.

---

## 4. Keyframes mit `KeyframeEffect` und `Animation` (erweitert)

```js
const box = document.querySelector(".box");

const keyframes = new KeyframeEffect(
  box,
  [
    { transform: "scale(1)" },
    { transform: "scale(1.5)" }
  ],
  { duration: 1000, iterations: Infinity }
);

const anim = new Animation(keyframes, document.timeline);
anim.play();
```

---

## 5. Vergleich zu CSS-Animationen

| Merkmal     | CSS-Animation                     | Web Animations API                       |
| ----------- | --------------------------------- | ---------------------------------------- |
| Definition  | CSS (`@keyframes`)                | JS (`element.animate`)                   |
| Kontrolle   | begrenzt (`animation-play-state`) | voll: `pause`, `reverse`, `playbackRate` |
| Dynamik     | nur vordefiniert                  | dynamische Keyframes m√∂glich             |
| Performance | native, GPU-optimiert             | ebenso, da gleiche Engine                |

---

## 6. Praxisbeispiel: Button-Klick animiert Box

```js
document.querySelector("button").addEventListener("click", () => {
  document.querySelector(".box").animate(
    [
      { transform: "rotate(0deg)" },
      { transform: "rotate(360deg)" }
    ],
    { duration: 1000, iterations: 1 }
  );
});
```

---

**Zusammenfassung:**

* **Web Animations API**: native JS-API f√ºr Keyframe-Animationen.
* Methode: `element.animate(keyframes, options)` ‚Üí liefert `Animation`-Objekt.
* Vorteile: volle **Kontrolle** (play, pause, reverse, cancel, Geschwindigkeit).
* Moderne Alternative/Erg√§nzung zu CSS-Animationen.

üìñ Quelle: [MDN Web Docs ‚Äî Web Animations API](https://developer.mozilla.org/ru/docs/Web/API/Web_Animations_API)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

72. ### <a name="72"></a> requestAnimationFrame

**`requestAnimationFrame` in JavaScript**

---

## 1. Definition

* **`requestAnimationFrame(callback)`** plant die Ausf√ºhrung einer Funktion, bevor der Browser den **n√§chsten Repaint** macht (ca. 60 FPS).
* Alternative zu `setInterval`/`setTimeout`, aber **fl√ºssiger und effizienter**, da Browser die Wiederholrate optimiert.

---

## 2. Einfaches Beispiel

```js
function step(timestamp) {
  console.log("Frame bei:", timestamp);
  requestAnimationFrame(step);
}

requestAnimationFrame(step);
```

* `timestamp` = Zeitstempel (ms), wann der Frame gestartet wurde.

---

## 3. Animation-Beispiel (Bewegung)

```js
const box = document.querySelector(".box");
let start = null;

function animate(time) {
  if (!start) start = time;
  const progress = time - start;

  box.style.transform = `translateX(${progress / 10}px)`;

  if (progress < 2000) { // l√§uft 2s
    requestAnimationFrame(animate);
  }
}

requestAnimationFrame(animate);
```

---

## 4. Abbrechen

* Mit `cancelAnimationFrame(id)` m√∂glich.

```js
let id = requestAnimationFrame(step);
cancelAnimationFrame(id);
```

---

## 5. Vorteile gegen√ºber `setInterval`

| Merkmal             | `setInterval` / `setTimeout` | `requestAnimationFrame`  |
| ------------------- | ---------------------------- | ------------------------ |
| Timing              | fix (ms)                     | synchron zum Repaint     |
| Performance         | kann Frames √ºberspringen     | optimiert f√ºr FPS        |
| Energieverbrauch    | h√∂her                        | effizienter              |
| Visibility Handling | l√§uft auch im Hintergrund    | pausiert bei Tab-Wechsel |

---

## 6. Praxis: Animation mit Steuerung

```js
let running = true;
function move(time) {
  if (!running) return;
  box.style.left = (time / 10) % 500 + "px";
  requestAnimationFrame(move);
}

requestAnimationFrame(move);

// Pause mit Button
document.querySelector("button").addEventListener("click", () => {
  running = !running;
  if (running) requestAnimationFrame(move);
});
```

---

**Zusammenfassung:**

* **`requestAnimationFrame`** ‚Üí API f√ºr fl√ºssige, performante Animationen.
* F√ºhrt Callback **vor n√§chstem Repaint** aus.
* Besser als `setInterval`: synchronisiert mit Bildschirm-Refresh, energieeffizient, pausiert bei Tab-Wechsel.
* Steuerung: `requestAnimationFrame` + `cancelAnimationFrame`.

üìñ Quelle: [MDN Web Docs ‚Äî requestAnimationFrame](https://developer.mozilla.org/ru/docs/Web/API/window/requestAnimationFrame)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

73. ### <a name="73"></a> Debouncing und Throttling

**Debouncing und Throttling in JavaScript**

---

## 1. Debouncing

* **Definition:** F√ºhrt eine Funktion erst aus, **wenn nach dem letzten Aufruf eine bestimmte Zeit vergangen ist**.
* Typisch f√ºr: **Eingaben, Resize-Events, Autocomplete**.

```js
function debounce(fn, delay) {
  let timer;
  return function (...args) {
    clearTimeout(timer);
    timer = setTimeout(() => fn.apply(this, args), delay);
  };
}

// Beispiel: Eingabefeld
const search = document.querySelector("#search");
search.addEventListener("input", debounce((e) => {
  console.log("Suche nach:", e.target.value);
}, 500));
```

‚û° Funktion startet **erst nach 500ms Pause**.

---

## 2. Throttling

* **Definition:** F√ºhrt eine Funktion h√∂chstens **einmal pro definiertem Zeitintervall** aus, auch wenn sie h√§ufiger aufgerufen wird.
* Typisch f√ºr: **Scroll-Events, Mausbewegungen, Fenster-Resize**.

```js
function throttle(fn, limit) {
  let waiting = false;
  return function (...args) {
    if (!waiting) {
      fn.apply(this, args);
      waiting = true;
      setTimeout(() => (waiting = false), limit);
    }
  };
}

// Beispiel: Scroll
window.addEventListener("scroll", throttle(() => {
  console.log("Scroll-Ereignis:", window.scrollY);
}, 1000));
```

‚û° Funktion l√§uft **h√∂chstens alle 1000ms**.

---

## 3. Vergleich

| Merkmal        | Debouncing                              | Throttling                                |
| -------------- | --------------------------------------- | ----------------------------------------- |
| Verhalten      | wartet bis ‚ÄûRuhe‚Äú herrscht              | begrenzt Ausf√ºhrungen auf festen Rhythmus |
| Typische F√§lle | Eingabevalidierung, Autocomplete, Suche | Scroll, Resize, Mausbewegung              |
| Beispiel       | Autocomplete nach Tipp-Pause            | Scroll-Handler max. 1x pro Sekunde        |

---

## 4. Visualisierung

* **Debounce:** Ausf√ºhrung nur **einmal nach letzter Aktion**.
* **Throttle:** Ausf√ºhrung in **regelm√§√üigen Abst√§nden**, solange Ereignisse auftreten.

---

**Zusammenfassung:**

* **Debouncing** = Funktion wird nach letzter Aktion mit Verz√∂gerung ausgef√ºhrt.
* **Throttling** = Funktion wird in festen Intervallen ausgef√ºhrt.
* Beide optimieren Performance bei h√§ufigen Events.

üìñ Quelle:

* [MDN Web Docs ‚Äî Event throttling and debouncing](https://developer.mozilla.org/ru/docs/Web/API/Document/scroll_event#throttling_the_scroll_event_handler)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

74. ### <a name="74"></a> IntersectionObserver API

**IntersectionObserver API in JavaScript**

---

## 1. Definition

* Die **IntersectionObserver API** erlaubt es, **sichtbare Ver√§nderungen** eines Elements im **Viewport** oder in einem √ºbergeordneten Container zu beobachten.
* H√§ufig genutzt f√ºr **Lazy Loading, Infinite Scroll, Sichtbarkeits-Tracking (Analytics, Animationen)**.

---

## 2. Grundprinzip

```js
const observer = new IntersectionObserver((entries, observer) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      console.log("Element sichtbar:", entry.target);
    }
  });
}, {
  root: null,          // Container (null = Viewport)
  rootMargin: "0px",   // Rand (z. B. "100px" Vorlauf)
  threshold: 0.5       // Anteil Sichtbarkeit (0‚Äì1)
});

const box = document.querySelector(".box");
observer.observe(box);
```

---

## 3. Wichtige Optionen

* **`root`** ‚Üí Container-Element, das Sichtbarkeit bestimmt (`null` = Browser-Viewport).
* **`rootMargin`** ‚Üí zus√§tzliche R√§nder f√ºr Trigger (z. B. `"0px 0px -100px 0px"`).
* **`threshold`** ‚Üí Prozentanteil, wann das Event ausgel√∂st wird:

  * `0` ‚Üí sobald 1 Pixel sichtbar ist.
  * `1.0` ‚Üí erst, wenn komplett sichtbar.
  * `[0, 0.5, 1]` ‚Üí mehrere Schwellen.

---

## 4. Methoden

* `observer.observe(element)` ‚Üí Beobachtung starten.
* `observer.unobserve(element)` ‚Üí Beobachtung f√ºr Element stoppen.
* `observer.disconnect()` ‚Üí komplett stoppen.

---

## 5. Beispiel: Lazy Loading von Bildern

```js
const images = document.querySelectorAll("img[data-src]");

const imgObserver = new IntersectionObserver((entries, obs) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      const img = entry.target;
      img.src = img.dataset.src;
      obs.unobserve(img); // nur einmal laden
    }
  });
});

images.forEach(img => imgObserver.observe(img));
```

---

## 6. Vorteile gegen√ºber `scroll`-Events

* **Performant**: Browser entscheidet optimal, wann Callbacks aufgerufen werden.
* Kein manuelles `throttle` oder `debounce` n√∂tig.
* Einfacher zu warten.

---

**Zusammenfassung:**

* **IntersectionObserver API** √ºberwacht Sichtbarkeit von Elementen.
* Optionen: `root`, `rootMargin`, `threshold`.
* Methoden: `observe`, `unobserve`, `disconnect`.
* Typische Use-Cases: **Lazy Loading, Infinite Scroll, Animationen bei Sichtbarkeit, Tracking**.

üìñ Quelle: [MDN Web Docs ‚Äî IntersectionObserver](https://developer.mozilla.org/ru/docs/Web/API/Intersection_Observer_API)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

75. ### <a name="75"></a> Unterschied zwischen innerHTML, textContent und innerText

**Unterschied zwischen `innerHTML`, `textContent` und `innerText` in JavaScript**

---

## 1. `innerHTML`

* Liest oder setzt den **HTML-Inhalt** eines Elements.
* Enth√§lt **Tags + Text**.
* Kann neue HTML-Struktur einf√ºgen ‚Üí ‚ö†Ô∏è XSS-Risiko bei unkontrollierten Daten.

```js
const div = document.querySelector("#box");
div.innerHTML = "<b>Hallo</b>";
console.log(div.innerHTML); // "<b>Hallo</b>"
```

---

## 2. `textContent`

* Liest oder setzt **nur den Text** (ohne HTML).
* Gibt den **gesamten Text** zur√ºck (inkl. unsichtbare Inhalte, z. B. `display: none`).
* Sicherer als `innerHTML` f√ºr Nutzereingaben.

```js
div.textContent = "<b>Hallo</b>";
console.log(div.textContent); // "<b>Hallo</b>"
```

---

## 3. `innerText`

* √Ñhnlich wie `textContent`, aber ber√ºcksichtigt **sichtbaren Text** nach CSS-Stilen.
* Reflow-lastig ‚Üí langsamer bei vielen Abfragen.
* Browser-spezifisches Verhalten (urspr√ºnglich nur IE).

```js
div.innerText = "<b>Hallo</b>";
console.log(div.innerText); // "<b>Hallo</b>"
```

Wenn ein Element `display: none` hat:

* `textContent` ‚Üí liefert den Text trotzdem.
* `innerText` ‚Üí gibt nichts zur√ºck (da unsichtbar).

---

## 4. Vergleich

| Eigenschaft   | Inhalt              | Ber√ºcksichtigt CSS        | Enth√§lt HTML | Performance        |
| ------------- | ------------------- | ------------------------- | ------------ | ------------------ |
| `innerHTML`   | HTML + Text         | Nein                      | ‚úÖ            | Mittel             |
| `textContent` | Nur reiner Text     | Nein                      | ‚ùå            | Schnell            |
| `innerText`   | Nur sichtbarer Text | ‚úÖ (z. B. `display: none`) | ‚ùå            | Langsamer (Reflow) |

---

**Zusammenfassung:**

* **`innerHTML`**: liest/√§ndert HTML + Text, riskant bei User-Daten.
* **`textContent`**: liest/√§ndert reinen Text (schnell, sicher).
* **`innerText`**: liest/√§ndert sichtbaren Text (CSS-bewusst, langsamer).

üìñ Quelle: [MDN Web Docs ‚Äî Node.textContent](https://developer.mozilla.org/ru/docs/Web/API/Node/textContent), [MDN Web Docs ‚Äî HTMLElement.innerText](https://developer.mozilla.org/ru/docs/Web/API/HTMLElement/innerText), [MDN Web Docs ‚Äî Element.innerHTML](https://developer.mozilla.org/ru/docs/Web/API/Element/innerHTML)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

76. ### <a name="76"></a> setTimeout und setInterval, Besonderheiten

**`setTimeout` und `setInterval` in JavaScript**

---

## 1. `setTimeout`

* F√ºhrt eine Funktion **einmal** nach einer bestimmten Verz√∂gerung aus.

```js
setTimeout(() => {
  console.log("Nach 2 Sekunden");
}, 2000);
```

* R√ºckgabe: **Timer-ID**, die mit `clearTimeout(id)` gestoppt werden kann.

```js
const id = setTimeout(() => console.log("Wird nicht ausgef√ºhrt"), 3000);
clearTimeout(id);
```

---

## 2. `setInterval`

* F√ºhrt eine Funktion in **regelm√§√üigen Abst√§nden** aus.

```js
const id = setInterval(() => {
  console.log("Alle 1 Sekunde");
}, 1000);

clearInterval(id); // stoppen
```

---

## 3. Besonderheiten

1. **Ungenaue Zeitmessung**

   * Timer sind **nicht garantiert exakt**.
   * JS ist **Single-Threaded** ‚Üí Verz√∂gerungen durch Event Loop m√∂glich.

   ```js
   setTimeout(() => console.log("Kann sp√§ter als 2s kommen"), 2000);
   ```

2. **Minimale Verz√∂gerung**

   * Spezifikation: mindestens **4 ms** ab zweitem verschachtelten Timer (`setTimeout` im `setTimeout`).

   ```js
   let i = 0;
   function repeat() {
     i++;
     console.log(i);
     if (i < 5) setTimeout(repeat, 0); // mindestens 4ms
   }
   repeat();
   ```

3. **setInterval vs. rekursives setTimeout**

   * `setInterval` kann sich stapeln, wenn die Callback-Ausf√ºhrung l√§nger dauert als das Intervall.
   * Besser: **rekursives `setTimeout`**, da es wartet, bis die Funktion fertig ist.

   ```js
   // Besser als setInterval
   function tick() {
     console.log("Tick");
     setTimeout(tick, 1000);
   }
   setTimeout(tick, 1000);
   ```

4. **Inaktive Tabs / Hintergrund**

   * Browser drosseln Timer (z. B. 1000ms Minimum in inaktiven Tabs).

5. **clearTimeout / clearInterval**

   * Unbedingt nutzen, um Speicherlecks oder unn√∂tige Berechnungen zu vermeiden.

---

## 4. Vergleich

| Merkmal       | `setTimeout`             | `setInterval`                        |
| ------------- | ------------------------ | ------------------------------------ |
| Ausf√ºhrung    | einmalig                 | wiederholt                           |
| Kontrolle     | `clearTimeout(id)`       | `clearInterval(id)`                  |
| Genauigkeit   | durch Event Loop ungenau | kann stapeln                         |
| Best Practice | f√ºr Verz√∂gerungen        | besser durch rekursives `setTimeout` |

---

**Zusammenfassung:**

* `setTimeout(fn, ms)` ‚Üí einmalige Ausf√ºhrung nach `ms`.
* `setInterval(fn, ms)` ‚Üí wiederholte Ausf√ºhrung alle `ms`.
* Beide sind **ungenau**, da durch Event Loop und Tab-Drosselung beeinflusst.
* F√ºr wiederholte Aktionen ist rekursives `setTimeout` oft **stabiler** als `setInterval`.

üìñ Quelle: [MDN Web Docs ‚Äî setTimeout](https://developer.mozilla.org/ru/docs/Web/API/setTimeout), [MDN Web Docs ‚Äî setInterval](https://developer.mozilla.org/ru/docs/Web/API/setInterval)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

77. ### <a name="77"></a> AJAX und XMLHttpRequest

**AJAX und `XMLHttpRequest` in JavaScript**

---

## 1. AJAX (Asynchronous JavaScript and XML)

* Technik f√ºr **asynchrone Kommunikation** mit dem Server.
* Seite muss **nicht neu geladen** werden, um Daten auszutauschen.
* Nutzt HTTP-Anfragen im Hintergrund ‚Üí heute meist mit **`fetch`** statt `XMLHttpRequest`.

‚û° Typische Formate: **JSON, XML, Text, HTML**.

---

## 2. `XMLHttpRequest` (XHR)

√Ñltere API, die AJAX erm√∂glicht.

### a) Erstellung einer Anfrage

```js
const xhr = new XMLHttpRequest();
xhr.open("GET", "https://jsonplaceholder.typicode.com/todos/1");
xhr.send();
```

### b) Antwort verarbeiten

```js
xhr.onreadystatechange = function () {
  if (xhr.readyState === 4 && xhr.status === 200) {
    console.log(JSON.parse(xhr.responseText));
  }
};
```

---

## 3. Wichtige Eigenschaften von `XMLHttpRequest`

* **`readyState`** ‚Üí Status der Anfrage

  * `0`: erstellt
  * `1`: ge√∂ffnet
  * `2`: Header empfangen
  * `3`: Laden im Gange
  * `4`: abgeschlossen
* **`status`** ‚Üí HTTP-Status (200, 404, 500 ‚Ä¶)
* **`responseText`** ‚Üí Textantwort (String)
* **`responseXML`** ‚Üí XML-DOM-Dokument (falls Antwort XML ist)

---

## 4. Alternative: `onload`-Handler

```js
const xhr = new XMLHttpRequest();
xhr.open("GET", "https://jsonplaceholder.typicode.com/todos/1");
xhr.onload = () => {
  if (xhr.status === 200) {
    console.log(JSON.parse(xhr.responseText));
  } else {
    console.error("Fehler:", xhr.status);
  }
};
xhr.send();
```

---

## 5. POST-Anfrage mit JSON

```js
const xhr = new XMLHttpRequest();
xhr.open("POST", "https://jsonplaceholder.typicode.com/posts");
xhr.setRequestHeader("Content-Type", "application/json;charset=UTF-8");

xhr.onload = () => {
  console.log("Antwort:", JSON.parse(xhr.responseText));
};

xhr.send(JSON.stringify({ title: "Hallo", body: "Welt", userId: 1 }));
```

---

## 6. Nachteile von `XMLHttpRequest`

* Umst√§ndliche Syntax (Callbacks, `readyState`).
* Kein natives `Promise`.
* Wird heute durch **`fetch`** und **Axios** ersetzt.

---

**Zusammenfassung:**

* **AJAX** = Technik, um Daten asynchron ohne Reload auszutauschen.
* **`XMLHttpRequest`** = alte API f√ºr AJAX, unterst√ºtzt GET/POST, Statuskontrolle, Events.
* Heute: **`fetch` bevorzugt**, da moderner, Promise-basiert und einfacher.

üìñ Quelle: [MDN Web Docs ‚Äî XMLHttpRequest](https://developer.mozilla.org/ru/docs/Web/API/XMLHttpRequest)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

78. ### <a name="78"></a> Promise (ES6)

**`Promise` in JavaScript (ES6)**

---

## 1. Definition

* Ein **Promise** ist ein Objekt, das das Ergebnis einer **asynchronen Operation** repr√§sentiert.
* Kann drei Zust√§nde haben:

  * **pending** ‚Üí ausstehend
  * **fulfilled** ‚Üí erfolgreich abgeschlossen
  * **rejected** ‚Üí fehlgeschlagen

---

## 2. Promise erstellen

```js
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("Fertig!"); // oder reject("Fehler")
  }, 1000);
});
```

---

## 3. Promise verwenden (`then`, `catch`, `finally`)

```js
promise
  .then(result => {
    console.log("Erfolg:", result);
  })
  .catch(error => {
    console.error("Fehler:", error);
  })
  .finally(() => {
    console.log("Cleanup");
  });
```

---

## 4. Promise-Ketten

* Jeder `then` gibt ein **neues Promise** zur√ºck ‚Üí Verkettung m√∂glich.

```js
new Promise(resolve => resolve(2))
  .then(x => x * 2)      // 4
  .then(x => x * 3)      // 12
  .then(console.log);    // 12
```

---

## 5. Promise-Methoden (statisch)

* **`Promise.resolve(value)`** ‚Üí Promise, das sofort erf√ºllt ist.
* **`Promise.reject(error)`** ‚Üí Promise, das sofort fehlschl√§gt.
* **`Promise.all([...])`** ‚Üí alle Promises m√ºssen erfolgreich sein.
* **`Promise.race([...])`** ‚Üí erstes Promise entscheidet.
* **`Promise.allSettled([...])`** ‚Üí wartet auf alle, egal ob fulfilled oder rejected.
* **`Promise.any([...])`** ‚Üí erstes erf√ºlltes Promise (ES2021).

```js
Promise.all([
  Promise.resolve(1),
  Promise.resolve(2)
]).then(console.log); // [1, 2]
```

---

## 6. Vorteile von Promises

* Besser lesbar als Callbacks (‚ÄûCallback Hell‚Äú vermeiden).
* Fehlerbehandlung klarer (`catch`).
* Grundlage f√ºr **async/await** (ES2017).

---

**Zusammenfassung:**

* **Promise** = Objekt f√ºr asynchrone Operationen mit Zust√§nden *pending*, *fulfilled*, *rejected*.
* Nutzung √ºber **`then`**, **`catch`**, **`finally`**.
* Wichtige Methoden: `resolve`, `reject`, `all`, `race`, `allSettled`, `any`.
* Grundlage f√ºr **async/await**.

üìñ Quelle: [MDN Web Docs ‚Äî Promise](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

79. ### <a name="79"></a> Fetch API

**Fetch API in JavaScript**

---

## 1. Definition

* **Fetch API** = moderne Schnittstelle zum Senden von HTTP-Anfragen.
* Liefert ein **Promise**, das sich mit einem **Response-Objekt** aufl√∂st.
* Ersatz f√ºr das alte `XMLHttpRequest`.

---

## 2. Einfaches Beispiel (GET)

```js
fetch("https://jsonplaceholder.typicode.com/todos/1")
  .then(response => {
    if (!response.ok) throw new Error("HTTP-Fehler " + response.status);
    return response.json(); // Antwort in JSON umwandeln
  })
  .then(data => console.log("Daten:", data))
  .catch(error => console.error("Fehler:", error));
```

---

## 3. Mit `async/await`

```js
async function loadTodo() {
  try {
    const res = await fetch("https://jsonplaceholder.typicode.com/todos/1");
    if (!res.ok) throw new Error("HTTP-Fehler " + res.status);
    const data = await res.json();
    console.log("Daten:", data);
  } catch (err) {
    console.error("Fehler:", err);
  }
}
loadTodo();
```

---

## 4. POST-Anfrage

```js
fetch("https://jsonplaceholder.typicode.com/posts", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ title: "Hallo", body: "Welt", userId: 1 })
})
  .then(res => res.json())
  .then(data => console.log("Antwort:", data));
```

---

## 5. Response-Methoden

* **`response.text()`** ‚Üí als Text
* **`response.json()`** ‚Üí JSON ‚Üí Objekt
* **`response.blob()`** ‚Üí Bin√§rdaten (z. B. Bilder)
* **`response.formData()`** ‚Üí Formulardaten
* **`response.arrayBuffer()`** ‚Üí Low-Level-Bin√§rdaten

---

## 6. Besondere Eigenschaften

* **Standard = GET**
* **Fetch l√∂st nur bei Netzwerkfehlern `catch` aus**, nicht bei HTTP-Fehlern (z. B. `404`).

  * Deshalb: `if (!response.ok)` pr√ºfen.
* Unterst√ºtzt **CORS** (Cross-Origin Resource Sharing).
* Streams m√∂glich (gro√üe Dateien St√ºck f√ºr St√ºck laden).

---

## 7. Vergleich zu `XMLHttpRequest`

| Merkmal          | Fetch API                       | XMLHttpRequest                 |
| ---------------- | ------------------------------- | ------------------------------ |
| Syntax           | Promise-basiert, moderner       | Callback-basiert               |
| Fehlerbehandlung | `catch` nur bei Netzwerkfehler  | HTTP-Fehler manuell pr√ºfen     |
| Response-Formate | `.json()`, `.text()`, `.blob()` | komplizierter (`responseType`) |
| CORS             | eingebaut                       | eingeschr√§nkt                  |
| Lesbarkeit       | kurz, mit `async/await` top     | komplexer                      |

---

**Zusammenfassung:**

* **Fetch API** = moderne, Promise-basierte HTTP-Schnittstelle.
* R√ºckgabe: `Promise<Response>`.
* Methoden: `.json()`, `.text()`, `.blob()`, etc.
* Vorteil: einfache Syntax, kompatibel mit `async/await`.
* Ersatz f√ºr `XMLHttpRequest`.

üìñ Quelle: [MDN Web Docs ‚Äî Fetch API](https://developer.mozilla.org/ru/docs/Web/API/Fetch_API)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

80. ### <a name="80"></a> Async/Await (ES8)

**`async/await` in JavaScript (ES8)**

---

## 1. Definition

* **`async/await`** ist syntaktischer Zucker √ºber **Promises**.
* Macht asynchronen Code **lesbarer** (√§hnlich wie synchroner Code).
* `async` markiert eine Funktion ‚Üí R√ºckgabewert ist immer ein **Promise**.
* `await` pausiert die Ausf√ºhrung, bis ein Promise erf√ºllt ist.

---

## 2. `async`-Funktion

```js
async function hello() {
  return "Hallo!";
}

hello().then(console.log); // Promise ‚Üí "Hallo!"
```

---

## 3. `await`

* Nur innerhalb von `async`-Funktionen nutzbar.
* Wartet auf ein Promise und gibt dessen Wert zur√ºck.

```js
async function getData() {
  const res = await fetch("https://jsonplaceholder.typicode.com/todos/1");
  const data = await res.json();
  console.log(data);
}
getData();
```

---

## 4. Fehlerbehandlung

* Mit `try...catch` wie bei synchronem Code.

```js
async function load() {
  try {
    const res = await fetch("https://jsonplaceholder.typicode.com/404");
    if (!res.ok) throw new Error("HTTP-Fehler " + res.status);
    const data = await res.json();
    console.log(data);
  } catch (err) {
    console.error("Fehler:", err);
  }
}
load();
```

---

## 5. Parallelisierung mit `Promise.all`

Mehrere Promises gleichzeitig starten:

```js
async function loadUsers() {
  const [u1, u2] = await Promise.all([
    fetch("/user/1").then(r => r.json()),
    fetch("/user/2").then(r => r.json())
  ]);
  console.log(u1, u2);
}
```

---

## 6. Besonderheiten

* `async`-Funktionen **geben immer ein Promise zur√ºck**.
* `await` blockiert nicht den Thread, sondern pausiert nur die Funktion.
* Mischung mit `then/catch` m√∂glich, aber un√ºblich.

---

## 7. Vergleich zu Promises direkt

**Promise-Kette:**

```js
fetch(url)
  .then(res => res.json())
  .then(data => console.log(data))
  .catch(err => console.error(err));
```

**async/await:**

```js
try {
  const res = await fetch(url);
  const data = await res.json();
  console.log(data);
} catch (err) {
  console.error(err);
}
```

‚û° Deutlich **lesbarer** und besser wartbar.

---

**Zusammenfassung:**

* **`async`** markiert Funktion, R√ºckgabe ist Promise.
* **`await`** pausiert, bis Promise aufgel√∂st ist.
* Vorteil: asynchroner Code wirkt **synchron**, lesbarer.
* Fehlerbehandlung mit `try...catch`.
* Perfekt in Kombination mit `Promise.all` f√ºr parallele Tasks.

üìñ Quelle: [MDN Web Docs ‚Äî async/await](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/async_function)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

81. ### <a name="81"></a> try...catch, throw-Anweisung

**`try...catch` und `throw` in JavaScript**

---

## 1. `try...catch`

* Erm√∂glicht **Fehlerbehandlung** im Code.
* Wenn im `try`-Block ein Fehler (Exception) auftritt ‚Üí Springt in `catch`.

```js
try {
  let result = riskyOperation();
  console.log(result);
} catch (error) {
  console.error("Fehler aufgefangen:", error.message);
}
```

---

## 2. `throw`-Anweisung

* Mit `throw` kann man **eigene Fehler erzeugen**.
* Jeder Wert kann geworfen werden (`Error`, String, Zahl, Objekt).
* Best Practice: Instanzen von `Error` verwenden.

```js
function divide(a, b) {
  if (b === 0) {
    throw new Error("Division durch 0 nicht erlaubt");
  }
  return a / b;
}

try {
  console.log(divide(10, 0));
} catch (e) {
  console.error("Fehler:", e.message);
}
```

---

## 3. Fehlerobjekte (`Error`)

* Eingebaute Konstruktoren: `Error`, `TypeError`, `ReferenceError`, `SyntaxError`, ‚Ä¶
* Eigenschaften:

  * `message` ‚Üí Fehlertext
  * `name` ‚Üí Typ des Fehlers
  * `stack` ‚Üí Stacktrace

```js
try {
  throw new TypeError("Ung√ºltiger Typ!");
} catch (e) {
  console.log(e.name);    // "TypeError"
  console.log(e.message); // "Ung√ºltiger Typ!"
}
```

---

## 4. `finally`-Block

* Wird **immer** ausgef√ºhrt (egal ob Fehler oder nicht).
* Praktisch f√ºr Aufr√§umarbeiten (z. B. Ressourcen schlie√üen).

```js
try {
  console.log("Start");
  throw new Error("Oops!");
} catch (e) {
  console.log("Fehler:", e.message);
} finally {
  console.log("Cleanup l√§uft immer");
}
```

---

## 5. Asynchroner Code

* `try...catch` funktioniert auch mit **async/await**.

```js
async function fetchData() {
  try {
    const res = await fetch("https://jsonplaceholder.typicode.com/404");
    if (!res.ok) throw new Error("HTTP-Fehler " + res.status);
    const data = await res.json();
    return data;
  } catch (e) {
    console.error("Fehler bei Fetch:", e.message);
  }
}
```

---

**Zusammenfassung:**

* **`try...catch`** ‚Üí behandelt Fehler im Code.
* **`throw`** ‚Üí erzeugt Fehler (eigene oder Standard).
* **Best Practice:** `Error`-Objekte werfen.
* **`finally`** ‚Üí f√ºhrt Cleanup-Code unabh√§ngig vom Ergebnis aus.
* Mit **async/await** nahtlos kombinierbar.

üìñ Quelle: [MDN Web Docs ‚Äî try...catch](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/try...catch), [MDN Web Docs ‚Äî throw](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/throw)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

82. ### <a name="82"></a> Axios-Bibliothek

**Axios-Bibliothek in JavaScript**

---

## 1. Definition

* **Axios** = beliebte externe Bibliothek f√ºr **HTTP-Anfragen**.
* Baut auf **Promises** auf.
* Funktioniert in **Browser** und **Node.js**.
* Alternative zu **Fetch API**, aber mit mehr Komfort.

---

## 2. Installation

```bash
npm install axios
```

Import:

```js
import axios from "axios";
```

---

## 3. GET-Anfrage

```js
axios.get("https://jsonplaceholder.typicode.com/todos/1")
  .then(response => {
    console.log("Daten:", response.data);
  })
  .catch(error => {
    console.error("Fehler:", error.message);
  });
```

---

## 4. POST-Anfrage

```js
axios.post("https://jsonplaceholder.typicode.com/posts", {
  title: "Hallo",
  body: "Welt",
  userId: 1
})
.then(res => console.log("Antwort:", res.data))
.catch(err => console.error(err));
```

---

## 5. Mit `async/await`

```js
async function loadTodo() {
  try {
    const res = await axios.get("https://jsonplaceholder.typicode.com/todos/1");
    console.log(res.data);
  } catch (err) {
    console.error(err);
  }
}
loadTodo();
```

---

## 6. Besondere Features von Axios

* **Automatische JSON-Umwandlung** (`res.data`).
* **Interceptors** ‚Üí Anfragen/Antworten abfangen und modifizieren.
* **Cancel-Token** ‚Üí Anfragen abbrechen.
* **Standard-Header konfigurieren** (z. B. Auth).
* **Time-out** festlegen.
* L√§uft in **alten Browsern**, wo `fetch` fehlt.

---

## 7. Interceptor-Beispiel

```js
axios.interceptors.request.use(config => {
  console.log("Sende Anfrage an:", config.url);
  return config;
});
```

---

## 8. Vergleich Axios vs. Fetch

| Merkmal          | Axios                             | Fetch API                    |
| ---------------- | --------------------------------- | ---------------------------- |
| Syntax           | einfacher (direkt `res.data`)     | explizit `res.json()` n√∂tig  |
| Browser-Support  | auch alte Browser                 | modernere Browser            |
| Features         | Interceptors, Abbrechen, Timeouts | Basis-API, erweiterbar       |
| Fehlerbehandlung | HTTP-Fehler automatisch `catch`   | nur Netzwerkfehler ‚Üí `catch` |

---

**Zusammenfassung:**

* **Axios** = HTTP-Client-Bibliothek (Promise-basiert).
* Vorteile: automatische JSON-Umwandlung, Interceptors, Timeouts, Cancel.
* Bietet mehr Komfort als **Fetch**, besonders in komplexen Projekten.
* Heute Standard in vielen React-/Vue-/Node-Projekten.

üìñ Quelle: [Axios GitHub](https://github.com/axios/axios)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**   

83. ### <a name="83"></a> Event Loop, synchrone und asynchrone Operationen

**Event Loop, synchrone und asynchrone Operationen in JavaScript**

---

## 1. Synchrone Operationen

* Werden **direkt** und in der **Reihenfolge** des Codes ausgef√ºhrt.
* Blockieren den Thread, bis sie fertig sind.

```js
console.log("1");
console.log("2");
console.log("3");
// Ausgabe: 1, 2, 3
```

---

## 2. Asynchrone Operationen

* Werden **sp√§ter** ausgef√ºhrt, ohne den Haupt-Thread zu blockieren.
* Beispiele: `setTimeout`, `fetch`, DOM-Events, Promises.

```js
console.log("1");
setTimeout(() => console.log("2"), 0);
console.log("3");
// Ausgabe: 1, 3, 2
```

---

## 3. Event Loop (Ereignisschleife)

* Herzst√ºck der **JavaScript-Laufzeitumgebung** (Browser, Node.js).
* √úberwacht **Call Stack** (Aufrufstapel) und **Queues** (Warteschlangen).
* Ablauf:

  1. Call Stack leer?
  2. Nimm n√§chste Aufgabe aus der Queue.
  3. F√ºhre sie aus.
  4. Wiederholen.

---

## 4. Task Queues

### a) **Macro-Tasks** (Task Queue)

* `setTimeout`, `setInterval`, DOM-Events, `setImmediate` (Node.js).

### b) **Micro-Tasks** (Microtask Queue)

* `Promise.then/catch/finally`, `MutationObserver`, `queueMicrotask()`.
* Haben **h√∂here Priorit√§t** ‚Üí werden **vor Macro-Tasks** ausgef√ºhrt.

---

## 5. Beispiel: Reihenfolge verstehen

```js
console.log("A");

setTimeout(() => console.log("B"), 0); // Macro-Task
Promise.resolve().then(() => console.log("C")); // Micro-Task

console.log("D");
```

**Ablauf:**

1. `A` (synchron)
2. `D` (synchron)
3. `C` (Microtask ‚Üí vor Timeout)
4. `B` (Timeout ‚Üí Macro-Task)

**Ausgabe:**

```
A
D
C
B
```

---

## 6. Visualisierung

* **Call Stack** = Stapel aktueller Funktionsaufrufe.
* **Web APIs** = z. B. Timer, DOM, Fetch (f√ºhren Aufgaben im Hintergrund aus).
* **Task Queues** = Ergebnisse der Web APIs warten hier.
* **Event Loop** = schiebt fertige Tasks zur√ºck in den Call Stack.

---

**Zusammenfassung:**

* **Synchron**: direkt, blockierend.
* **Asynchron**: sp√§ter, blockieren nicht.
* **Event Loop** koordiniert Call Stack + Task Queues.
* **Microtasks (Promises)** ‚Üí h√∂here Priorit√§t als **Macrotasks (Timeouts)**.

üìñ Quelle: [MDN Web Docs ‚Äî Event Loop](https://developer.mozilla.org/ru/docs/Web/JavaScript/EventLoop)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

84. ### <a name="84"></a> M√∂glichkeiten zum Senden von Serveranfragen

**M√∂glichkeiten zum Senden von Serveranfragen in JavaScript**

---

## 1. **XMLHttpRequest (XHR)**

* Klassische Methode (seit AJAX).
* Unterst√ºtzt GET/POST, Header, Status-Codes.
* Callback-basiert, kein Promise ‚Üí umst√§ndlich.

```js
const xhr = new XMLHttpRequest();
xhr.open("GET", "/api/data");
xhr.onload = () => console.log(xhr.responseText);
xhr.send();
```

---

## 2. **Fetch API (ES6)** ‚úÖ *heute Standard*

* Promise-basiert.
* Unterst√ºtzt moderne Features (CORS, Streams).
* Muss HTTP-Fehler manuell gepr√ºft werden (`response.ok`).

```js
fetch("/api/data")
  .then(res => res.json())
  .then(data => console.log(data))
  .catch(err => console.error(err));
```

Mit `async/await`:

```js
const res = await fetch("/api/data");
const data = await res.json();
```

---

## 3. **Axios (externe Bibliothek)**

* Promise-basiert, Komfortfunktionen: automatische JSON-Konvertierung, Interceptors, Timeouts, Cancel.
* Funktioniert in Browser + Node.js.

```js
import axios from "axios";

const res = await axios.get("/api/data");
console.log(res.data);
```

---

## 4. **GraphQL-Requests**

* Serverseitige Abfragen √ºber HTTP (`POST /graphql`).
* Abfragen + Mutationen als String.

```js
const query = `{ user(id: 1) { name, email } }`;

const res = await fetch("/graphql", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ query })
});
```

---

## 5. **WebSockets**

* Bidirektionale, persistente Verbindung.
* F√ºr **Echtzeit-Kommunikation** (Chats, Live-Updates).

```js
const socket = new WebSocket("wss://example.com/socket");

socket.onmessage = (event) => {
  console.log("Nachricht:", event.data);
};
```

---

## 6. **Server-Sent Events (SSE)**

* Einweg-Kommunikation: Server ‚Üí Client.
* Gut f√ºr Live-Streams, Notifications.

```js
const evtSource = new EventSource("/events");
evtSource.onmessage = (e) => console.log("Event:", e.data);
```

---

## 7. **Formular-√úbermittlung (klassisch)**

* `<form action="/api" method="POST">` ‚Üí Seite wird neu geladen.
* Heute oft durch AJAX/Fetch ersetzt.

---

## 8. Vergleich

| Methode          | Paradigma                 | Typische Nutzung         |
| ---------------- | ------------------------- | ------------------------ |
| XMLHttpRequest   | Alt, Callback-basiert     | Legacy, √§ltere Browser   |
| Fetch API        | Promise-basiert           | Standard f√ºr REST-APIs   |
| Axios            | Promise + Komfort         | Komplexe Apps, React/Vue |
| GraphQL-Requests | POST mit Query            | Moderne APIs             |
| WebSockets       | persistent, bidirektional | Echtzeit (Chat, Live)    |
| SSE              | persistent, einseitig     | Server ‚Üí Client Updates  |
| Formulare        | Standard HTML             | einfache Formulare       |

---

**Zusammenfassung:**

* Klassisch: **XMLHttpRequest**.
* Modern: **Fetch API**, **Axios**.
* Echtzeit: **WebSockets**, **SSE**.
* Strukturierte APIs: **GraphQL**.
* Legacy/Standard: **Formulare**.

üìñ Quelle: [MDN Web Docs ‚Äî Client-side web APIs](https://developer.mozilla.org/ru/docs/Learn/JavaScript/Client-side_web_APIs/Introduction)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

85. ### <a name="85"></a> Long Polling (Langes Abfragen)

**Long Polling (Langes Abfragen) in JavaScript**

---

## 1. Definition

* **Long Polling** ist eine Technik, um **nahezu Echtzeit-Kommunikation** zwischen Client und Server zu erm√∂glichen, wenn WebSockets oder SSE nicht verf√ºgbar sind.
* Prinzip:

  1. Client sendet eine Anfrage an den Server.
  2. Server **wartet**, bis neue Daten vorhanden sind.
  3. Sobald Daten da sind ‚Üí Antwort wird zur√ºckgeschickt.
  4. Client startet sofort eine **neue Anfrage** ‚Üí Kreislauf.

---

## 2. Ablauf (visuell)

```
Client ‚Üí Anfrage ‚Üí Server
Client ‚Üê Antwort (wenn Daten da)
Client ‚Üí neue Anfrage ‚Üí ...
```

---

## 3. Beispiel mit `fetch`

```js
async function longPolling() {
  try {
    const res = await fetch("/events");
    const data = await res.json();
    console.log("Neue Nachricht:", data);

    // sofort n√§chste Anfrage starten
    longPolling();
  } catch (err) {
    console.error("Fehler:", err);
    setTimeout(longPolling, 3000); // Retry mit Verz√∂gerung
  }
}

longPolling();
```

---

## 4. Eigenschaften

‚úÖ Vorteile:

* Einfach zu implementieren (funktioniert mit normalen HTTP).
* Funktioniert auch in √§lteren Browsern.

‚ö†Ô∏è Nachteile:

* Viele HTTP-Verbindungen ‚Üí ineffizient (Overhead).
* Serverlast steigt, wenn viele Clients parallel laufen.
* Nicht so performant wie **WebSockets** oder **SSE**.

---

## 5. Vergleich

| Technik      | Richtung                  | Verbindung       | Typische Nutzung         |
| ------------ | ------------------------- | ---------------- | ------------------------ |
| Long Polling | bidirektional (simuliert) | viele kurze HTTP | Fallback f√ºr Echtzeit    |
| WebSockets   | bidirektional             | persistent       | Chat, Multiplayer, B√∂rse |
| SSE          | nur Server ‚Üí Client       | persistent       | Live-Daten, Newsfeed     |

---

**Zusammenfassung:**

* **Long Polling** = Client fragt den Server st√§ndig ab, aber jede Anfrage ‚Äûwartet‚Äú bis neue Daten vorhanden sind.
* Einfach, aber **ineffizient** (Overhead).
* Heute eher als **Fallback**, moderne Alternativen: **WebSockets, SSE**.

üìñ Quelle: [MDN Web Docs ‚Äî Comet (Long polling)](https://developer.mozilla.org/en-US/docs/Web/Guide/AJAX/Comet/Long_polling)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

86. ### <a name="86"></a> Web Socket

**WebSockets in JavaScript**

---

## 1. Definition

* **WebSocket** = Protokoll f√ºr **bidirektionale, persistente Kommunikation** zwischen Client und Server √ºber eine einzige TCP-Verbindung.
* Unterschied zu HTTP: Verbindung bleibt **offen**, Server kann aktiv Nachrichten senden.
* Typisch f√ºr: **Chats, Multiplayer-Games, B√∂rsenkurse, Live-Dashboards**.

---

## 2. Verbindung aufbauen

```js
// Client-Seite (Browser)
const socket = new WebSocket("wss://example.com/socket");

// Verbindungsaufbau erfolgreich
socket.onopen = () => {
  console.log("Verbunden");
  socket.send("Hallo Server!");
};

// Nachricht empfangen
socket.onmessage = (event) => {
  console.log("Nachricht:", event.data);
};

// Verbindung geschlossen
socket.onclose = () => {
  console.log("Verbindung geschlossen");
};

// Fehlerbehandlung
socket.onerror = (err) => {
  console.error("Fehler:", err);
};
```

---

## 3. Senden von Nachrichten

```js
socket.send(JSON.stringify({ type: "chat", text: "Hallo!" }));
```

---

## 4. Server-Seite (Node.js mit `ws`)

```js
import { WebSocketServer } from "ws";

const wss = new WebSocketServer({ port: 8080 });

wss.on("connection", (ws) => {
  console.log("Client verbunden");

  ws.on("message", (msg) => {
    console.log("Empfangen:", msg.toString());
    ws.send("Echo: " + msg);
  });

  ws.on("close", () => console.log("Client getrennt"));
});
```

---

## 5. Eigenschaften

‚úÖ Vorteile:

* Echtzeitf√§hig (ms-Latenz).
* Effizienter als Long Polling (keine st√§ndigen HTTP-Requests).
* Bidirektional (Client ‚Üî Server).

‚ö†Ô∏è Nachteile:

* Nicht √ºberall unterst√ºtzt (z. B. sehr alte Browser/Firewalls).
* H√∂here Komplexit√§t im Vergleich zu einfachem HTTP.
* Skalierung schwieriger (Sticky Sessions, spezielle Load Balancer n√∂tig).

---

## 6. Vergleich

| Technik          | Richtung            | Verbindung     | Typische Nutzung           |
| ---------------- | ------------------- | -------------- | -------------------------- |
| **HTTP-Request** | Client ‚Üí Server     | kurzlebig      | klassische APIs            |
| **Long Polling** | quasi bidirektional | viele Anfragen | Fallback, Legacy           |
| **SSE**          | Server ‚Üí Client     | persistent     | Live-Feeds, News, Updates  |
| **WebSockets**   | bidirektional       | persistent     | Chat, Games, Echtzeit-Apps |

---

**Zusammenfassung:**

* **WebSockets**: persistente, bidirektionale Verbindung √ºber `ws://` oder `wss://`.
* Client: `new WebSocket(url)` ‚Üí Events `open`, `message`, `close`, `error`.
* Server (Node.js): `ws`-Bibliothek g√§ngig.
* Vorteil: Echtzeit, effizient; Nachteil: komplexere Skalierung.

üìñ Quelle: [MDN Web Docs ‚Äî WebSockets](https://developer.mozilla.org/ru/docs/Web/API/WebSockets_API)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

87. ### <a name="87"></a> Was sind Web Workers und wof√ºr braucht man sie?

**Web Workers in JavaScript**

---

## 1. Definition

* **Web Worker** = API, um **JavaScript in Hintergrund-Threads** auszuf√ºhren.
* Standard-JS l√§uft im **Single-Thread** (UI + Logik). Lange Berechnungen ‚Üí blockieren UI.
* Worker l√∂sen das: Berechnung l√§uft parallel, UI bleibt responsiv.

---

## 2. Arten von Workern

* **Dedicated Worker** ‚Üí nur f√ºr einen bestimmten Haupt-Thread.
* **Shared Worker** ‚Üí kann von mehreren Skripten/Seiten genutzt werden.
* **Service Worker** ‚Üí speziell f√ºr Netzwerk-Proxy, Caching, Offline.

---

## 3. Dedicated Worker ‚Äì Beispiel

**main.js**

```js
const worker = new Worker("worker.js");

// Nachricht an Worker senden
worker.postMessage({ num: 5 });

// Antwort empfangen
worker.onmessage = (event) => {
  console.log("Ergebnis vom Worker:", event.data);
};
```

**worker.js**

```js
// L√§uft im Hintergrund
onmessage = (event) => {
  const { num } = event.data;
  const result = num * num;
  postMessage(result);
};
```

---

## 4. Einschr√§nkungen

* Kein direkter Zugriff auf **DOM**.
* Kommunikation nur √ºber **Message-Passing** (`postMessage`, `onmessage`).
* Zugriff auf eingeschr√§nkte APIs: `fetch`, `WebSockets`, `IndexedDB`, aber **kein `document` oder `window`**.

---

## 5. Typische Anwendungsf√§lle

* Aufw√§ndige Berechnungen (z. B. Bildbearbeitung, KI-Modelle).
* Parsing gro√üer JSON-Dateien.
* Kryptographie (Hashing, Verschl√ºsselung).
* Echtzeitdaten-Verarbeitung ohne UI-Lags.

---

## 6. Vorteile & Nachteile

‚úÖ Vorteile:

* Verhindern UI-Blockaden.
* Parallele Verarbeitung m√∂glich.

‚ö†Ô∏è Nachteile:

* Kein DOM-Zugriff.
* Kommunikation √ºber Nachrichten kann Overhead verursachen.
* Komplexer als normaler JS-Code.

---

**Zusammenfassung:**

* **Web Workers** = Hintergrund-Threads f√ºr rechenintensive Aufgaben.
* Kommunikation: `postMessage` / `onmessage`.
* Kein DOM-Zugriff, aber Zugriff auf einige Web-APIs.
* Nutzen f√ºr **Performance** (z. B. Bild-/Datenverarbeitung, KI).

üìñ Quelle: [MDN Web Docs ‚Äî Web Workers](https://developer.mozilla.org/ru/docs/Web/API/Web_Workers_API)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

88. ### <a name="88"></a> Microtasks vs. Macrotasks

**Microtasks vs. Macrotasks in JavaScript**

---

## 1. Event Loop √úberblick

* Der **Event Loop** koordiniert, wann Code ausgef√ºhrt wird.
* Aufgaben (Tasks) landen in **Queues**:

  * **Macrotask Queue** ‚Üí gro√üe Bl√∂cke (z. B. Timer, Events).
  * **Microtask Queue** ‚Üí kleine Jobs mit hoher Priorit√§t (z. B. Promises).
* Reihenfolge:

  1. Ausf√ºhrung synchroner Code
  2. Alle **Microtasks**
  3. N√§chste **Macrotask**

---

## 2. Microtasks

* Beispiele:

  * `Promise.then/catch/finally`
  * `queueMicrotask()`
  * `MutationObserver`

```js
Promise.resolve().then(() => console.log("Microtask"));
queueMicrotask(() => console.log("Noch ein Microtask"));
```

---

## 3. Macrotasks

* Beispiele:

  * `setTimeout`
  * `setInterval`
  * `setImmediate` (Node.js)
  * DOM-Events (`click`, `load`)

```js
setTimeout(() => console.log("Macrotask"), 0);
```

---

## 4. Reihenfolge Beispiel

```js
console.log("A");

setTimeout(() => console.log("B"), 0);         // Macrotask
Promise.resolve().then(() => console.log("C")); // Microtask

console.log("D");
```

**Ausgabe:**

```
A
D
C   // Microtask vor Macrotask
B
```

---

## 5. Besonderheit

* Nach **jedem Macrotask** werden **alle Microtasks** geleert.
* Deshalb k√∂nnen verschachtelte Promises ‚Äûdazwischenfunken‚Äú.

```js
setTimeout(() => console.log("Macrotask 1"), 0);

Promise.resolve().then(() => {
  console.log("Microtask 1");
  Promise.resolve().then(() => console.log("Microtask 2"));
});

setTimeout(() => console.log("Macrotask 2"), 0);
```

**Ausgabe:**

```
Microtask 1
Microtask 2
Macrotask 1
Macrotask 2
```

---

## 6. Vergleich

| Merkmal         | Microtask                         | Macrotask                  |
| --------------- | --------------------------------- | -------------------------- |
| Priorit√§t       | h√∂her                             | niedriger                  |
| Beispiele       | `Promise.then`, `queueMicrotask`  | `setTimeout`, DOM-Events   |
| Ausf√ºhrungszeit | sofort nach synchronem Code       | nach allen Microtasks      |
| Queue Verhalten | wird nach jedem Macrotask geleert | l√§uft in Event Loop-Zyklen |

---

**Zusammenfassung:**

* **Microtasks**: Promises, haben **h√∂here Priorit√§t**, laufen **vor Macrotasks**.
* **Macrotasks**: Timer, Events, laufen sp√§ter im Event Loop.
* Ablauf: **Sync Code ‚Üí alle Microtasks ‚Üí erste Macrotask ‚Üí alle Microtasks ‚Üí n√§chste Macrotask...**

üìñ Quelle: [MDN Web Docs ‚Äî Event Loop](https://developer.mozilla.org/ru/docs/Web/JavaScript/EventLoop)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

89. ### <a name="89"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

90. ### <a name="90"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

91. ### <a name="91"></a> Klassen (ES6)

**Klassen (ES6) in JavaScript**

---

## 1. Definition

* Mit **ES6** eingef√ºhrt.
* Syntax-Zucker √ºber **prototypische Vererbung**.
* Erlaubt objektorientierte Struktur (√§hnlich wie in Java/JavaScript).

---

## 2. Klassendeklaration

```js
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  greet() {
    console.log(`Hallo, ich bin ${this.name}`);
  }
}

const p = new Person("Sergii", 30);
p.greet(); // Hallo, ich bin Sergii
```

---

## 3. Klassen-Ausdr√ºcke

```js
const Animal = class {
  speak() {
    console.log("Ger√§usch");
  }
};
```

---

## 4. Vererbung mit `extends` und `super`

```js
class Animal {
  constructor(name) {
    this.name = name;
  }
  speak() {
    console.log(`${this.name} macht ein Ger√§usch`);
  }
}

class Dog extends Animal {
  constructor(name, breed) {
    super(name); // ruft Konstruktor von Animal
    this.breed = breed;
  }
  speak() {
    console.log(`${this.name} bellt`);
  }
}

const dog = new Dog("Bobby", "Labrador");
dog.speak(); // Bobby bellt
```

---

## 5. Statische Methoden und Eigenschaften

```js
class MathUtils {
  static add(a, b) {
    return a + b;
  }
}

console.log(MathUtils.add(2, 3)); // 5
```

---

## 6. Getter & Setter

```js
class User {
  constructor(name) {
    this._name = name;
  }

  get name() {
    return this._name.toUpperCase();
  }

  set name(newName) {
    this._name = newName;
  }
}

const u = new User("Sergii");
console.log(u.name); // SERGII
u.name = "Alex";
console.log(u.name); // ALEX
```

---

## 7. Besonderheiten

* Klassen sind **nicht hoisted** wie Funktionsdeklarationen.
* Immer im **Strict Mode**.
* Methoden sind standardm√§√üig **nicht aufz√§hlbar**.
* Unter der Haube basiert alles auf **Prototypen**.

---

## 8. Vergleich: Funktion vs. Klasse

```js
// Vor ES6
function PersonOld(name) {
  this.name = name;
}
PersonOld.prototype.greet = function () {
  console.log(`Hallo, ich bin ${this.name}`);
};

// Ab ES6
class PersonNew {
  constructor(name) {
    this.name = name;
  }
  greet() {
    console.log(`Hallo, ich bin ${this.name}`);
  }
}
```

Beide Varianten sind funktional gleich ‚Äì **Klassen = syntaktischer Zucker**.

---

**Zusammenfassung:**

* **Klassen (ES6)** = Syntax-Zucker √ºber Prototypen.
* Bestandteile: `constructor`, Methoden, `extends`, `super`, `static`, Getter/Setter.
* Unterschiede: nicht hoisted, Strict Mode, Methoden nicht aufz√§hlbar.
* Erleichtern objektorientiertes Programmieren in JavaScript.

üìñ Quelle: [MDN Web Docs ‚Äî Classes](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

92. ### <a name="92"></a> Klassenvererbung, private und gesch√ºtzte Eigenschaften

**Klassenvererbung, private und gesch√ºtzte Eigenschaften in JavaScript (ES6+)**

---

## 1. Klassenvererbung (`extends`, `super`)

* Mit `extends` k√∂nnen Klassen von anderen erben.
* Mit `super` ruft man den Konstruktor oder Methoden der Elternklasse auf.

```js
class Animal {
  constructor(name) {
    this.name = name;
  }
  speak() {
    console.log(`${this.name} macht ein Ger√§usch`);
  }
}

class Dog extends Animal {
  constructor(name, breed) {
    super(name); // Konstruktor von Animal aufrufen
    this.breed = breed;
  }
  speak() {
    console.log(`${this.name} bellt`);
  }
}

const dog = new Dog("Bello", "Labrador");
dog.speak(); // Bello bellt
```

---

## 2. Gesch√ºtzte Eigenschaften (Konvention)

* JavaScript hat **keine echten ‚Äûprotected‚Äú Properties**.
* Konvention: Unterstrich (`_`) signalisiert ‚Äûnicht √∂ffentlich gedacht‚Äú.

```js
class User {
  constructor(name) {
    this._name = name; // gesch√ºtzt (Konvention)
  }
}
```

‚û° **Aber:** technisch bleibt die Eigenschaft √∂ffentlich zug√§nglich.

---

## 3. Private Eigenschaften (`#`, ES2020)

* Mit `#` vor Namen ‚Üí echte Private Properties, **au√üerhalb nicht zugreifbar**.

```js
class Account {
  #balance = 0; // private Eigenschaft

  deposit(amount) {
    this.#balance += amount;
  }

  getBalance() {
    return this.#balance;
  }
}

const acc = new Account();
acc.deposit(100);
console.log(acc.getBalance()); // 100
console.log(acc.#balance);     // ‚ùå SyntaxError
```

---

## 4. Private Methoden (`#`)

Auch Methoden k√∂nnen privat sein:

```js
class Secret {
  #generateKey() {
    return Math.random().toString(36).slice(2);
  }

  getKey() {
    return this.#generateKey();
  }
}

const s = new Secret();
console.log(s.getKey()); // erlaubt
// s.#generateKey(); ‚ùå SyntaxError
```

---

## 5. Zusammenfassung der Sichtbarkeiten

| Typ                    | Syntax      | Zugriff von au√üen m√∂glich? | Anmerkung      |
| ---------------------- | ----------- | -------------------------- | -------------- |
| √ñffentlich             | `this.prop` | ‚úÖ ja                       | Standard       |
| Gesch√ºtzt (Konvention) | `_prop`     | ‚úÖ ja                       | Nur Stilfrage  |
| Privat                 | `#prop`     | ‚ùå nein                     | ES2020, strikt |

---

**Zusammenfassung:**

* **Vererbung**: `extends` + `super` f√ºr Konstruktor und Methoden.
* **Gesch√ºtzt**: nur Konvention (`_name`), kein echter Schutz.
* **Privat**: mit `#`, ab ES2020 ‚Üí strikter Zugriffsschutz.
* Sinnvoll f√ºr **Datenkapselung** und saubere OOP-Architektur in JavaScript.

üìñ Quelle: [MDN Web Docs ‚Äî Classes](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes), [Private class features](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes/Private_class_fields)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

93. ### <a name="93"></a> Kapselung (Encapsulation)

**Kapselung (Encapsulation) in JavaScript**

---

## 1. Definition

* **Kapselung** = Prinzip der **Objektorientierten Programmierung (OOP)**, das Daten (Eigenschaften) und Methoden in einer Einheit (**Klasse/Objekt**) zusammenfasst.
* Ziel: **Daten vor unbefugtem Zugriff sch√ºtzen** und **nur kontrollierten Zugriff** √ºber Methoden erlauben.

---

## 2. Klassisches Beispiel ohne Kapselung

```js
class User {
  constructor(name, password) {
    this.name = name;
    this.password = password; // √∂ffentlich sichtbar ‚ùå
  }
}

const u = new User("Sergii", "1234");
console.log(u.password); // jeder kann zugreifen ‚ùå
```

---

## 3. Kapselung mit privaten Eigenschaften (`#`, ES2020)

```js
class User {
  #password; // private Eigenschaft

  constructor(name, password) {
    this.name = name;
    this.#password = password;
  }

  checkPassword(pwd) {
    return this.#password === pwd;
  }
}

const u = new User("Sergii", "1234");
console.log(u.name);            // Sergii
console.log(u.#password);       // ‚ùå SyntaxError
console.log(u.checkPassword("1234")); // true ‚úÖ
```

---

## 4. Kapselung mit Getter & Setter

```js
class Account {
  #balance = 0;

  get balance() {
    return this.#balance;
  }

  set balance(amount) {
    if (amount >= 0) {
      this.#balance = amount;
    } else {
      console.error("Ung√ºltiger Wert");
    }
  }
}

const acc = new Account();
acc.balance = 100;          // nutzt Setter
console.log(acc.balance);   // 100 (Getter)
acc.balance = -50;          // Fehler, bleibt 100
```

---

## 5. Kapselung √ºber Closures (√§lterer Ansatz)

Vor ES2020 wurde Kapselung oft mit **Closures** umgesetzt:

```js
function createCounter() {
  let count = 0; // private Variable

  return {
    increment() { count++; },
    get value() { return count; }
  };
}

const counter = createCounter();
counter.increment();
console.log(counter.value); // 1
console.log(counter.count); // undefined ‚ùå
```

---

## 6. Vorteile von Kapselung

* **Datensicherheit**: interne Details verbergen.
* **Kontrolle**: Zugriff nur √ºber definierte Methoden.
* **Wartbarkeit**: klare Schnittstellen.
* **Flexibilit√§t**: interne Implementierung kann sich √§ndern, API bleibt gleich.

---

**Zusammenfassung:**

* **Kapselung** = Daten + Methoden in einer Einheit, Zugriff √ºber kontrollierte Schnittstellen.
* Umsetzung in JS:

  * moderne Syntax: **private Felder `#` + Getter/Setter**,
  * √§ltere Technik: **Closures**.
* Ziel: **Daten sch√ºtzen, Kontrolle erh√∂hen, Code wartbar machen**.

üìñ Quelle: [MDN Web Docs ‚Äî Classes](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes), [Private class fields](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes/Private_class_fields)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

94. ### <a name="94"></a> Was ist funktionale Programmierung? Grundlagen (First-Class-Funktionen, Higher-Order-Funktionen, Pure Functions, Immutability, Lazy Evaluation usw.)

**Funktionale Programmierung (FP) in JavaScript**

---

## 1. Definition

* **Funktionale Programmierung** = Paradigma, das Programme durch **Funktionen** statt durch Zust√§nde und Objekte strukturiert.
* Fokus: **Unver√§nderlichkeit (Immutability)**, **Pure Functions**, **Komposition** und **Deklarativit√§t**.

---

## 2. Grundlagen

### a) First-Class-Funktionen

* Funktionen sind **Werte wie andere auch**: k√∂nnen Variablen zugewiesen, als Argumente √ºbergeben oder zur√ºckgegeben werden.

```js
const greet = (name) => `Hallo, ${name}`;
const say = greet;  
console.log(say("Sergii")); // Hallo, Sergii
```

---

### b) Higher-Order-Funktionen (HOF)

* Funktionen, die andere Funktionen **als Argument nehmen** oder **zur√ºckgeben**.

```js
function higherOrder(fn, value) {
  return fn(value);
}
console.log(higherOrder(x => x * 2, 5)); // 10
```

Beispiele: `map`, `filter`, `reduce`.

---

### c) Pure Functions

* **Pure** = gleiche Eingabe ‚Üí gleiche Ausgabe, **keine Nebenwirkungen** (kein Zugriff auf √§u√üere Zust√§nde).

```js
function add(a, b) {
  return a + b; // pure
}
```

‚ùå Unrein (side-effect):

```js
let counter = 0;
function increment() {
  return ++counter; // ver√§ndert √§u√üeren Zustand
}
```

---

### d) Immutability (Unver√§nderlichkeit)

* Daten sollen **nicht mutiert**, sondern **kopiert und ver√§ndert** werden.

```js
const arr = [1, 2, 3];
const newArr = [...arr, 4]; // Immutability
```

---

### e) Lazy Evaluation

* Werte/Funktionen werden **erst berechnet, wenn sie gebraucht werden**.
* In JS m√∂glich z. B. √ºber Generatoren:

```js
function* numbers() {
  let i = 0;
  while (true) yield i++;
}
const gen = numbers();
console.log(gen.next().value); // 0
console.log(gen.next().value); // 1
```

---

### f) Funktionale Komposition

* Kleine Funktionen kombinieren, um komplexere zu bilden.

```js
const double = x => x * 2;
const square = x => x * x;
const doubleThenSquare = x => square(double(x));

console.log(doubleThenSquare(3)); // 36
```

---

## 3. Vorteile von FP

* Weniger Fehler durch **keine Seiteneffekte**.
* Einfachere Tests (Pure Functions sind vorhersagbar).
* Code wird **deklarativer** statt imperativ.

---

## 4. Praxis in JavaScript

* Array-Methoden: `map`, `filter`, `reduce`.
* Nutzung von **Promises** und **async/await** (keine manuelle Nebenwirkungskontrolle).
* Bibliotheken: **Lodash/fp, Ramda**.

---

**Zusammenfassung:**

* **Funktionale Programmierung** basiert auf **Funktionen als Werte**, **Pure Functions**, **Unver√§nderlichkeit** und **Komposition**.
* In JS unterst√ºtzt durch **First-Class Functions**, **Higher-Order Functions**, **Array-Methoden** und **Generatoren (Lazy Evaluation)**.
* Ziel: **vorhersagbarer, testbarer, deklarativer Code**.

üìñ Quelle: [MDN Web Docs ‚Äî First-class functions](https://developer.mozilla.org/ru/docs/Glossary/First-class_Function), [MDN Web Docs ‚Äî Functional programming](https://developer.mozilla.org/en-US/docs/Glossary/Functional_programming)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

95. ### <a name="95"></a> Regul√§re Ausdr√ºcke (RegExp)

**Regul√§re Ausdr√ºcke (RegExp) in JavaScript**

Ein **Regul√§rer Ausdruck** ist ein Muster, das f√ºr die Suche, das Ersetzen oder die Validierung von Strings verwendet wird. In JavaScript werden RegExps mit **`/muster/flags`** oder mit dem **`RegExp`-Konstruktor** erstellt.

---

### Erzeugung

```js
// Literal-Notation
const regex1 = /abc/;

// Mit Konstruktor
const regex2 = new RegExp('abc');
```

---

### Wichtige Flags

* **g** ‚Üí global (alle Treffer, nicht nur der erste)
* **i** ‚Üí ignore case (Gro√ü-/Kleinschreibung ignorieren)
* **m** ‚Üí multiline (^ und \$ funktionieren zeilenweise)
* **s** ‚Üí dotAll (Punkt `.` matcht auch Zeilenumbr√ºche)
* **u** ‚Üí Unicode (korrekt mit Unicode-Zeichen arbeiten)
* **y** ‚Üí sticky (Treffer muss an der aktuellen Position starten)

---

### Grundlegende Metazeichen

* `.` ‚Üí beliebiges Zeichen (au√üer Zeilenumbruch)
* `^` ‚Üí Anfang des Strings
* `$` ‚Üí Ende des Strings
* `\d` ‚Üí Ziffer \[0-9]
* `\w` ‚Üí Wortzeichen \[A-Za-z0-9\_]
* `\s` ‚Üí Whitespace (Leerzeichen, Tab, Zeilenumbruch)
* `+` ‚Üí ein oder mehr
* `*` ‚Üí null oder mehr
* `?` ‚Üí optional (null oder eins)
* `{n,m}` ‚Üí mindestens n, h√∂chstens m Wiederholungen
* `|` ‚Üí oder

---

### Methoden f√ºr Strings

```js
const text = "Hallo 123 Welt";

// Suche (true/false)
console.log(/123/.test(text)); // true

// Finde erstes Match
console.log(text.match(/\d+/)); 
// ["123"]

// Alle Matches (mit Flag g)
console.log(text.match(/\d+/g)); 
// ["123"]

// Ersetzen
console.log(text.replace(/\d+/, "XYZ")); 
// "Hallo XYZ Welt"

// Split
console.log(text.split(/\s+/)); 
// ["Hallo", "123", "Welt"]
```

---

### Methoden f√ºr RegExp

```js
const regex = /\d+/g;
const str = "Preis: 20‚Ç¨, Rabatt: 5‚Ç¨";

let match;
while ((match = regex.exec(str)) !== null) {
  console.log(match[0]); 
  // "20", dann "5"
}
```

---

### Beispiel: E-Mail-Validierung

```js
const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

console.log(emailRegex.test("test@example.com")); // true
console.log(emailRegex.test("falsche-mail"));     // false
```

---

**Zusammenfassung:**
RegExps in JavaScript sind Muster, die mit `/pattern/flags` oder `new RegExp()` erstellt werden. Sie werden f√ºr Suche, Ersetzung und Validierung in Strings genutzt. Zentrale Methoden sind `test()`, `match()`, `replace()`, `split()` und `exec()`. Flags steuern das Verhalten (z. B. `g`, `i`, `m`).

üìñ Quelle: [MDN Web Docs ‚Äî RegExp](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/RegExp)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

96. ### <a name="96"></a> JSON

**JSON (JavaScript Object Notation)**

---

## 1. Definition

* **JSON** = leichtgewichtiges **Datenformat** zur Speicherung und zum Austausch von Informationen.
* Abgeleitet von JavaScript-Objekt-Literalen, aber **sprachunabh√§ngig**.
* H√§ufig f√ºr **API-Kommunikation** (Client ‚Üî Server).

---

## 2. Syntax

* Nur **Datenstruktur**, kein Code.
* Werte: `string`, `number`, `boolean`, `null`, `object`, `array`.
* **Strings immer in doppelten Anf√ºhrungszeichen `"`**.
* Keine Funktionen, `undefined` oder Kommentare erlaubt.

```json
{
  "name": "Sergii",
  "age": 30,
  "isDeveloper": true,
  "skills": ["JavaScript", "React", "Node.js"],
  "address": { "city": "Leipzig", "country": "Germany" },
  "partner": null
}
```

---

## 3. JSON in JavaScript

### a) Objekt ‚Üí JSON (Serialisierung)

```js
const user = { name: "Sergii", age: 30 };
const jsonString = JSON.stringify(user);
console.log(jsonString); // '{"name":"Sergii","age":30}'
```

### b) JSON ‚Üí Objekt (Parsing)

```js
const str = '{"name":"Sergii","age":30}';
const obj = JSON.parse(str);
console.log(obj.name); // Sergii
```

---

## 4. Optionen bei `JSON.stringify`

```js
const user = { name: "Sergii", age: 30, password: "secret" };

console.log(JSON.stringify(user, ["name", "age"])); 
// nur bestimmte Felder: {"name":"Sergii","age":30}

console.log(JSON.stringify(user, null, 2));
// sch√∂n formatiert mit Einr√ºckung
```

---

## 5. JSON vs. JS-Objekt

| Merkmal   | JSON                         | JavaScript-Objekt           |
| --------- | ---------------------------- | --------------------------- |
| Format    | String                       | Struktur im Speicher        |
| Schl√ºssel | nur in `"` erlaubt           | ohne oder mit `"`           |
| Werte     | keine Funktionen/`undefined` | Funktionen, Symbole m√∂glich |
| Nutzung   | Datenaustausch               | Laufzeit-Code               |

---

## 6. Typische Anwendungsf√§lle

* API-Response/Request (REST, GraphQL).
* Speicherung (z. B. `localStorage`).
* Konfigurationsdateien (`package.json`).

---

**Zusammenfassung:**

* **JSON** = textbasiertes Format f√ºr Datenaustausch.
* Umwandlung: `JSON.stringify()` (Objekt ‚Üí String), `JSON.parse()` (String ‚Üí Objekt).
* Einschr√§nkung: keine Funktionen, nur Standarddatentypen.
* Sehr verbreitet in **Web-APIs, Configs, Storage**.

üìñ Quelle: [MDN Web Docs ‚Äî JSON](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/JSON)

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

97. ### <a name="97"></a> Design-Patterns in JavaScript (Singleton, Factory, Observer, etc.)

**Design-Patterns in JavaScript (kurzer Spickzettel + Beispiele, ESM)**

---

### 1) Singleton

* Genau **eine** Instanz im gesamten Programm.

```js
// config.js
export class Config { constructor() { this.env = "prod"; } }
const instance = new Config();
export default instance;

// usage.js
import config from "./config.js";
console.log(config.env);
```

**Wann?** Gemeinsamer Zustand/Service (z. B. Logger, Config).

---

### 2) Factory (Fabrikfunktion)

* Erzeugt Objekte, kapselt Erstellungslogik/Varianten.

```js
// factory.js
export const createUser = ({ role, name }) => {
  const base = { name, say: () => `${name}` };
  if (role === "admin") return { ...base, canDelete: true };
  return { ...base, canDelete: false };
};

// usage.js
import { createUser } from "./factory.js";
console.log(createUser({ role: "admin", name: "Sergii" }).canDelete); // true
```

**Wann?** Unterschiedliche Typen/Varianten hinter einheitlicher API.

---

### 3) Observer (Publish‚ÄìSubscribe)

* Publisher benachrichtigt Abonnenten √ºber Events.

```js
// eventBus.js
export class EventBus {
  #m = new Map();
  on(type, fn) { (this.#m.get(type) ?? this.#m.set(type, new Set()).get(type)).add(fn); }
  off(type, fn) { this.#m.get(type)?.delete(fn); }
  emit(type, payload) { this.#m.get(type)?.forEach(fn => fn(payload)); }
}

// usage.js
import { EventBus } from "./eventBus.js";
const bus = new EventBus();
const sub = (msg) => console.log("got:", msg);
bus.on("chat", sub);
bus.emit("chat", "Hallo"); // got: Hallo
bus.off("chat", sub);
```

**Wann?** Entkopplung UI ‚Üî Daten, Cross-Komponenten-Events.

---

### 4) Strategy

* Austauschbare Algorithmen √ºber einheitliches Interface.

```js
// strategies.js
export const strategies = {
  sum: (a,b) => a+b,
  mul: (a,b) => a*b,
};
export const calc = (s, a, b) => strategies[s](a,b);

// usage.js
import { calc } from "./strategies.js";
console.log(calc("mul", 3, 4)); // 12
```

**Wann?** Zur Laufzeit w√§hlbare Regeln/Heuristiken.

---

### 5) Decorator (Funktions-/Objekt-Dekorateur)

* F√ºgt Verhalten hinzu, ohne Original zu √§ndern.

```js
// decorator.js
export const withTiming = (fn) => async (...args) => {
  const t0 = performance.now(); const r = await fn(...args);
  console.log(`took ${Math.round(performance.now()-t0)}ms`); return r;
};

// usage.js
import { withTiming } from "./decorator.js";
const fetchJson = async (u) => (await fetch(u)).json();
const timed = withTiming(fetchJson);
timed("https://jsonplaceholder.typicode.com/todos/1");
```

**Wann?** Logging, Caching, Retry, Metriken.

---

### 6) Module / Revealing Module

* Kapselt Implementierung, gibt nur API frei (ESM bevorzugt).

```js
// counter.js
let count = 0;                         // gekapselt
const inc = () => ++count;
const value = () => count;
export { inc, value };                 // ‚Äûrevealing‚Äú
```

**Wann?** Klare √∂ffentliche API, interne Details verstecken.

---

### 7) Proxy (Strukturelles Pattern)

* F√§ngt Zugriffe ab (Validierung, Lazy-Load, Virtualisierung).

```js
// guarded.js
const target = { age: 0 };
export default new Proxy(target, {
  set(obj, prop, val) {
    if (prop === "age" && (val < 0 || !Number.isInteger(val))) throw new TypeError("invalid age");
    return Reflect.set(obj, prop, val);
  }
});

// usage.js
import guarded from "./guarded.js";
guarded.age = 33; // ok
// guarded.age = -1; // throws
```

**Wann?** Validierung, Zugriffskontrolle, Tracing.

---

### 8) Adapter

* Passt inkompatible Schnittstellen an.

```js
// legacy and adapter
export const legacyFetchUser = (id, cb) => setTimeout(() => cb(null, { id, n: "Sergii" }), 0);
export const getUser = (id) => new Promise((res, rej) =>
  legacyFetchUser(id, (err, data) => err ? rej(err) : res({ id: data.id, name: data.n }))
);

// usage.js
import { getUser } from "./adapter.js";
getUser(1).then(console.log); // { id: 1, name: "Sergii" }
```

**Wann?** Alte APIs in neue konsumierbare Form bringen (Promise/ESM).

---

### 9) Command (optional, UI-Aktionen r√ºckg√§ngig machen)

* Verpackt Aktionen als Objekte (undo/redo).

```js
// command.js
export class History {
  #stack=[]; #undo=[];
  exec(cmd){ cmd.do(); this.#stack.push(cmd); this.#undo.length=0; }
  undo(){ const c=this.#stack.pop(); c?.undo(); this.#undo.push(c); }
}
export const setTextCmd = (el, next) => {
  const prev = el.textContent;
  return { do(){ el.textContent = next; }, undo(){ el.textContent = prev; } };
};
```

**Wann?** Undo/Redo, Makros.

---

## Hinweise & Best Practices

* In modernen Projekten **ES-Module** nutzen (klare Kapselung, Tree-Shaking).
* **Observer** in Browsern oft mit nativen Events/`EventTarget` umsetzbar.
* **Proxy** sparsam einsetzen (Overhead), gezielt f√ºr Validierung/Tracing.
* **Decorator/Factory** sind sehr interview-relevant in React/Node-Kontext.

---

**Zusammenfassung**

* **Erzeugung**: *Singleton, Factory*.
* **Strukturell**: *Module, Proxy, Adapter*.
* **Verhalten**: *Observer, Strategy, Decorator, Command*.
* Alle Beispiele zeigen **ESM** und fokussieren auf **Kapselung, Austauschbarkeit, Entkopplung**.

üìñ Quellen (MDN, RU):

* –ú–æ–¥—É–ª–∏ `import`/`export`: [https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/import](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/import)
* –ö–ª–∞—Å—Å—ã/–Ω–∞—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ (f√ºr OOP-Beispiele): [https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes)
* Proxy/Reflect: [https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global\_Objects/Proxy](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Proxy)
* EventTarget/–°–æ–±—ã—Ç–∏—è (f√ºr Observer/Events): [https://developer.mozilla.org/ru/docs/Web/API/EventTarget](https://developer.mozilla.org/ru/docs/Web/API/EventTarget)
* –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å/–º–æ–¥—É–ª–∏ (Allg. ESM-Praxis): [https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Modules](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Modules)

**Zusammenfassung**
Design-Patterns strukturieren JS-Code: **Singleton/Factory** erzeugen Objekte, **Module/Proxy/Adapter** formen Schnittstellen, **Observer/Strategy/Decorator/Command** steuern Verhalten. ESM erleichtert **Kapselung** und **Wiederverwendung**.


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

98. ### <a name="98"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

99. ### <a name="99"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

100. ### <a name="100"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**

101. ### <a name="101"></a> Erstellen von Tabs in einem Projekt

### **Erstellen von Tabs in JavaScript**  

Tabs sind eine h√§ufige UI-Komponente, um Inhalte **in verschiedene Bereiche zu unterteilen**.  
Hier zeige ich eine **einfache, moderne** Methode, um Tabs mit **JavaScript, HTML und CSS** zu erstellen.

---

## **1. HTML-Grundstruktur**
```html
<div class="tabs">
  <button class="tab-button active" data-tab="1">Tab 1</button>
  <button class="tab-button" data-tab="2">Tab 2</button>
  <button class="tab-button" data-tab="3">Tab 3</button>
</div>

<div class="tab-content active" id="tab-1">
  <p>Inhalt f√ºr Tab 1</p>
</div>
<div class="tab-content" id="tab-2">
  <p>Inhalt f√ºr Tab 2</p>
</div>
<div class="tab-content" id="tab-3">
  <p>Inhalt f√ºr Tab 3</p>
</div>
```
‚úÖ **`data-tab="1"` f√ºr Zuordnung von Tabs zu Inhalten**  
‚úÖ **`active`-Klasse f√ºr das aktuell sichtbare Tab**  

---

## **2. CSS-Styling**
```css
.tabs {
  display: flex;
  gap: 10px;
}

.tab-button {
  padding: 10px;
  border: none;
  background: lightgray;
  cursor: pointer;
}

.tab-button.active {
  background: blue;
  color: white;
}

.tab-content {
  display: none;
  padding: 10px;
  border: 1px solid #ccc;
  margin-top: 10px;
}

.tab-content.active {
  display: block;
}
```
‚úÖ **Nur der aktive Tab ist sichtbar (`display: block`)**  
‚úÖ **Visuelle Hervorhebung des aktiven Buttons (`background: blue`)**  

---

## **3. JavaScript f√ºr die Tab-Funktionalit√§t**
```javascript
document.addEventListener("DOMContentLoaded", () => {
  const buttons = document.querySelectorAll(".tab-button");
  const contents = document.querySelectorAll(".tab-content");

  buttons.forEach((button) => {
    button.addEventListener("click", () => {
      // Entferne `active` von allen Buttons und Inhalten
      buttons.forEach((btn) => btn.classList.remove("active"));
      contents.forEach((content) => content.classList.remove("active"));

      // Aktiviere den geklickten Tab
      button.classList.add("active");
      document.getElementById(`tab-${button.dataset.tab}`).classList.add("active");
    });
  });
});
```
‚úÖ **Event-Listener f√ºr alle Buttons**  
‚úÖ **Wechselt die `active`-Klasse f√ºr den geklickten Tab**  
‚úÖ **Verwendet `dataset.tab`, um Inhalt zuzuordnen (`data-tab="1" ‚Üí id="tab-1"`)**  

---

### **Fazit**
‚úî **Einfach & modern mit JavaScript, HTML & CSS**  
‚úî **Ohne externe Bibliotheken**  
‚úî **Kann leicht erweitert oder gestylt werden**  

---
---
Hier ist die **einfache Tabs-Implementierung** mit Beschreibung **auf Deutsch**:

```html
<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <title>Einfache Tabs</title>
  <style>
    .tabs { max-width: 400px; margin: 2rem auto; font-family: sans-serif; }
    .tab-buttons { display: flex; gap: .5rem; margin-bottom: 1rem; }
    .tab-buttons button {
      padding: .5rem 1rem;
      border: 1px solid #ccc;
      background: #f5f5f5;
      cursor: pointer;
    }
    .tab-buttons button.active { background: #0ea5e9; color: white; }
    .tab-content { border: 1px solid #ccc; padding: 1rem; }
    .tab-panel { display: none; }
    .tab-panel.active { display: block; }
  </style>
</head>
<body>
  <div class="tabs">
    <div class="tab-buttons">
      <button data-tab="1" class="active">Tab 1</button>
      <button data-tab="2">Tab 2</button>
      <button data-tab="3">Tab 3</button>
    </div>

    <div class="tab-content">
      <div id="tab-1" class="tab-panel active">Inhalt von Tab 1</div>
      <div id="tab-2" class="tab-panel">Inhalt von Tab 2</div>
      <div id="tab-3" class="tab-panel">Inhalt von Tab 3</div>
    </div>
  </div>

  <script>
    // Alle Buttons und Panels ausw√§hlen
    const buttons = document.querySelectorAll('.tab-buttons button');
    const panels = document.querySelectorAll('.tab-panel');

    buttons.forEach(button => {
      button.addEventListener('click', () => {
        const tabId = button.dataset.tab;

        // Zuerst alle aktiven Zust√§nde entfernen
        buttons.forEach(b => b.classList.remove('active'));
        panels.forEach(p => p.classList.remove('active'));

        // Geklickten Button + zugeh√∂riges Panel aktivieren
        button.classList.add('active');
        document.getElementById('tab-' + tabId).classList.add('active');
      });
    });
  </script>
</body>
</html>
```

---

### Erkl√§rung auf Deutsch

1. **Daten-Attribut (`data-tab`)**
   Jeder Button besitzt ein `data-tab="nummer"`.
   Damit wissen wir, zu welchem Panel er geh√∂rt.

2. **ID-Zuordnung**
   Jedes Panel hat ein `id="tab-nummer"`, sodass die Verbindung klar ist.

3. **Event-Listener**
   Beim Klick:

   * Entfernen wir √ºberall die Klasse `active`.
   * Aktivieren Button und Panel mit derselben Nummer.

4. **CSS**

   * Panels sind standardm√§√üig `display: none`.
   * Das aktive Panel (`.active`) wird sichtbar.
   * Aktiver Button wird farbig hervorgehoben.

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**  

102. ### <a name="102"></a> Countdown-Timer

### **Countdown-Timer in JavaScript**  

Ein **Countdown-Timer** kann in vielen Anwendungen verwendet werden, z. B. f√ºr **Veranstaltungen, Werbeaktionen oder Online-Tests**.  
Hier zeige ich eine **dynamische L√∂sung mit JavaScript, HTML & CSS**.

---

## **1. HTML-Grundstruktur**
```html
<div class="timer">
  <h2>Countdown:</h2>
  <div id="countdown">
    <span id="days">00</span> Tage 
    <span id="hours">00</span> Stunden 
    <span id="minutes">00</span> Minuten 
    <span id="seconds">00</span> Sekunden
  </div>
</div>
```
‚úÖ **Zeigt Tage, Stunden, Minuten & Sekunden an**  

---

## **2. CSS-Styling (optional)**
```css
.timer {
  font-family: Arial, sans-serif;
  text-align: center;
  font-size: 24px;
  background: #222;
  color: white;
  padding: 20px;
  border-radius: 10px;
}

#countdown span {
  font-weight: bold;
  font-size: 30px;
  margin: 0 5px;
}
```
‚úÖ **Macht den Timer √ºbersichtlicher & modern**  

---

## **3. JavaScript f√ºr den Countdown-Timer**
```javascript
function startCountdown(endTime) {
  function updateTimer() {
    const now = new Date().getTime();
    const distance = endTime - now;

    if (distance <= 0) {
      clearInterval(timerInterval);
      document.getElementById("countdown").innerHTML = "Zeit abgelaufen!";
      return;
    }

    const days = Math.floor(distance / (1000 * 60 * 60 * 24));
    const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
    const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
    const seconds = Math.floor((distance % (1000 * 60)) / 1000);

    document.getElementById("days").textContent = days.toString().padStart(2, "0");
    document.getElementById("hours").textContent = hours.toString().padStart(2, "0");
    document.getElementById("minutes").textContent = minutes.toString().padStart(2, "0");
    document.getElementById("seconds").textContent = seconds.toString().padStart(2, "0");
  }

  updateTimer();
  const timerInterval = setInterval(updateTimer, 1000);
}

// Countdown auf ein zuk√ºnftiges Datum setzen (z. B. Neujahr)
const countdownDate = new Date("December 31, 2024 23:59:59").getTime();
startCountdown(countdownDate);
```

‚úÖ **Berechnet die verbleibende Zeit bis zum `countdownDate`**  
‚úÖ **Aktualisiert den Timer jede Sekunde (`setInterval`)**  
‚úÖ **Zeigt `"Zeit abgelaufen!"`, wenn die Zeit vorbei ist**  

---

### **Erweiterungen**
üîπ **Live-Anpassung des Enddatums?** ‚Äì √úber ein Eingabefeld setzen  
üîπ **Animationen hinzuf√ºgen?** ‚Äì `fade-in` Effekt f√ºr Sekunden  
üîπ **Ton abspielen?** ‚Äì Sound beim Ablauf des Countdowns  

---
---
## Timer

```html
<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <title>Countdown in Tagen</title>
  <style>
    body { font-family: sans-serif; text-align: center; margin-top: 50px; }
    #timer { font-size: 2rem; font-weight: bold; }
  </style>
</head>
<body>
  <h1>Countdown bis Ziel-Datum</h1>
  <div id="timer"></div>

  <script>
    // Ziel-Datum einstellen (z. B. 31. Dezember 2025 um 23:59)
    const targetDate = new Date("2025-12-31T23:59:00");

    const timerEl = document.getElementById("timer");

    function updateTimer() {
      const now = new Date();
      const remaining = targetDate - now;

      if (remaining <= 0) {
        timerEl.textContent = "Zeit abgelaufen!";
        clearInterval(intervalId);
        return;
      }

      // Umrechnung in Tage, Stunden, Minuten, Sekunden
      const days    = Math.floor(remaining / (1000 * 60 * 60 * 24));
      const hours   = Math.floor((remaining / (1000 * 60 * 60)) % 24);
      const minutes = Math.floor((remaining / (1000 * 60)) % 60);
      const seconds = Math.floor((remaining / 1000) % 60);

      timerEl.textContent =
        days + "d " +
        String(hours).padStart(2, "0") + "h " +
        String(minutes).padStart(2, "0") + "m " +
        String(seconds).padStart(2, "0") + "s";
    }

    // Sofort starten
    updateTimer();
    // Jede Sekunde aktualisieren
    const intervalId = setInterval(updateTimer, 1000);
  </script>
</body>
</html>
```
---

### Erkl√§rung auf Deutsch

1. **Ziel-Datum festlegen**
   Im Code wird ein Datum definiert, z. B.

   ```js
   const targetDate = new Date("2025-12-31T23:59:00");
   ```

   Dieses Datum ist der Zeitpunkt, bis wann der Countdown l√§uft.

2. **Differenz berechnen**
   Mit `targetDate - now` wird die verbleibende Zeit in Millisekunden berechnet.

3. **Umwandlung in Tage, Stunden, Minuten, Sekunden**

   * Tage: `Math.floor(remaining / (1000 * 60 * 60 * 24))`
   * Stunden: `(remaining / (1000 * 60 * 60)) % 24`
   * Minuten: `(remaining / (1000 * 60)) % 60`
   * Sekunden: `(remaining / 1000) % 60`

4. **Anzeige formatieren**
   Das Ergebnis wird als `Xd XXh XXm XXs` im HTML-Element angezeigt.
   Beispiel: `10d 05h 23m 09s`.

5. **Aktualisierung jede Sekunde**
   Mit `setInterval(updateTimer, 1000)` wird der Countdown alle 1000 ms neu berechnet.

6. **Abbruch**
   Sobald das Ziel-Datum erreicht oder √ºberschritten ist (`remaining <= 0`),

   * wird `"Zeit abgelaufen!"` angezeigt,
   * und der Timer mit `clearInterval` gestoppt.

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

103. ### <a name="103"></a> Modales Fenster

### **Modales Fenster (Modal) in JavaScript**  

Ein **modales Fenster** ist eine UI-Komponente, die sich √ºber den Inhalt legt und Benutzeraktionen erfordert (z. B. Best√§tigungen oder Formulareingaben).  
Hier erstellen wir ein **eigenes modales Fenster mit HTML, CSS & JavaScript**.

---

## **1. HTML-Struktur**
```html
<button id="openModal">√ñffne Modal</button>

<div id="modal" class="modal">
  <div class="modal-content">
    <span class="close">&times;</span>
    <h2>Modales Fenster</h2>
    <p>Dies ist ein Beispiel f√ºr ein modales Fenster.</p>
  </div>
</div>
```
‚úÖ **Das Modal ist anfangs unsichtbar und wird durch den Button ge√∂ffnet**  
‚úÖ **Das `span.close`-Element schlie√üt das Modal**  

---

## **2. CSS-Styling**
```css
/* Modal-Hintergrund */
.modal {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
  justify-content: center;
  align-items: center;
}

/* Modal-Inhalt */
.modal-content {
  background: white;
  padding: 20px;
  border-radius: 10px;
  width: 300px;
  text-align: center;
  position: relative;
}

/* Schlie√üen-Button */
.close {
  position: absolute;
  top: 10px;
  right: 15px;
  font-size: 24px;
  cursor: pointer;
}
```
‚úÖ **Das `modal` ist `display: none`, bis es aktiviert wird**  
‚úÖ **Der `close`-Button schlie√üt das Modal**  
‚úÖ **Hintergrund wird abgedunkelt (`rgba(0, 0, 0, 0.5)`)**  

---

## **3. JavaScript f√ºr Modal-Funktionalit√§t**
```javascript
document.addEventListener("DOMContentLoaded", () => {
  const modal = document.getElementById("modal");
  const openBtn = document.getElementById("openModal");
  const closeBtn = document.querySelector(".close");

  // √ñffne das Modal
  openBtn.addEventListener("click", () => {
    modal.style.display = "flex";
  });

  // Schlie√üe das Modal
  closeBtn.addEventListener("click", () => {
    modal.style.display = "none";
  });

  // Schlie√üen beim Klicken au√üerhalb des Modal-Inhalts
  window.addEventListener("click", (event) => {
    if (event.target === modal) {
      modal.style.display = "none";
    }
  });
});
```
‚úÖ **`click`-Event √∂ffnet & schlie√üt das Modal**  
‚úÖ **Modal wird geschlossen, wenn man auf den dunklen Hintergrund klickt**  
‚úÖ **`window.addEventListener("click", ...)` sorgt f√ºr benutzerfreundliches Schlie√üen**  

---

### **Erweiterungen**
üîπ **Animationen (`opacity`, `transform`) f√ºr sanfte √úberg√§nge hinzuf√ºgen**  
üîπ **Tastatursteuerung (`ESC`-Taste zum Schlie√üen)**  
üîπ **Mehrere Modals in einer Seite verwalten**  

---
---
## Modal Fenster
---
## Beispiel: Modales Fenster

```html
<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <title>Einfaches Modal</title>
  <style>
    body { font-family: sans-serif; text-align: center; margin-top: 50px; }

    /* Hintergrund (Overlay) */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.6);
      display: none;
      justify-content: center;
      align-items: center;
    }

    /* Modalfenster */
    .modal {
      background: white;
      padding: 2rem;
      border-radius: 10px;
      width: 300px;
      max-width: 80%;
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
      text-align: left;
      position: relative;
    }

    .modal h2 { margin-top: 0; }
    .modal button { margin-top: 1rem; }

    /* Button zum Schlie√üen (oben rechts) */
    .close-btn {
      position: absolute;
      top: .5rem;
      right: .5rem;
      background: transparent;
      border: none;
      font-size: 1.2rem;
      cursor: pointer;
    }

    /* Sichtbar machen */
    .show { display: flex; }
  </style>
</head>
<body>
  <h1>Beispiel: Modales Fenster</h1>
  <button id="openModal">Modal √∂ffnen</button>

  <!-- Overlay + Modal -->
  <div id="overlay" class="modal-overlay">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
      <button class="close-btn" id="closeModal">&times;</button>
      <h2 id="modalTitle">Hallo!</h2>
      <p>Dies ist ein einfaches modales Fenster.</p>
      <button id="okBtn">OK</button>
    </div>
  </div>

  <script>
    const overlay = document.getElementById("overlay");
    const openBtn = document.getElementById("openModal");
    const closeBtn = document.getElementById("closeModal");
    const okBtn = document.getElementById("okBtn");

    // Modal √∂ffnen
    openBtn.addEventListener("click", () => {
      overlay.classList.add("show");
    });

    // Modal schlie√üen (X oder OK)
    closeBtn.addEventListener("click", () => {
      overlay.classList.remove("show");
    });
    okBtn.addEventListener("click", () => {
      overlay.classList.remove("show");
    });

    // Schlie√üen beim Klick auf Overlay
    overlay.addEventListener("click", (e) => {
      if (e.target === overlay) {
        overlay.classList.remove("show");
      }
    });

    // Schlie√üen mit Escape-Taste
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape") {
        overlay.classList.remove("show");
      }
    });
  </script>
</body>
</html>
```
---

### Erkl√§rung auf Deutsch

1. **HTML-Struktur**

   * Ein Button, um das Modal zu √∂ffnen.
   * Ein `div.overlay` (halbtransparenter Hintergrund).
   * Darin ein `div.modal` mit Inhalt.

2. **CSS**

   * Overlay ist standardm√§√üig `display: none`.
   * Mit `.show` wird es sichtbar (`display: flex`).
   * Das Modal selbst ist mittig und hat Schatten/Radius.

3. **JavaScript**

   * `overlay.classList.add("show")` ‚Üí Modal sichtbar machen.
   * `overlay.classList.remove("show")` ‚Üí Modal schlie√üen.
   * Schlie√üen funktioniert √ºber:

     * Klick auf X,
     * Klick auf OK,
     * Klick neben das Modal (auf Overlay),
     * Escape-Taste.

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

104. ### <a name="104"></a> Slider

### **Bild-Slider (Karussell) in JavaScript**  

Ein **Slider** (Karussell) zeigt mehrere Bilder oder Inhalte **nacheinander**, oft mit Steuerungselementen (Pfeile, Punkte).  
Hier erstellen wir einen **einfachen und modernen Slider mit HTML, CSS & JavaScript**.

---

## **1. HTML-Struktur**
```html
<div class="slider">
  <div class="slider-container">
    <div class="slide active"><img src="image1.jpg" alt="Bild 1"></div>
    <div class="slide"><img src="image2.jpg" alt="Bild 2"></div>
    <div class="slide"><img src="image3.jpg" alt="Bild 3"></div>
  </div>

  <button id="prev" class="slider-btn">&#10094;</button>
  <button id="next" class="slider-btn">&#10095;</button>
</div>
```
‚úÖ **Bilder werden in `.slider-container` platziert**  
‚úÖ **Vorw√§rts-/R√ºckw√§rtsbuttons mit `id="prev"` & `id="next"`**  

---

## **2. CSS-Styling**
```css
.slider {
  position: relative;
  max-width: 600px;
  margin: auto;
  overflow: hidden;
}

.slider-container {
  display: flex;
  transition: transform 0.5s ease-in-out;
}

.slide {
  min-width: 100%;
  transition: opacity 0.5s;
}

img {
  width: 100%;
  display: block;
}

.slider-btn {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  background: rgba(0, 0, 0, 0.5);
  color: white;
  border: none;
  padding: 10px;
  cursor: pointer;
}

#prev { left: 10px; }
#next { right: 10px; }
```
‚úÖ **Slider bewegt sich mit `flexbox` & `transform: translateX()`**  
‚úÖ **Buttons √ºberlagern das Bild f√ºr Navigation**  

---

## **3. JavaScript f√ºr Slider-Funktionalit√§t**
```javascript
document.addEventListener("DOMContentLoaded", () => {
  const slides = document.querySelectorAll(".slide");
  let index = 0;

  function showSlide(i) {
    slides.forEach((slide, idx) => {
      slide.style.display = idx === i ? "block" : "none";
    });
  }

  document.getElementById("prev").addEventListener("click", () => {
    index = (index - 1 + slides.length) % slides.length;
    showSlide(index);
  });

  document.getElementById("next").addEventListener("click", () => {
    index = (index + 1) % slides.length;
    showSlide(index);
  });

  showSlide(index);
});
```
‚úÖ **Funktion `showSlide(i)` zeigt nur ein Bild gleichzeitig**  
‚úÖ **Navigation mit `prev` / `next`-Buttons**  
‚úÖ **Runde Logik: Letztes Bild ‚Üí Erstes Bild und umgekehrt**  

---

## **4. Automatischer Slider (`setInterval`)**
üìå **L√§sst den Slider alle 3 Sekunden automatisch wechseln**
```javascript
setInterval(() => {
  index = (index + 1) % slides.length;
  showSlide(index);
}, 3000);
```
‚úÖ **Verhindert, dass der Nutzer klicken muss**  

---

### **Erweiterungen**
üîπ **Mit `transform: translateX()` f√ºr fl√ºssige Animationen**  
üîπ **Pagination (Punkte unter den Bildern zum Wechseln)**  
üîπ **Swipe-Funktion f√ºr mobile Ger√§te (`touchstart`, `touchend`)**  

---
---
## Slider
---

## Beispiel: Bild-Slider

```html
<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <title>Bild-Slider</title>
  <style>
    body { font-family: sans-serif; text-align: center; margin-top: 30px; }

    .slider {
      position: relative;
      width: 600px;
      max-width: 90%;
      margin: auto;
      overflow: hidden;
      border-radius: 10px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }

    .slides {
      display: flex;
      transition: transform 0.5s ease-in-out;
    }

    .slides img {
      width: 100%;
      border-radius: 10px;
      flex-shrink: 0;
    }

    /* Navigation Buttons */
    .prev, .next {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      background: rgba(0,0,0,0.5);
      color: white;
      border: none;
      padding: 10px;
      cursor: pointer;
      font-size: 20px;
      border-radius: 50%;
    }
    .prev { left: 10px; }
    .next { right: 10px; }

    /* Punkte (Indikatoren) */
    .dots {
      text-align: center;
      margin-top: 10px;
    }
    .dots span {
      display: inline-block;
      width: 12px;
      height: 12px;
      margin: 5px;
      background: #ccc;
      border-radius: 50%;
      cursor: pointer;
    }
    .dots .active { background: #0ea5e9; }
  </style>
</head>
<body>
  <h1>Bild-Slider (Karussell)</h1>

  <div class="slider">
    <div class="slides">
      <img src="https://picsum.photos/id/1015/600/300" alt="Bild 1">
      <img src="https://picsum.photos/id/1025/600/300" alt="Bild 2">
      <img src="https://picsum.photos/id/1035/600/300" alt="Bild 3">
    </div>
    <button class="prev">&#10094;</button>
    <button class="next">&#10095;</button>
  </div>

  <div class="dots"></div>

  <script>
    const slides = document.querySelector('.slides');
    const images = document.querySelectorAll('.slides img');
    const prevBtn = document.querySelector('.prev');
    const nextBtn = document.querySelector('.next');
    const dotsContainer = document.querySelector('.dots');

    let index = 0;

    // Punkte dynamisch erstellen
    images.forEach((_, i) => {
      const dot = document.createElement('span');
      if (i === 0) dot.classList.add('active');
      dot.addEventListener('click', () => goToSlide(i));
      dotsContainer.appendChild(dot);
    });
    const dots = document.querySelectorAll('.dots span');

    function showSlide(i) {
      if (i < 0) index = images.length - 1;
      else if (i >= images.length) index = 0;
      else index = i;

      slides.style.transform = `translateX(${-index * 100}%)`;

      dots.forEach(d => d.classList.remove('active'));
      dots[index].classList.add('active');
    }

    function nextSlide() { showSlide(index + 1); }
    function prevSlide() { showSlide(index - 1); }
    function goToSlide(i) { showSlide(i); }

    nextBtn.addEventListener('click', nextSlide);
    prevBtn.addEventListener('click', prevSlide);

    // Auto-Slide alle 4 Sekunden
    setInterval(nextSlide, 4000);
  </script>
</body>
</html>
```

---

### Erkl√§rung auf Deutsch

1. **HTML-Struktur**

   * `div.slider` enth√§lt alle Bilder (`.slides`).
   * Buttons links/rechts f√ºr Navigation.
   * Punkte (`.dots`) f√ºr direkte Auswahl.

2. **CSS**

   * `display: flex` f√ºr Bilder in einer Reihe.
   * `transform: translateX()` verschiebt die Bilder.
   * Buttons und Punkte mit Styling f√ºr Usability.

3. **JavaScript**

   * Index (`let index = 0`) bestimmt, welches Bild sichtbar ist.
   * Funktion `showSlide(i)` aktualisiert Position und Punkte.
   * Buttons (`prev/next`) rufen `showSlide` auf.
   * Punkte (`dots`) sind klickbar ‚Üí springen direkt zu einem Bild.
   * `setInterval` f√ºr automatisches Wechseln alle 4 Sekunden.

---

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

105. ### <a name="105"></a> Rechner

### **Einfacher Rechner in JavaScript**  

Hier erstellen wir einen **einfachen Taschenrechner** mit **HTML, CSS & JavaScript**, der die Grundrechenarten (`+`, `-`, `*`, `/`) unterst√ºtzt.

---

## **1. HTML-Struktur**
```html
<div class="calculator">
  <input type="text" id="display" disabled />
  <div class="buttons">
    <button class="btn" data-value="7">7</button>
    <button class="btn" data-value="8">8</button>
    <button class="btn" data-value="9">9</button>
    <button class="btn" data-value="/">√∑</button>

    <button class="btn" data-value="4">4</button>
    <button class="btn" data-value="5">5</button>
    <button class="btn" data-value="6">6</button>
    <button class="btn" data-value="*">√ó</button>

    <button class="btn" data-value="1">1</button>
    <button class="btn" data-value="2">2</button>
    <button class="btn" data-value="3">3</button>
    <button class="btn" data-value="-">‚àí</button>

    <button class="btn" data-value="0">0</button>
    <button class="btn" data-value=".">.</button>
    <button class="btn clear" data-value="C">C</button>
    <button class="btn" data-value="+">+</button>

    <button class="btn equal" data-value="=">=</button>
  </div>
</div>
```
‚úÖ **`<input>` als Display f√ºr die Berechnung**  
‚úÖ **Buttons f√ºr Zahlen & Operatoren mit `data-value`**  

---

## **2. CSS-Styling**
```css
.calculator {
  width: 250px;
  margin: 50px auto;
  padding: 10px;
  background: #222;
  color: white;
  border-radius: 10px;
  text-align: center;
}

#display {
  width: 100%;
  height: 50px;
  font-size: 24px;
  text-align: right;
  padding: 10px;
  border: none;
  background: #333;
  color: white;
}

.buttons {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 5px;
  margin-top: 10px;
}

.btn {
  padding: 15px;
  font-size: 20px;
  border: none;
  background: #444;
  color: white;
  cursor: pointer;
  border-radius: 5px;
}

.btn:hover {
  background: #666;
}

.equal {
  grid-column: span 4;
  background: #f39c12;
}

.clear {
  background: #e74c3c;
}
```
‚úÖ **Raster-Layout mit `grid-template-columns`**  
‚úÖ **Buttons mit `hover`-Effekt & Highlight-Farben f√ºr `=` & `C`**  

---

## **3. JavaScript f√ºr die Taschenrechner-Funktionalit√§t**
```javascript
document.addEventListener("DOMContentLoaded", () => {
  const display = document.getElementById("display");
  const buttons = document.querySelectorAll(".btn");

  buttons.forEach(button => {
    button.addEventListener("click", () => {
      const value = button.dataset.value;

      if (value === "=") {
        try {
          display.value = eval(display.value); // Berechnung
        } catch {
          display.value = "Fehler";
        }
      } else if (value === "C") {
        display.value = ""; // Reset
      } else {
        display.value += value; // Zahlen & Operatoren hinzuf√ºgen
      }
    });
  });
});
```
‚úÖ **`eval()` berechnet den Ausdruck (z. B. `3+5*2`)**  
‚úÖ **Fehlermeldung bei ung√ºltiger Eingabe (`try...catch`)**  
‚úÖ **`C` l√∂scht das Eingabefeld**  

---

## **4. Erweiterungen**
üîπ **Ersetze `eval()` mit `Function()` f√ºr mehr Sicherheit**  
üîπ **Unterst√ºtzung f√ºr `Backspace` (`‚Üê` l√∂schen letzte Zahl)**  
üîπ **Dunkler/heller Modus mit CSS-Variablen**  

  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

106. ### <a name="106"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

107. ### <a name="107"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

108. ### <a name="108"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

109. ### <a name="109"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

110. ### <a name="110"></a> Zusammenfassung JavaScript

### **Grundlagen (–û—Å–Ω–æ–≤en)**

#### **Was ist JavaScript und wof√ºr wird es verwendet?**  
JavaScript ist eine Programmiersprache, die zur Erstellung interaktiver Webseiten verwendet wird. Sie erm√∂glicht die Manipulation des DOM, die Verarbeitung von Ereignissen, die Arbeit mit APIs und die Ausf√ºhrung asynchroner Operationen.

#### **Was ist der Unterschied zwischen let, const und var?**  
- `var`: Hat Function Scope, kann √ºberschrieben und erneut deklariert werden.  
- `let`: Hat Block Scope, kann √ºberschrieben, aber nicht erneut deklariert werden.  
- `const`: Hat Block Scope, kann nicht √ºberschrieben oder erneut deklariert werden.  

```js
var x = 10;  // Kann √ºberschrieben und erneut deklariert werden
let y = 20;  // Kann √ºberschrieben, aber nicht erneut deklariert werden
const z = 30; // Kann nicht ge√§ndert werden
```

#### **Was sind primitive Datentypen in JavaScript?**  
Primitive Datentypen:  
1. `string`  
2. `number`  
3. `boolean`  
4. `null`  
5. `undefined`  
6. `bigint`  
7. `symbol`  

#### **Was bedeutet "dynamische Typisierung" in JavaScript?**  
JavaScript bestimmt den Typ einer Variablen automatisch zur Laufzeit.  

```js
let a = 5;  // number
a = "Hallo"; // jetzt string
```

#### **Was ist der Unterschied zwischen == und ===?**  
- `==` ‚Äì lockerer Vergleich (Konvertiert Typen).  
- `===` ‚Äì strikter Vergleich (Ber√ºcksichtigt Typen).  

```js
console.log(5 == "5");  // true
console.log(5 === "5"); // false
```

#### **Wie funktioniert typeof und welche Werte kann es zur√ºckgeben?**  
`typeof` gibt den Datentyp eines Werts zur√ºck.  

```js
console.log(typeof 42); // "number"
console.log(typeof "hallo"); // "string"
console.log(typeof null); // "object" (JS-Fehler)
console.log(typeof undefined); // "undefined"
```

#### **Was sind Falsy- und Truthy-Werte in JavaScript?**  
Falsy-Werte: `false, 0, "", null, undefined, NaN`  
Truthy-Werte: Alle anderen Werte.  

```js
if ("hallo") console.log("Truthy"); // Wird ausgef√ºhrt
if (0) console.log("Falsy"); // Wird nicht ausgef√ºhrt
```

#### **Wie funktioniert Type Coercion in JavaScript?**  
JS wandelt Typen automatisch um.  

```js
console.log(5 + "5"); // "55" (number -> string)
console.log("5" - 2); // 3 (string -> number)
console.log(true + 1); // 2 (true -> 1)
```

#### **Was sind die Hauptunterschiede zwischen null und undefined?**  
- `null`: Wert ist explizit gesetzt.  
- `undefined`: Wert wurde nicht zugewiesen.  

```js
let a;  // undefined
let b = null; // null
```

#### **Wie werden Objekte in JavaScript erstellt?**  
1. **Mit Objektliteralen:**  
   ```js
   let obj = { name: "John", alter: 30 };
   ```
2. **Mit `new Object()`:**  
   ```js
   let obj = new Object();
   obj.name = "John";
   ```
3. **Mit einer Konstruktorfunktion:**  
   ```js
   function Person(name) {
       this.name = name;
   }
   let user = new Person("Alice");
   ```
---

### **Funktionen & Closures**

#### **Was sind Higher-Order Functions in JavaScript?**  
Funktionen, die andere Funktionen als Argumente akzeptieren oder Funktionen zur√ºckgeben.  

```js
function hof(callback) {
    return callback(5);
}
console.log(hof(x => x * 2)); // 10
```

#### **Was ist eine Closure und wie funktioniert sie?**  
Eine Closure ist eine Funktion, die sich den Scope merkt, in dem sie erstellt wurde.  

```js
function outer() {
    let count = 0;
    return function inner() {
        count++;
        console.log(count);
    };
}
const counter = outer();
counter(); // 1
counter(); // 2
```

#### **Was bedeutet "IIFE" (Immediately Invoked Function Expression)?**  
Eine sofort ausgef√ºhrte Funktion.  

```js
(function() {
    console.log("Hallo!");
})(); 
```

#### **Was ist der Unterschied zwischen einer normalen Funktion und einer Arrow-Funktion?**  
- **Normale Funktion:** Hat ihr eigenes `this`.  
- **Arrow-Funktion:** Hat kein eigenes `this`, sondern √ºbernimmt es aus dem √§u√üeren Kontext.  

```js
const obj = {
    value: 10,
    func: function() { console.log(this.value); }, // 10
    arrow: () => { console.log(this.value); } // undefined
};
obj.func();
obj.arrow();
```

#### **Was sind Callback-Funktionen und wann werden sie verwendet?**  
Funktionen, die als Argument an andere Funktionen √ºbergeben werden. Wird oft in asynchronem Code verwendet.  

```js
function fetchData(callback) {
    setTimeout(() => {
        callback("Daten geladen");
    }, 1000);
}
fetchData(console.log);
```

#### **Wie funktioniert this in JavaScript?**  
`this` h√§ngt vom Aufrufkontext ab.  

```js
const obj = {
    name: "John",
    sayHi() { console.log(this.name); }
};
obj.sayHi(); // "John"
```

#### **Was sind Funktionsdeklaration und Funktionsausdruck?**  
- **Function Declaration:** Kann vor der Deklaration aufgerufen werden.  
- **Function Expression:** Kann nicht vor der Deklaration aufgerufen werden.  

```js
sayHi(); // Funktioniert
function sayHi() { console.log("Hallo"); }

// Funktioniert nicht:
// sayHello(); 
const sayHello = function() { console.log("Hi"); };
```

#### **Wie funktioniert bind(), call() und apply()?**  
- **`call()`** Ruft eine Funktion mit √ºbergebenem `this` und Argumenten nacheinander auf.  
- **`apply()`** Dasselbe, aber Argumente werden als Array √ºbergeben.  
- **`bind()`** Erstellt eine neue Funktion mit festgelegtem `this`.  

```js
function greet(greeting) {
    console.log(greeting + ", " + this.name);
}

const user = { name: "Alice" };

greet.call(user, "Hi");  // "Hi, Alice"
greet.apply(user, ["Hallo"]); // "Hallo, Alice"
const boundGreet = greet.bind(user, "Hey");
boundGreet(); // "Hey, Alice"
```

#### **Was ist Currying in JavaScript?**  
Umwandlung einer Funktion mit mehreren Argumenten in eine Kette von Aufrufen.  

```js
function curry(a) {
    return function(b) {
        return function(c) {
            return a + b + c;
        };
    };
}
console.log(curry(1)(2)(3)); // 6
```

#### **Was ist Rekursion und wie kann sie in JavaScript verwendet werden?**  
Rekursion ist eine Funktion, die sich selbst aufruft.  

```js
function factorial(n) {
    return n === 1 ? 1 : n * factorial(n - 1);
}
console.log(factorial(5)); // 120
```

### **ES6+ Features**

#### **Was ist Destructuring in JavaScript?**  
Destructuring erm√∂glicht es, Werte aus Arrays oder Objekten zu extrahieren und in Variablen zu speichern.  

```js
const person = { name: "John", age: 30 };
const { name, age } = person;
console.log(name, age); // "John", 30

const arr = [1, 2, 3];
const [a, b, c] = arr;
console.log(a, b, c); // 1, 2, 3
```

---

#### **Wie funktioniert der Spread-Operator (...)?**  
Der Spread-Operator `...` erweitert Arrays oder Objekte.  

```js
const numbers = [1, 2, 3];
const newNumbers = [...numbers, 4, 5];
console.log(newNumbers); // [1, 2, 3, 4, 5]

const obj = { a: 1, b: 2 };
const newObj = { ...obj, c: 3 };
console.log(newObj); // { a: 1, b: 2, c: 3 }
```

---

#### **Was ist der Unterschied zwischen map(), filter() und reduce()?**  
- **`map()`**: Erstellt ein neues Array durch Transformation der Werte.  
- **`filter()`**: Erstellt ein neues Array mit Werten, die eine Bedingung erf√ºllen.  
- **`reduce()`**: Reduziert ein Array auf einen einzigen Wert.  

```js
const numbers = [1, 2, 3, 4];

const doubled = numbers.map(num => num * 2); // [2, 4, 6, 8]
const even = numbers.filter(num => num % 2 === 0); // [2, 4]
const sum = numbers.reduce((acc, num) => acc + num, 0); // 10
```

---

#### **Was ist ein Template Literal und warum ist es n√ºtzlich?**  
Template Literals (`` ` ` ``) erlauben mehrzeilige Strings und Variablen-Einbindung.  

```js
const name = "Alice";
console.log(`Hallo, mein Name ist ${name}.`);
```

---

#### **Was sind Default Parameter in JavaScript?**  
Default Parameter setzen Standardwerte f√ºr Funktionsargumente.  

```js
function greet(name = "Gast") {
    console.log(`Hallo, ${name}`);
}
greet(); // "Hallo, Gast"
```

---

#### **Was sind Set und Map in JavaScript?**  
- **`Set`**: Speichert einzigartige Werte.  
- **`Map`**: Speichert Schl√ºssel-Wert-Paare.  

```js
const set = new Set([1, 2, 2, 3]);
console.log(set); // Set {1, 2, 3}

const map = new Map();
map.set("key", "value");
console.log(map.get("key")); // "value"
```

---

#### **Was ist Symbol in JavaScript?**  
Ein `Symbol` ist ein einzigartiger und unver√§nderlicher Wert.  

```js
const sym = Symbol("id");
console.log(sym); // Symbol(id)
```

---

#### **Was ist der Unterschied zwischen forEach() und map()?**  
- **`forEach()`** f√ºhrt eine Funktion f√ºr jedes Element aus, gibt aber kein neues Array zur√ºck.  
- **`map()`** gibt ein neues Array mit ver√§nderten Werten zur√ºck.  

```js
const arr = [1, 2, 3];

arr.forEach(num => console.log(num * 2)); // Gibt Werte aus, ver√§ndert aber nicht das Array
const newArr = arr.map(num => num * 2); // Gibt neues Array zur√ºck
console.log(newArr); // [2, 4, 6]
```

---

#### **Wie funktionieren Generators in JavaScript?**  
Ein Generator ist eine spezielle Funktion, die `yield` verwendet und ihren Zustand speichert.  

```js
function* generator() {
    yield 1;
    yield 2;
    yield 3;
}
const gen = generator();
console.log(gen.next().value); // 1
console.log(gen.next().value); // 2
```

---

#### **Was ist das Konzept der "Rest Parameter" (...args)?**  
Rest-Parameter sammeln mehrere Argumente in einem Array.  

```js
function sum(...nums) {
    return nums.reduce((acc, num) => acc + num, 0);
}
console.log(sum(1, 2, 3, 4)); // 10
```

---

### **Asynchrones JavaScript & Promises**

#### **Was sind Promises und wie funktionieren sie?**  
Ein `Promise` repr√§sentiert eine asynchrone Operation.  

```js
const promise = new Promise((resolve, reject) => {
    setTimeout(() => resolve("Daten geladen"), 1000);
});
promise.then(data => console.log(data));
```

---

#### **Was ist der Unterschied zwischen async und await?**  
`async/await` vereinfacht das Arbeiten mit Promises.  

```js
async function fetchData() {
    return "Daten geladen";
}
fetchData().then(console.log);
```

---

#### **Wie behandelt man Fehler in async/await?**  
Mit `try...catch`.  

```js
async function fetchData() {
    try {
        let data = await Promise.reject("Fehler!");
    } catch (error) {
        console.log(error);
    }
}
fetchData();
```

---

#### **Was ist das Event Loop in JavaScript?**  
Die Event Loop verwaltet asynchrone Operationen.  

```js
console.log("Start");
setTimeout(() => console.log("Timeout"), 0);
console.log("End");

// Ausgabe:
// Start
// End
// Timeout
```

---

#### **Was ist der Unterschied zwischen setTimeout() und setInterval()?**  
- `setTimeout()`: F√ºhrt eine Funktion einmal nach einer Verz√∂gerung aus.  
- `setInterval()`: F√ºhrt eine Funktion wiederholt aus.  

```js
setTimeout(() => console.log("Einmal"), 1000);
setInterval(() => console.log("Wiederholt"), 1000);
```

---

#### **Was sind Web APIs und warum sind sie wichtig f√ºr asynchrones JavaScript?**  
Web APIs (z.B. `fetch()`, `localStorage`) erm√∂glichen Interaktion mit dem Browser.  

```js
console.log(navigator.userAgent); // Gibt Browser-Informationen aus
```

---

#### **Wie funktioniert die Fetch-API in JavaScript?**  
`fetch()` erm√∂glicht HTTP-Anfragen.  

```js
fetch("https://jsonplaceholder.typicode.com/todos/1")
    .then(response => response.json())
    .then(data => console.log(data));
```

---

#### **Was ist der Unterschied zwischen XMLHttpRequest und fetch()?**  
- `XMLHttpRequest`: Alte API, komplexer.  
- `fetch()`: Neuer, moderner Ansatz.  

```js
// Mit XMLHttpRequest
const xhr = new XMLHttpRequest();
xhr.open("GET", "https://jsonplaceholder.typicode.com/todos/1");
xhr.onload = () => console.log(xhr.response);
xhr.send();

// Mit fetch()
fetch("https://jsonplaceholder.typicode.com/todos/1")
    .then(response => response.json())
    .then(data => console.log(data));
```

---

#### **Was sind Microtasks und Macrotasks in JavaScript?**  
- **Microtasks** (`Promise.then()`, `queueMicrotask()`) haben h√∂here Priorit√§t.  
- **Macrotasks** (`setTimeout()`, `setInterval()`) werden sp√§ter ausgef√ºhrt.  

```js
console.log("Start");

setTimeout(() => console.log("Macrotask"), 0);
Promise.resolve().then(() => console.log("Microtask"));

console.log("End");

// Ausgabe:
// Start
// End
// Microtask
// Macrotask
```

---

#### **Was ist Promise.all(), Promise.race() und Promise.allSettled()?**  
- **`Promise.all()`**: Wartet auf alle Promises.  
- **`Promise.race()`**: Gibt das erste abgeschlossene Promise zur√ºck.  
- **`Promise.allSettled()`**: Wartet auf alle, gibt Status zur√ºck.  

```js
const p1 = Promise.resolve("A");
const p2 = new Promise(res => setTimeout(() => res("B"), 1000));

Promise.all([p1, p2]).then(console.log); // ["A", "B"]
Promise.race([p1, p2]).then(console.log); // "A"
```

### **OOP & Prototypen**

#### **Wie funktioniert das Prototypenmodell in JavaScript?**  
Jedes Objekt in JavaScript hat eine `__proto__`-Eigenschaft, die auf ein anderes Objekt verweist (sein Prototyp). Methoden und Eigenschaften k√∂nnen von Prototypen geerbt werden.

```js
const person = { greet() { console.log("Hallo!"); } };
const user = Object.create(person);
user.greet(); // "Hallo!" (geerbt vom Prototypen)
```

---

#### **Was ist der Unterschied zwischen Klassen und Prototypen?**  
- **Prototypen** sind die urspr√ºngliche Methode zur Vererbung in JS.  
- **Klassen** (`class`) sind syntaktischer Zucker √ºber Prototypen, um OOP-√§hnlichen Code zu schreiben.

```js
// Prototypen
function User(name) {
    this.name = name;
}
User.prototype.sayHello = function() {
    console.log(`Hallo, ${this.name}`);
};
const u1 = new User("Alice");
u1.sayHello();

// Klasse
class UserClass {
    constructor(name) {
        this.name = name;
    }
    sayHello() {
        console.log(`Hallo, ${this.name}`);
    }
}
const u2 = new UserClass("Bob");
u2.sayHello();
```

---

#### **Wie erstellt man eine Klasse in JavaScript?**  
Mit `class` und einem `constructor`.  

```js
class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
}
const user = new Person("Alice", 25);
console.log(user.name); // "Alice"
```

---

#### **Was bedeutet `super` in JavaScript?**  
`super` ruft die Methoden oder den Konstruktor der Elternklasse auf.  

```js
class Parent {
    constructor(name) {
        this.name = name;
    }
}
class Child extends Parent {
    constructor(name, age) {
        super(name); // Ruft den Parent-Konstruktor auf
        this.age = age;
    }
}
const c = new Child("Tom", 10);
console.log(c.name, c.age); // "Tom", 10
```

---

#### **Was sind Getter und Setter in JavaScript?**  
Getter und Setter erm√∂glichen kontrollierten Zugriff auf Objekt-Eigenschaften.  

```js
class Person {
    constructor(name) {
        this._name = name;
    }
    get name() {
        return this._name.toUpperCase();
    }
    set name(value) {
        this._name = value;
    }
}
const user = new Person("Alice");
console.log(user.name); // "ALICE"
user.name = "Bob";
console.log(user.name); // "BOB"
```

---

#### **Was ist der Unterschied zwischen Object.create() und Klasseninstanzen?**  
- **`Object.create(proto)`** erstellt ein Objekt mit einem bestimmten Prototypen.  
- **Klasseninstanzen (`new Class()`)** erstellen Objekte mit eigener Logik.  

```js
const proto = { greet() { console.log("Hallo!"); } };
const obj = Object.create(proto);
obj.greet(); // "Hallo!"
```

---

#### **Wie funktioniert Vererbung in JavaScript?**  
Mit `extends` f√ºr Klassen oder Prototypen.  

```js
class Animal {
    speak() { console.log("Ger√§usch!"); }
}
class Dog extends Animal {
    speak() { console.log("Wuff!"); }
}
const d = new Dog();
d.speak(); // "Wuff!"
```

---

#### **Was ist Polymorphismus in JavaScript?**  
Eine Methode kann in verschiedenen Klassen unterschiedlich implementiert werden.  

```js
class Shape {
    draw() { console.log("Zeichne eine Form"); }
}
class Circle extends Shape {
    draw() { console.log("Zeichne einen Kreis"); }
}
const s = new Circle();
s.draw(); // "Zeichne einen Kreis"
```

---

#### **Was ist der Unterschied zwischen einer Factory Function und einer Constructor Function?**  
- **Factory Function** gibt ein Objekt zur√ºck.  
- **Constructor Function** wird mit `new` aufgerufen.  

```js
// Factory Function
function createUser(name) {
    return { name, greet() { console.log(`Hallo, ${name}`); } };
}
const user1 = createUser("Alice");
user1.greet();

// Constructor Function
function User(name) {
    this.name = name;
    this.greet = function() { console.log(`Hallo, ${this.name}`); };
}
const user2 = new User("Bob");
user2.greet();
```

---

#### **Was bedeutet "Encapsulation" in JavaScript?**  
Encapsulation versteckt interne Details einer Klasse.  

```js
class Person {
    #privateField = "Geheim";
    
    getSecret() {
        return this.#privateField;
    }
}
const p = new Person();
console.log(p.getSecret()); // "Geheim"
```

---

### **DOM-Manipulation & Events**

#### **Wie w√§hlt man ein Element mit JavaScript aus?**  
```js
document.getElementById("id");
document.querySelector(".class");
document.querySelectorAll("div");
```

---

#### **Was ist der Unterschied zwischen innerHTML und textContent?**  
- `innerHTML` enth√§lt HTML-Tags.  
- `textContent` enth√§lt nur Text.  

```js
document.getElementById("test").innerHTML = "<b>Fett</b>";
document.getElementById("test").textContent = "<b>Kein HTML</b>";
```

---

#### **Wie f√ºgt man ein Event Listener zu einem Element hinzu?**  
```js
document.getElementById("btn").addEventListener("click", () => alert("Geklickt!"));
```

---

#### **Was ist Event Bubbling und Event Capturing?**  
- **Bubbling**: Ereignis steigt von unten nach oben.  
- **Capturing**: Ereignis geht von oben nach unten.  

```js
document.body.addEventListener("click", () => console.log("Body"), true);
document.getElementById("child").addEventListener("click", () => console.log("Child"));
```

---

#### **Was bedeutet preventDefault() und stopPropagation()?**  
- **`preventDefault()`** verhindert Standardaktionen (z.B. Link-Klick).  
- **`stopPropagation()`** stoppt Event-Bubbling.  

```js
document.getElementById("link").addEventListener("click", (e) => {
    e.preventDefault(); // Kein Seitenwechsel
});
```

---

#### **Was sind data-attributes und wie kann man sie mit JavaScript auslesen?**  
```html
<div data-id="123"></div>
```

```js
const div = document.querySelector("div");
console.log(div.dataset.id); // "123"
```

---

#### **Wie entfernt man ein Element mit JavaScript?**  
```js
document.getElementById("test").remove();
```

---

#### **Wie erstellt man ein neues DOM-Element mit JavaScript?**  
```js
const el = document.createElement("div");
el.textContent = "Hallo!";
document.body.appendChild(el);
```

---

#### **Wie funktioniert debounce() und throttle() f√ºr Event Listener?**  
- **Debounce**: Verz√∂gert die Ausf√ºhrung.  
- **Throttle**: Begrenzte Ausf√ºhrung innerhalb eines Zeitraums.  

```js
function debounce(func, delay) {
    let timeout;
    return function(...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func(...args), delay);
    };
}
```

---

#### **Was sind MutationObserver und IntersectionObserver?**  
- **MutationObserver** √ºberwacht DOM-√Ñnderungen.  
- **IntersectionObserver** √ºberwacht Element-Sichtbarkeit.  

```js
const observer = new MutationObserver(mutations => console.log(mutations));
observer.observe(document.body, { childList: true });

const io = new IntersectionObserver(entries => console.log(entries));
io.observe(document.getElementById("target"));
```

### **Module & Bundling**

#### **Was ist der Unterschied zwischen CommonJS und ES6-Modulen?**  
- **CommonJS (CJS)**: Wird in Node.js verwendet, nutzt `require()` und `module.exports`.  
- **ES6-Module (ESM)**: Wird in modernen Browsern verwendet, nutzt `import` und `export`.  

```js
// CommonJS
const fs = require("fs");

// ES6-Module
import fs from "fs";
```

---

#### **Wie importiert und exportiert man Module in JavaScript?**  

```js
// Named Export
export const sayHello = () => console.log("Hallo");
import { sayHello } from "./module.js";

// Default Export
export default function greet() { console.log("Hallo"); }
import greet from "./module.js";
```

---

#### **Was ist der Unterschied zwischen default export und named export?**  
- **Default Export**: Nur eine Hauptfunktion oder Klasse pro Datei.  
- **Named Export**: Mehrere exportierbare Funktionen oder Variablen.  

```js
export default function() {};  // Import: import x from "./file.js"
export const test = () => {};  // Import: import { test } from "./file.js"
```

---

#### **Was ist Webpack und warum wird es verwendet?**  
Webpack ist ein **Modul-Bundler**, der JavaScript-Dateien zu einer optimierten Datei zusammenfasst.  

```js
// Webpack erm√∂glicht das Importieren von CSS, Bildern etc.
import "./style.css";
```

---

#### **Wie funktioniert Tree Shaking?**  
Nicht genutzter Code wird bei der B√ºndelung entfernt.  

```js
// Unbenutzte Funktion wird entfernt
export function unused() {}
export function used() { console.log("Ich werde genutzt"); }
```

---

#### **Was ist ein Polyfill und wann wird er ben√∂tigt?**  
Ein **Polyfill** f√ºgt neue Funktionen f√ºr alte Browser hinzu.  

```js
import "core-js/stable"; // F√ºgt ES6+ Funktionen f√ºr √§ltere Browser hinzu
```

---

#### **Was ist ein Transpiler (z. B. Babel)?**  
Ein Transpiler konvertiert modernen JavaScript-Code in √§ltere Versionen f√ºr √§ltere Browser.  

```json
// Babel in package.json
"browserslist": "> 0.5%, last 2 versions, not dead"
```

---

#### **Was sind Code-Splitting und Lazy Loading?**  
- **Code-Splitting**: Teilt JavaScript in kleinere Dateien.  
- **Lazy Loading**: L√§dt Code nur bei Bedarf.  

```js
// Lazy Loading mit Dynamic Import
import("./module.js").then(module => module.default());
```

---

#### **Wie funktioniert Dynamic Import (`import()`) in JavaScript?**  
L√§dt Module **dynamisch** zur Laufzeit.  

```js
if (condition) {
    import("./extra.js").then(module => module.default());
}
```

---

#### **Warum ist es wichtig, `defer` und `async` in `<script>`-Tags zu verwenden?**  
- **`async`**: Script wird parallel geladen und sofort ausgef√ºhrt.  
- **`defer`**: Script wird parallel geladen, aber erst nach dem Parsen von HTML ausgef√ºhrt.  

```html
<script src="script.js" defer></script>
```

---

### **Leistung & Optimierung**

#### **Was ist der Unterschied zwischen Call Stack und Memory Heap?**  
- **Call Stack**: H√§lt die Reihenfolge der ausgef√ºhrten Funktionen.  
- **Memory Heap**: Speichert Objekte und Variablen im Speicher.  

```js
function foo() {
    console.log("Start");
}
foo(); // Call Stack: foo -> console.log -> (leert sich)
```

---

#### **Was ist Memory Leak in JavaScript und wie kann man es vermeiden?**  
**Memory Leaks** entstehen, wenn Speicher nicht freigegeben wird.  

```js
let obj = {};
setInterval(() => obj = { data: new Array(1000000) }, 1000); // Leak
```

üí° **Vermeidung:**  
- **Event Listener entfernen** (`removeEventListener()`).  
- **Unn√∂tige globale Variablen vermeiden**.  
- **WeakMap/WeakSet f√ºr Speicheroptimierung nutzen**.

---

#### **Wie funktioniert Garbage Collection in JavaScript?**  
**Garbage Collection** entfernt ungenutzte Objekte aus dem Memory Heap, wenn sie nicht mehr referenziert werden.  

```js
let obj = { name: "Alice" };
obj = null; // Wird von Garbage Collector entfernt
```

---

#### **Was ist der Unterschied zwischen Deep Copy und Shallow Copy?**  
- **Shallow Copy**: Kopiert nur die Referenz auf Objekte.  
- **Deep Copy**: Erstellt eine echte Kopie eines Objekts.  

```js
const obj = { name: "Alice", details: { age: 25 } };
const shallowCopy = { ...obj }; // Shallow Copy
const deepCopy = JSON.parse(JSON.stringify(obj)); // Deep Copy
```

---

#### **Wie kann man die Performance einer JavaScript-Anwendung optimieren?**  
‚úÖ **Minimierung von DOM-Manipulationen**  
‚úÖ **Verwendung von Web Workers f√ºr Hintergrundaufgaben**  
‚úÖ **Debounce und Throttle f√ºr Event-Handling**  
‚úÖ **Bilder optimieren und Lazy Loading nutzen**  
‚úÖ **Caching und lokale Speicherung verwenden (localStorage, IndexedDB)**  

---

#### **Was ist `requestAnimationFrame()` und wann wird es verwendet?**  
`requestAnimationFrame()` sorgt f√ºr **performante Animationen**, die mit der **Bildwiederholrate des Monitors** synchronisiert sind.  

```js
function animate() {
    console.log("Frame update");
    requestAnimationFrame(animate);
}
requestAnimationFrame(animate);
```

---

#### **Was ist der Unterschied zwischen `console.log()` und `console.table()`?**  
- `console.log()` gibt Werte aus.  
- `console.table()` zeigt **Objekte oder Arrays als Tabelle**.  

```js
const users = [{ name: "Alice" }, { name: "Bob" }];
console.table(users);
```

---

#### **Wie kann man asynchrone Funktionen debuggen?**  
‚úÖ `console.log()` innerhalb von `async`-Funktionen nutzen.  
‚úÖ `try...catch` f√ºr Fehlermanagement.  
‚úÖ `debugger;` im Code einf√ºgen und DevTools nutzen.  

```js
async function fetchData() {
    try {
        let response = await fetch("https://jsonplaceholder.typicode.com/posts");
        let data = await response.json();
        console.log(data);
    } catch (error) {
        console.error("Fehler:", error);
    }
}
fetchData();
```

---

#### **Was ist ein Web Worker und wann sollte man ihn verwenden?**  
Ein **Web Worker** f√ºhrt Code in einem separaten Thread aus, um die Haupt-Thread-Performance nicht zu blockieren.  

```js
// worker.js
onmessage = function(e) {
    postMessage(e.data * 2);
};

// main.js
const worker = new Worker("worker.js");
worker.postMessage(10);
worker.onmessage = function(e) {
    console.log(e.data); // 20
};
```

‚úÖ **Verwendung:** F√ºr **CPU-intensive Aufgaben** wie Bildbearbeitung, gro√üe Berechnungen.  

---

#### **Was sind die besten Methoden zur Reduzierung der Reflow/Repaint-Probleme?**  
üöÄ **Vermeidung von h√§ufigen DOM-Manipulationen:**  
- **Mehrere √Ñnderungen in einem einzigen Batch vornehmen**.  
- **CSS-Klassen statt Inline-Styles √§ndern**.  
- **`requestAnimationFrame()` f√ºr Animationen nutzen**.  
- **Grid und Flexbox bevorzugen** (statt `float` oder `position: absolute`).  
- **Vermeiden von `offsetWidth`, `offsetHeight`, da sie Reflow ausl√∂sen**.  

```js
document.body.classList.add("hidden");
```

---

### **Zusammenfassung**  
‚úÖ **Module optimieren (Tree Shaking, Code-Splitting, Lazy Loading)**  
‚úÖ **Speicher effizient verwalten (Garbage Collection, Memory Leaks vermeiden)**  
‚úÖ **Performance steigern (Web Worker, `requestAnimationFrame()`, Debounce/Throttle)**  
‚úÖ **Effiziente Debugging-Techniken nutzen (`console.table()`, DevTools, `debugger`)**  

### **Sonstiges & Best Practices**

#### **Was ist strict mode in JavaScript?**  
Der **Strict Mode** (`"use strict"`) erh√∂ht die Sicherheit von JavaScript, indem er bestimmte unsichere Praktiken verbietet.

```js
"use strict";
x = 10; // Fehler: x ist nicht deklariert
```

---

#### **Warum sollte man `use strict` verwenden?**  
‚úÖ Verhindert das Erstellen globaler Variablen  
‚úÖ Erzwingt saubere Syntax  
‚úÖ Reduziert Sicherheitsrisiken  

---

#### **Was sind JavaScript-Design-Patterns?**  
Wiederverwendbare Muster zur L√∂sung g√§ngiger Probleme. Beispiele:  
- **Singleton** (nur eine Instanz)  
- **Factory Pattern** (Erstellung von Objekten)  
- **Observer Pattern** (Event-basierte Architektur)  

```js
const Singleton = (function() {
    let instance;
    function createInstance() {
        return { name: "Ich bin einzigartig!" };
    }
    return {
        getInstance: function() {
            if (!instance) instance = createInstance();
            return instance;
        }
    };
})();
console.log(Singleton.getInstance());
```

---

#### **Was ist Functional Programming und warum ist es in JavaScript beliebt?**  
Ein Paradigma, das Funktionen als erste Klasse behandelt. Vorteile:  
‚úÖ **Pure Functions** (keine Seiteneffekte)  
‚úÖ **Immutability** (keine Ver√§nderung von Daten)  
‚úÖ **H√∂here Wiederverwendbarkeit**  

```js
const add = (x, y) => x + y;
const multiply = (x, y) => x * y;
console.log(add(2, multiply(3, 4))); // 14
```

---

#### **Was sind WeakMap und WeakSet?**  
- **WeakMap** speichert Schl√ºssel-Wert-Paare, wobei die Schl√ºssel nur Objekte sein k√∂nnen.  
- **WeakSet** speichert nur Objekte.  

üí° **Vorteil:** Verhindert Memory Leaks, da Elemente automatisch gel√∂scht werden, wenn keine Referenz mehr existiert.  

```js
let wm = new WeakMap();
let obj = {};
wm.set(obj, "Wert");
obj = null; // Automatische L√∂schung aus WeakMap
```

---

#### **Was ist Tail Call Optimization in JavaScript?**  
Optimierung rekursiver Funktionen zur Speicherersparnis.

```js
"use strict";
function factorial(n, acc = 1) {
    if (n === 1) return acc;
    return factorial(n - 1, n * acc); // Tail Call
}
console.log(factorial(5)); // 120
```

---

#### **Was ist der Unterschied zwischen einer Callback-Hell und Promises?**  
- **Callback-Hell:** Verschachtelte Callbacks machen Code schwer lesbar.  
- **Promises:** Vereinfachen asynchronen Code.  

```js
// Callback-Hell
fetch("data.json", function(response) {
    parseJSON(response, function(data) {
        processData(data, function(result) {
            console.log(result);
        });
    });
});

// Mit Promises
fetch("data.json")
    .then(response => response.json())
    .then(data => processData(data))
    .then(result => console.log(result));
```

---

#### **Was ist die Bedeutung von NaN in JavaScript?**  
`NaN` (Not a Number) zeigt ung√ºltige numerische Berechnungen an.

```js
console.log(0 / 0); // NaN
console.log(Number.isNaN("abc" / 2)); // true
```

---

#### **Warum sollte man globale Variablen vermeiden?**  
‚ùå Kann zu Namenskonflikten f√ºhren  
‚ùå Erschwert Debugging  
‚ùå Reduziert Modularit√§t  

‚úÖ **Besser:** Lokale Variablen oder `const` und `let` verwenden.

---

#### **Was sind Service Worker und wie funktionieren sie?**  
Ein **Service Worker** erm√∂glicht Offline-Funktionalit√§t und Hintergrundprozesse.

```js
navigator.serviceWorker.register("sw.js");
```

**Nutzen:**  
‚úÖ **Caching** f√ºr Offline-Modus  
‚úÖ **Hintergrundsynchronisation**  

---

### **Sicherheitsfragen**

#### **Was ist Cross-Site Scripting (XSS) und wie kann man es verhindern?**  
XSS erlaubt es Angreifern, sch√§dliches JavaScript in Webseiten einzuf√ºgen.

üîí **Schutzma√ünahmen:**  
‚úÖ **Eingaben escapen/sanitizen**  
‚úÖ **Content Security Policy (CSP) verwenden**  
‚úÖ **Keine ungesicherten `innerHTML`-Manipulationen**  

```js
element.textContent = userInput; // Sicherer als innerHTML
```

---

#### **Was ist CSRF (Cross-Site Request Forgery)?**  
CSRF nutzt Authentifizierungs-Sitzungen aus, um unerw√ºnschte Aktionen im Namen eines Benutzers auszuf√ºhren.

üîí **Schutzma√ünahmen:**  
‚úÖ **CSRF-Tokens verwenden**  
‚úÖ **SameSite-Cookies setzen**  

---

#### **Wie kann man sich gegen SQL-Injection sch√ºtzen?**  
SQL-Injection erlaubt Angreifern, Datenbanken zu manipulieren.

üîí **Schutz:**  
‚úÖ **Prepared Statements verwenden**  
‚úÖ **Eingaben validieren und escapen**  

```sql
SELECT * FROM users WHERE username = ?; 
```

---

#### **Was ist CORS und warum ist es wichtig?**  
CORS (Cross-Origin Resource Sharing) erlaubt oder blockiert Anfragen zwischen unterschiedlichen Urspr√ºngen.

üîí **L√∂sung:**  
‚úÖ Server muss `Access-Control-Allow-Origin` Header setzen.

```js
res.setHeader("Access-Control-Allow-Origin", "*");
```

---

#### **Was ist Content Security Policy (CSP)?**  
CSP verhindert XSS-Angriffe durch Kontrolle, welche Ressourcen geladen werden d√ºrfen.

üîí **Beispiel:**  

```html
<meta http-equiv="Content-Security-Policy" content="default-src 'self'">
```

---

#### **Warum ist `eval()` gef√§hrlich?**  
‚ùå F√ºhrt beliebigen Code aus und kann zu Sicherheitsl√ºcken f√ºhren.  
‚ùå Verlangsamt die Performance.  

üîí **Alternative:** `JSON.parse()`, `Function()`  

```js
// Unsicher:
eval("alert('Gef√§hrlich!')");

// Sicher:
const safeFunction = new Function("return 2 + 2;");
console.log(safeFunction()); // 4
```

---

#### **Wie kann man mit Secure Cookies und HTTPOnly umgehen?**  
- **Secure Cookies**: Werden nur √ºber HTTPS gesendet.  
- **HTTPOnly Cookies**: K√∂nnen nicht von JavaScript gelesen werden.  

üîí **Beispiel-Header:**  

```
Set-Cookie: session=abc123; Secure; HttpOnly; SameSite=Strict
```

---

#### **Was ist Clickjacking und wie kann man es verhindern?**  
Clickjacking manipuliert Benutzer, versteckte Buttons zu klicken.

üîí **Schutz:**  
‚úÖ **X-Frame-Options Header setzen:**  

```
X-Frame-Options: DENY
```

‚úÖ **`frame-ancestors` in CSP verwenden:**  

```
Content-Security-Policy: frame-ancestors 'none';
```

---

#### **Was sind Same-Origin Policy und wie beeinflussen sie Webanwendungen?**  
Die **Same-Origin Policy (SOP)** blockiert Anfragen zwischen verschiedenen Urspr√ºngen.  

‚úÖ **L√∂sung:**  
- CORS aktivieren  
- JSONP f√ºr einfache GET-Anfragen nutzen  

---

#### **Was sind JSON Web Tokens (JWT) und wie werden sie verwendet?**  
JWTs sind sichere, signierte Tokens f√ºr Authentifizierung.

```js
const token = jwt.sign({ userId: 123 }, "secret", { expiresIn: "1h" });
```

‚úÖ **Verwendung:**  
- Sicherer Login  
- API-Authentifizierung  

---

### **Zusammenfassung**  
‚úÖ **Best Practices in JavaScript einhalten**  
‚úÖ **Sicherheitsl√ºcken vermeiden (XSS, CSRF, SQL-Injection)**  
‚úÖ **Web-Performance optimieren**  
‚úÖ **Moderne Technologien wie Service Worker & JWT nutzen**  


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)** 

111. ### <a name="111"></a> 


  **[‚¨Ü –ù–∞–≤–µ—Ä—Ö](#top)**   
